<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-36"><em class="italic"><a id="_idTextAnchor069"/>Chapter 2</em>: Handling UI State with Jetpack ViewModel</h1>
			<p>In this chapter, we will cover one of the most important libraries in Jetpack: <strong class="bold">ViewModel</strong>. In the first section, <em class="italic">Understanding the Jetpack ViewModel</em>, we will explore the concept and usages behind the <strong class="source-inline">ViewModel</strong> architecture component. We will see what it is, why we need it in our apps, and how we can implement one in our Restaurants app, which we started in the previous chapter.</p>
			<p>In the next section, <em class="italic">Defining and handling state with Compose</em>, we will study how state is managed in Compose and exemplify usages of state inside our project. Afterward, in the <em class="italic">Hoisting state in Compose</em> section, we will understand what state hoisting is, why we need to achieve it, and then we will apply it to our app.</p>
			<p>Finally, in the <em class="italic">Recovering from system-initiated process death</em> section, we will cover what a system-initiated process death is, how it occurs, and how essential it is for our applications to be able to recover from it by restoring the previous state details.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the Jetpack ViewModel</li>
				<li>Defining and handling state with Compose</li>
				<li>Hoisting state in Compose</li>
				<li>Recovering from system-initiated process death</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor070"/>Technical requirements</h1>
			<p>When building Compose-based Android projects with Jetpack ViewModel, you usually require your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The Restaurants app code from the previous chapter.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app that we developed in the previous chapter. If you haven't followed the implementation side by side, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_01</strong> directory of this book's GitHub repository and importing the Android project entitled <strong class="source-inline">chapter_1_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_02</strong> folder: </p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app</a>.</p>
			<p>The project coding solution for the Restaurants app that we will develop throughout this chapter can be found in the <strong class="source-inline">chapter_2_restaurants_app</strong> Android project folder, which you can import.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor071"/>Understanding the Jetpack ViewModel</h1>
			<p>While<a id="_idIndexMarker094"/> developing Android applications, you must have heard of the term <strong class="bold">ViewModel</strong>. If you haven't heard of it, then don't worry – this section aims to clearly illustrate what this component represents and why we need it in the first place.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>What is a ViewModel?</li>
				<li>Why do you need ViewModels?</li>
				<li>Introducing Android Jetpack ViewModel</li>
				<li>Implementing your first ViewModel</li>
			</ul>
			<p>Let's start with the first question: what is this <strong class="source-inline">ViewModel</strong> that we keep hearing about in Android?</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor072"/>What is a ViewModel?</h2>
			<p>Initially, the <strong class="source-inline">ViewModel</strong> <a id="_idIndexMarker095"/>was designed to allow developers to persist UI state across configuration changes. In time, the <strong class="source-inline">ViewModel</strong> became a way to also recover from edge cases such as system-initiated process death.</p>
			<p>However, often, Android apps require you to write code that is responsible for getting the data from the server, transforming it, caching it, and then displaying it. To delegate some work, developers <a id="_idIndexMarker096"/>made use of this separate component, which should model the UI (also called the <strong class="bold">View</strong>) – the <em class="italic">ViewModel</em>.</p>
			<p>So, we can perceive a <strong class="source-inline">ViewModel</strong> class as a component that manages and caches the UI's state:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B17788_02_01.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – ViewModel stores the state and receives interactions</p>
			<p>As we can see, <strong class="source-inline">ViewModel</strong> not only handles the UI state and provides it to the UI but also receives user interaction events from <strong class="source-inline">View</strong> and updates the state accordingly. </p>
			<p>In Android, the views are usually represented<a id="_idIndexMarker097"/> by <strong class="bold">UI controllers</strong> such as <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, or <strong class="source-inline">Composable</strong> since they are intended to display the UI data. These components are prone to being recreated when configuration changes occur, so <strong class="source-inline">ViewModel</strong> must find a way to cache and then restore the UI state – more on this in the next section, <em class="italic">Why do you need ViewModels?</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">ViewModel</strong> oversees what data is sent back to the UI controllers and how the UI state reacts to user-generated events. That's why we can call <strong class="source-inline">ViewModel</strong> as a master of the UI controller – since it represents the authority that performs decision-making for UI-related events.</p>
			<p>We can try to<a id="_idIndexMarker098"/> enumerate some core activities that a <strong class="source-inline">ViewModel</strong> should perform. <strong class="source-inline">ViewModel</strong> should be able to do the following:</p>
			<ul>
				<li>Hold, manage, and preserve the entire UI state.</li>
				<li>Request data or reload content from the server or other sources.</li>
				<li>Prepare data to be displayed by applying various transformations (such as map, sort, filter, and so on).</li>
				<li>Accept user interaction events and change the state based on those events.</li>
			</ul>
			<p>Even though you now understand what a <strong class="source-inline">ViewModel</strong> is, you might be wondering, why do we need a separate class that holds the UI state or that prepares data to be displayed? Why can't we do that directly in the UI, in <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, or even inside the Composable? We'll address this question next.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor073"/>Why do you need ViewModels?</h2>
			<p>Imagine that <a id="_idIndexMarker099"/>we put all the state-handling logic inside the UI classes. Following this approach, we may soon add other logic for handling network requests, caching, or any other implementation details – everything will be inside the UI layer.</p>
			<p>Obviously, this is not a great approach. If we do that, we will end up with an <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, or <strong class="source-inline">composable</strong> function that has way too many responsibilities. In other words, our UI components will become bloated with so much code and so many responsibilities, thus making the entire project difficult to maintain, fix, or extend.</p>
			<p><strong class="source-inline">ViewModel</strong> is an architecture component that alleviates these potential issues. By adding <strong class="source-inline">ViewModel</strong> components to our projects, we are taking the first step toward a solid <em class="italic">architecture</em> since we can delegate the responsibilities of a UI controller to components such as <strong class="source-inline">ViewModel</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">ViewModel</strong> should not have a reference to a UI controller and should run independently of it. This reduces coupling between the UI layer and <strong class="source-inline">ViewModel</strong> and allows multiple UI components to reuse the same <strong class="source-inline">ViewModel</strong>.</p>
			<p>Preventing <a id="_idIndexMarker100"/>multiple responsibilities in UI controllers is the cornerstone of a good system architecture since it promotes a very simple principle called <strong class="bold">separation of concerns</strong>. This <a id="_idIndexMarker101"/>principle states that every component/module within our app should have and handle one concern.</p>
			<p>If, in our case, we add the entire application logic inside <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, or <strong class="source-inline">composable</strong>, these components will become huge pieces of code that violate the separation of concerns principle, simply because they know how to do everything: from displaying the UI to getting data and serving their UI states. To alleviate this, we can start implementing ViewModels.</p>
			<p>Next, we'll see how ViewModels are designed in Android.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor074"/>Introducing Android Jetpack ViewModel</h2>
			<p>Creating a <strong class="source-inline">ViewModel</strong> class to <a id="_idIndexMarker102"/>govern the UI state of a <strong class="source-inline">View</strong> is doable and straightforward. We can simply create a separate class and move the corresponding logic there.</p>
			<p>However, as we mentioned previously, UI controllers have their own lifecycle: the <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> objects have their own lifecycles, while composables have a composition cycle. That's why UI controllers are usually fragile and end up being recreated when different events occur, such as a configuration change or a process death. When this happens, any UI state information is lost.</p>
			<p>Moreover, UI controllers usually need to make async calls (to obtain data from the server, for example) that have to be managed correctly. This means that when the system destroys UI controllers (such as by calling <strong class="source-inline">onDestroy()</strong> on an <strong class="source-inline">Activity</strong>), you need to manually interrupt or cancel any pending or ongoing work. Otherwise, your application can leak memory since your UI controller's memory reference cannot be freed up by the system. This is because it's still trying to finish some asynchronous work.</p>
			<p>To preserve the UI state and to manage async work easier, our <strong class="source-inline">ViewModel</strong> class should be able to get around these <em class="italic">downsides</em>. But how?</p>
			<p><strong class="bold">Jetpack ViewModel</strong> comes<a id="_idIndexMarker103"/> to the rescue! Because the Android <strong class="source-inline">ViewModel</strong> is lifecycle aware, this means that it knows how to outlive events such as configuration changes, which are triggered by the user.</p>
			<p>It does that by having a <em class="italic">lifecycle scope</em> tied to the lifecycle of its UI controller. Let's see how the lifecycle of an <strong class="source-inline">Activity</strong> and a <strong class="source-inline">composable</strong> are defined as opposed to the one of <strong class="source-inline">ViewModel</strong>:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B17788_02_02.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The ViewModel's lifecycle in comparison to UI controller's lifecycle</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When the <strong class="source-inline">ViewModel</strong> is used in Compose, it lives by default for as long as the parent <strong class="source-inline">Fragment</strong> or <strong class="source-inline">Activity</strong> does. For the <strong class="source-inline">ViewModel</strong> to live as long as a top-level composable (or screen composable) function does, as shown in the previous diagram, the composable must be used in conjunction with a navigation library. More granular composables can have smaller lifetimes. Don't worry, we will cover the aspect of scoping the lifetime of a ViewModel to the lifetime of a screen composable in <a href="B17788_05_ePub.xhtml#_idTextAnchor147"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Navigation in Compose with Jetpack Navigation</em>.</p>
			<p>When the UI is recreated or recomposed because of such events, the <strong class="source-inline">ViewModel</strong>'s lifecycle awareness allows it to outlive those events and avoid being destroyed, thus allowing the state to be preserved. When the entire lifecycle is finalized, the <strong class="source-inline">ViewModel</strong>'s <strong class="source-inline">onCleared()</strong> method is called to allow you to easily clean up any pending async work.</p>
			<p>Yet one question <a id="_idIndexMarker104"/>arises: how can the Jetpack ViewModel do that?</p>
			<p>By design, the <strong class="source-inline">ViewModel</strong> classes outlive specific instantiations of <strong class="source-inline">LifecycleOwners</strong>. In our case, UI controllers are <strong class="source-inline">LifecycleOwners</strong> since they have a designated lifecycle, and they can be <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> objects.</p>
			<p>To understand how <strong class="source-inline">ViewModel</strong> components are scoped to a specific <strong class="source-inline">Lifecycle</strong>, let's have a look at a traditional way of getting a reference to a <strong class="source-inline">ViewModel</strong> instance:</p>
			<p class="source-code">val vm = ViewModelProvider(this)[MyViewModel::class.java]</p>
			<p>To obtain an instance of <strong class="source-inline">MyViewModel</strong>, we pass a <strong class="source-inline">ViewModelStoreOwner</strong> to the <strong class="source-inline">ViewModelProvider</strong> constructor. We used to get our <strong class="source-inline">ViewModel</strong> like this in <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> classes, so this is a reference to the current <strong class="source-inline">ViewModelStoreOwner</strong>.</p>
			<p>To control the lifetime of the instance of our <strong class="source-inline">MyViewModel</strong>, <strong class="source-inline">ViewModelProvider</strong> needs an instance of <strong class="source-inline">ViewModelStoreOwner</strong> because when it creates an instance of <strong class="source-inline">MyViewModel</strong>, it will link the lifetime of this instance to the lifetime of <strong class="source-inline">ViewModelStoreOwner</strong> – that is, of our <strong class="source-inline">Activity</strong>. </p>
			<p>The <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> components are <strong class="source-inline">LifecycleOwners</strong> with a lifecycle, meaning that every time you get a reference to your <strong class="source-inline">ViewModel</strong>, the object you receive is scoped to the <strong class="source-inline">LifecycleOwner</strong>'s lifecycle. This means that your <strong class="source-inline">ViewModel</strong> remains alive in memory until the <strong class="source-inline">LifecycleOwner</strong>'s lifecycle is finished. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will explain the inner workings of <strong class="source-inline">ViewModel</strong> components and how they are scoped to the lifecycle of a <strong class="source-inline">LifecycleOwner</strong> in more detail in <a href="B17788_12_ePub.xhtml#_idTextAnchor327"><em class="italic">Chapter 12</em></a>, <em class="italic">Exploring the Jetpack Lifecycle Components</em>.</p>
			<p>In Compose, the <strong class="source-inline">ViewModel</strong> objects<a id="_idIndexMarker105"/> are instantiated differently by using a special inline function called <strong class="source-inline">viewModel()</strong>, which abstracts all the boilerplate code that was needed previously.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Optionally, if you need to pass parameters whose values are decided at runtime to your <strong class="source-inline">ViewModel</strong>, you can create and pass a <strong class="source-inline">ViewModelFactory</strong> instance to the <strong class="source-inline">viewModel()</strong> constructor. <strong class="source-inline">ViewModelFactory</strong> is a special class that allows you to control the way your <strong class="source-inline">ViewModel</strong> is instantiated.</p>
			<p>Now that we have provided an overview of how the Android <strong class="source-inline">ViewModel</strong> works, let's create one!</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor075"/>Implementing your first ViewModel</h2>
			<p>It's time to create a <strong class="source-inline">ViewModel</strong> inside<a id="_idIndexMarker106"/> the Restaurants application that we created in the previous chapter. To do this, follow these steps:</p>
			<ol>
				<li>First, create a new file by left-clicking the application package, selecting <strong class="bold">New</strong>, and then selecting <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsViewModel</strong> as the name and select <strong class="bold">File</strong> as the type. Inside the newly created file, add the following code:<p class="source-code">import androidx.lifecycle.ViewModel</p><p class="source-code">class RestaurantsViewModel(): ViewModel() {</p><p class="source-code">   fun getRestaurants() = dummyR<a id="_idTextAnchor076"/>estaurants</p><p class="source-code">}</p></li>
			</ol>
			<p>Our <strong class="source-inline">RestaurantsViewModel</strong> inherits from the <strong class="source-inline">ViewModel</strong> class (previously referenced as the Jetpack ViewModel) that's defined in <strong class="source-inline">androidx.lifecycle.ViewModel</strong>, so it becomes lifecycle aware of the components that instantiate it.</p>
			<p>Moreover, we've added the <strong class="source-inline">getRestaurants()</strong> method to our <strong class="source-inline">ViewModel</strong>, allowing it to be the provider of our <strong class="source-inline">dummyRestaurants</strong> list – a first and shy step toward giving it responsibility for governing the UI state.</p>
			<p>Next, it's time to prepare to instantiate our <strong class="source-inline">RestaurantsViewModel</strong>. In Compose, we can't use the previous syntax for instantiating <strong class="source-inline">ViewModel</strong> objects, so we will use a special and dedicated syntax instead. </p>
			<ol>
				<li value="2">To gain access to<a id="_idIndexMarker107"/> this special syntax, go to the <strong class="source-inline">build.gradle</strong> file in the app module and inside the <strong class="source-inline">dependencies</strong> block, add the ViewModel-Compose dependency:<p class="source-code">dependencies {</p><p class="source-code">      […]</p><p class="source-code">    debugImplementation "androidx.compose.ui:ui-</p><p class="source-code">        tooling:$compose_version"</p><p class="source-code">    <strong class="bold">implementation "androidx.lifecycle:lifecycle-</strong></p><p class="source-code"><strong class="bold">        viewmodel-compose:2.4.1"</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project with its Gradle files. You can do that by clicking on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="3">Going back to the <strong class="source-inline">RestaurantsScreen</strong> file, we want to instantiate our <strong class="source-inline">RestaurantsViewModel</strong> inside our <strong class="source-inline">RestaurantsScreen</strong> composable function. We can do this using the <strong class="source-inline">viewModel()</strong> inline function syntax and specifying the type of <strong class="source-inline">ViewModel</strong> that we expect; that is, <strong class="source-inline">RestaurantsViewModel</strong>:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen() {</p><p class="source-code">   <strong class="bold">val viewModel: RestaurantsViewModel = viewModel()</strong></p><p class="source-code">   LazyColumn( … ) {</p><p class="source-code">       items(<strong class="bold">viewModel.getRestaurants()</strong>) { restaurant-&gt;</p><p class="source-code">             RestaurantItem(restaurant)</p><p class="source-code">  <a id="_idTextAnchor077"/>     }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>Behind the <a id="_idIndexMarker108"/>scenes, the <strong class="source-inline">viewModel()</strong> function gets the default <strong class="source-inline">ViewModelStoreOwner</strong> for our <strong class="source-inline">RestaurantsScreen()</strong> composable. Since we haven't implemented a navigation library, the default <strong class="source-inline">ViewModelStoreOwner</strong> will be the calling parent of our composable – the <strong class="source-inline">MainActivity</strong> component. This means that for now, even though our <strong class="source-inline">RestaurantsViewModel</strong> has been instantiated inside a composable, it will live for as long as our <strong class="source-inline">MainActivity</strong> does.</p>
			<p>In other words, our <strong class="source-inline">RestaurantsViewModel</strong> is scoped to the lifecycle of our <strong class="source-inline">MainActivity</strong>, thereby outliving our <strong class="source-inline">RestaurantsScreens</strong> composable, or any other composable we would pass to the <strong class="source-inline">setContent()</strong> method call from within <strong class="source-inline">MainActivity</strong>.</p>
			<p>To make sure that our <strong class="source-inline">ViewModel</strong> lives for as long as the composable function that needs it does, we will implement a navigation library in <a href="B17788_05_ePub.xhtml#_idTextAnchor147"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Navigation in Compose with Jetpack Navigation</em>.</p>
			<p>We also made sure that we now get the restaurants to be displayed from our <strong class="source-inline">RestaurantsViewModel</strong> by calling <strong class="source-inline">getRestaurants()</strong> on the <strong class="source-inline">viewModel</strong> variable.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">From this point on, on certain older Compose versions, the Compose Preview functionality might not work as expected anymore. As the <strong class="source-inline">RestaurantsScreen</strong> composable now depends on a <strong class="source-inline">RestaurantsViewModel</strong> object, Compose can fail to infer the data that is passed to the previewed composable, thereby not being able to show us the content. That's why directly referencing a <strong class="source-inline">ViewModel</strong> inside your screen composable isn't a good practice. We will fix this in <a href="B17788_08_ePub.xhtml#_idTextAnchor285"><em class="italic">Chapter 8</em></a>, <em class="italic">Getting Started with Clean Architecture in Android</em>. Alternatively, to see any changes in your code, you can just run the application on your emulator or physical device.</p>
			<p>Getting back to <a id="_idIndexMarker109"/>our Restaurants app, we have successfully added a <strong class="source-inline">ViewModel</strong>, yet our <strong class="source-inline">RestaurantsViewModel</strong> doesn't handle any state for our UI. It only sends a hardcoded list of restaurants, which has no state. We envisioned that its purpose is to govern the state of the UI, so let's take a break from <strong class="source-inline">ViewModel</strong> and work on understanding state.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor078"/>Defining and handling state with Compose</h1>
			<p>State and events are <a id="_idIndexMarker110"/>essential to any application since their existence implies that <a id="_idIndexMarker111"/>the UI can change over time as you interact with it. </p>
			<p>In this <a id="_idIndexMarker112"/>section, we will cover the<a id="_idIndexMarker113"/> concept of state and events and then<a id="_idIndexMarker114"/> integrate them into our <a id="_idIndexMarker115"/>Restaurants app.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>Understanding state and events</li>
				<li>Adding state to our Restaurants app</li>
			</ul>
			<p>Let's start by exploring the basic concepts of state and events in Android applications.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor079"/>Understanding state and events</h2>
			<p><strong class="bold">State</strong> represents<a id="_idIndexMarker116"/> a possible form of the UI at a certain point in time. This form can change or mutate. When the user interacts with the UI, an event is created that triggers a change in the state of the UI. So, an <strong class="bold">event</strong> is<a id="_idIndexMarker117"/> represented by different interactions that are initiated by the user that target the app and that consequently cause its state to update.</p>
			<p>In simple terms, state <a id="_idIndexMarker118"/>changes over time because of events. The UI, on the <a id="_idIndexMarker119"/>other hand, should observe the changes within the state<a id="_idIndexMarker120"/> so that it can update accordingly:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B17788_02_03.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – UI update flow</p>
			<p>In Compose, composable functions <a id="_idIndexMarker121"/>are, by default, stateless. That's why, when we tried to use a <strong class="source-inline">TextField</strong> composable in the previous chapter, it didn't present anything to the UI that we typed in with the keyboard. This happened because the composable had no state defined and it didn't get recomposed with the new values that had to be displayed!</p>
			<p>This is why, in Compose, it's our job to define state objects for our composables. With the help of <em class="italic">state</em> objects, we make sure that recomposition is triggered every time a state object's value is changed.</p>
			<p>To make such a <strong class="source-inline">TextField</strong> display the text that we are typing in, remember that we added a <strong class="source-inline">textState</strong> variable. Our <strong class="source-inline">TextField</strong> needed such a state object that holds a <strong class="source-inline">String</strong> value. This value represents the text that's written by us, which can change as we keep on typing:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun NameInput() {</p>
			<p class="source-code">   <strong class="bold">val textState: MutableState&lt;String&gt; =</strong></p>
			<p class="source-code">       <strong class="bold">remember { mutableStateOf("") }</strong></p>
			<p class="source-code">   TextField(…) </p>
			<p class="source-code">}</p>
			<p>Let's have a closer<a id="_idIndexMarker122"/> look at how we defined a state object for our <strong class="source-inline">TextField</strong>:</p>
			<ul>
				<li>First, we created a <a id="_idIndexMarker123"/>variable to hold our state object and made<a id="_idIndexMarker124"/> sure that its value can change over time by making it <strong class="source-inline">MutableState</strong>. We did that by defining a <strong class="source-inline">textState</strong> variable <a id="_idIndexMarker125"/>that is of type <strong class="source-inline">MutableState</strong>, which, in turn, holds data of type <strong class="source-inline">String</strong>.</li>
			</ul>
			<p>At its core, <strong class="source-inline">textState</strong> is a <strong class="source-inline">androidx.compose.runtime.State</strong> object, yet since we want to be able to change its value over time, we directly used a <strong class="source-inline">MutableState</strong> that implements <strong class="source-inline">State</strong>.</p>
			<ul>
				<li>We instantiated <strong class="source-inline">textState</strong> with the <strong class="source-inline">mutableStateOf("")</strong> constructor to create a state object and passed an initial value of the data that it holds: an empty string.</li>
			</ul>
			<p>We also wrapped the <strong class="source-inline">mutableStateOf("")</strong> constructor inside a <strong class="source-inline">remember { }</strong> block. The <strong class="bold">remember</strong> block<a id="_idIndexMarker126"/> allows the state value to be preserved across recompositions. Every time the UI is recomposed because other composables received new data or maybe because of an animation, this state value will be the same because of the <strong class="source-inline">remember</strong> block.</p>
			<p>Now that we've covered how state objects are defined, some questions remain: how can we alter the state to retrigger recomposition and how can we make sure our <strong class="source-inline">TextField</strong> accesses the updated values from our <strong class="source-inline">textState</strong>? Let's add these missing pieces:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun NameInput() {</p>
			<p class="source-code">   val textState = remember { mutableStateOf("")<strong class="bold"> </strong>}</p>
			<p class="source-code">   TextField(</p>
			<p class="source-code">            <strong class="bold">value = textState.value,</strong></p>
			<p class="source-code">            onValueChange = { newValue -&gt;</p>
			<p class="source-code">                <strong class="bold">textState.value = newValue</strong></p>
			<p class="source-code">            },</p>
			<p class="source-code">            label = { Text("Your name") })</p>
			<p class="source-code">}</p>
			<p>Let's have a<a id="_idIndexMarker127"/> closer look at how we wired everything up inside <strong class="source-inline">TextField</strong>:</p>
			<ul>
				<li>For <strong class="source-inline">TextField</strong> to <a id="_idIndexMarker128"/>always have access to the latest value of <a id="_idIndexMarker129"/>the <strong class="source-inline">textState</strong> state object, we obtained the current state value with the <strong class="source-inline">.value</strong> accessor using <strong class="source-inline">textState.value</strong>. Then, we <a id="_idIndexMarker130"/>passed it to the <strong class="source-inline">TextField</strong>'s <strong class="source-inline">value</strong> parameter to display it.</li>
				<li>To change the state value, we made use of the <strong class="source-inline">onValueChange</strong> callback, which can be portrayed as an <em class="italic">event</em>. Inside this callback, we updated the <strong class="source-inline">textState</strong> state value by using the same <strong class="source-inline">.value</strong> accessor and set the new value that was received, called <strong class="source-inline">newValue</strong>. Since we updated a <strong class="source-inline">State</strong> object, the UI should recompose and our <strong class="source-inline">TextField</strong> should render the new input value from the keyboard. This will repeat for as long as we keep on writing.</li>
			</ul>
			<p>Now that we have got the hang of defining and altering state in Compose, it's time to add such state functionality to our Restaurants app.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor080"/>Adding state to our Restaurants app</h2>
			<p>Let's imagine that the<a id="_idIndexMarker131"/> user can scroll through the list of restaurants<a id="_idIndexMarker132"/> and then tap a particular one, thereby marking it as a favorite. For this to be more suggestive, we will add a heart icon for each restaurant. To do this, follow these steps:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, add another composable inside <strong class="source-inline">RestaurantItem</strong> called <strong class="source-inline">FavoriteIcon</strong>. Then, pass a weight of <strong class="source-inline">0.15f</strong> to make it occupy 15% of the parent <strong class="source-inline">Row</strong>:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantItem(item: Restaurant) {</p><p class="source-code">   Card(...) {</p><p class="source-code">       Row(...) {</p><p class="source-code">           RestaurantIcon(..., Modifier.weight(0.15f)<a id="_idTextAnchor081"/>)</p><p class="source-code">           RestaurantDetails(..., Modifier.weight(<strong class="bold">0.7f</strong>))</p><p class="source-code">           <strong class="bold">FavoriteIcon(Mo<a id="_idTextAnchor082"/>difier.weight(0.15f))</strong></p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>We have also made sure to decrease the weight of <strong class="source-inline">RestaurantDetails</strong> from 85% to 70%.</p>
			<ol>
				<li value="2">Still inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, define the missing <strong class="source-inline">FavoriteIcon</strong> composable, which receives an <strong class="source-inline">imageVector</strong> as a predefined icon with <strong class="source-inline">Icons.Filled.FavoriteBorder</strong>. Also, make it receive a <strong class="source-inline">Modifier</strong> object with <strong class="source-inline">8.dp</strong> of padding:<p class="source-code">@Composable</p><p class="source-code">private fun FavoriteIcon(modifier: Modifier) {</p><p class="source-code">   Image(</p><p class="source-code">       imageVector = Icons.Filled.FavoriteBorder,</p><p class="source-code">       contentDescription = "Favorite restaurant icon",</p><p class="source-code">      <a id="_idTextAnchor083"/> modifier = modifier.padding(8.dp))</p><p class="source-code">}</p></li>
				<li>If we try to <a id="_idIndexMarker133"/>refresh the preview or run the app, we can see several <strong class="source-inline">RestaurantItem</strong> composables similar to the following:</li>
			</ol>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B17788_02_04.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The RestaurantItem composable with a favorite icon</p>
			<p>Our <strong class="source-inline">RestaurantItem</strong> composable now has a favorite icon. However, when we click it, nothing <a id="_idIndexMarker134"/>happens. Clicking it should change the heart icon into a filled one, marking the restaurant as a favorite. To fix this, we must add a state that allows us to hold the favorite status of a restaurant.</p>
			<ol>
				<li value="4">Add state to the <strong class="source-inline">FavoriteIcon</strong> composable by adding the following code:<p class="source-code">@Composable</p><p class="source-code">private fun FavoriteIcon(modifier: Modifier) {</p><p class="source-code">   <strong class="bold">val favoriteState = remember { </strong></p><p class="source-code"><strong class="bold">       mutableStateOf(false) }</strong></p><p class="source-code"><strong class="bold">   val icon = if (favoriteState.value)</strong></p><p class="source-code"><strong class="bold">       Icons.Filled.Favorite</strong></p><p class="source-code"><strong class="bold">   else</strong></p><p class="source-code"><strong class="bold">       Icons.Filled.FavoriteBorder</strong></p><p class="source-code">    Image(</p><p class="source-code">        <strong class="bold">imageVector = icon,</strong></p><p class="source-code">        contentDescription = "Favorite restaurant icon",</p><p class="source-code">        modifier = modifier</p><p class="source-code">            .padding(8.dp)</p><p class="source-code">            <strong class="bold">.clickable { favoriteState.value =</strong></p><p class="source-code"><strong class="bold">                    !favoriteState.value</strong></p><p class="source-code">            <strong class="bold">}</strong></p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>To hold the state of<a id="_idIndexMarker135"/> being a favorite or not and to trigger a change in this<a id="_idIndexMarker136"/> state value, we've done the following:</p>
			<ol>
				<li value="1">We added a <strong class="source-inline">favoriteState</strong> variable that holds a <strong class="source-inline">MutableState</strong> of type <strong class="source-inline">Boolean</strong> with an initial value of <strong class="source-inline">false</strong>. As usual, we wrap the <strong class="source-inline">mutableStateOf</strong> constructor inside a <strong class="source-inline">remember</strong> block to preserve the state's value across recompositions.</li>
				<li>We defined an <strong class="source-inline">icon</strong> variable that can hold a value of <strong class="source-inline">Icons.Filled.Favorite</strong>, which means that the restaurant is your favorite, or a value of <strong class="source-inline">Icons.Filled.FavoriteBorder</strong>, which means that the restaurant is not your favorite.</li>
				<li>We passed the value of <strong class="source-inline">icon</strong> value to the <strong class="source-inline">imageVector</strong> parameter of our <strong class="source-inline">Image</strong> composable.</li>
				<li>We added a <strong class="source-inline">clickable</strong> modifier that's chained after the <strong class="source-inline">padding</strong> one. In this callback, we made sure to update <strong class="source-inline">favoriteState</strong> with the <strong class="source-inline">.value</strong> accessor by obtaining it and writing the previously negated value.<p class="callout-heading">Note</p><p class="callout">When defining state objects in Compose, you can replace the assignment (<strong class="source-inline">=</strong>) operator with property delegation, which can be achieved with the <strong class="source-inline">by</strong> operator: <strong class="source-inline">val favoriteState by remember { … }</strong>. By doing this, you will not need to use the <strong class="source-inline">.value</strong> accessor anymore as it is delegated.</p></li>
			</ol>
			<p>When we're <a id="_idIndexMarker137"/>running or live previewing the application, we can see <a id="_idIndexMarker138"/>that upon clicking the empty heart icon of each restaurant, it becomes filled, marking the restaurant as a favorite:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B17788_02_05.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – The RestaurantsScreen composable with a favorite state for its items</p>
			<p>Most of the time, keeping state and state handling logic inside composable functions is not recommended. Let's explore why this is not the best practice and how we can improve the way we manage state with the help of state hoisting.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor084"/>Hoisting state in Compose</h1>
			<p>Composable functions are usually categorized in terms of state handling in two main categories:</p>
			<ul>
				<li><strong class="bold">Stateful</strong>, which allows the composable to hold and manage its state. Stateful composables are<a id="_idIndexMarker139"/> those functions where the caller (or parent composable) doesn't need to manage the state. They model basic UI <a id="_idIndexMarker140"/>interactions such as animations or expanding content, and they are usually okay to be stateful and hold a <strong class="source-inline">State</strong> object.</li>
				<li><strong class="bold">Stateless</strong>, which <a id="_idIndexMarker141"/>allows the composable to delegate the state management and to forward event callbacks to its parent composable. Composables that not only impact the UI as their state changes but are also of interest to the presentation or business logic are usually ok to be<a id="_idIndexMarker142"/> stateless. This way, the <strong class="source-inline">ViewModel</strong> component can be the only source of truth for their state to control and manage UI changes but also to avoid illegal states.</li>
			</ul>
			<p>In our case, state changes when a restaurant is marked as a favorite or not. Since we want to control this interaction at the presentation level in the <strong class="source-inline">ViewModel</strong> class to keep track of which restaurants have been favorited, we need to move the state up from the <strong class="source-inline">FavoriteIcon</strong> composable.</p>
			<p>The pattern of moving state up<a id="_idIndexMarker143"/> from a composable to its caller composable is called <strong class="bold">state hoisting</strong>. To achieve this, we must replace the <strong class="source-inline">State</strong> object with two parameters:</p>
			<ul>
				<li>One <strong class="source-inline">value</strong> parameter for the data that defines the current state</li>
				<li>A callback function that is triggered as an event when a new value is emitted </li>
			</ul>
			<p>By receiving data as input and forwarding events to the parent composable, we make sure that our Compose UI obeys the previously introduced concept of the unidirectional flow of state and events. This concept defines how state values and events should only flow in one direction: the events upwards and the state downwards, and with state hoisting, we enforce just that.</p>
			<p>The benefits of state<a id="_idIndexMarker144"/> hoisting are as follows:</p>
			<ul>
				<li><strong class="bold">Single source of truth for the state</strong>: The state of our Compose UI can have a single source of truth: the parent composable or, even better, <strong class="source-inline">ViewModel</strong>. Composables can be decoupled from their state to avoid illegal states in your UI.</li>
				<li><strong class="bold">Reusability</strong>: Since composables only render the data that's received as input, it's much easier to reuse them within other composables as you can simply pass different values.</li>
				<li><strong class="bold">Encapsulation limitation</strong>: Only stateful composables can change their state internally. This means that you can limit the number of composables that handle their state, which could lead to illegal UI states.</li>
			</ul>
			<p>Now that we've briefly<a id="_idIndexMarker145"/> covered what state hoisting is and why it is <a id="_idIndexMarker146"/>beneficial, it's time to hoist the state within our Restaurants application:</p>
			<ol>
				<li value="1">First, lift the state from the <strong class="source-inline">FavoriteIcon</strong> composable by removing the existing <strong class="source-inline">favoriteState</strong> and <strong class="source-inline">icon</strong> variables along with their instantiation logic from the top of the body of the function. At the same time, update the <strong class="source-inline">FavoriteIcon</strong> composable to accept an <strong class="source-inline">icon</strong> parameter for receiving input data and also an <strong class="source-inline">onClick</strong> event callback for forwarding upwards events:<p class="source-code">@Composable</p><p class="source-code">private fun FavoriteIcon(<strong class="bold">icon: ImageVector</strong>, </p><p class="source-code">                         modifier: Modifier<strong class="bold">,</strong></p><p class="source-code">                         <strong class="bold">onClick: () -&gt; Unit</strong>) {</p><p class="source-code">   Image(</p><p class="source-code">       imageVector <strong class="bold">= icon</strong>,</p><p class="source-code">       contentDescription = "Favorite restaurant icon",</p><p class="source-code">       modifi<a id="_idTextAnchor085"/>er = [...]</p><p class="source-code">           .clickable { <strong class="bold">onClick()</strong> })</p><p class="source-code">}</p></li>
			</ol>
			<p>Additionally, we passed <strong class="source-inline">icon</strong> to the <strong class="source-inline">imageVector</strong> parameter of the <strong class="source-inline">Image</strong> composable and triggered the <strong class="source-inline">onClick</strong> callback function whenever the <strong class="source-inline">clickable</strong> event is triggered. By applying these changes, we lifted the state up and transformed <strong class="source-inline">FavoriteIcon</strong> from a stateful composable into a stateless one.</p>
			<ol>
				<li value="2">Now, move<a id="_idIndexMarker147"/> the <strong class="source-inline">favoriteState</strong> variable in <a id="_idIndexMarker148"/>the <strong class="source-inline">RestaurantItem</strong> parent composable of <strong class="source-inline">FavoriteIcon</strong>. The <strong class="source-inline">RestaurantItem</strong> composable provides the state to <strong class="source-inline">FavoriteIcon</strong> and is also in charge of updating its state over time:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantItem(item: Restaurant) {</p><p class="source-code">   <strong class="bold">val favoriteState</strong> <strong class="bold">= remember { </strong></p><p class="source-code"><strong class="bold">       mutableStateOf(false) }</strong></p><p class="source-code"><strong class="bold">   val icon = if (favoriteState.value)</strong></p><p class="source-code"><strong class="bold">       Icons.Filled.Favorite</strong></p><p class="source-code"><strong class="bold">   else</strong></p><p class="source-code"><strong class="bold">       Icons.Filled.FavoriteBorder</strong></p><p class="source-code">   Card(...) {</p><p class="source-code">       Row(...) {</p><p class="source-code">          [...]</p><p class="source-code">          FavoriteIcon(<strong class="bold">icon</strong>, Modifier.weight(0.15f)) <strong class="bold">{</strong></p><p class="source-code">               <strong class="bold">favoriteState.value = </strong></p><p class="source-code"><strong class="bold">  <a id="_idTextAnchor086"/>                 !favoriteState.value</strong></p><p class="source-code">          <strong class="bold">}</strong></p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>The corresponding <strong class="source-inline">icon</strong> for each state is now passed to <strong class="source-inline">FavoriteIcon</strong>. Additionally, <strong class="source-inline">RestaurantItem</strong> is now listening for <strong class="source-inline">onClick</strong> events in the trailing lambda block, where it mutates the <strong class="source-inline">favoriteState</strong> object, triggering recomposition upon every click.</p>
			<p>Yet, looking at <strong class="source-inline">FavoriteIcon</strong> and <strong class="source-inline">RestaurantIcon</strong>, we can see many similarities. Both are stateless composables that receive an <strong class="source-inline">ImageVector</strong> as a parameter. Since<a id="_idIndexMarker149"/> they are stateless and perform similar<a id="_idIndexMarker150"/> functions, let's reuse one of them and delete the other.</p>
			<ol>
				<li value="3">Inside <strong class="source-inline">RestaurantIcon</strong>, add a similar <strong class="source-inline">onClick</strong> function parameter (just like <strong class="source-inline">FavoriteIcon</strong> has) and bind it to the <strong class="source-inline">clickable</strong> modifier's callback: <p class="source-code">@Composable</p><p class="source-code">private fun RestaurantIcon(icon: ImageVector, modifier: Modifier<strong class="bold">, onClick: () -&gt; Unit = { })</strong> {</p><p class="source-code">   Image([...],</p><p class="source-code">       modifier = modifier</p><p class="source-code">           .padding(8.dp)</p><p class="source-code">           <strong class="bold">.clickable { onClick() }</strong></p><p class="source-code"><strong class="bold">   )</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Since we don't want to execute anything on click events for the restaurant profile icon, we provided a default empty function (<strong class="source-inline">{ }</strong>) value to the <strong class="source-inline">onClick</strong> parameter. </p>
			<p>Once you've done this, you can delete the <strong class="source-inline">FavoriteIcon</strong> composable since we won't need it<a id="_idIndexMarker151"/> anymore.</p>
			<ol>
				<li value="4">Inside<a id="_idIndexMarker152"/> the <strong class="source-inline">RestaurantItem</strong> composable, replace <strong class="source-inline">FavoriteIcon</strong> with <strong class="source-inline">RestaurantIcon</strong>: <p class="source-code">@Composable</p><p class="source-code">fun RestaurantItem(item: Restaurant) {</p><p class="source-code">   val favoriteState = ...</p><p class="source-code">   Card(...) {</p><p class="source-code">       Row(...) {</p><p class="source-code">          RestaurantIcon(…)</p><p class="source-code">          RestaurantDetails(...)</p><p class="source-code">          <strong class="bold">RestaurantIcon</strong>(icon, Modifier.weight(0.15f)) {</p><p class="source-code">               favoriteState.value = !favoriteState.value</p><p class="source-code">           }</p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>You have now hoisted the state from <strong class="source-inline">RestaurantIcon</strong> to the <strong class="source-inline">RestaurantItem</strong> composable. </p>
			<p>Let's keep on hoisting the state even further uphill, into the <strong class="source-inline">RestaurantsScreen</strong> composable. However, we cannot keep individual <strong class="source-inline">State</strong> objects for each <strong class="source-inline">RestaurantItem</strong> inside this composable, so we will have to change the <strong class="source-inline">State</strong> object to hold a list of <strong class="source-inline">Restaurant</strong> objects, each having a separate <strong class="source-inline">isFavorite</strong> value.</p>
			<ol>
				<li value="5">Inside the <strong class="source-inline">Restaurant.kt</strong> file, add another property for <strong class="source-inline">Restaurant</strong> called <strong class="source-inline">isFavorite</strong>. It should have a default value of <strong class="source-inline">false</strong> since, by default, restaurants are not marked as favorites when the application starts:<p class="source-code">data class Restaurant(val id: Int,</p><p class="source-code">                      val title: String,</p><p class="source-code">                      val description: String,</p><p class="source-code">                      <strong class="bold">var isFavorite: Boolean = false</strong>)</p><p class="source-code">val dummyRestaurants = listOf(…)</p></li>
				<li>Going back <a id="_idIndexMarker153"/>inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, hoist the state up again, this time from <strong class="source-inline">RestaurantItem</strong>, by adding an <strong class="source-inline">onClick</strong> function parameter that's triggered inside <a id="_idIndexMarker154"/>the <strong class="source-inline">RestaurantIcon</strong>'s callback function parameter. We won't add a new argument for the input data since we already have the <strong class="source-inline">item</strong> argument of type <strong class="source-inline">Restaurant</strong>, and you can also safely remove the <strong class="source-inline">favoriteState</strong> variable since we won't be needing it anymore:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantItem(item: Restaurant, </p><p class="source-code">                   <strong class="bold">onClick: (id: Int) -&gt; Unit</strong>) {</p><p class="source-code">   val icon = if (<strong class="bold">item.isFavorite</strong>)</p><p class="source-code">       Icons.Filled.Favorite</p><p class="source-code">   else</p><p class="source-code">       Icons.Filled.FavoriteBorder</p><p class="source-code">   Card(...) {</p><p class="source-code">       Row(...) {</p><p class="source-code">           ...</p><p class="source-code">          RestaurantIcon(…)</p><p class="source-code">          RestaurantDetails(…)</p><p class="source-code">          RestaurantIcon(…) {</p><p class="source-code">              <strong class="bold">onClick(item.id)</strong></p><p class="source-code">          }</p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>This time, the <strong class="source-inline">item</strong> parameter will be our <strong class="source-inline">Restaurant</strong> object. <strong class="source-inline">Restaurant</strong> now holds an <strong class="source-inline">isFavorite: Boolean</strong> property that states whether the restaurant is favorited or not. That's why we set the correct value for the <strong class="source-inline">icon</strong> variable based on the item's field by checking the <strong class="source-inline">item.isFavorite</strong> value.</p>
			<p>Now, <strong class="source-inline">RestaurantItem</strong> is a stateless<a id="_idIndexMarker155"/> composable, so it's time to add a <strong class="source-inline">State</strong> object <a id="_idIndexMarker156"/>to its parent.</p>
			<ol>
				<li value="7">Inside <strong class="source-inline">RestaurantsScreen</strong>, add a <strong class="source-inline">state</strong> variable that will hold our list of restaurants. Its type will be <strong class="source-inline">MutableState&lt;List&lt;Restaurant&gt;&gt;</strong> and we will set the restaurants from <strong class="source-inline">viewModel</strong> as it initial value, finally passing the state's <strong class="source-inline">value</strong> to the <strong class="source-inline">items</strong> constructor of <strong class="source-inline">LazyColumn</strong>:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen() {</p><p class="source-code">  val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code"><strong class="bold">  val state: MutableState&lt;List&lt;Restaurant&gt;&gt; =</strong></p><p class="source-code"><strong class="bold">    remember {</strong></p><p class="source-code"><strong class="bold">      mutableStateOf(viewModel.getRestaurants())</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  LazyColumn(...) {</p><p class="source-code">   items(<strong class="bold">state.value</strong>) { restaurant -&gt;</p><p class="source-code">     RestaurantItem(restaurant) <strong class="bold">{ id -&gt;</strong></p><p class="source-code">      <strong class="bold"> val restaurants = state.value.toMutableList()</strong></p><p class="source-code"><strong class="bold">       val itemIndex =</strong></p><p class="source-code"><strong class="bold">         restaurants.indexOfFirst { it.id == id }</strong></p><p class="source-code"><strong class="bold">       val item = restaurants[itemIndex]</strong></p><p class="source-code"><strong class="bold">       restaurants[itemIndex] =</strong></p><p class="source-code"><strong class="bold">         item.copy(isFavorite = !item.isFavorite)</strong></p><p class="source-code"><strong class="bold">       state.value = restaurants</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Inside <strong class="source-inline">RestaurantItem</strong>'s <strong class="source-inline">onClick</strong> trailing lambda block, we must toggle the favorite status of the<a id="_idIndexMarker157"/> corresponding restaurant and update the state. Because <a id="_idIndexMarker158"/>of this, we did the following:</p>
			<ol>
				<li value="1">We obtained the current list of restaurants by calling <strong class="source-inline">state.value</strong> and converting it into a mutable list so that we could replace the item whose <strong class="source-inline">isFavorite</strong> field's value should be updated.</li>
				<li>We obtained the index of the item whose <strong class="source-inline">isFavorite</strong> field should be updated via the <strong class="source-inline">indexOfFirst</strong> function, where we matched the <strong class="source-inline">id</strong> property of the <strong class="source-inline">Restaurant</strong> objects.</li>
				<li>Having found <strong class="source-inline">itemIndex</strong>, we obtained the <strong class="source-inline">item</strong> object of type <strong class="source-inline">Restaurant</strong> and applied the <strong class="source-inline">copy()</strong> constructor, where we negated the <strong class="source-inline">isFavorite</strong> field. The resulting value replaced the existing <strong class="source-inline">item</strong> at <strong class="source-inline">itemIndex</strong>.</li>
				<li>Finally, we passed the updated <strong class="source-inline">restaurants</strong> list back to the <strong class="source-inline">state</strong> object with the <strong class="source-inline">.value</strong> accessor.<p class="callout-heading">Note</p><p class="callout">For Compose to observe changes within a list of objects of type <strong class="source-inline">T</strong> called <strong class="source-inline">List&lt;T&gt;,</strong> where <strong class="source-inline">T</strong> is a data class, you must update the memory reference of the updated item. You can do that by calling the <strong class="source-inline">copy()</strong> constructor of <strong class="source-inline">T</strong> so that when the updated list is passed back to your <strong class="source-inline">State</strong> object, Compose triggers a recomposition. Alternatively, you can use <strong class="source-inline">mutableStateListOf&lt;Restaurant&gt;()</strong> to have easier recomposition events triggered.</p></li>
			</ol>
			<p>If we try to run the <a id="_idIndexMarker159"/>app, we should notice that the functionality is <a id="_idIndexMarker160"/>the same, yet the state was hoisted and that we can now reuse composables such as <strong class="source-inline">RestaurantItem</strong> or <strong class="source-inline">RestaurantIcon</strong> much easier.</p>
			<p>But what happens if we toggle a couple of restaurants that are favorites and then rotate the device, thereby changing the screen orientation? </p>
			<p>Even though we used the <strong class="source-inline">remember</strong> block to preserve the state across recompositions, our selections were lost, and all the restaurants are marked as not favorites again. This is because the <strong class="source-inline">MainActivity</strong> host of our <strong class="source-inline">RestaurantsScreen</strong> composable has been recreated, so any state was also lost when the configuration change occurred.</p>
			<p>To fix this, we can do the following:</p>
			<ul>
				<li>Replace the <strong class="source-inline">remember</strong> block with <strong class="source-inline">rememberSaveable</strong>. This will allow the state to be automatically saved across configuration changes of the host <strong class="source-inline">Activity</strong>.</li>
				<li>Hoist the state to <strong class="source-inline">ViewModel</strong>. We know that <strong class="source-inline">RestaurantsViewModel</strong> is not scoped to the lifecycle of our <strong class="source-inline">RestaurantsScreen</strong> yet since no navigation library was used, so this means it's scoped to <strong class="source-inline">MainActivity</strong>, which allows it to survive configuration changes.</li>
			</ul>
			<p>You can try replacing the <strong class="source-inline">remember</strong> block with <strong class="source-inline">rememberSaveable</strong> and then rotate the screen to see that the state is now preserved across configuration changes. However, we want to take the high road and make sure <strong class="source-inline">ViewModel</strong> is the only source of truth for our state. Let's get started:</p>
			<ol>
				<li value="1">To lift the state to <strong class="source-inline">ViewModel</strong>, we must move the <strong class="source-inline">State</strong> object from the <strong class="source-inline">RestaurantsScreen</strong> composable to the <strong class="source-inline">RestaurantsViewModel</strong> and we must also create a new method called <strong class="source-inline">toggleFavorite</strong> that will allow the <strong class="source-inline">RestaurantsViewModel</strong> to mutate the value of the <strong class="source-inline">state</strong> variable every time we try to <a id="_idIndexMarker161"/>toggle the favorite status of a<a id="_idIndexMarker162"/> restaurant:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">   <strong class="bold">val state = mutableStateOf(dummyRestaurants)</strong></p><p class="source-code"><strong class="bold">    fun toggleFavorite(id: Int) {</strong></p><p class="source-code"><strong class="bold">        val restaurants = state.value.toMutableList()</strong></p><p class="source-code"><strong class="bold">        val itemIndex =</strong></p><p class="source-code"><strong class="bold">            restaurants.indexOfFirst { it.id == id }</strong></p><p class="source-code"><strong class="bold">        val item = restaurants[itemIndex]</strong></p><p class="source-code"><strong class="bold">        restaurants[itemIndex] =</strong></p><p class="source-code"><strong class="bold">            item.copy(isFavori<a id="_idTextAnchor087"/>te = !item.isFavorite)</strong></p><p class="source-code"><strong class="bold">        state.value = restaurants</strong></p><p class="source-code"><strong class="bold">    }</strong> </p><p class="source-code">}</p></li>
			</ol>
			<p>The new method called <strong class="source-inline">toggleFavorite</strong> accepts the <strong class="source-inline">id</strong> property of the targeted restaurant. Inside this method, we moved the code from the <strong class="source-inline">RestaurantItem</strong>'s <strong class="source-inline">onClick</strong> trailing lambda block, where we toggle the favorite status of the corresponding item and update its state.</p>
			<p>By this time, you can safely remove the <strong class="source-inline">getRestaurants()</strong> method from the <strong class="source-inline">RestaurantsViewModel</strong> class since we won't be needing it anymore.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">State</strong> object that's contained within the <strong class="source-inline">ViewModel</strong> should not be publicly available for other classes to modify it, since we want it to be encapsulated and allow only the <strong class="source-inline">ViewModel</strong> to update it. We will fix this in <a href="B17788_07_ePub.xhtml#_idTextAnchor249"><em class="italic">Chapter 7</em></a><em class="italic">, Introducing Presentation Patterns in Android</em>.</p>
			<ol>
				<li value="2">Inside the <strong class="source-inline">RestaurantsScreen</strong> composable, remove the <strong class="source-inline">state</strong> variable and pass the <a id="_idIndexMarker163"/>restaurants from <strong class="source-inline">RestaurantsViewModel</strong> by accessing<a id="_idIndexMarker164"/> the value of its state through the <strong class="source-inline">.value</strong> accessor with <strong class="source-inline">viewModel.state.value</strong>:<p class="source-code">fun RestaurantsScreen() {</p><p class="source-code">   val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">   LazyColumn(...) {</p><p class="source-code">       items(<strong class="bold">viewModel.state.value</strong>) { restaurant -&gt;</p><p class="source-code">           RestaurantItem(restaurant) { id -&gt;</p><p class="source-code">               <strong class="bold">viewModel.toggleFavorite(id)</strong></p><p class="source-code">           }</p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>We also removed the old code from the <strong class="source-inline">RestaurantItem</strong>'s <strong class="source-inline">onClick</strong> trailing lambda block and replaced it with a call to our <strong class="source-inline">ViewModel</strong>'s <strong class="source-inline">toggleFavorite</strong> method.</p>
			<p>If you run the application, the UI should perform as expected, so you should be able to toggle any<a id="_idIndexMarker165"/> restaurants as favorite and your selections should be saved upon events like<a id="_idIndexMarker166"/> orientation change.</p>
			<p>The only difference is that now, <strong class="source-inline">RestaurantsViewModel</strong> is the only source of truth for the state of <strong class="source-inline">RestaurantsScreen</strong> and we no longer need to hold or save the UI state inside the composables themselves.</p>
			<p>We now know how to hoist the state up into the <strong class="source-inline">ViewModel</strong>. Now, let's cover a very important scenario in the world of Android that's related to process death.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor088"/>Recovering from system-initiated process death</h1>
			<p>We've already learned how, whenever a configuration change occurs, our <strong class="source-inline">Activity</strong> is recreated, which can cause our UI to lose its state. To bypass this issue and to preserve the UI's state, we ended up implementing a <strong class="source-inline">ViewModel</strong> component and hoisted the UI state there.</p>
			<p>But what would happen in the case of a system-initiated process death?</p>
			<p>A <strong class="bold">system-initiated process death</strong> happens <a id="_idIndexMarker167"/>when the user places our application in the background and decides to use other apps for a while – in the meantime, though, the system decides to kill our app's process to free up system resources, which initiates process death.</p>
			<p>Let's try to simulate<a id="_idIndexMarker168"/> such an event and see what happens:</p>
			<ol>
				<li value="1">Start the Restaurants app using the IDE's <strong class="bold">Run</strong> button and mark some restaurants as favorites:</li>
			</ol>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B17788_02_06.jpg" alt="Figure 2.6 – The RestaurantsScreen composable with favorite selections made&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The RestaurantsScreen composable with favorite selections made</p>
			<ol>
				<li value="2">Place the app in <a id="_idIndexMarker169"/>the background by pressing the <strong class="bold">Home</strong> button on the device/emulator.</li>
				<li>In Android Studio, select the <strong class="bold">Logcat</strong> window and then press the red square button on the left-hand side to terminate the application:</li>
			</ol>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B17788_02_07.jpg" alt="Figure 2.7 – Killing the process in Logcat to simulate system-initiated process death&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Killing the process in Logcat to simulate system-initiated process death</p>
			<ol>
				<li value="4">Relaunch the<a id="_idIndexMarker170"/> application from the application drawer:</li>
			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B17788_02_08.jpg" alt="Figure 2.8 – The RestaurantsScreen composable with favorite selections lost&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – The RestaurantsScreen composable with favorite selections lost</p>
			<p>We have now <a id="_idIndexMarker171"/>simulated a situation where the system would kill our process. When we return to the app, we can see that our selections are now gone and that the restaurants that were favorited are now in their default states.</p>
			<p>To restore state upon system-initiated process death, we used to use the <strong class="bold">Saved State module</strong>, which allowed <a id="_idIndexMarker172"/>us to save state-related details in the <strong class="source-inline">onSaveInstanceState()</strong> callback of our activity.</p>
			<p>Similarly, every <strong class="source-inline">ViewModel</strong> that uses the default <strong class="source-inline">ViewModelFactory</strong> (like we did with the <strong class="source-inline">viewModel()</strong> inline syntax previously) can access a <strong class="source-inline">SavedStateHandle</strong> object through its constructor. If you use a custom <strong class="source-inline">ViewModelFactory</strong>, make sure that it extends <strong class="source-inline">AbstractSavedStateViewModelFactory</strong>.</p>
			<p>The <strong class="source-inline">SavedStateHandle</strong> object is a key-value map that allows you to save and then restore objects that are crucial to your state. This map survives the event of process death when this event is initiated by the system, which allows you to retrieve and restore your saved objects.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When we're saving state-related data, it's crucial to save lightweight objects that define the state and not the entire data that is described on the screen. For large data, we should use local persistence.</p>
			<p>Let's try to do<a id="_idIndexMarker173"/> this in our application by saving a list of <strong class="source-inline">id</strong> values of the restaurants that were toggled as favorites in <strong class="source-inline">SavedStateHandle</strong>. Saving the <strong class="source-inline">id</strong> values is better than saving the entire list of restaurants since a list of <strong class="source-inline">Int</strong> values is lightweight. And since we can always get the restaurant list back at runtime, the only thing that's missing is to remember which of them were favorited.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Usually, <strong class="source-inline">SavedStateHandle</strong> is used for saving transient data like sorting or filtering selections performed by the user, or other selections that you need to restore upon system-initiated process death. In our case though, favorited restaurants should be restored not only upon system-initiated process death but also upon a simple application restart. That's why we will save these selections as part of the domain data of the app inside a local database later in <a href="B17788_06_ePub.xhtml#_idTextAnchor186"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding Offline Capabilities with Jetpack Room</em>.</p>
			<p>Let's use a <strong class="source-inline">SavedStateHandle</strong> object to recover from system-initiated process death:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">SavedStateHandle</strong> parameter to your <strong class="source-inline">RestaurantsViewModel</strong>:<p class="source-code">class RestaurantsViewModel(</p><p class="source-code">    <strong class="bold">private val stateHandle: SavedStateHandle</strong>) : </p><p class="source-code"><strong class="bold">        </strong>ViewModel() {</p><p class="source-code">   …</p><p class="source-code">}</p></li>
				<li>Call a <strong class="source-inline">storeSelection</strong> method whenever we toggle the favorite status of a restaurant inside the <strong class="source-inline">toggleFavorite</strong> method and pass the respective restaurant: <p class="source-code">class RestaurantsViewModel(…) {</p><p class="source-code">   fun toggleFavorite(id: Int) {</p><p class="source-code">       …</p><p class="source-code">       restaurants[itemIndex] = item.copy(isFavorite = </p><p class="source-code">           !item.isFavorite)</p><p class="source-code">       <strong class="bold">storeSelection(restaurants[itemIndex])</strong></p><p class="source-code">       state.value = restaurants</p><p class="source-code">   }</p><p class="source-code"> ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This code won't compile though because we haven't yet defined the <strong class="source-inline">storeSelection</strong> method. Let's do that up next.</p>
			<ol>
				<li value="3">Inside <strong class="source-inline">RestaurantsViewModel</strong>, create a new <strong class="source-inline">storeSelection</strong> method that <a id="_idIndexMarker174"/>receives a <strong class="source-inline">Restaurant</strong> object whose <strong class="source-inline">isFavorite</strong> property has just been altered, and saves that selection inside the <strong class="source-inline">SavedStateHandle</strong> object provided by the <strong class="source-inline">RestaurantsViewModel</strong> class:<p class="source-code">private fun storeSelection(item: Restaurant) {</p><p class="source-code">   val savedToggled = stateHandle</p><p class="source-code">     .get&lt;List&lt;Int&gt;?&gt;(FAVORITES)</p><p class="source-code">     .orEmpty().toMutableList()</p><p class="source-code">   if (item.isFavorite) savedToggled.add(item.id)</p><p class="source-code">   else savedToggled.remove(item.id)</p><p class="source-code">   stateHandle[FAVORITES] = savedToggled</p><p class="source-code">}</p><p class="source-code">companion object {</p><p class="source-code">  const val FAVORITES = "favorites"</p><p class="source-code">}</p></li>
			</ol>
			<p>This new method will try to save the <strong class="source-inline">id</strong> value of a restaurant in our <strong class="source-inline">stateHandle</strong> object every time we toggle its favorite status. It does this as follows:</p>
			<ol>
				<li value="1"> It obtains a<a id="_idIndexMarker175"/> list containing the IDs of the previously favorited restaurants from <strong class="source-inline">stateHandle</strong> by accessing the <strong class="source-inline">FAVORITES</strong> key inside the map. It stores the result in a <strong class="source-inline">savedToggle</strong> mutable list. If no restaurants were favorited, the list will be empty.</li>
				<li> If this restaurant was marked as favorite, it adds the ID of the restaurant to the <strong class="source-inline">savedToggle</strong> list. Otherwise, it removes it.</li>
				<li> Saves the updated list of favorited restaurants with the <strong class="source-inline">FAVORITES</strong> key inside the <strong class="source-inline">stateHandle</strong> map.</li>
			</ol>
			<p>We have also added a <strong class="source-inline">companion object</strong> construct to the <strong class="source-inline">RestaurantsViewModel</strong> class as a static extension object. We used this <strong class="source-inline">companion object</strong> to define a constant value for the key used to save the restaurant's selection inside our <strong class="source-inline">stateHandle</strong> map.</p>
			<p>Now, we've made sure to cache the selections of favorite restaurants before process death, so our next step is to find a way to restore these selections after the app recovers from a system-initiated process death event.</p>
			<ol>
				<li value="4">Call a <strong class="source-inline">restoreSelections()</strong> extension method on the <strong class="source-inline">dummyRestaurants</strong> list that we are passing as an initial value to our <strong class="source-inline">state</strong> object. This call should restore the UI selections:<p class="source-code">class RestaurantsViewModel(</p><p class="source-code">   private val stateHandle: SavedStateHandle):</p><p class="source-code">      ViewModel() {</p><p class="source-code">   val state = mutableStateOf(</p><p class="source-code">     <strong class="bold">dummyRestaurants.restoreSelections()</strong></p><p class="source-code">   )</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This code won't compile though because we haven't yet defined the <strong class="source-inline">restoreSelections</strong> method. Let's do that up next.</p>
			<ol>
				<li value="5">Inside <a id="_idIndexMarker176"/><strong class="source-inline">RestaurantsViewModel</strong>, define the <strong class="source-inline">restoreSelections</strong> extension function that will allow us to retrieve the restaurants that were favorited upon process death:<p class="source-code">private fun List&lt;Restaurant&gt;.restoreSelections():</p><p class="source-code">        List&lt;Restaurant&gt; {</p><p class="source-code">    stateHandle.get&lt;List&lt;Int&gt;?&gt;(FAVORITES)?.let {</p><p class="source-code">            selectedIds -&gt;</p><p class="source-code">        val restaurantsMap = this.associateBy { it.id }</p><p class="source-code">        selectedIds.forEach { id -&gt;</p><p class="source-code">            restaurantsMap[id]?.isFavorite = true</p><p class="source-code">        }</p><p class="source-code">        return restaurantsMap.values.toList()</p><p class="source-code">    }</p><p class="source-code">    return this</p><p class="source-code">}</p></li>
			</ol>
			<p>This extension function will allow us to mark those restaurants that were marked by the user previously as favorites upon system-initiated process death. The <strong class="source-inline">restoreSelections</strong> extension function achieves that in the following way:</p>
			<ol>
				<li value="1">First, by obtaining the list with the unique identifiers of the previously favorited restaurants from <strong class="source-inline">stateHandle</strong> by accessing the <strong class="source-inline">FAVORITES</strong> key inside the map. If the list is not <strong class="source-inline">null</strong>, this means that a process death occurred, and it references the list as <strong class="source-inline">selectedIds</strong>; otherwise, it will return the list without any modifications.</li>
				<li>Then, by creating<a id="_idIndexMarker177"/> a map from the input list of restaurants with the key being the <strong class="source-inline">id</strong> value of the restaurant and the value the <strong class="source-inline">Restaurant</strong> object itself.</li>
				<li>By iterating over the unique identifiers of the favorited restaurants and for each of them, by trying to access the respective restaurant from our new list and sets its <strong class="source-inline">isFavorite</strong> value to <strong class="source-inline">true</strong>.</li>
				<li>By returning the modified restaurants list from <strong class="source-inline">restaurantMap</strong>. This list should now contain the restored <strong class="source-inline">isFavorite</strong> values from before the death process occurred.</li>
			</ol>
			<p>6.	Finally, build the app and then repeat <em class="italic">steps 1</em>, <em class="italic">2</em>, <em class="italic">3</em>, and <em class="italic">4</em> from when we simulated a system-initiated process death.</p>
			<p>The application should now correctly display the UI state with the previously favorited restaurants from before the system-initiated process death.</p>
			<p>With that, we've made sure that our application not only stores the UI state at the <strong class="source-inline">ViewModel</strong> level but that it also can recover from extraordinary events, such as system-initiated process death.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor089"/>Summary</h1>
			<p>In this chapter, we learned what a <strong class="source-inline">ViewModel</strong> class is, we explored the concepts that define it, and we learned how to instantiate one. We tackled why a <strong class="source-inline">ViewModel</strong> is useful as a single source of truth for the UI's <em class="italic">state</em>: to avoid illegal and undesired states.</p>
			<p>For that to make sense, we explored how a UI is defined by its state and how to define such a state in Compose. We then understood what <em class="italic">state hoisting</em> is and how to separate widgets between <em class="italic">stateless</em> and <em class="italic">stateful</em> composables. </p>
			<p>Finally, we put all these new concepts into practice by defining state in our Restaurants app, hoisting it, and then lifting it even higher into the newly created <strong class="source-inline">ViewModel</strong>.</p>
			<p>Finally, we learned how system-initiated process death occurs and how to allow the app to recover by restoring the previous state with the help of <strong class="source-inline">SavedStateHandle</strong>.</p>
			<p>In the next chapter, we will add real data to our Restaurants app by connecting it to our database using Retrofit.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor090"/>Further reading</h1>
			<p>Working with ViewModels and handling state changes in Compose represent two essential topics for reliable projects. Let's see what other subjects revolve around them. </p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor091"/>Exploring ViewModel with runtime-provided arguments</h2>
			<p>In most cases, you can declare and provide dependencies to your <strong class="source-inline">ViewModel</strong> inside the constructor, at compile time. In some cases, though, you might need to initialize a <strong class="source-inline">ViewModel</strong> instance with a parameter that's only known at runtime. </p>
			<p>For example, when we're adding a composable screen that displays the details of a restaurant, instead of sending the ID of the target restaurant from the composable to <strong class="source-inline">ViewModel</strong> through a function call, we can provide it directly to the <strong class="source-inline">ViewModel</strong> constructor through <strong class="bold">ViewModelFactory</strong>.</p>
			<p>To explore the process of building a <strong class="source-inline">ViewModelFactory</strong>, check out the following Codelab: <a href="https://developer.android.com/codelabs/kotlin-android-training-view-model#7">https://developer.android.com/codelabs/kotlin-android-training-view-model#7</a>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor092"/>Exploring ViewModel for Kotlin Multiplatform projects</h2>
			<p>While this chapter covered the Jetpack ViewModel for Compose in pure Android apps, if you're aiming to build cross-platform projects using <strong class="bold">Kotlin Multiplatform</strong> (<strong class="bold">KMP</strong>) or <strong class="bold">Kotlin Multiplatform Mobile</strong> (<strong class="bold">KMM</strong>), the Jetpack ViewModel might not be your best option.</p>
			<p>When we're building cross-platform projects, we should try to avoid platform-specific dependencies. The Jetpack ViewModel is suited for Android and therefore is an Android dependency, so we might need to build or define a ViewModel.</p>
			<p>To learn more about KMM and platform-agnostic ViewModels, check out the following GitHub example: <a href="https://github.com/dbaroncelli/D-KMP-sample">https://github.com/dbaroncelli/D-KMP-sample</a>.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor093"/>Understanding how to minimize the number of recompositions</h2>
			<p>In this chapter, we learned how to trigger recompositions by using <strong class="source-inline">State</strong> objects. While in Compose, recompositions happen often, we haven't had a chance to optimize the performance of our Compose-based screens.</p>
			<p>We can reduce the number of recompositions by ensuring that the input of the composables is deeply stable. To learn more about how to achieve this, go to <a href="https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&amp;skip_cache=true#skipping">https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&amp;skip_cache=true#skipping</a>.</p>
		</div>
	</body></html>