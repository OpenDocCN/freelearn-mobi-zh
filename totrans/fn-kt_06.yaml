- en: Delegates in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, we learned about functions and function types in functional
    programming. We also learned about the various types of function Kotlin has to
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is based on delegates in Kotlin. Delegates are awesome features
    of Kotlin in favour of functional programming. If you are coming from a non-FP
    background such as Java, you are probably hearing about delegates for the first
    time. So in this chapter, we will try to untangle things for you.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by learning the basics of delegation and then gradually move into
    implementations of delegates in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list contains the topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegated properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegated map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started with delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The origin of delegation in programming is from object composition. Object composition
    is a way to combine simple objects to derive a complex one. Object compositions
    are a critical building block of many basic data structures, including the tagged
    union, the linked list, and the binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: To make object composition more reusable (as reusable as inheritance), a new
    pattern is incorporated—the **delegation pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern allows an object to have a helper object, and that helper object
    is called a **delegate**. This pattern allows the original object to handle requests
    by delegating to the delegate helper object.
  prefs: []
  type: TYPE_NORMAL
- en: Though delegation is an object-oriented design pattern, not all languages have
    implicit support for delegation (such as Java, which doesn't support delegation
    implicitly). In those cases, you can still use *delegation* by explicitly passing
    the original object to the delegate to a method, as an argument/parameter.
  prefs: []
  type: TYPE_NORMAL
- en: But with the language support (such as in Kotlin), delegation becomes easier
    and often seems like using the original variable itself.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over time, the delegation pattern has proven to be a better alternative of inheritance.
    Inheritance is a powerful tool for code reuse, especially in the context of the *Liskov
    Substitution* model. Moreover, the direct support of OOP languages makes it even
    stronger.
  prefs: []
  type: TYPE_NORMAL
- en: However, inheritance still has some limitations, such as a class can't change
    its superclass dynamically during program execution; also, if you perform a small
    modification to the super class, it'll be directly propagated to the child class,
    and that is not what we want every time.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation, on the other hand, is flexible. You can think of delegation as a
    composition of multiple objects, where one object passes its method calls to another
    one and calls it a delegate. As I mentioned earlier, delegation is flexible; you
    can change the delegate at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For an example, think of the `Electronics` class and `Refrigerator` class. With
    inheritance, `Refrigerator` should implement/override the `Electronics` method
    calls and properties. With delegation however, the `Refrigerator` object would
    keep a reference of the `Electronics` object and would pass the method calls with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we know that Kotlin provides support for delegation, let's get started
    with delegation in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has out-of-the-box support for delegation. Kotlin provides you with some
    standard delegates for properties for most common programming needs. Most of the
    time, you'll find yourself using those standard delegates, instead of creating
    your own one; however, Kotlin also allows you to create your own delegate, as
    per your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Not only delegation for properties, Kotlin also allows you to have delegated
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So basically, there are two types of delegation in Kotlin, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Property delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's have a look at the property delegation first, and then we will move
    ahead with class delegation.
  prefs: []
  type: TYPE_NORMAL
- en: Property delegation (standard delegates)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, where we discussed delegation, we learned that delegation
    is a technique of method passing/forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: For property delegates, it almost does the same. A property can pass its getter
    and setter calls to the delegate and the delegate can handle those calls on behalf
    of the property itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re probably thinking, what is the benefit of passing getter and setter
    calls to the delegate? Only the delegate you''re using can answer this question.
    Kotlin has multiple predefined standard delegations for most common use cases.
    Let''s have a look at the following list, containing available standard delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Delegates.notNull` function and `lateinit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lazy` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Delegates.Observable` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Delegates.vetoble` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Delegates.notNull function and lateinit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of a situation where you need to declare a property at the class level,
    but you don't have the initial value for the variable there. You'll get the value
    at some later point, but before the property is actually used, and you're confident
    that the property will get initialised before using and it'll not be null. But,
    as per Kotlin syntax, you must initialize a property at the time of initializing.
    The quick fix is to declare it as a `nullable var` property, and assign a default
    null value. But as we mentioned earlier, since you are confident that the variable
    will not be null while using it, you are not willing to declare it as nullable.
  prefs: []
  type: TYPE_NORMAL
- en: '`Delegates.notNull` is here to save you in this scenario. Have a look at the
    following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Focus on the first line—`var notNullStr:String by Delegates.notNull<String>()`,
    we declared a non-null `String var` property, but we didn't initialize it. Instead,
    we wrote `by Delegates.notNull<String>()`, but what does it mean? Let us inspect.
    The `by` operator is a reserved keyword in Kotlin, to be used with delegates.
    The `by` operator works with two operands, on the left-hand side of `by` will
    be the property/class that needs to be delegated, and on the right-hand side will
    be the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: The delegate—`Delegates.notNull` allows you to temporarily go without initializing
    the property. It must be initialized before it is used (as we did on the very
    first line of the `main` method), otherwise it'll throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s modify the program by adding another property, which we will not
    initialize before using it, and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/562500f7-04ce-47e2-97b1-5eca2ded726f.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the `notInit` property caused the exception—`Property notInit should be
    initialized before get`.
  prefs: []
  type: TYPE_NORMAL
- en: But doesn't the variable declaration—`by Delegates.notNull()` sound awkward?
    The Kotlin team also thought the same way. That's why from Kotlin 1.1 they added
    a simple keyword—`lateinit`, to achieve the same objective. As it simply states
    about late initialization, it should be simply `lateinit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s modify the last program by replacing `by Delegates.notNull()` with
    `lateinit`. The following is the modified program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we had to rename the variables, as you can't have two top-level
    (package-level variable, without any class/function) variables of the same name.
    Except variable names, the only thing that changed is we added `lateinit`, instead
    of `by Delegates.notNull()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now let''s have a look at the following output to identify if there''s
    any change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bb69276-a4e0-4be2-8f3a-4bed42942b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: The output is also identical, except it slightly changes the error message.
    It now says, `lateinit property notInit1 has not been initialized`.
  prefs: []
  type: TYPE_NORMAL
- en: The lazy function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `lateinit` keyword works only on the `var` properties. The `Delegates.notNull()` 
    function works properly only with `var` properties, too.
  prefs: []
  type: TYPE_NORMAL
- en: So, what should we do when using `val` properties? Kotlin provides you with
    another delegation—`lazy`, that's meant for `val` properties only. But it works
    in a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `lateinit` and `Delegates.notNull()`, you must specify how you want to
    initialize the variable at the time of declaration. So, what's the benefit? The
    initialization will not be called until the variable is actually used. That's
    why this delegate is called `lazy`; it enables lazy initialization of properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So in this program, we declared a `String val` property—`myLazyVal` with a `lazy`
    delegate. We used (printed) that property in the second line of the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's focus on the variable declaration. The `lazy` delegate accepts a
    lambda that's expected to return the value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s have a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9487a37-2d5f-4e9d-bd10-d85cb1c96271.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the output clearly shows that the property got initialized after
    the first line of the `main` method executed, that is, when the property was actually
    used. This `lazy` initialization of properties can save your memory by a significant
    measure. It also comes as a handy tool in some situations, for example, think
    of a situation where you want to initialize the property with some other property/context,
    which would be available only after a certain point (but you have the property
    name); in that situation, you can simply keep the property as `lazy`, and then
    you can use it when it's confirmed that the initialization will be successful.
  prefs: []
  type: TYPE_NORMAL
- en: Observing property value change with Delegates.Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delegates are not only for initializing properties lately/lazily. As we learned,
    delegation enables the forwarding of getter and setter calls of a property to
    the delegate. This enables delegates to offer more cool features than just lately/lazily
    initialization.
  prefs: []
  type: TYPE_NORMAL
- en: One such cool feature comes with `Delegates.observable`. Think of a situation
    where you need to look out for the value change of a property, and perform some
    action as soon as this occurs. The immediate solution that comes to our mind is
    to override the setter, but this would look nasty and make codes complex, whereas
    delegates are there to save our life.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's a simple example, we declared a `String` property—`myStr`, with the help
    of `Delegates.observable` (we will describe that initialization soon after having
    a look at the output), then, inside the `main` function, we changed the value
    of `myStr` twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29f2b91e-fc1f-4b14-bc94-732c2397b7ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the output, we can see, that for both times we changed the value, a log
    got printed with the old and new value of the property. The `Delegates.observable`
    block in this program is responsible for that log in the output. So now, let''s
    have a close look at the `Delegates.observable` block and understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Delegates.observable` function takes two parameters to create the delegate.
    The first argument is the initial value of the property, and the second argument
    is the lambda that should be executed whenever the value change is noticed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda for `Delegates.observable` expects three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is an instance of `KProperty<out R>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KProperty` is an interface in the Kotlin `stdlib`, `kotlin.reflect` package,
    it is a property; such as a named `val` or `var` declaration. Instances of this
    class are obtainable by the `::` operator. For more information, visit: [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/.](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/)'
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter contains the old value of the property (the last value
    just before the assignment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is the newest value assigned to the property (the new value
    used in the assignment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, as we've got the concept of `Delegates.observable`, let's move ahead with
    a new delegate, `Delegates.vetoable`.
  prefs: []
  type: TYPE_NORMAL
- en: The power of veto – Delegates.vetoable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Delegates.vetoable` is another standard delegate that allows us to veto a
    value change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **veto**, Latin for *I forbid,* is the power (for example, used by an officer
    of the state) to unilaterally stop an official action. There is more information
    here: [https://en.wikipedia.org/wiki/Veto](https://en.wikipedia.org/wiki/Veto).'
  prefs: []
  type: TYPE_NORMAL
- en: This right to veto allows us to have a logic check on each assignment of the
    property, where we can decide to continue with the assignment or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we created an `Int` property—`myIntEven`; this property should
    only accept even numbers as an assignment. The `Delegates.vetoable` delegate works
    almost the same as the `Delegates.observable` function, just there's a small change
    in the lambda. Here, the lambda is expected to return a Boolean; the assignment
    would be passed if that returned Boolean is `true`, else the assignment would
    be dismissed.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look back at the program. While declaring the variable with the delegate
    `Delegates.vetoable`, we passed `0` as the initial value, then, in the lambda,
    we logged an assignment call, then we will return `true` if the new value is even
    and `false` if odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/132e0642-60b1-4e3f-afb3-49aa4632b57d.png)'
  prefs: []
  type: TYPE_IMG
- en: So, in the output, we can see two logs of assignment, but when we printed the `myIntEven`
    property after the last assignment, we can see the last assignment wasn't successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interesting, isn''t it? Let us see another example of `Delegates.vetoable`.
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This program has a property—`myCounter`, which is expected to increase with
    each assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the lambda, we checked if the `newValue` value is greater than the `oldValue` value.
    Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5ef800e-3e61-4f75-8dbe-9efbb6620ca0.png)'
  prefs: []
  type: TYPE_IMG
- en: The output which shows those assignments where the value was increased was successful,
    but those where the value decreased got dismissed.
  prefs: []
  type: TYPE_NORMAL
- en: Even when we used the increment and decrement operators, the increment operator
    was successful, but the decrement operator wasn't. This feature wouldn't be that
    easy to implement without delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Delegated map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we learned how to use standard delegates, but Kotlin has to offer more
    with delegation. The map delegation is among those awesome features that comes
    with delegation. So, what is it? It is the freedom of passing a map as a single
    parameter instead of numbers of parameters in a function/class constructor. Let''s
    have a look. The following is a program applying *map delegation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The program is simple enough; we defined a `Book` data class, and in the constructor,
    instead of taking all member values one by one, we took a map and then delegated
    all to the map delegate.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to be cautious here is to mention all member variables in the map,
    and the key name should exactly match the property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01d55125-05ae-49c3-a258-dbc919e5606d.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple enough, isn't it? Yes, delegations are that much powerful. But are you
    curious about what will happen if we skip mentioning any of the properties in
    the map? It will simply avoid the properties you skipped, and if you explicitly
    try to access them, then it'll throw an exception—`java.util.NoSuchElementException`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have seen the standard delegations available with
    Kotlin. However, Kotlin does allow us to write our own custom delegates, to suit
    our custom needs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the program, where we checked for the `Even` with `Delegates.vetoable`,
    we could only discard the value assignment, but there's no way to automatically
    assign the next even number to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the following program, we used `makeEven`, a custom delegate which would
    automatically assign the next even number if an odd number is passed to the assignment,
    otherwise if an even number is passed to the assignment, it would pass that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59858d6f-3f44-44e2-9a36-1fbbd54cfd42.png)'
  prefs: []
  type: TYPE_IMG
- en: The output clearly shows that whenever we assigned an even number to `myEven`,
    it got assigned, but when we assigned an odd number, the next even number (`+1`)
    got assigned.
  prefs: []
  type: TYPE_NORMAL
- en: For this delegate, we used almost the same lambda as the `Delegates.observable` we
    just added one more parameter—`wasEven:Boolean`, which will contain `true` if
    the assigned number was even, or `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eager to know how we created the delegate? Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For creating a delegate on `var` properties, you need to implement the `ReadWriteProperty`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: That interface has two functions to be overridden—`getValue` and `setValue`.
    These functions are actually delegated functions of the getters and setters of
    the property. You can return your desired value from the `getValue` function,
    which will then be forwarded as the return value of the property. Every time the
    property is accessed, the `getValue` function will be called. Similarly, every
    time the property is assigned a value, the `setValue` function will get called,
    and whatever we return from the `setValue` function will actually be the value
    the property is finally assigned. For example, assume a property `a` is assigned `X`,
    but from the `setValue` function, we returned `Y`, so after the assignment statement,
    the property `a` will actually hold `Y` instead of `X`.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to return the property's value from your delegate's `getValue`
    function, you must keep the value of the property stored somewhere (yes, you would
    not be able to pull the value from the original property, maybe because the original
    property will not even store the value, as the property knows that it would be
    delegated). In this program, we used a mutable `var` property—`value`, to store
    the value of the property. We are returning `value` from the `getValue` function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `setValue` function, we checked whether the assigned `newValue` is
    even or not. If even, we assigned that `newValue` to the value property (which
    will be returned from the `getValue` function), and if the `newValue` is odd,
    we assigned `newValue+1` to the `value` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MakeEven` class, we have an abstract function—`afterAssignmentCall`.
    We called this function during the end of the `setValue` function. This function
    is meant for logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the delegate is almost ready, but what about the abstract function? We
    need to extend this class to apply the delegate, right? But remember the code
    where we used it like `by makeEven(0) {...}`, so there must be a function there,
    mustn''t there? Yes, there''s a function, the following is the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We created an anonymous object of `MakeEven` and passed it as a delegate, and
    we passed the argument lambda—`onAssignment`, as the abstract function—`afterAssignmentCall`.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've got to grip with delegates, let's move ahead and try our hands on
    some more interesting aspects of delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Local delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Delegation is powerful, we''ve already seen that, but think of a common situation
    where inside a method we declare and initialize a property, then we apply a logic
    which will either use the property or will continue without it. For example, the
    following is such a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we will use the `localDelegate` property, only if the `shouldPrint` value
    is `true`, else we won't use it. But it would always take space in memory since
    it is declared and initialized. An option to avoid this memory blockage is to
    have the property inside the `if` block, but it's a simple dummy program, and
    here we can easily afford to move the variable declaration inside the `if` block,
    whereas in many real-life scenarios, moving the variable declaration inside the `if`
    block is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's the solution? Yes, using `lazy` delegation can save our life here.
    But it wasn't possible in Kotlin before the arrival of Kotlin 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the following is the updated program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Though we only used `lazy` for this example, from Kotlin 1.1, we can have any
    delegation applied in local properties.
  prefs: []
  type: TYPE_NORMAL
- en: Class delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class delegation is another interesting feature of Kotlin. How? Just think of
    the following situation.
  prefs: []
  type: TYPE_NORMAL
- en: You have an interface, *I*, and two classes, *A* and *B*. Both *A* and *B* implement *I*.
    In your code, you've an instance of *A* and you want to create an instance of
    *B* from that *A*.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional inheritance, it is not directly possible; you have to write a
    bunch of nasty codes to achieve that, but class delegation is there to save you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we created the instance of `User`, with its member property—`person`,
    which is an instance of the `Person` interface. In the main function, we passed
    an instance of `PersonImpl` to the user to create the instance of `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, have a look at the declaration of `User`. After color (`:`), the phrase
    `Person by person` indicates that the class `User` extends `Person` and is expected
    to copy `Person` behaviors from the provided `person` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47465d12-c4c5-46c2-aeab-eb0f50f470a0.png)'
  prefs: []
  type: TYPE_IMG
- en: The output shows the overriding works as expected, and we can also access properties
    and functions of the `person`, just like a normal property.
  prefs: []
  type: TYPE_NORMAL
- en: A really awesome feature, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about delegates and we saw how to use delegates
    in various ways to make our code efficient and clean. We learned about different
    features and parts of delegates, and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about coroutines, a path-breaking feature of Kotlin, to
    enable seamless asynchronous processing while keeping the developer's life easy
    and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: So, don't wait long, start with the next chapter now.
  prefs: []
  type: TYPE_NORMAL
