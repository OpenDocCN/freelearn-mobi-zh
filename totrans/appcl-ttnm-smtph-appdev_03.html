<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Integrating Google Maps and GPS</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding a MapView to your application</li><li class="listitem" style="list-style-type: disc">Getting your current position with Geolocation</li><li class="listitem" style="list-style-type: disc">Converting addresses to latitude and longitude positions</li><li class="listitem" style="list-style-type: disc">Adding annotations to your MapView</li><li class="listitem" style="list-style-type: disc">Customizing annotations and capturing MapView events</li><li class="listitem" style="list-style-type: disc">Monitoring your heading using the device compass</li><li class="listitem" style="list-style-type: disc">Drawing routes on your MapView</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Introduction</h1></div></div></div><p>Applications that utilize maps and location-based technology are second only to games and entertainment in sheer numbers of users and downloads on the iTunes store. This popularity with consumers is no surprise considering the multitude of uses we have found for them so far. From apps that help us navigate in the car and on foot, to being able to find a coffee shop or restaurant close by, the uses of this technology are truly only just being explored.<a id="id108" class="indexterm"/>
</p><p>Titanium exposes the building blocks of this technology for us through the tight integration of Google Maps and GPS-based services for both the iPhone and the Android platform. Built-in geo-location, reverse geo-location and point-to-point routing are accessible all through Titanium's native API set. With these tools at your disposal, you can build anything from a store location finder to augmented reality applications.<a id="id109" class="indexterm"/>
</p><p>Throughout the course of this chapter, we will introduce all of these core mapping concepts and use them to put together an exercise tracker app which will access our location at certain points and provide us feedback on how far we have traveled.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec01"/>Pre-requisites</h2></div></div></div><p>You should already be familiar with Titanium basics, including creating UI objects and using Titanium Studio. Additionally, it would be useful to have a basic understanding of how latitude and longitude positioning works, which is the standardized method of calculating the position of a person or object anywhere on Earth.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Adding a MapView to your application</h1></div></div></div><p>Maps have become ubiquitous throughout all levels of technology. We now have real-time maps available everywhere from our computers, to our cars, the Web, and of course mobile devices. Google Maps is the most common platform implementation and the one both Android and the iPhone platforms utilize. In our first recipe for this chapter, we'll be implementing a MapView, and providing it with regional co-ordinates in the form of longitude and latitude values.<a id="id110" class="indexterm"/>
</p><p>If you are intending to follow the entire chapter and build the<strong> Exercise Tracker</strong> app, then pay careful attention to the first<em> Getting ready</em> section for this recipe, as it will guide you through setting up the project.<a id="id111" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec02"/>Getting ready</h2></div></div></div><p>To prepare for this recipe, open up Titanium Studio and log in if you have not already done so. If you need to register a new account, you can do so for free directly from within the application. Once you are logged in, click on<strong> New Project</strong>, and the details window for creating a new project will appear. Enter in<code class="literal"> Exercise Tracker</code> as the name of the app, and fill in the rest of the details with your own information.</p><div><h3 class="title"><a id="note17"/>Note</h3><p>Pay attention to the app identifier, which is written normally in reverse domain notation (that is<em> com.packtpub.exercisetracker)</em>. This identifier cannot be easily changed after the project is created and you will need to match it<em> exactly</em> when creating provisioning profiles for distributing your apps later on.</p></div><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 3/Recipe 1</code> folder, while complete source code for this entire chapter can be found in the<code class="literal"> /Chapter 3/Exercise Tracker</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec03"/>How to do it...</h2></div></div></div><p>Our project has now been created using Titanium Studio. Let's get down to business! Open up the<code class="literal"> app.js</code> file in your editor and remove all existing code. After you have done that, type in the following and then hit save:</p><div><pre class="programlisting">//create the window
var win1 = Titanium.UI.createWindow({
title:'Exercise Tracker',
backgroundColor: '#000'
});
//create our mapview
var mapview = Titanium.Map.createView({
top: 110,
height: 350,
mapType: Titanium.Map.STANDARD_TYPE,
region: {latitude: 51.50015,
longitude:-0.12623,
latitudeDelta:0.5,
longitudeDelta:0.5},
animate: true,
regionFit: true,
userLocation: true
});
//add the map to the window
win1.add(mapview);
//finally, open the window
win1.open();
</pre></div><p>Try running the emulator now for either Android or iPhone. You should see a map appear in the bottom two-thirds of the screen, and after a few seconds it should center on London, England, as shown in the following screenshot. You may also receive a request at this point from the emulator asking if it can use your location. If this appears on your screen, simply select<em> yes</em>.<a id="id112" class="indexterm"/>
</p><div><img src="img/3968EXP_03_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec04"/>How it works…</h2></div></div></div><p>Most of this code should be pretty familiar to you by now. We have created a<code class="literal"> Window</code> object and added another object of type MapView to that window, before opening it via the<code class="literal"> win1.open()</code> method. The MapView itself has a number of new properties that are relevant and significant only to it. These include:<a id="id113" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">region:</code> The region property accepts an array of parameters, which contain the latitude and longitude points that we wish to center the map on, as well as latitude and longitude delta values. The delta values indicate the zoom level of the map according to its centered location.<a id="id114" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">userLocation:</code> This Boolean value will turn on or off the blue<em> dot</em> indicator (an arrow on Android devices), which indicates where you are in relation to the MapView. It's important to note that this will probably not function in the emulator due to its inability to properly ascertain your current position.<a id="id115" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">animate:</code> This Boolean value will turn zooming and movement animation on or off in the MapView. Useful in the event of targeting older devices with low processing power and/or low bandwidth.<a id="id116" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">regionFit:</code> A Boolean that indicates whether the selected region fits the view dimensions given.<a id="id117" class="indexterm"/></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec05"/>There's more...</h2></div></div></div><p>After adding the Map view to your application, let's look at how we can make changes to the MapView's style.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec01"/>Changing your MapView's style</h3></div></div></div><p>There are actually a number of different MapView types you can add to your application, all accessible via the<code class="literal"> TITANIUM.MAP</code> enumerator. The full set of map types available are as follows:<a id="id118" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TITANIUM.MAP.STANDARD_TYPE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TITANIUM.MAP.SATELLITE_TYPE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TITANIUM.MAP.HYBRID_TYPE</code></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Getting your current position using GeoLocation</h1></div></div></div><p>Our map may be working, but it is currently hardcoded to appear above London, England, and not all of us merry chaps work for Her Majesty. One of the great things about mapping technology is that we can determine our location from anywhere in the world via GPS satellites and, when GPS fails, mobile tower signals. This allows us to put maps into context, and let's you issue data to your user that is targeted to their environment.</p><p>In order to get our current location, we need to use the<code class="literal"> Titanium.Geolocation</code> namespace, which contains a method called<code class="literal"> getCurrentPosition</code>. The next recipe will explain how to use this namespace to adjust the bounds of our MapView to our current location.<a id="id119" class="indexterm"/>
</p><div><h3 class="title"><a id="note18"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 3/Recipe 2</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec06"/>How to do it...</h2></div></div></div><p>Add in the following code after you have added your MapView component to the window:<a id="id120" class="indexterm"/>
</p><div><pre class="programlisting">//set the distance filter
Titanium.Geolocation.distanceFilter = 10;
//apple now requires this parameter so it can inform the user //of why you are accessing their location data
Ti.Geolocation.purpose = "To obtain user location for tracking distance travelled.";
Titanium.Geolocation.getCurrentPosition(function(e)
{
if (e.error)
{
//if mapping location doesn't work, show an alert
alert('Sorry, but it seems geo location
is not available on your device!');
return;
}
//get the properties from Titanium.GeoLocation
var longitude = e.coords.longitude;
var latitude = e.coords.latitude;
var altitude = e.coords.altitude;
var heading = e.coords.heading;
var accuracy = e.coords.accuracy;
var speed = e.coords.speed;
var timestamp = e.coords.timestamp;
var altitudeAccuracy = e.coords.altitudeAccuracy;
//apply the lat and lon properties to our mapview
mapview.region = {latitude: latitude,
longitude: longitude,
latitudeDelta:0.5,
longitudeDelta:0.5
};
});
</pre></div><p>Run your app in the emulator now and you should have a screen appear that looks similar to the following screenshot. Note that if you run the code in the emulator, the map will zoom to your current location but will not show the blue dot indicating your current location. You will need to run the application on a device in order to see the full results of this recipe.<a id="id121" class="indexterm"/>
</p><div><img src="img/3968EXP_03_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec07"/>How it works…</h2></div></div></div><p>Getting our current position is simply a matter of calling the<code class="literal"> getCurrentPosition</code> method of the<code class="literal"> Titanium.Geolocation</code> namespace, and capturing the properties returned when this event fires. All of the information we need is then accessible via the<code class="literal"> coords</code> property of the event object<code class="literal"> (e)</code>. In the source code mentioned in the previous example, we have set a number of these properties to variables, some of which we will use in our Exercise Tracker application later on. Finally, we have taken the latitude and longitude properties from the<code class="literal"> coords</code> object and reset the MapView's<code class="literal"> region</code> according to these new values. The distance filter property being set determines how accurate you want your GPS location/position to be. In our case, we have set it to 10 meters, which is accurate enough for our purposes.<a id="id122" class="indexterm"/>
</p><div><h3 class="title"><a id="tip04"/>Tip</h3><p>An important note for iPhone applications…</p><p>The second line in our block of code is a new requirement from Apple. It states that you must define exactly why you are requesting a user's location. This is there for your user's privacy and safety, so don't forget to add this line whenever you are using Geolocation, or Apple will probably reject your app from the iTunes store!</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec04"/>Converting addresses to latitude and longitude positions</h1></div></div></div><p>Getting our location is all well and good when it's done for us, but humans don't think of places in terms of latitude and longitude values, we use good old addresses to define points on a map. To convert addresses to latitude and longitude decimal values, we can again use the<code class="literal"> Titanium.Geolocation</code> namespace, and specifically a method in it called<code class="literal"> forwardGeocoder</code>. Titanium has built-in methods for geo-coding, which utilize and essentially ''black box'' the services provided by the Google Maps API. The Google Geocoding API processes the converting addresses (such as "1600 Amphitheatre Parkway, Mountain View, CA") into geographic coordinates (for example, latitude: 37.423021 and longitude: 122.083739), which you can use to place markers or position the map. The Google Geocoding API provides a direct way to access a geocoder via an HTTP request.<a id="id123" class="indexterm"/>
</p><div><h3 class="title"><a id="note19"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 3/Recipe 3</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec08"/>How to do it...</h2></div></div></div><p>First, we need to create some input fields so that the user can provide us with a starting and an ending address. Let's create a new View and add it to the top of our window above the<code class="literal"> MapView</code>. We'll also need to add a button to fire off the<code class="literal"> forwardGeocoder</code> conversion. The background gradient image for the View is available within the<code class="literal"> images</code> folder of the source code:<a id="id124" class="indexterm"/>
</p><div><pre class="programlisting">//create the search view
var searchview = Titanium.UI.createView({
top: 0,
left: 0,
width: 320,
height: 110,
backgroundImage: 'images/gradient.png'
});
//style it up a bit
var bottomBorder = Titanium.UI.createView({
height: 1,
width: 320,
left: 0,
bottom: 0,
backgroundColor: '#000'
});
searchview.add(bottomBorder);
//add a search box for starting location
var txtStartLocation = Titanium.UI.createTextField({
backgroundColor: '#fff',
left: 10,
top: 20,
width: 200,
height: 30,
borderColor: '#000',
borderRadius: 5,
hintText: 'Current Location',
paddingLeft: 10
});
searchview.add(txtStartLocation);
//add a search box for starting location
var txtEndLocation = Titanium.UI.createTextField({
backgroundColor: '#fff',
left: 10,
top: 60,
width: 200,
height: 30,
borderColor: '#000',
borderRadius: 5,
hintText: 'End Location',
paddingLeft: 10
});
searchview.add(txtEndLocation);
//add the button with an empty click event, this will fire off
//our forwardGeocoder
var btnSearch = Titanium.UI.createButton({
width: 80,
height: 30,
top: 60,
right: 10,
backgroundImage: 'images/search.png',
borderRadius: 3
});
//btnsearch event listener fires on button tap
btnSearch.addEventListener('click',function(e){
});
searchview.add(btnSearch);
</pre></div><p>Now, as we have some input fields, let's use the search button to capture those addresses and convert them into location values that we can use to define the region of our<code class="literal"> MapView</code>. Put the next block of code into your button's<code class="literal"> click</code> event handler:<a id="id125" class="indexterm"/>
</p><div><pre class="programlisting">//btnsearch event listener fires on button tap
btnSearch.addEventListener('click',function(e){
//check for a start address
if(txtStartLocation.value != '')
{
//works out the start co-ords
Ti.Geolocation.forwardGeocoder(txtStartLocation.value, function(e){
//we'll set our map view to this initial region so it
//appears on screen
mapview.region = {latitude: e.latitude,
longitude: e.longitude,
latitudeDelta:0.5,
longitudeDelta:0.5
};
Ti.API.info('Start location co-ordinates are: ' +
e.latitude + ' lat, ' + e.longitude +
'lon');
});
}
else
{
alert('You must provide a start address!');
}
//check for an end address
if(txtEndLocation.value != '')
{
//do the same and work out the end co-ords
Ti.Geolocation.forwardGeocoder(txtEndLocation.value, function(e){
Ti.API.info('End location co-ordinates are: ' + e.latitude + ' lat, ' + e.longitude + ' lon');
});
}
else
{
alert('You must provide an end address!');
}
});
</pre></div><p>Run your app in the emulator and provide a start and an end address, and then hit<strong> search</strong>. After a few seconds you should get the geolocation values of those addresses outputted to the console, and your MapView should re-orientate itself to the region surrounding your starting address. The following screenshot shows the start and end addresses converted to latitude and longitude coordinates being outputted to the Titanium Studio console:<a id="id126" class="indexterm"/>
</p><div><img src="img/3968EXP_03_03.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec09"/>How it works…</h2></div></div></div><p>The first section of code in this recipe is simple. Create a couple of TextFields for the start and end address and capture the click event of a Button component, wherein we pass those address values to our<code class="literal"> Titanium.Geolocation.forwardGeocoder</code> method.<a id="id127" class="indexterm"/>
</p><p>The forward geolocation task is actually performed against Google's servers. Titanium has wrapped this into one simple method for you to call, which saves you having to do the legwork of creating your own HTTP request against Google's server and then manually parsing the response.</p><p>You can try it out manually if you wish by reading the instructions at Google's own website:<a class="ulink" href="http://code.google.com/apis/maps/documentation/geocoding/index.html"> http://code.google.com/apis/maps/documentation/geocoding/index.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec05"/>Adding annotations to your MapView</h1></div></div></div><p>The ability to find locations on a map is extremely useful, but what the user needs is some kind of visual representation of that location on the screen. This is where annotations come in. In the next recipe, we will create annotation pins for both the start and end addresses, using the latitude and longitude values created by our<code class="literal"> forwardGeocoder</code>.<a id="id128" class="indexterm"/>
</p><div><h3 class="title"><a id="note20"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 3/Recipe 4</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec10"/>How to do it...</h2></div></div></div><p>Within your search button function and the<code class="literal"> forwardGeocoder</code> method we called in the previous recipe, add the following code to create an annotation for the start location:</p><div><pre class="programlisting">//works out the start co-ords
Ti.Geolocation.forwardGeocoder(txtStartLocation.value, function(e)
{
//we'll set our map view to this initial region so it appears
//on screen
mapview.region = {latitude: e.latitude,
longitude: e.longitude,
latitudeDelta: 0.5,
longitudeDelta: 0.5
};
Ti.API.info('Start location co-ordinates are: ' +
e.latitude + ' lat, ' + e.longitude + ' lon');
//add an annotation to the mapview for the start location
var annotation = Titanium.Map.createAnnotation({
latitude: e.latitude,
longitude: e.longitude,
title: 'Start location',
subtitle: txtStartLocation.value,
animate:true,
id: 1,
pincolor: Titanium.Map.ANNOTATION_GREEN
});
//add the annotation pin to the mapview
mapview.addAnnotation(annotation);
});
</pre></div><p>Once you have added this code into the<code class="literal"> forwardGeocoder</code> method for the start location, do exactly the same for your end location, except give the end location a<code class="literal">'myid'</code> property value of<code class="literal"> 2</code>. We will use these custom ID values later on when capturing events from our annotations; they will allow us to determine which annotation pin was tapped. Also, for your second annotation, give it a<code class="literal"> pinColor</code> property of<code class="literal"> Titanium.Map.ANNOTATION_RED</code>, as this well help distinguish the two pins on the map.<a id="id129" class="indexterm"/>
</p><p>Load your application in the emulator and give it a start and an end location, then press<strong> search</strong>—you should end up with a couple of pins on your MapView, as shown in the following screenshot:</p><div><img src="img/3968EXP_03_04.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec11"/>How it works...</h2></div></div></div><p>Within your search button function and the<code class="literal"> forwardGeocoder</code> method we called in the previous recipe, is the instantiation of a new object of type<code class="literal"> annotation</code>, using<code class="literal"> Titanium.Map.createAnnotation()</code>. This object represents a pin icon that is dropped onto the map to identify a specific location, and has a number of interesting properties. Apart from the standard longitude and latitude values, it can also accept a title and a secondary title, with the title being displayed more prominently at the top of the annotation and the secondary one below it. You should also give your annotations an<code class="literal"> id</code> property (we have used<code class="literal"> id</code> in this example), so that it is easier to identify them when you are adding events to your<code class="literal"> MapView</code>. This is explained further in the next recipe.<a id="id130" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec06"/>Customizing annotations and capturing MapView events</h1></div></div></div><p>Annotations can also be customized to give the user a better indication of what your location symbolizes. For example, if you were mapping restaurants in a particular area, you may provide each annotation with an icon that symbolized the type of restaurant it was—be it a pizza slice for Italian, a pint for pub food or a hamburger for a fast food chain.<a id="id131" class="indexterm"/>
</p><p>In this recipe, we will add a left image to both the start and end location annotations, using an "S" (for "Start") and an "E" (for "End") icon respectively, to help the user identify them. We will also add a<em> start</em> button to the first pin, and a<em> stop</em> button to the second, which we will use to control our exercise timer later on.<a id="id132" class="indexterm"/>
</p><div><h3 class="title"><a id="note21"/>Note</h3><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 3/Recipe 5</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec12"/>How to do it...</h2></div></div></div><p>After your annotation is declared, but before it is added to your<code class="literal"> mapView</code> object, type in the following code to create a custom<code class="literal"> leftView</code> and custom<code class="literal"> rightButton</code>. You should do the same for both the start location pin and the end location pin.</p><div><pre class="programlisting">//add an image to the left of the annotation
var leftImage = Titanium.UI.createImageView({
image: 'images/start.png',
width: 25,
height: 25
});
annotation.leftView = leftImage;
//add the start button
var startButton = 'images/startbutton.png';
annotation.rightButton = startButton;
mapview.addAnnotation(annotation);
</pre></div><p>Now, let's create the event listener for the<code class="literal"> mapView</code> object. This function will execute when a user taps on any annotation in the map. You should place this code near the bottom of your JavaScript, just before the<code class="literal"> mapView</code> is added to our window:</p><div><pre class="programlisting">//create the event listener for when annotations
//are tapped on the map
mapview.addEventListener('click', function(e){
Ti.API.info('Annotation id that was tapped: ' + e.source.id);
Ti.API.info('Annotation button source that was tapped: ' + e.clicksource);
});
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec13"/>How it works...</h2></div></div></div><p>In this recipe, all we are doing at the beginning is pointing some new properties at each annotation. Our<code class="literal"> leftView</code> is being populated by an<code class="literal"> imageView</code>, using the image icons for "S" and "E" respectively. The annotation also accepts a simple URL string for the<code class="literal"> rightButton</code> property, and it is here that we are providing the "start" and "stop" button image locations (both are to be found in the<code class="literal"> images</code> folder of the source code).<a id="id133" class="indexterm"/>
</p><p>The event listener for the<code class="literal"> mapView</code> works slightly differently as compared to other event listeners. You need to capture an annotation click from the<code class="literal"> mapView</code> parent object and then work out which annotation was tapped by means of a custom ID. In this case, we have used the<code class="literal"> id</code> property to determine which annotation was the start location and which was the end location. The start location is set to<code class="literal"> id 1</code>, while the end location is simply set to<code class="literal"> id 2</code>.</p><p>Additionally, you may wish to perform different actions based on whether the right or left button on the annotation pin was tapped. We can determine this by using the event property's<code class="literal"> (e) clicksource</code>. A comparison to a string of either<code class="literal"> leftButton</code> or<code class="literal"> rightButton</code> will let you know which was tapped and you can program functions into your app accordingly.</p><div><img src="img/3968EXP_03_05.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Drawing routes on your MapView</h1></div></div></div><p>In order to track our movements and draw a route on the map, we need to create an array of points, each with its own latitude and longitude value. The MapView will take in this array of points as a property called route, and draw a series of lines to provide a visual representation of the route to the user.</p><p>In this recipe, we will create a timer that records our location every minute, and adds it to the points array. When each new point is recorded, we will access the Google Directions API to determine the distance and add that to our overall tally of how far we have traveled.<a id="id134" class="indexterm"/>
</p><div><h3 class="title"><a id="note22"/>Note</h3><p>Note that this recipe will not work on Android devices, as there is currently no support for Android routing in Titanium. However, it will work as described here for the iPhone and iPod Touch. There is an unsupported method of routing in Android, which you can read about at<a class="ulink" href="http://bit.ly/pUq2v2"> http://bit.ly/pUq2v2</a>. You will need to use an actual iPhone or iPod Touch device to test this recipe, as the emulator will not be able to get your current location.</p></div><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 3/Recipe 6</code> folder.<a id="id135" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec14"/>How to do it...</h2></div></div></div><p>Within your<code class="literal"> mapView</code> click event, after the console logging to determine which button was tapped and which annotation, type in the following code:</p><div><pre class="programlisting">//create the event listener for when annotations
//are tapped on the map
mapview.addEventListener('click', function(e){
Ti.API.info('Annotation id that was tapped: ' + e.source.id);
Ti.API.info('Annotation button source that was tapped: ' + e.clicksource);
Ti.API.info('Annotation button title that was tapped: ' + e.title);
if(timerStarted == false &amp;&amp; (e.clicksource == 'rightButton' &amp;&amp; e.title == 'Start location'))
{
Ti.API.info('Timer will start...');
points = [];
//set our first point
Ti.Geolocation.forwardGeocoder(txtStartLocation.value, function(e){
points.push({latitude: e.coords.latitude,
longitude: e.coords.longitude
});
route.points = points;
//add route to our mapview object
mapview.addRoute(route);
timerStarted = true;
//start our timer and refresh it every minute
//1 minute = 60,000 milliseconds
intTimer = setInterval(recordCurrentLocation,
60000);
});
}
else
{
//stop any running timer
if(timerStarted == true &amp;&amp;
(e.clicksource == 'rightButton'
&amp;&amp; e.title == 'End location'))
{
clearInterval(intTimer);
timerStarted = false;
alert('You travelled ' + distanceTraveled
+ ' meters!');
}
}
});
</pre></div><p>There are some variables we need to create now that need to be globally accessible to this JavaScript file. Add the following code to the very top of your<code class="literal"> app.js</code> file:<a id="id136" class="indexterm"/>
</p><div><pre class="programlisting">//create the variables
var timerStarted = false;
var intTimer;
//this array will hold all the latitude and
//longitude points in our route
var points = [];
//this will hold the distance traveled
var distanceTraveled = 0;
//route object
var route = {
name: 'Exercise Route',
color: "#00f",
width: 2
};
</pre></div><p>Next, we need to create the function for obtaining the user's new current location and determining how far the new location is from our previous location. Create this new function above the click event for the<code class="literal"> mapView</code> component:</p><div><pre class="programlisting">//this function records the current location and
//calculates distance between it and the last location,
//adding that to our overall distance count
function recordCurrentLocation()
{
Ti.API.info('getting next position...');
points.push({latitude:-27.466175,
longitude:153.030426
});
route.points = points;
//get the current position
Titanium.Geolocation.getCurrentPosition(function(e) {
var currLongitude = e.coords.longitude;
var currLatitude = e.coords.latitude;
points.push({latitude: e.currLatitude, longitude: e.currLongitude});
//add new point to route
route.points = points;
//remove the old route and add this new one
mapview.removeRoute(route);
mapview.addRoute(route);
});
//ask google for the distance between this point
//and the previous point in the points[] array
var url = 'http://maps.googleapis.com/maps/api/directions/json?travelMode=Walking&amp;origin=' + points[points.length-2].latitude + ',' + points[points.length-2].longitude + '&amp;destination=' + points[points.length-1].latitude + ',' + points[points.length-1].longitude + '&amp;sensor=false';
var req = Ti.Network.createHTTPClient();
req.open('GET', url);
req.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
req.onreadystate = function(){};
req.onload = function()
{
//record the distance values
Ti.API.info(req.responseText);
var data = JSON.parse(req.responseText);
Ti.API.info("distance.text " + data.routes[0].legs[0].distance.text);
Ti.API.info("distance.value " + data.routes[0].legs[0].distance.value);
distanceTraveled = distanceTraveled + data.routes[0].legs[0].distance.value;
};
req.send();
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>How it works...</h2></div></div></div><p>There are a number of things happening in this recipe, so let's break them down logically into their separate parts. First, we are obtaining the user's current location again on the start button's<code class="literal"> click</code> event, and adding that as the first point in our<code class="literal"> points</code> array. In order for our<code class="literal"> mapView</code> component to use the array of point locations, we need to create a route object. This route object contains the array of points, plus the visual information such as the route's line, color, and thickness.<a id="id137" class="indexterm"/>
</p><p>From there, we are creating a timer using<code class="literal"> setInterval().</code> This timer will only start when both the<code class="literal"> timerStarted</code> variable is set to false, and when we can determine that the button tapped was indeed the right "start" button on one of our annotations.<a id="id138" class="indexterm"/>
</p><p>Our timer is set to execute every 60 seconds, or as required by the code, 60,000 milliseconds. This means that every minute the function called<code class="literal"> recordCurrentLocation()</code> will be executed. This function does the processing for determining our current location, and adds the new location to our "points" array. It then performs an HTTP request call to the Google APIs, which performs a distance calculation between our newest point, and the point location that we were at previously. This new distance is added to our total distance variable, called<code class="literal"> distanceTraveled</code>.<a id="id139" class="indexterm"/>
</p><p>Finally, whenever the user taps the<em> stop</em> button on the end annotation, the timer is stopped and the user is presented with an<code class="literal"> alertDialog</code> showing the total value for how far they have traveled in meters. The following screenshot shows the route being drawn from our start to end location, and then the alert with the distance traveled when the<em> stop</em> button is tapped.</p><div><img src="img/3968EXP_03_06.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec08"/>Monitoring your heading using the device compass</h1></div></div></div><p>In this recipe, our final recipe for our chapter on Maps and GPS, we will be using the inbuilt device compass to determine your heading. We'll present that heading using an image of an arrow to represent the direction visually.<a id="id140" class="indexterm"/>
</p><div><h3 class="title"><a id="note23"/>Note</h3><p>Note that this recipe will not work on older iPhone devices, such as the iPhone 3G, which lack the compass. You will need to use an actual device to test this recipe, as the emulator will not be able to get your current heading either.</p></div><p>Complete source code for this recipe can be found in the<code class="literal"> /Chapter 3/Recipe 7</code> folder.</p><p>Complete source code for the Exercise Tracker application built in this chapter can be found in the<code class="literal"> /Chapter 3/Exercise Tracker</code> folder.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>How to do it...</h2></div></div></div><p>Add the following code to your<code class="literal"> app.js</code> file, just before you perform a<code class="literal"> win1.open()</code> method call at the end of the file:<a id="id141" class="indexterm"/>
</p><div><pre class="programlisting">//this image will appear over the map and indicate our
//current compass heading
var imageCompassArrow = Titanium.UI.createImageView({
image: 'images/arrow.gif',
width: 50,
height: 50,
right: 25,
top: 5
});
win1.add(imageCompassArrow);
//how to monitor your heading using the compass
if(Titanium.Geolocation.hasCompass)
{
//this is the degree of angle change our heading
//events don't fire unless this value changes
Titanium.Geolocation.headingFilter = 90;
//this event fires only once to get our intial
//heading and to set our compass "arrow" on screen
Ti.Geolocation.getCurrentHeading(function(e) {
if (e.error) {
return;
}
var x = e.heading.x;
var y = e.heading.y;
var z = e.heading.z;
var magneticHeading = e.heading.magneticHeading;
accuracy = e.heading.accuracy;
var trueHeading = e.heading.trueHeading;
timestamp = e.heading.timestamp;
var rotateArrow = Titanium.UI.create2DMatrix();
var angle = 360 - magneticHeading;
rotateArrow = rotateArrow.rotate(angle);
imageCompassArrow.transform = rotateArrow;
});
//this event will fire repeatedly depending on the change
//in angle of our heading filter
Titanium.Geolocation.addEventListener('heading',function(e) {
if (e.error) {
return;
}
var x = e.heading.x;
var y = e.heading.y;
var z = e.heading.z;
var magneticHeading = e.heading.magneticHeading;
accuracy = e.heading.accuracy;
var trueHeading = e.heading.trueHeading;
timestamp = e.heading.timestamp;
var rotateArrow = Titanium.UI.create2DMatrix();
var angle = 360 - magneticHeading;
rotateArrow = rotateArrow.rotate(angle);
imageCompassArrow.transform = rotateArrow;
});
}
else
{
//log an error to the console if this device has no compass
//older devices such as the iphone 3g don't have this
Titanium.API.info("No Compass on device");
//you can uncomment this to test rotation when using the emulator
//var rotateArrow = Titanium.UI.create2DMatrix();
//var angle = 45;
//rotateArrow = rotateArrow.rotate(angle);
//imageCompassArrow.transform = rotateArrow;
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>How it works...</h2></div></div></div><p>We are first creating an<code class="literal"> imageView</code> and setting its image property to our arrow image. Initially, this will face towards the top of the screen, and will indicate north. This<code class="literal"> imageView</code> is then added to our<code class="literal"> Window</code> object. The heading source code for this recipe is performing two similar tasks: one gets our<em> initial</em> heading and the second fires on set intervals to get our<em> current</em> heading. When the heading is obtained for either the current position or the new position, we use the<code class="literal"> magneticHeading</code> property to determine the angle (direction) in which we are facing, and use a simple transformation to rotate the arrow in that direction.<a id="id142" class="indexterm"/>
</p><div><h3 class="title"><a id="note24"/>Note</h3><p>Don't worry if you don't understand what a 2D matrix is, or how the transformation is performing the rotation of our image! We will be covering transformations, rotations, and animations in<a class="link" href="ch07.html" title="Chapter 7. Creating Animations, Transformations, and Understanding Drag-and-drop"> Chapter 7</a>,</p></div></div></div></body></html>