<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;Autonomous Moving Agents"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Autonomous Moving Agents</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Introduction to steering behaviors</li><li class="listitem">Implementing seek</li><li class="listitem">Implementing flee</li><li class="listitem">Implementing arrive</li><li class="listitem">Implementing evade</li><li class="listitem">Implementing wander</li><li class="listitem">Implementing wall avoidance</li><li class="listitem">Obstacle avoidance</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Autonomous Moving Agents">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec47" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">Games are interesting as they are challenging in each and every level. To make a game interesting, it's important to increase the difficulty of the game at each level. It's always interesting to defeat something in the game. In this chapter, we will learn about various ways to create the autonomous behavior for game objects. This chapter has a bunch of recipes to demonstrate the artificially intelligent game objects. To understand all the concepts in detail, it is recommended to read the previous chapter, which gives you a grip on mathematics and physics. Each recipe will allow you to understand and learn a specific autonomous behavior. By the end of this chapter, you will be able to understand and implement various autonomous game behaviors.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Introduction to steering behaviors"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec48" class="calibre1"/>Introduction to steering behaviors</h1></div></div></div><p class="calibre8">AI characters<a id="id344" class="calibre1"/> are a type of autonomous agent that is intended to be used in computer games for showing virtual reality. These agents represent a character in a story or game and have some ability to follow some pre-set actions. Actions of these characters are directed in real time by a human player or participant. In games, autonomous characters are sometimes called non-player or artificially intelligent characters. An AI character<a id="id345" class="calibre1"/> always has some aspects of an autonomous robot with some predefined skills such as either they will be seeking some characters in the game or they will evade themselves from the playing character. All these behaviors are called steering behaviors.</p></div>

<div class="book" title="Introduction to steering behaviors">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec114" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">In this chapter, we will create a<a id="id346" class="calibre1"/> new game to demonstrate all the steering behaviors. To get started with the implementation, let us create a new project. Open Xcode and go to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">New</strong></span> | <span class="strong"><strong class="calibre2">Project</strong></span>, and then select <span class="strong"><strong class="calibre2">iOS</strong></span> | <span class="strong"><strong class="calibre2">Application</strong></span> | <span class="strong"><strong class="calibre2">SpriteKit Game</strong></span>. In the pop up provide the <span class="strong"><strong class="calibre2">Product Name</strong></span> as <code class="email">SteeringBehaviors</code>, select <span class="strong"><strong class="calibre2">Devices</strong></span> | <span class="strong"><strong class="calibre2">iPhone</strong></span>, and <a id="id347" class="calibre1"/>click on <span class="strong"><strong class="calibre2">Next</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00136.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Introduction to steering behaviors">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec115" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Now we have<a id="id348" class="calibre1"/> our working sample project and we need to update the game template project to get started with code game logic. Perform the following steps to start working with the basic code flow for the game:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">GameViewController.m</code> file and update the <code class="email">viewDidLoad</code> method; remove all the code from this class and make it look something similar to the following lines of code:<div class="informalexample"><pre class="programlisting">- (void)viewDidLoad {
    [super viewDidLoad];

    // Configure the view.
    SKView * skView = (SKView *)self.view;
    skView.showsFPS = YES;
    skView.showsNodeCount = YES;
    
    // Create and configure the scene.
    SKScene * scene = [GameScene sceneWithSize:skView.bounds.size];
    scene.scaleMode = SKSceneScaleModeAspectFill;
    
    // Present the scene.
    [skView presentScene:scene];
}</pre></div></li><li class="listitem" value="2">Open the <code class="email">GameScene.m</code> file; this class creates a scene, which will be plugged inside the game. Now, remove all the codes from this class and just add the following function:<div class="informalexample"><pre class="programlisting">-(id)initWithSize:(CGSize)size {  
if (self = [super initWithSize:size]) {
    self.backgroundColor = [SKColor colorWithRed:0.15 green:0.15 blue:0.3 alpha:1.0];  
}
}</pre></div></li><li class="listitem" value="3">Now, compile and run the app; you should be able to see the background image correctly. This will look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00137.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Now we <a id="id349" class="calibre1"/>will need one AI character on which we will be implementing all our AI behaviors. So, we will create a new subclass of <code class="email">SKSpriteNode</code> with the name <code class="email">Player</code>. Go to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">New</strong></span> | <span class="strong"><strong class="calibre2">File</strong></span>, then select <span class="strong"><strong class="calibre2">iOS</strong></span> | <span class="strong"><strong class="calibre2">Source</strong></span> | <span class="strong"><strong class="calibre2">Cocoa Touch Classes</strong></span>, and click on <span class="strong"><strong class="calibre2">Next</strong></span>. Now, change the <span class="strong"><strong class="calibre2">Subclass of</strong></span> to <span class="strong"><strong class="calibre2">SKSpriteNode</strong></span>, and <span class="strong"><strong class="calibre2">Class</strong></span> name as <code class="email">Player</code>. The final screen should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00138.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">Now, open<a id="id350" class="calibre1"/> the <code class="email">Player.m</code> file, and add the following code after <code class="email">@implementation</code>:<div class="informalexample"><pre class="programlisting">+ (Player*) playerObject {
    // Create a new critter, and give it a name
    Player* obj = [Player spriteNodeWithColor:[SKColor whiteColor] size:CGSizeMake(30, 30)];
    obj.name = @"GamePlayer";
    return obj;
}

- (void) update:(float)deltaTime {

}</pre></div></li><li class="listitem" value="6">Now, add the declaration of both the methods in the <code class="email">Player.h</code> file using the following code:<div class="informalexample"><pre class="programlisting">+ (Player*) playerObject;
- (void) update:(float)deltaTime;</pre></div></li><li class="listitem" value="7">Now, open your <code class="email">GameScene.m</code> file and add the following code right after your <code class="email">initWithSize</code> method:<div class="informalexample"><pre class="programlisting">- (Player *)createPlayer
{
    Player *plyr = [Player playerObject];
    [self addChild:plyr];
    
    return plyr;
}</pre></div></li><li class="listitem" value="8">Now, add<a id="id351" class="calibre1"/> the <code class="email">touchesBegan</code> method just after the <code class="email">createPlayer</code> method. This method will give you all the touch events.</li><li class="listitem" value="9">So, nothing happened till now. Let's make the game work for the first state. Now, add the following code:<div class="informalexample"><pre class="programlisting">Player *newPlayer = [self createPlayer];
newPlayer.position = [touch locationInNode:self];</pre></div></li></ol><div class="calibre14"/></div><p class="calibre8">The final file should look something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00139.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now, compile and run the project. Touch on any location and you will see the square box is created on that location. Multiple sprites are added to the scene on the tap action. The output should look something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00140.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now we have <a id="id352" class="calibre1"/>a separate class for our player. This approach will help us to isolate all the features of the game character. Similarly, when we take the games to next levels, these are very useful as we can isolate the behaviors for various types of AI characters.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementing the seek"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec49" class="calibre1"/>Implementing the seek</h1></div></div></div><p class="calibre8">To <a id="id353" class="calibre1"/>implement the seek behavior<a id="id354" class="calibre1"/> for our player, we will need a derive force that will redirect the agent toward a target position. In the seek behavior, our character will overshoot the target because the force applied on the player will be more, which will make the player overshoot the target and then return to the target. It will take a finite amount of time before coming to rest.</p></div>

<div class="book" title="Implementing the seek">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec116" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Seek behavior is something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00141.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The preceding<a id="id355" class="calibre1"/> image explains the algorithm that will be used to implement the seek behavior. In our case, we will need to seek to the target and have to follow the following algorithm:</p><p class="calibre8">
<span class="strong"><em class="calibre9">Vector desiredVelocity = targetVector – player.locationVector;</em></span>
</p><p class="calibre8">
<span class="strong"><em class="calibre9">desiredVelocity.normalize;</em></span>
</p><p class="calibre8">
<span class="strong"><em class="calibre9">desiredVelocity *= player.maxSpeed;</em></span>
</p><p class="calibre8">
<span class="strong"><em class="calibre9">return (desiredVelocity – agent.locationVector);</em></span>
</p></div></div>

<div class="book" title="Implementing the seek">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec117" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Now we will start again on the project to implement the seek behaviors. Now, follow the steps below to implement the seek behavior:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">Player.m</code> file and add the <code class="email">enum</code> function on the top, after the import statements:<div class="informalexample"><pre class="programlisting">typedef enum : NSUInteger {
    Seek,
    Arrive,
    Flee,
    Wander,
    Evade
} SteeringBehaviorType;</pre></div></li><li class="listitem" value="2">Then, add the following code after your interface:<div class="informalexample"><pre class="programlisting">@property (assign) SteeringBehaviorType behaviourType;
@property (assign) CGPoint target;</pre></div><p class="calibre15">The <code class="email">enum</code> holds the behavior we want to implement. Whenever we add any behavior, we will have to add it to this <code class="email">enum</code>.</p><p class="calibre15">The target property will hold the location where we want the player to seek and <code class="email">behaviourType</code> will tell us which behavior we want to implement.</p></li><li class="listitem" value="3">Now, to<a id="id356" class="calibre1"/> implement the seek, add the following function:<div class="informalexample"><pre class="programlisting">- (void) seek:(CGPoint )target deltaTime:(float)deltaTime {
    
    // Work out the direction to this position
    GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);
    GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);
    
    GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);
    
    // Reduce this vector to be the same length as our movement speed
    offset = GLKVector2Normalize(offset);
    offset = GLKVector2MultiplyScalar(offset, 10);
    
  [self.physicsBody applyForce:CGVectorMake(offset.x, offset.y)];
}</pre></div></li><li class="listitem" value="4">Now, add the following code in the update function:<div class="informalexample"><pre class="programlisting">if (self.behaviourType == Seek) {
  [self seek:self.target deltaTime:deltaTime];
}</pre></div><p class="calibre15">This function will be executed if the player behavior is set as seek.</p></li><li class="listitem" value="5">Now we are all set to test the function we have written in the previous few steps. So, open the <code class="email">GameScene.m</code> file and create the instance of the <code class="email">newPlayer</code> object at the top of the implementation file. The implementation code should look like the following:<div class="informalexample"><pre class="programlisting">@implementation GameScene {
    float lastTime;
    Player * newplayer;
    SteeringBehaviorType behaviourType;
}</pre></div></li><li class="listitem" value="6">Also, add the following line of code in the <code class="email">init</code> method we have written earlier:<div class="informalexample"><pre class="programlisting">self.physicsWorld.gravity = CGVectorMake(0, 0);
        
newplayer = [self createPlayer];
newplayer.position = CGPointMake(size.width/2, size.height/2);

behaviourType = Seek;
newplayer.behaviourType = behaviourType;

if (behaviourType == Seek) {
    newplayer.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:CGSizeMake(30, 30)];
    newplayer.physicsBody.friction = 1.0f;
    newplayer.physicsBody.linearDamping = 1.0f;
}</pre></div><p class="calibre15">The final <a id="id357" class="calibre1"/>init function should look something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00142.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p><p class="calibre15">We have created a <code class="email">newPlayer</code> object and have also associated the physics body with it.</p></li><li class="listitem" value="7">Now we<a id="id358" class="calibre1"/> have our player ready to seek the target. Wherever we tap on the screen, the player will seek to that location. In the <code class="email">touchesBegain:withEvent</code> method, add the following line of code:<div class="informalexample"><pre class="programlisting">for (UITouch *touch in touches) {
    CGPoint location = [touch locationInNode:self];
    NSLog(@"%@", NSStringFromCGPoint(location));
    
    newplayer.target = location;
}</pre></div></li><li class="listitem" value="8">So, now we are all set for the seek behavior. So, finally, we will call the player's update method on every update of the scene, so that the player can seek to the location a user has tapped on. To perform this add the following code:<div class="informalexample"><pre class="programlisting">-(void)update:(CFTimeInterval)currentTime {
   /* Called before each frame is rendered */
    
    if (!CGPointEqualToPoint(newplayer.target, CGPointZero)) {
        float deltaTime = currentTime - lastTime;
        [newplayer update:deltaTime];
        lastTime = currentTime;
    }
}</pre></div><p class="calibre15">In the above line of code, we are calling the update function on each and every <code class="email">newPlayer</code> object.</p></li><li class="listitem" value="9">Now, compile and run the project; you will see the player in the center of the screen and it will seek the location that you will tap on the screen. The output should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00143.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div><p class="calibre8">This completes<a id="id359" class="calibre1"/> our seek behavior for the player object.</p></div></div>

<div class="book" title="Implementing the seek">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec118" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">You can read all these properties in more detail at Apple's developer documentation at <a class="calibre1" href="https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html">https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementing flee"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec50" class="calibre1"/>Implementing flee</h1></div></div></div><p class="calibre8">Flee is <a id="id360" class="calibre1"/>the opposite of the seek behavior, which steers the vehicle in the <a id="id361" class="calibre1"/>opposite direction from the target. Instead of producing the force toward target, we will push the player off to the target as the object has to flee from the target.</p></div>

<div class="book" title="Implementing flee">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec119" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To<a id="id362" class="calibre1"/> implement the flee behavior, we need to flee to the target and follow the following algorithm:</p><div class="informalexample"><pre class="programlisting">Vector desiredVelocity = player.locationVector - targetVector;
desiredVelocity.normalize;
desiredVelocity *= player.maxSpeed;
return (desiredVelocity – agent.locationVector);</pre></div><p class="calibre8">In the preceding algorithm, we are calculating the force that will be needed to flee the object off from <a id="id363" class="calibre1"/>the screen. First, we will calculate the direction vector to determine the direction opposite to the player, so that our object can flee from the target in that location. Now, in the second step, we normalize the vector and increase its magnitude to its max speed. Using this algorithm, we will implement the flee behavior for our object. </p></div></div>

<div class="book" title="Implementing flee">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec120" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Perform the following steps to implement the flee behavior in the game:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the Player.m file and add the following line of code just after the seek function:<div class="informalexample"><pre class="programlisting">- (void) flee:(CGPoint )target deltaTime:(float)deltaTime {
    
    // Work out the direction to this position
    GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);
    GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);
    
    GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);
    
    // Reduce this vector to be the same length as our movement speed
    offset = GLKVector2Normalize(offset);
    offset = GLKVector2MultiplyScalar(offset, -10);
    
    [self.physicsBody applyForce:CGVectorMake(offset.x, offset.y)];
}</pre></div></li><li class="listitem" value="2">Now, add the following code in the update function after the seek code:<div class="informalexample"><pre class="programlisting">if (self.behaviourType == Flee) {
    [self flee:self.target deltaTime:deltaTime];
}</pre></div></li><li class="listitem" value="3">Now, our function is ready to flee the player. This function will accept a target from which it will flee. So, once again, we will be using the same approach, and when the user will tap on the screen, we will make the object flee from the tapped point. The final <code class="email">Player.m</code> file should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00144.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Now <a id="id364" class="calibre1"/>our <code class="email">Player.m</code> class is ready to execute the flee behavior. So, open the <code class="email">GameScene.m</code> file and take the following line of code:<div class="informalexample"><pre class="programlisting">behaviourType = Seek;</pre></div><p class="calibre15">Then, replace this with the following line of code:</p><div class="informalexample"><pre class="programlisting">behaviourType = Flee;</pre></div><p class="calibre15">And also, add the following code:</p><div class="informalexample"><pre class="programlisting">if (behaviourType == Seek)</pre></div><p class="calibre15">Then, update the <code class="email">if</code> condition from the above code to:</p><div class="informalexample"><pre class="programlisting">if (behaviourType == Seek || behaviourType == Flee)</pre></div></li><li class="listitem" value="5">The <code class="email">init</code> function should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00145.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="6">That's all. Now<a id="id365" class="calibre1"/> compile and run the project. You should be able to see the player and when you tap anywhere near to the player, you will see the player will flee from the tapped location. </li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Implementing flee">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec121" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">You can read all these properties in more detail at Apple's developer documentation at <a class="calibre1" href="https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html">https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementing arrive"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec51" class="calibre1"/>Implementing arrive</h1></div></div></div><p class="calibre8">Arrive is<a id="id366" class="calibre1"/> similar to seek. The only<a id="id367" class="calibre1"/> difference between seek and arrive is that in arrive the player will stop at the target location. However, in seek, it overshoots the target location and then seeks again.</p></div>

<div class="book" title="Implementing arrive">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec122" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">The technical definition of arrive is to reach the goal with zero velocity. The arrival behavior will remain the same as the seek behavior, the only difference is that it will not overshoot the target.</p><p class="calibre8">In this approach, when the player is outside the stopping radius, it will follow the maximum speed toward the target, while as soon as the player is inside the stopping radius, the desired velocity of the player will be ramped down to zero.</p></div></div>

<div class="book" title="Implementing arrive">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec123" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Perform the <a id="id368" class="calibre1"/>following steps to implement the arrive behavior:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the Player.m file, and add the following line of code in the end of the file:<div class="informalexample"><pre class="programlisting">- (void) arrive:(CGPoint )target deltaTime:(float)deltaTime {
    
    // Work out the direction to this position
    GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);
    GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);
    
    GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);
    
    // Reduce this vector to be the same length as our movement speed
    offset = GLKVector2Normalize(offset);
    offset = GLKVector2MultiplyScalar(offset, 5);
    
    // Add this to our current position
    CGPoint newPosition = self.position;
    newPosition.x += offset.x;
    newPosition.y += offset.y;
    
    self.position = newPosition;
}</pre></div></li><li class="listitem" value="2">Now, we have to call this function till our player is not in the stopping radius. So, we will create a box around our target point, and as soon as the player is inside this box, we will stop calling the arrive function. To implement this, add the following line of code in the update method:<div class="informalexample"><pre class="programlisting">if (self.behaviourType == Arrive) {
    int boxWidth = 20;
    
    CGRect targetRect = CGRectMake(self.target.x - boxWidth, self.target.y - boxWidth, boxWidth*2, boxWidth*2);
    
    if (!CGRectContainsPoint(targetRect, self.position)) {
        [self arrive:self.target deltaTime:deltaTime];
    }
}</pre></div><p class="calibre15">The final update function should look something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00146.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Now, it's time<a id="id369" class="calibre1"/> to check the arrive function we have written in the <code class="email">Player.m</code> file. Open the <code class="email">GameScene.m</code> file. Take the following line of code:<div class="informalexample"><pre class="programlisting">behaviourType = Flee;</pre></div><p class="calibre15">Then, replace this with the following line of code:</p><div class="informalexample"><pre class="programlisting">behaviourType = Arrive;</pre></div></li><li class="listitem" value="4">Now, compile and run the project; you should see our player in the center of the screen. Now, click anywhere on the screen to provide the target for the player. After you have tapped, the player will arrive at the target location you have tapped on with overshooting the target. The output should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00147.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div><p class="calibre8">The red pointer shows<a id="id370" class="calibre1"/> the target location where the player has to arrive.</p></div></div>

<div class="book" title="Implementing arrive">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec124" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">You can read all these properties in more detail at Apple's developer documentation at <a class="calibre1" href="https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html">https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementing evade"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec52" class="calibre1"/>Implementing evade</h1></div></div></div><p class="calibre8">Evade is<a id="id371" class="calibre1"/> similar to flee. The only difference between flee and evade is that in <a id="id372" class="calibre1"/>evade, the player will stop after fleeing to a safe location from the target location selected for evade. However, in flee, it just runs out of the screen from the target location and never comes back.</p></div>

<div class="book" title="Implementing evade">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec125" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Technically, evade is to flee from the target to the safe location. The evade behavior will remain the same as the flee behavior, the only difference is that it will not run away infinitely from the target.</p><p class="calibre8">In this approach, when the target location is inside the safe range of the player, then the player will flee till the target location is not outside its safe range. So, in our case, we will make the player flee till the player is far from the target, and then its velocity will be ramped down to zero.</p></div></div>

<div class="book" title="Implementing evade">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec126" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Perform the following <a id="id373" class="calibre1"/>steps to implement the evade behavior:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">Player.m</code> file and add the following line of code in the end of the file:<div class="informalexample"><pre class="programlisting">- (void) evade:(CGPoint )target deltaTime:(float)deltaTime {
    
    GLKVector2 myPosition = GLKVector2Make(self.position.x, self.position.y);
    GLKVector2 targetPosition = GLKVector2Make(target.x, target.y);
    
    GLKVector2 offset = GLKVector2Subtract(targetPosition, myPosition);
    
    // Reduce this vector to be the same length as our movement speed
    offset = GLKVector2Normalize(offset);
    
    // Note the minus sign - we're multiplying by the inverse of our movement speed,
    // which means we're moving away from it
    offset = GLKVector2MultiplyScalar(offset, -5);
    
    // Add this to our current position
    CGPoint newPosition = self.position;
    newPosition.x += offset.x;
    newPosition.y += offset.y;
    
    self.position = newPosition;
}</pre></div></li><li class="listitem" value="2">Now, add the following code in the <code class="email">update</code> method:<div class="informalexample"><pre class="programlisting">if (self.behaviourType == Evade) {
    
    int boxWidth = 100;
    
    CGRect targetRect = CGRectMake(self.target.x - boxWidth, self.target.y - boxWidth, boxWidth*2, boxWidth*2);
    
    if (CGRectContainsPoint(targetRect, self.position)) {
        
        [self evade:self.target deltaTime:deltaTime];
    }
}</pre></div></li><li class="listitem" value="3">After this, the <a id="id374" class="calibre1"/>update function should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00148.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p><p class="calibre15">In the preceding function, we are drawing a rectangle on the target location vector. Whenever the player is inside this rectangle, it's not safe. So, it will flee to get the player outside into the safe location. So, we will execute our evade function till the player is in the rectangle.</p></li><li class="listitem" value="4">Now, it's time to test the evade function we have written in <code class="email">Player.m</code>. So, open the <code class="email">GameScene.m</code> file. Enter the following line of code:<div class="informalexample"><pre class="programlisting">behaviourType = Arrive;</pre></div><p class="calibre15">Then, replace this with the following line of code:</p><div class="informalexample"><pre class="programlisting">behaviourType = Evade;</pre></div></li><li class="listitem" value="5">The final <code class="email">init</code> method should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00149.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="6">Now, compile <a id="id375" class="calibre1"/>and run the project to see the object player in action. Click anywhere near the player, and it will flee to maintain a certain distance from the location you have tapped, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00150.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Implementing evade">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec127" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">You can read about all these properties in more detail at Apple's developer documentation at <a class="calibre1" href="https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html">https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementing wander"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec53" class="calibre1"/>Implementing wander</h1></div></div></div><p class="calibre8">You <a id="id376" class="calibre1"/>might <a id="id377" class="calibre1"/>have observed very often in the game that few characters are just randomly moving around in their environment. These characters are waiting for some event to happen. For example, in any warfare game, the enemy soldiers are just wandering around in the castle to catch the player and they will keep on wandering till they find the player. Once the player is in the vicinity, then they will change their behavior to seek. So, the wandering ability of the characters makes them visually pleasant and realistic.</p><p class="calibre8">Making a game object follow the path will make it unrealistic and will affect the overall game play by making it more predictive. So these wandering behaviors add much more fun and realistic behavior to the game.</p><p class="calibre8">The wander steering behavior produces a realistic movement, which makes the players think that the character is just walking and to feel the whole environment more alive.</p></div>

<div class="book" title="Implementing wander">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec128" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">There are various<a id="id378" class="calibre1"/> ways to implement the wander behaviors. They are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Implementing wander using seek and randomness. In this approach, wander brings together two behaviors, seek and randomness. This means technically wander is just seeking to some random points and targets in the world.</li><li class="listitem">The second way is to evaluate a virtual point in front of the character and draw a circle in front of it, and get point on it circumference. Now, make the object seek that location. The following image will explain the approach a little better:<div class="mediaobject"><img src="../images/00151.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre13"> </p></li></ul></div><p class="calibre8">We will implement the first approach, so we will follow the following approach:</p><div class="informalexample"><pre class="programlisting">Get targetVector
while (true) {
  Seek (targetVector);
  get anotherTargetVector;
}</pre></div></div></div>

<div class="book" title="Implementing wander">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec129" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Now we will implement <a id="id379" class="calibre1"/>the wander behavior and will take our project a little more further. Perform the following steps to implement the wander behavior:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">Player.m</code> file and add the following line of code in the end of the file:<div class="informalexample"><pre class="programlisting">int myRandom() {
    return (arc4random() % 2 ? 1 : -1);
}

- (void)wanderWithDeltaTime:(float)deltaTime
{
    int boxWidth = 20;
    
    CGRect targetRect = CGRectMake(self.target.x - boxWidth, self.target.y - boxWidth, boxWidth*2, boxWidth*2);
    if (!CGRectContainsPoint(targetRect, self.position)) {
        
        [self seek:self.target deltaTime:deltaTime];
        
    } else {
        int offsetX = self.scene.size.width;
        int offsetY = self.scene.size.height;
        
        self.target = CGPointMake(arc4random() % offsetX, arc4random() % offsetY);
    }
}</pre></div><p class="calibre15">We have implemented the algorithm that we have seen in the start of this section. In this code, we are getting a random local point in front of the player, and then make the player to seek that location. This will make a wander behavior.</p></li><li class="listitem" value="2">Now, add the following line of code in the <code class="email">update</code> method:<div class="informalexample"><pre class="programlisting">if (self.behaviourType == Wander) {
    [self wanderWithDeltaTime:deltaTime];
}</pre></div><p class="calibre15">The final <code class="email">update</code> function should look something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00152.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Now, it's time <a id="id380" class="calibre1"/>to test the <code class="email">evade</code> function we have written in <code class="email">Player.m</code>. So, open the <code class="email">GameScene.m</code> file and add the following line of code:<div class="informalexample"><pre class="programlisting">behaviourType = Evade;</pre></div><p class="calibre15">Then, replace it with the following line of code:</p><div class="informalexample"><pre class="programlisting">behaviourType = Wander; </pre></div><p class="calibre15">Also, add the following if condition right after the if we had for the seek and flee:</p><div class="informalexample"><pre class="programlisting">if (behaviourType == Wander) {
    newplayer.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:CGSizeMake(30, 30)];
    SKPhysicsBody* borderBody = [SKPhysicsBody bodyWithEdgeLoopFromRect:self.frame];
    self.physicsBody = borderBody;
    self.physicsBody.friction = 0.0f;
    newplayer.physicsBody.friction = 1.0f;
    newplayer.physicsBody.linearDamping = 1.0f;
}</pre></div><p class="calibre15">The final file should look something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00153.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Now, compile <a id="id381" class="calibre1"/>and run the project to see the object player in action. Click anywhere on the screen and the player will start wandering on the screen, as shown in the following screenshot:<div class="mediaobject"><img src="../images/00154.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Implementing wander">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec130" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">You can read all these properties in more detail at Apple's developer documentation at <a class="calibre1" href="https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html">https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementing wall avoidance"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec54" class="calibre1"/>Implementing wall avoidance</h1></div></div></div><p class="calibre8">The<a id="id382" class="calibre1"/> AI characters <a id="id383" class="calibre1"/>will look a little odd if they collide with a wall while wandering. So, we have to make them even more intelligent so that they can seek the wall and can respond or change direction accordingly. </p><p class="calibre8">The wander behavior returns a force that steers the AI away from the wall to avoid collision.</p></div>

<div class="book" title="Implementing wall avoidance">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec131" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">The following <a id="id384" class="calibre1"/>approach will be used to implement the wall avoidance behavior:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Create feelers to sense the wall </li><li class="listitem">We will use one feeler in front of the AI to sense the wall</li><li class="listitem">When wall is detected, apply the force at the reflected vector</li></ul></div></div></div>

<div class="book" title="Implementing wall avoidance">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec132" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Follow the following algorithm to achieve the wall avoidance behavior in the project: </p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The visual explanation of the technique is shown in the following screenshot:<div class="mediaobject"><img src="../images/00155.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Create feelers that will sense the wall:<div class="informalexample"><pre class="programlisting">Front_Feeler = player-&gt;Get velocity; // vector
Front_Feeler = Front_Feeler.normalize(); // vector</pre></div><p class="calibre15">This will project the feeler in front of the player.</p><div class="informalexample"><pre class="programlisting">Front_Feeler =  Front_Feeler *  FeelerLength; // vector
Front_Feeler =  Front_Feeler + player-&gt;location;</pre></div></li><li class="listitem" value="3">Now <a id="id385" class="calibre1"/>we have got the <code class="email">Front_Feeler</code> so let's apply the force in the same direction. This force will push the player away from the wall.</li><li class="listitem" value="4">To fine-tune the behavior even more, you can additionally add two more feelers on the either side of the player. This will help player to take a more smooth turn and look realistic.</li></ol><div class="calibre14"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Obstacle avoidance"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec55" class="calibre1"/>Obstacle avoidance </h1></div></div></div><p class="calibre8">If the <a id="id386" class="calibre1"/>game objects are exhibiting the group behaviors, then it's really important to make them avoid collision with each other. Also, there can be multiple obstacles on the way, which the characters have to avoid intelligently.</p></div>

<div class="book" title="Obstacle avoidance">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec133" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">The following approach will be used to <a id="id387" class="calibre1"/>implement <a id="id388" class="calibre1"/>the obstacle avoidance behavior:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Create three feelers in front of the player object </li><li class="listitem">Let all the three feelers sense the obstacles on the way</li><li class="listitem">Redirect the player in the opposite direction if the feeler has sensed any obstacles</li></ul></div></div></div>

<div class="book" title="Obstacle avoidance">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec134" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Follow the following algorithm to achieve the obstacle avoidance behavior in the project.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The visual explanation of the technique is shown in the following screenshot:<div class="mediaobject"><img src="../images/00156.jpeg" alt="How to do it" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Create<a id="id389" class="calibre1"/> feelers that will sense the wall:<div class="informalexample"><pre class="programlisting">Front_Feeler = player-&gt;Get velocity; // vector
Front_Feeler = Front_Feeler.normalize(); // vector

Left_Feeler = player-&gt;Get velocity; // vector
Left_Feeler = Left_Feeler.normalize(); // vector

Right_Feeler = player-&gt;Get velocity; // vector
Right_Feeler = Right_Feeler.normalize(); // vector

This will project the feeler in front of the player.
Front_Feeler =  Front_Feeler *  FeelerLength; // vector
Front_Feeler =  Front_Feeler + player-&gt;location; 

Left_Feeler =  Left_Feeler *  FeelerLength; // vector
Left_Feeler =  Left_Feeler + player-&gt;location; 
Left_Feeler-&gt;x = Left_Feeler -&gt; x - player-&gt; width;

Right_Feeler =  Right_Feeler *  FeelerLength; // vector
Right_Feeler =  Right_Feeler + player-&gt;location; 
Right_Feeler-&gt;x = Right_Feeler -&gt; x + player-&gt; width;</pre></div><p class="calibre15">Now we have left, right, and front feelers. So whenever these feelers will sense any object in their way, they will push the player away from the obstacle.</p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Obstacle avoidance">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec135" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">There are a lot <a id="id390" class="calibre1"/>more steering behaviors that can make the games very interesting. There are various group behaviors as well, which can be explored after having a hands-on these behaviors. Few of the behaviors are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Flocking</strong></span>: When <a id="id391" class="calibre1"/>the objects exhibit certain <a id="id392" class="calibre1"/>common behavior in groups, then that behavior is called flocking</li><li class="listitem"><span class="strong"><strong class="calibre2">Alignment</strong></span>: When<a id="id393" class="calibre1"/> the objects exhibit some behavior<a id="id394" class="calibre1"/> that causes a particular character to line up with agents close by, then it's called alignment</li><li class="listitem"><span class="strong"><strong class="calibre2">Cohesion</strong></span>: In<a id="id395" class="calibre1"/> this behavior, the objects are steered <a id="id396" class="calibre1"/>toward the center of the mass of all the objects—that is, the average position of the agents within a certain radius</li><li class="listitem"><span class="strong"><strong class="calibre2">Separation</strong></span>: In<a id="id397" class="calibre1"/> this behavior, the objects are steered <a id="id398" class="calibre1"/>away from all of their neighbors</li></ul></div><p class="calibre8">You can read <a id="id399" class="calibre1"/>more about these behaviors at:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><a class="calibre1" href="http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444">http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444</a></li><li class="listitem"><a class="calibre1" href="http://www.red3d.com/cwr/steer/gdc99/">http://www.red3d.com/cwr/steer/gdc99/</a></li></ul></div></div></div></body></html>