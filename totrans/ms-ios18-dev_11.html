<html><head></head><body>
		<div><h1 id="_idParaDest-200" class="chapter-number"><a id="_idTextAnchor346"/><st c="0">11</st></h1>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor347"/><st c="3">Creating Pipelines with Combine</st></h1>
			<p><st c="35">Data flow is a central programming topic, not just in iOS development. </st><st c="107">Indeed, we have many solutions and design patterns to address data flow management. </st><st c="191">It was only in 1997 that the computer science world introduced reactive programming – a programming paradigm focusing on data streams, enabling </st><st c="335">declarative composition.</st></p>
			<p><st c="359">Apple’s version of reactive programming is Combine, a framework that provides infrastructure for building data streams in our apps. </st><st c="492">It is also the infrastructure of SwiftUI, enabling it to be a </st><st c="554">declarative framework.</st></p>
			<p><st c="576">In this chapter, we will do </st><st c="605">the following:</st></p>
			<ul>
				<li><st c="619">Discuss the reasons to use Combine in </st><st c="658">our projects</st></li>
				<li><st c="670">Go over </st><st c="679">the basics</st></li>
				<li><st c="689">Delve </st><st c="696">into Combine</st></li>
				<li><st c="708">Learn about Combine </st><st c="729">using examples</st></li>
			</ul>
			<p><st c="743">Before we start going over the Combine framework, let’s understand why we should </st><st c="825">use Combine.</st></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor348"/><st c="837">Technical requirements</st></h1>
			<p><st c="860">For this chapter, it’s essential to download Xcode version 16.0 or higher from the </st><st c="944">App Store.</st></p>
			<p><st c="954">Ensure you’re operating on the most recent version of macOS (Ventura or newer). </st><st c="1035">Just search for Xcode in the App Store, choose the latest version, and proceed with the download. </st><st c="1133">Open Xcode and complete any further setup instructions that appear. </st><st c="1201">After Xcode is completely up and running, you </st><st c="1247">can begin.</st></p>
			<p><st c="1257">Download the sample code from the following GitHub </st><st c="1309">link: </st><a href="https://github.com/PacktPublishing/Mastering-iOS-17-Programming-fifth-edition/tree/main/Chapter%2011"><st c="1315">https://github.com/PacktPublishing/Mastering-iOS-17-Programming-fifth-edition/tree/main/Chapter%2011</st></a></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor349"/><st c="1415">Why use Combine?</st></h1>
			<p><st c="1432">Apple’s Combine framework</st><a id="_idIndexMarker622"/><st c="1458"> is considered to have a steep learning curve, but not because it is technically complex. </st><st c="1548">This is because many developers don’t understand why, how, and where they should use Combine in </st><st c="1644">their apps.</st></p>
			<p><st c="1655">To answer these questions, let’s try to understand Combine. </st><st c="1716">Combine is Apple’s reactive framework and provides a unified API for asynchronous events and </st><st c="1809">data streams.</st></p>
			<p><st c="1822">But why do we need a reactive framework? </st><st c="1864">Don’t we have everything </st><st c="1889">we need?</st></p>
			<p><st c="1897">Let’s see what we have in our </st><st c="1928">iOS SDK:</st></p>
			<ul>
				<li><strong class="bold"><st c="1936">Notifications</st></strong><st c="1950"> allow us to send messages</st><a id="_idIndexMarker623"/><st c="1976"> that any object </st><st c="1993">can observe</st></li>
				<li><strong class="bold"><st c="2004">Delegates</st></strong><st c="2014"> allow objects to respond</st><a id="_idIndexMarker624"/><st c="2039"> to events or changes triggered by </st><st c="2074">other objects</st></li>
				<li><strong class="bold"><st c="2087">Closures</st></strong><st c="2096"> are self-contained functionality</st><a id="_idIndexMarker625"/><st c="2129"> blocks we can pass around and call whenever </st><st c="2174">we need</st></li>
				<li><strong class="bold"><st c="2181">Key-Value Observing</st></strong><st c="2201"> (</st><strong class="bold"><st c="2203">KVO</st></strong><st c="2206">) allows us to observe value changes</st><a id="_idIndexMarker626"/><st c="2243"> in </st><st c="2247">object property</st></li>
			</ul>
			<p><st c="2262">That’s a powerful toolbox! </st><st c="2290">But while we have a toolbox with so many options, these options have some drawbacks we need </st><st c="2382">to discuss.</st></p>
			<p><st c="2393">For example, notifications might be considered to be an anti-pattern, mainly because they have implicit communication. </st><st c="2513">Imagine a project based on notifications, with objects that mainly communicate with each other using the notification center. </st><st c="2639">That project can take time to manage and understand the data flow </st><st c="2705">and dependencies.</st></p>
			<p><st c="2722">Delegates help with some of these problems. </st><st c="2767">But when we want to pass data between different objects continuously, they require us to create many protocols and require each object to call another, making it hard to understand </st><st c="2948">what’s happening.</st></p>
			<p><st c="2965">Closures are actually significant progress compared to delegates, but they also create complexity when nested or captured by </st><st c="3091">other closures.</st></p>
			<p><st c="3106">Imagine we have a view controller with a view model. </st><st c="3160">The view model has a </st><code><st c="3181">message</st></code><st c="3188"> property, and we always want UILabel’s text to match the </st><code><st c="3246">message</st></code> <st c="3253">property value.</st></p>
			<p><st c="3269">With Combine, we would do </st><st c="3296">the following:</st></p>
			<pre class="source-code"><st c="3310">
messageSubscriber = viewModel.$message
            .sink { [weak self] message in
                self?.label.text = message
            }</st></pre>			<p><st c="3409">The </st><code><st c="3414">sink</st></code><st c="3418"> operator receives an update of any change in the </st><code><st c="3468">message</st></code><st c="3475"> property and has a closure with the new </st><code><st c="3516">message</st></code><st c="3523"> property. </st><st c="3534">We store the new </st><code><st c="3551">message</st></code><st c="3558"> property directly in the label’s </st><st c="3592">text value.</st></p>
			<p><st c="3603">This example binds the label’s text property to the </st><code><st c="3656">viewModel</st></code><st c="3665"> text property. </st><st c="3681">There is no need to define a specific interface</st><a id="_idIndexMarker627"/><st c="3728"> for delegating, observing, posting notifications, or defining </st><st c="3791">a closure.</st></p>
			<p><st c="3801">Combine has much more to offer, but before we delve into additional practical examples, let’s understand </st><st c="3907">the basics.</st></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor350"/><st c="3918">Going over the basics</st></h1>
			<p><st c="3940">As a reactive framework, Combine is built upon components that publish updates (the publishers) and components that subscribe to updates (</st><st c="4079">the subscribers).</st></p>
			<p><st c="4097">In between, we’ve got the operators, which can manipulate data and control the stream flow. </st><st c="4190">Let’s get an overview of Combine by starting with </st><st c="4240">the publisher.</st></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor351"/><st c="4254">Starting with the publisher</st></h2>
			<p><st c="4282">The best way to explain</st><a id="_idIndexMarker628"/><st c="4306"> how Combine works</st><a id="_idIndexMarker629"/><st c="4324"> is by talking about publishers. </st><strong class="bold"><st c="4357">Publishers</st></strong><st c="4367"> are types that can deliver a sequence of values over time. </st><st c="4427">We saw one example in </st><a href="B21795_10.xhtml#_idTextAnchor329"><em class="italic"><st c="4449">Chapter 10</st></em></a><st c="4459">:</st></p>
			<pre class="source-code"><st c="4461">
URLSession.shared.dataTaskPublisher(for: url)</st></pre>			<p><st c="4507">For a type to be a publisher, it needs to conform to the </st><code><st c="4565">Publisher</st></code><st c="4574"> protocol, and </st><code><st c="4589">URLSession</st></code><st c="4599"> is not the only type that does that. </st><code><st c="4637">Timer</st></code><st c="4642"> and </st><code><st c="4647">NotificationCenter</st></code><st c="4665"> are also types that have </st><st c="4691">their publishers:</st></p>
			<pre class="source-code"><st c="4708">
NotificationCenter.default.publisher(for:
  Notification.Name("DataValueChanged"))</st></pre>			<p><st c="4789">Or, it can be a </st><code><st c="4806">Timer</st></code><st c="4811"> publisher:</st></p>
			<pre class="source-code"><st c="4822">
let timerPublisher = Timer.publish(every: 1.0, on: .main,
  in: .default)
    .autoconnect()</st></pre>			<p><st c="4909">For types that don’t have a publisher, we can add one as long as their property </st><st c="4990">is KVO-compliant:</st></p>
			<pre class="source-code"><st c="5007">
extension UserDefaults {
@objc dynamic var test: Int { return integer(forKey:
  "myProperty") }
}
let userDefaultsPublisher = UserDefaults.standard
  .publisher(for: \. </st><st c="5173">myProperty)</st></pre>			<p><st c="5184">We can also create a custom</st><a id="_idIndexMarker630"/><st c="5212"> publisher, and we’ll learn how to</st><a id="_idIndexMarker631"/><st c="5246"> do that shortly. </st><st c="5264">The publisher emits values only if a subscriber wants to receive them. </st><st c="5335">So next, let’s meet </st><st c="5355">the subscriber.</st></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor352"/><st c="5370">Setting up the subscriber</st></h2>
			<p><st c="5396">A </st><code><st c="5484">Subscriber</st></code><st c="5494"> instance is located at the end of the stream and handles the incoming values. </st><st c="5573">The Combine framework has two built-in subscribers, </st><code><st c="5625">sink</st></code><st c="5629"> and </st><code><st c="5634">assign</st></code><st c="5640">; both simplify the use of Combine in </st><st c="5679">most cases.</st></p>
			<p><st c="5690">Let’s start </st><st c="5703">with </st><code><st c="5708">sink</st></code><st c="5712">:</st></p>
			<pre class="source-code"><st c="5714">
import Combine
import Foundation
let subscriber = Timer.publish(every: 1.0, on: .main, in:
  .default)
    .autoconnect()
    .sink( receiveValue: { value in
        print("Received value: \(value)")
    })
DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
    subscriber.cancel()
}</st></pre>			<p><st c="5975">In this code example, we created a </st><code><st c="6011">Timer</st></code><st c="6016"> publisher that sends a value every second. </st><st c="6060">The value it sends is from the </st><code><st c="6091">date</st></code><st c="6095"> type, but it doesn’t matter to us – the </st><code><st c="6136">sink</st></code><st c="6140"> subscriber can receive </st><st c="6164">any value.</st></p>
			<p><st c="6174">The next thing we do is cancel the subscriber after five seconds. </st><st c="6241">Once no subscriber is listening, the publisher stops sending values. </st><st c="6310">That’s an essential</st><a id="_idIndexMarker634"/><st c="6329"> concept of Combine, called a </st><strong class="bold"><st c="6359">demand-driven model</st></strong><st c="6378">. With this approach, we ensure efficient resource management and avoid performing any work without </st><st c="6478">a goal.</st></p>
			<p><st c="6485">In this code example, we printed the received value to the console. </st><st c="6554">However, in many cases, we want to assign it to a specific property. </st><st c="6623">For example, we may download a file and receive an update on its progress. </st><st c="6698">In this case, we want to update a progress property to show the </st><st c="6762">download status.</st></p>
			<p><st c="6778">We could use the </st><code><st c="6796">sink</st></code><st c="6800"> closure</st><a id="_idIndexMarker635"/><st c="6808"> to receive the value</st><a id="_idIndexMarker636"/><st c="6829"> and set it to the relevant property, but we’ve got a more elegant way, and that’s the </st><code><st c="6916">assign</st></code><st c="6922"> subscriber:</st></p>
			<pre class="source-code"><st c="6934">
import Combine
import Foundation
class DateContainer {
    var date: Date
    init() { date = Date() }
}
let container = DateContainer()
let cancellable = Timer.publish(every: 1.0, on: .main, in:
  .default)
    .autoconnect()
    .assign(to: \.date, on: container)
DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
    cancellable.cancel()
}</st></pre>			<p><st c="7259">In this example, we have the same timer as the previous example. </st><st c="7325">However, this time, we’ve got an instance of </st><code><st c="7370">DateContainer</st></code><st c="7383"> with a </st><code><st c="7391">date</st></code><st c="7395"> property. </st><st c="7406">The </st><code><st c="7410">assign</st></code><st c="7416"> subscriber at the end of the stream ensures that we take the received value and assign it to a specific property using a </st><st c="7538">key path.</st></p>
			<p><st c="7547">In this case, the </st><code><st c="7566">assign</st></code><st c="7572"> subscriber input value</st><a id="_idIndexMarker637"/><st c="7595"> must match the publisher</st><a id="_idIndexMarker638"/> <st c="7620">output value.</st></p>
			<p><st c="7634">We obviously can achieve the same results using the </st><code><st c="7687">sink</st></code><st c="7691"> closure:</st></p>
			<pre class="source-code"><st c="7700">
    .sink( receiveValue: { value in
        container.date = value
    })</st></pre>			<p><st c="7757">However, using the </st><code><st c="7777">assign</st></code><st c="7783"> subscriber is far more elegant and more than just semantic. </st><st c="7844">Using key paths improves our code type safety and makes it more declarative </st><st c="7920">and concise.</st></p>
			<p><st c="7932">We’ve learned that the publisher’s output</st><a id="_idIndexMarker639"/><st c="7974"> should match the </st><a id="_idIndexMarker640"/><st c="7992">subscriber’s input. </st><st c="8012">But what do we do if we need to perform some transformations and processing to make that happen? </st><st c="8109">That’s why we have </st><st c="8128">the operators.</st></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor353"/><st c="8142">Connecting operators</st></h2>
			<p><st c="8163">The third part of Combine</st><a id="_idIndexMarker641"/><st c="8189"> streams is the </st><strong class="bold"><st c="8205">operator</st></strong><st c="8213">. The operator takes upstream</st><a id="_idIndexMarker642"/><st c="8242"> data (the output from the previous step), processes it, and emits it downstream. </st><st c="8324">Downstream means the next step – the subscriber or </st><st c="8375">another operator.</st></p>
			<p><st c="8392">The operators are actually</st><a id="_idIndexMarker643"/><st c="8419"> what helps</st><a id="_idIndexMarker644"/><st c="8430"> us build what we call a </st><strong class="bold"><st c="8455">pipeline</st></strong><st c="8463"> or </st><strong class="bold"><st c="8467">Combine stream</st></strong><st c="8481">.</st></p>
			<p><st c="8482">Let’s try to build a </st><st c="8504">simple stream:</st></p>
			<pre class="source-code"><st c="8518">
let numbersPublisher = Array(1...20).publisher
let subscription = numbersPublisher
    .filter { $0 % 2 == 0 }
    .map { "The number is \($0)" }
    .sink(receiveValue: { print($0) })</st></pre>			<p><st c="8691">This simple code example takes an array of numbers between </st><code><st c="8751">1</st></code><st c="8752"> and </st><code><st c="8757">20</st></code><st c="8759">, making it a publisher using the </st><code><st c="8793">publisher</st></code><st c="8802"> variable.</st></p>
			<p><code><st c="8812">numbersPublisher</st></code><st c="8829"> emits a new value from the array each time. </st><st c="8874">The value goes downstream to the </st><code><st c="8907">filter</st></code><st c="8913"> operator, which republishes the value only if it’s even. </st><st c="8971">The filtered value moves to the </st><code><st c="9003">map</st></code><st c="9006"> operator, which transforms it into a string message and republishes </st><st c="9075">it again.</st></p>
			<p><st c="9084">At the end of the stream, we have the </st><code><st c="9123">sink</st></code><st c="9127"> subscriber, which prints the message to </st><st c="9168">the console.</st></p>
			<p><st c="9180">Congratulations! </st><st c="9198">We’ve created our first pipeline. </st><st c="9232">Look at </st><em class="italic"><st c="9240">Figure 11</st></em><em class="italic"><st c="9249">.1</st></em><st c="9251">:</st></p>
			<div><div><img src="img/B21795_11_1.jpg" alt="Figure 11.1: Our first Combine timeline"/><st c="9253"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9325">Figure 11.1: Our first Combine timeline</st></p>
			<p><em class="italic"><st c="9364">Figure 11</st></em><em class="italic"><st c="9374">.1</st></em><st c="9376"> shows the different pipeline operators, such as </st><code><st c="9425">filter</st></code><st c="9431"> and </st><code><st c="9436">map</st></code><st c="9439">. I am highlighting the input and output for each operator here. </st><st c="9504">We can see that the output of one timeline component is the input of the </st><st c="9577">next element.</st></p>
			<p><st c="9590">That leads us to something</st><a id="_idIndexMarker645"/><st c="9617"> we haven’t discussed yet – what exactly are publishers</st><a id="_idIndexMarker646"/><st c="9672"> and subscribers? </st><st c="9690">How do they work under the hood? </st><st c="9723">Let’s </st><st c="9729">delve in.</st></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor354"/><st c="9738">Delving into Combine components</st></h1>
			<p><st c="9770">Until now, we have created simple examples</st><a id="_idIndexMarker647"/><st c="9813"> in Combine to warm up. </st><st c="9837">However, if we want to use Combine in a more advanced way, we need to understand better what happens under </st><st c="9944">the hood.</st></p>
			<p><st c="9953">The first thing we must understand is that Combine is not magic. </st><st c="10019">Combine alone doesn’t include any sophisticated code. </st><st c="10073">Ultimately, we are talking about a group of protocols that helps us subscribe to changes and create a pipeline </st><st c="10184">of updates.</st></p>
			<p><st c="10195">To delve in, we will review the different protocols and build our own custom publishers, operators, and subscribers to understand how things </st><st c="10337">work inside.</st></p>
			<p><st c="10349">Let’s start with </st><st c="10367">the publisher.</st></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor355"/><st c="10381">Creating a custom publisher</st></h2>
			<p><st c="10409">I just mentioned that Combine</st><a id="_idIndexMarker648"/><st c="10439"> is a set of protocols that speak with each other, and the publisher is the first protocol we </st><st c="10533">will review.</st></p>
			<p><st c="10545">Let’s see what we know up until now about </st><st c="10588">the publisher:</st></p>
			<ul>
				<li><st c="10602">The publisher </st><em class="italic"><st c="10617">emits values</st></em><st c="10629"> to one or </st><st c="10640">more subscribers</st></li>
				<li><st c="10656">The publisher output type </st><em class="italic"><st c="10683">must match the </st></em><em class="italic"><st c="10698">subscriber’s input</st></em></li>
				<li><st c="10716">The publisher can also </st><em class="italic"><st c="10740">deliver errors</st></em></li>
			</ul>
			<p><st c="10754">Based on that, let’s take our </st><code><st c="10785">Int</st></code><st c="10788"> array publisher </st><a id="_idIndexMarker649"/><st c="10805">example and try to create our own publisher that </st><st c="10854">delivers numbers:</st></p>
			<pre class="source-code"><st c="10871">
class CustomNumberPublisher: Publisher {
    typealias </st><strong class="bold"><st c="10923">Output</st></strong><st c="10929"> = Int
    typealias </st><strong class="bold"><st c="10946">Failure</st></strong><st c="10953"> = Never
    private let numbers: [Int]
    init(numbers: [Int]) {
        self.numbers = numbers
    }
    func receive&lt;S: Subscriber&gt;(subscriber: S) where
      S.Input == Output, S.Failure == Failure {
        for number in numbers {
            _ = subscriber.receive(number)
        }
        subscriber.receive(completion: .finished)
    }
}</st></pre>			<p><st c="11230">The </st><code><st c="11235">CustomNumberPublisher</st></code><st c="11256"> class has three </st><st c="11273">essential parts:</st></p>
			<ul>
				<li><code><st c="11289">Output</st></code><st c="11296"> – This is where we define the publisher output type. </st><st c="11350">In this case, it is an </st><code><st c="11373">Int</st></code><st c="11376"> type.</st></li>
				<li><code><st c="11382">Failure</st></code><st c="11390"> – This is where we define the publisher error type. </st><st c="11443">In this case, the publisher never emits </st><st c="11483">an error.</st></li>
				<li><code><st c="11492">receive</st></code><st c="11500"> – This is the main publisher method. </st><st c="11538">Combine calls the </st><code><st c="11556">receive</st></code><st c="11563"> method whenever a subscriber subscribes to the publisher. </st><st c="11622">We can see that the </st><code><st c="11642">receive</st></code><st c="11649"> function has the subscriber’s parameter, and it also verifies that the subscriber input type and error match the </st><st c="11763">publisher definition.</st></li>
			</ul>
			<p><st c="11784">When the publisher wants to emit a new value, it calls the subscriber’s </st><code><st c="11857">receive</st></code><st c="11864"> method with the new value. </st><st c="11892">When the publisher completes sending values, it calls the subscriber’s </st><code><st c="11963">receive</st></code><st c="11970"> function with the </st><code><st c="11989">completion</st></code><st c="11999"> parameter.</st></p>
			<p><st c="12010">Let’s see how we </st><st c="12028">use </st><code><st c="12032">CustomNumberPublisher</st></code><st c="12053">:</st></p>
			<pre class="source-code"><st c="12055">
let subscriber = CustomNumberPublisher(numbers: [1, 2, 3,
  4, 5])
    .sink { value in
        print(value)
}</st></pre>			<p><st c="12152">Running this code will print </st><code><st c="12182">1,2,3,4,5</st></code><st c="12191"> to the console </st><st c="12207">as expected.</st></p>
			<p><st c="12219">The </st><code><st c="12224">CustomNumberPublisher</st></code><st c="12245"> example explains how a publisher works. </st><st c="12286">But sometimes, we want to send values imperatively. </st><st c="12338">We may wish to implement Combine in an existing project code</st><a id="_idIndexMarker650"/><st c="12398"> or </st><st c="12402">simplify things.</st></p>
			<p><st c="12418">So, let’s meet a special publisher type </st><st c="12459">called </st><code><st c="12466">Subject</st></code><st c="12473">.</st></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor356"/><st c="12474">Working with Subjects</st></h2>
			<p><st c="12496">A </st><code><st c="12597">send(_:)</st></code><st c="12605"> method.</st></p>
			<p><st c="12613">Let’s start with the most basic Subject – </st><code><st c="12656">PassthroughSubject</st></code><st c="12674">.</st></p>
			<h3><st c="12675">Understanding PassthroughSubject</st></h3>
			<p><st c="12708">Let’s see a basic example</st><a id="_idIndexMarker652"/><st c="12734"> of </st><st c="12738">Subject usage:</st></p>
			<pre class="source-code"><st c="12752">
import Combine
let subject = PassthroughSubject&lt;Int, Never&gt;()
let subscriber = subject.sink { value in
    print("Received value: \(value)")
}
subject.send(1)
subject.send(2)
subject.send(3)</st></pre>			<p><st c="12939">The code example is simple and</st><a id="_idTextAnchor357"/><a id="_idTextAnchor358"/><st c="12970"> easy to follow. </st><st c="12987">We created a </st><code><st c="13000">Subject</st></code><st c="13007"> instance (which is a publisher) of the </st><code><st c="13047">PassthroughSubject</st></code><st c="13065"> type. </st><code><st c="13072">PassthroughSubject</st></code><st c="13090"> can be initialized without any value, and the first time we open a stream is after we call its </st><code><st c="13186">send(_:)</st></code><st c="13194"> function.</st></p>
			<p><st c="13204">Notice that our </st><code><st c="13221">Subject</st></code><st c="13228"> is just sending values</st><a id="_idIndexMarker653"/><st c="13251"> but never closing the stream. </st><st c="13282">However, we’ve learned from our custom publisher implementation that, sometimes, the publisher closes its streams and sends a completion to </st><st c="13422">the subscriber.</st></p>
			<p><st c="13437">We can also use the </st><code><st c="13458">send(_:)</st></code><st c="13466"> function to close the </st><st c="13489">Combine stream:</st></p>
			<pre class="source-code"><st c="13504">
subject.send(1)
subject.send(2)
subject.send(completion: .finished)
subject.send(3)</st></pre>			<p><st c="13588">In this code example, we use our Subject to send two values – </st><code><st c="13651">1</st></code><st c="13652"> and </st><code><st c="13657">2</st></code><st c="13658">. After sending these values, we close the stream by calling the </st><code><st c="13723">send</st></code><st c="13727"> function with the </st><code><st c="13746">.</st></code><code><st c="13747">finished</st></code><st c="13756"> parameter.</st></p>
			<p><st c="13767">After that, the Subject tries to send another value (</st><code><st c="13821">3</st></code><st c="13823">), but the stream is already closed, and the subscriber won’t </st><st c="13885">receive it.</st></p>
			<p><st c="13896">The publisher life cycle is crucial to the Combine methodology and applies to </st><st c="13975">our Subjects.</st></p>
			<p><code><st c="13988">PassthroughSubject</st></code><st c="14007"> is excellent for sending values</st><a id="_idIndexMarker654"/><st c="14039"> to subscribers. </st><st c="14056">However, it’s not very good for holding a state. </st><st c="14105">For example, imagine we want to store the current authentication login status or a file download progress. </st><st c="14212">One solution is to store the received value in an instance variable. </st><st c="14281">However, using an instance variable can be cumbersome, especially with </st><st c="14352">several subscribers.</st></p>
			<p><st c="14372">Another option is to use another type of Subject </st><st c="14422">called </st><code><st c="14429">CurrentValueSubject</st></code><st c="14448">.</st></p>
			<h3><st c="14449">Preserving state with CurrentValueSubject Subject</st></h3>
			<p><st c="14499">Unlike </st><code><st c="14507">PassthroughSubject</st></code><st c="14525">, </st><code><st c="14527">CurrentValueSubject</st></code><st c="14546"> is excellent</st><a id="_idIndexMarker655"/><st c="14559"> for holding a state. </st><st c="14581">It has an initial state and a </st><code><st c="14611">value</st></code><st c="14616"> property representing the </st><st c="14643">current value.</st></p>
			<p><st c="14657">Let’s see a basic example of </st><code><st c="14687">CurrentValueSubject</st></code><st c="14706"> usage:</st></p>
			<pre class="source-code"><st c="14713">
import Combine
let subject = CurrentValueSubject&lt;String, Never&gt;("Initial
  Value")
let currentValue = subject.value
print("Current value: \(currentValue)")
let subscriber = subject.sink { value in
    print("Received value: \(value)")
}
subject.send("New Value")</st></pre>			<p><st c="14970">In this code example, we create </st><code><st c="15003">CurrentValueSubject</st></code><st c="15022"> and initialize it with a value (</st><code><st c="15055">"</st></code><code><st c="15057">Initial Value"</st></code><st c="15071">).</st></p>
			<p><st c="15074">We then print the Subject’s current value into the console and subscribe to it using a simple </st><code><st c="15169">sink</st></code><st c="15173"> function, printing each update </st><st c="15205">as well.</st></p>
			<p><st c="15213">In the last line, we send a new value using </st><st c="15258">our Subject.</st></p>
			<p><st c="15270">The console, in this case, will show </st><st c="15308">the following:</st></p>
			<pre class="source-code"><st c="15322">
Current value: Initial Value
Received value: Initial Value
Received value: New Value</st></pre>			<p><st c="15407">At first glance, the console output looks weird. </st><st c="15457">Why do we see </st><code><st c="15471">Received value: Initial Value</st></code><st c="15500"> if we have not sent it using the </st><code><st c="15534">send(_:)</st></code><st c="15542"> function?</st></p>
			<p><st c="15552">The answer is that </st><code><st c="15572">CurrentValueSubject</st></code><st c="15591"> already holds a value when we initialize it, and when we subscribe to it for the first time, we already receive the </st><st c="15708">current value.</st></p>
			<p><st c="15722">This is why </st><code><st c="15735">CurrentValueSubject</st></code><st c="15754"> is excellent for state management. </st><st c="15790">This behavior ensures that our subscribers always sync with the current </st><st c="15862">Subject value.</st></p>
			<p><code><st c="15876">PassthroughSubject</st></code><st c="15895"> doesn’t have the </st><code><st c="15913">value</st></code><st c="15918"> property, and we cannot read</st><a id="_idIndexMarker656"/><st c="15947"> its current value. </st><st c="15967">However, the fact that it doesn’t emit its values before we call the </st><code><st c="16036">send(_:)</st></code><st c="16044"> function can be an advantage in </st><st c="16077">some cases.</st></p>
			<p><st c="16088">Let’s see </st><st c="16099">an example:</st></p>
			<pre class="source-code"><st c="16110">
let subject1 = PassthroughSubject&lt;Int, Never&gt;()
let subject2 = PassthroughSubject&lt;Int, Never&gt;()
let subscriber = subject1
    .merge(with: subject2)
    .sink { value in
        print("Transformed value: \(value)")
    }
subject1.send(1)
subject1.send(2)
subject2.send(3)
subject2.send(4)</st></pre>			<p><st c="16379">In this example, we have two </st><code><st c="16409">PassthroughSubject</st></code><st c="16427"> publishers and the </st><code><st c="16447">merge()</st></code><st c="16454"> operator in our Combine stream. </st><st c="16487">The </st><code><st c="16491">merge()</st></code><st c="16498"> operator combines the values emitted by both publishers into a single stream. </st><st c="16577">If one of the Subjects sends a value, the </st><code><st c="16619">merge()</st></code><st c="16626"> operator moves it down </st><st c="16650">the stream.</st></p>
			<p><st c="16661">So, in this case, the output will be </st><st c="16699">as follows:</st></p>
			<pre class="source-code"><st c="16710">
Transformed value: 1
Transformed value: 2
Transformed value: 3
Transformed value: 4</st></pre>			<p><code><st c="16794">PassthroughSubject</st></code><st c="16813"> can act as an intermediate step in the Combine pipeline, allowing us to combine multiple publishers and perform data transformations before it reaches the subscribers. </st><st c="16982">This is something we cannot do </st><st c="17013">with </st><code><st c="17018">CurrentValueSubject</st></code><st c="17037">.</st></p>
			<p><st c="17038">Until now, we have used the built-in </st><code><st c="17076">sink</st></code><st c="17080"> subscriber</st><a id="_idIndexMarker657"/><st c="17091"> to handle the incoming value. </st><st c="17122">But just like the publisher, we can also create a custom subscriber. </st><st c="17191">Learning how to make a custom subscriber can enrich our knowledge of Combine. </st><st c="17269">Let’s </st><st c="17275">delve in!</st></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor359"/><st c="17284">Creating a custom subscriber</st></h2>
			<p><st c="17313">If the publisher is the element</st><a id="_idIndexMarker658"/><st c="17345"> that delivers updates, the subscriber is the element that </st><st c="17404">demands them.</st></p>
			<p><st c="17417">We already understand that Combine works with a </st><em class="italic"><st c="17466">supply-and-demand</st></em><st c="17483"> model. </st><st c="17491">This means the subscriber needs a mechanism to handle and request </st><st c="17557">incoming values.</st></p>
			<p><st c="17573">Let’s build a subscriber </st><st c="17599">for </st><code><st c="17603">CustomNumberPublisher</st></code><st c="17624">:</st></p>
			<pre class="source-code"><st c="17626">
class CustomNumberSubscriber: Subscriber {
    typealias Input = Int
    typealias Failure = Never
    func receive(subscription: Subscription) {
        subscription.request(.unlimited)
    }
    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print("Received: \(input)")
        return .unlimited
    }
    func receive(completion: Subscribers.Completion&lt;Never&gt;)
    {
        print("Received completion: \(completion)")
    }
}</st></pre>			<p><st c="18000">The subscriber protocol</st><a id="_idIndexMarker659"/><st c="18024"> contains the publisher’s corresponding type aliases, </st><code><st c="18078">Input</st></code><st c="18083"> and </st><code><st c="18088">Failure</st></code><st c="18095">. Both need to match the publisher’s </st><code><st c="18132">Output</st></code><st c="18138"> and </st><code><st c="18143">Failure</st></code> <st c="18150">data types.</st></p>
			<p><st c="18162">Looking at the subscriber implementation, we can see three more </st><code><st c="18227">receive</st></code><st c="18234"> functions, which we’ll look at in the </st><st c="18273">next subsections.</st></p>
			<h3><st c="18290">receive(subscription: Subscription)</st></h3>
			<p><code><st c="18326">receive(subscription: Subscription)</st></code><st c="18362"> is called when the subscriber</st><a id="_idIndexMarker660"/><st c="18392"> subscribes successfully to the publisher. </st><st c="18435">The </st><code><st c="18439">subscription</st></code><st c="18451"> object handles the subscription, and it has one important method – to define the demand from the publisher. </st><st c="18560">We do that by requesting </st><st c="18585">unlimited values:</st></p>
			<pre class="source-code"><st c="18602">
subscription.request(.unlimited)</st></pre>			<p><st c="18635">We can also limit the number of items we’re requesting. </st><st c="18692">For example, let’s request a maximum of three </st><st c="18738">additional items:</st></p>
			<pre class="source-code"><st c="18755">
subscription.request(.max(3))</st></pre>			<p><st c="18785">We can also request no items </st><st c="18815">at all:</st></p>
			<pre class="source-code"><st c="18822">
subscription.request(.none)</st></pre>			<p><st c="18850">Notice that the publisher needs to call the </st><code><st c="18895">receive(subscription: Subscription)</st></code><st c="18930"> method explicitly. </st><st c="18950">This means that if we build a custom publisher (as in the </st><em class="italic"><st c="19008">Creating a custom publisher</st></em><st c="19035"> section), we must ensure that we call that </st><st c="19079">function ourselves.</st></p>
			<p><st c="19098">We need to handle the incoming values now that we have established the subscription, and we do that with the </st><code><st c="19208">receive(_input:Int)</st></code><st c="19227"> method.</st></p>
			<h3><st c="19235">receive(_ input: Int) -&gt; Subscribers.Demand</st></h3>
			<p><st c="19279">If we look back</st><a id="_idIndexMarker661"/><st c="19295"> at the </st><code><st c="19303">CustomNumberPublisher</st></code><st c="19324"> subscriber we created in the </st><em class="italic"><st c="19354">Creating a custom publisher</st></em><st c="19381"> section, we can see that our publisher calls the </st><st c="19431">subscriber directly:</st></p>
			<pre class="source-code"><st c="19451">
_ = subscriber.receive(number)</st></pre>			<p><st c="19482">That’s the </st><code><st c="19494">receive(_ input:Int)</st></code><st c="19514"> method we need to implement as part of the subscriber protocol. </st><st c="19579">This method handles the incoming updates, similar to the closure we saw in the </st><code><st c="19658">sink</st></code><st c="19662"> function (in the </st><em class="italic"><st c="19680">Setting up the </st></em><em class="italic"><st c="19695">Subscriber</st></em><st c="19705"> section).</st></p>
			<p><st c="19715">Notice that the </st><code><st c="19732">receive</st></code><st c="19739"> function returns </st><code><st c="19757">Subscribers.Demand</st></code><st c="19775">. That’s the same demand type we discussed in the previous function. </st><st c="19844">When the subscriber finishes handling the input, it must inform the publisher how many more items it demands. </st><st c="19954">Demanding more items doesn’t replace the demand sent in the previous function when the subscriber first established its subscription to the publisher. </st><st c="20105">The new demand request is an additive value that needs to be handled by </st><st c="20177">the publisher.</st></p>
			<p><st c="20191">Look at the </st><st c="20204">following code:</st></p>
			<pre class="source-code"><st c="20219">
    func receive(subscription: Subscription) {
        subscription.request(.max(2))
    }
    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print("Received: \(input)")
        return .max(3)
    }</st></pre>			<p><st c="20390">Let’s try to follow the calls in this </st><st c="20429">code example:</st></p>
			<ul>
				<li><st c="20442">The subscriber subscribes to the publisher, and the </st><code><st c="20495">receive(subscription: Subscription)</st></code><st c="20530"> function is called, returning a maximum of </st><code><st c="20574">1</st></code><st c="20575">. The total demand is </st><st c="20597">now </st><code><st c="20601">1</st></code><st c="20602">.</st></li>
				<li><st c="20603">The publisher emits a value to the subscriber, and the </st><code><st c="20659">receive(_ input:Int)</st></code><st c="20679"> function is called, returning a maximum of </st><code><st c="20723">3</st></code><st c="20724">. The total demand is </st><st c="20746">now </st><code><st c="20750">4</st></code><st c="20751">.</st></li>
			</ul>
			<p><st c="20752">As mentioned, it is the publisher’s responsibility</st><a id="_idIndexMarker662"/><st c="20803"> to manage the subscriber demand. </st><st c="20837">If we create our custom publisher, we need to </st><st c="20883">consider that.</st></p>
			<p><st c="20897">Now that we know how to start and manage a subscription, it’s no less important to understand how to </st><st c="20999">complete it.</st></p>
			<h3><st c="21011">receive(completion: Subscribers.Completion&lt;Never&gt;)</st></h3>
			<p><st c="21062">The publisher calls</st><a id="_idIndexMarker663"/><st c="21082"> the subscriber’s </st><code><st c="21100">receive(completion:)</st></code><st c="21120"> function when it completes publishing. </st><st c="21160">It can be either because the publisher has no updates or </st><st c="21217">an error.</st></p>
			<p><st c="21226">That’s where the subscriber needs to perform cleanups, update UI or application state, or print logs, mainly when an </st><st c="21344">error occurs.</st></p>
			<p><st c="21357">Here’s an example of the </st><code><st c="21383">receive(completion:)</st></code><st c="21403"> function:</st></p>
			<pre class="source-code"><st c="21413">
func receive(completion: Subscribers.Completion&lt;Never&gt;) {
    switch completion {
    case .finished:
        print("Subscription completed successfully.")
    case .failure(let error):
        print("Subscription failed with error: \(error)")
    }
}</st></pre>			<p><st c="21633">That’s a basic implementation</st><a id="_idIndexMarker664"/><st c="21663"> of the </st><code><st c="21671">receive(completion:)</st></code><st c="21691"> function.</st></p>
			<p><st c="21701">We now know how to create a custom publisher and a custom subscriber. </st><st c="21772">Now, let’s see how to </st><st c="21794">connect them.</st></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor360"/><st c="21807">Connecting the custom publisher and subscriber</st></h2>
			<p><st c="21854">To complete the picture</st><a id="_idIndexMarker665"/><st c="21878"> of how the subscriber and the publisher work together, we must return to the publisher and respond to our subscriber </st><st c="21996">demand requests.</st></p>
			<p><st c="22012">Let’s see an example of how to implement a </st><code><st c="22056">receive</st></code><st c="22063"> function on the </st><st c="22080">publisher side:</st></p>
			<pre class="source-code"><st c="22095">
    func receive&lt;S: Subscriber&gt;(subscriber: S) where
      S.Input == Output, S.Failure == Failure {
        for number in numbers {
            guard subscriber.receive(number) != .none else
            {
                subscriber.receive(completion: .finished)
                return
            }
        }
        subscriber.receive(completion: .finished)
    }</st></pre>			<p><st c="22356">In the code example, the publisher keeps sending more updates to the subscriber as long as the subscriber keeps demanding them. </st><st c="22485">When the subscriber stops demanding more updates, the publisher closes the stream and calls the subscriber </st><code><st c="22592">receive(completion:)</st></code><st c="22612"> function.</st></p>
			<p><st c="22622">At this point, we should be familiar</st><a id="_idIndexMarker666"/><st c="22659"> with how subscribers and publishers work together. </st><st c="22711">We created custom publishers and subscribers and performed basic subscriptions. </st><st c="22791">Let’s improve these subscriptions with operators, something we have </st><st c="22859">barely discussed.</st></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor361"/><st c="22876">Working with operators</st></h2>
			<p><st c="22899">Subscriptions and publishers</st><a id="_idIndexMarker667"/><st c="22928"> are great, but the true power of Combine comes </st><st c="22976">from operators.</st></p>
			<p><st c="22991">Unlike subscriptions and publishers, operators are not protocols or instances. </st><st c="23071">Operators are just publisher methods that republish the update downstream and create a chain of data manipulations until the subscriber reaches the end of </st><st c="23226">the pipeline.</st></p>
			<p><st c="23239">Operators help us modify the updates, filter them, merge them, and perform many operations, which allows us to achieve an </st><st c="23362">ideal result.</st></p>
			<p><st c="23375">The Combine framework</st><a id="_idIndexMarker668"/><st c="23397"> comes with many built-in operators. </st><st c="23434">We will go over only some of them now, but you can go over the full list at the Apple </st><st c="23520">website: </st><a href="https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators"><st c="23529">https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators</st></a></p>
			<p><st c="23615">Let’s start with some </st><st c="23638">basic operators.</st></p>
			<h3><st c="23654">Starting with basic operators</st></h3>
			<p><st c="23684">One of the most basic use cases for operators in Combine is to </st><em class="italic"><st c="23748">filter</st></em><st c="23754"> the updates that the </st><st c="23776">publisher delivers.</st></p>
			<p><st c="23795">For example, we can use the </st><code><st c="23824">filter</st></code><st c="23830"> operator:</st></p>
			<pre class="source-code"><st c="23840">
let cancellable = (1...10).publisher
    .filter{ $0 % 2 == 0 }
    .sink { value in
        print(value)
    }</st></pre>			<p><st c="23932">In this code example, we created a publisher that emits values from </st><code><st c="24001">1</st></code><st c="24002"> to </st><code><st c="24006">10</st></code><st c="24008">. The </st><code><st c="24014">filter</st></code><st c="24020"> operator ensures that only even numbers will continue downstream. </st><st c="24087">This code will print </st><code><st c="24108">2</st></code><st c="24109">, </st><code><st c="24111">4</st></code><st c="24112">, </st><code><st c="24114">6</st></code><st c="24115">, </st><code><st c="24117">8</st></code><st c="24118">, and </st><code><st c="24124">10</st></code><st c="24126"> to </st><st c="24130">the console.</st></p>
			<p><st c="24142">Another example of a filtering operator </st><st c="24183">is </st><code><st c="24186">removeDuplicates</st></code><st c="24202">:</st></p>
			<pre class="source-code"><st c="24204">
let cancellable = [1,2,2,3,3,3,4,5].publisher
</st><strong class="bold"><st c="24251">    .removeDuplicates()</st></strong><st c="24270">
    .sink { value in
    print(value)
}</st></pre>			<p><st c="24301">The code example shows a publisher that emits duplicate values. </st><st c="24366">The </st><code><st c="24370">removeDuplicates</st></code><st c="24386"> operator filters out the values in case they were sent in the last update. </st><st c="24462">The console will show </st><st c="24484">the following:</st></p>
			<pre class="source-code"><st c="24498">
1
2
3
4
5</st></pre>			<p><st c="24508">Let’s try to create a custom operator </st><a id="_idIndexMarker669"/><st c="24547">to understand how an operator </st><st c="24577">works underneath.</st></p>
			<h3><st c="24594">Creating a custom operator</st></h3>
			<p><st c="24621">When we try to examine</st><a id="_idIndexMarker670"/><st c="24644"> the filter operator</st><a id="_idIndexMarker671"/><st c="24664"> in Apple’s header files, we can see </st><st c="24701">the following:</st></p>
			<pre class="source-code"><st c="24715">
extension Publisher {
…
public func filter(_ isIncluded: @escaping (Self.Output) -&gt;
  Bool) -&gt; Publishers.Filter&lt;Self&gt;
}</st></pre>			<p><code><st c="24834">filter()</st></code><st c="24843"> is a function that accepts a closure with a parameter of a generic type of </st><code><st c="24919">Output</st></code><st c="24925"> and returns a publisher. </st><st c="24951">This function extends the </st><code><st c="24977">Publisher</st></code><st c="24986"> protocol we discussed earlier under </st><em class="italic"><st c="25023">Creating a </st></em><em class="italic"><st c="25034">custom publisher</st></em><st c="25050">.</st></p>
			<p><st c="25051">The important thing to notice here is that the </st><code><st c="25099">filter</st></code><st c="25105"> function republishes the values and allows multiple operators to be chained together to create a complex data </st><st c="25216">processing pipeline.</st></p>
			<p><st c="25236">This is similar to how view modifiers work with SwiftUI – they modify the current view and return a </st><st c="25337">new view.</st></p>
			<p><st c="25346">To create our own custom</st><a id="_idIndexMarker672"/><st c="25371"> operator, let’s try to do the same</st><a id="_idIndexMarker673"/><st c="25406"> thing and create a </st><code><st c="25426">multiply</st></code><st c="25434"> operator. </st><st c="25445">Our </st><code><st c="25449">multiply</st></code><st c="25457"> operator accepts an </st><code><st c="25478">Int</st></code><st c="25481"> value and republishes it while multiplying with a </st><st c="25532">certain factor:</st></p>
			<pre class="source-code"><st c="25547">
extension Publisher where Output == Int {
    func multiply(by factor: Int) -&gt; Publishers.Map&lt;Self,
      Int&gt; {
        return self.map { value in
            return value * factor
        }
    }
}</st></pre>			<p><st c="25705">In our code example, we also extended the </st><code><st c="25748">Publisher</st></code><st c="25757"> protocol while ensuring the </st><code><st c="25786">Output</st></code><st c="25792"> type needs to </st><st c="25807">be </st><code><st c="25810">Int</st></code><st c="25813">.</st></p>
			<p><st c="25814">We then create a </st><code><st c="25832">multiply</st></code><st c="25840"> function that accepts a factor as a parameter and returns a </st><st c="25901">new publisher.</st></p>
			<p><st c="25915">In our implementation, we use a </st><code><st c="25948">map</st></code><st c="25951"> operator to transform our value into a new one, which means we need to return a </st><code><st c="26032">Map</st></code><st c="26035"> publisher. </st><st c="26047">Let’s see how to use our </st><st c="26072">new operator:</st></p>
			<pre class="source-code"><st c="26085">
let cancellable = [1, 2, 3, 4, 5].publisher
    .multiply(by: 2)
    .sink { value in
        print("Received value: \(value)")
    }</st></pre>			<p><st c="26199">We added our new </st><code><st c="26217">multiply</st></code><st c="26225"> operator to a Combine stream that starts with an array of five numbers. </st><st c="26298">The output for this code would be </st><st c="26332">as follows:</st></p>
			<pre class="source-code"><st c="26343">
Received value: 2
Received value: 4
Received value: 6
Received value: 8
Received value: 10</st></pre>			<p><st c="26434">We created our </st><st c="26450">first operator!</st></p>
			<p><st c="26465">However, if you are like me, the return</st><a id="_idIndexMarker674"/><st c="26505"> of a new Map publisher</st><a id="_idIndexMarker675"/><st c="26528"> may bother you. </st><st c="26545">Let’s try to understand why it happened and what we can do </st><st c="26604">about it.</st></p>
			<h3><st c="26613">Working with AnyPublisher</st></h3>
			<p><st c="26639">Our intuition says</st><a id="_idIndexMarker676"/><st c="26658"> that if </st><code><st c="26667">multiply</st></code><st c="26675"> is a function that accepts an </st><code><st c="26706">Int</st></code><st c="26709"> type and returns</st><a id="_idIndexMarker677"/><st c="26726"> a new value, why do we need to use a </st><st c="26764">Map publisher?</st></p>
			<p><st c="26778">So, we need to remember that operators republish our values. </st><st c="26840">The function doesn’t return a value but rather a publisher that publishes the new value. </st><st c="26929">It might not sound obvious, but our goal is to create a chain of publishers and multiply, despite its name, which is part of </st><st c="27054">this chain.</st></p>
			<p><st c="27065">So, our solution is to return some sort of a </st><em class="italic"><st c="27111">generic publisher</st></em><st c="27128">, or what we call in Combine – </st><code><st c="27159">AnyPublisher</st></code><st c="27171">.</st></p>
			<p><code><st c="27172">AnyPublisher</st></code><st c="27185"> is a type-erased publisher, and we use it to present a more abstract interface to </st><st c="27268">our publishers.</st></p>
			<p><st c="27283">Let’s see our </st><code><st c="27298">multiply</st></code><st c="27306"> operator</st><a id="_idIndexMarker678"/><st c="27315"> version, which now returns </st><code><st c="27343">AnyPublisher</st></code><st c="27355"> instead</st><a id="_idIndexMarker679"/> <st c="27363">of </st><code><st c="27367">Publisher.Map</st></code><st c="27380">:</st></p>
			<pre class="source-code"><st c="27382">
extension Publisher where Output == Int {
    func multiply(by factor: Int) -&gt; AnyPublisher&lt;Int,
      Failure&gt; {
        return self.map { value in
            return value * factor
        }
        .eraseToAnyPublisher()
    }
}</st></pre>			<p><st c="27564">In this code example, we performed </st><st c="27600">two changes:</st></p>
			<ul>
				<li><st c="27612">We changed the function’s return type to </st><code><st c="27654">AnyPublisher&lt;Int, Failure&gt;</st></code><st c="27680">. In this way, we hide the implementation details and the fact that we used the </st><st c="27760">Map publisher.</st></li>
				<li><st c="27774">We erased the publisher type using the </st><code><st c="27814">eraseToAnyPublisher()</st></code><st c="27835"> function, which erases the publisher type and </st><st c="27882">returns </st><code><st c="27890">AnyPublisher</st></code><st c="27902">.</st></li>
			</ul>
			<p><st c="27903">At first glance, it looks like </st><code><st c="27935">AnyPublisher</st></code><st c="27947"> is there only for semantic reasons. </st><st c="27984">But when I said that returning a Map publisher </st><em class="italic"><st c="28031">bothers</st></em><st c="28038"> me, it wasn’t because it didn’t look nice. </st><st c="28082">It’s because </st><code><st c="28095">AnyPublisher</st></code><st c="28107"> has practical implications for how we build </st><st c="28152">Combine streams.</st></p>
			<p><st c="28168">One reason is </st><em class="italic"><st c="28183">API design</st></em><st c="28193">. Using </st><code><st c="28201">AnyPublisher</st></code><st c="28213"> allows us to design a more flexible and polymorphic API interface. </st><st c="28281">Our previous version of the </st><code><st c="28309">multiply</st></code><st c="28317"> function returned a specific type of publisher. </st><st c="28366">Returning </st><code><st c="28376">AnyPublisher</st></code><st c="28388"> makes it easier to chain publishers together because they are from the </st><st c="28460">same type.</st></p>
			<p><st c="28470">Another reason is </st><em class="italic"><st c="28489">decoupling</st></em><st c="28499"> – by returning publishers as </st><code><st c="28529">AnyPublisher</st></code><st c="28541">, we’re decoupling our publisher’s implementation from its usage. </st><st c="28607">By that, we make our code more modular </st><st c="28646">and maintainable.</st></p>
			<p><st c="28663">The </st><code><st c="28668">filter</st></code><st c="28674"> and </st><code><st c="28679">removeDuplicates</st></code><st c="28695"> operators, along with </st><code><st c="28718">map</st></code><st c="28721">, are great for streamlining</st><a id="_idIndexMarker680"/><st c="28749"> and manipulating values</st><a id="_idIndexMarker681"/><st c="28773"> along the pipeline. </st><st c="28794">We also reviewed the </st><code><st c="28815">merge</st></code><st c="28820"> operator when we discussed Subjects in the </st><em class="italic"><st c="28864">Working with Subjects</st></em><st c="28885"> section. </st><st c="28895">But Combine offers more advanced operators. </st><st c="28939">Let’s go over some of </st><st c="28961">them now.</st></p>
			<h3><st c="28970">Exploring advanced operators</st></h3>
			<p><st c="28999">Let’s face it, up until now, we discussed operators</st><a id="_idIndexMarker682"/><st c="29051"> that performed tasks that were easy to do even without Combine. </st><st c="29116">Yes, using </st><code><st c="29127">map</st></code><st c="29130"> and </st><code><st c="29135">filter</st></code><st c="29141"> operators is extremely valuable, but they don’t reflect the real Combine </st><st c="29215">added value.</st></p>
			<p><st c="29227">One of the Combine framework goals is to create much more sophisticated and complex streams that can be error-prone to do </st><st c="29350">without it.</st></p>
			<p><st c="29361">Let’s understand what I mean and explore the </st><code><st c="29407">zip</st></code><st c="29410"> operator.</st></p>
			<h4><st c="29420">Using the zip operator</st></h4>
			<p><st c="29443">The </st><code><st c="29448">zip</st></code><st c="29451"> operator combines values</st><a id="_idIndexMarker683"/><st c="29476"> from two publishers and emits a tuple only after each publisher emits </st><st c="29547">its value.</st></p>
			<p><st c="29557">Once the </st><code><st c="29567">zip</st></code><st c="29570"> operator receives values from all publishers, it emits a tuple and </st><em class="italic"><st c="29638">resets</st></em><st c="29644"> itself. </st><st c="29653">This means it waits again to receive values from all publishers before it emits a </st><st c="29735">new tuple.</st></p>
			<p><st c="29745">Let’s see a simple </st><st c="29765">code example:</st></p>
			<pre class="source-code"><st c="29778">
import Combine
let publisher1 = PassthroughSubject&lt;Int, Never&gt;()
let publisher2 = PassthroughSubject&lt;Int, Never&gt;()
let cancellable = publisher1
    .zip(publisher2)
    .sink { value in
    print("Zipped value: \(value)")
}
publisher1.send(1)  // no output
publisher2.send(10) // output is (1,10)
publisher1.send(2)  // no output
publisher2.send(20) // output is (2,20)</st></pre>			<p><st c="30134">In this code example, we used two Subjects</st><a id="_idIndexMarker684"/><st c="30177"> to send values to our subscriber. </st><st c="30212">We zipped them together and printed </st><st c="30248">the output.</st></p>
			<p><st c="30259">We can see that after </st><code><st c="30282">publisher1</st></code><st c="30292"> sends a value, the stream doesn’t continue and waits for </st><code><st c="30350">publisher2</st></code><st c="30360"> to send its value. </st><st c="30380">Only after </st><code><st c="30391">publisher2</st></code><st c="30401"> sends a value does the stream continue and print </st><code><st c="30451">(1,10)</st></code><st c="30457"> to the console. </st><st c="30474">At this point, the </st><code><st c="30493">zip</st></code><st c="30496"> operator is reset, and again, it waits for both publishers to </st><st c="30559">emit values.</st></p>
			<p><st c="30571">The </st><code><st c="30576">zip</st></code><st c="30579"> operator is not limited to two publishers. </st><st c="30623">We can also use </st><code><st c="30639">zip</st></code><st c="30642"> for three publishers and receive a tuple </st><st c="30684">of three.</st></p>
			<p><st c="30693">The </st><code><st c="30698">zip</st></code><st c="30701"> operator belongs to a group of Combine operators that handles multiple publishers together. </st><st c="30794">We already saw the </st><code><st c="30813">merge</st></code><st c="30818"> operator under the </st><em class="italic"><st c="30838">Working with </st></em><em class="italic"><st c="30851">Subjec</st><a id="_idTextAnchor362"/><a id="_idTextAnchor363"/><st c="30857">ts</st></em><st c="30860"> section.</st></p>
			<p><st c="30869">Another operator that belongs to this category is </st><code><st c="30920">combineLatest</st></code><st c="30933">. Let’s go over </st><st c="30949">it now.</st></p>
			<h4><st c="30956">Combining multiple values using combineLatest</st></h4>
			<p><st c="31002">The </st><code><st c="31007">zip</st></code><st c="31010"> operator combines</st><a id="_idIndexMarker685"/><st c="31028"> multiple publisher</st><a id="_idIndexMarker686"/><st c="31047"> outputs into a tuple. </st><st c="31070">However, it waits for all publishers to send values </st><st c="31122">each time.</st></p>
			<p><st c="31132">The </st><code><st c="31137">combineLatest</st></code><st c="31150"> operator only waits for the first time for all publishers to emit values, and from this point, it emits a new tuple each time one of the publishers sends a </st><st c="31307">new value.</st></p>
			<p><st c="31317">Let’s see an example </st><st c="31339">of </st><code><st c="31342">combineLatest</st></code><st c="31355">:</st></p>
			<pre class="source-code"><st c="31357">
let publisher1 = PassthroughSubject&lt;Int, Never&gt;()
let publisher2 = PassthroughSubject&lt;Int, Never&gt;()
let cancellable = publisher1
    .combineLatest(publisher2)
    .sink { value in
    print("Combined value: \(value)")
}
publisher1.send(1)  // no output
publisher2.send(10) // output will be 1,10
publisher1.send(2) // output will be 2,10
publisher2.send(20) // output will be 2,20</st></pre>			<p><st c="31726">In this code example, we also have two Subjects</st><a id="_idIndexMarker687"/><st c="31774"> that send values. </st><st c="31793">This time, we combined</st><a id="_idIndexMarker688"/><st c="31815"> them </st><st c="31821">using </st><code><st c="31827">combineLatest</st></code><st c="31840">.</st></p>
			<p><st c="31841">After </st><code><st c="31848">publisher1</st></code><st c="31858"> sends its first value, </st><code><st c="31882">combineLatest</st></code><st c="31895"> halts the stream as it waits for </st><code><st c="31929">publisher2</st></code><st c="31939"> to send </st><st c="31948">a value.</st></p>
			<p><st c="31956">Once </st><code><st c="31962">publisher2</st></code><st c="31972"> sends its first value, </st><code><st c="31996">combineLatest</st></code><st c="32009"> emits a tuple with the values </st><st c="32040">of (</st><code><st c="32044">1,10</st></code><st c="32049">).</st></p>
			<p><st c="32052">Next, </st><code><st c="32059">publisher1</st></code><st c="32069"> sends a new value – </st><code><st c="32090">2</st></code><st c="32091">. This time, </st><code><st c="32104">combineLatest</st></code><st c="32117"> doesn’t wait for </st><code><st c="32135">publisher2</st></code><st c="32145"> to send a new value and emits a new tuple – (</st><code><st c="32191">2,10</st></code><st c="32196">)</st></p>
			<p><st c="32198">The behavior of emitting a new tuple each time one of the publishers sends a new value makes </st><code><st c="32291">combineLatest</st></code><st c="32304"> a top-rated operator for handling </st><st c="32339">asynchronized operations.</st></p>
			<p><st c="32364">Imagine you have a screen being updated by multiple sources, such as a search results screen of live sports updates, and each time we get a new update, we want our screen to refresh its UI to reflect the </st><st c="32569">new state.</st></p>
			<p><code><st c="32579">combineLatest</st></code><st c="32593"> is ideal for such a case, as it creates a new tuple downstream whenever one of the publishers emits a </st><st c="32696">new value.</st></p>
			<p><st c="32706">We can use many more useful</st><a id="_idIndexMarker689"/><st c="32734"> operators; you can find</st><a id="_idIndexMarker690"/><st c="32758"> them all on Apple’s website. </st><st c="32788">However, the real challenge with adopting Combine in our projects is understanding how to implement them in real-life </st><st c="32906">use cases.</st></p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor364"/><st c="32916">Learning about Combine using examples</st></h1>
			<p><st c="32954">Up until now, we have discussed several Combine</st><a id="_idIndexMarker691"/><st c="33002"> components and delved into understanding how Combine works underneath by creating our custom publishers, subscribers, </st><st c="33121">and operators.</st></p>
			<p><st c="33135">Despite that, many developers need help incorporating Combine frameworks in </st><st c="33212">real-life scenarios.</st></p>
			<p><st c="33232">The different publishers and operators are mostly clear in theory, but it can be difficult to imagine them as part of the central design patterns we use in </st><st c="33389">our projects.</st></p>
			<p><st c="33402">Let’s review some examples to help us understand how to implement Combine in our projects. </st><st c="33494">We’ll start with a basic example of managing a UI state in a </st><st c="33555">view model.</st></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor365"/><st c="33566">Managing UIKit-based view state in a view model</st></h2>
			<p><st c="33614">SwiftUI view states</st><a id="_idIndexMarker692"/><st c="33634"> are naturally</st><a id="_idIndexMarker693"/><st c="33648"> declarative. </st><st c="33662">This means we can bind the view state, such as a list of items, to a UI component, such as a </st><code><st c="33755">List</st></code><st c="33759"> view. </st><st c="33766">That’s the only way to handle states </st><st c="33803">in SwiftUI.</st></p>
			<p><st c="33814">However, achieving that design pattern in UIKit takes time </st><st c="33874">and effort.</st></p>
			<p><st c="33885">Using Combine, we can create a publisher and bind our table view data source to reflect any changes coming from </st><st c="33998">the server.</st></p>
			<p><st c="34009">Here’s a code example for such a </st><st c="34043">view model:</st></p>
			<pre class="source-code"><st c="34054">
class MyViewModel {
    struct Item: Codable {
        let title: String
        let description: String
    }
    var dataPublisher: AnyPublisher&lt;[Item], Error&gt; {
        return URLSession.shared.dataTaskPublisher(for:
          URL(string: "https://api.example.com/data")!)
            .map { $0.data }
            .decode(type: [Item].self, decoder:
              JSONDecoder())
            .eraseToAnyPublisher()
    }
}</st></pre>			<p><st c="34379">We have already discussed</st><a id="_idIndexMarker694"/><st c="34405"> the </st><code><st c="34410">AnyPublisher</st></code><st c="34422"> form, and that’s a great example</st><a id="_idIndexMarker695"/><st c="34455"> of its usage. </st><st c="34470">We create a publisher that starts with a URL request, extracts its data using the </st><code><st c="34552">map</st></code><st c="34555"> operator, and decodes it into an array of Items. </st><st c="34605">To hide the publisher implementation, we erase its type for </st><code><st c="34665">AnyPublisher</st></code><st c="34677">. Connecting the view model to the view controller is simple now that we have </st><st c="34755">a publisher:</st></p>
			<pre class="source-code"><st c="34767">
        viewModel.dataPublisher
            .sink(receiveCompletion: { completion in
            }, receiveValue: { [weak self] data in
                self?.updateTableView(with: data)
            })
            .store(in: &amp;cancellables)</st></pre>			<p><st c="34934">In this code example, we subscribe to our new </st><code><st c="34981">dataPublisher</st></code><st c="34994"> and update our table view with </st><st c="35026">the data.</st></p>
			<p><st c="35035">To make our project</st><a id="_idIndexMarker696"/><st c="35055"> even more modular, we can move</st><a id="_idIndexMarker697"/><st c="35086"> the </st><code><st c="35091">URLSession</st></code> <code><st c="35101">dataTaskPublisher</st></code><st c="35119"> function to a class of its own and keep the separation of </st><st c="35178">concerns principle.</st></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor366"/><st c="35197">Performing searches from multiple sources</st></h2>
			<p><st c="35239">One of the most popular</st><a id="_idIndexMarker698"/><st c="35263"> use cases of iOS development is performing</st><a id="_idIndexMarker699"/><st c="35306"> a search from the server and the </st><st c="35340">local database.</st></p>
			<p><st c="35355">The requirement for such a search is first to show results from the local data store and then go to the server and </st><st c="35471">return results.</st></p>
			<p><st c="35486">This is a common requirement, and using Combine is also easy. </st><st c="35549">Let’s see a simple example </st><st c="35576">of that:</st></p>
			<pre class="source-code"><st c="35584">
func searchLocalDatabase(query: String) -&gt; AnyPublisher&lt;[SearchResult], Never&gt; {
    return Just([
        SearchResult(id: 1, title: "Local Result 1"),
        SearchResult(id: 2, title: "Local Result 2")
    ])
    .delay(for: .seconds(1), scheduler: DispatchQueue.main)
    .eraseToAnyPublisher()
}
func searchServer(query: String) -&gt;
  AnyPublisher&lt;[SearchResult], Never&gt; {
    return Future { promise in
        DispatchQueue.global().asyncAfter(deadline: .now()
          + 2) {
            promise(.success([
                SearchResult(id: 3, title: "Server Result
                  1"),
                SearchResult(id: 4, title: "Server Result
                  2")
            ]))
        }
    }
    .eraseToAnyPublisher()
}
var cancellables = Set&lt;AnyCancellable&gt;()
let query = "example"
var totalResults = [SearchResult]()
searchLocalDatabase(query: query)
    .merge(with: searchServer(query: query))
    .sink(receiveCompletion: { _ in }, receiveValue: {
      results in
        totalResults.append(contentsOf: results)
        print("Search results: \(totalResults)")
    })
    .store(in: &amp;cancellables)</st></pre>			<p><st c="36505">In this code</st><a id="_idIndexMarker700"/><st c="36518"> example, we performed</st><a id="_idIndexMarker701"/><st c="36540"> three </st><st c="36547">primary steps:</st></p>
			<ol>
				<li><code><st c="36901">Just</st></code><st c="36905"> and </st><code><st c="36910">Future</st></code><st c="36916">. We can use </st><code><st c="36929">Just</st></code><st c="36933"> to start a stream, and </st><code><st c="36957">Future</st></code><st c="36963"> is a publisher we use to perform a task and emit the </st><st c="37017">value asynchronously.</st></li>
				<li><code><st c="37167">merge</st></code><st c="37172"> operator. </st><st c="37183">Remember that the </st><code><st c="37201">merge</st></code><st c="37206"> operator emits an update if one of its sources emits a new value. </st><st c="37273">We could also use </st><code><st c="37291">combineLatest</st></code><st c="37304">, but </st><code><st c="37310">combineLatest</st></code><st c="37323"> waits for all the publishers to emit values before it emits the combined </st><st c="37397">value downstream.</st></li>
				<li><code><st c="37510">totalResults</st></code><st c="37522"> array. </st><st c="37530">Our data flow doesn’t have to end here. </st><st c="37570">We can make </st><code><st c="37582">totalResults</st></code><st c="37594"> a </st><code><st c="37597">CurrentValueSubject</st></code><st c="37616"> instance and deliver the results to the view model or the view itself. </st><st c="37688">If we are working with SwiftUI, we can make </st><code><st c="37732">totalResults</st></code><st c="37744"> a </st><code><st c="37747">@Published</st></code><st c="37757"> variable to refresh the search results </st><st c="37797">UI automatically.</st></li>
			</ol>
			<p><st c="37814">There’s a nice lesson here related</st><a id="_idIndexMarker702"/><st c="37849"> to using Combine</st><a id="_idIndexMarker703"/><st c="37866"> in our projects. </st><st c="37884">If we create publishers for different data sources and ensure they emit values, it becomes easy to create pipelines of updates and connect them to the rest of </st><st c="38043">the project.</st></p>
			<p><st c="38055">The following example handles another everyday use case, which is </st><st c="38122">form validation.</st></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor367"/><st c="38138">Validating forms</st></h2>
			<p><st c="38155">Forms are common use cases</st><a id="_idIndexMarker704"/><st c="38182"> in any user-facing platform, not just iOS. </st><st c="38226">One of the most essential responsibilities of creating forms is the ability to validate </st><st c="38314">their inputs.</st></p>
			<p><st c="38327">Let’s see how to use Combine to validate a simple </st><st c="38378">sign-in form:</st></p>
			<pre class="source-code"><st c="38391">
struct FormView: View {
    @ObservedObject var viewModel = FormViewModel()
    var body: some View {
        VStack {
            TextField("Username", text:
              $viewModel.username)
              .padding()
             .textFieldStyle(RoundedBorderTextFieldStyle())
            SecureField("Password", text:
              $viewModel.password)
              .padding()
             .textFieldStyle(RoundedBorderTextFieldStyle())
            Button("Login") {
                if viewModel.isFormValid {
                    print("Login successful!")
                } else {
                    print("Please fill in all fields.")
                }
            }
            .padding()
            .disabled(!viewModel.isFormValid)
        }
        .padding()
    }
}</st></pre>			<p><st c="38893">Our form contains two text fields – </st><code><st c="38930">username</st></code><st c="38938"> and </st><code><st c="38943">password</st></code><st c="38951">. We also have a view model attached to the view. </st><st c="39001">The view model has several </st><code><st c="39028">@Published</st></code><st c="39038"> variables, such as </st><code><st c="39058">username</st></code><st c="39066">, </st><code><st c="39068">password</st></code><st c="39076">, and </st><code><st c="39082">isFormValid</st></code><st c="39093">. The </st><code><st c="39099">username</st></code><st c="39107"> and </st><code><st c="39112">password</st></code><st c="39120"> variables are connected to the view </st><st c="39157">text fields.</st></p>
			<p><st c="39169">Now, let’s see the </st><code><st c="39189">FormViewModel</st></code><st c="39202"> class:</st></p>
			<pre class="source-code"><st c="39209">
class FormViewModel: ObservableObject {
    @Published var username: String = ""
    @Published var password: String = ""
    @Published var isFormValid: Bool = false
    private var cancellables = Set&lt;AnyCancellable&gt;()
    init() {
        Publishers.combineLatest($username, $password)
            .map { username, password in
                !username.isEmpty &amp;&amp; !password.isEmpty
            }
            .assign(to: \.isFormValid, on: self)
            .store(in: &amp;cancellables)
    }
}</st></pre>			<p><st c="39606">When we initialize the view</st><a id="_idIndexMarker705"/><st c="39634"> model, we create a Combine stream based on the </st><code><st c="39682">combineLatest</st></code><st c="39695"> operator to observe changes in the </st><code><st c="39731">username</st></code><st c="39739"> and </st><code><st c="39744">password</st></code><st c="39752"> variables. </st><st c="39764">The </st><code><st c="39768">map</st></code><st c="39771"> operator ensures that both variables are not empty, and we assign the results (</st><code><st c="39851">Bool</st></code><st c="39856">) to the </st><code><st c="39866">isFormValid</st></code><st c="39877"> variable.</st></p>
			<p><st c="39887">The view observes the </st><code><st c="39910">isFormValid</st></code><st c="39921"> value and uses it to turn the login button on </st><st c="39968">and off.</st></p>
			<p><st c="39976">This stream is basic; we can achieve the same results without Combine. </st><st c="40048">However, forms can become very complex at some point. </st><st c="40102">The Combine pipeline we created is an excellent infrastructure for more </st><st c="40174">complicated forms.</st></p>
			<p><st c="40192">Even simple rules for </st><code><st c="40215">username</st></code><st c="40223"> and </st><code><st c="40228">password</st></code><st c="40236"> can be easily enforced using our stream, as in </st><st c="40284">this example:</st></p>
			<pre class="source-code"><st c="40297">
 Publishers.combineLatest($username, $password)
            .map { username, password in
                let isUsernameValid = !username.isEmpty &amp;&amp;
                  username.count &gt;= 6
                let isPasswordValid = !password.isEmpty &amp;&amp;
                  password.count &gt;= 8 &amp;&amp; password.contains(
                    where: { $0.isNumber })
                return isUsernameValid &amp;&amp; isPasswordValid
            }
            .assign(to: \.isFormValid, on: self)
            .store(in: &amp;cancellables)</st></pre>			<p><st c="40652">In this code example, we used our Combine stream</st><a id="_idIndexMarker706"/><st c="40701"> to enforce rules – the password needs at least eight characters including a number, and the username needs at least six characters. </st><st c="40834">The </st><code><st c="40838">map</st></code><st c="40841"> operator is great for centralizing this logic, outputting a Boolean value, and assigning it to the </st><code><st c="40941">isFormValid</st></code><st c="40952"> value.</st></p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor368"/><st c="40959">Summary</st></h1>
			<p><st c="40967">Combine makes our code reactive beyond SwiftUI views. </st><st c="41022">It’s a framework that can help us handle complex tasks such as search, network requests, and </st><st c="41115">state management.</st></p>
			<p><st c="41132">This chapter reviewed the basic Combine components, such as the publisher, subscriber, and operator. </st><st c="41234">We also delved in and created custom versions of each of the components. </st><st c="41307">We learned how to create pipelines with data transforms and network requests. </st><st c="41385">In the end, we learned how to incorporate Combine in common </st><st c="41445">use cases.</st></p>
			<p><st c="41455">By now, we should be able to start working with Combine on our </st><st c="41519">existing projects.</st></p>
			<p><st c="41537">The next chapter touches on another topic many iOS developers feel irritated by – </st><st c="41620">Core Data.</st></p>
		</div>
	<div></body></html>