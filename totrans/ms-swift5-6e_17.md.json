["```swift\nstruct MyValueType { \n    var name: String\n    var assignment: String \n    var grade: Int\n} \n```", "```swift\nclass MyReferenceType { \n    var name: String\n    var assignment: String \n    var grade: Int\n    init(name: String, assignment: String, grade: Int) { \n        self.name = name\n        self.assignment = assignment \n        self.grade = grade\n    }\n} \n```", "```swift\nvar ref = MyReferenceType(name: \"Jon\", assignment: \"Math Test 1\", grade: 90)\nvar val = MyValueType(name: \"Jon\", assignment: \"Math Test 1\", grade: 90) \n```", "```swift\nfunc extraCreditReferenceType(ref: MyReferenceType, extraCredit: Int) {\n    ref.grade += extraCredit\n}\nfunc extraCreditValueType(val: MyValueType, extraCredit: Int) { \n    val.grade += extraCredit\n} \n```", "```swift\nfunc getGradeForAssignment(assignment: inout MyValueType) {\n    // Code to get grade from DB\n    // Random code here to illustrate issue \n    let num = Int.random(in: 80..<100)\n    assignment.grade = num\n    print(\"Grade for \\(assignment.name) is \\(num)\")\n} \n```", "```swift\nvar mathGrades = [MyValueType]()\nvar students = [\"Jon\", \"Kailey\", \"Kara\"]\nvar mathAssignment = MyValueType(name: \"\", assignment: \"Math Assignment\", grade: 0)\nfor student in students { \n    mathAssignment.name = student\n    getGradeForAssignment(assignment: &mathAssignment)\n    mathGrades.append(mathAssignment)\n}\nfor assignment in mathGrades { \n    print(\"\\(assignment.name): grade \\(assignment.grade)\")\n} \n```", "```swift\nGrade for Jon is 87 \nGrade for Kailey is 90 \nGrade for Kara is 83\nJon: grade 87\nKailey: grade 90\nKara: grade 83 \n```", "```swift\nclass LinkedListReferenceType { \n    var value: String\n    var next: LinkedListReferenceType? \n    init(value: String) {\n        self.value = value\n    }\n} \n```", "```swift\nstruct LinkedListValueType { \n    var value: String\n    var next: LinkedListValueType?\n} \n```", "```swift\nvar one = LinkedListValueType(value: \"One\",next: nil) \nvar two = LinkedListValueType(value: \"Two\",next: nil)\nvar three = LinkedListValueType(value: \"Three\",next: nil) \n```", "```swift\none.next = two\ntwo.next = three \n```", "```swift\nclass Animal {\n    var numberOfLegs = 0 \n    func sleeps() {\n        print(\"zzzzz\")\n    }\n    func walking() {\n        print(\"Walking on \\(numberOfLegs) legs\")\n    }\n    func speaking() {\n        print(\"No sound\")\n    }\n} \n```", "```swift\nclass Biped: Animal { \n    override init() {\n        super.init() numberOfLegs =2\n    }\n}\nclass Quadruped: Animal { \n    override init() {\n        super.init() numberOfLegs = 4\n    }\n} \n```", "```swift\nclass Dog: Quadruped { \n    override func speaking() {\n        print(\"Barking\")\n    }\n} \n```", "```swift\nfinal func myFunc() {} \nfinal var myProperty = 0 \nfinal class MyClass {} \n```", "```swift\nclass Animal {\n    final var numberOfLegs = 0\n    func sleeps() { \n        print(\"zzzzz\")\n    }\n    final func walking() {\n        print(\"Walking on \\(numberOfLegs) legs\")\n    }\n    func speaking() { \n        print(\"No\tsound\")\n    }\n} \n```", "```swift\nfileprivate class BackendQueue<T> { \n    private var items = [T]()\n    public func addItem(item: T) { \n        items.append(item)\n    }\n    public func getItem() -> T? {\n        if items.count > 0 {\n            return items.remove(at: 0)\n        } else {\n            return nil\n        }\n    }\n    public func count() -> Int { \n        return items.count\n    }\n} \n```", "```swift\npublic init() {}\nprivate init(_ items: [T]) { \n    self.items = items\n} \n```", "```swift\npublic func copy() -> BackendQueue<T> {\n    return BackendQueue<T>(items)\n} \n```", "```swift\nfileprivate class BackendQueue<T> { \n    private var items = [T]()\n    public init() {}\n    private init(_ items: [T]) { \n        self.items = items\n    }\n    public func addItem(item: T) { \n        items.append(item)\n    }\n    public func getItem() -> T? { \n        if items.count > 0 {\n            return items.remove(at: 0)\n        } else {\n            return nil\n        }\n    }\n    public func count() -> Int { \n        return items.count\n    }\n    public func copy() -> BackendQueue<T> { \n        return BackendQueue<T>(items)\n    }\n} \n```", "```swift\nstruct Queue {\n    private var internalQueue = BackendQueue<Int>()\n    public mutating func addItem(item: Int) {\n        internalQueue.addItem(item: item)\n    }\n    public mutating func getItem() -> Int? { \n        return internalQueue.getItem()\n    }\n    public func count() -> Int { \n        return internalQueue.count()\n    }\n} \n```", "```swift\nmutating private func checkUniquelyReferencedInternalQueue() { \n    if !isKnownUniquelyReferenced(&internalQueue) {\n        internalQueue = internalQueue.copy() \n        print(\"Making a copy of internalQueue\")\n    } else {\n        print(\"Not making a copy of internalQueue\")\n    }\n} \n```", "```swift\nvar queue1 = Queue()\nvar queue2 = queue1 \n```", "```swift\npublic mutating func addItem(item: Int) { \n    checkUniquelyReferencedInternalQueue()\n    internalQueue.addItem(item: item)\n}\npublic mutating func getItem() -> Int? { \n    checkUniquelyReferencedInternalQueue()\n    return internalQueue.getItem()\n} \n```", "```swift\nmutating public func uniquelyReferenced() -> Bool { \n    return isKnownUniquelyReferenced(&internalQueue)\n} \n```", "```swift\nstruct Queue {\n    private var internalQueue = BackendQueue<Int>()\n    mutating private func checkUniquelyReferencedInternalQueue() { \n        if !isKnownUniquelyReferenced(&internalQueue) {\n            print(\"Making a copy of internalQueue\")\n            internalQueue = internalQueue.copy()\n        } else {\n            print(\"Not making a copy of internalQueue\")\n        }\n    }\n    public mutating func addItem(item: Int) { \n        checkUniquelyReferencedInternalQueue()\n        internalQueue.addItem(item: item)\n    }\n    public mutating func getItem() -> Int? {\n        checkUniquelyReferencedInternalQueue(); \n        return internalQueue.getItem()\n    }\n    public func count() -> Int { \n        return internalQueue.count()\n    }\n    mutating public func uniquelyReferenced() -> Bool { \n        return isKnownUniquelyReferenced(&internalQueue)\n    }\n} \n```", "```swift\nvar queue3 = Queue()\nqueue3.addItem(item: 1)\nprint(queue3.uniquelyReferenced()) \n```", "```swift\nNot making a copy of internalQueue \n```", "```swift\nvar queue4 = queue3 \n```", "```swift\nprint(queue3.uniquelyReferenced())\nprint(queue4.uniquelyReferenced()) \n```", "```swift\nqueue3.addItem(item: 2) \n```", "```swift\nMaking a copy of internalQueue \n```", "```swift\nstruct Place {\n    let id: String\n    let latitude: Double \n    let longitude: Double\n} \n```", "```swift\nextension Place: Equatable {\n    static func ==(lhs: Place, rhs: Place) -> Bool { \n        return lhs.id == rhs.id &&\n            lhs.latitude == rhs.latitude && \n            lhs.longitude == rhs.longitude\n    }\n} \n```", "```swift\nvar placeOne = Place(id: \"Fenway Park\", latitude: 42.3467, longitude: -71.0972)\nvar placeTwo = Place(id: \"Wrigley Field\", latitude: 41.9484, longitude: -87.6553)\nprint(placeOne == placeTwo) \n```", "```swift\nstruct Place: Equatable {\n    let id: String\n    let latitude: Double \n    let longitude: Double\n} \n```"]