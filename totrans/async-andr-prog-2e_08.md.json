["```java\nif (Build.VERSION.SDK_INT >= 9) {\n    // After Gingerbread, use the google recommended\n    // client, HttpUrlConnection\n    ...\n}  else {\n    // Prior to Gingerbread, use the Apache based\n    // client, AndroidHttpClient\n    ...\n}\n```", "```java\npublic interface AsyncHTTPClient {\n    void execute(HTTPRequest request, ResponseHandler handler);\n}\n```", "```java\npublic class HTTPRequest {\n\n  final Verb mVerb;\n  final String mUrl;\n  final List<Header> mHeaders;\n  final Map<String, String> mParameters;\n  final Body mBody;\n\n  private HTTPRequest(Builder builder) {...}\n  }\n```", "```java\npublic abstract class ResponseHandler {\n\n    // Method invoked when a success response is returned\n    // 200 Response Code\n    abstract public void onSuccess(HTTPResponse response) ;\n\n    // Method invoked when a failure response is returned\n    // 4XX, 50X \t\n    abstract public void onFailure(HTTPResponse response) ;\n\n    // Method Invoked when an error happens\n    abstract public void onError(Throwable error);\n}\n```", "```java\npublic class HTTPResponse {\n\n    final int mResponseCode;\n    final List<Header> mHeaders;\n    final Body mBody;\n\n}\n```", "```java\n public class HTTPAsyncTask extends\n  AsyncTask<HTTPRequest, Void, Result<HTTPResponse>> {\n\n  // Response Handler to be invoked In onPostExecute\n  // on the UI Thread\n  final ResponseHandler mHandler;\n\n  // Handler is passed on the constructor\n  public  HTTPAsyncTask(ResponseHandler handler) {\n    this.mHandler = handler;\n  }\n  ...\n}\n```", "```java\n@Override\nprotected Result<HTTPResponse> doInBackground(HTTPRequest... params) {\n\n  HTTPRequest request = params[0];\n  Body body = null;\n  HttpURLConnection conn = null;\n  Result<HTTPResponse> response = new Result<HTTPResponse>();\n  try {\n\n    // Retrieve the request URL from the request object\n    URL url = new URL(request.mUrl);\n\n    // Opens up the connection to the remote peer\n    conn = (HttpURLConnection) url.openConnection();\n\n    // Set the HTTP Request verb\n    conn.setRequestMethod(request.mVerb);\n\n    // set The HTTP Request Headers\n    setRequestHeaders(conn,request);\n\n    // Allows Receiving data on the response\n    conn.setDoInput(true);\n\n    // Retrieve the response code\n    int responseCode = conn.getResponseCode();\n\n    // Build the HTTP Response Object\n    HTTPResponse.Builder builder = new HTTPResponse.Builder()\n    .setResponseCode(responseCode);\n\n    // Fill the HTTP Response Headers\n    fillHeaders(conn.getHeaderFields(), builder);\n\n    // Read the Body from the Connection Input Stream\n    // using a factory\n    body = BodyFactory.read(conn.getContentType(),\n                              conn.getInputStream());\n    // Set the HTTPResponse body\n    builder.setBody(body);\n    // Build the HTTP Response Object\n    response.result = builder.build();\n  } catch (Exception e) {\n    response.error = e;\n  } finally {\n    if ( conn != null ) {\n      conn.disconnect();\n  }\n  }\n  return response;\n  }\n\n// Write any header to the Request Ex: Accept: text/xml\nvoid setRequestHeaders(HttpURLConnection con, HTTPRequest request ) {\n  for (Header header : request.mHeaders) {\n    con.addRequestProperty(header.getName(), header.getValue());\n  }\n}\n```", "```java\npublic class BodyFactory {\n\n  public static Body read(String mimeType,\n                          InputStream is) throws IOException {\n    Body result = null;\n    if ( mimeType.startsWith(\"text\") ) {\n      result = new TextPlainBody(mimeType);\n      result.consume(is);\n    }    \n    return result;\n  }\n}\n```", "```java\nabstract void consume(InputStream is)\n  throws IOException;\n```", "```java\nprotected void onPostExecute(Result<HTTPResponse> result) {\n\n  if ( result.error != null ) {\n    mHandler.onError(result.error);\n  } else if ( result.obj.mResponseCode ==\n              HttpURLConnection.HTTP_OK ) {\n    mHandler.onSuccess(result.obj);\n  } else {\n    mHandler.onFailure(result.obj);\n  }\n}\n```", "```java\npublic class PacktAsyncHTTPClient implements AsyncHTTPClient {\n\n  @Override\n  public void execute( HTTPRequest request,\n                       ResponseHandler handler) {\n    // Execute the HTTP Request on the default AsyncTask Executor\n    new HTTPAsyncTask(handler).execute(request);\n  }\n  ...\n }\n```", "```java\nprotected void onCreate(Bundle savedInstanceState) {\n   ...\n  HTTPRequest.Builder builder = new HTTPRequest.Builder();\n  // Set the HTTP Verb to GET\n  builder.setVerb(HTTPRequest.Verb.GET);\n  // Sets location of the remote resource\n  builder.setUrl(\"http://<hostname>:<port>/greetings\");\n  // Build the request object\n  HTTPRequest request =  builder.build();\n  ...\n}\n```", "```java\npublic abstract class TextResponseHandler \n  extends ResponseHandler {\n   // Response Callback receiving the string body\n    abstract void onSuccess(String response);\n\n    @Override\n    public void onSuccess(HTTPResponse response) {\n        TextPlainBody body = (TextPlainBody)response.mBody;\n        // Invoke the callback that receives a string\n        onSuccess(body.getContent());\n    }\n}\n```", "```java\nHTTPRequest request =  builder.build();\n// Create a client Instance object\nPacktAsyncHTTPClient client = new PacktAsyncHTTPClient();\n// Enable a progress bar\nProgressBar pb =(ProgressBar) findViewById(R.id.loading);\npb.setVisibility(View.VISIBLE);\n// Retrieve the response on the background\nclient.execute(request,textResponseHandler);\n...\n```", "```java\nTextResponseHandler greetingsHandler = new TextResponseHandler() {\n\n  // Invoked when request was processed with success by the server\n  @Override\n  void onSuccess(String response) {\n\n    // Update the View with the String received on the \n    // HTTP body\n    EditText et = (EditText) findViewById(R.id.inputText);\n    et.setText(response);\n    dismissProgress();\n  }\n\n  // Invoked when the served returned an error\n  @Override\n  public void onFailure(HTTPResponse response) {\n    Log.e(\"GreetingsActivity\", \"Server returned an error: \" + \n          response.mResponseCode + \" \" + \n          response.mResponseMessage);\n    dismissProgress();\n  }\n\n  // Invoked when an error happened\n  @Override\n  public void onError(Throwable error) {\n    Log.e(\"GreetingsActivity\", \"Exception happened: \" + \n           error.getMessage(), error);\n    dismissProgress();\n  }  \n};\n```", "```java\npublic abstract class JsonResponseHandler<ResponseType, ErrorType> extends ResponseHandler {\n\n  abstract public void onSuccess(ResponseType response);\n  abstract public void onFailure(ErrorType response);\n  ...\n}\n```", "```java\npublic class BodyFactory {\n\n  public static Body read(String mimeType,\n                         InputStream is)\n    throws IOException {\n\n    ...\n    } else if ( mimeType.startsWith(\"application/json\")){\n      result = new RawBody(mimeType);\n      result.consume(is);\n    }  \n    return result;\n  }\n}\n```", "```java\ncompile 'com.google.code.gson:gson:2.5'\n```", "```java\npublic interface BodyDecoder <T> {\n    T decode(Body body) throws Exception ;\n}\n```", "```java\npublic interface BodyEncoder<T> {\n    Body encode(T obj,String mimeType) throws Exception;\n}\n```", "```java\npublic class JSONConverter<POJO> \n  implements BodyEncoder<POJO>, BodyDecoder<POJO> {\n  // Store the Generic Type information\n  private final Type pojoType;\n\n  JSONConverter(Type pojoType) {\n    this.pojoType = pojoType;\n  }\n\n  @Override\n  public POJO decode(Body body) throws Exception {\n    Gson gson = new Gson();\n    RawBody rawBody = (RawBody) body;\n    InputStream is = null;\n    POJO obj = null;\n    try {\n      is = new ByteArrayInputStream(rawBody.getContent());\n      BufferedReader bfReader = \n        new BufferedReader(new InputStreamReader(is));\n      obj = gson.fromJson(bfReader, pojoType);\n    } finally {\n      if (is != null) is.close();\n    }\n    return obj;\n  }\n}\n```", "```java\npublic abstract class JsonResponseHandler<ResponseType, ErrorType>\n  extends ResponseHandler {\n   // Store the Response Type class information\n    private final Type responseType;\n   // Store the Error Type class information\n    private final Type errorType;\n\n    JsonResponseHandler(Type responseType, Type errorType) {\n        this.responseType = responseType;\n        this.errorType = errorType;\n    }\n\n  // Callback invoked on the main Thread that converts\n  // a body to a POJO object\n  @Override\n  public void onSuccess(HTTPResponse response) {\n    RawBody body = (RawBody)response.mBody;\n\n    if ( body != null ) {\n      Response obj = null;\n      try {\n        obj = new JSONConverter<Response>(responseType).\n                decode(body);\n        onSuccess(obj); \n      } catch (Exception e) {\n        onError(e);\n      }\n\n    } else {\n      onSuccess((Response)null);\n    }\n  }\n  @Override\n  public void onFailure(HTTPResponse response) {...}\n}\n```", "```java\n  Content-Type: application/json\n\n   [\n     {\n      \"userId\": 1,\n      \"id\": 1,\n      \"title\": \"..\",\n      \"body\": \"...\"\n     },...\n   ]\n```", "```java\npublic class User {\n  public int id;\n  public String name;\n  public String username;\n  public String email;\n  public String phone;\n  public String website;\n}\n```", "```java\npublic class Error {\n  public int resultCode;\n  public String resultMessage;\n}\n```", "```java\nJsonResponseHandler<List<User>, Error> jsonResponseHandler =\n  new JsonResponseHandler<List<User>, Error>(\n    new TypeToken<ArrayList<User>>() {} .getType(),\n    new TypeToken<Error>() {} .getType()) {\n      // On Success Callback\n      @Override\n      public void onSuccess(List<User> users) {\n        // Update the List View with the a List Adapter that displays\n        // the user name and email per user\n        ListView listView = (ListView) findViewById(R.id.usersList);\n        ListAdapter adapter = new UserListAdapter(\n          UserListActivity.this, users);\n        listView.setAdapter(adapter);\n      }\n      // Prints the Error object\n      @Override\n      public void onFailure(Error response) {\n        Log.e(\"UserListActivity\",\n              \"Error happened retrieving greetings \" +\n              response.toString());\n      }\n      @Override\n      public void onError(Throwable error) {\n      // Do Something with the exception\n      }\n    };\n```", "```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView(R.layout.user_list_layout);\n\n  HTTPRequest.Builder builder = new HTTPRequest.Builder();\n  // Set the HTTP Verb to GET\n  builder.setVerb(HTTPRequest.Verb.GET);\n  // Sets location of the remote resource\n  builder.setUrl(\"http://jsonplaceholder.typicode.com/users\");\n\n  // Notify the server that the client is able to receive json\n  // documents\n  builder.addHeader(new Header(\"Accept\",\"application/json\"));\n  HTTPRequest request = builder.build();\n\n  PacktAsyncHTTPClient client = new PacktAsyncHTTPClient();\n  client.execute(request, jsonResponseHandler);\n}\n```", "```java\n@Override\nprotected Result<HTTPResponse> doInBackground(HTTPRequest... params) {\n  ...\n  if ( request.mBody != null ) {\n    // Allows Sending data on the request\n    conn.setDoOutput(true);\n    // Specifies The Content-Type based on the Body Mime Type\n    conn.setRequestProperty(\n      \"Content-type\", request.mBody.getMimeType());\n    // Retrieves the connection stream to write content\n    OutputStream os = conn.getOutputStream();\n    request.mBody.write(os);\n  }\n  // Retrieve the response code\n  int responseCode = conn.getResponseCode();\n  ...\n}\n```", "```java\ndependencies {\n  ...\n  compile('org.simpleframework:simple-xml:2.7.+'){\n        exclude module: 'stax'\n        exclude module: 'stax-api'\n        exclude module: 'xpp3'\n  }\n}\n```", "```java\n@Root(name = \"GetUserInfo\")\n@Namespace(prefix=\"p\", \n  reference=\"https://www.packtpub.com/asynchronous_android\")\npublic class GetUserInfo {\n\n    @Namespace(reference=\n      \"https://www.packtpub.com/asynchronous_android\")\n    @Element(name=\"UserId\")\n    public String userId;\n         // … Setters and Getters\n}\n```", "```java\n@Root\n@Namespace(prefix = \"p\",\n  reference = \"https://www.packtpub.com/asynchronous_android\")\npublic class GetUserInfoResponse {\n\n  @Element(name = \"User\")\n  @Namespace(prefix = \"p\", \n    reference = \"https://www.packtpub.com/asynchronous_android\" )\n  private User user = new User();\n  // … Setters and Getters\n}\n```", "```java\npublic class XMLConverter<POJO>\n  implements Encoder<POJO>{\n\n  private final Class<POJO> clazz;\n  XMLConverter(Class<POJO> clazz){ this.clazz = clazz; }\n\n  @Override\n  public Body encode(POJO obj, String mimeType)\n    throws Exception {\n\n    // Creates SimpleXML Serializer Instance\n    Serializer serializer = new Persister();\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n    // Converts from obj -> xml document\n    serializer.write(obj, output);\n\n    // Build a RawBody body\n    RawBody body = new RawBody(mimeType);\n    output.close();\n\n    // Stores the result on the body\n    body.setContent(output.toByteArray());\n    return body;\n  }\n}\n```", "```java\npublic class XMLConverter<POJO>\n  implements BodyEncoder<POJO>, BodyDecoder<POJO> {\n\n  ...\n  @Override\n  public POJO decode(Body body) throws Exception {\n    // Instantiate a SimpleXML Serializer\n    Serializer serializer = new Persister();\n    InputStream is = null;\n    RawBody rawBody = (RawBody)body;\n    POJO obj = null;\n    try {\n      is = new ByteArrayInputStream(rawBody.getContent());\n      BufferedReader bfReader =\n        new BufferedReader(new InputStreamReader(is));\n      obj = (POJO) serializer.read(clazz, bfReader);\n    } finally {\n      if ( is != null ) is.close();\n    }\n    return obj;\n  }\n  ...\n}\n```", "```java\n<?xml version=\"1.0\"  ?>\n<p:GetUserInfoResponse\n   >\n <p:User>\n   <p:Id>12</p:Id>\n   <p:Name>John</p:Name>\n   <p:Username>John</p:Username>\n   ...\n   <p:Company>\n        <p:Name>Packt</p:Name>\n        ...\n    </p:Company>\n  </p:User>\n  </p:GetUserInfoResponse>\n```", "```java\npublic abstract class XMLResponseHandler\n   <Response, Error> extends ResponseHandler {\n\n  // Class used to by Simple to convert to the ResponseTYpe\n  private final Class<Response> responseClass;\n\n  private final Class<Error> errorClass;\n\n  XMLResponseHandler(Class<Response> responseClass,\n                     Class<Error> errorClass) {\n    this.responseClass = responseClass;\n    this.errorClass = errorClass;\n  }\n\n  // Callback invoked with the converted Response  object instance\n  abstract public void onSuccess(Response response);\n\n  // Callback invoked with the converted Error object instance\n  abstract public void onFailure(Error response);\n\n  // Convert the body to a POJO object using the our converter\n  @Override\n  public void onSuccess(HTTPResponse response) {\n    RawBody body = (RawBody)response.mBody;\n\n    if ( body != null ) {\n      Response obj = null;\n      try {\n        obj = new XMLConverter<Response>(responseClass)\n        decode(body);\n        onSuccess(obj);\n      } catch (Exception e) {\n        onError(e);\n      }\n    } else { onSuccess((Response)null); }\n  }\n //.. Failure elided for brevity\n}\n```", "```java\nXMLResponseHandler<GetUserInfoResponse, Error> xmlResponseHandler\n  = new XMLResponseHandler<GetUserInfoResponse,Error>(\n      GetUserInfoResponse.class, Error.class) {\n\n  // Updates the UI with the user details\n  @Override\n  public void onSuccess(GetUserInfoResponse getUserInfoResponse) {\n    TextView nameTv = (TextView)findViewById(R.id.nameValue);\n    TextView emailTv = (TextView)findViewById(R.id.emailValue);\n\n    nameTv.setText(getUserInfoResponse.getUser().name);\n    emailTv.setText(getUserInfoResponse.getUser().email);\n\n  }\n  @Override\n  public void onFailure(Error response) {\n    // Do Something with the Error \n  }\n  @Override\n  public void onError(Throwable error) {\n    // Do Something with the Throwable\n  }\n};\n```", "```java\nHTTPRequest.Builder builder = new HTTPRequest.Builder();\n// Set the HTTP POST Verb\nbuilder.setVerb(HTTPRequest.Verb.POST);\n\n// Set location of the remote resource\nbuilder.setUrl(\"http://demo1472539.mockable.io/GetUserInfo\");\n\n// Tell the Server that you are able to consume \n// application/xml contents on the response\nbuilder.addHeader(new Header(\"Accept\", \"application/xml\"));\n\n// Build the Request Body object\nGetUserInfo query = new GetUserInfo();\nquery.setUserId(\"123\");\ntry {\n  // Encode the POJO into a XML Document\n  Body body = new XMLConverter<GetUserInfo>(GetUserInfo.class)\n                .encode(query, \"application/xml\");\n  builder.setBody(body);\n} catch (Exception e) {\n  // Catch and display and error to the user\n  ...\n}\nPacktAsyncHTTPClient client = new PacktAsyncHTTPClient();\nclient.execute(builder.build(), xmlResponseHandler);\n```", "```java\n<?xml version=\"1.0\"?>\n<p:Error   \n   >\n <p:ResultCode>1000</p:ResultCode>\n <p:ResultMessage>The LDAP Server is down</p:ResultMessage>\n</p:Error>\n```", "```java\nvoid setConnectTimeout(int timeoutMillis)\nvoid setReadTimeout(int timeoutMillis)\n```", "```java\npublic class HTTPRequest {\n  ...\n  public static class Builder {\n\n    private int mReadTimeout = 0; // Default Value\n    private int mConnectTimeout = 0; // Default Value\n\n    public void setConnectTimeout(int connectTimeoutMs) {\n      this.mConnectTimeout = connectTimeoutMs;\n    }\n    public void setReadTimeout(int readTimeoutMs) {\n      this.mReadTimeout = readTimeoutMs;\n    }\n  }\n}\n```", "```java\npublic class HTTPAsyncTask extends \n  AsyncTask<HTTPRequest, Void, Result<HTTPResponse>> {\n   @Override\n   protected Result<HTTPResponse> doInBackground(\n    HTTPRequest... params) {    \n      conn = (HttpURLConnection) url.openConnection();\n      conn.setReadTimeout(request.mReadTimeout);\n      conn.setConnectTimeout(request.mConnectTimeout);\n      ...\n  }\n}\n```", "```java\nURL url = new URL(\"https://packtpub.com\");\ncon = (HttpsURLConnection) url.openConnection();\n```", "```java\npublic class SSLOptions {\n\n  enum CipherSuite {\n    DEFAULT(\"Default\"), // Supported on Android API Level > 9\n    SSL(\"SSL\"), // Supported on Android API Level > 9\n    SSLv3(\"SSLv3\"), // Supported on Android API Level > 9\n    TLS(\"TLS\"), // Supported on Android API Level > 1\n    TLSv1(\"TLSv1\"), // Supported on Android API Level > 1+\n    TLSv1_1(\"TLSv1.1\"), // Supported on Android API Level > 16+\n    TLSv1_2(\"TLSv1.2\"); // Supported on Android API Level > 16+\n ...\n  }\n  // Cipher Suite used on the connection\n  final CipherSuite cipherSuite; \n  final SSLContext sslContext;\n\n  public SSLOptions(Context ctx, Builder builder)\n    throws Exception {\n    ...\n    // Build up our own SSLContext\n    sslContext = SSLContext.\n    getInstance(cipherSuite.toString());\n // Will use the Android default KeyManager and TrustManager\n    sslContext.init(null,null,new SecureRandom());\n  }  \n\n  public static class Builder {   \n    private CipherSuite cipherSuite = CipherSuite.DEFAULT;\n    ...         \n    SSLOptions build(Context ctx) throws Exception {\n      return new SSLOptions(ctx, this);\n    }\n  }\n}\n```", "```java\nvoid init(KeyManager[] km, TrustManager[] tm, SecureRandom sr)\n```", "```java\nkeytool -list -v -keystore asynchronous_client.ks -storetype BKS provider org.bouncycastle.jce.provider.BouncyCastleProvider providerpath bcprov-jdk15on-146.jar\n\nAlias name: asynchronous_client\nEntry type: PrivateKeyEntry\nCertificate[1]:\nOwner: C=UK,ST=Birmingham,L=Birmingham,O=Packt Publishing,OU=Packt Publishing,CN=asynchronous_client\nIssuer: C=UK,…,CN=packt\nCertificate[2]:\nOwner: C=UK,…,CN=packt\n\nAlias name: ca\nEntry type: trustedCertEntry\nOwner: C=UK,…,CN=packt\nIssuer: C=UK,…,CN=packt\n```", "```java\npublic class SSLOptions {\n  final CipherSuite cipherSuite; \n  final SSLContext sslContext;\n  private final  String keyStore;\n  private final String keyStorePassword;\n  private final String trustStore;\n  private final String trustStorePassword;\n  ...\n\n  public SSLOptions(Context ctx, Builder builder)\n    throws Exception {\n    ...\n    sslContext = initSSLContext(ctx);\n  }\n  // Initialize the SSLContect with loaded \n  private SSLContext initSSLContext(Context ctx)\n    throws Exception {\n\n    KeyManagerFactory kmf = getKeyManagerFactory(ctx);\n    TrustManagerFactory tmf = getTrustManagerFactory(ctx);\n    // Use the cipher suite defined SSL, SSLv3 , TLS, TLSv1,\n    SSLContext result = SSLContext.getInstance(\n                          cipherSuite.toString());\n\n    result.init( kmf != null ? kmf.getKeyManagers() : null ,\n                 tmf != null ? tmf.getTrustManagers() : null,\n                 new SecureRandom());\n    return result;\n  }\n}\n```", "```java\nKeyManagerFactory getKeyManagerFactory(Context ctx)\n  throws Exception {\n  KeyManagerFactory kmf = null;\n  // Initialize Key store\n  if ( keyStore != null ) {\n    // Load the file keystore from the assets directory\n    InputStream keyStoreIs = ctx.getResources().\n                              getAssets().open(keyStore);\n    String algorithm = KeyManagerFactory.getDefaultAlgorithm();\n    kmf = KeyManagerFactory.getInstance(algorithm);\n\n    // Create BouncyCastle Key Store \n    KeyStore ks = KeyStore.getInstance(\"BKS\");\n\n    // Load the Keymanagers available on the file using\n    // a password\n    ks.load(keyStoreIs, keyStorePassword.toCharArray());\n    kmf.init(ks, keyStorePassword.toCharArray());\n  }\n  return kmf;\n}\n```", "```java\nTrustManagerFactory getTrustManagerFactory(Context ctx)\n  throws Exception {\n\n  TrustManagerFactory tmf = null;\n\n  if ( trustStore != null) {\n    InputStream keyStoreIs = ctx.getResources().\n                               getAssets().open(trustStore);\n    String algorithm = TrustManagerFactory.getDefaultAlgorithm();\n    tmf = TrustManagerFactory.getInstance(algorithm);\n    KeyStore ts = KeyStore.getInstance(\"BKS\");\n    ts.load(keyStoreIs, trustStorePassword.toCharArray());\n    tmf.init(ts);\n  }\n  return tmf;\n}\n```", "```java\npublic class HTTPRequest {\n\n  final SSLOptions mSSLOptions;\n\n  private HTTPRequest(Builder builder) {\n    this.mSSLOptions = builder.mSSLOptions;\n  }\n\n  public static class Builder {\n    ...\n    private SSLOptions mSSLOptions = null;\n\n    public Builder setSSLOptions(SSLOptions options) {\n      this.mSSLOptions = options;\n      return this;\n    }\n  }\n  ...\n}\n```", "```java\n@Override\nprotected Result<HTTPResponse>\ndoInBackground(HTTPRequest... params) {\n  // Retrieve the request URL from the request object\n  URL url = new URL(request.mUrl);\n  // Opens up the connection to the remote pper\n  conn = initConnection(request, url);\n  ...\n}\n\nHttpURLConnection \ninitConnection( HTTPRequest request, URL url) throws IOException {\n\n  HttpURLConnection genCon = (HttpURLConnection) url.\n                             openConnection();\n\n  if ( url.getProtocol().equals(\"https\") ) {\n    HttpsURLConnection con = (HttpsURLConnection) genCon;\n    // Apply our SSL Options to the connection\n    if ( request.mSSLOptions != null ) {\n      applySSLContext(request, con);\n    }\n  }\n  return result;\n}\nvoid \napplySSLContext(HTTPRequest request, HttpsURLConnection con) {\n // Initialize the SSL Session with your own\n // keystore and truststore\n  if ( request.mSSLOptions != null ) {\n    SSLContext ctx = request.mSSLOptions.sslContext;\n    con.setSSLSocketFactory(ctx.getSocketFactory());\n    con.setHostnameVerifier(new AcceptAllHostNameVerifier());\n  }\n}\n```", "```java\n// Server Certificate\nCertificate[1]:\nOwner: CN=asynchronous_server, OU=Packt Publishing, O=Packt Publishing, L=Birmingham, ST=Birmingham, C=UK\nIssuer: CN=packt, ..., C=UK\n\n// CA Certificate\nCertificate[2]:\nOwner: CN=packt, OU=Packt Publishing, O=Packt Publishing, L=Birmingham, ST=Birmingham, C=UK\nIssuer: CN=packt, …, C=UK\n```", "```java\n// Set the HTTP Verb to GET\nbuilder.setVerb(HTTPRequest.Verb.GET);\n// Sets location of the remote resource\nbuilder.setUrl(\"https://<server_hostname>:<port>/hello_ssl\");\nbuilder.addHeader(new Header(\"Accept\", \"text/plain\"));\nSSLOptions.Builder sslBuilder = new SSLOptions.Builder();\n\n// TLS Cipher Suite using the  asynchronous_client.ks \n// as the truststore file and keystore file \nsslBuilder.setKeyStore(\"asynchronous_client.ks\", \"123qwe\")\n          .setTrustStore(\"asynchronous_client.ks\", \"123qwe\")\n          .setCipherSuite(SSLOptions.CipherSuite.TLS);\n\n// The Application context is required to load\n// the keystore from the assets\nbuilder.setSSLOptions(sslBuilder.build(getApplication()));\n\nHTTPRequest request = builder.build();\n\nPacktAsyncHTTPClient client = new PacktAsyncHTTPClient();\nclient.execute(request, textResponseHandler);\n```"]