<html><head></head><body>
        

                            
                    <h1 class="header-title">Tasteful Design Patterns Adopting Kotlin Concepts</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li class="mce-root">Implementing the Strategy pattern</li>
<li>Exploring the power of the Delegation pattern</li>
<li>Implementing delegated class properties</li>
<li>Tracking state with the Observer pattern</li>
<li>Restricting property updates with the Vetoable delegate</li>
<li>Implementing the advanced Observer pattern by defining a custom property delegate</li>
<li>Working with the Lazy delegate</li>
<li>Implementing builders the smart way</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>The following chapter is going to present popular, general-purpose design patterns applicable to a range of programming problems. The following recipes focus on exploiting Kotlin's built-in language support for implementing specific concepts and patterns. Apart from basic design patterns, such as Strategy or Builder, the chapter will focus on different usages of Delegation in a diverse set of applications and scenarios. Once you get familiar with the concepts presented in this chapter, you will be able to utilize the language's built-in features while designing and developing elegant and reliable systems.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Strategy pattern</h1>
                
            
            
                
<p>The Strategy design pattern is used to provide an interchangeable set of strategies that can be applied to a given input and return an output of a specific type. We can understand the concept of a strategy as an action or an algorithm that can be applied to the input. A mechanism responsible for processing input should be able to switch between provided strategies at runtime. To illustrate the Strategy pattern, we are going to implement a text-formatting mechanism that allows us to apply a transformation to the input text and print it to the console. We are going to implement a class called <kbd>Printer</kbd>, which will provide a <kbd>printText(text: String)</kbd> function for printing the text to the console. Before printing out the text to the console, the <kbd>Printer</kbd> class will perform a transformation of the given <kbd>text</kbd> parameter according to the selected text formatting strategy.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Implement the <kbd>Printer</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class Printer(val textFormattingStrategy: (String) -&gt; String) {<br/>    fun printText(text: String) {<br/>        val processedText = textFormattingStrategy(text)<br/>        println(processedText)<br/>    }<br/>}</pre>
<ol start="2">
<li>Add sample strategies:</li>
</ol>
<pre style="padding-left: 60px">val lowerCaseFormattingStrategy: (String) -&gt; String = {<br/>    it.toLowerCase()<br/>}<br/><br/>val upperCaseFormattingStrategy: (String) -&gt; String = {<br/>    it.toUpperCase()<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's start by testing how our <kbd>Printer</kbd> class works in action. First, declare two instances of the <kbd>Printer</kbd> class—the first one with the <kbd>lowerCaseFormattingStrategy</kbd> for the <kbd>textFormattingStrategy</kbd> property, and the second one with <kbd>upperCaseFormattingStrategy</kbd>:</p>
<pre>val lowerCasePrinter = Printer(lowerCaseFormattingStrategy)<br/>val upperCasePrinter = Printer(upperCaseFormattingStrategy)</pre>
<p>Next, let's use them to format and display the following text:</p>
<pre>val text = "This functional-style Strategy pattern looks tasty!"<br/><br/>lowerCasePrinter.printText(text)<br/>upperCasePrinter.printText(text)</pre>
<p>The following output will print to the console:</p>
<pre><strong>this functional-style strategy pattern looks tasty!</strong><br/><strong>THIS FUNCTIONAL-STYLE STRATEGY PATTERN LOOKS TASTY!</strong></pre>
<p>The <kbd>Printer.textFormattingStrategy</kbd> property is a function that takes a single <kbd>String</kbd> argument and returns a <kbd>String</kbd> type as the output. It is invoked inside the <kbd>printText(text: String)</kbd> function with the <kbd>text</kbd> parameter, and its output is returned by the function. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You can practice by implementing your own text-formatting strategies. Try to implement a new text formatting strategy, called <kbd>capitalizeFormattingStrategy</kbd>, that will be responsible for capitalizing the first letter of the input text. Once you're done, create a new strategy be composed of the two implemented earlier—<kbd>lowerCaseFormattingStrategy</kbd> and <kbd>capitalizeFormattingStrategy</kbd>. You can refer to the <em>Function composition</em> recipe in <a href="28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml" target="_blank">Chapter 3</a>, <em>Shaping Code with Kotlin Functional Programming Features</em><em> </em>to learn more about the generic way of composing functions together. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you are not familiar with the concept of higher-order functions used to declare the <kbd>Printer.textFormattingStrategy</kbd> property, you can explore the <em>Working with higher-order functions</em> recipe from <a href="28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml" target="_blank">Chapter 3</a>, <em>Shaping Code with Kotlin Functional Programming Features</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the power of the Delegation pattern</h1>
                
            
            
                
<p>The Delegation pattern is a great alternative to typical inheritance of classes. Delegation allows a certain class to be derived from another one or to implement an interface. However, under the hood, the derived class is not a subclass of the base class but the composition is used instead to provide the properties of the base class to the derived one. Whenever a request to the properties of the base class part is made, it is being redirected to a delegated object. This is comparable to subclasses deferring a request to parent classes. However, delegation not only allows us to achieve the same code reusability as inheritance does, it's also much more powerful and customizable. Kotlin makes the Delegation pattern even more impressive because it provides a built-in support for declaring delegates using the <kbd>by</kbd> keyword.</p>
<p>In this recipe, we are going to implement a combination of dependent classes modeling a simple book library system. We are going to write a code of a given UML class diagram that describes a set of dependent classes using inheritance. However, we are going to use the delegation pattern instead of any inheritance occurrences.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We are going to work on implementing a set of the following classes using the Delegate pattern instead of inheritance:</p>
<div><img src="img/dc7b5ea9-ac66-4714-8eee-1964080ba13e.jpg" style="width:22.67em;height:36.50em;"/></div>
<p>In this class diagram, you can see two base classes that are being derived from the <kbd>BasePublication</kbd> class with its  <kbd>Book</kbd> and <kbd>Magazine</kbd> subclasses, and the <kbd>BaseUser</kbd> class, which is extended by the <kbd>Member</kbd> and <kbd>Librarian</kbd> subclasses. Note that those base classes are implementing corresponding interfaces declaring their properties. The <kbd>BaseUser</kbd> class implements the <kbd>User</kbd> interface, and the <kbd>BasePublication</kbd> class implements the <kbd>Publication</kbd> interface. There is also the <kbd>Rental</kbd> interface, which declares methods implemented by the <kbd>Book</kbd> subclass.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In order to implement the delegation using the language's built-in language features, we are going to operate on interfaces directly and remove any existing inheritance. Instead of extending the <kbd>BaseUser</kbd> and <kbd>BasePublication</kbd> base classes, we are going to use them as the properties of the final <kbd>User</kbd>, <kbd>Librarian</kbd>, <kbd>Book</kbd>, and <kbd>Magazine</kbd> classes, as presented in the following diagram:</p>
<div><img src="img/86204b5c-5743-49f3-8602-05eaebd4aa3d.jpg" style="width:29.33em;height:29.75em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare the <kbd>Magazine</kbd> class implementing the <kbd>Publication</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">class Magazine(val number: Int,<br/>               title: String,<br/>               pageCount: Int) : Publication</pre>
<ol start="2">
<li>Delegate the <kbd>Publication</kbd> interface to the class property of the <kbd>Publication</kbd> type:</li>
</ol>
<pre style="padding-left: 60px">class Magazine(val number: Int,<br/>               val publication: Publication) :<br/>        Publication by publication</pre>
<ol start="3">
<li>Implement the <kbd>Rentable</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">interface Rentable {<br/>    var currentUser: Optional&lt;User&gt;<br/><br/>    fun availableToRent() = !currentUser.isPresent<br/><br/>    fun doRent(user: User): Boolean {<br/>        return if (availableToRent()) {<br/>            currentUser = Optional.of(user)<br/>            true<br/>        } else {<br/>            false<br/>        }<br/>    }<br/>}</pre>
<ol start="4">
<li>Implement the <kbd>Book</kbd> class, delegating its <kbd>Publication</kbd> interface functionality to the class member:</li>
</ol>
<pre style="padding-left: 60px">class Book(val publicationDate: Instant,<br/>           val author: String,<br/>           val publication: Publication) :<br/>        Publication by publication, Rentable {<br/><br/>    override var currentUser: Optional&lt;User&gt; = Optional.empty()<br/>}</pre>
<ol start="5">
<li>Implement the <kbd>Member</kbd> and <kbd>Librarian</kbd> classes, implementing the <kbd>User</kbd> interface and delegating it to their class properties:</li>
</ol>
<pre style="padding-left: 60px">class Member(val currentRentals: List&lt;Rentable&gt;,<br/>             name: String,<br/>             isActive: Boolean,<br/>             user: User) : User by user<br/><br/>class Librarian(user: User) : User by user</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Using the <kbd>by</kbd> keyword, we have delegated the implementation of the <kbd>User</kbd> and <kbd>Publication</kbd> interfaces to specialized objects defined as class members. In the case of the <kbd>Book</kbd> and <kbd>Magazine</kbd> classes, the responsibilities for the <kbd>Publication</kbd> interface were delegated to the <kbd>publication: Publication</kbd> class properties, and, in the case of the <kbd>Member</kbd> and <kbd>Librarian</kbd> classes, the responsibilities for the <kbd>User</kbd> interface were delegated to the <kbd>user: User</kbd> properties.</p>
<p>Now, let's explore how we can work with delegated types. Let's start by creating an instance of the <kbd>Book</kbd> class. We provide a <kbd>Book.publication</kbd>  property of the <kbd>Publication</kbd> type by reusing the original <kbd>BasePublication</kbd> class declaration:</p>
<pre>class BasePublication(override val title: String, <br/>                      override val pageCount: Int): Publication</pre>
<p>Note that we are able to access all the public members of the <kbd>Publication</kbd> interface directly from the <kbd>Book</kbd> class instance. Any requests to those <kbd>Publication</kbd> interface properties are being redirected to the <kbd>val publication</kbd> property of the <kbd>Book</kbd> class:</p>
<pre>val book = Book(Instant.now(), "Sam", <br/>        BasePublication("Kotlin Standard Library Cookbook",<br/>         Integer.MAX_VALUE))<br/><br/>println("${book.title} written by ${book.author} has ${book.pageCount} pages.")</pre>
<p>In the result, the preceding code should print the following output to the console:</p>
<pre><strong>Kotlin Standard Library Cookbook written by Sam has 2147483647 pages.</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Another great type of Delegation design pattern is related to delegating class properties. You can find out more in the <em>Implementing delegated class properties </em>recipe. </li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing delegated class properties</h1>
                
            
            
                
<p>Class properties in Kotlin are more than just plain class fields. The key characteristic of Kotlin properties is the fact that their values are specified by accessor functions automatically. Each class property in Kotlin has a dedicated set of accessor functions available out of the box. By default, the Kotlin compiler generates a field storing the value of the property and its getters or setters as well. Each immutable <kbd>val</kbd> property has a corresponding <kbd>get()</kbd> function provided and the mutable one declared with <kbd>var</kbd> keyword has the <kbd>set()</kbd> function in addition to a <kbd>get()</kbd> as well. We are also able to override a default implementation of the accessor function, which makes a property highly customizable and powerful. For example, we can override the <kbd>get()</kbd> function of the property and provide a custom implementation for it, which can stop the compiler from storing the value of the property in a field. Moreover, the fact that properties are represented by their accessor functions and not by the fields values makes <em>property delegation</em> possible.  The basic use cases for the property delegation include:</p>
<ul>
<li>Implementing lazy properties—providing the value that gets computed only upon first access</li>
<li>Observable properties—listeners get notified about changes to the property</li>
<li>Storing properties in a map, instead of a separate field for each property</li>
</ul>
<p>In this recipe, we are going to learn how to create a function allowing us to easily serialize class instance into JSON format by to delegating its properties to be stored in a map. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Similar to the interface delegation, the class property delegation is achieved using the <kbd>by</kbd> keyword in the following manner:</p>
<pre>class MyClass {<br/>    var property: String by MyDelegate<br/>}</pre>
<p>The object which is delegated to should implement one of the following interfaces—<kbd>ReadWriteProperty</kbd> or <kbd>ReadOnlyProperty</kbd> from the <kbd>kotlin.properties</kbd> package. Those interfaces expose the <kbd>getValue()</kbd> and <kbd>setValue()</kbd> functions, which provide values for the property.</p>
<p class="mce-root"/>
<p>We are going to use the <kbd>Gson</kbd> library to convert objects into their JSON format representation. It's a widely used Java library for working with JSON-formatted objects.  You can learn more about the library on its GitHub site (<a href="https://github.com/google/gson">https://github.com/google/gson</a>). If you're using the Gradle build tool, you need to add the Gson artifact to the project dependencies: </p>
<pre>dependencies {
    implementation 'com.google.code.gson:gson:2.8.4'
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Implement the <kbd>Client</kbd> class containing a data property of a <kbd>Map&lt;String, Any&gt;</kbd> type:</li>
</ol>
<pre style="padding-left: 60px">data class Client(private val data: Map&lt;String, Any&gt;)</pre>
<ol start="2">
<li>Implement the <kbd>CreditCard</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">data class CreditCard(val holderName: String,<br/>                      val number: String,<br/>                      val cvcCode: String,<br/>                      val expiration: Long)</pre>
<ol start="3">
<li>Add the <kbd>name</kbd>, <kbd>email</kbd>, and <kbd>creditCards</kbd> properties to the <kbd>Client</kbd> class and delegate them to the <kbd>data</kbd> property:</li>
</ol>
<pre style="padding-left: 60px">data class Client(private val data: Map&lt;String, Any&gt;) {<br/>    val name: String by data<br/>    val email: String by data<br/>    val creditCards: List&lt;CreditCard&gt; by data<br/>}</pre>
<ol start="4">
<li>Implement the <kbd>toJson(): String</kbd> member function, allowing us to serialize a <kbd>Client</kbd> type object into JSON format, and the <kbd>fromJson(json: String): Client</kbd> utility function responsible for the opposite operation:</li>
</ol>
<pre style="padding-left: 60px">data class Client(private val data: Map&lt;String, Any&gt;) {<br/>    val name: String by data<br/>    val email: String by data<br/>    val creditCards: List&lt;CreditCard&gt; by data<br/><br/>    /**<br/>     * Function for serializing instance of Client class into<br/>       JSON format<br/>     */<br/>    fun toJson(): String = gson.toJson(data)<br/><br/>    companion object {<br/>        private val gson = Gson()<br/><br/>        /**<br/>         * Utility function for instantiating Client class from<br/>           JSON string<br/>         */<br/>        fun fromJson(json: String): Client {<br/>            val mapType = object : TypeToken&lt;Map&lt;String,<br/>             Any&gt;&gt;() {}.type<br/>            val data: Map&lt;String, Any&gt; = gson.fromJson(json,<br/>             mapType)<br/>            return Client(data)<br/>        }<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Class properties can be delegated to a <kbd>Map</kbd> or <kbd>MutableMap</kbd> instance, which contains keys of the <kbd>String</kbd> type and values of the <kbd>Any</kbd> type. The map's keys correspond to the names of the class properties and the map's values associated with them store the properties values. The map that is delegated to is being updated dynamically whenever the delegated property is updated.</p>
<p>Let's take a look at how we can make use of the <kbd>Client</kbd> class implemented in this recipe. We can instantiate the <kbd>Client</kbd> class by passing the <kbd>Map</kbd> instance to the class constructor:</p>
<pre>val <strong>SAMPLE_CLIENT_MAP </strong>= mapOf("name" to "Mark Zuck",<br/>        "email" to "mark@fb.com",<br/>        "creditCards" to listOf(<br/>                CreditCard("Mark Zuckerberg", "123345456789", "123",<br/>                 1527330705017),<br/>                CreditCard("Mark Zuckerberg", "987654321", "321",<br/>                 1527330719816))<br/>)<br/>val client1 = Client(<strong>SAMPLE_CLIENT_MAP</strong>)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We can also instantiate the <kbd>Client</kbd> class using the <kbd>fromJson()</kbd> function, passing a string containing a JSON representation of the sample <kbd>Client</kbd> type object:</p>
<pre>@Language("JSON")<br/>const val SAMPLE_CLIENT_JSON =<br/>        "{\n  \"name\": \"Mark Zuck\",<br/>          \n  \"email\": \"mark@fb.com\",<br/>          \n  \"creditCards\": [<br/>          \n    {<br/>          \n      \"holderName\": \"Mark Zuckerber\",<br/>          \n      \"number\": \"123345456789\",<br/>          \n      \"cvc\": \"123\",<br/>          \n      \"expiration\": 1527330705017<br/>          \n    },<br/>          \n    {<br/>          \n      \"holderName\": \"Mark Zuckerber\",<br/>          \n      \"number\": \"987654321\",<br/>          \n      \"cvc\": \"321\",<br/>          \n      \"expiration\": 1527330719816<br/>          \n    }<br/>          \n  ]<br/>          \n}"<br/>val client2 = Client.fromJson(SAMPLE_CLIENT_JSON)</pre>
<p>If you are working with IntelliJ IDE, you can use a cool <em>Language injection</em> feature that allows us to inject another language's code snippet as a String type and provides support for the language-specific syntax for editing and formatting.  You can use it to inject JSON snippets as a Kotlin String. You can learn more about it at the official JetBrains tutorial (<a href="https://www.jetbrains.com/help/idea/using-language-injections.html">https://www.jetbrains.com/help/idea/using-language-injections.html</a>).</p>
<p>Under the hood, the <kbd>Client.fromJson()</kbd> function uses Gson to convert JSON data to the <kbd>Map&lt;String, Any&gt;</kbd> instance.</p>
<p>We can now test those two ways and print the contents of both the <kbd>client1</kbd> and <kbd>client2</kbd> objects to the console:</p>
<pre>println("name: ${client1.name}, mail: ${client1.email}, cards: ${client1.creditCards}")<br/>println("name: ${client2.name}, email: ${client2.email}, cards: ${client2.creditCards}")</pre>
<p class="mce-root"/>
<p>As the result, we are going to get the following output printed to the console:</p>
<pre><strong>name: Mark Zuck, email: mark@fb.com, cards: [{holderName=Mark Zuckerber, number=123345456789, cvc=123, expiration=1.527330705017E12}, {holderName=Mark Zuckerber, number=987654321, cvc=321, expiration=1.527330719816E12}]</strong><br/><br/><strong>name: Mark Zuck, email: mark@fb.com, cards: [CreditCard(holderName=Mark Zuckerberg, number=123345456789, cvcCode=123, expiration=1527330705017), CreditCard(holderName=Mark Zuckerberg, number=987654321, cvcCode=321, expiration=1527330719816)]</strong></pre>
<p>In both cases, all the class properties are stored in the <kbd>data</kbd> map object, no matter which way of instantiating the <kbd>Client</kbd> class was chosen. The delegation of the properties to the map allowed us to implement a mechanism that exports the state of the <kbd>Client</kbd> object to the map automatically. The map object was stored internally in the <kbd>Client</kbd> class, however, it could be declared anywhere else as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In this recipe, we have created the <kbd>Client</kbd> class, which contains immutable <kbd>val</kbd> properties. In order to store mutable <kbd>var</kbd> properties, we can use a <kbd>MutableMap</kbd> instance instead of a read-only <kbd>Map</kbd>. </p>
<p>Built-in support for class properties is a powerful feature of the language. It brings awesome possibilities to shape your code in a neat way. You should definitely give it a try when working on a more complex project. For example, you can delegate the properties of your entities to be read and written directly to and from the database. There is also a group of ready-to-use delegates built into the standard library, such as the <em>Lazy</em> or <em>Observable</em> delegates. You can learn more about their application in the next recipes in this chapter. You can explore the full set of built-in delegates in the official standard library docs: <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/index.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/index.html.</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to explore the concept of interface delegation, you can take a look at the <em>Exploring the power of Delegation pattern</em> recipe</li>
<li>You should also learn about the standard property delegates provided by the standard library</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Tracking state with the Observer pattern</h1>
                
            
            
                
<p>The Observer pattern is a concept in which an object allows us to subscribe to the changes of its state and notifies a set of its observers automatically whenever there is a change of the object state. The implementation of the Observer pattern in Kotlin is pretty easy with the help of the built-in <kbd>Observable</kbd> property delegate offered by the standard library. In this recipe, we are going to implement an observable variable that will allow us to subscribe to the changes in its state. The subscribed listener should be notified immediately after any state updates. In the following example, we are going to declare the <kbd>temperature: Int</kbd> variable and subscribe to its changes. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Define an initial value for the temperature variable:</li>
</ol>
<pre style="padding-left: 60px"><strong>val initialValue = 1</strong></pre>
<ol start="2">
<li>Declare the listener for the variable that will be observed:</li>
</ol>
<pre style="padding-left: 60px">val initialValue = 1<br/><strong>val changesListener: (KProperty&lt;*&gt;, Int, Int) -&gt; Unit =</strong><br/><strong>        { _, _: Int, newValue: Int -&gt; println("Current temperature: $newValue") }</strong></pre>
<ol start="3">
<li>Declare the <kbd>temperature</kbd> variable, delegating its value to the <kbd>ReadWriteProperty</kbd> instance returned by the <kbd>Delegates.observable()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">val initialValue = 1<br/>val changesListener: (KProperty&lt;*&gt;, Int, Int) -&gt; Unit =<br/>        { _, _: Int, newValue: Int -&gt; println("Current temperature: $newValue") }<br/><strong>var temperature: Int by Delegates.observable(initialValue, changesListener)</strong></pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We are delegating the <kbd>var temperature</kbd> variable to the result of the <kbd>Delegates.observable()</kbd> function, which returns an instance of the <kbd>ReadWriteProperty</kbd> class. That fact makes it possible to declare <kbd>temperature</kbd> as a mutable variable. The <kbd>observe()</kbd> function takes two arguments—the initial value, and an instance of the hook function that is going to be invoked on every change made to the delegated variable. In our case, we are instantiating the function as the lambda block, which is supposed to print the new <kbd>temperature</kbd> value to the console.</p>
<p>Let's test how our implementation is going to work. We are going to modify the value of the temperature directly a couple of times:</p>
<pre>temperature = 10<br/>temperature = 11<br/>temperature = 12<br/>temperature = 30</pre>
<p>As the result, we get the following output:</p>
<pre><strong>Current temperature: 10</strong><br/><strong>Current temperature: 11</strong><br/><strong>Current temperature: 12</strong><br/><strong>Current temperature: 30</strong></pre>
<p>On each change of the temperature value, the listener function is being invoked with the previous and new values of the property passed to its parameters.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to explore how the property delegates are working under the hood, take a look at the <em>Implementing delegated class properties</em> recipe</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Restricting property updates with the Vetoable delegate</h1>
                
            
            
                
<p>In this recipe, we are going to explore the usage of the Vetoable delegate offered by the standard library. Similar to the Observable, the Vetoable tracks the changes applied to the delegated property. However, the Vetoable delegate is able to refuse to update the delegated property if a predefined update condition is not met. We are going to declare a variable of the <kbd>Int</kbd> type and specify the update condition, allowing us to update the variable only if the absolute value of change is greater than or equal to <kbd>10</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start by defining an initial value for the temperature variable:</li>
</ol>
<pre style="padding-left: 60px"><strong>val initialValue = 1</strong></pre>
<ol start="2">
<li>Define the update condition for the observed variable:</li>
</ol>
<pre style="padding-left: 60px">val initialTemperature = 1<br/><strong>val updateCondition: (KProperty&lt;*&gt;, Int, Int) -&gt; Boolean =</strong><br/><strong>        { _, oldValue: Int, newValue: Int -&gt; Math.abs(oldValue - newValue) &gt;= 10 }</strong></pre>
<ol start="3">
<li>Declare the <kbd>temperature: Int</kbd> variable and delegate it to the result of the <kbd>Delegates.vetoable()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">val initialTemperature = 1<br/>val updateCondition: (KProperty&lt;*&gt;, Int, Int) -&gt; Boolean =<br/>        { _, oldValue: Int, newValue: Int -&gt; Math.abs(oldValue - newValue) &gt;= 10 }<br/><strong>var temperature: Int by Delegates.vetoable(initialTemperature, updateCondition)</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We are delegating the <kbd>var temperature</kbd> variable to the result of the <kbd>Delegates.vetoable()</kbd> function, which returns an instance of the <kbd>ReadWriteProperty</kbd> class. That fact makes it possible to declare <kbd>temperature</kbd> as a mutable variable. The <kbd>vetoable()</kbd> function takes two arguments—the initial value, and an instance of the hook function that is going to be invoked on every change made to the delegated variable.</p>
<p class="mce-root"/>
<p>That function provides the current value of the delegated variable and a candidate for the new value. As the result, the function returns the Boolean—<kbd>true</kbd> if the value can be updated, and <kbd>false</kbd> if the update condition is not met. In our case, we are instantiating the function as the lambda block in which we check whether the absolute value of change is greater than or equal to <kbd>10</kbd>:</p>
<pre>{ _, oldValue: Int, newValue: Int -&gt; Math.abs(oldValue - newValue) &gt;= 10 }</pre>
<p>Let's test how our implementation is going to work. We are going to modify the value of <kbd>temperature</kbd> directly a couple of times with different values and verify whether the update was approved by printing the <kbd>temperature</kbd> state to the console:</p>
<pre>temperature = 10<br/>println("Current temperature: $temperature")<br/><br/>temperature = 11<br/>println("Current temperature: $temperature")<br/><br/>temperature = 12<br/>println("Current temperature: $temperature")<br/><br/>temperature = 30<br/>println("Current temperature: $temperature")</pre>
<p>As the result, we get the following output printed out:</p>
<pre><strong>Current temperature: 1</strong><br/><strong>Current temperature: 11</strong><br/><strong>Current temperature: 11</strong><br/><strong>Current temperature: 30</strong></pre>
<p>As you can see, the value of temperature remains unchanged whenever we are assigning it with values that don't satisfy the specified condition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>In the next recipe, <em>Implementing the advanced observer using a custom property delegate, </em>we are going to combine together the functionalities of the Observable and Vetoable delegates by implementing our custom delegate. Read on to explore how to both filter updates of the property and implement the Observer pattern in one property delegate.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the advanced Observer pattern by defining a custom property delegate</h1>
                
            
            
                
<p>In this recipe, we are going to implement a custom, generic property delegate combining features of the Observable and Vetoable delegates available in the standard library. In other words, we want to implement a property delegate that allows us to notify a subscribed listener about any changes made to the observed property. At the same time, we also want the delegate to allow filtering of the updates made to the delegated property. In this example, we are going to declare the <kbd>temperature: Int</kbd> variable delegated to our custom implementation of the <kbd>ObservableVetoable</kbd> delegate class. We are going to create a generic class that allows us to pass the initial value, a function responsible for filtering property updates and a function that will be invoked immediately after the change to the property is made.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Define the custom property delegate called <kbd>ObservableVetoableDelegate</kbd> as a subclass of the <kbd>ObservableProperty</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class ObservableVetoable&lt;T&gt;(initialValue: T,<br/>                          val updatePrecondition: (old: T, new: T)<br/>                           -&gt; Boolean,<br/>                          val updateListener: (old: T, new: T)<br/>                           -&gt; Unit) :<br/>        ObservableProperty&lt;T&gt;(initialValue = initialValue) {<br/><br/>    override fun beforeChange(property: KProperty&lt;*&gt;,<br/>                              oldValue: T,<br/>                              newValue: T): Boolean =<br/>            updatePrecondition(oldValue, newValue)<br/><br/>    override fun afterChange(property: KProperty&lt;*&gt;,<br/>                             oldValue: T,<br/>                             newValue: T) = <br/>            updateListener(oldValue, newValue)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Define the <kbd>initialTemperature</kbd>, <kbd>updatePrecondition</kbd>, and <kbd>updateListener</kbd> arguments required by the <kbd>ObservableVetoable</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">val initialTemperature = 1<br/>val updatePrecondition: (Int, Int) -&gt; Boolean =<br/>        { oldValue, newValue -&gt; Math.abs(oldValue - newValue) &gt;= 10 }<br/><br/>val updateListener: (Int, Int) -&gt; Unit = { _, newValue -&gt; println(newValue) }</pre>
<ol start="3">
<li>Declare the <kbd>temperature: Int</kbd> variable by delegating it to the <kbd>ObservableVetoable</kbd> class instance:</li>
</ol>
<pre style="padding-left: 60px">var temperature: Int by ObservableVetoable(initialTemperature, <br/>                                           updatePrecondition, <br/>                                           updateListener)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have defined the <kbd>ObservableVetoable</kbd> class and delegated the <kbd>var temperature: Int</kbd> variable to the <kbd>ObservableVetoable</kbd> instance. Our <kbd>ObservableVetoable</kbd> class extends the <kbd>ObservableProperty</kbd> class, which implements the <kbd>ReadWriteProperty</kbd> interface under the hood. Thanks to this, <kbd>ObservableProperty</kbd> allows us to delegate mutable properties to it. The <kbd>ObservableProperty</kbd> class also has the <kbd>beforeChange(): Boolean</kbd> and <kbd>afterChange(): Unit</kbd> open functions, which are being invoked inside the <kbd>setValue()</kbd> function:</p>
<pre>public override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {<br/>    val oldValue = this.value<br/>    if (!beforeChange(property, oldValue, value)) {<br/>        return<br/>    }<br/>    this.value = value<br/>    afterChange(property, oldValue, value)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, whenever the delegated property is assigned to a new value, the <kbd>beforeChange()</kbd> function is invoked to check whether the new value meets specified conditions. If the conditions are met, the property gets updated and the <kbd>afterChange()</kbd> function is called. In fact, our <kbd>ObservableVetoable</kbd> class takes instances of the function implementations, <kbd>updatePrecondition</kbd> and <kbd>updateListener</kbd>, which override the <kbd>beforeChange()</kbd> and <kbd>afterChange()</kbd> base functions. This way, we are able to both observe the changes made to the delegated property and notify the changes listener immediately to filter the changes being made to it.</p>
<p>For example, we can test our implementation by updating the <kbd>temperature</kbd> variable five times with different values:</p>
<pre>temperature = 11<br/>temperature = 12<br/>temperature = 13<br/>temperature = 14<br/>temperature = 30</pre>
<p>As a result, we are going to have only two lines printed to the console:</p>
<pre><strong>11</strong><br/><strong>30</strong></pre>
<p>This means that our mechanism is working properly because our update precondition function is checking whether the absolute value of change is greater than or equal to <kbd>10</kbd>. <kbd>updateListener()</kbd> is called only when the new value is accepted by the <kbd>updatePrecondition()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to get familiar with the basics of property-delegation support in Kotlin, take a look at the <em>Implementing delegated class properties </em>recipe, which contains an in-depth introduction and explanation of the language support for the delegation concept</li>
<li>You can also explore the <em>Restricting property's updates with Vetoable</em> delegate and the <em>Tracking state with Observer pattern </em>recipes to get familiar with the Observer and Vetoable delegates provided by the standard library</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with the Lazy delegate</h1>
                
            
            
                
<p>Lazy initialization is another design pattern that has its dedicated delegate implementation included in the standard library. The concept of lazy initialization refers to the strategy of delaying the creation of an object, calculation of a value, or execution of some expensive operation until the first time it's needed. In this recipe, we are going to define a sample class, <kbd>CoffeeMaker</kbd>, and declare an object of its type via the Lazy delegate. Then we are going to perform example operations on the object to explore how the lazy delegate is working in action.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start with defining the <kbd>CoffeeMaker</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class CoffeeMaker {<br/>    init {<br/>        println("I'm being created right now... Ready to make some<br/>         coffee!")<br/>    }<br/><br/>    fun makeEspresso() {<br/>        println("Un espresso, per favore!")<br/>    }<br/><br/>    fun makeAmericano() {<br/>        print("Un caffè americano, per favore!")<br/>    }<br/>}</pre>
<ol start="2">
<li>Declare a variable of the <kbd>CoffeMaker</kbd> type using the <kbd>lazy</kbd> delegate:</li>
</ol>
<pre style="padding-left: 60px">val coffeeMaker: CoffeeMaker by lazy { CoffeeMaker() }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's test out how the <kbd>coffeeMaker</kbd> instance is going to behave by running the following code:</p>
<pre>val coffeMaker: CoffeeMaker by lazy { CoffeeMaker() }<br/>println("Is the CoffeMaker created already?")<br/><br/></pre>
<p class="mce-root"/>
<pre>coffeMaker.makeEspresso()<br/>coffeMaker.makeAmericano()</pre>
<p>And here is the output printed out to the console:</p>
<pre><strong>Is the CoffeMaker created already?</strong><br/><strong>I'm being created right now... Ready to make some coffe!</strong><br/><strong>Un espresso, per favore!</strong><br/><strong>Un caffè americano, per favore!</strong></pre>
<p>As you might have imagined, the constructor of the <kbd>CoffeeMaker</kbd> class is being called only upon the first request to the <kbd>coffeeMaker</kbd> variable. In fact, the lambda block passed to the lazy function is invoked on the call to the <kbd>coffeeMaker.makeEspresso()</kbd> function. Once the <kbd>CoffeeMaker</kbd> object is instantiated, it's reused for any consecutive operations performed on it.</p>
<p>By default, the evaluation of lazy properties is synchronized; the value is computed only in one thread, and all threads will see the same value. If the synchronization of the initialization delegate is not required so that multiple threads can execute it simultaneously, pass <kbd>LazyThreadSafetyMode.PUBLICATION</kbd> as a parameter to the <kbd>lazy()</kbd> function. And if you're sure that the initialization will always happen on a single thread, you can use the <kbd>LazyThreadSafetyMode.NONE</kbd> mode, which doesn't incur any thread-safety guarantees and the related overhead (<a href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy">https://kotlinlang.org/docs/reference/delegated-properties.html#lazy</a>).</p>
<p>The <kbd>lazy()</kbd> function creates and returns an instance of the <kbd>Lazy&lt;T&gt;</kbd> interface:</p>
<pre>public interface Lazy&lt;out T&gt; {<br/>    public val value: T<br/>    public fun isInitialized(): Boolean<br/>}</pre>
<p>As you can see, the <kbd>value</kbd> property is immutable and it's not possible to declare a mutable variable or property using the lazy delegate. Under the hood, the <kbd>Lazy</kbd> implementation returns a specific value of the object it holds and is checking internally if it has been already evaluated. During the first access to the object, the <kbd>initializer</kbd> function passed to the lazy function as an argument is being executed and its result is being assigned to the dedicated property. Later, the cached value is going to be used instead of re-evaluating the value each time.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to explore how the property delegates are working under the hood, take a look at the <em>Implementing delegated class properties</em> recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing builders the smart way</h1>
                
            
            
                
<p>The Builder design pattern is one of the most commonly used mechanisms for instantiating complex types in the Java language. It was strongly recommended by Joshua Bloch in the <em>Effective Java</em> book. Bloch says the builders should be used when we need to implement multiple constructors. He also mentions that builder pattern simulates named optional parameters. However, in Kotlin, those arguments for implementing a specialized builder class are no longer valid. Kotlin allows us to provide default values to the class constructor arguments and properties and it has built-in support for named arguments. Given those Kotlin features, there is no need to implement the builders in most scenarios since we can simply achieve their functionality using the language's built-in concepts. However, in Kotlin, we can adapt the Builder pattern to achieve even more. We are going to utilize the concept of the builder, together with higher-order functions and the possibility of inlining lambda parameters, to define the DSL-like syntax for instantiating instances of a given class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's assume we have the <kbd>Dialog</kbd> class specified in some external dependency with an interface provided as follows:</p>
<pre>class Dialog {<br/>    lateinit var title: String<br/>    lateinit var message: String<br/>    lateinit var messageColor: String<br/>    lateinit var image: ByteArray<br/><br/>    fun show() = println("Dialog...\n$this")<br/><br/>    override fun toString() = "Title: $title \nImage: $image \nMessage:<br/>     $message"<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>Dialog</kbd> class exposes the following properties—<kbd>title: String</kbd>, <kbd>message: String</kbd>, <kbd>messageColor: String</kbd>, and <kbd>image: File</kbd>. We are going to implement a <kbd>DialogBuilder</kbd> class, which allows us to instantiate the <kbd>Dialog</kbd> class using the builder pattern. As the result, we would like to create a mechanism that allows us to instantiate the <kbd>Dialog</kbd> type using a DSL-like syntax similar to the JSON format:</p>
<pre style="padding-left: 30px">val dialog: Dialog = <br/>    dialog {<br/>        title {<br/>            "Title"<br/>        }<br/>        message {<br/>            text = "Message"<br/>            color = "#FF0000"<br/>        }<br/>        image {<br/>            File("path")<br/>        }<br/>    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the <kbd>DialogBuilder</kbd> class containing properties responsible for holding values needed by the <kbd>Dialog</kbd> class properties:</li>
</ol>
<pre style="padding-left: 60px"><strong>class DialogBuilder() {</strong><br/><strong>  private var titleHolder = "-"<br/>  private var messageHolder = StyleableText("-", "#000")</strong><br/><strong>  private var imageHolder: File = File.createTempFile("empty", "")<br/><br/>  class StyleableText(</strong><br/><strong>      var text: String = "",<br/>      var color: String = "#000"<br/>  )</strong><br/><strong>}</strong></pre>
<ol start="2">
<li>Add the <kbd>title()</kbd>, <kbd>message()</kbd>, and <kbd>image()</kbd> functions, allowing us to modify the <kbd>titleHolder</kbd>, <kbd>message</kbd>, and <kbd>image</kbd> properties:</li>
</ol>
<pre style="padding-left: 60px">class DialogBuilder() {<br/>  private var titleHolder = "-"<br/>  private var messageHolder = StyleableText("-", "#000")<br/>  private var imageHolder: File = File.createTempFile("empty", "")<br/><br/> <strong> fun title(block: () -&gt; String) {</strong><br/><strong>      titleHolder = block()</strong><br/><strong>  }</strong><br/><br/><strong>  fun message(block: StyleableText.() -&gt; Unit) {</strong><br/><strong>      messageHolder.apply { block() }<br/>  }</strong><br/><br/><strong>  fun image(block: File.() -&gt; Unit) {</strong><br/><strong>      imageHolder.apply { block() }<br/>  }</strong><br/>  <br/>  class StyleableText(<br/>      var text: String = "",<br/>      var color: String = "#000"<br/>  )<br/>}</pre>
<ol start="3">
<li>Add the <kbd>build()</kbd> function, returning the <kbd>Dialog</kbd> class instance:</li>
</ol>
<pre style="padding-left: 60px">class DialogBuilder() {<br/>  private var titleHolder = "-"<br/>  private var messageHolder = StyleableText("-", "#000")<br/>  private var imageHolder: File = File.createTempFile("empty", "")<br/><br/>  fun title(block: () -&gt; String) {<br/>      titleHolder = block()<br/>  }<br/><br/>  fun message(block: StyleableText.() -&gt; Unit) {<br/>      messageHolder.apply { block() }<br/>  }<br/><br/>  fun image(block: File.() -&gt; Unit) {<br/>      imageHolder.apply { block() }<br/>  }<br/><br/>  <strong>fun build(): Dialog = Dialog().apply {<br/>      title = titleHolder<br/>      message = messageHolder.text<br/>      messageColor = messageHolder.color<br/><br/>      imageHolder.apply {<br/>          image = readBytes()</strong><br/><strong>      }<br/></strong><strong>  }</strong><br/><br/>  class StyleableText(<br/>      var text: String = "",<br/>      var color: String = "#000"<br/>  )<br/>}</pre>
<ol start="4">
<li>Declare a constructor taking a function responsible for initialization of the <kbd>DialogBuilder</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class DialogBuilder() {<br/>  private var titleHolder = "-"<br/>  private var messageHolder = StyleableText("-", "#000")<br/>  private var imageHolder: File = File.createTempFile("empty", "")<br/><br/> <strong> constructor(initBlock: DialogBuilder.() -&gt; Unit): this() {</strong><br/><strong>      initBlock()</strong><br/><strong>  }</strong><br/><br/>  fun title(block: () -&gt; String) {<br/>      titleHolder = block()<br/>  }<br/><br/>  fun message(block: StyleableText.() -&gt; Unit) {<br/>      messageHolder.apply { block() }<br/>  }<br/><br/>  fun image(block: File.() -&gt; Unit) {<br/>      imageHolder.apply { block() }<br/>  }<br/><br/>  fun build(): Dialog = Dialog().apply {<br/>      title = titleHolder<br/>      message = messageHolder.text<br/>      messageColor = messageHolder.color<br/><br/>      imageHolder.apply {<br/>          image = readBytes()<br/>      }<br/>  }<br/><br/>  class StyleableText(<br/>      var text: String = "",<br/>      var color: String = "#000"<br/>  )<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Implement the <kbd>dialog()</kbd> helper function, taking a function responsible for initializing <kbd>DialogBuilder</kbd> and returning the <kbd>Dialog</kbd> class instance:</li>
</ol>
<pre style="padding-left: 60px"><strong>fun dialog(block: DialogBuilder.() -&gt; Unit): Dialog =            DialogBuilder(block).build()</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's start by testing how we can use our <kbd>dialog()</kbd> function in action. Let's use it to define a sample <kbd>Dialog</kbd> class instance:</p>
<pre>val dialog =<br/>        dialog {<br/>            title {<br/>                "Warning!"<br/>            }<br/>            message {<br/>                text = "You have 99999 viruses on your computer!"<br/>                color = "#FF0000"<br/>            }<br/>            image {<br/>                File.createTempFile("red_alert", "png")<br/>            }<br/>        }</pre>
<p>Now, we can invoke the <kbd>show()</kbd> function on the <kbd>dialog</kbd> variable, which is going print the following output to the console:</p>
<pre><strong>Dialog...</strong><br/><strong>Title: Warning! </strong><br/><strong>Image: [B@548c4f57 </strong><br/><strong>Message: You have 99999 viruses on your computer!</strong></pre>
<p>That's pretty cool! The <kbd>DialogBuilder</kbd> class allows us to compose instances of the <kbd>Dialog</kbd> type in a readable and natural way.</p>
<p class="mce-root"/>
<p>Implementing the new syntax for the <kbd>Dialog</kbd> class composition was possible by the use of higher-order functions and inline notation for lambda arguments. Note that each of the <kbd>DialogBuilder</kbd> functions, <kbd>title()</kbd>, <kbd>message()</kbd>, and <kbd>image()</kbd>, that are preparing information about the state of the target class properties, take a single functional parameter. The functional arguments are passed in the form of lambda blocks. There are two kinds of function types being used as parameters in the builder methods—the first one, which simply returns a specific value for the property, and the second one, which returns a function with a receiver type. The second type of the function returns <kbd>Unit</kbd> but takes an instance of the receiver<em> </em>type.</p>
<p>Function types are allowed to have an additional receiver type, which is declared before the dot. In the following notation—the <kbd>A.(B) -&gt; C</kbd> type represents a function that can be invoked on a receiver object of <kbd>A</kbd> type with a parameter of <kbd>B</kbd> type and return a value of <kbd>C</kbd>. Inside the body of the function literal, the receiver object passed to a call becomes an implicit <kbd>this</kbd>, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using  <kbd>this</kbd> keyword. You can read more about the available function types and their applications on the official Kotlin reference: <a href="https://kotlinlang.org/docs/reference/lambdas.html#function-types">https://kotlinlang.org/docs/reference/lambdas.html#function-types</a>.</p>
<p>For example, the <kbd>title(block: () -&gt; String)</kbd> function simply invokes the block function and assigns the result to the <kbd>DialogBuilder.titleHolder</kbd> property. On the other hand, whenever we are dealing with complex types, such as <kbd>StyleableText</kbd>, we are using the second approach using a function with a receiver type function's argument. For example, let's analyze the <kbd>message(block: StyleableText.() -&gt; Unit)</kbd> function:</p>
<pre>fun message(block: StyleableText.() -&gt; Unit) {<br/>    messageHolder.apply { block() }<br/>}</pre>
<p>Under the hood, it is executing the <kbd>block: StyleableText.() -&gt; Unit</kbd> argument to modify the <kbd>messageHolder: StyleableText</kbd> property instance directly. The <kbd>block</kbd> argument is being invoked using the <kbd>()</kbd> modifier inside the <kbd>apply</kbd> function, which in this case provides the access to the <kbd>messageHolder</kbd> instance via a local <kbd>this</kbd> keyword. The same approach is used in the constructor of the <kbd>DialogBuilder</kbd> class:</p>
<pre>constructor(initBlock: DialogBuilder.() -&gt; Unit): this() {<br/>    initBlock()<br/>}</pre>
<p class="mce-root"/>
<p>The receiver of the <kbd>DialogBuilder</kbd> type is being provided to the functional parameter and the function passed as <kbd>initBlock</kbd> is invoked inside the constructor, allowing us to modify its state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The concept of DSL-style builders is used extensively in many Kotlin libraries and frameworks. It is also employed by the standard library. For example, we can use the <kbd>html</kbd> function from the <kbd>kotlinx.html</kbd> library (<a href="https://github.com/Kotlin/kotlinx.html">https://github.com/Kotlin/kotlinx.html</a>) to generate the HTML code:</p>
<pre>val result =<br/>        html {<br/>            head {<br/>                title { +"HTML encoding with Kotlin" }<br/>            }<br/>            body {<br/>                h1 { "HTML encoding with Kotlin" }<br/>                p { +"this format can be used as an alternative to HTML" }<br/><br/>                // an element with attributes and text content<br/>                a(href = "http://jetbrains.com/kotlin") { +"Kotlin" }<br/>            }<br/>        }<br/>println(result)</pre>
<p>The preceding code is going to generate a valid HTML code and print it to the console:</p>
<pre><strong>&lt;html&gt;   <br/>    &lt;head&gt;     <br/>        &lt;title&gt;HTML encoding with Kotlin&lt;/title&gt;   <br/>    &lt;/head&gt;   <br/>    &lt;body&gt;     <br/>        &lt;h1&gt;HTML encoding with Kotlin&lt;/h1&gt;     <br/>        &lt;p&gt;this format can be used as an alternative to HTML&lt;/p&gt;     <br/>        &lt;a href="http://jetbrains.com/kotlin"&gt;Kotlin&lt;/a&gt;   <br/>    &lt;/body&gt;<br/>&lt;/html&gt;</strong></pre>
<p>You can explore even more awesome applications of the Builders in Kotlin at <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">https://kotlinlang.org/docs/reference/type-safe-builders.html.</a></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to learn more about the technical details of higher-order functions and inline notation for functional parameters, you can investigate the <em>Inlining parameters of closure type</em> recipe from <a href="b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml" target="_blank">Chapter 2</a>, <em>E</em><em>xpressive Functions and Adjustable Interfaces</em> and the <em>Working with higher order functions</em> recipe from <a href="28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml" target="_blank">Chapter 3</a>, <em>Shaping Code with Kotlin Functional Programming Features</em></li>
</ul>


            

            
        
    </body></html>