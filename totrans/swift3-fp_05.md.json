["```swift\nfunc swapTwoValues( a: inout Int, b: inout Int) {\n    let tempA = a\n    a = b\n    b = tempA\n}\n\n```", "```swift\nfunc swapTwoValues( a: inout String, b: inout String) {\n    let tempA = a\n    a = b\n    b = tempA\n}\n\n```", "```swift\nfunc swapTwoValues(a: Any, b: Any) -> (a: Any, b: Any) {\n    let temp = a\n    let newA = b\n    let newB = temp\n    return (newA, newB)\n}\n\n```", "```swift\nvar name = \"John Doe\"\nvar phoneNumber = 5141111111\n\nlet (a, b) = swapTwoValues(a: name, b: phoneNumber)\n\n```", "```swift\nfunc swapTwoValues<T>(a: T, b: T) -> (a: T, b: T) {\n    let temp = a\n    let newA = b\n    let newB = temp\n    return (newA, newB)\n}\n\n```", "```swift\nvar name = \"John Doe\"\nvar phoneNumber = 5141111111\n\nlet (a, b) = swapTwoValues(a: name, b: phoneNumber) // Compile error -\n  Cannot convert value of type 'Int' to expected argument type 'String'\n\n```", "```swift\nfunc addTwoValues(a: Int, b: Int) -> Int {\n    return a + b\n}\n\n```", "```swift\nfunc square(a: Int) -> Int {\n    return a * a\n}\n\n```", "```swift\nfunc addTwoSquaredValues(a: Int, b: Int) -> Int {\n    return (a * a) + (b * b)\n}\n\n```", "```swift\ntypealias AddSubtractOperator = (Int, Int) -> Int\ntypealias SquareTripleOperator = (Int) -> Int\n\nfunc calcualte(a: Int,\n               b: Int,\n           funcA: AddSubtractOperator,\n           funcB: SquareTripleOperator) -> Int {\n\n    return funcA(funcB(a), funcB(b))\n}\n\n```", "```swift\nprint(\"The result of adding two squared values is: \\(calcualte(a: 2, b: 2,\n  funcA: addTwoValues, funcB: square))\") // prints \"The result of adding\n  two squared value is: 8\"\n```", "```swift\nfunc calcualte<T>(a: T,\n                  b: T,\n              funcA: (T, T) -> T,\n              funcB: (T) -> T) -> T {\n\n    return funcA(funcB(a), funcB(b))\n}\n\n```", "```swift\ntypealias StringDictionary<T> = Dictionary<String, T>\ntypealias DictionaryOfStrings<T: Hashable> = Dictionary<T, String>\ntypealias IntFunction<T> = (T) -> Int\ntypealias Vec3<T> = (T, T, T)\ntypealias BackwardTriple<T1, T2, T3> = (T3, T2, T1)\n\n```", "```swift\nprotocol NumericType {\n    func +(lhs: Self, rhs: Self) -> Self\n    func -(lhs: Self, rhs: Self) -> Self\n    func *(lhs: Self, rhs: Self) -> Self\n    func /(lhs: Self, rhs: Self) -> Self\n    func %(lhs: Self, rhs: Self) -> Self\n}\n\n```", "```swift\nextension Double : NumericType { }\nextension Float  : NumericType { }\nextension Int    : NumericType { }\nextension Int8   : NumericType { }\nextension Int16  : NumericType { }\nextension Int32  : NumericType { }\nextension Int64  : NumericType { }\nextension UInt   : NumericType { }\nextension UInt8  : NumericType { }\nextension UInt16 : NumericType { }\nextension UInt32 : NumericType { }\nextension UInt64 : NumericType { }\n\n```", "```swift\nfunc calculate<T: NumericType>(a: T,\n                               b: T,\n                           funcA: (T, T) -> T,\n                           funcB: (T) -> T) -> T {\n\n    return funcA(funcB(a), funcB(b))\n}\n\nprint(\"The result of adding two squared values is: \\(calcualte(a: 2, b: 2,\n  funcA: addTwoValues, funcB: square))\") // prints \"The result of adding\n  two squared value is: 8\"\n\n```", "```swift\nfunc format(a: String) -> String {\n    return \"formatted \\(a)\"\n}\n\nfunc appendStrings(a: String, b: String) -> String {\n    return a + b\n}\n\nprint(\"The result is: \\(calculate(\"2\", b: \"2\", funcA:\n  appendStrings, funcB: format))\")\n\n```", "```swift\n<Seq: SequenceType where Seq.Generator.Element: Equatable>\n```", "```swift\n<Seq1: SequenceType, Seq2: SequenceType where \n  Seq1.Generator.Element == Seq2.Generator.Element>\n```", "```swift\nenum GenericTree <T> {\n    case empty\n    case leaf(T)\n    indirect case node(GenericTree, GenericTree)\n}\n\nlet ourGenericTree = GenericTree.node(GenericTree.leaf(\"First\"),\n  GenericTree.node(GenericTree.leaf(\"Second\"), GenericTree.leaf(\"Third\")))\nprint(ourGenericTree)\n```", "```swift\nstruct Queue<Element> {\n    private var elements = [Element]()\n    mutating func enQueue(newElement: Element) {\n        elements.append(newElement)\n    }\n\n    mutating func deQueue() -> Element? {\n        guard !elements.isEmpty else {\n            return nil\n       }\n       return elements.remove(at: 0)\n    }\n}\n\n```", "```swift\nprotocol Container {\n    associatedtype ItemType\n    mutating func append(item: ItemType)\n}\n\n```", "```swift\nstruct IntContainer: Container {\n    typealias ItemType = Int\n    mutating func append(item: ItemType) {\n        // append item to the container\n    }\n}\n\n```", "```swift\nextension Queue {\n    func peek() -> Element? {\n        return elements.first\n    }\n}\n\n```", "```swift\nclass Container<Item> {\n}\n\n// GenericContainer stays generic\nclass GenericContainer<Item>: Container<Item> {\n}\n\n// SpecificContainer becomes a container of Int type\nclass SpecificContainer: Container<Int> {\n}\n\n```"]