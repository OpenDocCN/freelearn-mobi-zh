["```kt\n    fun main(args: Array<String>) { \n      println(\"startWith Iterator\") \n      Observable.range(5,10) \n        .startWith(listOf(1,2,3,4))//(1) \n        .subscribe { \n           println(\"Received $it\") \n        } \n        println(\"startWith another source Producer\") \n       Observable.range(5,10) \n         .startWith(Observable.just(1,2,3,4))//(2) \n         .subscribe { \n            println(\"Received $it\") \n         } \n   } \n```", "```kt\n    fun startWith(items: Iterable<T>): Observable<T> { \n      return concatArray<T>(fromIterable<out T>(items), this) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.range(1,10) \n      val observable2 = Observable.range(11,10) \n      Observable.zip(observable1,observable2,  \n      io.reactivex.functions.BiFunction\n      <Int, Int, Int> { emissionO1, emissionO2 -> \n      emissionO1+emissionO2 \n      }).subscribe { \n          println(\"Received $it\") \n      } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.range(1,10) \n      val observable2 = listOf(\"String 1\",\"String 2\",\"String 3\",\n      \"String 4\",\"String 5\",\"String 6\",\"String 7\",\"String 8\",\n      \"String 9\",\"String 10\").toObservable() \n\n      observable1.zipWith(observable2,{e1:Int,e2:String -> \n      \"$e2 $e1\"})//(1) \n        .subscribe { \n            println(\"Received $it\") \n        } \n    }\n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 =  \n      Observable.interval(100,TimeUnit.MILLISECONDS)//(1) \n      val observable2 =\n      Observable.interval(250,TimeUnit.MILLISECONDS)//(2) \n\n      Observable.zip(observable1,observable2, \n        BiFunction { t1:Long, t2:Long -> \"t1: $t1, t2: $t2\" })//(3) \n        .subscribe{ \n           println(\"Received $it\") \n        } \n\n       runBlocking { delay(1100) } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.interval(100, TimeUnit.MILLISECONDS) \n      val observable2 = Observable.interval(250, TimeUnit.MILLISECONDS) \n\n      Observable.combineLatest(observable1,observable2, \n        BiFunction { t1:Long, t2:Long -> \"t1: $t1, t2: $t2\" }) \n        .subscribe{ \n           println(\"Received $it\") \n        } \n\n        runBlocking { delay(1100) } \n    }\n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = listOf(\"Kotlin\", \"Scala\",\n      \"Groovy\").toObservable() \n      val observable2 = listOf(\"Python\", \"Java\", \"C++\",\n      \"C\").toObservable() \n\n      Observable \n       .merge(observable1,observable2)//(1) \n       .subscribe { \n          println(\"Received $it\") \n       } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.interval(500,  \n      TimeUnit.MILLISECONDS).map { \"Observable 1 $it\" }//(1) \n      val observable2 = Observable.interval(100,\n      TimeUnit.MILLISECONDS).map { \"Observable 2 $it\" }//(2) \n\n      Observable \n        .merge(observable1,observable2) \n        .subscribe { \n          println(\"Received $it\") \n        } \n        runBlocking { delay(1500) } \n     }\n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = listOf(\"A\", \"B\", \"C\").toObservable() \n      val observable2 = listOf(\"D\", \"E\", \"F\", \"G\").toObservable() \n      val observable3 = listOf(\"I\", \"J\", \"K\", \"L\").toObservable() \n      val observable4 = listOf(\"M\", \"N\", \"O\", \"P\").toObservable() \n      val observable5 = listOf(\"Q\", \"R\", \"S\", \"T\").toObservable() \n      val observable6 = listOf(\"U\", \"V\", \"W\", \"X\").toObservable() \n      val observable7 = listOf(\"Y\", \"Z\").toObservable() \n\n      Observable.mergeArray(observable1, observable2, observable3, \n        observable4, observable5, observable6, observable7) \n        .subscribe { \n           println(\"Received $it\") \n        } \n    }\n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = listOf(\"Kotlin\", \"Scala\",\n      \"Groovy\").toObservable() \n      val observable2 = listOf(\"Python\", \"Java\", \"C++\",\n      \"C\").toObservable() \n\n       observable1 \n         .mergeWith(observable2) \n         .subscribe { \n            println(\"Received $it\") \n         } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.interval(500, TimeUnit.MILLISECONDS) \n        .take(2)//(1) \n        .map { \"Observable 1 $it\" }//(2) \n      val observable2 = Observable.interval(100,\n      TimeUnit.MILLISECONDS).map { \"Observable 2 $it\" }//(3) \n\n     Observable \n       .concat(observable1,observable2) \n       .subscribe { \n          println(\"Received $it\") \n       } \n\n      runBlocking { delay(1500) } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.interval(500, \n      TimeUnit.MILLISECONDS).map { \"Observable 1 $it\" }//(1) \n      val observable2 = Observable.interval(100,\n      TimeUnit.MILLISECONDS).map { \"Observable 2 $it\" }//(2) \n\n      Observable \n        .amb(listOf(observable1,observable2))//(3) \n        .subscribe { \n            println(\"Received $it\") \n         } \n\n         runBlocking { delay(1500) } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.range(1,30) \n\n      observable.groupBy {//(1) \n        it%5 \n      }.blockingSubscribe {//(2) \n        println(\"Key ${it.key} \") \n        it.subscribe {//(3) \n            println(\"Received $it\") \n        } \n      } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(1,10) \n        .flatMap { \n            val randDelay = Random().nextInt(10) \n            return@flatMap Observable.just(it) \n\n           .delay(randDelay.toLong(),TimeUnit.MILLISECONDS)//(1) \n         } \n         .blockingSubscribe { \n            println(\"Received $it\") \n         } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(1,10) \n         .concatMap { \n             val randDelay = Random().nextInt(10) \n             return@concatMap Observable.just(it) \n            .delay(randDelay.toLong(), TimeUnit.MILLISECONDS)//(1) \n          } \n         .blockingSubscribe { \n             println(\"Received $it\") \n          } \n     } \n```", "```kt\n    fun main(args: Array<String>) { \n      println(\"Without delay\") \n      Observable.range(1,10) \n      .switchMap { \n         val randDelay = Random().nextInt(10) \n         return@switchMap Observable.just(it)//(1) \n       } \n       .blockingSubscribe { \n          println(\"Received $it\") \n        } \n       println(\"With delay\") \n       Observable.range(1,10) \n       .switchMap { \n          val randDelay = Random().nextInt(10) \n          return@switchMap Observable.just(it) \n          .delay(randDelay.toLong(), TimeUnit.MILLISECONDS)//(2) \n       } \n       .blockingSubscribe { \n          println(\"Received $it\") \n       } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(1,10) \n        .switchMap { \n           val randDelay = Random().nextInt(10) \n           if(it%3 == 0) \n               Observable.just(it) \n           else \n               Observable.just(it) \n               .delay(randDelay.toLong(), TimeUnit.MILLISECONDS) \n         } \n         .blockingSubscribe { \n             println(\"Received $it\") \n         } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.range(1,20) \n      observable1 \n      .skip(5)//(1) \n      .subscribe(object:Observer<Int> { \n         override fun onError(e: Throwable) { \n            println(\"Error $e\") \n         } \n\n         override fun onComplete() { \n            println(\"Complete\") \n         } \n\n         override fun onNext(t: Int) { \n            println(\"Received $t\") \n         } \n\n         override fun onSubscribe(d: Disposable) { \n            println(\"starting skip(count)\") \n         } \n\n     }) \n\n     val observable2 = Observable.interval(100,TimeUnit.MILLISECONDS) \n     observable2 \n        .skip(400,TimeUnit.MILLISECONDS)//(2) \n        .subscribe( \n            object:Observer<Long> { \n               override fun onError(e: Throwable) { \n                 println(\"Error $e\") \n               } \n\n               override fun onComplete() { \n                 println(\"Complete\") \n               } \n\n               override fun onNext(t: Long) { \n                  println(\"Received $t\") \n               } \n\n               override fun onSubscribe(d: Disposable) { \n                  println(\"starting skip(time)\") \n               } \n\n            } \n           ) \n\n           runBlocking { \n             delay(1000) \n           } \n\n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.range(1,20) \n      observable \n       .skipLast(5)//(1) \n       .subscribe(object: Observer<Int> { \n         override fun onError(e: Throwable) { \n           println(\"Error $e\") \n         } \n\n         override fun onComplete() { \n           println(\"Complete\") \n         } \n\n         override fun onNext(t: Int) { \n            println(\"Received $t\") \n         } \n\n         override fun onSubscribe(d: Disposable) { \n            println(\"starting skipLast(count)\") \n         } \n\n       }) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.range(1,20) \n      observable \n       .skipWhile {item->item<10}//(1) \n       .subscribe(object: Observer<Int> { \n          override fun onError(e: Throwable) { \n            println(\"Error $e\") \n          } \n\n          override fun onComplete() { \n            println(\"Complete\") \n          } \n\n          override fun onNext(t: Int) { \n            println(\"Received $t\") \n          } \n\n          override fun onSubscribe(d: Disposable) { \n             println(\"starting skipWhile\") \n          } \n\n        }) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.interval(100, TimeUnit.MILLISECONDS) \n      val observable2 =\n      Observable.timer(500,TimeUnit.MILLISECONDS)//(1) \n\n      observable1 \n        .skipUntil(observable2)//(2) \n        .subscribe( \n           object: Observer<Long> { \n             override fun onError(e: Throwable) { \n                println(\"Error $e\") \n             } \n\n             override fun onComplete() { \n                println(\"Complete\") \n            } \n\n            override fun onNext(t: Long) { \n               println(\"Received $t\") \n            } \n\n            override fun onSubscribe(d: Disposable) { \n               println(\"starting skip(time)\") \n            } \n\n          } \n         ) \n\n         runBlocking { delay(1500) } \n    }\n```", "```kt\n    fun main(args: Array<String>) { \n      val observable1 = Observable.range(1,20) \n      observable1 \n        .take(5)//(1) \n        .subscribe(object:Observer<Int> { \n           override fun onError(e: Throwable) { \n              println(\"Error $e\") \n          } \n\n          override fun onComplete() { \n              println(\"Complete\") \n          } \n\n          override fun onNext(t: Int) { \n              println(\"Received $t\") \n          } \n\n          override fun onSubscribe(d: Disposable) { \n              println(\"starting skip(count)\") \n          } \n\n       }) \n\n      val observable2 = Observable.interval(100,TimeUnit.MILLISECONDS) \n      observable2 \n         .take(400,TimeUnit.MILLISECONDS)//(2) \n         .subscribe( \n            object:Observer<Long> { \n               override fun onError(e: Throwable) { \n                  println(\"Error $e\") \n               } \n\n               override fun onComplete() { \n                  println(\"Complete\") \n               } \n\n               override fun onNext(t: Long) { \n                  println(\"Received $t\") \n               } \n\n               override fun onSubscribe(d: Disposable) { \n                  println(\"starting skip(time)\") \n               } \n\n             } \n           ) \n\n           runBlocking { \n             delay(1000) \n           } \n\n     }\n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.range(1,20) \n      observable \n        .takeLast(5)//(1) \n        .subscribe(object: Observer<Int> { \n           override fun onError(e: Throwable) { \n             println(\"Error $e\") \n           } \n\n           override fun onComplete() { \n             println(\"Complete\") \n           } \n\n           override fun onNext(t: Int) { \n             println(\"Received $t\") \n           } \n\n           override fun onSubscribe(d: Disposable) { \n             println(\"starting skipLast(count)\") \n           } \n\n        }) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      val observable = Observable.range(1,20) \n      observable \n        .takeWhile{item->item<10}//(1) \n        .subscribe(object: Observer<Int> { \n            override fun onError(e: Throwable) { \n              println(\"Error $e\") \n            } \n\n            override fun onComplete() { \n              println(\"Complete\") \n            } \n\n            override fun onNext(t: Int) { \n              println(\"Received $t\") \n            } \n\n            override fun onSubscribe(d: Disposable) { \n               println(\"starting skipWhile\") \n            } \n\n          }) \n    }\n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.just(1,2,3,4,5) \n        .map { it/(3-it) } \n        .subscribe { \n           println(\"Received $it\") \n        } \n    }\n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.just(1,2,3,4,5) \n        .map { it/(3-it) } \n        .onErrorReturn { -1 }//(1) \n        .subscribe { \n           println(\"Received $it\") \n        } \n    }\n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.just(1,2,3,4,5) \n        .map { it/(3-it) } \n        .onErrorResumeNext(Observable.range(10,5))//(1) \n        .subscribe { \n           println(\"Received $it\") \n        } \n   }\n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.just(1,2,3,4,5) \n        .map { it/(3-it) } \n        .retry(3)//(1) \n        .subscribeBy ( \n            onNext  = {println(\"Received $it\")}, \n            onError = {println(\"Error\")} \n         ) \n         println(\"\\n With Predicate \\n\") \n        var retryCount = 0 \n        Observable.just(1,2,3,4,5) \n        .map { it/(3-it) } \n        .retry {//(2) \n           _, _-> \n           (++retryCount)<3 \n        } \n        .subscribeBy ( \n           onNext  = {println(\"Received $it\")}, \n           onError = {println(\"Error\")} \n        ) \n    }\n```", "```kt\n    //RxJava - Apache - HTTP \n    compile \"com.netflix.rxjava:rxjava-apache-http:0.20.7\" \n```", "```kt\n    fun main(args: Array<String>) { \n      val httpClient = HttpAsyncClients.createDefault()//(1) \n      httpClient.start()//(2) \n      ObservableHttp.createGet(\"http://rivuchk.com/feed/json\",\n      httpClient).toObservable()//(3) \n        .flatMap{ response -> \n           response.content.map{ bytes -> \n           String(bytes) \n         }//(4) \n       } \n       .onErrorReturn {//(5) \n          \"Error Parsing data \" \n       } \n       .subscribe { \n          println(it)//(6) \n          httpClient.close()//(7) \n       } \n    }  \n```"]