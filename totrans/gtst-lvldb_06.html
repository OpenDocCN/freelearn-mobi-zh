<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Integrating with a Cocoa UI</h1></div></div></div><p>The emphasis upto this point has been on how to program the database calls in C++ or Objective-C with as little user interface as possible. Now we will see some simple approaches to presenting that data in Cocoa applications, sufficient to build a full application. For the first time, our sample code will be an application driven by the user rather than just a series of test functions. These discussions assume you're comfortable using Xcode to edit interfaces, including making connections to <code class="literal">IBOutlets</code> and <code class="literal">IBActions</code>. See the references at the end of this chapter (section: <em>Recommended Xcode books</em>) for help with Xcode.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec27"/>Meeting the data source needs with LevelDB</h1></div></div></div><p>The problem with <a id="id125" class="indexterm"/>presenting lists of data in either <code class="literal">NSTableView</code> or <code class="literal">UITableView</code> is that they expect an array-like data model with two characteristics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The number of rows is known</li><li class="listitem" style="list-style-type: disc">Row contents can be retrieved at arbitrary indexes</li></ul></div><p>This is not a great fit with <a id="id126" class="indexterm"/>LevelDB which doesn't know the total number of keys, and can only get the tenth key by stepping through the nine others before. The typical solution, which we use in these samples, is to copy from the database into an <code class="literal">NSArray</code> <a id="id127" class="indexterm"/>class, to fill the table view. This performs well for usable data quantities in a single scrolling table. I tested with 50,000 records like the 500 bundled here and it's still fast and usable on an iPhone4.</p><p>To get the full details of data associated with a given row, when the row is selected, you need to be able to map from a row number to a position in the data source. This is complicated if you allow resorting of the table by clicking headers or dragging and dropping new content. We will not go into a great level of detail with this example but the usual technique is to use an <code class="literal">NSMutableArray</code> <a id="id128" class="indexterm"/>subclass so that cells can be moved.</p><p>While the discussion following is all about the OS X app, the iOS version is included online and is nearly identical, substituting <code class="literal">UITableview</code> for <code class="literal">NSTableview</code>. The other major difference is where to put the <a id="id129" class="indexterm"/>controller logic. In simple OS X apps, the <code class="literal">AppDelegate</code> is used where you <a id="id130" class="indexterm"/>would use the <code class="literal">ViewController</code> class in iOS apps.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Creating the OS X GUI</h1></div></div></div><p>The OS X UI combines a searchable <a id="id131" class="indexterm"/>list of records with an adjacent data entry form to see and change the details of a record, including creating new records.</p><div><img src="img/1015OS_06_01.jpg" alt="Creating the OS X GUI"/><div><p>OS X sample app showing list with search results and record details</p></div></div><p>The OS X app is a single window <code class="literal">MainMenu06.xib</code> with:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An <code class="literal">NSTableView</code> <a id="id132" class="indexterm"/>class for listing <a id="id133" class="indexterm"/>records</li><li class="listitem" style="list-style-type: disc">An <code class="literal">NSSearchField</code> <a id="id134" class="indexterm"/>class to enter searches, that triggers <a id="id135" class="indexterm"/>as you type</li><li class="listitem" style="list-style-type: disc">A series of <a id="id136" class="indexterm"/><code class="literal">NSTextField</code> fields for editing the individual parts <a id="id137" class="indexterm"/>of the record</li><li class="listitem" style="list-style-type: disc">Two <a id="id138" class="indexterm"/><code class="literal">NSButtons</code> for <a id="id139" class="indexterm"/>issuing the commands, <strong>Save</strong> and <strong>New</strong></li><li class="listitem" style="list-style-type: disc">A menu bar with <a id="id140" class="indexterm"/>the <a id="id141" class="indexterm"/>same commands as the buttons (for example, <strong>File</strong> | <strong>Save</strong>)</li></ul></div><p>It was created using the Xcode template for a <a id="id142" class="indexterm"/>new Cocoa app, not checking the <strong>Document-based</strong> option.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Connecting the database to the NSTableView</h1></div></div></div><p>All these interface <a id="id143" class="indexterm"/>methods and outlets are in <code class="literal">GSwLDB06osxAppDelegate</code>.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Live searching as you <a id="id144" class="indexterm"/>type occurs automatically because the action of the <code class="literal">NSSearchField</code> object <a id="id145" class="indexterm"/>is connected to the <code class="literal">IBActionviewMatches</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">datasource</code> and <code class="literal">delegate</code> outlets of the <code class="literal">NSTableView</code> class are connected to <code class="literal">GSwLDB06osxAppDelegate</code>, which has a corresponding outlet <code class="literal">tableView</code> <a id="id146" class="indexterm"/>referencing the <code class="literal">NSTableView</code> class</li></ul></div><p>In order to support table operations, two independent protocols were added to the object. <code class="literal">NSTableViewDelegate</code> is <a id="id147" class="indexterm"/>about table behaviour, responding to events such as editing and dragging items. The vital two methods supplying displayed data to the table are provided by the <code class="literal">NSTableViewDataSource</code> <a id="id148" class="indexterm"/>protocol. It is common, but not mandatory, for these two protocols to be satisfied by one object:</p><div><pre class="programlisting">@interface GSwLDB06osxAppDelegate: NSObject
&lt;NSApplicationDelegate, NSTableViewDataSource,
NSTableViewDelegate&gt;
- (IBAction)viewMatches:(id)sender;
- (IBAction)newRecord:(id)sender;
- (IBAction)saveRecord:(id)sender;
@property (weak) IBOutletNSTextField *FirstNameEntry;
...
@property (weak) IBOutletNSTextField *EmailEntry;
@property (assign) IBOutletNSWindow *window;
@property (retain) IBOutletNSTableView *tableView;
@end</pre></div><p>There is a clear separation between this GUI delegate and a <code class="literal">Model</code> class which is responsible for managing a data selection and is reused in the iOS app. As an <code class="literal">NSTableViewDataSource</code> <a id="id149" class="indexterm"/>protocol, the delegate asks the model for data. The GUI knows nothing about LevelDB.The table-related methods in <code class="literal">GSwLDB06osxAppDelegate</code> are:</p><div><pre class="programlisting">- (IBAction)viewMatches:(id)sender {
  [self.modelloadStartingWith:[sender stringValue]];
  [self.tableViewreloadData];
  [selfloadFieldsForCurrentSelectedRow];  // explicitly reload
}

- (NSInteger) numberOfRowsInTableView:(NSTableView *)table {
  return [self.modelcountRows];
}

- (id)tableView:(NSTableView *)table
    objectValueForTableColumn:(NSTableColumn *)column
    row:(NSInteger)rowIndex
{ // cheat by using combined Last/First Name rather than two cols
  return [self.modelkeyForRow:rowIndex];
}</pre></div><p>The public interface <a id="id150" class="indexterm"/>of the <a id="id151" class="indexterm"/>Model is in <code class="literal">Sample06_Model.h</code>:</p><div><pre class="programlisting">@interface Sample06_Model :NSObject
+ (Sample06_Model*)modelWithSampleDatabasePath:
(NSError**)errorOut;
- (void)loadSampleDatafile:(NSString*)filename;
- (NSString*)keyForRow:(NSInteger)row;
- (int)countRows;
- (void)loadStartingWith:(NSString*)partialKey;
- (NSArray*)fieldsForRow:(NSInteger)index;
- (BOOL)saveRecord:(NSArray*)fields;
@end
enumfieldOffsets {eFirstName=0, eLastName=1, eCompany=2,
eState=3, eZip=4, ePhone=5, eEmail=6};</pre></div><p>Private methods and properties are added by a class extension in <code class="literal">Sample06_Model.m</code>:</p><div><pre class="programlisting">@interface Sample06_Model(){}	
- (Sample06_Model*) initWithSampleDatabasePath:
(NSError**)errorOut;
- (void)loadListForUI;
- (NSString*)mainKeyFrom:(NSString*)key;
- (void)addRecord:(NSArray*)fields
using:(id&lt;APLevelDBWriteBatch&gt;)batch;
@property (retain) APLevelDB* db;
@property (retain) NSArray* rowsForUI;
@end

- (void)loadStartingWith:(NSString*)partialKey {
  self.rowsForUI = [self.dbkeysWithPrefix:partialKey];
}

- (int)countRows{
  if (self.rowsForUI == nil)
    [selfloadListForUI];
  return [self.rowsForUI count];
}

- (NSString*) keyForRow:(NSInteger)row{
  if (self.rowsForUI == nil)
    [selfloadListForUI];
  return (NSString*)(self.rowsForUI[row]);
}

- (void)loadListForUI {
  self.rowsForUI = [self.dballKeys];
}</pre></div><p>There's a consistent pattern assuming that <code class="literal">loadListForUI</code> might need to be called at any time. Although it's just one <a id="id152" class="indexterm"/>line, it's <a id="id153" class="indexterm"/>separated out into a method so later code can be smarter about loading the list.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Connecting record details to the editing form</h1></div></div></div><p>The editing GUI displays <a id="id154" class="indexterm"/>details of a record next to the table, based on the <a id="id155" class="indexterm"/>current selection in the table. We can change records and save them back, or click on a different row without warning of losing our changes. The simplest editing behaviours are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Respond</strong> to changing <a id="id156" class="indexterm"/>table selection by displaying the details</li><li class="listitem" style="list-style-type: disc"><strong>Save</strong> to copy the details <a id="id157" class="indexterm"/>entered back to the database</li><li class="listitem" style="list-style-type: disc"><strong>New</strong> to clear the entry fields so a <a id="id158" class="indexterm"/>record can be added</li></ul></div><p>The record details are presented by the model as an <code class="literal">NSArray</code> class of <code class="literal">NSString</code> values, indexed by the enum <code class="literal">fieldOffsets</code>. You could think of this as a horizontal array, in contrast to the vertical array of keys displayed in the table.</p><p>Allowing and responding to <strong>selection</strong> <a id="id159" class="indexterm"/>changes is simple. The two <a id="id160" class="indexterm"/>selection-related methods declared by the protocol <code class="literal">NSTableViewDelegate</code> are also used:</p><div><pre class="programlisting">- (void)tableViewSelectionDidChange:(NSNotification*)notification
{
  [selfloadFieldsForCurrentSelectedRow];
}

- (BOOL)selectionShouldChangeInTableView:(NSTableView*)tableView {
  return YES; // assumes we always leave, abandoning changes
}

- (void)loadFieldsForCurrentSelectedRow {  // mirrors saveRecord
if ([self.tableViewnumberOfSelectedRows] == 0) {
    [selfclearEntryFields];
    return;
  }
  NSArray* fields = [self.modelfieldsForRow:row];
  [self.FirstNameEntrysetStringValue:fields[eFirstName] ];
...
  [self.EmailEntrysetStringValue:fields[eEmail] ];
}

- (IBAction)saveRecord:(id)sender {
  NSArray* fields = [NSArrayarrayWithObjects:
    [self.FirstNameEntrystringValue],
...
    [self.EmailEntrystringValue],
  nil ]; // built an array of all field entries
  [self.modelsaveRecord:fields]; // save array to record
}

- (IBAction)newRecord:(id)sender {
  if ([self.tableViewnumberOfSelectedRows] == 0)
    [selfclearEntryFields];
  else  // selecting none will trigger clearEntryFields
    [self.tableViewdeselectAll:sender];
}</pre></div><p>The <code class="literal">Sample06_Model.m</code> support for the GUI knows how to map a row number from the GUI to a database key, as we saw, used to provide the tableview contents. Similar logic provides the key we now use to <a id="id161" class="indexterm"/>retrieve a database record:</p><div><pre class="programlisting">- (NSArray*)fieldsForRow:(NSInteger)index
{
  NSString* key = [self keyForRow:index];
  NSData* mainRec = [self.dbdataForKey:key];
  NSError* decodeErr;
  NSArray* fields = [NSJSONSerialization
  JSONObjectWithData:mainRec options:0 error:&amp;decodeErr];
  return fields;
}</pre></div><p>That takes care of data loading. To <a id="id162" class="indexterm"/>save we will need to send an array of fields back to the model and update the database. This starts with <code class="literal">(IBAction)saveRecord</code> in <code class="literal">GSwLDB06osxAppDelegate</code>. It calls the model's <code class="literal">saveRecord</code> method which in turn uses <code class="literal">addRecord</code> to save a key of combined names with JSON for the body:</p><div><pre class="programlisting">- (IBAction)saveRecord:(id)sender {
  NSArray* fields  = [NSArrayarrayWithObjects:
    [self.FirstNameEntrystringValue],
...
    [self.EmailEntrystringValue],
  nil ];
  [self.modelsaveRecord:fields];
  self.isNewRecord = NO;
  [self.tableViewreloadData];
}

- (void)saveRecord:(NSArray*)fields {
  id&lt;APLevelDBWriteBatch&gt;wb = [self.dbbeginWriteBatch];  
  [selfaddRecord:fieldsusing:wb];
  [self.dbcommitWriteBatch:wb];  
  self.rowsForUI = nil; // force reload when UI refreshes
  return YES;
}

- (void)addRecord:(NSArray*)fields 
  using:(id&lt;APLevelDBWriteBatch&gt;)batch{
  NSString* nameKey = nameKeyFromFields(fields); 
  NSError* encErr;
  NSData* enc = [NSJSONSerializationdataWithJSONObject:fields
    options:0 error:&amp;encErr];
    [batchsetData:encforKey:nameKey];
}</pre></div><p>A new action is just a GUI action <a id="id163" class="indexterm"/>clearing all the entry fields. It sets a property of the delegate <code class="literal">isNewRecord</code>, as you saw, used in the preceding code in <code class="literal">saveRecord</code>, but has no <a id="id164" class="indexterm"/>effect on the Model or leveldb. Only if you save a new record will the database be used.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Recommended Xcode books</h1></div></div></div><p>The following Packt books are <a id="id165" class="indexterm"/>very straightforward with good examples walking you through the Xcode interface editor and explaining the table classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Cocoa and Objective-C Cookbook</em>, <em>Jeff Hawkins</em>, <em>Packt Publishing</em> for <code class="literal">NSTableView</code> on OS X</li><li class="listitem" style="list-style-type: disc"><em>Xcode 4 Cookbook</em>, <em>Steven F Daniel</em>, <em>Packt Publishing</em>, for <code class="literal">UITableView</code> on iOS</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Summary</h1></div></div></div><p>We now have a good start on a real database app with a separation between the GUI and data model. Your understanding of adding data and searching was used in the model layer. We covered the needs of loading lists of records and how to show detailed data based on our selection. Now that we have a more complex application, the next chapter will show us how to use some debugging techniques to see data changes. After that we'll come back to <code class="literal">Sample06</code> and add a secondary index, delete, and more complex data updates.</p></div></body></html>