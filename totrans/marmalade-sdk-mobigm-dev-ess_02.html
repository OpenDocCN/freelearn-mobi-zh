<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Resource Management and 2D Graphics Rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Resource Management and 2D Graphics Rendering</h1></div></div></div><p>Unless you happen to be writing an old school text adventure game (and perhaps even if you are), chances are that you will want more than just text in a simple debug font to appear on screen. Drawing nice-looking graphics demands that we should also be able to load those graphics into memory in order to display them; so in this chapter we will be looking at the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using Marmalade's resource manager to load games resources</li><li class="listitem" style="list-style-type: disc">Extending the resource management system with our own custom classes</li><li class="listitem" style="list-style-type: disc">The programming choices we have available to us for rendering purposes</li><li class="listitem" style="list-style-type: disc">How to display a bitmapped image on screen using the IwGx API</li></ul></div><div class="section" title="The Marmalade ITX file format"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The Marmalade ITX file format</h1></div></div></div><p>An ITX<a id="id146" class="indexterm"/> file<a id="id147" class="indexterm"/> is Marmalade's built-in file format that can be used for loading all kinds of data into our program. The extension ITX is short for Ideaworks TeXt; Ideaworks being the original name of the company that<a id="id148" class="indexterm"/> created the SDK before they rebranded themselves as Marmalade.</p><p>ITX files have a simple text format and are used as the basis for resource loading. While it is possible to load resources ourselves, it is a bit like reinventing the wheel when Marmalade already provides a great deal of support for this truly tedious aspect of coding.</p><p>Marmalade has an API called IwUtil<a id="id149" class="indexterm"/> that contains a wide range of useful utility functions ranging from memory management and debugging through to the serialization of objects and random number generation. It also contains a class called<a id="id150" class="indexterm"/> <code class="literal">CIwTextParserITX</code>, which allows us to load and process an ITX file.</p><p>To add this functionality to our own project, we just need to add <code class="literal">iwutil</code> to the <code class="literal">subprojects</code> list of the MKB file and then add a call to <code class="literal">IwUtilInit</code> at the start of our program, and <code class="literal">IwUtilTerminate</code> in our shutdown code.</p><p>Before we can use the text parser, we will need to create an instance of it by using <code class="literal">new CIwTextParserITX</code>. This class is a singleton class, so we can create an instance of it at the start of our program and then reuse it as much as we like in the rest of our code (don't forget to release it on shutdown!). The instance can be accessed using the<a id="id151" class="indexterm"/> <code class="literal">IwGetTextParserITX</code> function, and we can then load and parse an ITX file using the following code:</p><div class="informalexample"><pre class="programlisting">IwGetTextParserITX()-&gt;ParseFile("myfile.itx");</pre></div><p>An ITX file is little <a id="id152" class="indexterm"/>more than a big collection of class definitions. An <a id="id153" class="indexterm"/>instance of a class is defined by first putting the name of the class followed by a list of parameters for that instance enclosed in curly braces. Let's say we had a class called <code class="literal">WidgetClass</code> that was defined as follows (don't worry about the <code class="literal">CIwManaged</code> class <a id="id154" class="indexterm"/>and the <code class="literal">IW_MANAGED_DECLARE</code> macro<a id="id155" class="indexterm"/> for now, we'll come to these in a bit):</p><div class="informalexample"><pre class="programlisting">class WidgetClass : public CIwManaged
{
public:
  IW_MANAGED_DECLARE(WidgetClass)
  WidgetClass();
private:
  uint8         mColor[3];
  int32         mSize;
  bool          mSparkly;
  WidgetClass*  mpNextWidget;
  uint32        mNextWidgetHash;
};</pre></div><p>Here is an example of how we might instantiate this class from within an ITX file:</p><div class="informalexample"><pre class="programlisting">WidgetClass
{
  name     "red_widget"
  color    { 255 0 0 }
  size     10
  sparkly  true
}

WidgetClass
{
  name     "green_widget"
  color    { 0 255 0 }
  size    20
  sparkly  false
  next    "red_widget"
}</pre></div><p>This sample declares two instances of <code class="literal">WidgetClass</code>, and initializes those instances with a name, color value, size, and a flag indicating whether the widget in question is sparkly or not. Each of these <a id="id156" class="indexterm"/>
<a id="id157" class="indexterm"/>settings is called an attribute, and they can be of any type we desire—string, integer, floating point, boolean, or an array of values (the <code class="literal">color</code> attribute provides an example of this).</p><p>Hopefully, you are looking at this and thinking how exactly this format can be magically loaded and instanced by the Marmalade text parser, since it obviously knows nothing about <code class="literal">WidgetClass</code>. A good question! The answer is that any class that you wish to parse from an ITX file must first be derived from the Marmalade class <code class="literal">CIwManaged</code>.</p><div class="section" title="The CIwManaged class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>The CIwManaged class</h2></div></div></div><p>The <code class="literal">CIwManaged</code> class<a id="id158" class="indexterm"/> is the base class used throughout the Marmalade SDK and by our own classes whenever we want to be able to create instances of them by loading from a file.</p><p>The class provides some virtual methods that we can override to allow the parser to recognize our own custom classes, and also to serialize them into a binary format and resolve any references to other classes or resources. It also provides the coding glue required to instantiate copies of our class at runtime.</p><p>This facility is really useful for us as it allows us to make our code more data-driven. Say we have a class that describes an item that the player can collect. We might have lots of different item types in our game, so rather than creating instances of them all in the source code, which only a programmer can then change, we could instead instantiate them from an ITX file, which a game designer with no coding knowledge can then edit.</p><div class="section" title="Instantiating a class with the class factory"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Instantiating a class with the class factory</h3></div></div></div><p>The first thing <code class="literal">CIwTextParserITX</code> will encounter in the ITX file is the class name, which it <a id="id159" class="indexterm"/>
<a id="id160" class="indexterm"/>will use to create a brand new instance of our class. It achieves this by using the class factory, which is another part of the<a id="id161" class="indexterm"/> IwUtil API.</p><p>A <a id="id162" class="indexterm"/>class factory is a programming pattern that allows us to generate new instances of objects at runtime by asking another class (the so-called factory) to create a relevant class instance for us.</p><p>The Marmalade class factory system allows us to add our own classes to those provided by the SDK itself by registering a unique hash value identifying the class and a method that creates a new instance of it.</p><p>The hash value is normally derived by converting the name of the class into a number by passing its name as a string to the IwUtil API's function<a id="id163" class="indexterm"/> <code class="literal">IwHashString</code>. While this isn't guaranteed to produce a unique number, it is usually good enough for our purposes and clashes with hash values from other class names are rare.</p><p>To add our own custom <code class="literal">CIwManaged</code> derived class to the class factory, we just need to do the following (if you want to see a full example of this and indeed the things we'll be covering in the next few sections, take a look at the source code for the ITX project that accompanies this chapter):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">IW_MANAGED_DECLARE(CustomClassName)</code> macro to the public section of the class. This declares a method called<a id="id164" class="indexterm"/> <code class="literal">GetClassName</code>, which will return the name of the class as a string, and also adds a couple of type definitions to allow the class to be used more easily with the <code class="literal">CIwArray</code> class, which is yet another piece of functionality provided by IwUtil.</li><li class="listitem">Add the macro <code class="literal">IW_MANAGED_IMPLEMENT_FACTORY(CustomClassName)</code> to the source file for the class. This macro implements the <code class="literal">GetClassName</code> method and also creates the necessary class factory function that will be used to create a new instance of our class.</li><li class="listitem">Finally, we have to register our class with the class factory itself by adding the macro <code class="literal">IW_CLASS_REGISTER(CustomClassName)</code> somewhere in our initialization code.</li></ol></div><p>With this done, we <a id="id165" class="indexterm"/>
<a id="id166" class="indexterm"/>can now include our class in an ITX file. The <code class="literal">CIwTextParserITX</code> class can now create a brand new instance of it with a call to the class factory function <code class="literal">IwClassFactoryCreate("CustomClassName")</code>.</p></div><div class="section" title="Parsing a class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Parsing a class</h3></div></div></div><p>With the creation of a <a id="id167" class="indexterm"/>new instance of our class taken care of, the next step is to allow <code class="literal">CIwTextParserITX</code> to configure that instance by modifying its members. This is done with the following<a id="id168" class="indexterm"/> <code class="literal">CIwManaged</code> class' virtual methods:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ParseOpen</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id169" class="indexterm"/>
<a id="id170" class="indexterm"/> method gets called when the text parser reaches the open curly brace of the class definition. It can be used to initialize anything that might be needed internally during the process of parsing an object.</p>
<p>It is important<a id="id171" class="indexterm"/> that you do not use this method to initialize all the member variables of your class to some default values. The class constructor is a far better place to do this, as it is guaranteed to be called however the instance ends up being created.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ParseAttribute</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id172" class="indexterm"/>method is called whenever an attribute is encountered in the object <a id="id173" class="indexterm"/>definition. The attribute is passed as a standard C-style string to this method, which can then process it as needed.</p>
<p>The text parser can be used within this method to extract any data elements in a variety of different ways, including strings, integers, and Boolean values.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ParseClose</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id174" class="indexterm"/>method <a id="id175" class="indexterm"/>is called when the closing curly brace of the class definition is encountered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ParseCloseChild</code>
</p>
</td><td style="text-align: left" valign="top">
<p>It is possible to <a id="id176" class="indexterm"/>embed class definitions inside other class definitions in an ITX file. If a class does not implement the <code class="literal">ParseClose</code> method then when its closing curly brace is <a id="id177" class="indexterm"/>encountered, the <code class="literal">ParseCloseChild</code> method will be called on the parent class with a pointer to the child class.</p>
<p>In this case parent and child do not refer to class inheritance hierarchies, but rather to how the classes have been defined in the ITX file. For example:</p>
<p>
</p><div class="informalexample"><pre class="programlisting">ParentClass
{
    name "parent"

    ChildClass
    {
        name "child"
    }
}</pre></div><p>
</p>
</td></tr></tbody></table></div><p>When overriding any of these methods, you should normally call the version of the method from the superclass, be that <code class="literal">CIwManaged</code> or some other class derived from it. For example, the <code class="literal">name</code> <a id="id178" class="indexterm"/>attribute is parsed by <code class="literal">CIwManaged::ParseAttribute</code>, which not only reads the name for the class but also generates a hash value of the name. The hash value is very important when it comes to serializing and resolving class instances later.</p><p>The following diagram shows an example of how an instance of <code class="literal">WidgetClass</code> defined earlier in this chapter would be processed by the ITX parser:</p><div class="mediaobject"><img src="graphics/3363_02_07.jpg" alt="Parsing a class"/></div><p>For <code class="literal">WidgetClass</code> the only <a id="id179" class="indexterm"/>method we would definitely need to implement is the<a id="id180" class="indexterm"/> <code class="literal">ParseAttribute</code> method, which might look like the following code:</p><div class="informalexample"><pre class="programlisting">bool WidgetClass::ParseAttribute(CIwTextParserITX* apParser,
const char* apAttribute)
{
  if (!stricmp(apAttribute, "color"))
  {
    apParser-&gt;ReadUInt8Array(mColor, 3);
  }
else if (!stricmp(apAttribute, "size"))
  {
    apParser-&gt;ReadInt32(&amp;mSize);
  }
else if (!stricmp(apAttribute, "sparkly"))
  {
    apParser-&gt;ReadBool(&amp;mSparkly);
  }
else if (!stricmp(apAttribute, "next"))
  {
  CIwStringL lNextWidget;
  apParser-&gt;ReadString(lNextWidget);
  mNextWidgetHash = IwHashString(lNextWidget.c_str());
  }
else
    return CIwManaged::ParseAttribute(apParser, apAttribute);
return true;
}</pre></div></div><div class="section" title="Serializing a class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Serializing a class</h3></div></div></div><p>Serializing an <a id="id181" class="indexterm"/>object instance is the process of converting the current state of the object into (or from) a binary format.</p><p>While not strictly necessary when parsing an ITX file, it is still very much a useful part of the functionality provided by <code class="literal">CIwManaged</code>, and forms an integral part of the resource handling process that we will be seeing later in this chapter.</p><p>The serialization functionality can also be useful when it comes to saving out things such as current game progress or high score tables, though of course we can still use normal file handling operations to do this if we prefer.</p><p>Serialization of our class is handled by overriding the virtual method <code class="literal">Serialise</code>. This method can then use the serialization functions provided by IwUtil, which all start with the prefix <code class="literal">IwSerialise</code>.</p><p>For example, <code class="literal">IwSerialiseInt32</code> will serialize an <code class="literal">int32</code> value. All these functions make use of the Marmalade type definitions for the basic variable types, as these are far more explicit when it comes to the memory footprint of a variable. Take a look at the header files <code class="literal">IwSerialise.h</code> and <code class="literal">s3eTypes.h</code> in the Marmalade SDK installation for more information on the <code class="literal">IwSerialise</code> functions and the variable types respectively.</p><p>We must make sure to call our superclass implementation of <code class="literal">Serialise</code> as well to ensure every part of the object is serialized. Normally this would be the first thing we do in our implementation of <a id="id182" class="indexterm"/>
<code class="literal">Serialise</code>, but it does not have to be so as long as it is called at some point.</p><p>We can serialize our objects to a file of our choosing by calling <code class="literal">IwSerialiseOpen</code>. This allows us to specify the filename and a Boolean flag that indicates whether we are reading or writing the file. We then call the <code class="literal">Serialise</code> method of each object we want to serialize, and finally call <code class="literal">IwSerialiseClose</code> to finish the process.</p><p>One nice feature of the <code class="literal">IwSerialise</code> functions is that, in most cases, we do not have to worry about whether the <code class="literal">Serialise</code> method has been called to write data to a file or if it has been called to read data from a file. We just call the function and it will read or write the value, as appropriate.</p><p>There are times that we will care about reading or writing values to a file; for example, if we need to allocate a block of memory to read some values into. The functions <code class="literal">IwSerialiseIsReading</code> and <code class="literal">IwSerialiseIsWriting</code> allow us to make the appropriate decisions.</p><p>The <a id="id183" class="indexterm"/>following code snippet illustrates how the serialization functions are used by showing what the<a id="id184" class="indexterm"/> <code class="literal">Serialise</code> method might look like for <code class="literal">WidgetClass</code>:</p><div class="informalexample"><pre class="programlisting">void WidgetClass::Serialise()
{
  CIwManaged::Serialise();
  IwSerialiseUInt8(mColor[0], 3);
  IwSerialiseInt32(mSize);
  IwSerialiseBool(mSparkly);
}</pre></div></div><div class="section" title="Resolving a class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec17"/>Resolving a class</h3></div></div></div><p>The act of resolving a <a id="id185" class="indexterm"/>class instance is to fix up any parts of our class that are not initialized correctly when parsing the object from an ITX file or having created it from the serialization process.</p><p>When might this happen? The most frequent reason for needing to resolve our instances is when the instance requires a pointer to another class that may not exist when it is first created.</p><p>This is best illustrated by an example. Let's say our class contains a pointer to another instance of our class in order to implement a linked list. When we read in our instances, it is possible we might refer to an instance that has not yet been created and so we can't create the linked list yet.</p><p>To solve this problem we instead store a value in our data that will allow us to look up the required instance later. This might be a string representing the name of the instance or perhaps a unique identifier number.</p><p>Once all the instances have been read in, we can then call the <code class="literal">CIwManaged</code> class' virtual method <code class="literal">Resolve</code> on each instance in turn and obtain the required pointer to the correct instance using whatever methodology we see fit. For example, we might maintain a list of all instances of our class that gets added to whenever a new instance is created. We can then use this list to look up the required instance.</p><p>It is not always necessary to create our own implementation of <code class="literal">Resolve</code>, but if we do we must be sure to call the inherited version of the method from our superclass.</p><p>We'll take one more look at <code class="literal">WidgetClass</code> to wrap this all up. You may remember that it had a member <code class="literal">mpNextWidget</code> that points to another instance of <code class="literal">WidgetClass</code>. In the ITX file, we supplied a value for this member by specifying the name of another <code class="literal">WidgetClass</code> instance. In the<a id="id186" class="indexterm"/> <code class="literal">ParseAttribute</code> method, we read in this name and calculated a hash value from it which was stored in the <code class="literal">mNextWidgetHash</code> member variable.</p><p>We can implement <a id="id187" class="indexterm"/>the <code class="literal">Resolve</code> method and look up a pointer to the correct instance but we'll also need to maintain a list of all <code class="literal">WidgetClass</code> instances in order to do this. One way of doing this is to implement <code class="literal">ParseClose</code> and store each instance in a list. The following code shows how this could be achieved:</p><div class="informalexample"><pre class="programlisting">void WidgetClass::ParseClose(CIwTextParserITX* apParser)
{
  // Add this instance to a list.  gpWidgetList is an instance of a
  // Marmalade class called CIwManagedList which is very useful
  // for storing lists of objects derived from CIwManaged!
  gpWidgetList-&gt;Add(this);
}

void WidgetClass::Resolve()
{
  // Look up an instance of WidgetClass with the given hash
  if (mNextWidgetHash)
  {
    mpNextWidget = static_cast&lt;WidgetClass*&gt;
                   (gpWidgetList-&gt;GetObjHashed(mNextWidgetHash));
  }
}</pre></div></div></div></div></div>
<div class="section" title="The Marmalade resource manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>The Marmalade resource manager</h1></div></div></div><p>Most bitmap art <a id="id188" class="indexterm"/>
<a id="id189" class="indexterm"/>packages are capable of saving images in a number of different file formats, but we really need access to the actual bitmap data itself, which may well be stored in a compressed format with any particular file format.</p><p>Marmalade makes the task of loading images simple by way of the<a id="id190" class="indexterm"/> IwResManager API. This API relies upon the ITX file format we have just discussed, and is not just limited to loading images. It can also be used to load in data such as 3D models and animations, and we can also use it to keep track of our own custom classes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Earlier we had to create our own instance of <code class="literal">CIwTextParserITX</code> in order to parse an ITX file. IwResManager creates its own instance of <code class="literal">CIwTextParserITX</code> when it needs it, so we don't need to worry about creating our own instance.</p></div></div><div class="section" title="Adding IwResManager to a project"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Adding IwResManager to a project</h2></div></div></div><p>To make the <a id="id191" class="indexterm"/>
<a id="id192" class="indexterm"/>IwResManager API available to a project, all that needs to be done is to add <code class="literal">iwresmanager</code> to the subprojects list in the MKB file.</p><p>To initialize the API just add a call to <code class="literal">IwResManagerInit</code>, which will create a singleton instance of the Marmalade resource manager class <code class="literal">CIwResManager</code>. This class is used to load, free, and of course access our projects resources, whatever they may be. The singleton can be accessed using the function <code class="literal">IwGetResManager</code>.</p><p>When our project terminates we should call<a id="id193" class="indexterm"/> <code class="literal">IwResManagerTerminate</code>, which will destroy the resource manager singleton and any resources it may still have loaded in memory.</p></div><div class="section" title="Specifying resources with a GROUP file"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Specifying resources with a GROUP file</h2></div></div></div><p>Marmalade <a id="id194" class="indexterm"/>
<a id="id195" class="indexterm"/>allows us to collect different types of resources together into a resource group. We are free to mix images, sounds, 3D models, and any other data types we might need to use.</p><p>Why would we want to group resources together? Well, let's say you are writing a game with a number of different levels. Each level will have some common resources (for example, the player graphics) but might have unique elements specific to that level, so it would make sense to only have these resources in memory when the level is being played. You could therefore create one resource group for the player graphics, and individual ones for each level.</p><p>In order to load a resource group into our program, we first need to create a GROUP file. A GROUP file<a id="id196" class="indexterm"/> is actually an ITX file with the extension <code class="literal">.group</code> that allows us to list all the resources we want to gather together.</p><p>Let's start by taking a look at a sample GROUP file:</p><div class="informalexample"><pre class="programlisting">CIwResGroup
{
  name  "game_resources"

  "./images/titlescreen.png"
  "./sounds/sounds.group"
  "./levels/levels.itx"
}</pre></div><p>The first line of this file is defining a new <code class="literal">CIwResGroup</code> class instance, which is the class used to implement a resource group, and the first thing we do inside the curly braces of the definition is to give the resource group a name. This name will be used later to allow us to access the resource group.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>A GROUP file should only contain a single <code class="literal">CIwResGroup</code> definition. The Marmalade SDK documentation states that behavior is undefined should you specify more than one. In practice this is not a problem since the GROUP file is the lowest level block of resources that can be loaded at a time, so there would be no real benefit in specifying more than one <code class="literal">CIwResGroup</code> anyway.</p></div></div><p>The remaining lines of the example definition specify the resources we want to include in this group, and most often these will just be filenames for the resources in question. As we progress through this book we will see some extra functionality that the group file provides us with, but for now we'll just concentrate on the main task of loading resources.</p><p>In the <a id="id197" class="indexterm"/>
<a id="id198" class="indexterm"/>example, we are specifying three files that we want to be part of this resource group. The first is a bitmapped image saved in the PNG file format. The next resource is a reference to another GROUP file. When this GROUP file is loaded, the <code class="literal">sounds.group</code> file <a id="id199" class="indexterm"/>will be loaded into memory as well.</p><p>The final file we are including <a id="id200" class="indexterm"/>is <code class="literal">levels.itx</code>, which is a standard ITX file and would be used to create instances of our own classes.</p></div><div class="section" title="Loading groups and accessing resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Loading groups and accessing resources</h2></div></div></div><p>To load a GROUP file<a id="id201" class="indexterm"/> in our program, we do the following:</p><div class="informalexample"><pre class="programlisting">CIwResGroup* pResGroup;
pResGroup = IwGetResManager()-&gt;LoadGroup("groupfile.group");</pre></div><p>This will look in the project's <code class="literal">data</code> directory for the specified GROUP file, and then load it into memory. The <code class="literal">LoadGroup</code> method<a id="id202" class="indexterm"/> returns a pointer to the <code class="literal">CIwResGroup</code> instance that was created, which we can store away somewhere so we can release the resource group and all its resources later.</p><p>With the resource group<a id="id203" class="indexterm"/>
<a id="id204" class="indexterm"/> in memory, we can access the individual resources in one of two ways. The first way is to ask the <code class="literal">CIwResGroup</code> instance itself to locate a particular resource for us. Here's how we do this:</p><div class="informalexample"><pre class="programlisting">CIwResource* pResource;
pResource = pResGroup-&gt;GetResNamed(name, type, flags);</pre></div><p>In the call to <code class="literal">GetResNamed</code>, the <code class="literal">name</code> parameter is a null terminated string containing the name of the resource we want to access. This is the value that is specified using the <code class="literal">name</code> attribute in an ITX file. If no <code class="literal">name</code> value is explicitly specified, the name of the first resource encountered in the GROUP file (minus any extension) will be used for the name. In the example GROUP file in the previous section this name would become <code class="literal">titlescreen</code>, since the first resource in the file is the <code class="literal">titlescreen.png</code> file.</p><p>The <code class="literal">type</code> parameter indicates the class of the resource that we are trying to locate. This parameter is also a string and is simply the class name of the resource type.</p><p>Finally there is the <code class="literal">flags</code> parameter that we can normally leave out entirely as it defaults to a value of zero. There are various flags we can use that alter the way the search for our resource is performed. For example, <code class="literal">IW_RES_PERMIT_NULL_F</code> will prevent an assert from being fired if the required resource could not be found. Check the Marmalade documentation for more information on these flags, though in most cases the default value of zero is what we need to use.</p><p>If the resource can't be found, the <code class="literal">GetResNamed</code> call will return <code class="literal">NULL</code>, otherwise it returns our resource as a pointer to a <code class="literal">CIwResource</code> instance, which we can then cast to the required class type.</p><p>The second way of <a id="id205" class="indexterm"/>
<a id="id206" class="indexterm"/>accessing a resource is to ask the resource manager to find it by searching through all the currently loaded groups. This can be very useful since it means we don't have to know exactly which resource group to search in. Obviously a full search of all currently loaded resource groups will be slower, but it means we don't have to keep track of every resource group we load. After all, that's what the resource manager is for! The call required to search all loaded groups for a particular resource is as follows:</p><div class="informalexample"><pre class="programlisting">CIwResource* pResource;
pResource = IwGetResManager()-&gt;GetResNamed(name, type, flags);</pre></div><p>The parameters are exactly the same as calling the<a id="id207" class="indexterm"/> <code class="literal">CIwResGroup::GetResNamed</code> method.</p><p>Finally, we can remove a resource group and everything it contains from memory by making the following call:</p><div class="informalexample"><pre class="programlisting">IwGetResManager()-&gt;DestroyGroup(pResGroup);</pre></div><p>We should destroy a group whenever we no longer need those resources in memory (for example, a group containing resources for a particular level of a game only needs to be in memory when playing that level). It isn't strictly necessary to destroy all groups on shutdown however, as Marmalade will ensure everything that has been allocated will be freed whenever an application is terminated.</p></div><div class="section" title="The CIwResource class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>The CIwResource class</h2></div></div></div><p>We've already seen how the<a id="id208" class="indexterm"/> <code class="literal">CIwManaged</code> class can be used to allow us to easily create instances of our own classes by loading them out of a file. This functionality is improved further by the<a id="id209" class="indexterm"/> <code class="literal">CIwResource</code> class, which allows us to include our own classes into a resource group.</p><p>In the GROUP file example shown in the previous section, we specified the <code class="literal">levels.itx</code> file that may contain definitions of our own classes. If our custom classes used <code class="literal">CIwResource</code> as their base class (or of course another class that was in turn derived from <code class="literal">CIwResource</code>) then all of our resources can be added to the resource group, saving us the bother of keeping track of them ourselves.</p></div><div class="section" title="GROUP file serialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>GROUP file serialization</h2></div></div></div><p>It is great that we can load different types of resources so easily, but ultimately we probably do not want to deploy our application with a collection of easily recognized or editable files. There are <a id="id210" class="indexterm"/>
<a id="id211" class="indexterm"/>several reasons for this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading speed: Parsing a text file and converting it into a class is a slower operation than just loading in a ready parsed serialized version. It is also possible that we might need to do some sort of conversion on the original data to make it usable in the game, so if we can avoid doing this we will improve the loading time of our game.</li><li class="listitem" style="list-style-type: disc">To prevent hacking: If we ship a collection of text files and common file formats such as PNG files, we make it very easy for someone to hack and modify our game or make unauthorized use of the game's resources.</li><li class="listitem" style="list-style-type: disc">Smaller code size: If we are loading resource data that is already in a form that our game code can use directly, there is no need to include any code for converting the original data format into our own internal one. This makes the code size smaller and also helps guard against hackers a little more.</li><li class="listitem" style="list-style-type: disc">Deployment size: Text files are often much larger than their serialized binary equivalents, so shipping a binary version could reduce the size of our install package.</li></ul></div><p>Marmalade tackles all these issues by automatically converting every GROUP file we load into its binary equivalent using the serialization functionality provided by the <code class="literal">CIwManaged</code> class.</p><p>After the resource group has been fully loaded, the resource manager will call the <code class="literal">Serialise</code> method<a id="id212" class="indexterm"/> on every instance of every resource contained within the group, creating a file with <code class="literal">.bin</code> added to the original GROUP's filename. For example, the resources in a file called <code class="literal">images.group</code> would be serialized to a file called <code class="literal">images.group.bin</code>.</p><p>Once the serialized version of the GROUP file has been created, the resource manager destroys the resource group and then recreates it from the newly serialized version. This step is present as it makes catching problems, such as forgetting to serialize a member variable of a class, easier to spot.</p><p>There is a useful ICF setting that controls the resource building process. Simply add the following to the ICF file (refer back to <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Marmalade">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Marmalade</em></span>, for a discussion of what an ICF file is):</p><div class="informalexample"><pre class="programlisting">[RESMANAGER]
ResBuild=1</pre></div><p>When set to <code class="literal">1</code>, the<a id="id213" class="indexterm"/>
<a id="id214" class="indexterm"/> <code class="literal">ResBuild</code> setting will ensure that the resource manager always loads the GROUP file and serializes it. By setting it to <code class="literal">0</code>, the GROUP file parsing stage is skipped and instead any existing serialized version of the GROUP file will be loaded directly. This can be very useful during development, to both increase application startup time when no resources have been added or changed, and also to match more closely the loading process on the device.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>If you've made changes to the resources for your game but they aren't appearing when you run it, the <code class="literal">ResBuild</code> flag<a id="id215" class="indexterm"/> is always a good first port of call. It's amazing how easy it is to make a resource change and forget that you've disabled resource building!</p></div></div></div><div class="section" title="Resource handlers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Resource handlers</h2></div></div></div><p>There is one final part of the <a id="id216" class="indexterm"/> IwResManager API that is worth mentioning, and this is the concept of <a id="id217" class="indexterm"/> <span class="strong"><strong>resource handlers</strong></span>.</p><p>You may have wondered how the resource manager is able to load and process files of different types. It's great that we can just list a bunch of filenames in a GROUP file, but how exactly does a PNG format image file end up being loaded into a form that we can use for rendering? Resource handlers, of course!</p><p>A resource handler is a subclass of <code class="literal">CIwResHandler</code> that is used to load and process resources of a particular type, identified by one or more filename extensions.</p><p>When the text parser comes across a filename in the GROUP file, it looks at the file extension and then checks to see if a resource handler has been registered for that extension. If no suitable handler is found an error will be raised, otherwise the filename is passed to the relevant resource handler class that will then do whatever needs to be done to the file to make it usable in our code.</p><p>The entire resource manager system in Marmalade relies on resource handlers in order to work. GROUP files, ITX files, and bitmapped image files are all processed by classes derived from <code class="literal">CIwResHandler</code>, and we can create our own custom resource handlers should we want to make use of some other file type not supported by the core Marmalade SDK.</p><p>We will be <a id="id218" class="indexterm"/>
<a id="id219" class="indexterm"/>coming back to the subject of resource handlers when we talk about implementing sound in <a class="link" href="ch07.html" title="Chapter 7. Adding Sound and Video">Chapter 7</a>, <span class="emphasis"><em>Adding Sound and Video</em></span> of this book, since Marmalade does not have support for any sound file formats as part of the core SDK.</p></div></div>
<div class="section" title="Graphics APIs provided by the Marmalade SDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Graphics APIs provided by the Marmalade SDK</h1></div></div></div><p>Now that we are<a id="id220" class="indexterm"/>
<a id="id221" class="indexterm"/> familiar with resource management, we can get on to the more interesting task of showing a picture on the display.</p><p>Marmalade spoils us by providing several different ways in which we can draw graphics on the screen. The following sections provide an overview of the different options available to us.</p><div class="section" title="The s3eSurface API"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>The s3eSurface API</h2></div></div></div><p>The lowest level of display access is the<a id="id222" class="indexterm"/>
<a id="id223" class="indexterm"/> <code class="literal">s3eSurface</code> API. This provides access to the display by using a memory pointer that you can then use to directly read or alter pixels.</p><p>You can discover the width and height of the display in pixels and also the pitch, which is the number of bytes that you need to skip through memory to get to the next row of the display image.</p><p>The pitch is affected by the pixel format of the display (16-, 24-, or 32-bit displays are all possible) and often extra padding bytes are also added to allow each row to begin on a word-aligned memory address, which can improve display memory access times.</p><p>In practice this API is very rarely used, partly because it provides no support for drawing bitmapped images or lines, but mostly because it is incredibly slow on many modern devices due to the display being drawn by a <a id="id224" class="indexterm"/> <span class="strong"><strong>Graphics Processing Unit</strong></span> (<span class="strong"><strong>GPU</strong></span>), which may place restrictions on how and when this memory can be accessed by the CPU.</p><p>We will not be using this API anywhere in this book, but if you wish to use it there is nothing you have to add to your project as it is always available in any Marmalade project.</p></div><div class="section" title="The IwGL API and OpenGL ES"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>The IwGL API and OpenGL ES</h2></div></div></div><p>As mentioned above, most mobile devices available today contain a GPU that is used to speed up drawing operations and free the CPU for other tasks, such as updating the current state of a game. The standard API that has been adopted across most mobile platforms is OpenGL ES.</p><p>The OpenGL ES API<a id="id225" class="indexterm"/>
<a id="id226" class="indexterm"/> is a derivative of the <a id="id227" class="indexterm"/>OpenGL API, which has been used on many desktop systems for many years. OpenGL ES was conceived as a cut-down version of OpenGL designed for embedded systems (hence the ES part of the name!).</p><p>There are two main versions of the OpenGL ES. The 1.x standard is intended for devices that have fixed, function rendering pipelines, which means that while control is provided in how a 3D point is transformed to 2D coordinates, and how a polygon and its associated textures (if any) are rasterized to the screen, you are completely limited to the options provided by the hardware.</p><p>The 2.x standard of OpenGL ES is intended for GPU hardware where the act of both transforming 3D points and rasterizing the resultant polygons can be programmed by way of <a id="id228" class="indexterm"/>
<span class="strong"><strong>shaders</strong></span>. A shader is a short program that can be applied very quickly to either transform 3D points (a vertex shader) or work out the required color of a rendered pixel (a pixel or fragment shader).</p><p>In most cases a device supporting OpenGL ES 2.x will also support OpenGL ES 1.x, but the two cannot be mixed. When initializing OpenGL, you request one or the other of these interfaces to be created as the OpenGL context. The context is really nothing more than a big structure which stores all the information that OpenGL needs in order to operate, such as the current frame buffer, pixel blending mode, and available shaders.</p><p>So what <a id="id229" class="indexterm"/>
<a id="id230" class="indexterm"/>exactly is the IwGL API? Put simply, it is a wrapper for OpenGL ES that allows us to make normal OpenGL ES function calls directly, but it also provides some other very useful functionality:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">IwGL simplifies<a id="id231" class="indexterm"/> the process of initializing OpenGL ES to a single function call—<code class="literal">IwGLInit</code>. This function call will initialize the frame buffer and set up the OpenGL context so that it is ready and raring to go, with settings that should be optimal for the type of hardware available. Fine control over initialization is also provided to allow display and depth buffer formats to be chosen using settings made in the application's ICF file.</li><li class="listitem" style="list-style-type: disc">It provides context state caching functions, such as keeping a copy of all textures currently uploaded to OpenGL ES. In the event of your application being suspended (for example, by an incoming call) all its textures and other resources could be lost, and normally it would be your responsibility to reload everything you need. IwGL automatically takes care of all this for us.</li><li class="listitem" style="list-style-type: disc">Any OpenGL ES extension<a id="id232" class="indexterm"/> functions (extra functionality that a particular GPU may provide over and above the required base level of OpenGL ES) become mapped to functions that can be called directly and will not cause an error if that function is not actually supported. Normally you would need to specifically check if an extension exists before trying to call it.</li><li class="listitem" style="list-style-type: disc">It also provides a <a id="id233" class="indexterm"/>Virtual Resolution system<a id="id234" class="indexterm"/> that makes it easy to take existing code that was hardcoded to a particular resolution or screen orientation and make it run at a different resolution or orientation by resizing or rotating the rendered image.</li></ul></div><p>IwGL is an invaluable part of the Marmalade SDK when you are porting existing code written using OpenGL ES, as it allows you to take advantage of Marmalade's ability to deploy to multiple platforms without having to completely recode the entire project.</p><p>However, we won't be using IwGL in this book either. While there is nothing to stop us from using this API to develop a new project, it does mean we are limited to targeting only devices that feature GPUs (or support a software emulated version of OpenGL), and we still need to take care of things like loading textures ourselves.</p><p>You can use the IwGL API in your own project by adding <code class="literal">iwgl</code> to the <code class="literal">subprojects</code> section of the MKB file.</p></div><div class="section" title="The Iw2D API"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>The Iw2D API</h2></div></div></div><p>Given that this is a chapter about 2D graphics rendering, the Iw2D API<a id="id235" class="indexterm"/>
<a id="id236" class="indexterm"/> must surely be the way to go, right?</p><p>Well, yes and no. It certainly has a lot going<a id="id237" class="indexterm"/> for it, like the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It provides us with the ability to render flat shaded primitives such as lines, arcs, rectangles, and polygons, either as outlines or filled shapes.</li><li class="listitem" style="list-style-type: disc">It allows us to easily load bitmapped images and render them on screen and also apply scaling or rotational transforms to those images.</li><li class="listitem" style="list-style-type: disc">It makes it easy for us to draw text on screen that looks substantially better than the default debug font we've currently seen.</li><li class="listitem" style="list-style-type: disc">It provides certain optimizations that allow us to speed up rendering. For example, it can batch together several requests to draw a particular image into a single call, which can yield good performance increases on many devices.</li></ul></div><p>However, as you've probably already inferred from the tone of this section, we won't be using Iw2D in this book either.</p><p>If you are only <a id="id238" class="indexterm"/>interested in rendering 2D graphics, Iw2D may well be perfectly <a id="id239" class="indexterm"/>adequate for your needs, but if you ever want to make the jump to 3D graphics you will eventually find that the Iw2D API just doesn't do everything you need, such as rendering textured polygons of any shape, not just rectangular.</p><p>Since we will be tackling 3D graphics later in this very book, it makes sense for us to begin our journey into rendering with Marmalade by using 3D graphics itself.</p><p>If you want to use this API in your own project, just add <code class="literal">iw2d</code> to the <code class="literal">subprojects</code> section of the MKB file.</p></div><div class="section" title="The IwGx API"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>The IwGx API</h2></div></div></div><p>Finally we come to the API that we will be using in this book; in fact we have already used a very small part of it in the creation of our "Hello World" project. Ladies and gentlemen, I give you the<a id="id240" class="indexterm"/>
<a id="id241" class="indexterm"/> IwGx API!</p><p>This API is extremely flexible and boasts the following functionalities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It supports <a id="id242" class="indexterm"/>both hardware and software rendering pipelines, so your code can potentially run unaltered on modern hardware featuring a GPU yet still fall back to a software-based renderer for older or less capable hardware. You can even mix the two pipelines, so you could use the GPU for rasterization but still use the CPU for transform and lighting operations.</li><li class="listitem" style="list-style-type: disc">It takes care of the nitty-gritty for us, such as initializing the display and texture management, in a similar way to the IwGL API.</li><li class="listitem" style="list-style-type: disc">It allows us to use features such as texture mapping and flat or gouraud shading on arbitrary polygons.</li><li class="listitem" style="list-style-type: disc">It provides some debugging functionality, such as simple text rendering (as in our "Hello World" project) and rendering shapes like rectangles and circles.</li><li class="listitem" style="list-style-type: disc">It makes targeting OpenGL ES 2.x devices much easier, as it provides the necessary shader programs to emulate the fixed function pipeline of Open GL ES 1.x while still allowing us to provide our own custom shaders when <a id="id243" class="indexterm"/>we want to.</li></ul></div><p>By using IwGx for rendering 2D graphics from the start, we will find it a whole lot easier to move on to drawing 3D <a id="id244" class="indexterm"/>polygons later, as the techniques involved are incredibly similar.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>With Version 6.1 of Marmalade, the IwGx API underwent a little modernization and standardized using floating point values for specifying polygon information. Prior to this version, some information (for example, texture UV values) was specified in fixed point integer formats. There was also a software-based rendering engine for targeting old devices with no GPU hardware. If you have existing code that still needs the old fixed point way of doing things, you can revert back by adding <code class="literal">define IW_USE_LEGACY_MODULES</code> to the project MKB file.</p></div></div><p>It should come as no surprise by now that we can use IwGx in our project simply by adding <code class="literal">iwgx</code> to the <code class="literal">subprojects</code> section of the MKB file.</p></div></div>
<div class="section" title="Using IwGx to render 2D graphics"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Using IwGx to render 2D graphics</h1></div></div></div><p>Now that we know<a id="id245" class="indexterm"/>
<a id="id246" class="indexterm"/> how to load resources, we can get on with the fun stuff. We're going to look at how we can draw a bitmapped image on screen.</p><div class="section" title="IwGx initialization and termination"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>IwGx initialization and termination</h2></div></div></div><p>We've already seen<a id="id247" class="indexterm"/> how<a id="id248" class="indexterm"/> to do this in the "Hello World" project of <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Marmalade">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Marmalade</em></span>. We just call <code class="literal">IwGxInit</code> to set up IwGx at the start of our program and <code class="literal">IwGxTerminate</code> to close it down again at the end.</p></div><div class="section" title="Rendering a polygon"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Rendering a polygon</h2></div></div></div><p>In IwGx, the most <a id="id249" class="indexterm"/>
<a id="id250" class="indexterm"/>commonly used polygon types are lines, triangles, and quads (basically two triangles that share a common edge).</p><p>Also supported are sprites, which are always rectangular in shape and do not allow any scaling of textures, and n-polys, which can contain up to 63 vertices.</p><p>Sprites are rarely used since triangles and quads are more flexible, though they can be faster to draw especially in software rendering mode. The n-poly can also be faster to draw for the software renderer than a series of triangles, but they are generally best avoided since they need to be converted into triangles on the fly in order to be drawn using hardware rendering.</p><p>To render a polygon on screen, we at least need to specify where we want it to appear on screen and what color we want it to be in. Additionally, we might want to draw the polygon using a bitmapped <a id="id251" class="indexterm"/>image. The following sections show how we can provide this information.</p><div class="section" title="Materials and textures"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Materials and textures</h3></div></div></div><p>First we let <a id="id252" class="indexterm"/>IwGx know what color (or indeed colors) and image we want <a id="id253" class="indexterm"/>applied to our polygon. We do this by specifying the material we want to use, which is an instance of the <code class="literal">CIwMaterial</code> class that groups together this information. To set the material we want to use, we must provide IwGx with a pointer to the relevant <code class="literal">CIwMaterial</code> instance using the following function call:</p><div class="informalexample"><pre class="programlisting">IwGxSetMaterial(pMaterial);</pre></div><p>If we are drawing a polygon with no image applied to it, then the very minimum information the material will need to provide is the color we want to use.</p><p>A material actually contains four different colors that, if you are at all familiar with 3D graphics rendering, you will probably recognize. They are the ambient, diffuse, emissive, and specular colors. For 2D rendering purposes, it is only the ambient color that we are concerned with. We'll look into the others when we move on to 3D rendering in <a class="link" href="ch04.html" title="Chapter 4. 3D Graphics Rendering">Chapter 4</a>, <span class="emphasis"><em>3D Graphics Rendering</em></span>.</p><p>The material<a id="id254" class="indexterm"/>
<a id="id255" class="indexterm"/> also specifies the texture we want to apply. A texture specifies a bitmapped image that we want to apply to our polygon, and is represented in Marmalade by the <code class="literal">CIwTexture</code> class.</p><p>The <code class="literal">CIwTexture</code> class<a id="id256" class="indexterm"/> is actually a wrapper for the <code class="literal">CIwImage</code> class that actually stores the pixel information for an image. <code class="literal">CIwTexture</code> adds functionality to control how the image is actually rendered, with support for enabling and disabling features such as bilinear filtering and mipmapping.</p><p>Materials also provide control over other polygon rendering features, such as whether the polygon is rendered flat or gouraud shaded, and how it should be blended with the current screen contents when it is drawn.</p><p>Materials can either be created in code or they can be instanced by the resource manager. The following sections illustrate this.</p><div class="section" title="Creating materials in code"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>Creating materials in code</h4></div></div></div><p>Creating a material<a id="id257" class="indexterm"/>
<a id="id258" class="indexterm"/> in code requires little more than making a new instance of <code class="literal">CIwMaterial</code> and using the available methods to set the color, textures, and other settings. For example, to create a material that will render bright red, semi-transparent polygons we could use the following code:</p><div class="informalexample"><pre class="programlisting">CIwMaterial* lpRedMaterial = new CIwMaterial;
lpRedMaterial-&gt;SetColAmbient(255, 0, 0, 128);
lpRedMaterial-&gt;SetAlphaMode(CIwMaterial::ALPHA_BLEND);</pre></div><p>Note that Marmalade will raise an assert message if you try to create a local <code class="literal">CIwMaterial</code> instance on the program stack. This happens because rendering does not happen the moment you make a drawing function call, so by the time rendering does occur, the material data will likely have been trashed by other functions reusing the same area of stack space.</p></div><div class="section" title="Creating materials using an MTL file"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec06"/>Creating materials using an MTL file</h4></div></div></div><p>While creating<a id="id259" class="indexterm"/>
<a id="id260" class="indexterm"/> materials in code is simple enough, there is an easier way, especially when it comes to specifying materials with textures. This involves yet another use of our friend, the ITX file.</p><p>A material file has the extension <code class="literal">.mtl</code> <a id="id261" class="indexterm"/>and again uses the same formatting rules as an ITX file. We can create any number of <code class="literal">CIwMaterial</code> instances in an MTL file and initialize them with the required colors, textures, and other settings.</p><p>As a bonus, any texture we refer to in the MTL file will also be loaded automatically, meaning we don't have to list it separately in a GROUP file. In order for this to work, all the source image files must reside in a subdirectory named <code class="literal">textures</code>, which is located in the same directory as the MTL file, or alternatively they must already have been loaded into memory either from another GROUP file or in the same GROUP file prior to referencing the MTL file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Marmalade natively supports the PNG, TGA, GIF, and BMP image file formats. If you want to load any other type of bitmap, you will need to provide your own custom resource handler to do so.</p></div></div><p>Here is an example of what an MTL file might look like:</p><div class="informalexample"><pre class="programlisting">CIwMaterial
{
  name      "red"
  colAmbient  { 255 0 0 128 }
  alphaMode    BLEND
}

CIwMaterial
{
  name      "grid"
  colAmbient  { 128 128 128 128 }
  texture0    "grid.png"
  alphaMode    ADD
  shadeMode    FLAT
  filtering    false
}</pre></div><p>This example generates a semi-transparent red material equivalent to that created in the previous section, and also a material using a texture named <code class="literal">grid.png</code>, which is drawn flat shaded with additive transparency at half the original image brightness and without bilinear filtering.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>You may have noticed that the image is specified using an attribute called <code class="literal">texture0</code>. Marmalade materials can actually be assigned two textures that can be blended together when rendering a polygon and they are referred to as <code class="literal">texture0</code> and <code class="literal">texture1</code>. In this book we will only be concerned with single texture materials.</p></div></div><p>There are <a id="id262" class="indexterm"/>
<a id="id263" class="indexterm"/>far too many attribute names to list here, so for a complete list take a look at the Marmalade documentation page for the <code class="literal">CIwMaterial</code> class. This page lists all of them.</p><p>To make these materials available in our code, we just need to reference the MTL file inside a GROUP file that we are loading. We can then get hold of the materials by searching for them by name using the resource manager functions described earlier in this chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>It is recommended that when materials are created using an MTL file, you do not modify any of their settings using the methods in the<a id="id264" class="indexterm"/> <code class="literal">CIwMaterial</code> class. Instead, make a copy of the material using the<a id="id265" class="indexterm"/> <code class="literal">CIwMaterial::Copy</code> method. While it is possible to do so, problems can occur if the same material is used to render several different things, since rendering does not occur as soon as a drawing function call is made. The end result is therefore unpredictable as it would depend on how the <code class="literal">CIwMaterial</code> happens to be configured when rendering finally occurs.</p></div></div></div></div><div class="section" title="Vertex streams"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Vertex streams</h3></div></div></div><p>In order to display <a id="id266" class="indexterm"/>a polygon on screen, we need to specify a list of screen coordinates that define the corner points. Since we are only rendering in 2D at the moment, each coordinate is specified as a <code class="literal">CIwSVec2</code> instance, which is a vector class defined in another Marmalade API called <a id="id267" class="indexterm"/> <span class="strong"><strong>IwGeom</strong></span>. Any list of data items used when rendering polygons, be it vertices, colors, or whatever, is often referred to as a <a id="id268" class="indexterm"/>
<span class="strong"><strong>stream</strong></span>, so a list of vertices is called a <a id="id269" class="indexterm"/>
<span class="strong"><strong>vertex stream</strong></span>.</p><p>While we can specify this API to be part of our project by adding <code class="literal">iwgeom</code> to the <code class="literal">subprojects</code> section of the MKB file and calling <code class="literal">IwGeomInit</code> and <code class="literal">IwGeomTerminate</code>, there isn't actually a need to, since IwGx relies on this API itself.</p><p>The <code class="literal">CIwSVec2</code> class defines a two-component vector using signed 16-bit integers, so it is perfect for specifying screen coordinates.</p><p>The default screen coordinate system in IwGx places the origin at the top-left corner of the screen, with the x component increasing horizontally to the right and the y component increasing vertically downwards. It is possible to change the position of the origin, however, by passing a <code class="literal">CIwSVec2</code> instance containing the desired position of the origin to the function <code class="literal">IwGxSetScreenSpaceOrg</code>.</p><p>The following diagram illustrates how we could specify the coordinates for a triangle on a standard iPhone resolution screen (320 x 480 pixels). The top left of the screen is the origin and has a coordinate position of <span class="strong"><strong>(0,0)</strong></span>, while the bottom-right corner has a position of <span class="strong"><strong>(320,480)</strong></span>.</p><div class="mediaobject"><img src="graphics/3363_02_01.jpg" alt="Vertex streams"/></div><p>To render this <a id="id270" class="indexterm"/>
<a id="id271" class="indexterm"/>triangle all we have to do is fill in an array of <code class="literal">CIwSVec2</code> with the coordinates and submit them to IwGx, as follows:</p><div class="informalexample"><pre class="programlisting">CIwSVec2* v = new CIwSVec2[3];
v[0].x = 160;    v[0].y = 120;
v[1].x = 20;     v[1].y = 360;
v[2].x = 300;    v[2].y = 360;
IwGxSetVertStreamScreenSpace(v, 3);</pre></div><p>The <a id="id272" class="indexterm"/>function call, <code class="literal">IwGxSetVertStreamScreenSpace</code>, allows us to specify a list of screen space (that is, pixel) coordinates we want to use for rendering, but we must also explicitly state how many vertices we are submitting. In the case of our triangle, this is three.</p><p>It is also possible to specify our coordinates using sub-pixel positioning with the function call<a id="id273" class="indexterm"/> <code class="literal">IwGxSetVertStreamScreenSpaceSubPixel</code>. It may be getting a bit on the long side to type, but using sub-pixel positioning does provide the advantage of smoother movement on <a id="id274" class="indexterm"/>
<a id="id275" class="indexterm"/>screen, as we are no longer limited to only moving things around the screen in terms of whole pixels.</p><p>Using sub-pixel coordinates can also improve the quality of the final rendered image, as slow moving objects won't appear to jump between pixel positions if we are rendering using bilinear filtering.</p><p>IwGx only supports eight sub-pixel positions per pixel; so to convert our coordinates to use sub-pixel positioning, all we need to do is multiply the screen coordinates by eight or use the bitwise shift operator to shift left by three places.</p></div><div class="section" title="Color streams"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Color streams</h3></div></div></div><p>If we want to <a id="id276" class="indexterm"/>
<a id="id277" class="indexterm"/>draw a polygon using flat shading, so that every pixel rendered is the same color, we can just set the ambient color of our material and our work is done.</p><p>However, if we want to render a polygon using gouraud shading, we need to specify a color to be used at each vertex. This can't be done with a material, so we need to override the material's color information by providing our own color stream.</p><p>We do this by creating an array of <code class="literal">CIwColour</code> objects, which is Marmalade's chosen method of representing a color. This class has four public member variables of type <code class="literal">uint8</code> (an unsigned byte) called <code class="literal">r</code>, <code class="literal">g</code>, <code class="literal">b</code>, and <code class="literal">a</code>, which (probably not surprisingly) represent the red, green, blue, and alpha values of a color.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Note that because Marmalade was developed in the UK, all instances of the word <span class="emphasis"><em>color</em></span> in the API will actually be spelled <span class="emphasis"><em>colour</em></span>.</p></div></div><p>
<code class="literal">CIwColour</code> <a id="id278" class="indexterm"/>also provide several methods to make setting and manipulating colors easier.</p><p>Returning to the triangle defined in the earlier diagram, if we wanted to color the top of it red, the bottom-right corner green, and the bottom-left corner blue, we can use the following code:</p><div class="informalexample"><pre class="programlisting">CIwColour* c = new CIwColour[3];
c[0].Set(255, 0, 0, 255);
c[1].Set(0 255, 0, 255);
c[2].Set(0, 0, 255, 255);
IwGxSetColStream(c);</pre></div><p>Note <a id="id279" class="indexterm"/>
<a id="id280" class="indexterm"/>that <code class="literal">IwGxSetColStream</code> does not require us to specify the number of colors in our stream. This is because IwGx expects to find the same number of colors as there are vertices. If we do not want to specify a color stream, we can just pass <code class="literal">NULL</code> into the <code class="literal">IwGxSetColStream</code> function <a id="id281" class="indexterm"/>and the selected material's colors will be used instead.</p></div><div class="section" title="UV streams"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec21"/>UV streams</h3></div></div></div><p>When rendering<a id="id282" class="indexterm"/> a polygon with a texture, we need to somehow indicate how that texture should be mapped to the polygon. We do this by specifying a <a id="id283" class="indexterm"/>UV stream that allows us to state which part of the texture should appear at each vertex. The part of the texture required for each rendered pixel can then be worked out by the rendering engine by interpolating the UV values across the surface of the polygon.</p><p>In IwGx, UV coordinates are specified using floating point numbers. An individual UV value is often written as (u, v) and is represented in IwGx using the <code class="literal">CIwFVec2</code> class, which is a floating point equivalent of <code class="literal">CIwSVec2</code> that we came across earlier. The x component of the vector represents <span class="strong"><strong>u</strong></span>, and the y component represents <span class="strong"><strong>v</strong></span>.</p><p>UV values are mapped to a texture so that <span class="strong"><strong>(0.0, 0.0)</strong></span> is the top left of the image and <span class="strong"><strong>(1.0, 1.0)</strong></span> is the bottom-right corner. We can repeatedly tile a texture up to a maximum of eight times across our polygon by using values larger than one.</p><div class="mediaobject"><img src="graphics/3363_02_02.jpg" alt="UV streams"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Prior to Marmalade version 6.1, UV values were given as 16-bit signed integers using a 12-bit fixed point representation. The value 4096 is equivalent to 1.0, 8192 is equivalent to 2.0, and 2048 is equivalent to 0.5. The IwGeom API <a id="id284" class="indexterm"/>provides us with the define <code class="literal">IW_GEOM_ONE</code>, which we can use to avoid having nasty-looking magic numbers throughout our code. This functionality can still be used by reverting to the legacy version of the IwGx API, as detailed earlier in this chapter.</p></div></div><p>By mapping <a id="id285" class="indexterm"/>
<a id="id286" class="indexterm"/>UV values in this way, we make them independent of the actual size of the texture image. If we change the size of the image for any reason, it won't mess up rendering as our UV values do not need to change.</p><p>As with vertex streams, all we have to do to specify a set of UV values is allocate an array of <code class="literal">CIwSVec2</code>, populate the array, and submit it to IwGx. We don't need to specify the number of UV values we are submitting, as IwGx expects to see the same number of UVs as there are vertices. Here is some sample code that we might want to use to apply a texture to a triangle:</p><div class="informalexample"><pre class="programlisting">CIwSVec2* uv = new CIwSVec2[3];
uv[0].x = IW_GEOM_ONE / 2;    uv[0].y = 0;
uv[1].x = 0;                  uv[1].y = IW_GEOM_ONE;
uv[2].x = IW_GEOM_ONE;        uv[2].y = IW_GEOM_ONE;
IwGxSetUVStream(uv, 0);</pre></div><p>The second <a id="id287" class="indexterm"/>
<a id="id288" class="indexterm"/>parameter of <code class="literal">IwGxSetUVStream</code> indicates which texture the UV values apply to. If the material we are using only has a single texture, we can just leave this parameter out entirely as it will default to <code class="literal">0</code>, but if the material does have a second texture, we need to supply a UV stream to be used with it by changing the second parameter of <code class="literal">IwGxSetUVStream</code> to 1. This UV stream could be the same as the stream for the first texture or it could be a completely different set of UV values.</p><p>If our material does not have a texture applied to it, there is no need to set the UV stream to <code class="literal">NULL</code> as it will be ignored completely.</p></div><div class="section" title="Drawing a polygon"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Drawing a polygon</h3></div></div></div><p>We've now seen how<a id="id289" class="indexterm"/> to set just about all the information we need to specify how we want our polygon to appear, so we can finally instruct IwGx to draw it. To do so, we need to let IwGx know how our various input streams should be interpreted by using the following function call:</p><div class="informalexample"><pre class="programlisting">IwGxDrawPrims(polygon_type, indices, num_indices);</pre></div><p>The <code class="literal">polygon_type</code> parameter<a id="id290" class="indexterm"/> indicates whether we are drawing triangles, quads, lines, sprites, or n-polys, while the <code class="literal">indices</code> parameter is an array of <code class="literal">uint16</code> values showing the order in which the elements of our input streams should be accessed. This is called an <a id="id291" class="indexterm"/>
<span class="strong"><strong>index stream</strong></span>. The <code class="literal">num_indices</code> parameter is just a count of how many elements are in the <code class="literal">indices</code> array.</p><p>The following diagram shows the types of polygons supported by IwGx. Note that it is possible to draw more than one polygon at a time by providing longer streams of data. This is something we should try to do as much as possible, since it prevents the GPU from idling while it is waiting to be supplied with new polygon information.</p><div class="mediaobject"><img src="graphics/3363_02_03.jpg" alt="Drawing a polygon"/></div><p>The numbers labeling<a id="id292" class="indexterm"/> the vertices in the diagram correspond to the elements of the index stream. When rendering, the <code class="literal">indices</code> array is traversed in the order shown for each polygon type, and the values it contains indicate which element of the various input streams should be used to render each vertex.</p><p>To draw the triangle we've been building up to, we can use the following code snippet:</p><div class="informalexample"><pre class="programlisting">uint16* indices = new uint16[3];
indices[0] = 0;  indices[1] = 1;  indices[2] = 2;
IwGxDrawPrims(IW_GX_TRI_STRIP, indices, 3);</pre></div><p>We could simplify this a little more as the index stream isn't actually necessary in this instance since our input streams are accessed one element at a time in the order they occur in the stream, so we can just specify <code class="literal">NULL</code> for the <code class="literal">indices</code> parameter like this:</p><div class="informalexample"><pre class="programlisting">IwGxDrawPrims(IW_GX_TRI_STRIP, NULL, 3);</pre></div><p>When creating the <a id="id293" class="indexterm"/>index stream there is one other point to bear in mind, which is the order in which we supply our vertices. Because IwGx can also be used to render 3D polygons on screen, it supports back face culling, which prevents any polygon that is facing away from the viewer from being rendered.</p><p>How is a polygon classified as facing toward or away from the viewer? If we label each vertex of a polygon with an incrementing number, starting with zero for the first vertex and following around the edges of the polygon from vertex to vertex, then a polygon is facing the viewer if its vertices form an anti-clockwise pattern when rendered on screen and considered in ascending numerical order. The order the vertices are supplied in is called the <a id="id294" class="indexterm"/>
<span class="strong"><strong>winding order</strong></span>, and the following diagram shows this more clearly:</p><div class="mediaobject"><img src="graphics/3363_02_04.jpg" alt="Drawing a polygon"/></div><p>Putting the vertices in the correct order is not the only way to solve this problem, but it is worth getting in the habit of ordering the vertices in this way for when we progress to rendering 3D polygons. We can disable or reverse the back face culling operation on a per material basis by calling the<a id="id295" class="indexterm"/> <code class="literal">CIwMaterial::SetCullMode</code> method with one of the following enumeration values: <code class="literal">CULL_FRONT</code>, <code class="literal">CULL_BACK</code>, or <code class="literal">CULL_NONE</code>. The default is <code class="literal">CULL_BACK</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>If you are trying to draw a polygon and you just can't get it to appear, the first thing to do is double-check the winding order of your vertices. They may just be getting culled by the GPU and not being drawn!</p></div></div><p>Our polygon <a id="id296" class="indexterm"/>information has now been submitted for rendering; but we won't see it appear on screen just yet.</p></div><div class="section" title="Displaying the rendered image"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec23"/>Displaying the rendered image</h3></div></div></div><p>The final step in <a id="id297" class="indexterm"/>making something appear on screen is to flush all the drawing requests to the screen, and then display the final image.</p><p>IwGx automatically provides us with a double-buffered display setup. All this means is we do all our rendering to an off-screen buffer and then switch to displaying this buffer when all the drawing is complete. If we did not do this, we would likely see an incomplete, flickering screen display as our graphics could be displayed in an incomplete state if we drew straight to the visible display.</p><p>To complete the cycle of drawing, all we have to do is add the following two lines of code:</p><div class="informalexample"><pre class="programlisting">IwGxFlush();
IwGxSwapBuffers();</pre></div><p>That's it! We've drawn our first polygon!</p></div></div></div>
<div class="section" title="Example code"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Example code</h1></div></div></div><p>If you download the code package for this chapter, you will find three projects that illustrate the use of the Marmalade functionality we have learnt about in this chapter.</p><div class="section" title="The ITX project"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>The ITX project</h2></div></div></div><p>The ITX project<a id="id298" class="indexterm"/> demonstrates use of the ITX text parser and the<a id="id299" class="indexterm"/> <code class="literal">CIwManaged</code> class.</p><p>The example first creates custom instances of our own class by parsing an ITX file, then serializes those instances out to a file. All the instances are then destroyed and re-created by loading the serialized file back in.</p><p>The example also <a id="id300" class="indexterm"/>demonstrates the use of two more parts of the IwUtil API, which we haven't covered in depth, but are very useful to know about. First is the class <code class="literal">CIwManagedList</code>, which is used for maintaining a list of objects derived from <code class="literal">CIwManaged</code>, and the second is the <code class="literal">IwTrace</code> system that allows us to log information to a file (and to the standard output) in order to aid debugging.</p></div><div class="section" title="The Graphics2D project"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>The Graphics2D project</h2></div></div></div><p>The Graphics2D project<a id="id301" class="indexterm"/> pulls everything we've learnt in this chapter together to render a rotating, textured polygon on screen. The following screenshot depicts this project in action:</p><div class="mediaobject"><img src="graphics/3363_02_05.jpg" alt="The Graphics2D project"/></div></div><div class="section" title="The Skiing project"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>The Skiing project</h2></div></div></div><p>Throughout this book, we <a id="id302" class="indexterm"/>will be building up an entire game example that puts the things we have learnt into real practice. The game in question will be a simple version of that old favorite, the slalom skiing game, where the player guides a skier down a mountain, attempting to pass through as many flags as possible while avoiding obstacles.</p><p>In this chapter we kick things off by having a skier graphic at the top of the screen that moves from side to side, while some random trees scroll up the edges of the screen.</p><p>The following screenshot<a id="id303" class="indexterm"/> shows the project as it currently stands:</p><div class="mediaobject"><img src="graphics/3363_02_06.jpg" alt="The Skiing project"/></div><p>While this book is not intended to teach you the ins and outs of programming a game (it's assumed you already know how to do that) it might still be worthwhile providing a few notes on how the sample game is put together.</p><div class="section" title="The GameObject class"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec24"/>The GameObject class</h3></div></div></div><p>The<a id="id304" class="indexterm"/> <code class="literal">GameObject</code> class is the base class for anything that makes up a part of the game world. Currently there are two classes which inherit from this class, <code class="literal">Skier</code> and <code class="literal">Tree</code>. No prizes for guessing what they represent!</p><p>
<code class="literal">GameObject</code> provides two virtual methods that can be overridden by child classes to implement the behavior of an in-game object. The<a id="id305" class="indexterm"/> <code class="literal">GameObject::Update</code> method provides support for <a id="id306" class="indexterm"/>changing the position of an object by applying a velocity to it, while the <code class="literal">GameObject::Render</code> method<a id="id307" class="indexterm"/> allows a size and a material to be defined, and it will draw a textured polygon at the object's current position using this information.</p></div><div class="section" title="The ModeManager and Mode classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec25"/>The ModeManager and Mode classes</h3></div></div></div><p>The main flow of most games is often represented internally as some kind of state machine. Even the simplest game will normally have at least a title screen and the main game screen, but add to this things such as pause modes, high score tables, options screen, and the like, and you soon end up with a large number of states that your game could be in.</p><p>Often these states are completely mutually exclusive, but sometimes we might want several states active, or at least visible, at the same time. For example, quite often the pause mode will appear on top of the game screen. Only the pause mode will be accepting input, but both it and the game screen need to be drawn.</p><p>One approach (and this is purely my own personal preference; your own may vary wildly) is to create a separate class which handles a single part of the game. For want of a better word, I represent these using a base class called <code class="literal">Mode</code>.</p><p>The <code class="literal">Mode</code> class <a id="id308" class="indexterm"/>is similar to the <code class="literal">GameObject</code> class<a id="id309" class="indexterm"/> in that it provides two virtual methods called <code class="literal">Update</code> and <code class="literal">Render</code>. A mode can be made active, which means its <code class="literal">Update</code> method<a id="id310" class="indexterm"/> will be executed in each frame, and it can be visible, which means its <code class="literal">Render</code> method will be called. These two states are completely independent of each other.</p><p>When a <code class="literal">Mode</code> instance is created, it is automatically added to a list maintained by a singleton class called <code class="literal">ModeManager</code>. The<a id="id311" class="indexterm"/> <code class="literal">ModeManager</code> class uses the list of <code class="literal">Mode</code> instances to update all active modes and render all visible modes on each iteration of the main game loop.</p><p>Currently the project only consists of a single mode called <code class="literal">ModeGame</code>, which is responsible for loading and freeing the required resources and also initializing, updating, and rendering all the <code class="literal">GameObject</code>s that make up the game world.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter we've learnt about Marmalade's powerful resource management system. We know how to use it at a simple level to just load and release resources such as bitmapped images or our own custom classes; we also have a good idea of how the resource management system is put together, and how we can extend it with our own functionality.</p><p>We've also covered the options available for rendering on-screen images, and seen how to use one of these, IwGx, to render polygons on the screen.</p><p>In the next chapter we'll be learning how we can start using the various input options available on modern mobile devices, since the whole point of games is that they are interactive.</p></div></body></html>