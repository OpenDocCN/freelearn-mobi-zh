<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Beautifying Our Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Beautifying Our Game</h1></div></div></div><p>
<span class="emphasis"><em>In the previous chapter, we learned about cross-device compatibility and what we need to do if we want to target iPhones and iPads simultaneously. We then set up the base for our game. In this chapter, we will begin to add animations to our game.</em></span>
</p><div class="section" title="Working with tweens"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec64"/>Working with tweens</h1></div></div></div><p>Let's <a id="id203" class="indexterm"/>say we want to move our ship to an edge of the screen. How would we go about achieving this? The following are two options to achieve this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move the ship each frame in the direction we want it to move</li><li class="listitem" style="list-style-type: disc">Define two states for our ship and let the processor calculate all the required steps for animation</li></ul></div><p>At first glance, the second option seems to be more attractive. We first need to know the initial position of the ship and the position where the ship should be after the animation is complete. Sparrow provides the <code class="literal">SPTween</code> class, which does exactly this.</p><p>We take two values, also called key frames, and interpolate all values in between. The name "tween" comes from its in-between states.</p><p>While in this example, we are talking about moving a position explicitly, in general, a tween is not confined to animating the position of an entity, but could be used to animate its color or any of its other properties.</p><p>In Sparrow, specifically, any numeric property of an object can be animated. So every property that is available on an <code class="literal">SPDisplayObject</code> is available for the <code class="literal">SPTween</code> class and its animation abilities.</p><p>If we want to implement a fade-out or fade-in effect, all we need to do is to animate the <code class="literal">alpha</code> property<a id="id204" class="indexterm"/> of a display object from its maximum to its minimum value or vice versa.</p><p>Let's try this by actually moving the pirate ship.</p></div></div>
<div class="section" title="Time for action &#x2013; moving the pirate ship"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec65"/>Time for action – moving the pirate ship</h1></div></div></div><p>Let's follow <a id="id205" class="indexterm"/>these steps to move the ship:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open our game project file if it's not already open.</li><li class="listitem">Add an instance variable called <code class="literal">_pirateShip</code> of the type <code class="literal">SPImage</code>, as shown in following line of code:<div class="informalexample"><pre class="programlisting">SPImage* _pirateShip;</pre></div></li><li class="listitem">Update the references from <code class="literal">pirateShip</code> to <code class="literal">_pirateShip</code> in <code class="literal">Battlefield.m</code>:<div class="informalexample"><pre class="programlisting">_pirateShip = [SPImage imageWithTexture:[Assets texture:@"ship_pirate.png"]];
_pirateShip.x = (Sparrow.stage.width - _pirateShip.width) / 2;
_pirateShip.y = (Sparrow.stage.height - _pirateShip.height) / 2;</pre></div></li><li class="listitem">Add a method called <code class="literal">onBackgroundTouch</code> in the <code class="literal">Battlefield.m</code> file, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">-(void) onBackgroundTouch: (SPTouchEvent*) event</pre></div></li><li class="listitem">Within this method, get the touch itself:<div class="informalexample"><pre class="programlisting">SPTouch* touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];</pre></div></li><li class="listitem">Complete<a id="id206" class="indexterm"/> the <code class="literal">onBackgroundTouch</code> method with the following piece of code:<div class="informalexample"><pre class="programlisting">if (touch) {
  SPTween* tweenX = [SPTween tweenWithTarget:_pirateShip time:2.0f];
  SPTween* tweenY = [SPTween tweenWithTarget:_pirateShip time:2.0f];
  
  
  [tweenX animateProperty:@"x" targetValue:touch.globalX - (_pirateShip.width / 2)];
  [tweenY animateProperty:@"y" targetValue:touch.globalY - (_pirateShip.height / 2)];
  
  [Sparrow.juggler addObject:tweenX];
  [Sparrow.juggler addObject:tweenY];
}</pre></div></li><li class="listitem">Register the event listener to the background image as shown in the following line of code:<div class="informalexample"><pre class="programlisting">[background addEventListener:@selector(onBackgroundTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];</pre></div></li><li class="listitem">Switch to the <code class="literal">Game.m</code> file.</li><li class="listitem">Update the scene director to show the battlefield scene.</li><li class="listitem">Run the example and you will get the following output:<div class="mediaobject"><img src="graphics/1509OS_05_01.jpg" alt="Time for action – moving the pirate ship"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In <a id="id207" class="indexterm"/>step 1, we opened our Xcode template from where we left off in the previous chapter. In order to use a pirate ship in the entirety of our battlefield source file, we should move it into an instance variable for the <code class="literal">Battlefield</code> class, which is what we did in step 2.</p><p>Now, we need to update the references to the pirate ship which was the task for step 3.</p><p>After this, we defined the method where we declared what happens if we were to touch the background (in our case, the water on the screen). In step 5, we got the current touch.</p><p>In step 6, we implemented the actual tween. As soon as we were sure that we have the current touch object (as in not a false value such as <code class="literal">nil</code>), we began to animate the pirate ship.</p><p>We created two tweens: the first for the <code class="literal">x</code> position of the pirate ship and the second one for its <code class="literal">y</code> position. As long as the target and the duration of tween are the same, we could actually use a single tween, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (touch) {
  SPTween* tween = [SPTween tweenWithTarget:_pirateShip time:2.0f]; 
  
  [tween animateProperty:@"x" targetValue:touch.globalX - (_pirateShip.width / 2)];
  [tween animateProperty:@"y" targetValue:touch.globalY - (_pirateShip.height / 2)];
  
  [Sparrow.juggler addObject:tween];
}</pre></div><p>Since we are going to change these properties in a bit, we better leave it at being two separate tweens.</p><p>A tween always needs a target which we are setting to the <code class="literal">_pirateShip</code> instance variable. Another value we must specify is how long the tween will animate, which is set by<a id="id208" class="indexterm"/> the <code class="literal">time</code> parameter. The amount of time the tween takes is available as a property on an instance of <code class="literal">SPTween</code>. The <code class="literal">time</code> parameter is of the type <code class="literal">double</code> and is measured in seconds.</p><p>The <code class="literal">tweenX</code> instance is being bound to the <code class="literal">x</code> property. We need to access the property through its <code class="literal">NSString</code> identifier. So, if we want to animate the <code class="literal">alpha</code> property, we would need to access it through <code class="literal">@"alpha"</code>. Internally, Sparrow uses the runtime type information (also referred to as reflection) to change properties at runtime.</p><p>We set <a id="id209" class="indexterm"/>the target value to the current touch position, the x coordinate of that touch to be precise. Now, if we touch the background, the ship's top-left corner would be at the touch position. To feel more natural, we should change it so that the ship is at the center of the touch. This is why we subtracted half of the ship's width from the touch position.</p><p>Implicitly, the initial value is automatically set to the current value of the property, which is to be animated.</p><p>Then, we did the same for <code class="literal">tweenY</code> and the y positions, respectively.</p><p>To actually animate the properties, we added the tweens to an object called the juggler, which is available through <code class="literal">Sparrow.juggler</code>. We will take a look at how jugglers work later in the chapter.</p><p>For the touch event to fire, we registered the <code class="literal">onBackgroundTouch</code> method with the background <a id="id210" class="indexterm"/>image.</p><p>In step 8, we opened the <code class="literal">Game.m</code> file and updated the <code class="literal">show</code> call to use the battlefield scene instead of the pirate cove scene that happens in step 9.</p><p>Then, we ran the example. If we touch anywhere on the screen, the ship will move to the position we just touched.</p><p>Let's take a look at our source files.</p><p>The following is the code for the <code class="literal">Battlefield.h</code> file:</p><div class="informalexample"><pre class="programlisting">#import "Scene.h"

@interface Battlefield : Scene {
    SPImage *_pirateShip;
}

@end</pre></div><p>Here's the<a id="id211" class="indexterm"/> corresponding <code class="literal">Battlefield.m</code> file:</p><div class="informalexample"><pre class="programlisting">#import "Battlefield.h"
#import "Assets.h"

@implementation Battlefield

-(void) onBackgroundTouch: (SPTouchEvent*) event
{
    SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];
    
  if (touch) {
    SPTween *tweenX = [SPTween tweenWithTarget:_pirateShip time:2.0f];
    SPTween *tweenY = [SPTween tweenWithTarget:_pirateShip time:2.0f];
    
    
    [tweenX animateProperty:@"x" targetValue:touch.globalX - (_pirateShip.width / 2)];
    [tweenY animateProperty:@"y" targetValue:touch.globalY - (_pirateShip.height / 2)];
    
    [Sparrow.juggler addObject:tweenX];
    [Sparrow.juggler addObject:tweenY];
  }
}
-(id) init
{
    if ((self = [super init])) {
        SPImage *background = [SPImage imageWithTexture:[Assets texture:@"water.png"]];
        background.x = (Sparrow.stage.width - background.width) / 2;
        background.y = (Sparrow.stage.height - background.height) / 2;
        
       _pirateShip = [SPImage imageWithTexture:[Assets texture:@"ship_pirate.png"]];
       _pirateShip.x = (Sparrow.stage.width - _pirateShip.width) / 2;
       _pirateShip.y = (Sparrow.stage.height - _pirateShip.height) / 2;
        
        SPImage *ship = [SPImage imageWithTexture:[Assets texture:@"ship.png"]];
        ship.x = 100;
        ship.y = 100;
        
        [background addEventListener:@selector(onBackgroundTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];
        
        [self addChild:background];
        [self addChild:_pirateShip];
        [self addChild:ship];
    }
    
    return self;
}

@end</pre></div></div><div class="section" title="Understanding transitions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Understanding transitions</h2></div></div></div><p>Let's take<a id="id212" class="indexterm"/> a closer look at the animation we just implemented. When we moved our pirate ship, it moves at a constant speed. This is a linear transition, which is the default behavior for each newly created <code class="literal">SPTween</code> instance if the transition value is not explicitly set when creating the instance.</p><p>The standard way to create a tween with the default transition is as follows:</p><div class="informalexample"><pre class="programlisting">SPTween *myTween = [SPTween tweenWithTarget:_pirateShip time:2.0f];</pre></div><p>To use a tween with a nonlinear transition, just specify it as a parameter:</p><div class="informalexample"><pre class="programlisting">SPTween *myTween = [SPTween tweenWithTarget:_pirateShip time:2.0f transition:SP_TRANSITION_EASE_IN_OUT];</pre></div><p>In this piece of code, we are using a transition behavior called "ease-in-out", in which case the ship wouldn't move right away but would take its time to start, and shortly before the animation is over, it slows down a bit.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>For a complete list of all available transitions and their graphical representations, take a look <a id="id213" class="indexterm"/>at the Sparrow manual at <a class="ulink" href="http://wiki.sparrow-framework.org/_detail/manual/transitions.png?id=manual%3Aanimation">http://wiki.sparrow-framework.org/_detail/manual/transitions.png?id=manual%3Aanimation</a>.</p></div></div></div><div class="section" title="Explaining jugglers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Explaining jugglers</h2></div></div></div><a id="id214" class="indexterm"/><p>The purpose of a <span class="strong"><strong>juggler</strong></span> is to animate other objects. It does this by holding them in a list, and calling an update method every frame. The update method (<code class="literal">advanceTime</code>) passes through the number of milliseconds that have been passed since the last frame. Every object we want to animate needs to be added to an instance of <code class="literal">SPJuggler</code>.</p><p>The default juggler can be accessed through <code class="literal">Sparrow.juggler</code> and is the easiest way to animate objects on the screen.</p><p>As <code class="literal">Sparrow.juggler</code> is just an instance of <code class="literal">SPJuggler</code>, it is also possible to separate jugglers for each of the main components of our game. For now, using the default juggler is enough for our needs.</p></div><div class="section" title="Updating the movement and canceling tweens"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Updating the movement and canceling tweens</h2></div></div></div><p>It's time for <a id="id215" class="indexterm"/>our first gameplay decisions. Right now, the pirate ship's animation is always 2 seconds long which would provide a serious advantage if the player<a id="id216" class="indexterm"/> touched one of the edges of the screen instead of just moving a few points on the screen.</p><p>What we need to introduce is some kind of penalty if we move to an edge of the screen, like taking more time for the ship to advance.</p><p>It's also a good idea to add the possibility of canceling the animation when the ship is currently moving. So when things get heated, we have a option to retreat from the current battle.</p><p>Now, how would we go about implementing the cancelation of the current animation? Let's see the following options for doing so:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By adding a button on the screen</li><li class="listitem" style="list-style-type: disc">By touching the ship itself</li></ul></div><p>We should try to avoid onscreen controls as long as we can, so let's add this functionality to the touch event (when we touch the pirate ship).</p></div></div>
<div class="section" title="Time for action &#x2013; updating the movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec66"/>Time for action – updating the movement</h1></div></div></div><p>To<a id="id217" class="indexterm"/> update the movement of our ship, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Inside the initializer, add a tween for the enemy ship. We want the enemy ship to move on its own. We should also rename the ship instance to <code class="literal">enemyShip</code>:<div class="informalexample"><pre class="programlisting">SPImage *enemyShip = [SPImage imageWithTexture:[Assets texture:@"ship.png"]];
enemyShip.x = 100;
enemyShip.y = 100;

<span class="strong"><strong>SPTween *shipTween = [SPTween tweenWithTarget:enemyShip time:4.0f transition:SP_TRANSITION_EASE_IN_OUT];</strong></span>
<span class="strong"><strong>[shipTween animateProperty:@"y" targetValue:250];</strong></span>
<span class="strong"><strong>shipTween.repeatCount = 5;</strong></span>
<span class="strong"><strong>shipTween.reverse = YES;</strong></span>
<span class="strong"><strong>shipTween.delay = 2.0f;</strong></span>

<span class="strong"><strong>[Sparrow.juggler addObject:shipTween];</strong></span>
</pre></div></li><li class="listitem">Update <a id="id218" class="indexterm"/>the <code class="literal">onBackgroundTouch</code> method to resemble the following piece of code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SPTouch *touch = [[event touchesWithTarget:self] anyObject];</strong></span>

if (touch) {
<span class="strong"><strong>  [Sparrow.juggler removeObjectsWithTarget:_pirateShip];</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  float targetX = touch.globalX - (_pirateShip.width / 2);</strong></span>
<span class="strong"><strong>  float targetY = touch.globalY - (_pirateShip.height / 2);</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  float distanceX = fabsf(_pirateShip.x - targetX);</strong></span>
<span class="strong"><strong>  float distanceY = fabsf(_pirateShip.y - targetY);</strong></span>
<span class="strong"><strong>  float penalty = (distanceX + distanceY) / 80.0f;</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  float shipInitial = 0.25f + penalty;</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  float speedX = shipInitial + (distanceX / Sparrow.stage.width) * penalty * penalty;</strong></span>
<span class="strong"><strong>  float speedY = shipInitial + (distanceY / Sparrow.stage.height) * penalty * penalty;</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  SPTween *tweenX = [SPTween tweenWithTarget:_pirateShip time:speedX];</strong></span>
<span class="strong"><strong>  SPTween *tweenY = [SPTween tweenWithTarget:_pirateShip time:speedY];</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  [tweenX animateProperty:@"x" targetValue:targetX];</strong></span>
<span class="strong"><strong>  [tweenY animateProperty:@"y" targetValue:targetY]; </strong></span>
  
  [Sparrow.juggler addObject:tweenX];
  [Sparrow.juggler addObject:tweenY];
}</pre></div></li><li class="listitem">Add a new method called <code class="literal">onShipStop</code> as shown in the following line of code:<div class="informalexample"><pre class="programlisting">-(void) onShipStop:(SPTouchEvent*) event</pre></div></li><li class="listitem">Implement<a id="id219" class="indexterm"/> this method with all of the touch boilerplate code and stop all animations:<div class="informalexample"><pre class="programlisting">SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];

if (touch) {
  [Sparrow.juggler removeObjectsWithTarget:_pirateShip];
}</pre></div></li><li class="listitem">Register the <code class="literal">onShipStop</code> selector to the pirate ship:<div class="informalexample"><pre class="programlisting">[_pirateShip addEventListener:@selector(onShipStop:) atObject:self forType:SP_EVENT_TYPE_TOUCH];</pre></div></li><li class="listitem">When we add the ships to the battlefield scene, switch the enemy ship with the pirate ship.</li><li class="listitem">Run the example and you'll see the following result:<div class="mediaobject"><img src="graphics/1509OS_05_02.jpg" alt="Time for action – updating the movement"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In step 1, we added a tween for the enemy ship right below the code where we load its image.</p><p>When<a id="id220" class="indexterm"/> creating the instance, we set the time the animation should take to 4 seconds and we used the ease-in-out transition to see the difference when we directly compare it with the default linear transition.</p><p>This tween will move the enemy ship by its <code class="literal">y</code> property/position. We set the target value to <code class="literal">250</code>, which is more or less the bottom of the screen.</p><p>When setting<a id="id221" class="indexterm"/> the <code class="literal">repeatCount</code> property—which takes an <code class="literal">int</code> as its value—we want to repeat the animation for exactly as many times as we set the property to.</p><p>Tweens can be reversed by setting the reverse property to <code class="literal">YES</code> or <code class="literal">NO</code>, as it takes a <code class="literal">BOOL</code> value. If we<a id="id222" class="indexterm"/> had not set the <code class="literal">reverse</code> property in this example, the tween would start at its initial value when repeating the animation. When set to <code class="literal">YES</code>, the animation alternates between its initial and target values. We should keep in mind that a reverse animation counts as an animation cycle.</p><p>Tweens can be delayed by using their <code class="literal">delay</code> property. This property needs a <code class="literal">double</code> type as well and is measured in seconds just like the <code class="literal">time</code> property.</p><p>Now, we need to add the animation to the default juggler.</p><p>In step 2, we updated the touch event and the animation. First of all, we removed the <code class="literal">andPhase</code> parameter. Previously, we could only move the ship by tapping on the screen. Now, we can <a id="id223" class="indexterm"/>either tap the screen or touch-and-drag on the screen to move the ship around.</p><p>After we know<a id="id224" class="indexterm"/> that a touch was made, we removed all the previously bound tweens from the juggler. Here, we are just making sure that we always have a fresh tween and the pirate ship animation might produce any random side effects such as multiple tweens setting different target values at the same time.</p><p>In the next line, we declared and assigned variables for the new position our ship should move to. Then, we got the absolute values between the ship's position and the position of our touch.</p><p>The penalty is calculated by the sum of the distances divided by 80, which is conveniently the size of our ship in points. So, the closer the touch is to the ship, the lower this value is, and the further away the touch is from the ship, the higher this value will be.</p><p>The speed of the ship, that is, the duration of the animation, is calculated by the relative distance with regard to the screen size multiplied by the square penalty. We also have an initial value of 250 milliseconds, which is the shortest amount the animation could be.</p><p>Instead of the <code class="literal">animateProperty</code> method, we can also use the shorthand method <code class="literal">moveToX:y:</code> which<a id="id225" class="indexterm"/> does the same as calling <code class="literal">animateProperty</code> on the <code class="literal">x</code> and <code class="literal">y</code> properties.</p><p>In step 3, we added the <code class="literal">onShipStop</code> method to the source file, which we implemented in the next step. We <a id="id226" class="indexterm"/>also removed all tweens with the <code class="literal">_pirateShip</code> target. So, if currently a tween is being executed, it will be removed.</p><p>In step 5, we registered the <code class="literal">onShipStop</code> event to the pirate ship.</p><p>Currently, if we were to move over the enemy ship, the enemy ship would be displayed on the top of our ship. For our ship to be displayed on top of the enemy ship, we need to switch the two around when we add them to the display tree.</p><p>After this example, our <code class="literal">Battlefield.m</code> file should look like the following code:</p><div class="informalexample"><pre class="programlisting">#import "Battlefield.h"
#import "Assets.h"

@implementation Battlefield

-(id) init
{
    if ((self = [super init])) {
        SPImage *background = [SPImage imageWithTexture:[Assets texture:@"water.png"]];
        background.x = (Sparrow.stage.width - background.width) / 2;
        background.y = (Sparrow.stage.height - background.height) / 2;
        
        _pirateShip = [SPImage imageWithTexture:[Assets texture:@"ship_pirate.png"]];
        _pirateShip.x = (Sparrow.stage.width - _pirateShip.width) / 2;
        _pirateShip.y = (Sparrow.stage.height - _pirateShip.height) / 2;
        
        SPImage *enemyShip = [SPImage imageWithTexture:[Assets texture:@"ship.png"]];
        enemyShip.x = 100;
        enemyShip.y = 100;
        
        SPTween *shipTween = [SPTween tweenWithTarget:enemyShip time:4.0f transition:SP_TRANSITION_EASE_IN_OUT];
        [shipTween animateProperty:@"y" targetValue:250];
        shipTween.repeatCount = 5;
        shipTween.reverse = YES;
        shipTween.delay = 2.0f;
        
        [Sparrow.juggler addObject:shipTween];
        
        [background addEventListener:@selector(onBackgroundTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];
        [_pirateShip addEventListener:@selector(onShipStop:) atObject:self forType:SP_EVENT_TYPE_TOUCH];
        
        [self addChild:background];
        [self addChild:enemyShip];
        [self addChild:_pirateShip];
    }
    
    return self;
}

-(void) onBackgroundTouch:(SPTouchEvent*) event
{
    SPTouch *touch = [[event touchesWithTarget:self] anyObject];
    
    if (touch) {
        [Sparrow.juggler removeObjectsWithTarget:_pirateShip];
        
        float targetX = touch.globalX - (_pirateShip.width / 2);
        float targetY = touch.globalY - (_pirateShip.height / 2);
        
        float distanceX = fabsf(_pirateShip.x - targetX);
        float distanceY = fabsf(_pirateShip.y - targetY);
        
        float penalty = (distanceX + distanceY) / 80.0f;
        
        float shipInitial = 0.25f + penalty;
        
        float speedX = shipInitial + (distanceX / Sparrow.stage.width) * penalty * penalty;
        float speedY = shipInitial + (distanceY / Sparrow.stage.height) * penalty * penalty;
        
        SPTween *tweenX = [SPTween tweenWithTarget:_pirateShip time:speedX];
        SPTween *tweenY = [SPTween tweenWithTarget:_pirateShip time:speedY];
        
        
        [tweenX animateProperty:@"x" targetValue:targetX];
        [tweenY animateProperty:@"y" targetValue:targetY];
        
        [Sparrow.juggler addObject:tweenX];
        [Sparrow.juggler addObject:tweenY];
    }
}

-(void) onShipStop:(SPTouchEvent*) event
{
    SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];
    
    if (touch) {
        [Sparrow.juggler removeObjectsWithTarget:_pirateShip];
    }
}

@end</pre></div></div></div>
<div class="section" title="Working with sprite sheets"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec67"/>Working with sprite sheets</h1></div></div></div><p>So far, we loaded every image on its own and displayed them on the screen. Sprite sheets are a way to combine all of these smaller images into one big image. When we load the image, we are able to use the textures in the same way that we are used to.</p><p>When using multiple images, something called a "texture switch" happens every time the current active texture is being swapped out by a different one. This operation is quite heavy on performance, so it should be avoided where possible. Sprite sheets allow us to achieve this by using the same image asset for numerous different images, thus avoiding the texture switch and keeping the number of draw calls to a minimum.</p><p>Sprite sheets can also be used for sprite animation, in which a series of images is displayed sequentially one frame after another, which creates the illusion of animation to the human eye—just like a flip book.</p><p>A texture<a id="id227" class="indexterm"/> atlas is a specialization of sprite sheets with regard to containing smaller images, but it also provides a file of metadata which contains the information of where exactly its subimages are. In practice though, "texture atlas" and "sprite sheet" are used as synonyms.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Before we get started, let's download all the necessary graphics for this chapter at <a class="ulink" href="https://github.com/freezedev/pirategame-assets/releases/download/0.5/Graphics_05.zip">https://github.com/freezedev/pirategame-assets/releases/download/0.5/Graphics_05.zip</a>.</p></div></div></div>
<div class="section" title="Learning about texture formats"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec68"/>Learning about texture formats</h1></div></div></div><p>So far, we <a id="id228" class="indexterm"/>only used PNG images. However, let's see if there are any other texture formats in iOS that would better fit our purpose. Spoiler: there are. Leaving the brash remark aside, we are going to analyze which texture formats fits our purpose best.</p><p>The following table shows the pirate ship image in different file formats. Let's compare its file sizes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Compression</p>
</th><th style="text-align: left" valign="bottom">
<p>File format</p>
</th><th style="text-align: left" valign="bottom">
<p>File size</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>BMP</p>
</td><td style="text-align: left" valign="top">
<p>257 KB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Lossless</p>
</td><td style="text-align: left" valign="top">
<p>PNG</p>
</td><td style="text-align: left" valign="top">
<p>36.6 KB</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Depends</p>
</td><td style="text-align: left" valign="top">
<p>PVR</p>
<p>(In this case RGBA8888)</p>
</td><td style="text-align: left" valign="top">
<p>257 KB</p>
</td></tr></tbody></table></div><p>When we load a PNG file, what happens internally? The image gets decompressed when it's being loaded—at the expense of the CPU. The same goes for other conventional image formats such as JPEG. Once the image is decompressed, it becomes a texture.</p><p>PVR is a texture format specifically optimized for iOS devices or for PowerVR GPUs used on all iOS devices, to be more precise. When loading a PVR image, for example, it will decode the image directly on the GPU instead of the CPU.</p><p>PVR includes a lot of different image formats. If we are going for lossless quality including alpha channels, we should opt for the RGBA8888 format. If we don't need the alpha channel, we should use an image format without one. The RGBA8888 image format is <a id="id229" class="indexterm"/>not compressed. So, in order to keep the application size at a minimum, we should use the <code class="literal">pvr.gz</code> format, which is a PVR file compressed using GZIP.</p><div class="section" title="Using TexturePacker to create sprite sheets"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Using TexturePacker to create sprite sheets</h2></div></div></div><p>
<span class="strong"><strong>TexturePacker</strong></span> is<a id="id230" class="indexterm"/> a commercial application to<a id="id231" class="indexterm"/> create sprite sheets and texture atlases<a id="id232" class="indexterm"/> and is available at <a class="ulink" href="http://www.codeandweb.com/texturepacker">http://www.codeandweb.com/texturepacker</a> for around 30 dollars. To be able to create our very own sprite sheets, we either need the pro or the trial version of TexturePacker. The TexturePacker download window looks as follows:</p><div class="mediaobject"><img src="graphics/1509OS_05_03.jpg" alt="Using TexturePacker to create sprite sheets"/></div><p>While the workflow is pretty self-explanatory, let's go through a few steps to create our own texture atlas:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Drag-and-drop the images <code class="literal">0001.png</code> to <code class="literal">0032.png</code> into the <span class="strong"><strong>Sprites</strong></span> section of the application.</li><li class="listitem">Select <span class="strong"><strong>Sparrow/Starling</strong></span> as the <span class="strong"><strong>Data Format</strong></span>.</li><li class="listitem">Select <span class="strong"><strong>GZIP compr. PVR</strong></span> as the <span class="strong"><strong>Texture Format</strong></span>.</li><li class="listitem">Select <span class="strong"><strong>RGBA8888</strong></span> as the <span class="strong"><strong>Image Format</strong></span>.</li><li class="listitem">Hit the <span class="strong"><strong>AutoSD</strong></span> button and select <span class="strong"><strong>corona @4x/@2x</strong></span> from the presets.</li><li class="listitem">Set the filenames to <code class="literal">ship_pirate_small_cannon{v}.xml</code> for the data file and <code class="literal">ship_pirate_small_cannon{v}.pvr.gz</code> for the texture file.</li><li class="listitem">Click on the <span class="strong"><strong>Publish</strong></span> button.</li></ol></div><p>Now <a id="id233" class="indexterm"/>our texture atlas is generated for each of our resolution we are supporting. Let's take a look at the result. The output of one of the generated images would look like the following screenshot:</p><div class="mediaobject"><img src="graphics/1509OS_05_04.jpg" alt="Using TexturePacker to create sprite sheets"/></div><p>Here's a snippet from the corresponding XML file:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- Created with TexturePacker http://www.codeandweb.com/texturepacker--&gt;
&lt;!-- $TexturePacker:SmartUpdate:c58f88c054e0e917cc6c06d11cc04c15:0af47aa74ca5e538fac63da189c2b7ac:9e0a4549107632fbd952ab702bfc21e4$ --&gt;
&lt;TextureAtlas imagePath="ship_pirate_small_cannon.pvr.gz"&gt;
    &lt;SubTexture name="e_0001" x="0" y="0" width="80" height="80"/&gt;
    &lt;SubTexture name="e_0003" x="80" y="0" width="80" height="80"/&gt;
    &lt;SubTexture name="e_0005" x="160" y="0" width="80" height="80"/&gt;
    &lt;SubTexture name="e_0007" x="240" y="0" width="80" height="80"/&gt;</pre></div><p>From<a id="id234" class="indexterm"/> this snippet, we can see the reference to<a id="id235" class="indexterm"/> the original image and its subtextures. Each subtexture has a name, its location inside the bigger image, and its dimensions.</p></div><div class="section" title="Loading our first texture atlas"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Loading our first texture atlas</h2></div></div></div><p>Now that we have our texture atlas, let's load and display it with Sparrow.</p></div></div>
<div class="section" title="Time for action &#x2013; loading our first texture atlas"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec69"/>Time for action – loading our first texture atlas</h1></div></div></div><p>To load <a id="id236" class="indexterm"/>our first texture atlas, we need to follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy the necessary files (<code class="literal">ship_pirate_small_cannon*</code>) into the project.</li><li class="listitem">Load the texture atlas with the following line of code:<div class="informalexample"><pre class="programlisting">SPTextureAtlas* atlas = [SPTextureAtlas atlasWithContentsOfFile:@"ship_pirate_small_cannon.xml"];</pre></div></li><li class="listitem">Create an array out of all textures starting with <code class="literal">00</code>:<div class="informalexample"><pre class="programlisting">NSArray* textures = [atlas texturesStartingWith:@"00"];</pre></div></li><li class="listitem">Create a movie clip object and position it just above the original pirate ship, as shown in the following code:<div class="informalexample"><pre class="programlisting">SPMovieClip *cannonShip = [SPMovieClip movieWithFrames:textures fps:20.0f];
cannonShip.x = 200;
cannonShip.y = 50;</pre></div></li><li class="listitem">Play the animation with the following piece of code:<div class="informalexample"><pre class="programlisting">[cannonShip play];
[Sparrow.juggler addObject:cannonShip];</pre></div></li><li class="listitem">Add the animated pirate ship to the display tree as follows:<div class="informalexample"><pre class="programlisting">[self addChild:background];
[self addChild:enemyShip];
[self addChild:_pirateShip];
[self addChild:cannonShip];</pre></div></li><li class="listitem">Run <a id="id237" class="indexterm"/>the example to see the following result:<div class="mediaobject"><img src="graphics/1509OS_05_05.jpg" alt="Time for action – loading our first texture atlas"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>To use the texture atlas, we first copied all related files into the project. Using the <code class="literal">SPTextureAtlas</code> class, we then loaded the XML file.</p><p>In step 3, we needed to get an array (or an <code class="literal">NSArray</code> to be exact) out of the texture atlas with all of the images starting with <code class="literal">00</code>, which in our case means that every image in this sprite sheet will be used for the animation.</p><p>An <code class="literal">SPMovieClip</code> class is derived from <code class="literal">SPDisplayObject</code> and can be added to the display tree as well. It can play the animation from the array we made in step 3. The <code class="literal">fps</code> parameter is necessary as it sets the speed of the animation.</p><p>To play<a id="id238" class="indexterm"/> the animation itself, two things need to be done: first, we need to call the <code class="literal">play</code> method from the movie clip and second, we need to add the movie clip to the juggler. This is exactly what we did in step 5.</p><p>In the next step, we added the movie clip to the display tree and when we ran the example, we had our pirate ship, the enemy ship which moves up and down and now the second pirate ship which has the cannon firing animation.</p><p>If you want to take a look at the complete source file for this example, it is available at <a class="ulink" href="https://github.com/freezedev/pirategame/blob/71f42ded614c4917802dcba46a190476ff7b88c4/Classes/Battlefield.m">https://github.com/freezedev/pirategame/blob/71f42ded614c4917802dcba46a190476ff7b88c4/Classes/Battlefield.m</a>. </p></div><div class="section" title="Pop quiz"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Pop quiz</h2></div></div></div><p>Q1. What are tweens?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A way to define animation by setting two key frames</li><li class="listitem">Animations consisting of multiple sprites</li><li class="listitem">A way to optimize multiple display objects on the screen</li></ol></div><p>Q2. What are sprite sheets?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Sketches on a sheet of paper</li><li class="listitem">An image containing several smaller ones</li><li class="listitem">A Sparrow extension to use sprites</li></ol></div><p>Q3. Transitions are used to modify the rate of animation over time.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, we learned about tweens and sprite sheets.</p><p>Specifically, we covered how to animate display objects with tweens, create our own sprite sheets, and how to animate these sprite sheets.</p><p>We also touched upon texture formats, jugglers, and transitions.</p><p>Now that we have animations and our ship is moving around, let's add some game logic—which is the topic of the next chapter.</p></div></body></html>