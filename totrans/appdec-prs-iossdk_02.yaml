- en: Chapter 2. Parse Objects and Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parse helps you to manage your complete backend structure for mobile applications
    and discard the requirement of developing complex server-side code and their maintenance.
    Parse provides you with the database structures in the form of objects. It saves
    all your data in the form of objects and will return the same object while retrieving
    back from Parse.
  prefs: []
  type: TYPE_NORMAL
- en: Every application has a different and specific **Application ID** associated
    with the **Client Key**, which remains same for all the applications of the same
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Parse is based on object-oriented principles. All the operations on Parse will
    be done in the form of objects. Parse saves your data in the form of objects you
    send, and helps you to fetch the data in the same format again. In this chapter,
    you will learn about objects and operations that can be performed on Parse objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work with Parse objects along with writing
    queries to set and get data from Parse.
  prefs: []
  type: TYPE_NORMAL
- en: Parse objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the data in Parse is saved in the form of PFObject. When you fetch any data
    from Parse by firing a query, the result will be in the form of PFObject. The
    detailed concept of PFObject is explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: PFObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data stored on Parse is in the form of objects and it's developed around PFObject.
    PFObject can be defined as the key-value (dictionary format) pair of JSON data.
    The Parse data is schemaless, which means that you don't need to specify ahead
    of time what keys exist on each PFObject. Parse backend will take care of storing
    your data simply as a set of whatever key-value pair you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you are tracking the visited count of the username with a user ID
    using your application. A single PFObject could contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Parse accepts only string as `Key`. Values can be strings, numbers, Booleans,
    or even arrays, and dictionaries—anything that can be JSON encoded.
  prefs: []
  type: TYPE_NORMAL
- en: The class name of PFObject is used to distinguish different sorts of data. Let's
    say you call the `visitedCounts` object of the user. Parse recommends you to write
    your class name `NameYourClassLikeThis` and `nameYourKeysLikeThis` just to provide
    readability to the code. As you have seen in the previous example, we have used
    `visitedCounts` to represent the visited count key.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on Parse objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can perform save, update, and delete operations on Parse objects. Following
    is the detailed explanation of the operations that can be performed on Parse objects.
  prefs: []
  type: TYPE_NORMAL
- en: Saving objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To save your `User` table on the Parse Cloud with additional fields, you need
    to follow the coding convention similar to the `NSMutableDictionary` method. After
    updating the data you have to call the `saveInBackground` method to save it on
    the Parse Cloud. Here is the example that explains how to save additional data
    on the Parse Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after executing the preceding piece of code, your data is saved on the
    Parse Cloud. You can check your data in **Data Browser** of your application on
    Parse. It should be something similar to the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to configure or set up a new class called User before running
    your code. Parse will automatically create the class when it first encounters
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a few fields you don''t need to specify, those are provided
    as a convenience:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objectId` is a unique identifier for each saved object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createdAt` and `updatedAt` represent the time that each object was created
    and last modified in the Parse Cloud. Each of these fields is filled in by Parse,
    so they don''t exist on PFObject until a save operation has completed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can provide additional logic after the success or failure of the callback
    operation using the `saveInBackgroundWithBlock` or `saveInBackgroundWithTarget:selector:`
    methods provided by Parse:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fetch the saved data from the Parse Cloud is even easier than saving data.
    You can fetch the data from the Parse Cloud in the following way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fetch the complete object from its `objectId` using PFQuery. Methods
    to fetch data from the cloud are asynchronous. You can implement this either by
    using block-based or callback-based methods provided by Parse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze each line in here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 1: It creates a query object pointing to the class name given in the argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 2: It calls an asynchronous method on the query object created in line
    1 to download the complete object for `objectId`, provided as an argument. As
    we are using the block-based method, we can provide code inside the block, which
    will execute on success or failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 3: It reads data from `PFObject` that we got in response to the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parse provides some common values of all Parse objects as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To refresh the current Parse object, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method can be called on any Parse object, which is useful when you want
    to refresh the data of the object. Let's say you want to re-authenticate a user,
    so you can call the `refresh` method on the user object to refresh it.
  prefs: []
  type: TYPE_NORMAL
- en: Saving objects offline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parse provides you with the functions to save your data when the user is offline.
    So when the user is not connected to the Internet, the data will be saved locally
    in the objects, and as soon as the user is connected to the Internet, data will
    be saved automatically on the Parse Cloud. If your application is forcefully closed
    before establishing the connection, Parse will try again to save the object next
    time the application is opened. For such operations, Parse provides you with the
    `saveEventually` method, so that you will not lose any data even when the user
    is not connected to the Internet. Eventually all calls are executed in the order
    the request is made. The following code demonstrates the `saveEventually` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Updating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For updating objects on Parse, we just need to feed the new data to Parse by
    calling any of the save functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have `objectId` of the object saved on Parse. We can
    fetch the corresponding `PFObject` using `PFQuery` from Parse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After executing the previous code, the Parse client will automatically detect
    the fields that are changed and will send only the changed fields to Parse for
    update. Here, we are using the `saveInBackground` method to asynchronously save
    our data on the Parse Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Updating counters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, you may want to update the counters such as in the case of a
    game score. Then, in those cases, for incrementing the value of the key, you can
    use the `incrementKey` method, and for decrementing the value, you can use the
    `decrementKey` method over PFObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even increase or decrease the value of counters by any specific number
    by using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code will increment the `"score"` key by `8`.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in an array format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To store data in array format, Parse provides several methods for saving the
    data. To add the data into your existing value of key, you can use the following
    code snippet. This code will add the `"flying"` object in your `"skills"` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line of code will add the provided array of objects to the existing
    array on the cloud. (It can have duplicate data for the value of key.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous line of code, the data of the array will be appended to the
    existing cloud data without any check for the uniqueness of the value of the array.
    In case you want to avoid the duplicate values to be saved on the cloud, you can
    use the `addUniqueObjectsFromArray` method to save your array. This method will
    ensure that only unique values are saved on the cloud for the key. The following
    line of code will add the provided array of objects to the existing array if they
    are not already added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Deleting objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following line of code will help you to delete objects from the Parse Cloud.
    This method will delete your object asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `deleteInBackgroundWithBlock:` method to get a callback after
    the deletion of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will delete the object in the background and return the
    success or error message in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Relations and data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like our relations in the database, we have multiple tables that have a
    relationship with each other. Parse provides us with the facility to establish
    relations in between our Parse classes as well. Relations in Parse are explained
    in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can add a relationship between two Parse objects. To implement this, we
    can add one `PFObject` as the value of another `PFObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example, we have both `Course` and `Student` objects, and we
    can associate a course with a student by establishing the relationship between
    both of their classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Relations between objects can also be achieved by using `objectId`s as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parse supports all the data type formats such as `NSString`, `NSData`, `NSNumber`,
    `PFObject`, `NSDate`, `NSNull`, and `NSData`. You can even create nested objects
    in the form of `NSDictionary` and `NSArray` to store structured data within a
    single `PFObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some random variables shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Working with queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fetch the saved data from the cloud, we can use the queries to get the required
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with simple queries. We can fetch data from Parse asynchronously
    by executing these simple lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to filter the results while fetching from Parse, you can add
    conditions over the query object and retrieve the `NSArray` of the filtered `PFObject`.
    You can use the following method to find the data from the Parse Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Both methods are asynchronous and will execute callback on the main thread.
    There is one method called `[query findObjects]`; this method will block the thread
    on which it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to fetch the list of students registered for an MBA
    course, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add constraint to the result of the query we can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following types of predicate features are supported by Parse:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use comparisons such as =, !=, <, >, <=, >=, and BETWEEN with a key
    and a constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containment predicates, such as x IN {1, 2, 3}
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-existence predicates, such as x IN SELF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BEGINSWITH expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compound predicates with AND, OR, and NOT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sub-queries with "key IN %@", subquery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following types of predicates are not supported by Parse:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate operations, such as ANY, SOME, ALL, or NONE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions, such as LIKE, MATCHES, CONTAINS, or ENDSWITH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predicates comparing one key to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex predicates with many ORed clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding query constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various ways to add constraint to the query results. Following are
    the few ways to implement constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find all the students excluding the specified one in the query, Parse provides
    the `whereKey:notEqualTo:` method to get the selective filtered data from the
    Parse Cloud. This method is available in various combinations. The following code
    will get the objects where the student name is not John Simon:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can add multiple constraints to the same query, the resultant objects will
    match to all the constraints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can limit the result of the query by setting the `limit` of the query object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to get only the first object of the result, you can use `getFirstObject`
    or `getFirstObjectInBackground`. Both methods will return the first object from
    the array of objects received in response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can skip the result by setting `skip`. This can be used for pagination
    as well:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parse provides you with an easy way of sorting numbers and strings. It allows
    you to control the order in which the results are returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can filter the results by providing the comparisons in the queries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can filter the results based on the different values as well. You can provide
    the array of the values that should appear in the results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Relational and complex queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can fire the queries on relational schema to perform operations on the Parse
    data. Following are the various ways to fetch data from Parse under a relational
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Array-based queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have keys with data in the array format, you can find objects where
    array contains value `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to fetch the data matching multiple values of array, you can use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: String-based queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `where:hasPrefix:` to add the constraint to the query result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Relational queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can fetch the objects from Parse where the fields match the particular
    PFObject. Parse provides a method `whereKey:equalTo:` to fetch data from a query.
    Let''s say you want to fetch a list of students who are enrolled for the MBA course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you want to fetch multiple types of related objects in a single query,
    Parse provides you with the `includeKey:` method to fetch these kinds of relational
    results. For example, if you want to fetch the names of the top-scorer students,
    and you want to fetch their courses at the same time, you can use the following
    code snippet to get the desired results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Counting objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be some cases in which you just need to know the count of the resultant
    array. For this you don''t need to query the complete data using the `findObjects`
    method. Parse provides you with the `countObjects` method to fetch the count of
    the data available on Parse for the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Compound queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to fetch the objects as the result of several queries, Parse provides
    the `orQueryWithSubqueries:` method to fetch these kinds of result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you need to get the list of names of the top-scorer and the least-scorer
    students; the following code snippet gives the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Caching queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caching the data is a process where we store the data received from the remote
    API calls temporally on a device. So, for the same request, you do not need to
    fetch the data again and again. Caching improves the efficiency, performance,
    and reduces load on the server with minimal API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Once data is requested through a query from Parse, it is recommended to cache
    it, to reduce the number of hits to the Parse Cloud. You can cache the result
    on the disk. This feature will help you to show data in an offline mode or when
    the application is just launched and data is not fetched yet. Parse automatically
    handles flushing the cache when memory is low.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `PFQuery` doesn''t cache queries; however, you can enable caching
    of the `PFQuery` by setting the property `query.cachePolicy`. Let''s take an example,
    if network reachability is not available, you can add an automatic fallback to
    cached data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse provides you with the following caching policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `kPFCachePolicyIgnoreCache` | It is the default cache policy. The query does
    not load from the cache nor does it save results to the cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `KPFCachePolicyCacheOnly` | The query only loads from the cache, ignoring
    the network. If there are no cached results, that causes a `PFError`. |'
  prefs: []
  type: TYPE_TB
- en: '| `KPFCachePolicyNetworkOnly` | It does not load from the cache, but it saves
    results to the cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `KPFCachePolicyCacheElseNetwork` | It tries to load from the cache, but if
    the query fails, it loads results from the network. If neither cache nor network
    succeeds, there is a `PFError`. |'
  prefs: []
  type: TYPE_TB
- en: '| `KPFCachePolicyNetworkElseCache` | This query first tries to load from the
    network, but if it fails, it loads results from the cache. If neither network
    nor cache succeeds, you will get a `PFError`. |'
  prefs: []
  type: TYPE_TB
- en: '| `KPFCachePolicyCacheThenNetwork` | This query first loads from the cache,
    then loads from the network. In this case, the callback will be called twice—first
    with the cached results, then with the network results. Since it returns two results
    at different times, this cache policy cannot be used synchronously with `findObjects`.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Caching behavior can be controlled using the following operations on the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It helps you to check the cached result for a query:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It clears cached results for the query object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It clears all the cache of the `PFQuery`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can control the time for which the cache result will exist:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Parse objects and the way to query the data available
    on Parse.
  prefs: []
  type: TYPE_NORMAL
- en: We started by exploring Parse objects and the ways to save these objects on
    the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned about the queries which will help us to fetch the saved data
    on Parse.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw various ways to implement queries and the constraints by which
    we can reduce the complexity of the queries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn the various ways to save our files on the
    Parse Cloud, along with the subclassing concepts on Parse objects.
  prefs: []
  type: TYPE_NORMAL
