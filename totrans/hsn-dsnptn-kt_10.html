<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Idioms and Anti-Patterns</h1>
                
            
            
                
<p class="calibre2">This chapter discusses the best and worst practices in Kotlin. You'll learn what idiomatic Kotlin code should look like and which patterns to avoid.</p>
<p class="calibre2">After completing this chapter, you should be able to write more readable and maintainable Kotlin code, as well as avoid some common pitfalls.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Let</li>
<li class="calibre12">Apply</li>
<li class="calibre12">Also</li>
<li class="calibre12">Run</li>
<li class="calibre12">With</li>
<li class="calibre12">Instance checks</li>
<li class="calibre12">Try-with-resources</li>
<li class="calibre12">Inline functions</li>
<li class="calibre12">Reified</li>
<li class="calibre12">Constants</li>
<li class="calibre12">Constructor overload</li>
<li class="calibre12">Dealing with nulls</li>
<li class="calibre12">Explicit async</li>
<li class="calibre12">Validation</li>
<li class="calibre12">Sealed, not enumerated</li>
<li class="calibre12">More companions</li>
<li class="calibre12">Scala function</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Let</h1>
                
            
            
                
<p class="calibre2">Usually, we use <kbd class="calibre13">let()</kbd> to do something only if the object is <kbd class="calibre13">not null</kbd>:</p>
<pre class="calibre18">val sometimesNull = if (Random().nextBoolean()) "not null" else null<br class="title-page-name"/><br class="title-page-name"/>sometimesNull?.let {<br class="title-page-name"/>    println("It was $it this time")<br class="title-page-name"/>}</pre>
<p class="calibre2">One common gotcha here is that <kbd class="calibre13">let()</kbd> by itself also works on nulls:</p>
<pre class="calibre18">val alwaysNull = null<br class="title-page-name"/><br class="title-page-name"/>alwaysNull.let { // No null pointer there<br class="title-page-name"/>    println("It was $it this time") // Always prints null<br class="title-page-name"/>}</pre>
<p class="calibre2">Don't forget the question mark, <kbd class="calibre13">?</kbd>, when you use <kbd class="calibre13">let()</kbd> for null checks.</p>
<p class="calibre2">The return value of <kbd class="calibre13">let()</kbd> is not related to the type it operates on:</p>
<pre class="calibre18">val numberReturned = justAString.let {<br class="title-page-name"/>    println(it)<br class="title-page-name"/>    it.length<br class="title-page-name"/>}</pre>
<p class="calibre2">This code will print <kbd class="calibre13">"string"</kbd> and return <kbd class="calibre13">Int 6</kbd> as its length.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Apply</h1>
                
            
            
                
<p class="calibre2">We have already discussed <kbd class="calibre13">apply()</kbd> in previous chapters. It returns the same object it operates on and sets the context to <kbd class="calibre13">this</kbd>. The most useful case for this function is setting the fields of a mutable object.</p>
<p class="calibre2">Think of how many times you had to create a class with an empty constructor, then call a lot of setters, one after another:</p>
<pre class="calibre18">class JamesBond {<br class="title-page-name"/>    lateinit var name: String<br class="title-page-name"/>    lateinit var movie: String<br class="title-page-name"/>    lateinit var alsoStarring: String<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val agentJavaWay = JamesBond()<br class="title-page-name"/>agentJavaWay.name = "Sean Connery"<br class="title-page-name"/>agentJavaWay.movie = "Dr. No"</pre>
<p class="calibre2">We can set only <kbd class="calibre13">name</kbd> and <kbd class="calibre13">movie</kbd>, but leave <kbd class="calibre13">alsoStarring</kbd> blank, like this:</p>
<pre class="calibre18">val `007` = JamesBond().apply {<br class="title-page-name"/>    this.name = "Sean Connery"<br class="title-page-name"/>    this.movie = "Dr. No"<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println(`007`.name)</pre>
<p class="calibre2">Since the context is set to this, we can simplify it to the following nice syntax:</p>
<pre class="calibre18">val `007` = JamesBond().apply {<br class="title-page-name"/>    name = "Sean Connery"<br class="title-page-name"/>    movie = "Dr. No"<br class="title-page-name"/>}</pre>
<p class="calibre2">This function is especially good when you work with Java classes that usually have a lot of setters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Also</h1>
                
            
            
                
<p class="calibre2">Single-expression functions are very nice and concise:</p>
<pre class="calibre18">fun multiply(a: Int, b: Int): Int = a * b</pre>
<p class="calibre2">But often, you have a single-statement function, that also needs to write to a log, for example.</p>
<p class="calibre2">You could write it the following way:</p>
<pre class="calibre18">fun multiply(a: Int, b: Int): Int {<br class="title-page-name"/>    val c = a * b<br class="title-page-name"/>    println(c)<br class="title-page-name"/>    return c<br class="title-page-name"/>}</pre>
<p class="calibre2">But then it's not a single statement function anymore, right? </p>
<p class="calibre2">And we also introduced another variable. To the rescue, <kbd class="calibre13">also()</kbd>:</p>
<pre class="calibre18">fun multiply(a: Int, b: Int): Int = (a * b).<strong class="calibre1">also { println(it) }</strong></pre>
<p class="calibre2">This function will set results of the expression to <kbd class="calibre13">it</kbd> and return the result of the expression.</p>
<p class="calibre2">This is also useful when you want to have a side effect on a chain of calls:</p>
<pre class="calibre18">val l = (1..100).toList()<br class="title-page-name"/><br class="title-page-name"/>l.filter{ it % 2 == 0 }<br class="title-page-name"/>    .also { println(it) } // Prints, but doesn't change anything<br class="title-page-name"/>    .map { it * it }<br class="title-page-name"/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Run</h1>
                
            
            
                
<p class="calibre2">Not related to threads in any way, <kbd class="calibre13">run()</kbd> is much like <kbd class="calibre13">let()</kbd>, but it sets the context to <kbd class="calibre13">this</kbd> instead of using <kbd class="calibre13">it</kbd>:</p>
<pre class="calibre18">val justAString = "string"<br class="title-page-name"/><br class="title-page-name"/>val n = justAString.run { <br class="title-page-name"/>    this.length<br class="title-page-name"/>}</pre>
<p class="calibre2">Usually, <kbd class="calibre13">this</kbd> could be omitted:</p>
<pre class="calibre18">val n = justAString.run { <br class="title-page-name"/>    length<br class="title-page-name"/>}</pre>
<p class="calibre2">It is mostly useful when you plan to call a number of methods on the same object, much like <kbd class="calibre13">apply()</kbd>.</p>
<p class="calibre2">The return result, unlike <kbd class="calibre13">apply()</kbd>, may be of a totally different type, though:</p>
<pre class="calibre18">val year = JamesBond().run {<br class="title-page-name"/>    name = "ROGER MOORE"<br class="title-page-name"/>    movie = "THE MAN WITH THE GOLDEN GUN"<br class="title-page-name"/>    1974 // &lt;= Not JamesBond type<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">With</h1>
                
            
            
                
<p class="calibre2">Unlike the other four scoping functions, <kbd class="calibre13">with()</kbd> is not an extension function.</p>
<p class="calibre2">This means you cannot do the following:</p>
<pre class="calibre18">"scope".with { ... }</pre>
<p class="calibre2">Instead, <kbd class="calibre13">with()</kbd> receives the object you want to scope as an argument:</p>
<pre class="calibre18">with("scope") {<br class="title-page-name"/>    println(this.length) // "this" set to the argument of with()<br class="title-page-name"/>}</pre>
<p class="calibre2">And as usual, we can omit <kbd class="calibre13">this</kbd>:</p>
<pre class="calibre18">with("scope") {<br class="title-page-name"/>    length<br class="title-page-name"/>}</pre>
<p class="calibre2">Just like <kbd class="calibre13">run()</kbd> and <kbd class="calibre13">let()</kbd>, you can return any result from <kbd class="calibre13">with()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Instance checks</h1>
                
            
            
                
<p class="calibre2">Coming from Java, you may be inclined to check what type your object is using, <kbd class="calibre13">is</kbd>, and cast it using <kbd class="calibre13">as</kbd>:</p>
<pre class="calibre18">interface Superhero<br class="title-page-name"/>class Batman : Superhero {<br class="title-page-name"/>    fun callRobin() {<br class="title-page-name"/>        println("To the Bat-pole, Robin!")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class Superman : Superhero {<br class="title-page-name"/>    fun fly() {<br class="title-page-name"/>        println("Up, up and away!")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fun doCoolStuff(s : Superhero) {<br class="title-page-name"/>    if (s is Superman) {<br class="title-page-name"/>        (s as Superman).fly()<br class="title-page-name"/>    }<br class="title-page-name"/>    else if (s is Batman) {<br class="title-page-name"/>        (a as Batman).callRobin()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">But as you may know, Kotlin has smart casts, so implicit casting, in this case, is not needed:</p>
<pre class="calibre18">fun doCoolStuff(s : Superhero) {<br class="title-page-name"/>    if (s is Superman) {<br class="title-page-name"/>        s.fly()<br class="title-page-name"/>    }<br class="title-page-name"/>    else if (s is Batman) {<br class="title-page-name"/>        s.callRobin()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Moreover, in most cases, using <kbd class="calibre13">when()</kbd> while smart-casting produces cleaner code:</p>
<pre class="calibre18">fun doCoolStuff(s : Superhero) {<br class="title-page-name"/>    when(s) {<br class="title-page-name"/>        is Superman -&gt; s.fly()<br class="title-page-name"/>        is Batman -&gt; s.callRobin()<br class="title-page-name"/>        else -&gt; println("Unknown superhero")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">As a rule of thumb, you should avoid using casts and rely on smart casts most of the time:</p>
<pre class="calibre18">// Superhero is clearly not a string<br class="title-page-name"/>val superheroAsString = (s as String)</pre>
<p class="calibre2">But if you absolutely must, there's also a safe cast operator:</p>
<pre class="calibre18">val superheroAsString = (s as? String)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Try-with-resources</h1>
                
            
            
                
<p class="calibre2">Java7 added the notion of <kbd class="calibre13">AutoCloseable</kbd> and the try-with-resources statement.</p>
<p class="calibre2">This statement allows us to provide a set of resources that would be automatically closed after the code is done with them. No more risk (or at least less risk) of forgetting to close a file.</p>
<p class="calibre2">Before Java7, that was a total mess:</p>
<pre class="calibre18"><strong class="calibre1">BufferedReader br = null; // Nulls are bad, we know that<br class="title-page-name"/>try </strong>{<br class="title-page-name"/>    br = new BufferedReader(new FileReader("/some/peth"));
    System.out.println(br.readLine());
}<br class="title-page-name"/>finally {<br class="title-page-name"/>    if (br != null) { // Explicit check<br class="title-page-name"/>        br.close(); // Boilerplate<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">After Java7:</p>
<pre class="calibre18">try (BufferedReader br = new BufferedReader(new FileReader("/some/peth"))) {<br class="title-page-name"/>    System.out.println(br.readLine());<br class="title-page-name"/>}</pre>
<p class="calibre2">In Kotlin, the <kbd class="calibre13">this</kbd> statement is replaced with the <kbd class="calibre13">use()</kbd> function:</p>
<pre class="calibre18">val br = BufferedReader(FileReader(""))<br class="title-page-name"/><br class="title-page-name"/>br.<strong class="calibre1">use </strong>{<br class="title-page-name"/>    println(it.readLine())<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Inline functions</h1>
                
            
            
                
<p class="calibre2">You can think of inline functions as a copy/paste instruction for the compiler. Each time the compiler sees a call to a function marked with inline, it will replace the call with the <kbd class="calibre13">concrete</kbd> function body.</p>
<p class="calibre2">It makes sense to use the inline function only if it's a higher-order function that receives a lambda as one of its arguments:</p>
<pre class="calibre18">inline fun doesntMakeSense(something: String) {<br class="title-page-name"/>    println(something)<br class="title-page-name"/>}</pre>
<p class="calibre2">This is the most common use case where you would like to use <kbd class="calibre13">inline</kbd>:</p>
<pre class="calibre18">inline fun makesSense(block: () -&gt; String) {<br class="title-page-name"/>    println("Before")<br class="title-page-name"/>    println(block())<br class="title-page-name"/>    println("After")<br class="title-page-name"/>}</pre>
<p class="calibre2">You call it as usual, with the block body:</p>
<pre class="calibre18">makesSense {<br class="title-page-name"/>    "Inlining"<br class="title-page-name"/>}</pre>
<p class="calibre2">But if you view the bytecode, you'll see it's actually translated to the lines produces and not to a function call:</p>
<pre class="calibre18">println("Before")<br class="title-page-name"/>println("Inlining")<br class="title-page-name"/>println("After")</pre>
<p class="calibre2">In the actual code, you'll see the following:</p>
<pre class="calibre18">String var1 = "Before"; &lt;- Inline function call<br class="title-page-name"/>System.out.println(var1);<br class="title-page-name"/>var1 = "Inlining";<br class="title-page-name"/>System.out.println(var1);<br class="title-page-name"/>var1 = "After";<br class="title-page-name"/>System.out.println(var1);<br class="title-page-name"/><br class="title-page-name"/>var1 = "Before"; // &lt;- Usual code<br class="title-page-name"/>System.out.println(var1);<br class="title-page-name"/>var1 = "Inlining";<br class="title-page-name"/>System.out.println(var1);<br class="title-page-name"/>var1 = "After";<br class="title-page-name"/>System.out.println(var1);</pre>
<p class="calibre2">Notice there's absolutely no difference between the two blocks.</p>
<p class="calibre2">Since the inline function is copy/paste, you shouldn't use it if you have more than a few lines of code. It would be more efficient to have it as a regular function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reified</h1>
                
            
            
                
<p class="calibre2">Since the inline function is copied, we can get rid of one of the major JVM limitations–type erasure. After all, inside the function, we know exactly what type we're getting.</p>
<p class="calibre2">Let's look at the following example. You would like to create a generic function, which will receive a number but will print it only if it's of the same type as the function.</p>
<p class="calibre2">You can try writing something like this:</p>
<pre class="calibre18">fun &lt;T&gt; printIfSameType(a: Number) {<br class="title-page-name"/>    if (a is T) { // &lt;== Error<br class="title-page-name"/>        println(a)   <br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">But this code won't compile with an error as follows: </p>
<pre class="calibre18"><strong class="calibre1">Cannot check for instance of erased type: T</strong></pre>
<p class="calibre2">What we usually do in Java, in this case, is pass the class as an argument:</p>
<pre class="calibre18">fun &lt;T: Number&gt; printIfSameType(clazz: KClass&lt;T&gt;, a: Number) {<br class="title-page-name"/>    if (clazz.isInstance(a) ) {<br class="title-page-name"/>        println(a)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can check this code by running the following two lines:</p>
<pre class="calibre18">printIfSameType(Int::class, 1) // Print 1, as 1 is Int<br class="title-page-name"/>printIfSameType(Int::class, 2L) // Prints nothing, as 2 is Long</pre>
<p class="calibre2">This code has a few downsides:</p>
<ul class="calibre11">
<li class="calibre12">We had to use reflection, and for that, we had to include the <kbd class="calibre13">kotlin-reflect</kbd> library: </li>
</ul>
<pre class="calibre27">compile group: 'org.jetbrains.kotlin', name: 'kotlin-reflect', version: '1.2.31'</pre>
<ul class="calibre11">
<li class="calibre12">We cannot use the <kbd class="calibre13">is</kbd> operator and must use the <kbd class="calibre13">isInstance()</kbd> function instead.</li>
<li class="calibre12">We must pass the correct class: </li>
</ul>
<pre class="calibre27">clazz: KClass&lt;T&gt;</pre>
<p class="calibre2">Instead, we canuse a <kbd class="calibre13">reified</kbd> function:</p>
<pre class="calibre18"><code>reified </code>T&gt; printIfSameTypeReified(a: Number) {<br class="title-page-name"/>    if (a is T) {<br class="title-page-name"/>        println(a)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can test that our code still works as expected:</p>
<pre class="calibre18">printIfSameTypeReified&lt;Int&gt;(3) // Prints 3, as 3 is Int<br class="title-page-name"/>printIfSameTypeReified&lt;Int&gt;(4L) // Prints nothing, as 4 is Long<br class="title-page-name"/>printIfSameTypeReified&lt;Long&gt;(5) // Prints nothing, as 5 is Int<br class="title-page-name"/>printIfSameTypeReified&lt;Long&gt;(6L) // Prints 6, as 6 is Long</pre>
<p class="calibre2">We get all the benefits of the language this way:</p>
<ul class="calibre11">
<li class="calibre12">No need for another dependency</li>
<li class="calibre12">Clear method signature</li>
<li class="calibre12">Ability to use the <kbd class="calibre13">is</kbd> construct</li>
</ul>
<p class="calibre2">Of course, the same rules as regular inline functions apply. This code would be replicated, so it shouldn't be too large.</p>
<p class="calibre2">Consider another case regarding function overloading:</p>
<pre class="calibre18">fun printList(list: List&lt;Int&gt;) {<br class="title-page-name"/>    println("This is a lit of Ints")<br class="title-page-name"/>    println(list)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>fun printList(list: List&lt;Long&gt;) {<br class="title-page-name"/>    println("This is a lit of Longs")<br class="title-page-name"/>    println(list)<br class="title-page-name"/>}</pre>
<p class="calibre2">This won't compile because there's a platform declaration clash. Both have the same signature in terms of JVM: <kbd class="calibre13">printList(list: List)</kbd>.</p>
<p class="calibre2">But with <kbd class="calibre13">reified</kbd>, we can achieve this:</p>
<pre class="calibre18">const val int = 1<br class="title-page-name"/>const val long = 1L<br class="title-page-name"/>inline fun &lt;reified T : Any&gt; printList(list: List&lt;T&gt;) {<br class="title-page-name"/>    when {<br class="title-page-name"/>        int is T -&gt; println("This is a list of Ints")<br class="title-page-name"/>        long is T -&gt; println("This is a list of Longs")<br class="title-page-name"/>        else -&gt; println("This is a list of something else")<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    println(list)<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Constants</h1>
                
            
            
                
<p class="calibre2">Since everything in Java is an object (unless you're a primitive type), we're used to putting all the constants inside our objects as static members.</p>
<p class="calibre2">And since Kotlin has companion objects, we usually try putting them there:</p>
<pre class="calibre18">class MyClass {<br class="title-page-name"/>    companion object {<br class="title-page-name"/>        val MY_CONST = "My Const"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">This will work, but you should remember that companion object is an object, after all.</p>
<p class="calibre2">So, this will be translated to the following code, more or less:</p>
<pre class="calibre18">public final class Spock {<br class="title-page-name"/>   @NotNull<br class="title-page-name"/>   private static final String MY_CONST = "My Const";<br class="title-page-name"/>   public static final Spock.Companion Companion = new Spock.Companion(...);<br class="title-page-name"/><br class="title-page-name"/>   public static final class Companion {<br class="title-page-name"/>      @NotNull<br class="title-page-name"/>      public final String getMY_CONST() {<br class="title-page-name"/>         return MyClass.MY_CONST;<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      private Companion() {<br class="title-page-name"/>      }<br class="title-page-name"/>   }<br class="title-page-name"/>}</pre>
<p class="calibre2">And the call to our constant looks like this:</p>
<pre class="calibre18">String var1 = Spock.Companion.getSENSE_OF_HUMOR();<br class="title-page-name"/>System.out.println(var1);</pre>
<p class="calibre2">So, we have our class, <kbd class="calibre13">Spock</kbd>, inside of which we have another class. But what we wanted was only <kbd class="calibre13">static final String</kbd>.</p>
<p class="calibre2">Let's now mark this value as constant:</p>
<pre class="calibre18">class Spock {<br class="title-page-name"/>    companion object {<br class="title-page-name"/>        <strong class="calibre1">const</strong> val SENSE_OF_HUMOR = "None"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here are the bytecode changes:</p>
<pre class="calibre18">public final class Spock {<br class="title-page-name"/>   @NotNull<br class="title-page-name"/>   <strong class="calibre1">public</strong> static final String SENSE_OF_HUMOR = "NONE";<br class="title-page-name"/>   public static final Spock.Companion Companion = new Spock.Companion(...);<br class="title-page-name"/>   )<br class="title-page-name"/>   public static final class Companion {<br class="title-page-name"/>      private Companion() {<br class="title-page-name"/>      }<br class="title-page-name"/>        ...<br class="title-page-name"/>   }<br class="title-page-name"/>}</pre>
<p class="calibre2">And here is the call:</p>
<pre class="calibre18">String var1 = "NONE";<br class="title-page-name"/>System.out.println(var1);</pre>
<p class="calibre2">Notice that there's no call to this constant at all since the compiler already inlined its value for us. After all, it's constant.</p>
<p class="calibre2">If all you need is a constant, you can also set it up outside of any class:</p>
<pre class="calibre18">const val SPOCK_SENSE_OF_HUMOR = "NONE"</pre>
<p class="calibre2">And if you need namespacing, you can wrap it in an object:</p>
<pre class="calibre18">object SensesOfHumor {<br class="title-page-name"/>    const val SPOCK = "NONE"<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Constructor overload</h1>
                
            
            
                
<p class="calibre2">In Java, we're used to having overloaded constructors:</p>
<pre class="calibre18">class MyClass {<br class="title-page-name"/>    private final String a;<br class="title-page-name"/>    private final Integer b;<br class="title-page-name"/>    public MyClass(String a) {<br class="title-page-name"/>        this(a, 1);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public MyClass(String a, Integer b) {<br class="title-page-name"/>        this.a = a;<br class="title-page-name"/>        this.b = b;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can simulate the same behavior in Kotlin:</p>
<pre class="calibre18">class MyClass(val a: String, val b: Int, val c: Long) {<br class="title-page-name"/>    <br class="title-page-name"/>    constructor(a: String, b: Int) : this(a, b, 0) <br class="title-page-name"/>    <br class="title-page-name"/>    constructor(a: String) : this(a, 1)<br class="title-page-name"/>    <br class="title-page-name"/>    constructor() : this("Default")<br class="title-page-name"/>}</pre>
<p class="calibre2">But it's usually better to have default parameter values and named arguments instead:</p>
<pre class="calibre18"><br class="title-page-name"/>class BetterClass(val a: String = "Default",<br class="title-page-name"/>                  val b: Int = 1,<br class="title-page-name"/>                  val c: Long = 0)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Dealing with nulls</h1>
                
            
            
                
<p class="calibre2">Nulls are unavoidable, especially if you work with Java libraries or get data from a database. </p>
<p class="calibre2">But you can check for null the Java way:</p>
<pre class="calibre18">// Will return "String" half of the time, and null the other half<br class="title-page-name"/>val stringOrNull: String? = if (Random().nextBoolean()) "String" else null <br class="title-page-name"/><br class="title-page-name"/>// Java-way check<br class="title-page-name"/>if (stringOrNull != null) {<br class="title-page-name"/>    println(stringOrNull.length)<br class="title-page-name"/>}</pre>
<p class="calibre2">Or in a shorter form, with the <kbd class="calibre13">Elvis</kbd> operator. If the length is not null, this operator will return its value. Otherwise, it will return the default value we supplied, zero in this case:</p>
<pre class="calibre18">val alwaysLength = stringOrNull?.length ?: 0<br class="title-page-name"/><br class="title-page-name"/>println(alwaysLength) // Will print 6 or 0, but never null</pre>
<p class="calibre2">If you have a nested object, you can chain those checks:</p>
<pre class="calibre18">data class Json(<br class="title-page-name"/>        val User: Profile?<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/>data class Profile(val firstName: String?,<br class="title-page-name"/>                   val lastName: String?)<br class="title-page-name"/><br class="title-page-name"/>val json: Json? = Json(Profile(null, null))<br class="title-page-name"/><br class="title-page-name"/>println(json?.User?.firstName?.length)</pre>
<p class="calibre2">Finally, you can use the <kbd class="calibre13">let()</kbd> block for those checks:</p>
<pre class="calibre18">println(json?.let {<br class="title-page-name"/>    it.User?.let {<br class="title-page-name"/>        it.firstName?.length<br class="title-page-name"/>    }<br class="title-page-name"/>})</pre>
<p class="calibre2">If you want to get rid of the <kbd class="calibre13">it()</kbd> everywhere, you can use run:</p>
<pre class="calibre18">println(json?.run {<br class="title-page-name"/>    User?.run {<br class="title-page-name"/>        firstName?.length<br class="title-page-name"/>    }<br class="title-page-name"/>})</pre>
<p class="calibre2">By all means, do try to avoid the unsafe <kbd class="calibre13">!!</kbd> null operator:</p>
<pre class="calibre18">println(json!!.User!!.firstName!!.length)</pre>
<p class="calibre2">This will result in <kbd class="calibre13">KotlinNullPointerException</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Explicit async</h1>
                
            
            
                
<p class="calibre2">As you saw in the previous chapter, in Kotlin it is very easy to introduce concurrency:</p>
<pre class="calibre18">fun getName() = async {<br class="title-page-name"/>   delay(100)<br class="title-page-name"/>   "Ruslan"<br class="title-page-name"/>}</pre>
<p class="calibre2">But that concurrency may be unexpected behavior to the user of the function, as they may expect a simple value:</p>
<pre class="calibre18">println("Name: ${getName()}")</pre>
<p class="calibre2">It prints:</p>
<pre class="calibre18"><strong class="calibre1">Name: DeferredCoroutine{Active}@...</strong></pre>
<p class="calibre2">Of course, what's missing here is <kbd class="calibre13">await()</kbd>:</p>
<pre class="calibre18">println("Name: ${getName().await()}")</pre>
<p class="calibre2">But it would have been a lot more obvious if we'd named our function accordingly:</p>
<pre class="calibre18">fun getName<strong class="calibre1">Async</strong>() = async {<br class="title-page-name"/>   delay(100)<br class="title-page-name"/>   "Ruslan"<br class="title-page-name"/>}</pre>
<p class="calibre2">As a rule, you should establish some kind of convention to distinguish async functions from regular ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Validation</h1>
                
            
            
                
<p class="calibre2">How many times did you have to write code like this:</p>
<pre class="calibre18">fun setCapacity(cap: Int) {<br class="title-page-name"/>    if (cap &lt; 0) {<br class="title-page-name"/>        throw IllegalArgumentException()<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">Instead, you can check arguments with <kbd class="calibre13">require()</kbd>:</p>
<pre class="calibre18">fun setCapacity(cap: Int) {<br class="title-page-name"/>    require(cap &gt; 0)<br class="title-page-name"/>}</pre>
<p class="calibre2">This makes the code a lot more fluent.</p>
<p class="calibre2">You can use <kbd class="calibre13">require()</kbd> to check for nested nulls:</p>
<pre class="calibre18">fun printNameLength(p: Profile) {<br class="title-page-name"/>    <strong class="calibre1">require</strong>(p.firstName != null)<br class="title-page-name"/>}</pre>
<p class="calibre2">But there's also <kbd class="calibre13">requireNotNull()</kbd> for that:</p>
<pre class="calibre18">fun printNameLength(p: Profile) {<br class="title-page-name"/>    <strong class="calibre1">requireNotNull</strong>(p.firstName)<br class="title-page-name"/>}</pre>
<p class="calibre2">Use <kbd class="calibre13">check()</kbd> to validate the state of your object. This is useful when you provide some object that the user may not have set up correctly:</p>
<pre class="calibre18">private class HttpClient {<br class="title-page-name"/>    var body: String? = null<br class="title-page-name"/>    var url: String = ""<br class="title-page-name"/><br class="title-page-name"/>    fun postRequest() {<br class="title-page-name"/>        <strong class="calibre1">check(body != null)</strong> {<br class="title-page-name"/>            "Body must be set in POST requests"<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>    fun getRequest() {<br class="title-page-name"/>        // This one is fine without body<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">And again, there's a shortcut for <kbd class="calibre13">null</kbd>: <kbd class="calibre13">checkNotNull()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sealed, not enumerated</h1>
                
            
            
                
<p class="calibre2">Coming from Java, you may be tempted to overload your <kbd class="calibre13">enum</kbd> with functionality:</p>
<pre class="calibre18">// Java code<br class="title-page-name"/>enum PizzaOrderStatus {<br class="title-page-name"/>    ORDER_RECEIVED, <br class="title-page-name"/>    PIZZA_BEING_MADE, <br class="title-page-name"/>    OUT_FOR_DELIVERY, <br class="title-page-name"/>    COMPLETED;<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    public PizzaOrderStatus nextStatus() {<br class="title-page-name"/>        switch (this) {<br class="title-page-name"/>            case ORDER_RECEIVED: return PIZZA_BEING_MADE;<br class="title-page-name"/>            case PIZZA_BEING_MADE: return OUT_FOR_DELIVERY;<br class="title-page-name"/>            case OUT_FOR_DELIVERY: return COMPLETED;<br class="title-page-name"/>            case COMPLETED:return COMPLETED;<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Instead, you can use the <kbd class="calibre13">sealed</kbd> class:</p>
<pre class="calibre18">sealed class PizzaOrderStatus(protected val orderId: Int) {<br class="title-page-name"/>    abstract fun nextStatus() : PizzaOrderStatus<br class="title-page-name"/>    class OrderReceived(orderId: Int) : PizzaOrderStatus(orderId) {<br class="title-page-name"/>        override fun nextStatus(): PizzaOrderStatus {<br class="title-page-name"/>            return PizzaBeingMade(orderId)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    class PizzaBeingMade(orderId: Int) : PizzaOrderStatus(orderId) {<br class="title-page-name"/>        override fun nextStatus(): PizzaOrderStatus {<br class="title-page-name"/>            return OutForDelivery(orderId)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    class OutForDelivery(orderId: Int) : PizzaOrderStatus(orderId) {<br class="title-page-name"/>        override fun nextStatus(): PizzaOrderStatus {<br class="title-page-name"/>            return Completed(orderId)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    class Completed(orderId: Int) : PizzaOrderStatus(orderId) {<br class="title-page-name"/>        override fun nextStatus(): PizzaOrderStatus {<br class="title-page-name"/>            return this<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The benefit of this approach is that we can now pass data around along with the status:</p>
<pre class="calibre18">var status: PizzaOrderStatus = OrderReceived(123)<br class="title-page-name"/><br class="title-page-name"/>while (status !is Completed) {<br class="title-page-name"/>    status = when (status) {<br class="title-page-name"/>        is OrderReceived -&gt; status.nextStatus()<br class="title-page-name"/>        is PizzaBeingMade -&gt; status.nextStatus()<br class="title-page-name"/>        is OutForDelivery -&gt; status.nextStatus()<br class="title-page-name"/>        is Completed -&gt; status<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In general, sealed classes are good if you want to have data associated with a state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">More companions</h1>
                
            
            
                
<p class="calibre2">You are limited to having only one companion object in your class:</p>
<pre class="calibre18">class A {<br class="title-page-name"/>   companion {<br class="title-page-name"/>   }<br class="title-page-name"/>   companion {<br class="title-page-name"/>   }<br class="title-page-name"/>}</pre>
<p class="calibre2">But you can have as many objects in your class as you want:</p>
<pre class="calibre18">class A {<br class="title-page-name"/>   object B {<br class="title-page-name"/>   }<br class="title-page-name"/>   object C {<br class="title-page-name"/>   }<br class="title-page-name"/>}</pre>
<p class="calibre2">This is sometimes used to produce namespacing. Namespacing is important because it provides you with better naming conventions. Think about having cases when you created classes such as <kbd class="calibre13">SimpleJsonParser</kbd>, which inherits from <kbd class="calibre13">JsonParser</kbd>, which inherits from <kbd class="calibre13">Parser</kbd>. You could convert this structure to <kbd class="calibre13">Json.Parser</kbd>, for example, which is much more concise and practical, as Kotlin code should be. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Scala functions</h1>
                
            
            
                
<p class="calibre2">Developers coming into Kotlin from Scala may sometimes define their function this way:</p>
<pre class="calibre18">fun hello() = {<br class="title-page-name"/>    "hello"<br class="title-page-name"/>}</pre>
<p class="calibre2">Calling this function won't print what you expect:</p>
<pre class="calibre18">println("Say ${hello()}")</pre>
<p class="calibre2">It prints the following:</p>
<pre class="calibre18"> Say () -&gt; kotlin.String</pre>
<p class="calibre2">What we're missing is the second set of parentheses:</p>
<pre class="calibre18">println("Say ${hello()()}")</pre>
<p class="calibre2">It prints the following: </p>
<pre class="calibre18"><strong class="calibre1">Say hello</strong></pre>
<p class="calibre2">That's because the single-expression definition could be translated into:</p>
<pre class="calibre18">fun hello(): <strong class="calibre1">() -&gt; String</strong> {<br class="title-page-name"/>    return {<br class="title-page-name"/>        "hello"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">It could be further translated into:</p>
<pre class="calibre18">fun helloExpandedMore(): () -&gt; String {<br class="title-page-name"/>    return <strong class="calibre1">fun</strong><strong class="calibre1">():</strong><strong class="calibre1"> </strong><strong class="calibre1">String</strong> {<br class="title-page-name"/>        return "hello"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now you can see where that function came from, at least.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we reviewed best practices in Kotlin, as well as some of the caveats of the language. Now you should be able to write more idiomatic code that is also performant and maintainable.</p>
<p class="calibre2">You should make use of scoping functions, but make sure not to overuse them, as they may make the code confusing, especially for those newer to the language.</p>
<p class="calibre2">Be sure to handle nulls and type casts correctly, with <kbd class="calibre13">let()</kbd>, the <kbd class="calibre13">Elvis</kbd> operator, and smart casts that the language provides.</p>
<p class="calibre2">In the next and final chapter, we'll put those skills to use by writing a real-life microservice using everything we've learned.</p>


            

            
        
    </body></html>