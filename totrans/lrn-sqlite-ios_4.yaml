- en: Chapter 4. Essentials of SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 SQL基本知识
- en: In this chapter, you will learn all about the essentials of SQL. It will outline
    what the major possibilities with SQL are and how it can be used properly on SQLite.
    SQL is fundamental to using SQLite and is mandatory for utilizing the benefits
    of SQL. It is relevant in many ways, because it is the way data is passed through,
    interrogated, and displayed, using variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解SQL的所有基本知识。它将概述SQL的主要可能性以及如何在SQLite上正确使用。SQL是使用SQLite的基础，也是利用SQL优势的必要条件。它在许多方面都相关，因为它是数据通过、查询和显示的方式，使用变量。
- en: We will discuss how the language is used with subclauses like "having", for
    example. Once you come to know and learn the essentials of how SQL is used in
    SQLite, it will make the whole subject easier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何使用“having”之类的子句来使用该语言。一旦你了解了SQLite中SQL的基本用法，这将使整个主题变得更容易。
- en: SQL is also pronounced *sequel* in the industry and is the de facto standard
    for data retrieval using these commands and syntaxes. The instruction in this
    chapter will use a style and format that is easy to understand and follow. It
    makes use of the idea of replaying the code, repeating it, and remembering it
    well, for your knowledge and experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在业界，SQL也被发音为*sequel*，并且是使用这些命令和语法的默认数据检索标准。本章中的说明将使用易于理解和遵循的风格和格式。它利用了重放代码、重复它并牢记它的想法，以增强你的知识和经验。
- en: You will also see what data retrieval options and techniques are available to
    sort, collate, and order information as required. The examples shown in this chapter
    will provide easy-to-follow and useful instructions with advanced SQL commands.
    The results will be quick, or even instantaneous and can be practiced over and
    over again to gain the necessary knowledge. There will be tables such as `customers`
    or `salary` and different trigger names and SQL statements in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将看到可用于排序、校对和按需排序信息的各种数据检索选项和技术。本章中展示的示例将提供易于遵循和有用的指令，使用高级SQL命令。结果将快速，甚至瞬间即可获得，可以反复练习以获得必要的知识。本章将包含如`customers`或`salary`之类的表格以及不同的触发器名称和SQL语句。
- en: The examples in this chapter will be ANSI compliant and should work with SQL
    databases such as SQLite, Oracle, Ingres, SQL Server, mySQL, MS Access, Informix,
    Sybase, and other ANSI SQL compliant databases. This chapter aims to give you
    that critical information, which will advance your skills as well. It will also
    act as a simple refresher and reminder of when you first learned them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将符合ANSI标准，并且应该与SQLite、Oracle、Ingres、SQL Server、MySQL、MS Access、Informix、Sybase以及其他ANSI
    SQL兼容数据库一起工作。本章旨在提供关键信息，这将提高你的技能。它还将作为一个简单的复习和提醒，让你回忆起最初学习的内容。
- en: To start off, the `SELECT` statement is the easiest of the general commands,
    but it is also the core one of the pact. It allows the data inside the system
    to be visible by the end user in the choice of format and style requested, assuming
    it is syntactically correct.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`SELECT`语句是通用命令中最容易的一个，但也是协议的核心之一。它允许系统内的数据以用户请求的格式和风格可见，前提是它是语法正确的。
- en: There are many subcommands and clauses with the `SELECT` statement and some
    of those clauses are discussed in this chapter. The `SELECT` statement will have
    more focus due to its importance, and many options for data selection. As a developer
    or a DBA, it is always good to have the knowledge of possible options, which enable
    efficient queries to be written. This chapter will enable that knowledge and,
    for experts, refresh it. Although SQLite commands work and look the same for Oracle
    or MySQL, some of the SQLite ones are actually different.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SELECT`语句中存在许多子命令和子句，本章将讨论其中的一些。由于`SELECT`语句的重要性及其在数据选择方面的众多选项，它将成为本章的重点。作为一名开发者或数据库管理员，了解可能的选择总是有益的，这有助于编写高效的查询。本章将提供这方面的知识，并对专家来说，将是一个知识的更新。尽管SQLite命令在Oracle或MySQL中工作方式和外观相同，但实际上SQLite的一些命令是不同的。
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Transactions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: 'A database **transaction** is a logical unit of work that contains several
    operations within. By definition, it will have four **ACID** properties: **atomic**,
    **consistent**, **isolated**, and **durable**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库**事务**是一个包含多个操作的逻辑工作单元。根据定义，它将具有四个**ACID**属性：**原子性**、**一致性**、**隔离性**和**持久性**。
- en: A transaction must provide a sense of a full commitment to performing the work,
    or a way to rollback and not complete the work. It must also keep each transaction
    separate and isolated from the others, and ensure that transactions are completed,
    and information is written to the database. It must also reduce any amounts of
    database inconsistency and allow the best and proper way to recover from any failures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事务必须提供对执行工作的全面承诺感，或者是一种回滚而不完成工作的方式。它还必须保持每个事务与其他事务的独立和隔离，并确保事务完成，信息写入数据库。它还必须减少数据库的不一致性，并允许从任何故障中恢复的最佳和正确方式。
- en: Query plan
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询计划
- en: When a query is to be executed, a query plan is used by the database to forge
    a data path where the best and the most efficient types of routes are created.
    If there are table join, indexes, and a number of rows in the tables, a variety
    of mathematical calculations using different algorithms are prepared. Having an
    execution plan is useful when there are issues with SQL, and to debug multiple
    table joins and index setups, and follow a path to solve a data or programming
    issue.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当要执行查询时，数据库使用查询计划来构建数据路径，其中创建最佳和最有效的路由类型。如果有表连接、索引和表中的行数，则会准备使用不同算法的各种数学计算。当SQL存在问题，需要调试多个表连接和索引设置，以及遵循路径来解决数据或编程问题时，拥有执行计划是有用的。
- en: Apart from the straightforward SQL statements in a plain format, there will
    be those statements that will be used within iOS and wrapped in one of the languages
    such as Objective-C or Swift.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯文本格式的直接SQL语句外，还有一些语句将在iOS中使用，并封装在Objective-C或Swift等语言中。
- en: When the query execution plan is executed, the data, the information, is geared
    for debugging only and should be used as guidance. Every SQLite release will have
    different updates that affect the product. The whole idea of a plan is to outline
    the strategy path an SQL command takes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询执行计划执行时，数据和信息仅用于调试，应作为指导使用。每个SQLite版本都将有不同的更新影响产品。计划的整体思想是概述SQL命令采取的策略路径。
- en: 'A keyword called **EXPLAIN**, or a phrase, namely, **EXPLAIN QUERY PLAN**,
    is required to be used for obtaining the details of a table. These commands are
    for debugging and analysis only. These commands are partially documented and the
    behavior is not always 100%:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用一个名为**EXPLAIN**的关键字，或者是一个短语，即**EXPLAIN QUERY PLAN**，以获取表的详细信息。这些命令仅用于调试和分析。这些命令部分有文档记录，其行为并不总是100%：
- en: '![Query plan](img/4725_04_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![查询计划](img/4725_04_01.jpg)'
- en: 'Next, we see what an SQL statement with a `salary` selection will look like.
    Using the `EXPLAIN QUERY PLAN` command with the `SELECT` statement, the basic
    plan outlines the order of the table with its name. By learning the query execution
    plans effectively, you get a view of how SQLite accesses your data and see how
    it is committed:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看带有`salary`选择的SQL语句将是什么样子。使用`EXPLAIN QUERY PLAN`命令与`SELECT`语句一起，基本计划概述了表的名称及其顺序。通过有效地学习查询执行计划，你可以了解SQLite如何访问你的数据，并看到它是如何提交的：
- en: '![Query plan](img/4725_04_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![查询计划](img/4725_04_02.jpg)'
- en: The `EXPLAIN QUERY PLAN` command exists as a guidance and plan for executing
    the SQL Query. It will report and provide information that relates to how the
    database indices are effectively used to access the data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPLAIN QUERY PLAN`命令作为执行SQL查询的指导和计划。它将报告并提供与数据库索引如何有效使用来访问数据相关的信息。'
- en: 'The **system catalog** is also the master place where all tables and indexes
    are listed. For example, the `sqlite_master` table is the, as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统目录**也是所有表和索引的主列表位置。例如，`sqlite_master`表如下所示：'
- en: '![Query plan](img/4725_04_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![查询计划](img/4725_04_03.jpg)'
- en: SQL basics
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL基础
- en: 'SQLite also has some other features for using SQL, such as finding the greatest
    `id` from a column, and also the last insert and its `id`, as shown in the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite还有一些其他用于SQL的功能，例如从列中查找最大的`id`，以及最后插入及其`id`，如下所示：
- en: '![SQL basics](img/4725_04_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![SQL基础](img/4725_04_04.jpg)'
- en: Insert with a subselect clause
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带子查询子句的插入
- en: 'The `INSERT` statement is the one used to add data into the database. However,
    the example to date has only shown data from fixed information or program variables.
    There is another way to insert data, which comes from another table based on the
    select criteria and data/column matching. This is an insert with a **subselect**
    clause; see the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT`语句是用来向数据库中添加数据的。然而，迄今为止的示例只展示了来自固定信息或程序变量的数据。还有另一种插入数据的方法，即基于选择标准和数据/列匹配从另一个表插入。这是一种带有**子查询**子句的插入；请参见以下示例：'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are several variations available on the format, as shown in the preceding
    example. The SQL is flexible and there are options to select different data and
    offer computations on the last row of IDs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 格式有多种变体，如前例所示。SQL是灵活的，有选择不同数据和在ID的最后行上进行计算的选择。
- en: Update with a subselect clause
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子查询子句更新
- en: 'As discussed in the previous chapters, the `UPDATE` statement is used to change
    existing data in a table from variables in a program or from fixed data. However,
    there is another way to update data to the destination table from a source table
    where there is a match and link, as shown in the following. The `UPDATE` statement
    will modify more than one column. The `Where` clause will identify which column(s)
    are to be updated. This is one of the simplest and easiest SQL commands to understand:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，`UPDATE`语句用于从程序变量或固定数据中更改表中的现有数据。然而，还有另一种方法可以从具有匹配和链接关系的源表更新数据到目标表，如下所示。`UPDATE`语句将修改多个列。`WHERE`子句将确定哪些列需要更新。这是最容易理解和使用的SQL命令之一：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Select with a subselect clause
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子查询子句进行选择
- en: As discussed in the previous chapters, the `SELECT` statement is used to retrieve
    and display information from the core of the database to the user. The `SELECT`
    statement is a very popular and powerful command with a variety of options and
    choices to retrieve the data. A **subselect** or **subquery** is a nested piece
    of SQL within the original SQL, that is embedded near a `WHERE` clause. The subquery
    or subselect will only be used to retrieve information that links up to the main
    select query using the specific column names.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，`SELECT`语句用于从数据库的核心检索并显示信息给用户。`SELECT`语句是一个非常流行且功能强大的命令，具有各种选项和选择来检索数据。**子查询**或**子查询**是原始SQL中的嵌套SQL片段，它嵌入在`WHERE`子句附近。子查询或子查询将仅用于检索与主选择查询通过特定列名链接的信息。
- en: These subselect clauses can be used within the `DELETE`, `INSERT`, `UPDATE`,
    and `SELECT` SQL commands, with operators such as `=`, `<`, `>`, `>=`, `<=`, `IN`,
    or `BETWEEN`, for example. There are some rules that apply to subqueries, for
    example, the subcommand must only have one column in the `SELECT` clause, unless
    multiple columns are selected in the main SQL statement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子查询子句可以用于`DELETE`、`INSERT`、`UPDATE`和`SELECT` SQL命令中，例如使用`=`、`<`、`>`、`>=`、`<=`、`IN`或`BETWEEN`等运算符。子查询有一些规则适用，例如，子命令的`SELECT`子句中必须只有一个列，除非在主SQL语句中选择了多个列。
- en: 'The subselect queries must use parentheses as part of their syntax, to outline
    the subquery itself. The main part of the query can have the `ORDER BY` syntax,
    but it cannot be in the subquery. If multiple rows are returned using these types
    of queries, then operators such as `IN` must be used. The `BETWEEN` word can be
    used in a subquery as long as it is not the `BETWEEN` operator itself:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询查询必须使用括号作为其语法的一部分，以概述子查询本身。查询的主体部分可以使用`ORDER BY`语法，但不能在子查询中使用。如果使用这些类型的查询返回多行，则必须使用`IN`等运算符。只要不是`BETWEEN`运算符本身，`BETWEEN`词可以在子查询中使用：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Data integrity
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据完整性
- en: '**Data integrity** is very important in maintaining how tables and data relationships
    are defined and protected. There are four types of integrity: user defined, referential,
    entity, and domain.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据完整性**在维护表和数据关系定义及保护方面非常重要。数据完整性有四种类型：用户定义的、引用的、实体的和域的。'
- en: The mastering of data manipulation, database design, development, and administration
    is key to ensure that applications built using SQLite perform well, and are kept
    free from data crashes, data corruptions, and security issues.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握数据处理、数据库设计、开发和管理的技能对于确保使用SQLite构建的应用程序性能良好，并保持无数据崩溃、数据损坏和安全问题至关重要。
- en: When a column's datatype is set, it is a form of data integrity. Data integrity
    can be enhanced by only allowing certain values.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置列的数据类型时，这就是一种数据完整性的形式。可以通过仅允许某些值来增强数据完整性。
- en: When a mechanism is designed to maintain the primary keys in a table by a unique
    tuple or row identifier, it is known as entity integrity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计一种机制来通过唯一的元组或行标识符维护表中的主键时，这被称为实体完整性。
- en: Referential integrity occurs when, for example, two tables are linked by a common
    column datatype and no new data can be added to one table without being added
    to the second. Referential integrity ensures that data is cleaned and linked properly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当例如两个表通过一个公共列数据类型链接时，发生引用完整性。引用完整性确保数据被清理并正确链接。
- en: Default values
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认值
- en: The **default values** for columns is valuable because it enforces data integrity
    and ensures that a value is entered on the database. It also means that some SQL
    statements are smaller than others. A standard type of statement without its column
    being added is an `id` field, where the primary key is defined, and when an `INSERT`
    statement is used, the `id` field is not required, as shown in the following.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列的 **默认值** 非常有价值，因为它强制数据完整性并确保在数据库中输入了值。这也意味着某些 SQL 语句比其他语句更短。一个没有添加列的标准语句类型是
    `id` 字段，其中定义了主键，当使用 `INSERT` 语句时，不需要 `id` 字段，如下所示。
- en: The DBA can create columns to store `current_timestamp` in the database automatically,
    which is good for logging and time stamping.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DBA 可以创建列以在数据库中自动存储 `current_timestamp`，这对于日志记录和时间戳很有用。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Constraint checking
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束检查
- en: To ensure that the right data is inputted into columns on a table, certain rules
    are imposed, and these are called constraints. These rules enforce data accuracy,
    limit corruption, and format issues and data reliability are increased and maintained.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保正确的数据输入到表中的列，必须施加某些规则，这些规则被称为约束。这些规则强制数据准确性，限制损坏，并提高并维护数据可靠性。
- en: 'At table level, it will apply to the whole table, but at column level, it will
    apply only to one certain column level. How they can be used is given as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在表级别，它将应用于整个表，但在列级别，它将仅应用于一个特定的列级别。它们的使用方法如下所示：
- en: The `.UNIQUE` constraint will make sure column data information is not the same
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.UNIQUE` 约束将确保列数据信息不重复'
- en: The `.PRIMARY` key, each data row in the table is identified in SQLite
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.PRIMARY` 键，在 SQLite 中，每个数据行在表中都有一个标识'
- en: '`.NOT NULL` makes sure that no column has a NULL value stored'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.NOT NULL` 确保没有列存储了 NULL 值'
- en: '`DEFAULT` will sets up a default value, when no value is specified or entered'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT` 将设置一个默认值，当未指定或输入值时'
- en: Foreign keys
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外键
- en: When two or more tables need to link together on a common column, it is known
    as a **referencing key** or **foreign key**. SQLite supports relation integrity
    and supports foreign key constraints, like other databases. It is usually designed
    by the DBA and involves a column ID, for example, to match an ID on the second
    or third table.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或多个表需要在公共列上链接在一起时，这被称为 **引用键** 或 **外键**。SQLite 支持关系完整性并支持外键约束，就像其他数据库一样。它通常由
    DBA 设计，涉及一个列 ID，例如，以匹配第二或第三表上的 ID。
- en: 'There must be a logical reference between the table columns and actual data
    for it to perform well. SQLite will use the foreign key as part of the create
    table statement; an example is shown in the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表现良好，表列和实际数据之间必须存在逻辑引用。SQLite 将使用外键作为创建表语句的一部分；以下是一个示例：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Updating Views
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新视图
- en: A **VIEW** is a command that can use a combination of tables and joins to show
    the user or program a set of predefined data, as required. Effectively, it gives
    you a view of the data. You cannot `DELETE`, `UPDATE`, or `INSERT` from a view.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图** 是一个命令，可以使用表的组合和连接来向用户或程序显示一组预定义的数据，如所需。实际上，它提供了数据的视图。您不能从视图中 `DELETE`、`UPDATE`
    或 `INSERT`。'
- en: As a view is defined with a specific name, which is stored in the database,
    it can be effectively referenced as a table to another SQL statement, as part
    of a statement to be manipulated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图是用一个特定的名称定义的，该名称存储在数据库中，因此它可以有效地作为表引用，作为要操作的语句的一部分。
- en: If a keyword such as `Temporary` or `Temp` exists within the `create` and `view`
    words, then that view is only seen by that database connection and is removed
    upon the connection closing, hence the `temp/temporary` name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `create` 和 `view` 词语中存在如 `Temporary` 或 `Temp` 这样的关键字，那么该视图只能被那个数据库连接看到，并在连接关闭时被删除，因此得名
    `temp/temporary`。
- en: If a database name is referenced when the view is created, it will reside within
    that specific database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建视图时引用数据库名称，它将位于该特定数据库中。
- en: Index use
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引使用
- en: After a table is created with its column and datatypes, it is almost ready to
    use. The primary columns for data linking are done, but it is not quite ready
    as defined by a DBA. Instead, an index can be created to speed up SQL queries
    and act as special lookup tables that SQLite will use as a way of getting information
    faster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个具有其列和数据类型的表之后，它几乎可以投入使用。数据链接的主要列已经完成，但根据数据库管理员（DBA）的定义，它还不完全准备好。相反，可以创建一个索引来加速SQL查询，并作为SQLite将用作快速获取信息方式的特殊查找表。
- en: An **index** has a data pointer, which will quickly reference the data and bring
    it back, thus making access quicker without much overhead generally. By definition,
    indexes do have an overhead in their own right, but the overheads of the index
    are dwarfed by the performance and efficiency gained. This could be useful for
    mobile applications because of their limited resource and network access.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引**有一个数据指针，它将快速引用数据并将其返回，从而使得访问更快，通常没有太多开销。根据定义，索引确实有其自身的开销，但索引的开销被性能和效率的获得所掩盖。这对于移动应用程序可能很有用，因为它们资源有限且网络访问受限。'
- en: A database index as an example is similar to the one located in a book, where
    you can find what you want because you know what it is, and just opens the book
    to right page, after reading the index.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子的数据库索引类似于书中的索引，你可以找到你想要的内容，因为你知道它是什么，只需打开书到正确的页面，在阅读索引之后。
- en: 'The index is slow on data input but fast on the `SELECT` queries, with or without
    the `WHERE` clause. Once an index is created, it can also be dropped without affecting
    the core data of a table. The following is a simple example of an index called
    `table_index_name` being created on the `customer` table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 索引在数据输入上较慢，但在`SELECT`查询上较快，无论是否有`WHERE`子句。一旦创建了索引，也可以将其删除，而不会影响表的核心数据。以下是一个简单的例子，展示了在`customer`表上创建了一个名为`table_index_name`的索引：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A second example shows how an index is created to reference a column called
    `salary`, which is used multiple times in many queries:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子展示了如何创建一个索引来引用一个名为`salary`的列，该列在许多查询中被多次使用：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, an index will speed up access. An index called `table_index_salary` is
    created on the `customer` table, which is created on the `salary` column.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个索引将加速访问。在`customer`表上创建了一个名为`table_index_salary`的索引，它是在`salary`列上创建的。
- en: 'There are also indexes called **composite indexes**, which actually index more
    than one column on a database for further performance gains, but also an overhead
    on data input. As shown in the following, an index is created and is linked to
    two columns: `salary` and `bonus`. Rather than having two indexes with more overhead
    issues, a composite index maybe better, since it is one index with a reference
    to two columns:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 也有被称为**组合索引**的索引，实际上是为了在数据库中索引多个列以获得进一步的性能提升，但也会在数据输入上产生开销。如下所示，创建了一个索引并将其链接到两个列：`salary`和`bonus`。与其有两个索引并带来更多开销问题，一个组合索引可能更好，因为它是一个索引，但引用了两个列：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When creating indexes, the database server will also create implicit indexes
    that are automatic. If, as a DBA, you wish to see them, use the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建索引时，数据库服务器还会创建隐式索引，这些索引是自动的。如果作为数据库管理员（DBA），你想查看它们，请使用以下示例：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Triggers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发器
- en: '**Triggers** are an efficient way of using SQL commands to interact efficiently
    with the database. They are quick, and are embedded within the create `trigger`
    command.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发器**是使用SQL命令与数据库高效交互的有效方式。它们快速，并且嵌入在创建`trigger`命令中。'
- en: A trigger is made up of a trigger name, references to the tables involved, an
    event of time (like before, or after value changes), the type of operation (like
    insert, update, or delete), with a variety of tables and columns to complete the
    operation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器由触发器名称、涉及到的表引用、时间事件（如之前或值更改之后）、操作类型（如插入、更新或删除）以及各种表和列组成，以完成操作。
- en: The syntax has to be right and the tests should ensure that the updates and
    changes are correct to ensure data concurrency and stability with no corruptions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 语法必须正确，测试应确保更新和更改是正确的，以确保数据并发性和稳定性，没有损坏。
- en: This trigger is called `update_customer_trigger`, which performs an `UPDATE`
    query on the `customers` table. The update is going to affect the `tel_no` column.
    So, the current telephone column `tel_no` is going to be updated, where it will
    equal the value from the new table, and its column `tel_no`—(`tel_no = new.tel_no`),
    where the link of customer name (`customer_name`), equals the `old.name` column.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个触发器被称为`update_customer_trigger`，它对`customers`表执行`UPDATE`查询。更新将影响`tel_no`列。因此，当前的电话列`tel_no`将被更新，其中它将等于新表中的值，以及其列`tel_no`（`tel_no
    = new.tel_no`），其中客户名称的链接（`customer_name`）等于`old.name`列。
- en: Updated triggers must use specific columns for a table, which are predefined,
    unlike the `insert` or `delete` ones
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的触发器必须使用表中的特定列，这些列是预定义的，与`insert`或`delete`列不同。
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Synchronous writes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步写入
- en: '**Synchronous writes** are part of the SQL engine, which will ensure that data
    changes are written to the disk area, as required, for transaction reasons and
    the way databases work. In the case of SQLite, these operate under different statuses
    or settings of `NORMAL`, `FULL`, or `OFF`. For performance reasons, SQLite commits
    can be switched off by the DBA as required.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步写入**是SQL引擎的一部分，它将确保根据事务原因和数据库工作方式，将数据更改写入磁盘区域。在SQLite的情况下，这些操作在不同的状态或设置下进行，例如`NORMAL`、`FULL`或`OFF`。出于性能原因，DBA可以根据需要关闭SQLite的提交。'
- en: The `OFF` setting carries on its tasks quickly without much slowing down, minimal
    interruptions, and increased performance. However, in the case of a database crash,
    the data integrity will remain okay, but in the case of system crash and power
    loss, there is a good chance that corruption of the database itself may occur.
    There are performance gains to be made, but there are also risks associated with
    this move.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`OFF`设置快速执行任务，几乎没有减慢速度，最小化中断，并提高性能。然而，在数据库崩溃的情况下，数据完整性将保持良好，但在系统崩溃和断电的情况下，数据库本身损坏的可能性很大。虽然可以取得性能上的提升，但这也伴随着与此行动相关的风险。'
- en: The `FULL` setting has to ensure that data is saved to disk properly and in
    good time before carrying on. This method is not good for performance, but is
    the most robust and the safest. If there are data corruptions or system crashes,
    users can be assured that no database corruption will occur.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`FULL`设置必须确保在继续之前，数据被正确且及时地保存到磁盘上。这种方法对性能不利，但是最健壮和最安全的。如果出现数据损坏或系统崩溃，用户可以确信不会发生数据库损坏。'
- en: The `NORMAL` setting will slow down at intervals to protect the data and commit
    transactions to disk. A database crash or a power failure could damage the database,
    but a more serious hardware error could be worse.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`NORMAL`设置会定期减慢速度以保护数据并将事务提交到磁盘。数据库崩溃或断电可能会损坏数据库，但更严重的硬件错误可能更糟糕。'
- en: Database locking and deadlocks
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库锁定和死锁
- en: A **deadlock** occurs when one or many actions or SQL statements compete for
    data access and table updates or manipulation at the same time as another process
    or action. Since it works with a transaction, one process can't move forward or
    complete because the other process or action holds, and is waiting for a resource,
    hence a deadlock.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个或多个操作或SQL语句与其他进程或操作同时竞争数据访问和表更新或操作时，就会发生**死锁**。由于它与事务一起工作，一个进程无法前进或完成，因为另一个进程或操作正在持有资源并等待，因此形成了死锁。
- en: So, in a database, records of process one would attempt to update, but process
    two would like to update some of the same rows, or a conflict of another table
    in which the transaction occurs. Some form of data locking mechanism to manage
    and reduce conflict must happen. Code around the transaction can be added with
    a retry indicator of three, for example, so if there is a deadlock, it will retry,
    and after the third attempt, it would roll back or give the user an opportunity
    to retry.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在数据库中，一个进程可能会尝试更新某个记录，而另一个进程则希望更新同一行中的某些数据，或者是在事务发生时另一个表中的冲突。必须有一种形式的数据锁定机制来管理和减少冲突。可以在事务周围的代码中添加一个重试指示器，例如三个，如果发生死锁，它将重试，并在第三次尝试后回滚或给用户一个重试的机会。
- en: Deadlocking is a common occurrence in multithreaded and multiprocessing operating
    systems, which are performing a variety of tasks and attempting to complete with
    positive results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是多线程和多进程操作系统中的常见现象，这些系统正在执行各种任务，并试图以积极的结果完成。
- en: 'See the following example on how SQL transactions will end up in a deadlock.
    In this case, both transactions/sessions will be in a deadlock state. **Session
    2** will try to insert/write to the database and create a locking to get exclusive
    rights to protect, and ensure it can insert the record without any problem. **Session
    1** tries to write as well, which also causes a deadlock situation. Effectively,
    we have a situation where **Session 1** and **Session 2** do not want to lose
    access or control until the other leaves, which lets the deadlock continue, as
    shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 SQL 事务最终会导致死锁的情况。在这种情况下，两个事务/会话都将处于死锁状态。**会话 2** 将尝试向数据库插入/写入并创建锁定以获取独占权限来保护，并确保它可以无问题地插入记录。**会话
    1** 也尝试写入，这也导致了死锁情况。实际上，我们有一个**会话 1** 和**会话 2** 都不想失去访问或控制权，直到对方离开，这导致死锁继续，如下所示：
- en: '| Session 1 | Session 2 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 会话 1 | 会话 2 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sqlite3>` | `sqlite3>` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `sqlite3>` | `sqlite3>` |'
- en: '|   | `sqlite3>insert into temp(name,address) values(''Gene'',''London'');`
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|   | `sqlite3>insert into temp(name,address) values(''Gene'',''London'');`
    |'
- en: '| `sqlite3> select * from temp;` |   |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `sqlite3> select * from temp;` |   |'
- en: '|   | `sqlite3> commit;` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|   | `sqlite3> commit;` |'
- en: '|   | `SQL Error Message: database locked` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   | `SQL 错误信息：数据库锁定` |'
- en: '| `sqlite3> insert into temp(name,address) values(''Gene'',''London'');` |
      |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `sqlite3> insert into temp(name,address) values(''Gene'',''London'');` |
      |'
- en: '| `SQL Error Message: database locked` |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `SQL 错误信息：数据库锁定` |   |'
- en: FMDB SQLite wrapper
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FMDB SQLite 包装器
- en: In addition to using standard SQL, the FMDB SQLite wrapper, written in Objective-C,
    can be of assistance to those who prefer an alternative and easier way to work
    with SQLite.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用标准的 SQL，Objective-C 编写的 FMDB SQLite 包装器，对于那些喜欢使用替代且更简单方式与 SQLite 交互的人来说，可能会有所帮助。
- en: For more information on the FMDB specification and code examples, refer to [https://github.com/ccgus/fmdb](https://github.com/ccgus/fm).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 FMDB 规范和代码示例的更多信息，请参阅 [https://github.com/ccgus/fmdb](https://github.com/ccgus/fm)。
- en: 'There are three main classes in FMDB:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: FMDB 中有三个主要类：
- en: '**FMDatabase**: This is the single SQLite database that executes your SQL statements'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FMDatabase**：这是执行您的 SQL 语句的单个 SQLite 数据库。'
- en: '**FMResultSet**: This will hold and display the output and results from the
    `FMDatabase`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FMResultSet**：这将保存并显示从 `FMDatabase` 得到的输出和结果。'
- en: '**FMDatabaseQueue**: This will enable you to update and use many threads within
    this class if you want to perform queries and updates on multiple threads'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FMDatabaseQueue**：如果您想在多个线程中执行查询和更新，这个类将使您能够更新和使用许多线程。'
- en: Database creation and opening
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库创建和打开
- en: 'The database is defined and allocated to a location and directory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库被定义并分配到位置和目录：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To engage with the database, you must connect and open it up, as shown in the
    following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要与数据库交互，您必须连接并打开它，如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: SQL in iOS
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS 中的 SQL
- en: 'To select data, methods like `executeQuery` can be used to return the `FMResultSet`
    object if successful, or `0` upon failure. There are methods, such as `lastErrorMessage`
    or `lastErrorcode`, to find out if the query has worked or failed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择数据，可以使用 `executeQuery` 等方法返回 `FMResultSet` 对象（如果成功），或失败时返回 `0`。有如 `lastErrorMessage`
    或 `lastErrorcode` 等方法可以用来确定查询是否成功或失败：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For multiple rows, `[FMResultSet next]` must be used to see or read the values
    returned from the query, even if the recordset is one, for example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多行，必须使用 `[FMResultSet next]` 来查看或读取查询返回的值，即使记录集只有一个，例如。
- en: 'The following command shows how to use `FMResultSet` to select multiple queries
    as required:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了如何使用 `FMResultSet` 来选择所需的多个查询：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`FrmresultSet` offers several methods to the programmer to retrieve; some examples
    are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrmresultSet` 为程序员提供了几种检索方法；以下是一些示例：'
- en: '`intForColumn:`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intForColumn:`'
- en: '`longForColumn:`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longForColumn:`'
- en: '`longLongIntForColumn:`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longLongIntForColumn:`'
- en: Some of the aforementioned methods by default will have the `{type}ForColumnIndex:`
    variant, which will be used to get the data based on the position of the column
    in the rows and not the name itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述一些方法默认将具有 `{type}ForColumnIndex:` 变体，它将用于根据行中列的位置而不是名称本身来获取数据。
- en: The preceding code using `FMDatabase` comes from GitHub and is the standard
    code used for these types of operations. It has been used to improve the ease
    of interacting with SQLite, instead of the conventional standard method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用 `FMDatabase` 的代码来自 GitHub，是这些类型操作的标准代码。它已被用于提高与 SQLite 交互的便捷性，而不是传统的标准方法。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the essentials of SQL in relation to the
    SQLite database, and also what you need to be aware of, and the knowledge required,
    to build SQL statements and interactions with SQLite and iOS as a basic start.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了与SQLite数据库相关的SQL基础知识，以及构建SQL语句和与SQLite及iOS交互所需注意的事项和所需知识，作为基本入门。
- en: In the next chapter, you will learn all about exposing the C API, its impact
    and uses within IOS, and how it works as part of SQLite. The next chapter will
    also mention how the C API is at the core of SQLite and how it is used.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解暴露C API的所有内容，它在iOS中的影响和用途，以及它是作为SQLite一部分如何工作的。下一章还将提及C API是SQLite的核心，以及它的使用方式。
