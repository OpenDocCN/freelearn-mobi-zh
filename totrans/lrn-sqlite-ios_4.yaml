- en: Chapter 4. Essentials of SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn all about the essentials of SQL. It will outline
    what the major possibilities with SQL are and how it can be used properly on SQLite.
    SQL is fundamental to using SQLite and is mandatory for utilizing the benefits
    of SQL. It is relevant in many ways, because it is the way data is passed through,
    interrogated, and displayed, using variables.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how the language is used with subclauses like "having", for
    example. Once you come to know and learn the essentials of how SQL is used in
    SQLite, it will make the whole subject easier.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is also pronounced *sequel* in the industry and is the de facto standard
    for data retrieval using these commands and syntaxes. The instruction in this
    chapter will use a style and format that is easy to understand and follow. It
    makes use of the idea of replaying the code, repeating it, and remembering it
    well, for your knowledge and experience.
  prefs: []
  type: TYPE_NORMAL
- en: You will also see what data retrieval options and techniques are available to
    sort, collate, and order information as required. The examples shown in this chapter
    will provide easy-to-follow and useful instructions with advanced SQL commands.
    The results will be quick, or even instantaneous and can be practiced over and
    over again to gain the necessary knowledge. There will be tables such as `customers`
    or `salary` and different trigger names and SQL statements in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter will be ANSI compliant and should work with SQL
    databases such as SQLite, Oracle, Ingres, SQL Server, mySQL, MS Access, Informix,
    Sybase, and other ANSI SQL compliant databases. This chapter aims to give you
    that critical information, which will advance your skills as well. It will also
    act as a simple refresher and reminder of when you first learned them.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, the `SELECT` statement is the easiest of the general commands,
    but it is also the core one of the pact. It allows the data inside the system
    to be visible by the end user in the choice of format and style requested, assuming
    it is syntactically correct.
  prefs: []
  type: TYPE_NORMAL
- en: There are many subcommands and clauses with the `SELECT` statement and some
    of those clauses are discussed in this chapter. The `SELECT` statement will have
    more focus due to its importance, and many options for data selection. As a developer
    or a DBA, it is always good to have the knowledge of possible options, which enable
    efficient queries to be written. This chapter will enable that knowledge and,
    for experts, refresh it. Although SQLite commands work and look the same for Oracle
    or MySQL, some of the SQLite ones are actually different.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A database **transaction** is a logical unit of work that contains several
    operations within. By definition, it will have four **ACID** properties: **atomic**,
    **consistent**, **isolated**, and **durable**.'
  prefs: []
  type: TYPE_NORMAL
- en: A transaction must provide a sense of a full commitment to performing the work,
    or a way to rollback and not complete the work. It must also keep each transaction
    separate and isolated from the others, and ensure that transactions are completed,
    and information is written to the database. It must also reduce any amounts of
    database inconsistency and allow the best and proper way to recover from any failures.
  prefs: []
  type: TYPE_NORMAL
- en: Query plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a query is to be executed, a query plan is used by the database to forge
    a data path where the best and the most efficient types of routes are created.
    If there are table join, indexes, and a number of rows in the tables, a variety
    of mathematical calculations using different algorithms are prepared. Having an
    execution plan is useful when there are issues with SQL, and to debug multiple
    table joins and index setups, and follow a path to solve a data or programming
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the straightforward SQL statements in a plain format, there will
    be those statements that will be used within iOS and wrapped in one of the languages
    such as Objective-C or Swift.
  prefs: []
  type: TYPE_NORMAL
- en: When the query execution plan is executed, the data, the information, is geared
    for debugging only and should be used as guidance. Every SQLite release will have
    different updates that affect the product. The whole idea of a plan is to outline
    the strategy path an SQL command takes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A keyword called **EXPLAIN**, or a phrase, namely, **EXPLAIN QUERY PLAN**,
    is required to be used for obtaining the details of a table. These commands are
    for debugging and analysis only. These commands are partially documented and the
    behavior is not always 100%:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Query plan](img/4725_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we see what an SQL statement with a `salary` selection will look like.
    Using the `EXPLAIN QUERY PLAN` command with the `SELECT` statement, the basic
    plan outlines the order of the table with its name. By learning the query execution
    plans effectively, you get a view of how SQLite accesses your data and see how
    it is committed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Query plan](img/4725_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `EXPLAIN QUERY PLAN` command exists as a guidance and plan for executing
    the SQL Query. It will report and provide information that relates to how the
    database indices are effectively used to access the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **system catalog** is also the master place where all tables and indexes
    are listed. For example, the `sqlite_master` table is the, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Query plan](img/4725_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SQL basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQLite also has some other features for using SQL, such as finding the greatest
    `id` from a column, and also the last insert and its `id`, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL basics](img/4725_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Insert with a subselect clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `INSERT` statement is the one used to add data into the database. However,
    the example to date has only shown data from fixed information or program variables.
    There is another way to insert data, which comes from another table based on the
    select criteria and data/column matching. This is an insert with a **subselect**
    clause; see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are several variations available on the format, as shown in the preceding
    example. The SQL is flexible and there are options to select different data and
    offer computations on the last row of IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Update with a subselect clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed in the previous chapters, the `UPDATE` statement is used to change
    existing data in a table from variables in a program or from fixed data. However,
    there is another way to update data to the destination table from a source table
    where there is a match and link, as shown in the following. The `UPDATE` statement
    will modify more than one column. The `Where` clause will identify which column(s)
    are to be updated. This is one of the simplest and easiest SQL commands to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Select with a subselect clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous chapters, the `SELECT` statement is used to retrieve
    and display information from the core of the database to the user. The `SELECT`
    statement is a very popular and powerful command with a variety of options and
    choices to retrieve the data. A **subselect** or **subquery** is a nested piece
    of SQL within the original SQL, that is embedded near a `WHERE` clause. The subquery
    or subselect will only be used to retrieve information that links up to the main
    select query using the specific column names.
  prefs: []
  type: TYPE_NORMAL
- en: These subselect clauses can be used within the `DELETE`, `INSERT`, `UPDATE`,
    and `SELECT` SQL commands, with operators such as `=`, `<`, `>`, `>=`, `<=`, `IN`,
    or `BETWEEN`, for example. There are some rules that apply to subqueries, for
    example, the subcommand must only have one column in the `SELECT` clause, unless
    multiple columns are selected in the main SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subselect queries must use parentheses as part of their syntax, to outline
    the subquery itself. The main part of the query can have the `ORDER BY` syntax,
    but it cannot be in the subquery. If multiple rows are returned using these types
    of queries, then operators such as `IN` must be used. The `BETWEEN` word can be
    used in a subquery as long as it is not the `BETWEEN` operator itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Data integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data integrity** is very important in maintaining how tables and data relationships
    are defined and protected. There are four types of integrity: user defined, referential,
    entity, and domain.'
  prefs: []
  type: TYPE_NORMAL
- en: The mastering of data manipulation, database design, development, and administration
    is key to ensure that applications built using SQLite perform well, and are kept
    free from data crashes, data corruptions, and security issues.
  prefs: []
  type: TYPE_NORMAL
- en: When a column's datatype is set, it is a form of data integrity. Data integrity
    can be enhanced by only allowing certain values.
  prefs: []
  type: TYPE_NORMAL
- en: When a mechanism is designed to maintain the primary keys in a table by a unique
    tuple or row identifier, it is known as entity integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Referential integrity occurs when, for example, two tables are linked by a common
    column datatype and no new data can be added to one table without being added
    to the second. Referential integrity ensures that data is cleaned and linked properly.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **default values** for columns is valuable because it enforces data integrity
    and ensures that a value is entered on the database. It also means that some SQL
    statements are smaller than others. A standard type of statement without its column
    being added is an `id` field, where the primary key is defined, and when an `INSERT`
    statement is used, the `id` field is not required, as shown in the following.
  prefs: []
  type: TYPE_NORMAL
- en: The DBA can create columns to store `current_timestamp` in the database automatically,
    which is good for logging and time stamping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Constraint checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure that the right data is inputted into columns on a table, certain rules
    are imposed, and these are called constraints. These rules enforce data accuracy,
    limit corruption, and format issues and data reliability are increased and maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'At table level, it will apply to the whole table, but at column level, it will
    apply only to one certain column level. How they can be used is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.UNIQUE` constraint will make sure column data information is not the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.PRIMARY` key, each data row in the table is identified in SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.NOT NULL` makes sure that no column has a NULL value stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFAULT` will sets up a default value, when no value is specified or entered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When two or more tables need to link together on a common column, it is known
    as a **referencing key** or **foreign key**. SQLite supports relation integrity
    and supports foreign key constraints, like other databases. It is usually designed
    by the DBA and involves a column ID, for example, to match an ID on the second
    or third table.
  prefs: []
  type: TYPE_NORMAL
- en: 'There must be a logical reference between the table columns and actual data
    for it to perform well. SQLite will use the foreign key as part of the create
    table statement; an example is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Updating Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **VIEW** is a command that can use a combination of tables and joins to show
    the user or program a set of predefined data, as required. Effectively, it gives
    you a view of the data. You cannot `DELETE`, `UPDATE`, or `INSERT` from a view.
  prefs: []
  type: TYPE_NORMAL
- en: As a view is defined with a specific name, which is stored in the database,
    it can be effectively referenced as a table to another SQL statement, as part
    of a statement to be manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: If a keyword such as `Temporary` or `Temp` exists within the `create` and `view`
    words, then that view is only seen by that database connection and is removed
    upon the connection closing, hence the `temp/temporary` name.
  prefs: []
  type: TYPE_NORMAL
- en: If a database name is referenced when the view is created, it will reside within
    that specific database.
  prefs: []
  type: TYPE_NORMAL
- en: Index use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a table is created with its column and datatypes, it is almost ready to
    use. The primary columns for data linking are done, but it is not quite ready
    as defined by a DBA. Instead, an index can be created to speed up SQL queries
    and act as special lookup tables that SQLite will use as a way of getting information
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: An **index** has a data pointer, which will quickly reference the data and bring
    it back, thus making access quicker without much overhead generally. By definition,
    indexes do have an overhead in their own right, but the overheads of the index
    are dwarfed by the performance and efficiency gained. This could be useful for
    mobile applications because of their limited resource and network access.
  prefs: []
  type: TYPE_NORMAL
- en: A database index as an example is similar to the one located in a book, where
    you can find what you want because you know what it is, and just opens the book
    to right page, after reading the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The index is slow on data input but fast on the `SELECT` queries, with or without
    the `WHERE` clause. Once an index is created, it can also be dropped without affecting
    the core data of a table. The following is a simple example of an index called
    `table_index_name` being created on the `customer` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A second example shows how an index is created to reference a column called
    `salary`, which is used multiple times in many queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, an index will speed up access. An index called `table_index_salary` is
    created on the `customer` table, which is created on the `salary` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also indexes called **composite indexes**, which actually index more
    than one column on a database for further performance gains, but also an overhead
    on data input. As shown in the following, an index is created and is linked to
    two columns: `salary` and `bonus`. Rather than having two indexes with more overhead
    issues, a composite index maybe better, since it is one index with a reference
    to two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating indexes, the database server will also create implicit indexes
    that are automatic. If, as a DBA, you wish to see them, use the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Triggers** are an efficient way of using SQL commands to interact efficiently
    with the database. They are quick, and are embedded within the create `trigger`
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: A trigger is made up of a trigger name, references to the tables involved, an
    event of time (like before, or after value changes), the type of operation (like
    insert, update, or delete), with a variety of tables and columns to complete the
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax has to be right and the tests should ensure that the updates and
    changes are correct to ensure data concurrency and stability with no corruptions.
  prefs: []
  type: TYPE_NORMAL
- en: This trigger is called `update_customer_trigger`, which performs an `UPDATE`
    query on the `customers` table. The update is going to affect the `tel_no` column.
    So, the current telephone column `tel_no` is going to be updated, where it will
    equal the value from the new table, and its column `tel_no`—(`tel_no = new.tel_no`),
    where the link of customer name (`customer_name`), equals the `old.name` column.
  prefs: []
  type: TYPE_NORMAL
- en: Updated triggers must use specific columns for a table, which are predefined,
    unlike the `insert` or `delete` ones
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Synchronous writes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Synchronous writes** are part of the SQL engine, which will ensure that data
    changes are written to the disk area, as required, for transaction reasons and
    the way databases work. In the case of SQLite, these operate under different statuses
    or settings of `NORMAL`, `FULL`, or `OFF`. For performance reasons, SQLite commits
    can be switched off by the DBA as required.'
  prefs: []
  type: TYPE_NORMAL
- en: The `OFF` setting carries on its tasks quickly without much slowing down, minimal
    interruptions, and increased performance. However, in the case of a database crash,
    the data integrity will remain okay, but in the case of system crash and power
    loss, there is a good chance that corruption of the database itself may occur.
    There are performance gains to be made, but there are also risks associated with
    this move.
  prefs: []
  type: TYPE_NORMAL
- en: The `FULL` setting has to ensure that data is saved to disk properly and in
    good time before carrying on. This method is not good for performance, but is
    the most robust and the safest. If there are data corruptions or system crashes,
    users can be assured that no database corruption will occur.
  prefs: []
  type: TYPE_NORMAL
- en: The `NORMAL` setting will slow down at intervals to protect the data and commit
    transactions to disk. A database crash or a power failure could damage the database,
    but a more serious hardware error could be worse.
  prefs: []
  type: TYPE_NORMAL
- en: Database locking and deadlocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **deadlock** occurs when one or many actions or SQL statements compete for
    data access and table updates or manipulation at the same time as another process
    or action. Since it works with a transaction, one process can't move forward or
    complete because the other process or action holds, and is waiting for a resource,
    hence a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: So, in a database, records of process one would attempt to update, but process
    two would like to update some of the same rows, or a conflict of another table
    in which the transaction occurs. Some form of data locking mechanism to manage
    and reduce conflict must happen. Code around the transaction can be added with
    a retry indicator of three, for example, so if there is a deadlock, it will retry,
    and after the third attempt, it would roll back or give the user an opportunity
    to retry.
  prefs: []
  type: TYPE_NORMAL
- en: Deadlocking is a common occurrence in multithreaded and multiprocessing operating
    systems, which are performing a variety of tasks and attempting to complete with
    positive results.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example on how SQL transactions will end up in a deadlock.
    In this case, both transactions/sessions will be in a deadlock state. **Session
    2** will try to insert/write to the database and create a locking to get exclusive
    rights to protect, and ensure it can insert the record without any problem. **Session
    1** tries to write as well, which also causes a deadlock situation. Effectively,
    we have a situation where **Session 1** and **Session 2** do not want to lose
    access or control until the other leaves, which lets the deadlock continue, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Session 1 | Session 2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlite3>` | `sqlite3>` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `sqlite3>insert into temp(name,address) values(''Gene'',''London'');`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlite3> select * from temp;` |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | `sqlite3> commit;` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `SQL Error Message: database locked` |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlite3> insert into temp(name,address) values(''Gene'',''London'');` |
      |'
  prefs: []
  type: TYPE_TB
- en: '| `SQL Error Message: database locked` |   |'
  prefs: []
  type: TYPE_TB
- en: FMDB SQLite wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to using standard SQL, the FMDB SQLite wrapper, written in Objective-C,
    can be of assistance to those who prefer an alternative and easier way to work
    with SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the FMDB specification and code examples, refer to [https://github.com/ccgus/fmdb](https://github.com/ccgus/fm).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main classes in FMDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FMDatabase**: This is the single SQLite database that executes your SQL statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FMResultSet**: This will hold and display the output and results from the
    `FMDatabase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FMDatabaseQueue**: This will enable you to update and use many threads within
    this class if you want to perform queries and updates on multiple threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database creation and opening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The database is defined and allocated to a location and directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To engage with the database, you must connect and open it up, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: SQL in iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To select data, methods like `executeQuery` can be used to return the `FMResultSet`
    object if successful, or `0` upon failure. There are methods, such as `lastErrorMessage`
    or `lastErrorcode`, to find out if the query has worked or failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For multiple rows, `[FMResultSet next]` must be used to see or read the values
    returned from the query, even if the recordset is one, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows how to use `FMResultSet` to select multiple queries
    as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`FrmresultSet` offers several methods to the programmer to retrieve; some examples
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`intForColumn:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longForColumn:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longLongIntForColumn:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the aforementioned methods by default will have the `{type}ForColumnIndex:`
    variant, which will be used to get the data based on the position of the column
    in the rows and not the name itself.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code using `FMDatabase` comes from GitHub and is the standard
    code used for these types of operations. It has been used to improve the ease
    of interacting with SQLite, instead of the conventional standard method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the essentials of SQL in relation to the
    SQLite database, and also what you need to be aware of, and the knowledge required,
    to build SQL statements and interactions with SQLite and iOS as a basic start.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn all about exposing the C API, its impact
    and uses within IOS, and how it works as part of SQLite. The next chapter will
    also mention how the C API is at the core of SQLite and how it is used.
  prefs: []
  type: TYPE_NORMAL
