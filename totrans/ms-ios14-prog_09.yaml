- en: '*Chapter 9*: Fetching and Displaying Data from the Network'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：从网络获取和显示数据'
- en: Most modern applications communicate with a web service. Some apps rely on them
    heavily, acting as a layer that merely reads data from the web and displays it
    in app form. Other apps use the web to retrieve and sync data to make it locally
    available, and others only use the web as backup storage. Of course, there are
    a lot more reasons to use data from the internet than the ones mentioned.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代应用程序都会与Web服务进行通信。有些应用程序严重依赖它们，仅作为从网络上读取数据并在应用程序中以表单形式显示数据的层。其他应用程序使用Web来检索和同步数据，使其本地可用，而有些应用程序仅将Web用作备份存储。当然，使用互联网数据的原因远不止上述提到的这些。
- en: In this chapter, you will expand the **MustC** application, so it uses a web
    service to retrieve popularity ratings for the movies that family members have
    added as their favorites. These popularity ratings will be stored in the Core
    Data database and displayed together with the names of the movies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将扩展**MustC**应用程序，使其使用Web服务检索家庭成员添加为收藏的电影的流行度评分。这些流行度评分将存储在Core Data数据库中，并与电影名称一起显示。
- en: 'In this chapter, you''ll learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Fetching data from the web with `URLSession`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`URLSession`从网络上获取数据
- en: Working with JSON in Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Swift中使用JSON
- en: Updating Core Data objects with fetched data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用获取的数据更新Core Data对象
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code bundle for this chapter includes a starter project called `URLSession.playground`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包包含一个名为`URLSession.playground`的起始项目。
- en: You will also need to generate an API key from [https://www.themoviedb.org/](https://www.themoviedb.org/).
    Create an account on their website and request an API key on your account page.
    Setting this up should only take a couple of minutes, and if you want to follow
    along with this chapter, you will need to have your own API key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从[https://www.themoviedb.org/](https://www.themoviedb.org/)生成一个API密钥。在他们的网站上创建一个账户，并在账户页面上请求一个API密钥。设置这个过程只需几分钟，如果你想跟随本章的内容，你需要有自己的API密钥。
- en: 'After you have created and validated your account on [themoviedb.org](http://themoviedb.org),
    you can visit the following link to request an API key: [https://www.themoviedb.org/settings/api/request](https://www.themoviedb.org/settings/api/request).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在你已在[themoviedb.org](http://themoviedb.org/)上创建并验证了账户后，你可以访问以下链接来请求一个API密钥：[https://www.themoviedb.org/settings/api/request](https://www.themoviedb.org/settings/api/request)。
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%209%20-%20Fetching%20from%20Network](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%209%20-%20Fetching%20from%20Network).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%209%20-%20Fetching%20from%20Network](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%209%20-%20Fetching%20from%20Network)。
- en: Fetching data from the web with URLSession
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用URLSession从网络上获取数据
- en: Retrieving data from the web is something that you will often do as an iOS professional.
    You won't just fetch data from a web service; you'll also send data back to it.
    For example, you might have to make an HTTP POST request as part of a login flow
    or to update a user's profile information. Over time, iOS has evolved quite a
    bit in the web requests department, making it easier to use web services in apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络上检索数据是作为iOS专业人士你经常会做的事情。你不仅会从网络服务中获取数据，还会向其发送数据。例如，你可能需要作为登录流程的一部分或更新用户个人资料信息时发起一个HTTP
    POST请求。随着时间的推移，iOS在Web请求方面已经发展了很多，使得在应用程序中使用Web服务变得更加容易。
- en: Important Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: HTTP (or HTTPS) is a protocol that almost all web traffic uses for communication
    between a client, such as an app, and a server. The HTTP protocol supports several
    methods that signal the request's intent. GET is used to retrieve information
    from a server. A POST request indicates the intention to push new content to a
    server, such as, for instance, when submitting a form.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP（或HTTPS）是一种几乎所有网络流量都用于客户端（如应用程序）与服务器之间通信的协议。HTTP协议支持几种表示请求意图的方法。GET用于从服务器检索信息。POST请求表示将新内容推送到服务器的意图，例如，在提交表单时。
- en: When you want to perform a web request in iOS, you will typically use the `URLSession`
    class. The `URLSession` class makes asynchronous web requests on your behalf.
    This means that iOS loads data from the web on a background thread, ensuring that
    the user interface remains responsive throughout the entire request. If a web
    request is performed synchronously, the user interface is unresponsive for the
    duration of the network request because a thread can only do one thing at a time,
    so if it's waiting for a response from the network, it can't respond to touches
    or any other user input.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在 iOS 中执行网络请求时，您通常会使用 `URLSession` 类。`URLSession` 类代表您执行异步网络请求。这意味着 iOS 在后台线程上从网络加载数据，确保在整个请求过程中用户界面保持响应。如果执行同步网络请求，用户界面在网络请求期间将无响应，因为线程一次只能做一件事，所以如果它在等待网络响应，它就不能响应触摸或任何其他用户输入。
- en: If your user has a slow internet connection, a request could take several seconds.
    You don't want the interface to freeze for several seconds. Even a couple of milliseconds
    will create a noticeable drop in its responsiveness and frame rate. This can be
    easily avoided by using `URLSession` to perform asynchronous network requests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的用户拥有慢速的互联网连接，一个请求可能需要几秒钟。您不希望界面冻结几秒钟。即使是几毫秒也会导致其响应性和帧率明显下降。通过使用 `URLSession`
    来执行异步网络请求可以轻松避免这种情况。
- en: First, you will experiment with basic network requests in a playground. You
    can create a new playground or use the one provided in this book's code bundle.
    After you've seen the basics of `URLSession`, you'll implement a way to fetch
    movies from an open source movie database and put this implementation to use in
    the MustC app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将在游乐场中实验基本的网络请求。您可以创建一个新的游乐场或使用本书代码包中提供的游乐场。在您了解了 `URLSession` 的基础知识之后，您将实现从开源电影数据库获取电影的方法，并将此实现用于
    MustC 应用。
- en: Understanding the basics of URLSession
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 URLSession 的基础知识
- en: Making network calls is one of the fundamental tasks of every app that needs
    to fetch, post, or modify remote data. It is one of the most common tasks that
    a developer faces every day. For this task, Apple provides developers with the
    `URLSession` class. The `URLSession` class helps developers to work with remote
    data easily and by coordinating a group of related network data-transfer tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 进行网络调用是每个需要获取、发布或修改远程数据的应用的基石任务之一。这是开发者每天面临的最常见任务之一。为此任务，苹果为开发者提供了 `URLSession`
    类。`URLSession` 类帮助开发者轻松地处理远程数据，并通过协调一系列相关的网络数据传输任务。
- en: 'The following code snippet shows a sample network request that loads the [https://apple.com](https://apple.com)
    home page:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了加载 [https://apple.com](https://apple.com) 首页的示例网络请求：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is an elementary example: a URL is created, and then the shared `URLSession`
    instance is used to create a new `dataTask`. This `dataTask` is an instance of
    `URLSessionDataTask` and allows you to load data from a remote server.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的示例：创建一个 URL，然后使用共享的 `URLSession` 实例创建一个新的 `dataTask`。这个 `dataTask` 是
    `URLSessionDataTask` 的一个实例，允许您从远程服务器加载数据。
- en: Alternatively, you could use a download task if you're downloading a file, or
    an upload task if you're uploading files to a web server. After creating the task,
    you must call `resume` on the task, because new tasks are always created in a
    suspended state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您正在下载文件，可以使用下载任务；如果您正在将文件上传到网络服务器，可以使用上传任务。在创建任务后，您必须调用任务上的 `resume`，因为新任务总是以挂起状态创建。
- en: 'If you run this sample in an empty playground, you''ll find that the example
    doesn''t work. Because the network request is made asynchronously, the playground
    finishes its execution before the network request is complete. To fix this, you
    should make sure that the playground runs indefinitely. Doing so will allow the
    network request to finish. Add the following lines to the top of the playground
    source file to enable this behavior:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个空的游乐场中运行此示例，您会发现示例无法工作。因为网络请求是异步进行的，所以游乐场在网络请求完成之前就已经执行完毕。为了解决这个问题，您应该确保游乐场无限期地运行。这样做将允许网络请求完成。将以下行添加到游乐场源文件的顶部以启用此行为：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that the playground runs indefinitely, you''ll find that there isn''t a
    lot of useful data printed to the console. In this case, you''re not interested
    in the raw data, HTTP headers, or the fact that the error is nil. When you load
    data from a URL, you''re often most interested in the response''s body. The body
    of a response usually contains the string representation of the data you requested.
    In the case of the preceding example, the body is the HTML that makes up Apple''s
    home page. Let''s see how you can extract this HTML from the response. Replace
    the data task''s completion callback with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在沙盒运行无限期，您会发现控制台打印出来的有用数据并不多。在这种情况下，您对原始数据、HTTP头部或错误为nil的事实并不感兴趣。当您从URL加载数据时，您通常最感兴趣的是响应的主体。响应的主体通常包含您请求的数据的字符串表示。在先前的例子中，主体是构成苹果主页的HTML。让我们看看您如何从响应中提取这个HTML。将数据任务完成回调替换为以下内容：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding callback closure makes sure that there are no errors returned
    by the web service and that there is data present. Then, the raw data is converted
    to a string, and that string is printed to the console. If you use this callback
    instead of the old one, you'll see the HTML for the Apple home page printed. Simple
    requests to a web server like the one you just saw are relatively simple to implement
    with `URLSession`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的回调闭包确保了没有错误被网络服务返回，并且存在数据。然后，原始数据被转换成字符串，并将该字符串打印到控制台。如果您使用这个回调而不是旧的回调，您将看到苹果主页的HTML被打印出来。像您刚才看到的对网络服务器的简单请求，使用`URLSession`实现起来相对简单。
- en: If you need to customize your network request (for example, to add custom headers)
    rather than using the simple `dataTask` function with a URL, you need to create
    your own `URLRequest` instance, instead of letting `URLSession` do it. The example
    you saw is one where you let `URLSession` create the `URLRequest` on your behalf.
    This is fine if you want to perform a simple HTTP GET request with no custom headers,
    but if you're going to post data or include specific headers, you will need to
    have more control over the request that's used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要自定义网络请求（例如，添加自定义头部），而不是使用带有URL的简单`dataTask`函数，您需要创建自己的`URLRequest`实例，而不是让`URLSession`为您创建。您看到的例子是您让`URLSession`代表您创建`URLRequest`的情况。如果您只想执行一个没有自定义头部的简单HTTP
    GET请求，这是可以的，但如果您要发送数据或包含特定的头部，您将需要更多控制请求的方式。
- en: 'Let''s take a look at what a GET request with some parameters and a custom
    header looks like. The following code uses an API key from [https://www.themoviedb.org/](https://www.themoviedb.org/).
    If you want to try this code example, create an account on their website and request
    an API key on your account page. Setting this up should only take a couple of
    minutes, and if you want to follow along with this chapter, you will need to have
    your own API key. After you have created and validated your account on [themoviedb.org](http://themoviedb.org),
    you can visit the following link to request an API key: [https://www.themoviedb.org/settings/api/request](https://www.themoviedb.org/settings/api/request):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看带有一些参数和自定义头部的GET请求是什么样的。以下代码使用了来自[https://www.themoviedb.org/](https://www.themoviedb.org/)的API密钥。如果您想尝试这个代码示例，请在他们网站上创建一个账户，并在账户页面请求一个API密钥。设置这个过程只需要几分钟，如果您想跟随本章内容，您将需要自己的API密钥。在您在[themoviedb.org](http://themoviedb.org)上创建并验证账户后，您可以访问以下链接来请求一个API密钥：[https://www.themoviedb.org/settings/api/request](https://www.themoviedb.org/settings/api/request)。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is a bit more complicated than the example you saw before.
    In this example, a more complex URL request is configured that includes some HTTP
    GET parameters. The `httpMethod` value for `URLRequest` is specified, and a custom
    header is provided to inform the receiver of this request about the type of response
    it would like to receive.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码比您之前看到的例子要复杂一些。在这个例子中，配置了一个更复杂的URL请求，其中包含了一些HTTP GET参数。`URLRequest`的`httpMethod`值被指定，并提供了一个自定义的头部信息，以便通知接收者它希望接收哪种类型的响应。
- en: The flow for executing this URL request is the same as the one you saw earlier.
    However, the URL that is loaded responds with a JSON string instead of an HTML
    document. JSON is used by many APIs as the preferred format to pass data around
    on the web. In order to use this response, the raw data must be converted to a
    useful data structure. In this case, a dictionary will do. If you haven't seen
    or worked with JSON before, it's a good idea to take a step back and read up on
    the JSON data format because this chapter will continue under the assumption that
    you are at least somewhat familiar with JSON.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此URL请求的流程与之前看到的一样。然而，加载的URL响应返回的是JSON字符串而不是HTML文档。JSON被许多API用作在网络上传递数据的首选格式。为了使用此响应，必须将原始数据转换为有用的数据结构。在这种情况下，字典将
    suffice。如果你之前没有见过或处理过JSON，那么退一步阅读有关JSON数据格式的资料是个好主意，因为本章将继续假设你至少对JSON有些许了解。
- en: Working with JSON in Swift
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Swift中使用JSON
- en: 'The following snippet shows how you can convert raw data to a JSON dictionary.
    Working with JSON in Swift can be a little tedious at times, but overall, it''s
    a generally good experience. Let''s look at the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将原始数据转换为JSON字典。在Swift中使用JSON有时可能会有些繁琐，但总体来说，它是一个一般良好的体验。让我们看看以下示例：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding snippet converts the raw data that is returned by a URL request
    to a JSON object. The `print` statement prints a readable version of the response
    data, but it's not quite ready to be used. Let's see how you gain access to the
    first available movie in the response.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将URL请求返回的原始数据转换为JSON对象。`print`语句打印出可读的响应数据版本，但它还不是可以直接使用的。让我们看看如何访问响应中第一个可用的电影。
- en: 'If you look at the type of object returned by the `jsonObject(with:options:)`
    method, you''ll see that it returns `Any`. This means that you must typecast the
    returned object to something you can work with, such as an array or a dictionary.
    When you inspect the JSON response that the API returned, for instance by using
    `print` to make it appear in the console as you did with Apple''s home page HTML,
    you''ll notice that there''s a dictionary that has a key called `results`. The
    `results` object is an array of movies. In other words, it''s an array of `[String:
    Any]`, because every movie is a dictionary, where strings are the keys and the
    value can be a couple of different things, such as Strings, Int, or Booleans.
    With this information, you can access the first movie''s title in the JSON response,
    as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你查看`jsonObject(with:options:)`方法返回的对象类型，你会看到它返回`Any`。这意味着你必须将返回的对象类型转换为可以处理的对象，例如数组或字典。当你检查API返回的JSON响应时，例如使用`print`使其在控制台显示，就像你处理苹果主页HTML那样，你会注意到有一个键名为`results`的字典。`results`对象是一个电影数组。换句话说，它是一个`[String:
    Any]`类型的数组，因为每部电影都是一个字典，其中字符串是键，值可以是几种不同类型，例如字符串、整数或布尔值。有了这些信息，你可以访问JSON响应中的第一部电影标题，如下面的代码所示：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Working with dictionaries to handle JSON isn't the best experience. Since the
    JSON object is of the `AnyObject` type and you need to typecast every element
    in the dictionary you want to access, there's a lot of boilerplate code you need
    to add.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典处理JSON并不是最佳体验。由于JSON对象是`AnyObject`类型，并且你需要将你想要访问的字典中的每个元素都进行类型转换，因此你需要添加大量的模板代码。
- en: Luckily, Swift has better ways to create instances of objects from the JSON
    data. The following example shows how you can quickly create an instance of a
    `Movie` struct without having to cast all the keys in the JSON dictionary to the
    correct types for the `Movie` struct.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Swift有更好的方法从JSON数据创建对象实例。以下示例展示了如何快速创建一个`Movie`结构体实例，而无需将JSON字典中所有键转换为`Movie`结构体的正确类型。
- en: 'First, let''s define two structs, one for the `Movie` itself, and one for the
    response that contains the array of `Movie` instances:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义两个结构体，一个用于`Movie`本身，另一个用于包含`Movie`实例数组的响应：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, you can use the following snippet to quickly convert the raw data from
    a URL request to an instance of `MoviesResponse`, where all movies are converted
    to instances of the `Movie` struct:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用以下代码片段快速将URL请求的原始数据转换为`MoviesResponse`实例，其中所有电影都转换为`Movie`结构体实例：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might notice that both `MoviesResponse` and `Movie` conform to the `Codable`
    protocol. The `Codable` protocol was introduced in Swift 4, and it allows you
    to easily encode and decode data objects. The only requirement is that all properties
    of a `Codable` object conform to the `Codable` protocol. A lot of built-in types,
    such as `Array`, `String`, `Int`, `Float`, and `Dictionary`, conform to `Codable`.
    Because of this, you can easily convert an encoded JSON object into a `MoviesResponse`
    instance that holds `Movie` instances.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`MoviesResponse`和`Movie`都遵循了`Codable`协议。`Codable`协议是在Swift 4中引入的，它允许你轻松地编码和解码数据对象。唯一的要求是`Codable`对象的全部属性都必须遵循`Codable`协议。许多内置类型，如`Array`、`String`、`Int`、`Float`和`Dictionary`都遵循`Codable`。正因为如此，你可以轻松地将编码后的JSON对象转换为包含`Movie`实例的`MoviesResponse`实例。
- en: 'By default, each property name should correspond to the key of the JSON response
    it is mapped to. However, sometimes you might want to customize this mapping.
    For instance, the `poster_path` property in the response we''ve been working with
    so far would be best mapped to a `posterPath` property on the `Movie` struct,
    according to the general Swift guidelines for property naming. The following example
    shows how you would tackle these circumstances:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个属性名称应与其映射到的JSON响应键相对应。然而，有时你可能想要自定义这种映射。例如，我们一直在处理响应中的`poster_path`属性，根据一般的Swift属性命名指南，最好将其映射到`Movie`结构体上的`posterPath`属性。以下示例显示了如何处理这些情况：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By specifying a `CodingKeys` enum, you can override how the keys in the JSON
    response should be mapped to your `Codable` object. You must cover all keys that
    are mapped, including the ones you don't want to change. As you've seen, the `Codable`
    protocol provides powerful tools for working with data from the network. Custom
    key mapping makes this protocol even more powerful because it allows you to shape
    your objects exactly how you want them, instead of having the URL responses dictate
    the structure to you.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定一个`CodingKeys`枚举，你可以覆盖JSON响应中的键如何映射到你的`Codable`对象。你必须覆盖所有映射的键，包括你不想更改的键。正如你所看到的，`Codable`协议提供了处理网络数据的有力工具。自定义键映射使此协议更加强大，因为它允许你按照自己的意愿塑造对象，而不是让URL响应为你指定结构。
- en: 'If the only conversion you need to apply in the coding keys is converting from
    snake case (`poster_path`) to camel case (`posterPath`), you don''t have to specify
    the coding keys yourself. The `JSONDecoder` object can automatically apply this
    type of conversion when decoding data if you set its `keyDecodingStrategy` to
    `.convertFromSnakeCase`, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编码键中你需要应用的唯一转换是将蛇形命名（`poster_path`）转换为驼峰命名（`posterPath`），你不需要自己指定编码键。当解码数据时，如果将`JSONDecoder`对象的`keyDecodingStrategy`设置为`.convertFromSnakeCase`，它将自动应用这种类型的转换，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By applying these lines of code, the decoder will automatically translate property
    names such as `poster_path` into the `posterPath` syntax. Try implementing this
    in your playground and remove `CodingKeys` from the `Movie` object to ensure your
    JSON decoding still works.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用这些代码行，解码器将自动将属性名称如`poster_path`转换为`posterPath`语法。尝试在你的沙盒中实现这一点，并从`Movie`对象中移除`CodingKeys`以确保你的JSON解码仍然有效。
- en: In this section, we have learned how to work with JSON data and how to decode
    it into our own entities. Now let's move on to storing the fetched data in the
    Core Data database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何处理JSON数据以及如何将其解码为我们自己的实体。现在让我们继续学习如何将获取的数据存储在Core Data数据库中。
- en: Updating Core Data objects with fetched data
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用获取的数据更新Core Data对象
- en: So far, the only thing you have stored in Core Data is movie names. You will
    expand this functionality by performing a lookup for a certain movie name through
    the movie database API. The fetched information will be used to display and store
    a popularity rating for the movies in the Core Data database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你存储在Core Data中的唯一内容是电影名称。你将通过电影数据库API对某个电影名称进行查找来扩展这一功能。获取的信息将用于在Core
    Data数据库中显示和存储电影的流行度评分。
- en: 'A task such as this seems straightforward at first; you could come up with
    a flow such as the one shown in the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的任务一开始看起来很简单；你可以想出一个如以下步骤所示的流程：
- en: The user indicates their favorite movie.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户表明他们的最爱电影。
- en: The movie's popularity rating is fetched.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取电影的流行度评分。
- en: The movie and its rating are stored in the database.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电影及其评分存储在数据库中。
- en: The user interface updates with the new movie. At first glance, this is a fine
    strategy; insert the data when you have it. However, it's important to consider
    that API calls are typically done asynchronously so the user interface stays responsive.
    More importantly, API calls can be really slow if your user doesn't have a good
    internet connection. This means that you would be updating the interface with
    some very noticeable lag if the preceding steps are executed one by one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面随着新电影更新。乍一看，这是一个不错的策略；当你有数据时插入数据。然而，重要的是要考虑 API 调用通常是异步进行的，这样用户界面才能保持响应。更重要的是，如果你的用户没有良好的互联网连接，API
    调用可能会非常慢。这意味着如果前面的步骤逐个执行，你将会在界面上看到一些非常明显的延迟。
- en: 'The following would be a much better approach to implement the feature at hand:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现当前功能的更好方法：
- en: The user indicates their favorite movie.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户表明他们的最爱电影。
- en: The user stores the movie.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户存储电影。
- en: Update the user interface with the new movie.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新电影更新用户界面。
- en: Begin popularity fetching.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始获取流行度。
- en: Update the movie in the database.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据库中的电影。
- en: Update the user interface with the popularity.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用流行度更新用户界面。
- en: This approach is somewhat more complex, but it will give the user a responsive
    experience. The user interface responds to new movies immediately by showing them,
    and then automatically updates as soon as new data is retrieved. Before you can
    fetch the data and update the models, the Core Data model must be modified in
    order to store the given movie's popularity rating.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法稍微复杂一些，但它会给用户带来响应式的体验。用户界面会立即显示新电影，并在获取新数据后自动更新。在你能够获取数据并更新模型之前，必须修改 Core
    Data 模型以便存储给定电影的流行度评分。
- en: 'Open the `popularity`. Select the `Double` type for this property because `popularity`
    is stored as a decimal value. You have to make sure that this property is optional
    since you won''t be able to provide a value for it straight away:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `popularity`。为此属性选择 `Double` 类型，因为 `popularity` 存储为十进制值。你必须确保这个属性是可选的，因为你不能立即提供它的值：
- en: '![Figure 9.1 – Add the popularity attribute to the Movie entity'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 将流行度属性添加到电影实体'
- en: '](img/B14717_09_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14717_09_01.jpg)'
- en: Figure 9.1 – Add the popularity attribute to the Movie entity
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 将流行度属性添加到电影实体
- en: If you've worked with Core Data prior to when iOS 10 was released, this is the
    part where you expect to read about migrations and how you can orchestrate them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在 iOS 10 发布之前使用过 Core Data，那么你期望在这里读到关于迁移以及如何编排它们的内容。
- en: However, for simple changes like this, we don't need to manually manage migrations.
    All you need to do is simply build and run your application to regenerate your
    model definitions, and for a simple change, such as the one we performed just
    now, Core Data will automatically manage the migration for us.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于像这样的简单更改，我们不需要手动管理迁移。你所需要做的就是简单地构建并运行你的应用程序来重新生成你的模型定义，对于像我们刚才所做的这种简单更改，Core
    Data 将会自动为我们管理迁移。
- en: Important Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you want to support iOS versions earlier than 10, make sure you read up
    on Core Data migrations. Whenever you update your models, you have to make sure
    that your database can properly migrate from one model version to another. During
    development, this isn''t extremely important: you just reinstall the app whenever
    your models change. However, app updates will crash on launch if the Core Data
    model isn''t compatible with the previous model.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要支持低于 iOS 10 的版本，确保你阅读有关 Core Data 迁移的内容。每次你更新你的模型时，你必须确保你的数据库能够正确地从一种模型版本迁移到另一种模型版本。在开发过程中，这并不是非常重要：当你的模型发生变化时，你只需重新安装应用程序。然而，如果
    Core Data 模型与先前模型不兼容，应用程序更新将导致启动时崩溃。
- en: Now that the Core Data model is updated, let's figure out how to implement the
    flow that was described earlier.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Core Data 模型已经更新，让我们来找出如何实现之前描述的流程。
- en: Implementing the fetch logic
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现获取逻辑
- en: The asynchronous nature of network requests makes certain tasks, such as the
    one you're about to implement, quite complex. Usually, when you write code, its
    execution is very predictable. Your app typically runs line by line, sequentially,
    so any line that comes after the previous one can assume that the line before
    it has finished executing. This isn't the case with asynchronous code. Asynchronous
    code is taken off the main thread and runs separately from the rest of your code.
    This means that your asynchronous code might run in parallel with other code.
    In the case of a network request, the asynchronous code might execute seconds
    after the function that initiated the request.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 网络请求的异步特性使得某些任务，比如你即将要实现的任务，相当复杂。通常，当你编写代码时，其执行是非常可预测的。你的应用通常是逐行、顺序执行的，所以任何在上一行之后的行都可以假设上一行已经执行完毕。异步代码不是这样。异步代码被从主线程上移除，并独立于其他代码运行。这意味着你的异步代码可能会与其他代码并行运行。在网络请求的情况下，异步代码可能会在发起请求的函数执行几秒后执行。
- en: This means that you need to figure out a way to update and save movies that
    were added as soon as the rating was retrieved. However, it's important that you're
    aware of the fact that it's not as straightforward as it may seem at first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要想出一个方法来更新和保存那些在获取评分后立即添加的电影。然而，重要的是你要意识到这并不像最初看起来那么简单。
- en: It's also important that you're aware of the fact that the code you're about
    to look at is executed on multiple threads. This means that even though all pieces
    of the code are defined in the same place, they are not executed sequentially.
    The callback for the network request is executed on a different thread than the
    code that initiated the network request. You have already learned that Core Data
    is not thread-safe. This means that you can't safely access a Core Data object
    on a different thread than the thread it was created on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你要意识到你即将查看的代码是在多个线程上执行的。这意味着尽管所有代码片段都在同一个地方定义，但它们并不是按顺序执行的。网络请求的回调是在发起网络请求的代码所在的另一个线程上执行的。你已经了解到Core
    Data不是线程安全的。这意味着你不能在创建它的线程之外安全地访问Core Data对象。
- en: If this confuses you, that's okay. You're supposed to be a bit confused right
    now. Asynchronous programming is not easy and fooling you into thinking it is
    will cause frustration once you run into concurrency-related troubles (and you
    will). Whenever you work with callbacks, closures, and multiple threads, you should
    be aware that you're doing complex work that isn't straightforward.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到困惑，那没关系。你现在应该有点困惑。异步编程并不容易，一旦你遇到并发相关的问题（你会的），会让你感到沮丧。无论何时你与回调、闭包和多个线程一起工作，你应该意识到你正在做复杂的工作，而不是简单的工作。
- en: Now that you understand that asynchronous code is hard, let's take a closer
    look at the feature you're about to implement. It's time to start implementing
    the network request that fetches popularity ratings for movies. You will abstract
    the fetching logic into a helper named `MovieDBHelper`. Go ahead and create a
    new `Helper` folder in Xcode and add a new Swift file called `MovieDBHelper.swift`
    to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解到异步代码很难，让我们更仔细地看看你即将要实现的功能。是时候开始实现获取电影流行度评分的网络请求了。你将把获取逻辑抽象到一个名为`MovieDBHelper`的辅助函数中。继续在Xcode中创建一个新的`Helper`文件夹，并向其中添加一个名为`MovieDBHelper.swift`的新Swift文件。
- en: Abstracting this logic into a helper has multiple advantages. One of them is
    simplicity; it will keep our view controller code nice and clean. Another advantage
    is flexibility. Let's say that you want to combine multiple rating websites, or
    a different API, or compute the popularity of movies based on the number of family
    members who added this same title to their list; it will be easier to implement
    since all the logic for ratings is in a single place.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将此逻辑抽象到辅助函数中有多个优点。其中之一是简单性；它将使我们的视图控制器代码保持整洁。另一个优点是灵活性。假设你想结合多个评分网站，或者不同的API，或者根据添加相同标题到列表中的家庭成员数量来计算电影的流行度；由于所有评分逻辑都在一个地方，因此实现起来会更简单。
- en: 'Add the following skeleton implementation to the `MovieDBHelper` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下骨架实现添加到`MovieDBHelper`文件中：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code starts off with an interesting line:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从一行有趣的语句开始：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line specifies the type that's used for the callback closure that's called
    when the rating is fetched. This callback will receive an optional `Double` as
    its argument. If the network request fails for any reason, the `Double` will be
    nil. Otherwise, it contains the rating for the movie that the request was created
    for.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行指定了在获取评分时调用的回调闭包所使用的类型。这个回调将接收一个可选的`Double`作为其参数。如果网络请求因任何原因失败，则`Double`将为`nil`。否则，它包含请求创建的电影的评分。
- en: 'The snippet also contains a `fetchRating` dummy method that performs the fetch;
    you will implement this method soon. Finally, there''s a `url(forMovie movie:
    String)` method that builds a URL. This method is private because it''s only supposed
    to be used inside of the helper struct. Note that the movie is converted to a
    percent-encoded string. This is required because if your user were to add a movie
    with spaces in it, you would end up with an invalid URL if the spaces aren''t
    properly encoded.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '该片段还包含一个`fetchRating`占位方法，用于执行获取操作；你很快就会实现这个方法。最后，有一个`url(forMovie movie: String)`方法来构建URL。这个方法之所以是私有的，是因为它只应该在辅助结构内部使用。注意，电影被转换为一个百分编码字符串。这是必需的，因为如果你的用户添加了一个包含空格的电影，如果空格没有被正确编码，你最终会得到一个无效的URL。'
- en: 'Before you implement `fetchRating(forMovie:callback)`, add a new file named
    `MovieDBResponse.swift` to the `Helper` folder. This file will be used to define
    a struct that represents the response we expect to receive from [api.themoviedb.org](http://api.themoviedb.org).
    Add the following implementation to this file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在你实现`fetchRating(forMovie:callback)`之前，向`Helper`文件夹中添加一个名为`MovieDBResponse.swift`的新文件。这个文件将用于定义一个结构体，它代表我们从[api.themoviedb.org](http://api.themoviedb.org)期望接收到的响应。将以下实现添加到这个文件中：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code uses a nested struct to represent the movie objects that
    are part of the response. This is similar to what you saw in the playground example
    in the *Fetching data from the web with URLSession* section at the beginning of
    this chapter. Structuring the response this way makes the intent of this helper
    very obvious, which usually makes code easier to reason about. With this struct
    in place, replace the implementation of `fetchRating(forMovie:callback)` inside
    `MovieDBHelper` with the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用嵌套结构来表示响应中的电影对象。这与你在本章开头“使用URLSession从网络获取数据”部分中看到的游乐场示例类似。以这种方式结构化响应使得这个辅助函数的意图非常明显，这通常使得代码更容易推理。有了这个结构，将`MovieDBHelper`中的`fetchRating(forMovie:callback)`的实现替换为以下内容：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This implementation looks very similar to what you experimented with earlier
    in the playground. The URL-building method is used to create a valid URL. If this
    fails, it makes no sense to attempt requesting the movie's rating, so the callback
    is called with a `nil` argument. This will inform the caller of this method that
    the execution is completed, and no result was retrieved.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现看起来与你在游乐场中早期实验的非常相似。使用URL构建方法来创建一个有效的URL。如果这失败了，尝试请求电影的评分就没有意义了，所以回调函数会使用一个`nil`参数被调用。这将通知调用此方法的用户执行已完成，但没有检索到结果。
- en: 'Next, a new data task is created and `resume()` is called on this task to kick
    it off. There is an interesting aspect to how the callback for this data task
    is called, though. Let''s take a look at the following lines of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建了一个新的数据任务，并在这个任务上调用`resume()`来启动它。然而，这个数据任务的回调调用有一个有趣的方面。让我们看看以下几行代码：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A `rating optional Double` is created here, and it is given an initial value
    of `nil`. Then there's a `defer` block. The code inside of the `defer` block is
    called right before exiting the scope. In other words, it's executed right before
    the code returns from a function or closure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里创建了一个`rating optional Double`，并给它一个初始值`nil`。然后有一个`defer`块。`defer`块中的代码在退出作用域之前被调用。换句话说，它是在代码从函数或闭包返回之前执行的。
- en: Since this `defer` block is defined inside the callback for the data task, the
    callback for the `fetchRating(forMovie:callback:)` method is always called just
    before the data task callback is exited. This is convenient because all you must
    do is set the value for the rating to `double`, and you don't have to manually
    invoke the callback for each possible way the scope can be exited. This also applies
    when you return because of unmet requirements. For instance, if there is an error
    while calling the API, you don't need to invoke the callback. You can simply return
    from the closure, and the callback is called automatically. This strategy can
    also be applied if you instantiate or configure objects temporarily and you want
    to perform some clean-up when the method, function, or closure is done.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个`defer`块是在数据任务回调内部定义的，因此`fetchRating(forMovie:callback:)`方法的回调总是在数据任务回调退出之前被调用。这很方便，因为你只需要将评分的值设置为`double`，而且你不需要手动调用每个可能的退出范围的回调。当因为未满足的要求而返回时，这也适用。例如，如果在调用API时发生错误，你不需要调用回调。你可以简单地从闭包中返回，回调会自动调用。如果你临时实例化或配置对象，并且希望在方法、函数或闭包完成后执行一些清理操作，这种策略也可以应用。
- en: The rest of the code should be fairly straightforward since most of it is nearly
    identical to the code used in the playground. Now that you have the networking
    logic down, let's take a look at how to actually update the `movie` object with
    a popularity rating.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分应该相当直接，因为其中大部分几乎与在游乐场中使用的代码相同。现在你已经掌握了网络逻辑，让我们看看如何实际上更新`movie`对象以包含流行度评分。
- en: Updating a movie with a popularity rating
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新电影流行度评分
- en: 'To update the `movie` object, you will implement the final step of the approach
    that was outlined earlier. You need to asynchronously fetch a rating from the
    movie database and then use that rating to update the movie. The following code
    should be added to `MoviesViewController.swift`, inside the `saveMovie(withName
    name: String)` method right after the `familyMember.movies = NSSet(set: newFavorites`
    line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '要更新`movie`对象，你需要实现前面概述的方法的最终步骤。你需要异步从电影数据库中获取评分，然后使用该评分来更新电影。以下代码应添加到`MoviesViewController.swift`中的`saveMovie(withName
    name: String)`方法，在`familyMember.movies = NSSet(set: newFavorites`行之后：'
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that the helper abstraction provides a nice interface for the view
    controller. You can simply use the helper and provide it a movie to fetch the
    rating for with a callback and you're all set. Abstracting code like this can
    make maintaining your code a lot more fun in the long run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，辅助抽象为视图控制器提供了一个很好的接口。你可以简单地使用辅助工具，并给它一个电影，通过回调获取评分，然后你就准备好了。像这样抽象代码可以使你长期维护代码变得更加有趣。
- en: The most surprising thing in the preceding snippet is that `moc.persist` is
    called again inside of the `helper` callback. This must be done because this callback
    is actually executed long after the initial `persist` has finished. Actually,
    this callback isn't even executed on the same thread as the code it's surrounded
    by.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中最令人惊讶的是，在`helper`回调内部再次调用了`moc.persist`。这是因为这个回调实际上是在初始`persist`完成很长时间后才执行的。实际上，这个回调甚至不是在它周围的代码所在的同一个线程上执行的。
- en: 'To see how your code fails if you don''t properly persist your model, try replacing
    the `moc.persist` block in the rating retrieval callback with the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的代码在没有正确持久化模型时如何失败，尝试将评分检索回调中的`moc.persist`块替换为以下代码：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you add a new movie now, the rating will still be fetched. However, you will
    suddenly run into issues when reloading your table view. This is because the managed
    object context was saved on a background thread. This means that the notification
    that informs the table view about updates is also sent on a background thread.
    You could resolve the issue by pushing the `reloadData()` call onto the main thread
    as you've done before, but in this case, doing so would only make the problem
    worse. Your app might work fine for a while, but once your app grows in complexity,
    using the same managed object context in multiple threads will most certainly
    cause crashes. Therefore, it's important to always make sure that you access managed
    objects and their contexts on the correct thread by using a construct, such as
    the `persist` method we implemented for this app.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have looked at all the code involved, let's see what all this threading
    talk means in a more visual way.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing multiple threads
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram will help you understand multiple threads:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Threads diagram'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14717_09_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Threads diagram
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: When `saveMovie(withName:)` is called, the execution is still on the main thread.
    The persistence block is opened, the movie is created, its name is set, a helper
    is created, and then `fetchRating(forMovie:callback:)` is called on the helper.
    This call itself is still on the main thread. However, the fetching of data is
    pushed to a background thread. This was discussed earlier when you experimented
    with fetching data in a playground.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The callback that's invoked by `dataTask` is called on the same background thread
    that the task itself is on. The code will do its thing with the JSON and finally,
    the callback that was passed to `fetchRating(forMovie:callback:)` is called. The
    code inside of this callback is executed on the background thread as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the set movie-rating step in the update flow is somehow pushed
    back to the main thread. This is because of the `persist` method that you added
    as an extension to the managed object context. The context uses the `perform`
    method internally to ensure that any code we execute inside of the `persist` block
    is executed on the thread the managed object context is on. Also, since the managed
    object context was created on the main thread, the movie rating will be set on
    the main thread.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: If you didn't set the movie rating on the same thread that the managed object
    belongs to, you would get errors and undefined behavior. Always make sure that
    you manipulate Core Data objects on the same thread as their managed object context.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Threading is a complex subject, but it's essential for building responsive applications.
    Network logic is a great example of why multithreading is important. If we didn't
    perform the networking on a separate thread, the interface would be unresponsive
    for the duration of the request. If you have other operations that might take
    a while in your app, consider moving them onto a background thread so they don't
    block the user interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一个复杂的话题，但对于构建响应式应用程序来说至关重要。网络逻辑是为什么多线程很重要的一个很好的例子。如果我们不在单独的线程上执行网络操作，界面将在请求期间无响应。如果你在应用程序中还有其他可能需要较长时间的操作，考虑将它们移动到后台线程，这样它们就不会阻塞用户界面。
- en: All of the code is in place, and you have a better understanding of multithreading
    and how callbacks can be used in a multithreaded environment. Yet, if you build
    and run your app and add a new movie, the rating won't be displayed yet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都已就绪，你对多线程和如何在多线程环境中使用回调有了更好的理解。然而，如果你构建并运行你的应用程序并添加一部新电影，评分尚未显示。
- en: 'The following are the three reasons why this is happening:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是发生这种情况的三个原因：
- en: The table view cell that shows the movie isn't updated yet.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示电影的表格视图单元格尚未更新。
- en: The network request doesn't succeed because of **App Transport Security**.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络请求因 **应用传输安全** 而失败。
- en: Updates to movie objects aren't observed yet.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影对象的更新尚未被观察。
- en: Let's solve these issues in order, starting with the table view cell.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序解决这些问题，首先是表格视图单元格。
- en: Adding the rating to the movie cell
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将评分添加到电影单元格
- en: Currently, the movie table view displays cells that have a title. `UITableViewCell`
    has a built-in option to display a title and a subtitle for a cell.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，电影表格视图显示带有标题的单元格。`UITableViewCell` 有一个内置选项来显示单元格的标题和副标题。
- en: Open `Main.storyboard` and select the prototype cell for the movies. In the
    `detailTextLabel` on the table view cell. This is where we'll display the movie
    rating.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Main.storyboard` 并选择电影的原型单元格。在表格视图单元格的 `detailTextLabel` 上。这是我们显示电影评分的地方。
- en: 'In `MoviesViewController`, add the following line to `tableView(_:cellForRow:atIndexPath:)`,
    right after you set the cell''s title:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MoviesViewController` 中，在设置单元格标题后，向 `tableView(_:cellForRow:atIndexPath:)`
    添加以下行：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This line will put the movie's popularity rating in a string and assign it as
    the text for the detail text label.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将电影的受欢迎度评分放入字符串中，并将其分配为详细文本标签的文本。
- en: If you build and run your app now, all movies should have a popularity of 0.0\.
    Let's fix this by resolving the networking issue.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行你的应用程序，所有电影都应该有一个受欢迎度为 0.0。让我们通过解决网络问题来解决这个问题。
- en: Understanding App Transport Security
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解应用传输安全
- en: With iOS 9, Apple introduced **App Transport Security** (**ATS**). ATS makes
    applications safer and more secure by prohibiting the use of non-HTTPS resources.
    This is a great security feature, as it protects your users from a wide range
    of attacks that can be executed on regular HTTP connections.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 iOS 9 的推出，苹果引入了 **应用传输安全**（**ATS**）。ATS 通过禁止使用非 HTTPS 资源来使应用程序更安全、更可靠。这是一个很好的安全特性，因为它保护了用户免受在常规
    HTTP 连接上执行的各种攻击。
- en: If you paid close attention to the URL that's used to fetch movies, you may
    have noticed that the URL should be an HTTPS resource, so it should be fine to
    load this URL. However, the network requests are still blocked by ATS. Why is
    this?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细关注用于获取电影的 URL，你可能已经注意到该 URL 应该是一个 HTTPS 资源，因此加载这个 URL 应该是没问题的。然而，网络请求仍然被
    ATS 阻止。为什么？
- en: Well, Apple has strict requirements. At the time of writing this book, the movie
    database uses the SHA-1 signing of certificates, whereas Apple requires SHA-2\.
    Because of this, you will need to circumvent ATS for now. Your users should be
    safe regardless, since the movie database supports HTTPS, just not the version
    Apple considers to be secure enough.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，苹果有严格的要求。在撰写本书时，电影数据库使用证书的 SHA-1 签名，而苹果要求 SHA-2。因此，你现在需要绕过 ATS。尽管如此，您的用户仍然应该是安全的，因为电影数据库支持
    HTTPS，只是苹果认为它还不够安全。
- en: 'To do this, open the `Info.plist` file and add a new dictionary key named `themoviedb.org`
    to this dictionary and add two Booleans to this dictionary. Both should have **YES**
    as their values, and they should be named **NSIncludesSubdomains** and **NSTemporaryExceptionAllowsInsecureHTTPLoads**.
    Refer to the following screenshot to make sure that you''ve set this up correctly:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，打开`Info.plist`文件，并向此字典添加一个名为`themoviedb.org`的新字典键，并添加两个布尔值到这个字典中。这两个值都应该设置为**YES**，并且它们应该命名为**NSIncludesSubdomains**和**NSTemporaryExceptionAllowsInsecureHTTPLoads**。参考以下截图以确保你已经正确设置：
- en: '![Figure 9.3 – App Transport Security Settings'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 应用传输安全设置'
- en: '](img/B14717_09_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14717_09_03.jpg]'
- en: Figure 9.3 – App Transport Security Settings
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 应用传输安全设置'
- en: If you add a new movie to a family member now, nothing updates yet. However,
    if you go back to the family overview and then back to the family member, you'll
    see that the rating for the most recent movie is updated (make sure you choose
    a movie whose title is present on [themoviedb.org](http://themoviedb.org)). Great!
    Now, all you need to do is make sure that we observe the managed object context
    for updates to the movies, so they are reloaded if their rating changes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在为家庭成员添加一部新电影，还没有任何更新。然而，如果你回到家庭概览然后回到家庭成员，你会看到最新电影的评分已更新（确保你选择一个标题在[themoviedb.org](http://themoviedb.org)上存在的电影）。太棒了！现在，你需要确保我们观察管理对象上下文以更新电影，这样如果它们的评分发生变化，它们就会被重新加载。
- en: Observing changes to movie ratings
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察电影评分的变化
- en: 'You''re already observing the managed object context for changes, but they
    are only processed if the family member that is shown on the current page has
    updated. This logic should be replaced so that it will reload the table view if
    either the family member or their favorite movies change. Update the `managedObjectContextDidChange(_:)`
    method in `MoviesViewController.swift` as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经正在观察管理对象上下文的变化，但只有在当前页面上显示的家庭成员已更新时才会处理它们。这个逻辑应该被替换，以便在家庭成员或他们的喜欢的电影发生变化时重新加载表格视图。在`MoviesViewController.swift`中更新`managedObjectContextDidChange(_:)`方法如下：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Important Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The logic for observing the family member hasn't changed; its conditions simply
    moved from the `guard` statement to an `if` statement. An extra `if` statement
    was added for the movies. If the updated object set is a list of movies, we loop
    through the movies and check whether one of the movies has the current family
    member as its family member. If so, the table is refreshed immediately, and the
    loop is exited.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 观察家庭成员的逻辑没有改变；其条件只是从`guard`语句移动到了`if`语句。为电影添加了一个额外的`if`语句。如果更新的对象集是电影列表，我们遍历电影并检查是否有电影将当前家庭成员作为其家庭成员。如果是这样，表格会立即刷新，并且退出循环。
- en: It's important that the loop in the second `if` statement is set up like this
    because you might have just added a movie for family member A and then switched
    to family member B while the new movie for family member A was still loading its
    rating. Also, breaking out of the loop early ensures that you don't loop over
    any more objects than needed. All you want to do is refresh the table view if
    one of the current family members' favorite movies is updated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`if`语句中设置循环的方式很重要，因为你可能刚刚为家庭成员A添加了一部电影，然后切换到家庭成员B，而家庭成员A的新电影仍在加载其评分。提前退出循环确保你不会遍历比所需更多的对象。你只想在当前家庭成员的喜欢的电影更新时刷新表格视图。
- en: Okay, now build and run your app to take it for a spin! You'll notice that everything
    works as you'd want it to right now. Adding new movies triggers a network request;
    as soon as it finishes, the UI is updated with the new rating. Sometimes, this
    update will be done in an instant, but it could take a short while if you have
    a slow internet connection. Great! That's it for this feature.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在构建并运行你的应用来试驾一下！你会注意到现在一切按你的预期工作。添加新电影会触发网络请求；一旦完成，UI就会更新为新评分。有时，这个更新会立即完成，但如果你有慢速的互联网连接，可能需要一段时间。太棒了！这个功能就到这里。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about adding a small, simple feature to an existing app.
    We added the ability to load real data from an API. You saw that networking is
    made pretty straightforward by Apple with `URLSession` and data tasks. You also
    learned that this class abstracts away some very complex behavior regarding multithreading,
    so your apps remain responsive while data is loaded from the network. Next, you
    implemented a `helper` struct for networking and updated the Core Data model to
    store ratings for movies. Once all this was done, you could finally see how multithreading
    worked in the context of this app. This wasn't everything we needed to do, though.
    You learned about ATS and how it keeps your users secure. You also learned that
    you sometimes need to circumvent ATS, and we covered how you can achieve this.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲述向现有应用中添加一个微小、简单的功能。我们添加了从API加载真实数据的能力。你看到苹果公司通过`URLSession`和数据任务使网络变得相当简单。你还了解到这个类抽象了一些关于多线程的非常复杂的行为，因此当从网络加载数据时，你的应用仍然保持响应。接下来，你实现了一个用于网络的`helper`结构体，并更新了Core
    Data模型以存储电影的评分。一旦完成所有这些，你最终可以看到多线程在这个应用中的工作方式。但这还不是我们需要做的全部。你学习了ATS及其如何保护你的用户安全。你还了解到有时你需要绕过ATS，我们介绍了如何实现这一点。
- en: Even though the feature itself wasn't very complex, the concepts and theory
    involved could have been quite overwhelming. You suddenly had to deal with code
    that would be executed asynchronously in the future. And not just that. The code
    even used multiple threads to make sure that its performance was optimal. The
    concepts of multithreading and asynchronous programming are arguably two of the
    more complex aspects of programming. Practice them a lot and try to remember that
    any time you're passing around a closure, you could be writing some asynchronous
    code that gets executed on a different thread.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个功能本身并不复杂，但涉及的概念和理论可能相当令人难以承受。你突然不得不处理将来将异步执行代码。不仅如此，代码甚至使用了多个线程以确保其性能最优。多线程和异步编程的概念可以说是编程中更复杂的两个方面之一。大量练习它们，并试图记住，每次你传递闭包时，你可能会编写一些将在不同线程上执行的异步代码。
- en: Now that the list of movies is updated with data from the web, let's take it
    one step further in the next chapter. You will learn how to make your app smarter
    by using CoreML and Vision Framework features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在电影列表已经通过网络数据更新，让我们在下一章中更进一步。你将学习如何通过使用CoreML和Vision Framework功能使你的应用变得更智能。
