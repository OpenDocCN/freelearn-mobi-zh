<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling File Operations in Kotlin</h1>
                </header>
            
            <article>
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400">Reading from files using InputReader</li>
</ul>
<ul>
<li style="font-weight: 400">Reading all lines in a file using InputReader</li>
</ul>
<ul>
<li style="font-weight: 400">Reading line by line using InputReader</li>
</ul>
<ul>
<li style="font-weight: 400">Reading from files using BufferedReader</li>
</ul>
<ul>
<li style="font-weight: 400">Reading all lines in a file using BufferedReader</li>
</ul>
<ul>
<li style="font-weight: 400">Reading line by line using BufferedReader</li>
</ul>
<ul>
<li style="font-weight: 400">Reading string and JSON over network</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Kotlin I/O is used for input and output processing. Kotlin provides the <kbd>kotlin.io</kbd> API for working with files and streams. Some of the functions used in <kbd>kotlin.io</kbd> are extensions of <kbd>java.io</kbd> classes. All in all, using <kbd>kotlin.io</kbd> for reading from and writing to files and streams is very easy.</p>
<p> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading from files using InputReader</h1>
                </header>
            
            <article>
                
<p><kbd>Kotlin.io</kbd> provides a nice, clean API for reading from and writing to files. One way of doing this is by using <kbd>InputReader</kbd>. We will see how to do that in this recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for the development environment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are a lot of ways to go about reading from a file, but it is very important to understand the motivation behind them so as to be able to use the correct one for our purpose:</p>
<ol>
<li>First, we will try to get the <kbd>InputStream</kbd> of the file and use the reader to read the contents:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val inputStream: InputStream = File("lorem.txt").inputStream()<br/>    val inputString = inputStream.reader().use { it.readText() }<br/>    println(inputString)<br/>}</pre>
<ol start="2">
<li>In the preceding code block, <kbd>lorem.txt</kbd> is simply a file that we want to read. The file is located in the same folder as our code source file. If we need to read a file located in a different folder, it looks similar to the following:</li>
</ol>
<pre style="padding-left: 60px">File("/path/to/file/lorem.txt")</pre>
<ol start="3">
<li>This piece of code simply takes all the text in the file and prints it on the console.</li>
</ol>
<ol start="4">
<li>Another way of reading file contents is by directly creating a reader of the file, like we do in this code:</li>
</ol>
<pre style="padding-left: 60px">import java.io.File<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>  val inputString = File("lorem.txt").reader().use { it.readText() }<br/>  println(inputString)<br/>}</pre>
<ol start="5">
<li>The output of both preceding code blocks will simply be the text in the file as it is. In our case, it was as follows:</li>
</ol>
<pre style="padding-left: 60px">Lorem ipsum dolor sit amet, consectetur adipiscing elit.<br/>Nunc consequat eleifend mauris, eget congue ipsum consectetur id.<br/>Proin hendrerit felis metus, vitae suscipit mi tempus facilisis.<br/>Proin ut leo tellus. Donec nec lacus vel ante venenatis porttitor et sit amet purus.<br/>Sed tincidunt turpis ac metus pharetra dapibus.<br/>Integer sed auctor tellus. Morbi a metus luctus, viverra enim vel, imperdiet est.<br/>Curabitur purus massa, hendrerit id ligula et, finibus elementum purus.<br/>In ut consectetur lacus.<br/>Suspendisse non mauris eget dolor faucibus pharetra quis sed turpis.<br/>Vivamus eget lectus vel mi faucibus dignissim.<br/>Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos.<br/>Ut vitae velit non nunc consectetur imperdiet.<br/>Nunc feugiat diam tellus, in pellentesque nisl dapibus quis.<br/>Proin luctus sapien ac ante tempor, eget mollis odio aliquet.</pre>
<ol start="6">
<li>Now, what if we want to read the file line by line because we want to do some processing on each line? In that case, we use the <kbd>useLines()</kbd> method in place of <kbd>use()</kbd>.</li>
<li>Check out the following example, where we get an input stream from the file and use the <kbd>useLines()</kbd> method to get each line one after the other:</li>
</ol>
<pre style="padding-left: 60px">import java.io.File<br/>import java.io.InputStream<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    val inputStream: InputStream = File("lorem.txt").inputStream()<br/>    inputStream.reader().useLines { lines -&gt; lines.forEach { listOfLines.add(it)} }<br/>    listOfLines.forEach{println("$ " + it)}<br/>}</pre>
<ol start="8">
<li>Alternatively, if we wish to use a reader directly on the file, we do this:</li>
</ol>
<pre style="padding-left: 60px">import java.io.File<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/> <br/>    File("lorem.txt").reader().useLines { lines -&gt; lines.forEach { listOfLines.add(it)} }<br/>    listOfLines.forEach{println("$ " + it)}<br/>}</pre>
<p>The output, in this case, will be the following:</p>
<pre>$ Lorem ipsum dolor sit amet, consectetur adipiscing elit.<br/>$ Nunc consequat eleifend mauris, eget congue ipsum consectetur id.<br/>$ Proin hendrerit felis metus, vitae suscipit mi tempus facilisis.<br/>$ Proin ut leo tellus. Donec nec lacus vel ante venenatis porttitor et sit amet purus.<br/>$ Sed tincidunt turpis ac metus pharetra dapibus.<br/>$ Integer sed auctor tellus. Morbi a metus luctus, viverra enim vel, imperdiet est.<br/>$ Curabitur purus massa, hendrerit id ligula et, finibus elementum purus.<br/>$ In ut consectetur lacus.<br/>$ Suspendisse non mauris eget dolor faucibus pharetra quis sed turpis.<br/>$ Vivamus eget lectus vel mi faucibus dignissim.<br/>$ Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos.<br/>$ Ut vitae velit non nunc consectetur imperdiet.<br/>$ Nunc feugiat diam tellus, in pellentesque nisl dapibus quis.<br/>$ Proin luctus sapien ac ante tempor, eget mollis odio aliquet.</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p><span>Did you note that we used the </span><kbd>use()</kbd><span> and <kbd>useLines()</kbd> methods for reading the file? The call to the</span> <kbd>Closeable.use()</kbd><span> function will automatically close the input at the end of the lambda's execution. Now, we can of course use <kbd>Reader.readText()</kbd>, but that does not close the stream after execution. There are other methods apart from <kbd>use()</kbd>, such as <kbd>Reader.readText()</kbd> and so on, that can be used to read the contents of a stream or file. The decision to use any method is based on whether we want the stream to be closed on its own after execution, or we want to handle closing the resources, and whether or not we want to read from a stream or directly from the file.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more…</h1>
                </header>
            
            <article>
                
<p><kbd>BufferedReader</kbd> reads a couple of characters at a time from the input stream and stores <span>them in the buffer</span>. That’s why it is called <kbd>BufferedReader</kbd>. On the other hand, <kbd>InputReader</kbd> reads only one character from the input stream and the remaining characters still remain in the stream. There is no buffer in this case. This is why <kbd>BufferedReader</kbd> is fast, as it maintains a buffer, and retrieving data from the buffer is always quicker compared to retrieving data from disk.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading all lines in a file using InputReader</h1>
                </header>
            
            <article>
                
<p>We can use <kbd>InputReader</kbd> to read all the lines in a file in one go. In this recipe, we will learn how to do that.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for the development environment.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's follow these steps to understand how to read a file using the <kbd>InputReader</kbd> class:</p>
<ol>
<li>There are two ways to read a file, one of which is to attach an input stream to the file. Let's see how we can do that and use <kbd>InputReader</kbd> to read its contents:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val inputStream: InputStream = File("example2.txt").inputStream()<br/>    val inputString = inputStream.reader().use { it.readText() }<br/>    println(inputString)<br/>}</pre>
<ol start="2">
<li class="mce-root">The other way is without getting a stream and directly reading the contents of the file, such as in the following example:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>fun main(args: Array&lt;String&gt;) {<br/>    val inputString = File("example2.txt").reader().use { it.readText() }<br/>    println(inputString)<br/>}</pre>
<p class="mce-root">The output, in this case, is simply the contents of the file as it is:</p>
<pre class="mce-root">A panoramic view of Lower Manhattan as seen at dusk from Jersey City, New Jersey, in November 2014. Manhattan is the most densely populated borough of New York City. It is the city's economic and administrative center, and a major global cultural, financial, media, and entertainment center.<br/>The second paragraph of this file is small.</pre>
<p>We used the <kbd>use()</kbd> method because it closes the stream after execution.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>Attaching <kbd>inputStream</kbd> to a file returns the file contents as a stream of bytes. We can use a reader on the stream returned, or we can use the reader directly on the file. The <kbd>read()</kbd> method of <kbd>inputStream</kbd> reads the next byte in the stream. The <kbd>readText()</kbd> method returns the entire contents of the file as a string using UTF-8 or specified charset.</p>
<p class="mce-root">This <kbd>readText()</kbd> method is not recommended for huge files. It has an internal limitation of 2 GB file size. In case of a huge file, we read it byte by byte from the stream.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading line by line using InputReader</h1>
                </header>
            
            <article>
                
<p>Sometimes we need to read the contents of a file line by line and process it. This is easily done by reading a file line by line using the <kbd>InputReader</kbd>. Let's see how.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for the development environment.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>In the following steps, we will learn how to make use of the <kbd>InputReader</kbd> class to read the text line by line:</p>
<ol>
<li><span>Let's start with attaching the <kbd>InputStream</kbd> to the file and going line by line on the contents, like this:</span></li>
</ol>
<pre style="padding-left: 60px">import java.io.File<br/>import java.io.InputStream<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    val inputStream: InputStream =  File("example2.txt").inputStream()<br/>    inputStream.reader().useLines { lines -&gt; lines.forEach { listOfLines.add(it)} }<br/>    listOfLines.forEach{println("* " + it)}<br/>}</pre>
<ol start="2">
<li>Each line is appended with <kbd>*</kbd> in this case. Here's how the output looks:</li>
</ol>
<pre style="padding-left: 60px">* A panoramic view of Lower Manhattan as seen at dusk from Jersey City, New Jersey, in November 2014. Manhattan is the most densely populated borough of New York City. It is the city's economic and administrative center, and a major global cultural, financial, media, and entertainment center.<br/>* The second paragraph of this file is small.</pre>
<ol start="3">
<li>We can directly attach the reader to the file and read it line by line. The following code does just that:</li>
</ol>
<pre style="padding-left: 60px">import java.io.File<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/> <br/>    File("example2.txt").reader().useLines { lines -&gt; lines.forEach { listOfLines.add(it)} }<br/>    listOfLines.forEach{println("* " + it)}<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>The <kbd>useLines()</kbd> method provides us an iterable over all the lines of the file or stream and then does something with each line, which is a string. We add all the modified strings to a list and print them out.</p>
<p> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading from files using BufferedReader</h1>
                </header>
            
            <article>
                
<p><kbd>BufferedReader</kbd> stores some characters as it reads into the buffer. This makes the reading faster and hence more efficient. In this recipe, we will understand how to use the <kbd>BufferedReader</kbd> to read the contents of a file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p class="mce-root">You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for the development environment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Follow the mentioned steps to learn more about the working of the <kbd>BufferedReader</kbd> class:</p>
<ol>
<li class="mce-root">We can directly attach a <kbd>BufferedReader</kbd> to the file and read the contents of the whole file, as in the following code:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val inputString = File("lorem.txt").bufferedReader().use { it.readText() }<br/>    println(inputString)<br/>}</pre>
<ol start="2">
<li class="mce-root">We can also go line by line on the contents that we need so as to be able to process each line individually. In the following code, we go line by line and add a character at the beginning and the length of the string after the character:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    File("lorem.txt").bufferedReader().useLines { <br/>        lines -&gt; lines.forEach { <br/>            var x = "&gt; (" + it.length + ") " + it;<br/>            listOfLines.add(x)<br/>        } <br/>    }<br/>    listOfLines.forEach{println(it)}<br/>}</pre>
<ol start="3">
<li class="mce-root">In the preceding code blocks, we are directly attaching the reader to the file. However, there are cases when we need to take a stream of data. In that scenario, we can get an Input Stream from the file that we want to read and then attach a <kbd>BufferedReader</kbd> to it.</li>
<li class="mce-root">In the following code, we are trying to read line by line from the file input stream using a <kbd>BufferedReader</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import java.io.File<br/>import java.io.InputStream<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    val inputStream: InputStream = File("lorem.txt").inputStream()<br/>    inputStream.bufferedReader().useLines { <br/>        lines -&gt; lines.forEach { <br/>            var x = "&gt; (" + it.length + ") " + it;<br/>            listOfLines.add(x)<br/>        } <br/>    }<br/>    listOfLines.forEach{println(it)}<br/>}</pre>
<ol start="5">
<li class="mce-root">Here's the output when we try to read all the contents of the file in one go:</li>
</ol>
<pre style="padding-left: 60px">Lorem ipsum dolor sit amet, consectetur adipiscing elit.<br/>Nunc consequat eleifend mauris, eget congue ipsum consectetur id.<br/>Proin hendrerit felis metus, vitae suscipit mi tempus facilisis.<br/>Proin ut leo tellus. Donec nec lacus vel ante venenatis porttitor et sit amet purus.<br/>Sed tincidunt turpis ac metus pharetra dapibus.<br/>Integer sed auctor tellus. Morbi a metus luctus, viverra enim vel, imperdiet est.<br/>Curabitur purus massa, hendrerit id ligula et, finibus elementum purus.<br/>In ut consectetur lacus.<br/>Suspendisse non mauris eget dolor faucibus pharetra quis sed turpis.<br/>Vivamus eget lectus vel mi faucibus dignissim.<br/>Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos.<br/>Ut vitae velit non nunc consectetur imperdiet.<br/>Nunc feugiat diam tellus, in pellentesque nisl dapibus quis.<br/>Proin luctus sapien ac ante tempor, eget mollis odio aliquet.</pre>
<ol start="6">
<li class="mce-root">The output resembles the file, ignoring the <kbd>charset</kbd>. We can also specify the desired <kbd>charset</kbd>, such as we do in the following code, if needed:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">bufferedReader(charset).use { it.readText() }</pre>
<ol start="7">
<li class="mce-root">When we go line by line using either of the preceding examples, we get the following output:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">&gt; (56) Lorem ipsum dolor sit amet, consectetur adipiscing elit.<br/>&gt; (65) Nunc consequat eleifend mauris, eget congue ipsum consectetur id.<br/>&gt; (64) Proin hendrerit felis metus, vitae suscipit mi tempus facilisis.<br/>&gt; (84) Proin ut leo tellus. Donec nec lacus vel ante venenatis porttitor et sit amet purus.<br/>&gt; (47) Sed tincidunt turpis ac metus pharetra dapibus.<br/>&gt; (81) Integer sed auctor tellus. Morbi a metus luctus, viverra enim vel, imperdiet est.<br/>&gt; (71) Curabitur purus massa, hendrerit id ligula et, finibus elementum purus.<br/>&gt; (24) In ut consectetur lacus.<br/>&gt; (68) Suspendisse non mauris eget dolor faucibus pharetra quis sed turpis.<br/>&gt; (46) Vivamus eget lectus vel mi faucibus dignissim.<br/>&gt; (91) Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos.<br/>&gt; (46) Ut vitae velit non nunc consectetur imperdiet.<br/>&gt; (60) Nunc feugiat diam tellus, in pellentesque nisl dapibus quis.<br/>&gt; (61) Proin luctus sapien ac ante tempor, eget mollis odio aliquet.</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p class="mce-root">Using <kbd>InputStream</kbd> helps us get a stream of the file we wish to read. We can also read from the file directly though. In either case, the <kbd>BufferedReader</kbd> keeps presaving some data that it is reading in its buffer for faster operation, which increases the overall efficiency of the read operation, as compared to when using <kbd>InputReader</kbd>.<br/>
We use the <kbd>use()</kbd> and/or <kbd>useLines()</kbd> method in place of <kbd>Reader.readText()</kbd> and so on so that it automatically closes the input stream at the end of execution, which is a much cleaner and more responsible way of handling I/O of files. However, if needed, one can use a method such as <kbd>Reader.readText()</kbd> when they want to handle opening and closing the stream on their own.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading all lines in a file using BufferedReader</h1>
                </header>
            
            <article>
                
<p><kbd>BufferedReader</kbd> can be used to read contents of a file or an input stream. It presaves some contents it reads, so the read operation is faster. In this recipe, we will learn how to read all the contents of a file in one go using <kbd>BufferedReader</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for the development environment.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>In the following steps, we will learn how to use <kbd>BufferedReader</kbd> to read all lines of a file:</p>
<ol>
<li class="mce-root">Let's start with getting the <kbd>InputStream</kbd> of our file and use the <kbd>BufferedReader</kbd> on it to read the contents of the file in one go:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/>fun main(args: Array&lt;String&gt;) {<br/>    val inputStream: InputStream = File("lorem.txt").inputStream()<br/>    val inputString = inputStream.bufferedReader().use {     it.readText() }<br/>    println(inputString)<br/>}</pre>
<ol start="2">
<li class="mce-root">The output, in this case, will be the exact same as the file, depending on the charset of course, if we use it. Here's an example where we use <span>another charset:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/>fun main(args: Array&lt;String&gt;) {<br/>    val inputStream: InputStream = File("lorem.txt").inputStream()<br/>    val inputString =   inputStream.bufferedReader(Charsets.ISO_8859_1).use {  it.readText() }<br/>    println(inputString)<br/>}</pre>
<ol start="3">
<li class="mce-root">Now, let's quickly see the code example without getting the <kbd>inputStream</kbd> on this file:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/>fun main(args: Array&lt;String&gt;) {<br/>    val inputString = File("lorem.txt").bufferedReader().use { it.readText() }<br/>    println(inputString)<br/>}</pre>
<ol start="4">
<li class="mce-root">Although you might have guessed the output, here's the output anyway:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">Lorem ipsum dolor sit amet, consectetur adipiscing elit.<br/>Nunc consequat eleifend mauris, eget congue ipsum consectetur id.<br/>Proin hendrerit felis metus, vitae suscipit mi tempus facilisis.<br/>Proin ut leo tellus. Donec nec lacus vel ante venenatis porttitor et sit amet purus.<br/>Sed tincidunt turpis ac metus pharetra dapibus.<br/>Integer sed auctor tellus. Morbi a metus luctus, viverra enim vel, imperdiet est.<br/>Curabitur purus massa, hendrerit id ligula et, finibus elementum purus.<br/>In ut consectetur lacus.<br/>Suspendisse non mauris eget dolor faucibus pharetra quis sed turpis.<br/>Vivamus eget lectus vel mi faucibus dignissim.<br/>Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos.<br/>Ut vitae velit non nunc consectetur imperdiet.<br/>Nunc feugiat diam tellus, in pellentesque nisl dapibus quis.<br/>Proin luctus sapien ac ante tempor, eget mollis odio aliquet.</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p><kbd>BufferedReader</kbd>, as it reads, stores some characters in a buffer, hence the read operations are faster. We can directly attach the <kbd>BufferedReader</kbd> to the file or the stream and read from it.</p>
<p>The <kbd>use()</kbd> method ensures that the file or stream is closed after execution completes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading line by line using bufferedReader</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will understand how to use the <kbd>bufferedReader</kbd> to read the contents of a file line by line.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for this purpose, for which you need the Kotlin compiler installed along with JDK. You can also use IntelliJ IDEA for the development environment.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>In the given steps, we will learn how to use <kbd>BufferedReader</kbd> to read a file line by line:</p>
<ol>
<li class="mce-root">Let's start with getting the <kbd>InputStream</kbd> of our file and use the <kbd>BufferedReader</kbd> on it to read the contents of the file line by line:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    val inputStream: InputStream = File("lorem.txt").inputStream()<br/>    inputStream.bufferedReader().useLines {<br/>        lines -&gt; lines.forEach {<br/>            var x = "# (" + it.length + ") " + it.substring(0,8);<br/>            listOfLines.add(x)<br/>        }<br/>    }<br/>    listOfLines.forEach{println(it)}<br/>}</pre>
<p style="padding-left: 60px" class="mce-root">The<span> </span>output, in this case, is as follows:</p>
<pre style="padding-left: 60px" class="mce-root"># (56) Lorem ip<br/># (65) Nunc con<br/># (64) Proin he<br/># (84) Proin ut<br/># (47) Sed tinc<br/># (81) Integer<br/># (71) Curabitu<br/># (24) In ut co<br/># (68) Suspendi<br/># (46) Vivamus<br/># (91) Class ap<br/># (46) Ut vitae<br/># (60) Nunc feu<br/># (61) Proin lu</pre>
<ol start="2">
<li class="mce-root">The output depends on the charset we use if we use one. This is a code example with a charset:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    val inputStream: InputStream = File("lorem.txt").inputStream()<br/>    inputStream.bufferedReader(Charsets.US_ASCII).useLines {<br/>        lines -&gt; lines.forEach {<br/>            var x = "# (" + it.length + ") " + it.substring(0,8);<br/>            listOfLines.add(x)<br/>        }<br/>    }<br/>    listOfLines.forEach{println(it)}<br/>}</pre>
<ol start="3">
<li class="mce-root">Now, let's go through a code example where we read directly from a file:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import java.io.File<br/>import java.io.InputStream<br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    File("lorem.txt").bufferedReader().useLines {<br/>        lines -&gt; lines.forEach {<br/>            var x = "# (" + it.length + ") " + it.substring(0,8);<br/>            listOfLines.add(x)<br/>        }<br/>    }<br/>    listOfLines.forEach{println(it)}<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p><kbd>BufferedReader</kbd> provides us with a lot of methods that we can use to read contents of the file or input stream line by line. Using <kbd>useLines()</kbd>, we get a sequence of lines that we can then iterate on using <kbd>forEach</kbd>. A user may terminate the iteration loop, so the caller needs to close the <kbd>BufferedReader</kbd>, which is what <kbd>useLines()</kbd> does. We can only iterate over the sequence returned once.</p>
<p>The syntax for <kbd>useLines()</kbd> is this:</p>
<pre>inline fun &lt;T&gt; File.useLines(<br/>    charset: Charset = Charsets.UTF_8, <br/>    block: (Sequence&lt;String&gt;) -&gt; T<br/>): T</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more…</h1>
                </header>
            
            <article>
                
<p>We can also use other methods like <kbd>readLine()</kbd> for this purpose. This code is an example of that:</p>
<pre>import java.io.File<br/>import java.io.InputStream<br/>fun main(args: Array&lt;String&gt;) {<br/>    val listOfLines = mutableListOf&lt;String&gt;()<br/>    val reader = File("lorem.txt").bufferedReader()<br/>    while(true) {<br/>        var line = reader.readLine()<br/>        if(line == null) break<br/>        listOfLines.add("&gt; "+line)<br/>    }<br/>    listOfLines.forEach{println(it)}<br/>}</pre>
<p>The great thing about using the <kbd>useLines()</kbd> method is that it closes the stream post-execution. Also, the code in the preceding examples was a more idiomatic and clean way of doing the same thing.</p>
<p>Another method provided by Kotlin that returns a sequence of lines is <span><kbd>lineSequence()</kbd>, but it does not close the <kbd>BufferedReader</kbd> after execution, which is why it's good to use <kbd>useLines()</kbd>.</span></p>
<p><span>I</span>n the end, it depends on the scenario in which the code is to be used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading string and JSON over network</h1>
                </header>
            
            <article>
                
<p>Networking is an essential component of apps. Most of the apps we use are connected to the internet and involve reading/writing data over the internet. In this recipe, we will learn how to perform network requests in Kotlin. Although you can also use a third-party library such as Retrofit, Volley and such, understanding how it's done in Kotlin is worthwhile. So let's get started!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will be working with Android code, so I'll be using Android Studio. It's also required to include the anko-commons library as we will be using its methods in our code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Let's follow these steps to understand how to make a network request in Kotlin:</p>
<ol>
<li>Making a network request in Kotlin is straightforward with simple syntax. Here's how you would read data over the internet in Kotlin:</li>
</ol>
<pre style="padding-left: 60px">val response = URL("&lt;api_request&gt;").readText()</pre>
<ol start="2">
<li>That's it! Remember that this is equivalent to Java code when making a network request:</li>
</ol>
<pre style="padding-left: 60px">// 1. Declare a URL Connection<br/>URL url = new URL("http://www.google.com");<br/>HttpURLConnection conn = (HttpURLConnection) url.openConnection();<br/>// 2. Open InputStream to connection<br/>conn.connect();<br/>InputStream in = conn.getInputStream();<br/>// 3. Download and decode the string response using builder<br/>StringBuilder stringBuilder = new StringBuilder();<br/>BufferedReader reader = new BufferedReader(new InputStreamReader(in));<br/>String line;<br/>while ((line = reader.readLine()) != null) {<br/>    stringBuilder.append(line);<br/>}<br/><br/></pre>
<ol start="3">
<li>However, of course, if you try it on the main thread, you will get the <kbd>NetworkOnMainThreadException</kbd> exception. To get away with this, we need to make the network call in the background. One way to do this is by using an <kbd>Async</kbd> task. An <kbd>Async</kbd> task was a pain to implement in Java, but we can do it quite easily using Anko (a library for Kotlin). This is how you would create a background task in Kotlin using Anko:</li>
</ol>
<pre style="padding-left: 60px">doAsync{<br/>    val response=URL("&lt;network_url&gt;").readText()<br/>    uiThread{<br/>       // Here you would do UI operation<br/>       toast(" ... ")<br/>    }<br/>}</pre>
<ol start="4">
<li>In Java's <kbd>Async</kbd> task implementation, the <kbd>Async</kbd> task could be fired even if the activity was being destroyed. This resulted in defensive programming where you had to make checks on whether the UI was still present to do UI operations. However, Anko's implementation of background task takes care of it, and it won't fire the task if the activity is dying.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>The <kbd>doAsync</kbd> returns a Java <kbd>Future</kbd>. In simple words, a <kbd>Future</kbd> is a proxy or a wrapper around an object that is not yet there. When the asynchronous operation is done, you can extract it. If you want to avoid working with <kbd>Future</kbd>, <kbd>doAsync</kbd> has a different construct that accepts an <kbd>ExecutorService</kbd>:</p>
<pre><span>val </span>executor = Executors.newScheduledThreadPool(<span>5</span>)<br/><br/><span>doAsync</span>(<span>executorService = </span>executor)<span>{<br/></span><span>    </span><span>val </span>result = URL(<span>"https://httpbin.org/get"</span>).<span>readText</span>()<br/>    <span>uiThread </span><span>{<br/></span><span>        </span><span>toast</span>(result)<br/>    <span>}<br/></span><span>}</span></pre>
<p>As we discussed, the <kbd>uiThread</kbd> block isn't executed if the activity is closing. The reason is that it doesn't hold a context instance, only a weak reference. So even if the block isn't finished, the context will not leak.</p>


            </article>

            
        </section>
    </div>



  </body></html>