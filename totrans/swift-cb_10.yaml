- en: SwiftUI and Combine Framework
  prefs: []
  type: TYPE_NORMAL
- en: At the Apple **Worldwide Developer Conference** (**WWDC**) in 2019, Apple took
    a lot of us by surprise with the announcement of SwiftUI, a brand new **user interface**
    (**UI**) framework written from the ground up, entirely in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of the declarative programming paradigm, SwiftUI not only offers
    a powerful way to programmatically create and design your UI but a functional
    and logical approach too.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside many other announcements at WWDC 19, Apple also announced its very
    own entry into the reactive programming stream with a new framework called **Combine**.
    Combine replaces the traditional delegate pattern most of us will be accustomed
    to in iOS and macOS development.
  prefs: []
  type: TYPE_NORMAL
- en: With SwiftUI's change to the dynamics of how UI patterns are written programmatically,
    Combine is a welcome addition alongside the SwiftUI framework. In this chapter,
    we'll take a tour of the inner workings of SwiftUI and how to build our very own
    app—alongside this, we'll integrate the power of Combine to give us a truly unique
    and reactive workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function builders, property wrappers, and opaque return types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building simple views in SwiftUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine and data flow in SwiftUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3qE2mpv](https://bit.ly/3qE2mpv)'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the introduction of SwiftUI comes a new coding paradigm called declarative
    syntax. Well, I say "new"—it's actually been around for a while; it's just something
    we've never really used in iOS or macOS development. In this section, we'll take
    a look at what exactly declarative syntax is and how it compares to the style
    of syntax we might be used to seeing already.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this section, you'll need the latest version of Xcode available from the
    Mac App Store.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open Xcode and select **File** | **New** | **Playground**, then select ***Blank***
    in order to open a new Playground canvas to work from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once open, add in the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first `import` statement we've seen before and should be familiar with already.
    The next is our one for SwiftUI—pretty self-explanatory as to why we need this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a view in SwiftUI by adding in the following highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All SwiftUI views are built in a struct that conforms to the `View` type—this
    then houses another struct, which looks a bit like a computed property called
    `body`, which in turn conforms to `some View`. Inside this property—or "function
    builder", as it's known (which we'll touch on later in this chapter)—we have certain
    elements that start to make up our UI.
  prefs: []
  type: TYPE_NORMAL
- en: There is a `VStack` or **vertical stack**, which will wrap all enclosing views
    "vertically" within itself. A VStack is, again, a `View.`
  prefs: []
  type: TYPE_NORMAL
- en: Inside here, we have a `Text()` view where we set our text to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add the following to our Playground, we''ll be able to see our SwiftUI
    in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, where does the declarative syntax come into all this? Well, it already
    has done; you've written it, right there in your struct. Let's dig a little deeper
    into how declarative syntax works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In SwiftUI everything is made from Views, from the main container that is presented
    to the app's window, to text, a button, or even a toggle.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking back to how UIKit works, this theory isn't too dissimilar—most objects
    are a subclass of `UIView()`.
  prefs: []
  type: TYPE_NORMAL
- en: The only fundamental difference is that with SwiftUI, the layout and construction
    of all this is much more visible; this is the declarative syntax coming into play.
    The best way to think about declarative syntax is in a functional and logical
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to vertically align items on my view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I then want to add a `Text` box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s add a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Even the construction of the button is declarative itself: ***set an action***;
    ***set a label***.Everything is just... functional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to think of this would be similar to how we would work through
    a food recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Chop onions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fry onions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add seasoning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With our more traditional style of programming (or **imperative** programming,
    as it''s known), you might perform things a little differently and a little less
    logically:'
  prefs: []
  type: TYPE_NORMAL
- en: Get seasoning
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get onion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Peel onion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chop onion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Heat pan
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While with declarative syntax all the preceding steps still need to exist to
    make it work, the framework that it is written on does a lot of the work for you—we
    just simply "tell it" what to do.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declarative syntax has been around for a while now; you may have used it before
    without even realizing it. Let''s take a look at the following **Structured Query
    Language** (**SQL**) syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice anything familiar? That''s right: declarative syntax right there...
    give me `column1` and `column2` from a ***particular table*** where this `condition`
    is met.'
  prefs: []
  type: TYPE_NORMAL
- en: Most recently, the declarative syntax has been making its way into even more
    UI frameworks such as Google's Flutter and, most recently, into Android's new
    Jetpack Compose, both of which use a declarative syntax style to allow developers
    and designers to build a UI.
  prefs: []
  type: TYPE_NORMAL
- en: We've mentioned a few times already that declarative syntax gives us a much
    more functional and logical approach to programming. They are paradigms that sit
    beneath the declarative paradigm as a whole. SQL, for example, sits within **DSL**
    (**Domain-Specific Language**), along with HTML and other markup languages.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android Jetpack Compose: [https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google''s Flutter: [https://flutter.dev/](https://flutter.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function builders, property wrappers, and opaque return types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftUI certainly brings a lot to the table, especially as it's been built from
    the ground up using Swift at its core. This itself has a plethora of benefits,
    which include making use of some of the features we are about to cover in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this section, you'll need the latest version of Xcode available from the
    Mac App Store.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with our existing Playground project, let''s take another look at
    how things "stack up". We''ll start by taking another look at our VStack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here is a block of code, which in SwiftUI terms is a View to be displayed. The
    view is a vertical stack—think `UITableView`, but at the same time don't think
    `UITableView`, as it's bad practice to try to compare SwiftUI to UIKit.
  prefs: []
  type: TYPE_NORMAL
- en: All the code sitting within our VStack will be displayed vertically and then
    presented back to the main View, but where is the logic that adds our `Text()`
    and `Button()` views to the `VStack`? There's no `item` or `row` for index (see,
    it's bad to compare this to `UITableView`); there's no `.add()` or `.append()`
    function that you would see when building an array. Everything just sits inside
    what are called **function builders**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another in for good measure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've added an `HStack`, which (yep, you guessed it)
    gives us a horizontal stack of Views—another function builder like before, this
    time housing a `Text()` and an `Image()` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we''ve added our `HStack` function builder inside our existing VStack?
    This is like we said before: our Stacks are just Views, so our top-level VStack
    just treats it like that and our `HStack` does all the work of arranging its `Text()`
    and `Image()` views.'
  prefs: []
  type: TYPE_NORMAL
- en: But what is being returned here? When building Views in functions programmatically,
    you might expect to see the `return` keyword, with the return type specific to
    the object type being returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with Swift 5.1, we can harness the power of **opaque return types**.
    Let''s look back at the body of our SwiftUI view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `some View` return type. This is an opaque return type and allows
    SwiftUI to return any type that conforms to the View protocol, such as `Text`,
    `Button`, `Image`, and so on. Without this, SwiftUI would not be as versatile
    in terms of allowing us to build up a view, and our view builder would simply
    not exist.
  prefs: []
  type: TYPE_NORMAL
- en: But the beauty of **o****paque return types** is that they are not SwiftUI-specific;
    they are just a natural evolution of the Swift language, again demonstrating how
    much SwiftUI has been built from the core Swift programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we see here is the omission of the `return` keyword. Again, a
    new feature introduced in Swift 5.1: our SwiftUI code can now interpret a final
    return type to be passed back up the View hierarchy. But what about our `HStack`
    or `VStack`? Well, as these are **function builders**, they are not being returned
    back as such; it is more that they are being added to the Stack, which then, in
    turn, is passed back up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is always the possibility that you may need an `HStack` sitting
    alongside a `VStack`**,** like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the compiler will need a little help. Unfortunately, we can''t
    just add in a `return` keyword as we want both to be returned, so we could add
    these into another Stack—but as we don''t really need one that would be unnecessary,
    so we simply wrap these in a `Group()` view instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A `Group` view itself is another view that can then be passed back up as `some
    View` to our body—nice!
  prefs: []
  type: TYPE_NORMAL
- en: We're certainly getting all the ingredients together in order to make a start
    with SwiftUI, but before we get stuck in, let's take a look at another feature
    introduced in SwiftUI, again from our ever-evolving Swift programming language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Property wrappers** in SwiftUI are one of the features that really help make
    it shine, and are used for a wide variety of things. The main purpose that each
    one holds is to reduce the amount of maintenance required for your specific view.
    Let''s take a look at some of the more common ones you might use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`@State` allows SwiftUI to modify specific properties of specific views without
    the need to call a specific function to do so. For example, make the following
    highlighted changes to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've added a variable called `count` and have given this the `@State` property
    wrapper, and we now update our button click to increase the integer by `1`. Next,
    we add some logic based on the value of `count`**.**
  prefs: []
  type: TYPE_NORMAL
- en: By changing the value of `count` we have now bound our property that is being
    used within SwiftUI to the value and any changes that are made, thus invalidating
    the SwiftUI layout and rebuilding our view using the new value.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead—run this in the Playground and try it out for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Binding` is another well-used property wrapper specifically used in conjunction
    with passing values to state properties that may live in another view. Let''s
    take a look at how we might do this, starting by separating out some code and
    creating another SwiftUI view. We can do this just underneath our current `MyView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're simply just creating a SwiftUI view that returns a `Text` view,
    but this is a great way to see how easy it is to separate out specific view logic
    that you might want to work on separately (or make reusable).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice here we were also using our `count` variable, although this time with
    the `@Binding` wrapper. This is because we won''t be controlling the value of
    `count` from within this view; this will be done externally back in `MyView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding highlighted code, notice we still have our `@State` variable,
    and our `Button` action is still updating this value on each press. We've also
    added in our new `ResultView`, passing in our `@State` variable and "binding"
    this to our variable in `ResultView`, thus forcing a change to that view every
    time `count` is updated. Go ahead and try it for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve covered some of the property wrappers that you are more than likely
    to be exposed to with SwiftUI from the outset, but there are plenty more where
    they came from, some of which we''ll cover later on in this chapter, specifically
    when it comes to working with the Combine framework. However, here is a run-through
    of some of the others and what they have to offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Think of this as a global object—sometimes you might want to keep track of certain
    things throughout your app that you might not necessarily need or feel the need
    to pass through to every view. However, it's important to know that `EnvironmentObject`
    isn't a single source of truth; it's data—it's merely referencing it from the
    source, and should the source change, `EnvironmentObject` will trigger a state
    change (which is what we want).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of how we could use this is to create a class we want to observe,
    conforming to `ObservableObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, reference it from anywhere in our SwiftUI project, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another great and certainly convenient property wrapper is `@AppStorage`, used
    as a way to access data stored within `UserDefaults`. As of iOS 14, we can incorporate
    this straight into our SwiftUI views, without the need for additional logic or
    functions. Let''s take a look at how we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice here that we have a default value should there be no data already persisted.
    If we want to write to this, we simply assign the property a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and try this in your Playground. If you get stuck, have a look at the
    GitHub resource to see how I did it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the architecture of SwiftUI, there is—and will be—an ever-growing list
    of available property wrappers. We''ll cover some more later on in this chapter,
    but here are some others to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@GestureState`—Tracks the current gesture that is being performed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@FetchRequest`—Performs a fetch for Core Data entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'States: [https://developer.apple.com/documentation/swiftui/state](https://developer.apple.com/documentation/swiftui/state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bindings: [https://developer.apple.com/documentation/swiftui/binding](https://developer.apple.com/documentation/swiftui/binding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building simple views in SwiftUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered some of the fundamentals of how SwiftUI is built up from the Swift
    programming language, but it's time now to get into how we build an actual app
    in SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take everything we've learned so far and apply it in
    order for us to build a list app similar to the one we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this section, you'll need the latest version of Xcode from the Mac App Store.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get going. First, we''ll create a brand new project—in Xcode, click
    on File | **New** | **Project**. Then, select Single View App and make sure you''ve
    selected `SwiftUI` for the Interface style, just like I''ve done here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/579ddfcc-c33e-4c4e-bf52-9f3cd99f47ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Creating a new project
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Next and select a location on your disk. Once that is done, the familiar
    site of Xcode should appear; however, you may notice something new. On the right-hand
    side, you''ll see the Live Window screen. Go ahead and click Resume—you should
    see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ca17d0c7-67b2-47a7-8b3a-1ee0bf71ca2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Xcode and Live Window screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ve got a generated preview of our boilerplate SwiftUI code. Notice
    our `ContentView()` struct, just as we expect with its **body**. Now, look at
    the struct below it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is our `PreviewProvider` struct, allowing us to test out our SwiftUI views
    at design time, without the need to keep rerunning the simulator and rebuilding
    our application—neat!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for our initial list, we''re going to need some mock data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following struct (this can be in a new file if you want):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Comparing this to our `Task` model in [Chapter 8](9ce1feb3-8fca-4656-91dc-796ba77c3d07.xhtml),
    *Server-Side Swift*, it's pretty much identical in terms of properties and the
    data we want it to hold. The only difference we've had to make is for our model
    to conform to `Identifiable` and be given a unique ID—this is required by SwiftUI
    for anything that we are going to iterate around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create a little helper function for some mock data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This mock data will come in handy in SwiftUI in more than one way, but we'll
    get to that shortly. Let's hook this up to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back over to our `ContentView`, replace the `Hello World` text view with the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice something about our `List()` view? That''s right: another function builder
    accepts an argument of an array of items, where the items conform to `Identifiable`.
    A variable is given back to us in the closure, representing each one of these
    items so that we can then use them inside our list builder as we see fit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are just adding the description to a text view for now. If not already
    showing in the live preview, click R**esume** (sometimes this is needed in Xcode),
    and you should now see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8374630-e7d3-4000-8379-d49bbd66d0bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Preview screen
  prefs: []
  type: TYPE_NORMAL
- en: Now, run this in the simulator, and you should see the exact same thing—great
    job!
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for a little refactoring now, so make the following highlighted changes
    to the `ContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re removing our call to our mock data helper as, for production code,
    we shouldn''t be calling this in here. With this change, let''s head on over to
    `PreviewProvider` and make the following highlighted changes there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As our `ContentView` struct now has a non-optional `tasks` variable, it requires
    us to pass some data in; here, we'll pass in our `MockHelper` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If not already showing, go ahead and resume the live preview. All being well,
    everything should be working as expected. However, let''s see what happens when
    we try to run this in the simulator—that''s right: no data.'
  prefs: []
  type: TYPE_NORMAL
- en: If you take a closer look at the change we just made, you'll see why we're now
    only injecting our mock data into our `ContentView` via the Preview Provider so
    that when our actual app runs, our `tasks` array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: But this is right; as we'll be hooking our app up to the **REpresentational
    State Transfer application** **programming interface** (**REST API**) we created
    in [Chapter 8](9ce1feb3-8fca-4656-91dc-796ba77c3d07.xhtml), *Server-Side Swift*,
    by injecting the mock data via the Preview Provider, we can continue to build
    our UI long before we build in any networking functionality, so let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from the previous section how we refactored out our `Result` view?
    We're going to do the same again here for each row in our `List` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new SwiftUI file and call it `ListRowView`, then update the boilerplate
    code to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, head back over to `ContentView.swift` and make the following highlighted
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Just like before, we're replacing our text view with the view we just created.
    Click Resume to view the live preview and see for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know that''s working, we want to work on the style of our `ListRowView`
    a little, so let''s head back on over there now and start by updating the Preview
    Provider so that we can work from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding highlighted code, we''ve added some mock
    data for use in our Live Preview. If this is not already showing, click Resume
    and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/174b3e71-a967-4b6b-b60e-a12b0c1424ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Live Preview screen with some mock data
  prefs: []
  type: TYPE_NORMAL
- en: 'It works but doesn''t look much like a `List` row, but that''s fine—we just
    need to tell the Preview Provider what we intend to use it for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It really is that simple. We just wrap it around a `List` view and SwiftUI does
    the rest, and we can now get to work on decorating our row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the body of our `ListRowView`, make the following highlighted changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added modifiers to our views. Modifiers allow us to decorate and
    style our views just like we would with properties in UIKit, and each modifier
    is tied specifically to its type of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'SwiftUI has gone a little further with some of the modifiers available, giving
    us a wide variety of options. Let''s take the `.font` modifier, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding fonts are all available to use straight out of the box; however,
    if you still want to specify your own font, you can do so by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s finish off the base of our app by adding in an image based on the category
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the preceding code how we've now introduced an `HStack` and wrapped
    this around our current `VStack`, which allows us to now add views outside of
    our original `VStack` and align them horizontally, just like we've done with the
    `Image` view.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `Spacer()` view in SwiftUI has pushed out our two horizontal
    views (our `VStack` on the left and `Image` on the right) so that they act as
    leading and trailing views to the parent view (the body, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The base of our app is now ready to hook up to an external data source, but
    first, let''s go over how modifiers work and how we can create our very own. Either
    add the following code to your `ListRowView.swift` file or create a new file (it''s
    up to you):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a struct called `CategoryText` that conforms to the `ViewModifier`
    protocol. In here, there is a function called `Body` for which we are setting
    the modifiers of `.font` and `.foregroundColor`. These modifiers are available
    on anything that inherits from `View`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to have a play around with some of the modifiers available. You could
    add the following and really give the `Category` label a little punch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add this to our `Text` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using the `.modifier` (modifier) in order to call our custom struct;
    this is good from a readability point of view as it allows you to quickly identify
    anything that could potentially be custom as opposed to anything that is a system
    API. However, if you are like me and want it to look just right, simply create
    an extension of `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed we glossed over assigning a specific image to a category.
    This was with good reason, as I wanted to expand further on the use of SF Symbols
    within SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: Also available for use with UIKit, SF Symbols works exceptionally well in SwiftUI,
    especially when used with modifiers like the ones we've just been playing with.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF Symbols are exactly what they say they are—symbols (not images), they are
    fonts and can be treated just like fonts too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: No need for stretching images or **2x** or **3x** images' assets. SF Symbols
    will handle this just like having your own vector right in the app, with the added
    benefit that it's all included in the Swift API without extra assets bulking up
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name of the symbol is just written in plain text, let''s write a little
    function that works out what we need to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In an ideal world, our categories would be enums with `String` values that
    we could cast to, but for this demo, a basic string match will suffice. Now, replace
    the static text in the `Image` constructor to call this new static function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The only drawback is the following: is the image you want to use included in
    the library?'
  prefs: []
  type: TYPE_NORMAL
- en: With iOS 14, Apple introduced a much wider range of SF Symbols. There's even
    a Mac app you can download that catalogs all these for you in a nice **graphical
    UI** (**GUI**).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've touched on the Preview Provider a couple of times so far, but this handy
    little feature of SwiftUI does have a couple more tricks up its sleeve.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the device it will preview on will be that of the one currently
    selected in Xcode, but if you want to change this, simply add in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`.previewDevice`—This specifies the device you want to use—the raw value string
    matched that of an internal enum for that specific device (*basically the string
    name as you would see in the simulator list*).'
  prefs: []
  type: TYPE_NORMAL
- en: '`.previewDisplayName`—This is a custom name given for that device, as shown
    in the Live Preview window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The display name can come in handy for other reasons too, specifically if we
    have more than one preview running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As highlighted, we've created an additional preview to run in our Live Preview
    window, which in turn passes in different data and tests on a different device.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we could create mock data for every condition or style we wanted
    and have them previewing on all manner of device types, allowing us to test right
    there without the need to launch each version on a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI is no doubt powerful and, especially with the latest release of iOS
    14 at WWDC 2020, things have improved vastly, but we must not forget that at less
    than 2 years old it's still well within its infancy, and there will be more than
    one occasion when you'll need to revert back to UIKit for some form of component.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, Apple has us ready to go with `UIViewRepresentable`, a protocol
    that we can use to harness UIKit components and return them as SwiftUI views.
  prefs: []
  type: TYPE_NORMAL
- en: A good example would be `UITextView()`, currently not available in SwiftUI or
    any direct equivalent (*although with iOS 14, TextEditor for SwiftUI now does
    a lot of what we want, but is still not a direct replacement as such*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Swift file and call it `TextView`, then start by pasting the following
    methods in one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our `UIViewRepresentable` protocol requires us to conform to certain functions
    such as `makeUIView()`, which is, in turn, responsible for instantiating the UIKit
    component we want to wrap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With `updateUIView()`, we set the instance of our `UITextView` with whatever
    we want. Here, we are setting the `text` value from our variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add the `makeCoordinator()` function, which returns an instance
    of `Coordinator`, padding in our `@Binding` text field. The best way to think
    about the `Coordinator` is as a way of handling the delegate methods we might
    use for our UIKit component. Add in the following, and this should make more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'See how our `Coordinator` conforms to `UITextViewDelegate`, and we have `textViewDidChange()`
    in there. As our text variable being passed in is a `Binding` string, changes
    made will reflect in the delegate method being called, just as they would in UIKit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In order to call this, we would simply add this as we would any other SwiftUI
    view.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SF Symbols Mac app: [https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/](https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/)'
  prefs: []
  type: TYPE_NORMAL
- en: '`UIViewRepresentable`: [https://developer.apple.com/documentation/swiftui/uiviewrepresentable](https://developer.apple.com/documentation/swiftui/uiviewrepresentable)'
  prefs: []
  type: TYPE_NORMAL
- en: Combine and data flow in SwiftUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, the reactive programming stream has played a big part in development
    architecture in terms of iOS and macOS. You may have heard of RxSwift and RxCocoa,
    a massive community committed to the reactive stream that allows for asynchronous
    events to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with the terminology of Rx or reactive programming,
    you may have seen the use of **Publishers**, **Subscribers**, and **Operators**
    in your code base. If you have, then you've most likely been subject to reactive
    programming at some point.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to take a look at Apple's offering for reactive
    programming, called **Combine**. Introduced alongside SwiftUI at WWDC 2019, Combine
    is the perfect accompaniment for the new layout and structure of SwiftUI (although
    not bound solely to SwiftUI). We'll take a look at how we can create a seamless
    flow of data from our REST API, right up to our UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this section, you'll need the latest version of Xcode from the Mac App Store
    and the project from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll start by updating our `Task` model to a class, by making the
    following highlighted changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've converted our model to a class (more on that later), and have added
    a custom initializer and a couple of computed properties too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also added a variable of type `TaskResponse`, so let''s go ahead and
    create that now in a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a basic codable response from the REST API we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for a bit of boilerplate networking code; create a new file called `NetworkManager.swift`
    and add the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a basic implementation of `URLSession`, which is being passed
    a **Uniform Resource Locator** (**URL**), parsing the **JavaScript Object Notation**
    (**JSON**) response into a `Codable` object (our `TaskResponse` model). The function
    we've created has a completion handler that returns an array of our `TaskResponse`
    model, should the response and decoding be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a file called `TaskViewModel` and add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I've highlighted some areas of interest. First is how
    we've conformed our class to `ObservableObject`—this is required as our `tasks`
    variable has the `@Published` wrapper and will be looking for changes as and when
    they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the local URL we're passing into our `NetworkingManager`—this is our
    local instance of the REST API we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, head on back over to our `ContentView.swift` file and make the following
    highlighted changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We've now renamed our `tasks` variable to `model`, and this in turn has now
    created a new instance of `TaskViewModel()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve updated a few things here, the structure of how we inject our mock
    data will need adjusting too, so make the following highlighted changes to our
    `MockHelper` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As our `ContentView` now accepts an array of `TaskResponse`, we've just made
    the adjustment accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the magic—from our previous project, launch our local instance of our
    Task API and add a couple of things into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, it''s time to see the magic happen. Launch the app, and if
    all''s going well, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c69127f9-fd03-4bfb-8a1c-249b6823c02b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Launching the app
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple yet exceptionally effective demonstration of how Combine can
    and should be used within SwiftUI. Let's take a look now at how all this actually
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start at the `ContentView` and work our way back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Two things to note here—our model is that of an `@ObservedObject`, meaning any
    changes made to this model will result in an update being fired and thus forcing
    a refresh of our UI (just like we saw with `@State` earlier).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re instantiating our `TaskViewModel()` when the `ContentView` is
    rendered. Let''s dive into our `TaskViewModel` and see why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We already touched earlier on our class conforming to `ObservableObject`. This
    is what allows us to use `@ObservedObject` when declaring this back over in our
    `ContentView` (we're creating a **data flow** connection, so to speak).
  prefs: []
  type: TYPE_NORMAL
- en: Notice here that we've also added a call to our `getTasks()`function so that
    when we initialize the class (back over in `ContentView`), we'll kick off a networking
    request to get a list of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now have a quick look inside our `getTasks()` function, you''ll see that
    once we get a successful response, we assign this to our `@Published tasks` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: And as soon as the variable is updated, our `Observable` object class lets anything
    listening know about a change (our `@ObservedObject` in our `ContentView`, for
    example).
  prefs: []
  type: TYPE_NORMAL
- en: If you think back to how the `UITableView` works, if there are any updates or
    changes to the data source, we then have to call `UITableView.reloadData()`manually,
    and within our UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, everything has been handled the way it should be and is
    in the right place, passing data changes from the source of truth up to the UI
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift Combine: [https://developer.apple.com/documentation/combine](https://developer.apple.com/documentation/combine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
