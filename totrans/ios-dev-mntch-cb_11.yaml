- en: Chapter 11. Graphics and Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation with images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines and curves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple drawing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to discuss about custom drawing and animations.
    The iOS SDK contains two very useful frameworks for these tasks: Core Graphics
    and Core Animation.'
  prefs: []
  type: TYPE_NORMAL
- en: These two frameworks simplify the process of animating UI elements and drawing
    2D graphics on them. The effective usage of these two frameworks will make a difference
    between a dull and a stunning application. After all, these two frameworks play
    a very important role in making the iOS platform unique in its kind.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to provide simple or even more complicated animations for
    controls to provide a unique user experience. We will also see how to custom draw
    lines, curves, shapes, and text on the screen. Finally, with all the examples
    provided, we will create two drawing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Animating Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to take advantage of `UIKit` animations to
    move a `UILabel` on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `ViewAnimationApp`. Add a label
    and a button on the view of `MainController`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the `MonoTouch.ObjCRuntime` namespace, and enter the following `ViewDidLoad`
    override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the **Animate!** button, and watch the label move to the lower part of
    the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIView` class contains a number of various static methods that are targeted
    to animations. In this example, we simply change the position of a label with
    an animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To animate the change of position, we need to apply the changes after a call
    to the `BeginAnimations` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It accepts one string parameter, which declares the name of the animation.
    Changes we make to views after this call will be animated. But, we can also adjust
    various animation parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `SetAnimationDuration` method defines the duration of the animation in seconds.
    The `SetAnimationCurve` method defines the default easing functions that will
    be applied to the animation at its start point and/or its end point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the option of executing code when the animation completes. To do this,
    we first need to set the animation delegate object with the `SetAnimationDelegate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we set our controller object, `MainController`, as the animation
    delegate object. After setting the delegate object, we need to set the selector
    that will be called when the animation completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a `Selector` instance, we need to use the `MonoTouch.ObjCRuntime`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After making all the adjustments for our animation, we set the new value to
    the object that will be animated and call the `CommitAnimations` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the code below the `BeginAnimations` call will be executed at the
    `CommitAnimations` line. Also, every animation started with the `BeginAnimations`
    method should have a corresponding call to the `CommitAnimations` method, or unexpected
    results will occur; for example, every change that is made to UI elements will
    be animated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIView` class also contains an overloaded `Animate` method. This method
    basically wraps all the methods we used here in one. The previous example, with
    the `Animate` method, is represented with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter of this overload is the delay after which the animation
    will start.
  prefs: []
  type: TYPE_NORMAL
- en: UIKit animations and iOS versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Animate` method was introduced on iOS version 4.0\. When targeting an iOS
    version prior to 4, use the animation block, as defined by the `BeginAnimations`
    and `CommitAnimations` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Animatable properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`UIKit` animations support a specific set of `UIView` properties. These properties
    are called **animatable** properties. Following is a list of `UIView` properties
    that can be animated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Frame`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bounds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Center`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Transform`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alpha`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BackgroundColor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentStretch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will rotate a `UILabel` by applying a transformation. Furthermore,
    the rotation will be animated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `TransformViewApp`. Add a label
    and a button on the view of `MainController`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the `MonoTouch.CoreGraphics` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the button and watch the label rotate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the `CoreGraphics`
    framework. This framework is the basic graphics framework of iOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To rotate a view, we need a transformation object that will be applied to the
    view through its `Transform` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The transformation object is an instance of the class `CGAffineTransform` and
    is initialized through the `MakeRotation` static method. This method accepts a
    float value of the angle of rotation that we want to be applied, in radians. The
    `DegreesToRadians` method can be used to convert degrees to radians. After creating
    the transformation object, we assign it to the label''s `Transform` property inside
    an animation block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to increment the rotation angle each time the button is pressed,
    because the transformation we apply is not being auto-incremented. If we apply
    another rotation transformation object with the same angle, there will be no effect
    since it is basically the same transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the label has been rotated to a full circle (=360 degrees), we reset the
    `rotationAngle` value and the transformation object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `MakeIdentity` static method creates an identity transformation object,
    which is the default transformation of all views, before applying transformation
    objects to them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CGAffineTransform` class contains various static methods for creating
    transformation objects. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CGAffineTransformInvert:` This method inverts a current transformation and
    returns the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeIdentity:` This method creates an identity transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeRotation:` This method creates a rotation transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeScale:` This method creates a scale transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeTranslation:` This method creates a translation transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Multiply:` This method multiplies two transformations and returns the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation and frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After applying transformations on a view, its `Frame` property must not be taken
    into account. If there is a need for altering the view's size or position after
    a transformation has been applied, use the `Bounds` and `Center` properties, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Animating views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Animating layers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation with images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a simple slideshow of images using the built-in
    animation feature of `UIImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `ImageAnimationApp`. Add a
    `UIImageView` and two buttons on the view of `MainController`. The sample project
    for this task contains three images. Add two or more images to the project, and
    set their **Build Action** to **Content**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following `ViewDidLoad` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Animate images** button to start the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIImageView` can accept an array of `UIImage` objects and automatically
    display them in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the images that the view will animate, assign an array of the images
    to its `AnimationImages` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The sequence in which the images will be displayed is defined by their order
    in the array. After setting the images that will be animated, we set the duration
    of the animation in seconds and the number of times it will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To start or stop the animation, call the `StartAnimating` or `StopAnimating`
    methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no relation between the `AnimationImages` and `Image` properties of
    the `UIImageView` class. Set an image to be displayed to the `Image` property
    before or after an animation, if one needs to be displayed when no animation takes
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To determine if an animation takes place, check the `IsAnimating` property of
    `UIImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Animating views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"), User Interface:
    Views:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Displaying images*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `Core Animation` framework to copy
    a `UILabel` on the screen, by animating its layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `LayerAnimation`. Add two labels
    and a button on the view of `MainController`. Set text and background color for
    the first view and a different background color for the second view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add `MonoTouch.CoreAnimation` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a field of the type `CALayer` in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Copy** button to copy the contents of the first label to the second
    label with animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.CoreAnimation` namespace is a wrapper around the `Core Animation`
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Every view has a `Layer` property, which returns the view's `CALayer` object.
    In this task, we are creating an animation that graphically displays copying label
    contents from one label to another.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating another label and moving it with `UIView` animation, we
    will create a layer and move that instead. We create the layer by setting its
    `Frame` and `Contents` property, the latter from the source label's layer. We
    then add the layer to the main view's layer with the `AddSublayer` method. After
    this point, the main view contains a layer, which displays the same contents and
    is on top of the source label.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To animate the transition from the source label to the target label, we will
    use the `CABasicAnimation` class. The previous highlighted code shows how to initialize
    and set up the instances of the class. The `FromKeyPath` static method creates
    a new instance, accepting as a parameter the name of the layer's property that
    will be animated. The `To` property represents the value the property will be
    animated to. The `Duration` property represents the duration of the animation
    in seconds, while the `RemovedOnCompletion` property declares that the animation
    object should be removed from the layer when the animation finishes. The `TimingFunction`
    property sets the behavior of the animation. The `AnimationStopped` event is triggered
    when the animation finishes. Inside the handler we assign to it, we set the contents
    of the source label to the target label, thus completing the copy. The `AutoReverses`
    property states that when the value of the `To` property has been reached, the
    animation should be reversed. It is this property that gives the effect of the
    label getting bigger and subsequently smaller when it reaches its final position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animations start when they are added to the layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A list of strings that the `FromKeyPath` method accepts can be found in the
    following link: `http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreAnimation_guide/Articles/KVCAdditions.html#//apple_ref/doc/uid/TP40005299`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the `To` property, the `CABasicAnimation` class has two more properties
    for defining the animation: `From` and `By`. They are all of the type `NSObject`,
    but the actual values that should be assigned to them should be of the type `NSValue`.
    The `NSValue` class contains various static methods for creating instances of
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Layers** are very powerful and efficient objects that can be used for both
    drawing and animations. Using layers to perform animations on views, instead of
    the actual views themselves, is strongly suggested.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter
  prefs: []
  type: TYPE_NORMAL
- en: '*Animating Views*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines and curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will implement custom drawing to draw two lines on a `UIView`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `DrawLineApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a new class to the project, and name it `DrawingView`. Derive it from `UIView:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `using` directive in the `DrawingView.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `Draw` method of `UIView`, and implement it with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` override of the `MainController`, initialize and add the
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. The result should be similar
    to the following:![How to do it...](img/1468EXP_11_03a.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.CoreGraphics` namespace is a wrapper around the native `Core
    Graphics` framework. The `Core Graphics` framework contains the necessary objects
    for custom drawing on views.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw on a view, we have to override its `Draw(RectangleF)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Draw` method, we need an instance of the current graphics context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A graphics context is represented by the `CGContext` class. The `UIGraphics.GetCurrentContext`
    static method returns an instance of the current context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CGContext` class contains various methods that allows us to draw on the
    view. We need to set the line width, the color, and then add the type of drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a line, we use the `AddLines` method that accepts an array of `PointF
    structs` containing the start and end points of each line. Just adding the lines
    to the context is not enough. To present the drawing on the view, we call the
    `StrokePath` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To add another item to the drawing, we repeat the steps accordingly. The `MoveTo`
    method moves the current point so that the additional item will have a starting
    point for the curve.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Draw` method is being called by the runtime when it needs to draw the contents
    of a view. We can only get the instance of the current graphics context inside
    the `Draw` method. We should not call it directly, since the `UIGraphics.GetCurrentContext`
    method will return `null` if we do. If we need to force the runtime to call the
    `Draw` method, we need to call `SetNeedsDisplay()`. Care should be taken when
    calling it, since drawing operations are expensive in terms of CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: When there is no need for causing the entire view area to be redrawn, we can
    call the `SetNeedsDisplayInRect` method, passing the `RectangleF` in the view's
    coordinate system of the area that we want to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics context on a UIImageView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current graphics context of a `UIImageView` is reserved for drawing the
    contents of the image. Calling `SetNeedsDisplay` on a custom view deriving from
    `UIImageView` has the same effect as calling the `Draw` method directly. If we
    need to draw on a custom image view, we have to either add another view on top
    of it and draw on that, or draw on a custom layer and add it to the view's main
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Drawing text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"), User Interface:
    Views:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating* a *custom view*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the example in the previous recipe, we will draw a circle and a square
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `DrawShapeApp`. Add a custom
    view like in the previous task, and name it `DrawingView`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code in the `Draw` method override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the application on the simulator. The result on the screen
    should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To draw shapes on a view, we need to call the appropriate method. We first
    set the fill color of the `CGContext` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw a circle, we call the `AddEllipseInRect` method, passing a `RectangleF`
    object containing the bounding rectangle of the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether the shape will be an ellipse or an absolute circle is defined through
    the bounding rectangle''s size. We then call the `FillPath` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The shadow effect is defined by the `SetShadow` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, which is of the type `SizeF`, defines the offset of the
    shadow, while the second parameter defines the amount of blur.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `SetShadow` method is called, all objects that are added to the context
    are displayed with a shadow. To remove the shadow, call the `SetShadowWithColor`
    method, passing either a fully transparent color or `null` for the color parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To fill a shape with a transparent color, create a `CGColor` instance with
    the appropriate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will create a red color with its alpha set to 50 percent.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Drawing lines and curves*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to draw styled text with an outline.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `DrawTextApp`. Add the `DrawingView`
    class that we created in the previous tasks to the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the following `Draw` method override in the `DrawingView` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the application on the simulator. The text will be displayed
    on the screen. The result should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NSString` class contains the very useful method `DrawString`, which draws
    the text it contains to the current context. To provide the outline effect, we
    call the `SetTextDrawingMode` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We pass the `CGTextDrawingMode.FillStroke` value. Since we have not set a stroke
    color to the context, it defaults to black.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `DrawString` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This method is overloaded. The overload we use here accepts a `PointF struct`,
    which represents the location of the string in the view's coordinate system, and
    a `UIFont` instance that represents the font by which the text will be rendered
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CGContext` class contains the method for drawing text. We first need to
    call `SelectFont` method to assign the font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call the `ShowTextAtPoint` method to draw the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1468EXP_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The text will be displayed at the correct position, but reversed. To correct
    this, we need to set a transformation matrix to the `TextMatrix` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The biggest advantage in using the `CGContext` class'' methods is that we can
    easily transform the text appearance. For example, by applying a slightly different
    transformation matrix, we can easily display skewed text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![There''s more...](img/1468EXP_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Size of drawn text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `DrawString` method of the `NSString` class returns the size of the bounding
    rectangle of the text. We can, however, get the size of the text before drawing
    through the `StringSize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Drawing lines and curves*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing shapes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple drawing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the techniques that we learned to create a drawing
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `FingerDrawingApp`. Once again,
    we will need a custom view. Add a class deriving from `UIView`, and name it `CanvasView`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the `CanvasView` class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator or on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Touch and drag your finger (or click-and-drag with the cursor) and start drawing!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we are combining touch events and custom drawing to create a simple
    drawing application. When the user touches and moves the finger on the screen,
    we keep the touch location points information and use them in the `Draw` method
    to draw lines.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the touch locations to the class fields, we call `SetNeedsDisplay`
    to force the `Draw` method to be called. The `fingerDraw` field is used to determine
    if the `Draw` method was called by a touch on the screen and not by the runtime
    when the view is first loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we call a method to draw something to a graphics context, the previous
    drawings in that context are cleared. To avoid this behavior, we use a `CGPath`
    object. We can add various drawing objects in a `CGPath` and display these objects
    on the screen by adding them to the graphics context. So, every time the user
    moves the finger on the screen, the new lines defined by the touch location points
    are added to the path, and the path is drawn on the current context.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we need to hold information of both the current touch location and
    the previous one. This is because the `AddLineToPoint` method accepts one point,
    which defines the end point of the line, assuming there already is a point in
    the path. The starting point of each line is defined by calling `MoveToPoint`,
    passing the previous touch location point.
  prefs: []
  type: TYPE_NORMAL
- en: The path that is drawn on the screen by sliding the finger on it is basically
    comprised of a series of consecutive straight lines. The result, however, is a
    smooth path that follows the finger movement, because the `TouchesMoved` method
    is triggered every time there is a single movement of the finger on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the line to the path, we add it to the context and draw it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two new `CGContext` methods are introduced in this task: `SetLineJoin` and
    `SetLineCap`. The `SetLineJoin` method sets how each line will be joined to the
    previous one, while the `SetLineCap` sets the appearance of the endpoint of a
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values they accept are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetLineJoin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CGLineJoin.Miter:` Joins two lines with an angled corner'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CGLineJoin.Round:` Joins two lines with a rounded end'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CGLineJoin.Bevel:` Joins two lines with a squared end'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetLineCap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CGLineCap.Butt:` The line will end with a squared edge on the endpoint'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CGLineCap.Round:` The line will end with a rounded edge that expands beyond
    the endpoint'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CGLineCap.Square:` The line will end with a squared edge that expands beyond
    the endpoint'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear the drawing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To clear the drawing, we simply have to set the `fingerDraw` variable to `false`
    and call `SetNeedsDisplay`. This way, the `Draw` method will be called without
    our custom drawing code, clearing the current context.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Drawing lines and curves*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing shapes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will expand the finger drawing application that we created
    previously by providing the user with the feature of saving the created drawings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `ImageContextApp`. Add the
    `CanvasView` class that we created in the previous task to the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add two buttons on the view of `MainController`. One will be used for saving
    the image and the other for clearing the current drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following methods in the `CanvasView` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw something on the canvas, and tap the **Save drawing** button to save your
    drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the **Clear** drawing button to clear the canvas. You can then check
    the simulator's photo albums for your drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `UIGraphics` class, we can create an image context through which we
    can retrieve our drawing in a `UIImage` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an image context, inside the `GetDrawingImage` method we call the
    `BeginImageContext` static method, passing the size we want the image context
    to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The current context is now the image context that we created with the `BeginImageContext`
    call. We then repeat the code we have in the `Draw` method, only this time there
    is no need to add new lines to the path. We simply add the path we already have
    to the context and draw it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the path, we get the context image by calling the `GetImageFromCurrentContext`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to end the image context block and return the `UIImage` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To clear the drawing from the screen, we simply have to set the `fingerDraw`
    variable to `false` and dispose and prepare our `CGPath` object for re-use, inside
    the `ClearDrawing` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To reflect the clearing on the screen immediately, we call the `SetNeedsDisplay`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot create an image context inside the `Draw` method. That is because
    when we call the `BeginImageContext` method, a context is actually created, but
    the view's default context remains as the current context. Hence, the `GetImageFromCurrentImageContext`
    method would return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing on UIImageView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The technique discussed here can be used to draw on custom `UIImageViews`. To
    display the drawing when the finger slides on the screen, we would simply have
    to set its `Image` property to the image we get from the image context.
  prefs: []
  type: TYPE_NORMAL
- en: Background on saved drawings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that although we are setting the `CanvasView` background to
    gray, the saved drawings are with a white background. This is because the view's
    background color is not included in the drawing. To include it, we would just
    have to draw a rectangle with the same color as the background color to the graphics
    context.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Drawing lines and curves*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing shapes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A simple drawing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
