- en: Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is an asynchronous approach to event handling. We encounter
    asynchronous events, such as user interactions with the interface or the delivery
    of long-term operation results, all the time. There are also libraries, such as
    [RxJava](https://github.com/ReactiveX/RxJava) and [Reactor](https://github.com/reactor/reactor-core)[,](https://github.com/reactor/reactor-core)
    [that allow us to write reactive code in Kotlin or Java. ](https://github.com/reactor/reactor-core)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the Observer pattern, and how to transform
    asynchronous events from one type to another. You will also learn how to use the
    Mono, Single, Observable, and Flux classes that implement the reactive programming
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming with Spring Reactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking and non-blocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJava in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to apply reactive programming to
    your applications, using the RxJava and Reactor libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the examples from this chapter on GitHub, at the following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8).
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate the Reactor library into your project, add the following line
    to the repositories section of the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to the dependencies section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Reactor library works with a version of the **Java Development Kit** (**JDK**),
    8 or above. So, we should add the following line to the Android section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate the RxJava library, add the following line to the dependencies
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate the RxAndroid library, add the following line to the dependencies
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate the RxBinding library, you should add the following line to the
    dependencies section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Reactive programming with Spring Reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactor** is a library that implements reactive programming concepts for
    the JVM. This approach is based on the Observer pattern, and it provides types
    that can emit *zero*, *one*, or a sequence of values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement the Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Flux publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Mono publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Observer pattern* assumes that there is an object that sends a message,
    and another object that receives it. The following diagram shows how a class hierarchy
    can be organized to implement this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c728260a-1d64-439a-a06e-070d957d0511.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Activity` class implements the `OnClickListener` interface and contains
    an instance of the `Button` class, while the `Button` class contains the `performClick`
    method that invokes the `onClick` method of an instance of the `OnClickListener` class,
    if it is not null. The `onClick` method of the activity will then be invoked.
    In this way, an instance of the `Activity` class will be notified when a user
    clicks on the button.
  prefs: []
  type: TYPE_NORMAL
- en: The following example code shows how this approach works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ObserverActivity` contains an instance of the `Button` class and invokes
    the `setOnClickListener` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setOnClickListener` method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `performClick` method invokes the `onClick` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the `performClick` method invokes the `onClick` method if a
    reference of the `OnClickObserver` type is not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The Flux publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Flux` class represents a stream of values. This means that an instance
    of the Flux type can emit values, and a subscriber can receive them. This class
    contains a lot of functions that can be divided into two groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Static factories that allow us to create a new instance of the Flux type from
    different sources, such as callbacks or arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators that allow us to process emitted values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example code shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `fromArray` function creates a new instance of the Flux type that emits
    values from passed arrays, one by one. The `map` method allows us to modify a
    value from the upstream, and the `subscribe` method is needed to pass an Observer
    that takes the resulting values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this example looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Flux` provides a lot of operators that can be used to process the emitted
    values. The following example code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `.filter`, `.map`, `.reduce`, and `.subscribe` operators are provided by
    the flux. We will look at each one of them in detail in just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the operator point of view, a stream is divided into **upstream** and
    **downstream**. An **operator** takes a value from the **upstream**, modifies
    it, and passes the result to the **downstream**. The following diagram shows how
    operators work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ae8fa34-3e97-4c59-8d24-10f3c7666035.png)'
  prefs: []
  type: TYPE_IMG
- en: From the `map` operator point of view, the values emitted from the `filter`
    function belong to the **upstream****,** and  the items that are taken by `reduce`
    belong to the **downstream**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding example looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that after all of the transformations, an instance of the `Flux`
    class emits only two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The filter operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filter` method takes a predicate, and if a value from the upstream doesn't
    meet a condition of the predicate, it isn't passed to the downstream.
  prefs: []
  type: TYPE_NORMAL
- en: '*A predicate* is a function that takes parameters and returns a Boolean value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the `filter` method works in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/172c9c74-f27b-416e-a21a-8acb847c508f.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the `filter` operator is only used to receive odd numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The map operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map` operator takes a lambda that applies a transformation for each value
    from the upstream. The `map` function can be used to change the values of the
    primitive values, or to transform an instance from one type to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad94afcb-6f3e-4dd0-82eb-557a1a9b7f45.png)'
  prefs: []
  type: TYPE_IMG
- en: The `map` function takes another function that describes how an element from
    the upstream should be transformed.
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `flatMap` operator works in a similar way to the map, but works *asynchronously*.
    This means that it should return an instance that can return a value in the future,
    such as `Flux` or `Mono`. The following example code shows how it can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Mono** is similar to Flux, but it can emit one or zero elements. In this
    example, we use the `delayElement` function, which is why each element is received
    by a subscriber with a one-second delay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a8f859d-7726-434a-9a0f-3cbfa74cca68.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows that each `flatMap` operator passes each value to the downstream asynchronously, with
    a one-second delay.
  prefs: []
  type: TYPE_NORMAL
- en: The reduce operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reduce` function takes an instance of the `BiFunction` type, which contains
    the `apply` function, taking two values and returning a single one. The `this`
    operator can be used to combine all items from the upstream into a single value,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95b7ff37-6c44-4513-aa81-125f09741db6.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows that the upstream contains two values, and the `reduce`
    function passes a sum of them to the downstream.
  prefs: []
  type: TYPE_NORMAL
- en: The from static method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fromArray` function is one of many static factory methods that are provided
    by the `Flux` class. If we want to create our own source of events, we can use
    the `from` function. Let's create an instance of the `Flux` class that emits the
    `Unit` object when a user clicks on the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows how to wrap an Observer into an instance of the
    `Flux` class. This example illustrates using the `from` function to create a new
    instance of the `Flux` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run an application and press the THE OBSERVER PATTERN button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/013c5fe3-ed61-471d-97ee-7d4f86d951cd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows how an example works. When a user clicks the
    button, the `onNext` method is invoked and the `Observable` emits a value. The
    lambda that we passed to the `subscribe` method is invoked, and it shows a message.
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instances of the `Activity` or `Fragment` class have life cycles that are represented
    by methods, such as `onCreate` and `onDestroy`. We should clean all resources
    by using the `onDestroy` method, in order to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `subscribe` method returns an instance of the `Disposable` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Disposable` interface contains two methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dispose` cancels a publisher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isDisposed` returns `true` if a publisher has already been cancelled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example code shows how to cancel a publisher when the `onDestroy`
    method is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `onDestroy` method invokes the `dispose` method to unsubscribe
    from an instance of the `Flux` class.
  prefs: []
  type: TYPE_NORMAL
- en: The Mono publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Mono* publisher works in a similar way to Flux, but can only emit no values
    or a single value. We can use this to perform a request to a server and return
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code makes a request and receives an instance of the
    `Comic` class, loading an instance of the `Bitmap` class and displaying the retrieved
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `subscribeOn` method is used to specify a scheduler for long-term tasks.
    Let''s run this example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccdc8149-79fb-47e2-8256-2abea4f4de2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding snippet retrieves an instance of the `Comic` class, transforms
    it to a path to an image, loads the image, and then shows a downloaded image.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking and non-blocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we work with Android, we should remember that we have a main thread that
    is responsible for a user interface. First, it is not a good idea to invoke long-term
    operations in the main thread, because in that case, a user interface freezes.
    Secondly, when we invoke a synchronous method, this blocks a thread. Our user
    interface is unresponsive until a function that is invoked from the main thread
    returns the result. That is why we should invoke a long-term operation asynchronously,
    and reactive programming can help us to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: The `Mono` and `Flux` classes contain the `publishOn` and `subscribeOn` methods
    that can switch threads when operators are invoked. The `subscribeOn` method is
    used to specify a scheduler that produces emitted values, and the `publishOn`
    is used to specify a thread scheduler for the downstream of an `observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheduler is an abstraction over thread pool. The following example code creates
    our own scheduler that uses the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can rewrite an example from the Mono publisher section, in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The single function of the `Schedulers` class returns an instance of the `Scheduler`
    type that creates and uses a single thread under the hood. The `subscribeOn` method
    specifies that all operators from the upstream have to use a scheduler that is
    returned by the `single()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We pass our own scheduler that uses **the main thread** under the hood. For
    this reason, the lambda that is passed to the `subscribe` method is performed
    on **the main thread**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aa52423-0a10-4ee4-add9-a75f074422fe.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows that **the main thread** is not blocked, and runs with a background,
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RxJava** is another popular library that implements the concept of reactive
    programming. It also provides types, such as Observable or Single, that emit values.
    All of these classes also provide static factories and operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the Flowable class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Observable class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Single class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Maybe class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Completable class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flowable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Flowable` class was introduced in the second version of the RxJava library.
    This class represents a stream of events, such as Flux from Reactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should consider using `Flowable` when you read data from a file, database,
    or network. The following example code shows how to create and use `Flowable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This shows how to create an instance of the `Flowable` class that emits values.
  prefs: []
  type: TYPE_NORMAL
- en: Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Observable` class is similar to `Flowable`, but it can throw a `MissingBackpressureException`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Backpressure** is a case when an observable produces values faster than a
    subscriber can consume them. In this case, a `MissingBackpressureException` is
    thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example use case is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows how to create an instance of the `Observable` class
    that emits values.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that `Observable` has lower overhead than `Flowable`.
    You should consider using `Observable` when you handle user interface events.
  prefs: []
  type: TYPE_NORMAL
- en: There are operators that can help you to deal with backpressure, such as *debounce*
    or *throttle*. Let's take a look at each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: The debounce operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `debounce` method takes a duration and returns an instance of the `Observable`
    class that only emits a value if a time frame that is equal to the passed time
    from the moment when the previous value was emitted. The following diagram explains
    how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ece06aa2-c584-4858-a7bf-cff9f5acff35.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows how the `debounce` method reduces events. The debounce
    method takes a time frame and returns a new instance of the `Observable` type
    that only emits the last value that was produced during this timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: The throttle operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `throttle` operator returns an instance of the `Observable` that only emits one
    item from the upstream during the sequential time window that has passed. The
    throttle is a family of methods, such as `throttleFirst` or `throttleLast`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the `throttleFirst` method works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e702ec52-aa91-4f9c-abdf-c139accd427e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `throttleLast` method works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91a1c65d-c65a-40a5-afda-80dfc4aad7c7.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagrams shows that the `throttleFirst` and `throttleLast` methods
    can be used to reduce the emitted values.
  prefs: []
  type: TYPE_NORMAL
- en: Single
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Single` class works in a similar way to `Mono` from the Reactor library.
    This can also be used to perform a request to a server. We should consider using
    `Flowable` when a source returns only one item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code shows how `Single` can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This snippet contains an instance of the `Single` class that emits one value.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An instance of the `Maybe` type can emit no value, or a single value. The following
    example code shows how to use `Maybe` and the `test` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `test` method returns an instance of the `TestObservable` that is used for
    testing and contains methods such as `assertResult`. The `defaultIfEmpty` method
    of the `Maybe` class allows us to specify a default value that can be emitted
    if an instance of the `Maybe` class is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Completable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An instance of the `Completable` class doesn't emit a value at all. It can be
    used to notify the user of task completion. In addition, it can be used when we
    delete an item from a database, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code shows a case of deleting an item from a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `test` method returns an instance of the `TestObservable` class.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJava is a very popular library for Android development, and there are a lot
    of other libraries that are based on RxJava, such as RxAndroid and RxBinding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The RxAndroid library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RxBinding library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RxAndroid library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RxAndroid library provides a scheduler that uses the main thread. The following
    example code shows how to use this scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows how to use the `observeOn` method to handle emitted
    values on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The RxBinding library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RxBinding library provides a reactive application programming interface.
    Let's imagine that we want to observe an input of `EditText` and display this
    text in `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RxBinding library provides extension functions for user interface components,
    such as `textChanges`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can implement our example by using the `textChanges` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we invoked the `textChanges` function and subscribed
    to a retrieved subscriber. The `textChanges` method returns an instance of the
    `Observable` class that emits the text from the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks as follows, and shows that the text from the input immediately
    appears on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f82913ad-fc10-497b-93e3-39d42e582950.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The RxBinding library also contains the `clicks` extension function, which
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `clicks` extension function returns an instance of the `ViewClickObservable`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `ViewClickObservable` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It uses the `subscribeActual` method to pass an instance of the `Observer` class
    to the `setOnClickListener` of an instance of the `View` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewClickObservable` class inherits from the `Observable` class and overrides
    the `subscribeActual` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `Observer` class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet invokes the `onNext` method when the `onClick` method
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at reactive programming and how it can help us to
    handle asynchronous events. We also introduced the React and RxJava libraries
    that provide classes such as `Mono`, `Flux`, `Single`, and `Observable`, which
    follow reactive programming concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming allows us to use different thread schedulers to process
    and transform events with multithreading. The Blocking and Non-Blocking section
    showed us how to work with thread schedulers. You also learned that reactive programming
    is based on the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Android applications handle a lot of different asynchronous events, such
    as user interactions and push notifications. Learning about Reactive programming
    is important, because it can help us to better manage our resources through asynchronous
    processing, allowing us to build more complex applications that are capable of
    multitasking.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to create the `Application` class.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is reactive programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the Mono class?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the Observable class?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a scheduler?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To gain more comprehensive knowledge about applying reactive programming with
    Reactor, I recommend reading *Hands-On Reactive Programming with Reactor* ([https://www.packtpub.com/application-development/hands-reactive-programming-reactor](https://www.packtpub.com/application-development/hands-reactive-programming-reactor)),
    by Rahul Sharma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
