- en: Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Reactive programming is an asynchronous approach to event handling. We encounter
    asynchronous events, such as user interactions with the interface or the delivery
    of long-term operation results, all the time. There are also libraries, such as
    [RxJava](https://github.com/ReactiveX/RxJava) and [Reactor](https://github.com/reactor/reactor-core)[,](https://github.com/reactor/reactor-core)
    [that allow us to write reactive code in Kotlin or Java. ](https://github.com/reactor/reactor-core)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是一种处理异步事件的异步方法。我们经常遇到异步事件，例如用户与界面的交互或长期操作结果的交付。还有一些库，如 [RxJava](https://github.com/ReactiveX/RxJava)
    和 [Reactor](https://github.com/reactor/reactor-core)[,](https://github.com/reactor/reactor-core)
    [允许我们在 Kotlin 或 Java 中编写响应式代码。](https://github.com/reactor/reactor-core)
- en: In this chapter, you will learn about the Observer pattern, and how to transform
    asynchronous events from one type to another. You will also learn how to use the
    Mono, Single, Observable, and Flux classes that implement the reactive programming
    concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解观察者模式，以及如何将异步事件从一种类型转换为另一种类型。你还将学习如何使用实现响应式编程概念的 Mono、Single、Observable
    和 Flux 类。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reactive programming with Spring Reactor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Reactor 进行响应式编程
- en: Blocking and non-blocking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞和非阻塞
- en: RxJava
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava
- en: RxJava in Android
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 中的 RxJava
- en: By the end of this chapter, you will be able to apply reactive programming to
    your applications, using the RxJava and Reactor libraries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 RxJava 和 Reactor 库将响应式编程应用于你的应用程序。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the examples from this chapter on GitHub, at the following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的示例，链接如下：[https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter8)。
- en: 'To integrate the Reactor library into your project, add the following line
    to the repositories section of the `build.gradle` file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Reactor 库集成到你的项目中，请在 `build.gradle` 文件的仓库部分添加以下行：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following line to the dependencies section:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请在依赖项部分添加以下行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Reactor library works with a version of the **Java Development Kit** (**JDK**),
    8 or above. So, we should add the following line to the Android section:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 库与 Java 开发工具包（**JDK**）的 8 或更高版本兼容。因此，我们应该在 Android 部分添加以下行：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To integrate the RxJava library, add the following line to the dependencies
    section:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成 RxJava 库，请在依赖项部分添加以下行：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To integrate the RxAndroid library, add the following line to the dependencies
    section:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成 RxAndroid 库，请在依赖项部分添加以下行：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To integrate the RxBinding library, you should add the following line to the
    dependencies section:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成 RxBinding 库，你应该在依赖项部分添加以下行：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reactive programming with Spring Reactor
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Reactor 进行响应式编程
- en: '**Reactor** is a library that implements reactive programming concepts for
    the JVM. This approach is based on the Observer pattern, and it provides types
    that can emit *zero*, *one*, or a sequence of values.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reactor** 是一个为 JVM 实现响应式编程概念的库。这种方法基于观察者模式，并提供可以发出 *零*、*一个* 或一系列值的类型。'
- en: 'In this section, you will learn the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习以下内容：
- en: How to implement the Observer pattern
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现观察者模式
- en: How to use the Flux publisher
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Flux 发布者
- en: How to use the Mono publisher
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Mono 发布者
- en: The Observer pattern
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'The *Observer pattern* assumes that there is an object that sends a message,
    and another object that receives it. The following diagram shows how a class hierarchy
    can be organized to implement this approach:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*观察者模式* 假设存在一个发送消息的对象，以及另一个接收消息的对象。以下图表展示了如何组织类层次结构以实现此方法：'
- en: '![](img/c728260a-1d64-439a-a06e-070d957d0511.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c728260a-1d64-439a-a06e-070d957d0511.png)'
- en: The `Activity` class implements the `OnClickListener` interface and contains
    an instance of the `Button` class, while the `Button` class contains the `performClick`
    method that invokes the `onClick` method of an instance of the `OnClickListener` class,
    if it is not null. The `onClick` method of the activity will then be invoked.
    In this way, an instance of the `Activity` class will be notified when a user
    clicks on the button.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`类实现了`OnClickListener`接口并包含一个`Button`类的实例，而`Button`类包含调用`OnClickListener`类实例的`onClick`方法的`performClick`方法，如果它不为空。然后活动中的`onClick`方法将被调用。这样，当用户点击按钮时，`Activity`类的实例将得到通知。'
- en: The following example code shows how this approach works.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了这种方法是如何工作的。
- en: 'The `ObserverActivity` contains an instance of the `Button` class and invokes
    the `setOnClickListener` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObserverActivity`包含一个`Button`类的实例并调用`setOnClickListener`方法：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `setOnClickListener` method looks as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`setOnClickListener`方法如下所示：'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `performClick` method invokes the `onClick` function, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`performClick`方法调用`onClick`函数，如下所示：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This shows that the `performClick` method invokes the `onClick` method if a
    reference of the `OnClickObserver` type is not `null`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明如果`OnClickObserver`类型的引用不为`null`，则`performClick`方法将调用`onClick`方法。
- en: The Flux publisher
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux发布者
- en: 'The `Flux` class represents a stream of values. This means that an instance
    of the Flux type can emit values, and a subscriber can receive them. This class
    contains a lot of functions that can be divided into two groups:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux`类代表一个值流。这意味着Flux类型的实例可以发出值，订阅者可以接收它们。此类包含许多函数，可以分为两组：'
- en: Static factories that allow us to create a new instance of the Flux type from
    different sources, such as callbacks or arrays.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态工厂允许我们从不同的来源创建Flux类型的新实例，例如回调或数组。
- en: Operators that allow us to process emitted values
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们处理发出值的操作符
- en: 'The following example code shows how this works:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了这是如何工作的：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `fromArray` function creates a new instance of the Flux type that emits
    values from passed arrays, one by one. The `map` method allows us to modify a
    value from the upstream, and the `subscribe` method is needed to pass an Observer
    that takes the resulting values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromArray`函数创建了一个新的Flux类型实例，该实例从传递的数组中逐个发出值。`map`方法允许我们修改上游的值，而`subscribe`方法需要传递一个Observer来接收结果值。'
- en: 'The output of this example looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下所示：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Flux` provides a lot of operators that can be used to process the emitted
    values. The following example code demonstrates this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux`提供了许多可以用来处理发出值的操作符。以下示例代码演示了这一点：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `.filter`, `.map`, `.reduce`, and `.subscribe` operators are provided by
    the flux. We will look at each one of them in detail in just a bit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`.filter`、`.map`、`.reduce`和`.subscribe`操作符由Flux提供。我们将在稍后详细查看每一个。'
- en: 'From the operator point of view, a stream is divided into **upstream** and
    **downstream**. An **operator** takes a value from the **upstream**, modifies
    it, and passes the result to the **downstream**. The following diagram shows how
    operators work:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作符的角度来看，流被分为**上游**和**下游**。一个**操作符**从**上游**获取一个值，修改它，并将结果传递到**下游**。以下图表展示了操作符是如何工作的：
- en: '![](img/3ae8fa34-3e97-4c59-8d24-10f3c7666035.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ae8fa34-3e97-4c59-8d24-10f3c7666035.png)'
- en: From the `map` operator point of view, the values emitted from the `filter`
    function belong to the **upstream****,** and  the items that are taken by `reduce`
    belong to the **downstream**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从`map`操作符的角度来看，`filter`函数发出的值属于**上游**，而`reduce`方法获取的项目属于**下游**。
- en: 'The result of the preceding example looks as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的结果如下所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output shows that after all of the transformations, an instance of the `Flux`
    class emits only two numbers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，在所有转换之后，`Flux`类的实例只发出两个数字。
- en: The filter operator
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤操作符
- en: The `filter` method takes a predicate, and if a value from the upstream doesn't
    meet a condition of the predicate, it isn't passed to the downstream.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法接受一个谓词，如果上游的值不满足谓词的条件，则不会将其传递到下游。'
- en: '*A predicate* is a function that takes parameters and returns a Boolean value.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*谓词*是一个接受参数并返回布尔值的函数。'
- en: 'The following diagram shows how the `filter` method works in the previous example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了在前一个示例中`filter`方法的工作原理：
- en: '![](img/172c9c74-f27b-416e-a21a-8acb847c508f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/172c9c74-f27b-416e-a21a-8acb847c508f.png)'
- en: In this example, the `filter` operator is only used to receive odd numbers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`filter`操作符仅用于接收奇数。
- en: The map operator
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`map`操作符'
- en: The `map` operator takes a lambda that applies a transformation for each value
    from the upstream. The `map` function can be used to change the values of the
    primitive values, or to transform an instance from one type to another.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`操作符接受一个lambda，它为上游的每个值应用一个转换。`map`函数可以用来更改原始值的值，或者将一个实例从一种类型转换到另一种类型。'
- en: 'The following diagram shows how this works:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了它是如何工作的：
- en: '![](img/ad94afcb-6f3e-4dd0-82eb-557a1a9b7f45.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad94afcb-6f3e-4dd0-82eb-557a1a9b7f45.png)'
- en: The `map` function takes another function that describes how an element from
    the upstream should be transformed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数接受另一个函数，该函数描述了上游元素应该如何转换。'
- en: The flatMap operator
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`flatMap`操作符'
- en: 'The `flatMap` operator works in a similar way to the map, but works *asynchronously*.
    This means that it should return an instance that can return a value in the future,
    such as `Flux` or `Mono`. The following example code shows how it can be used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`操作符与`map`类似，但它是**异步**的。这意味着它应该返回一个可以在未来返回值的实例，例如`Flux`或`Mono`。以下示例代码展示了如何使用它：'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of this example looks as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下所示：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Mono** is similar to Flux, but it can emit one or zero elements. In this
    example, we use the `delayElement` function, which is why each element is received
    by a subscriber with a one-second delay.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mono**与`Flux`类似，但它可以发出一个或零个元素。在这个例子中，我们使用了`delayElement`函数，这就是为什么每个元素都是通过一个订阅者以一秒的延迟接收到的。'
- en: 'The following diagram shows how it works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了它是如何工作的：
- en: '![](img/8a8f859d-7726-434a-9a0f-3cbfa74cca68.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a8f859d-7726-434a-9a0f-3cbfa74cca68.png)'
- en: This shows that each `flatMap` operator passes each value to the downstream asynchronously, with
    a one-second delay.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明每个`flatMap`操作符都会异步地将每个值传递到下游，并延迟一秒钟。
- en: The reduce operator
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`reduce`操作符'
- en: 'The `reduce` function takes an instance of the `BiFunction` type, which contains
    the `apply` function, taking two values and returning a single one. The `this`
    operator can be used to combine all items from the upstream into a single value,
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数接受`BiFunction`类型的实例，该实例包含`apply`函数，它接受两个值并返回一个。可以使用`this`操作符将上游的所有项目组合成一个单一值，如下所示：'
- en: '![](img/95b7ff37-6c44-4513-aa81-125f09741db6.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95b7ff37-6c44-4513-aa81-125f09741db6.png)'
- en: The preceding diagram shows that the upstream contains two values, and the `reduce`
    function passes a sum of them to the downstream.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示上游包含两个值，`reduce`函数将它们的和传递到下游。
- en: The from static method
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`from`静态方法'
- en: The `fromArray` function is one of many static factory methods that are provided
    by the `Flux` class. If we want to create our own source of events, we can use
    the `from` function. Let's create an instance of the `Flux` class that emits the
    `Unit` object when a user clicks on the button.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromArray`函数是`Flux`类提供的许多静态工厂方法之一。如果我们想创建自己的事件源，我们可以使用`from`函数。让我们创建一个当用户点击按钮时发出`Unit`对象的`Flux`类实例。'
- en: 'We can implement this case as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式实现这个案例：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding snippet shows how to wrap an Observer into an instance of the
    `Flux` class. This example illustrates using the `from` function to create a new
    instance of the `Flux` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了如何将观察者包装成`Flux`类的实例。这个例子说明了如何使用`from`函数创建`Flux`类的新实例。
- en: 'Let''s run an application and press the THE OBSERVER PATTERN button:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个应用程序并按下“THE OBSERVER PATTERN”按钮：
- en: '![](img/013c5fe3-ed61-471d-97ee-7d4f86d951cd.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/013c5fe3-ed61-471d-97ee-7d4f86d951cd.png)'
- en: The preceding screenshot shows how an example works. When a user clicks the
    button, the `onNext` method is invoked and the `Observable` emits a value. The
    lambda that we passed to the `subscribe` method is invoked, and it shows a message.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了示例的工作方式。当用户点击按钮时，`onNext`方法被调用，并且`Observable`发出一个值。我们传递给`subscribe`方法的lambda被调用，并显示一条消息。
- en: Cancellation
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消
- en: Instances of the `Activity` or `Fragment` class have life cycles that are represented
    by methods, such as `onCreate` and `onDestroy`. We should clean all resources
    by using the `onDestroy` method, in order to avoid memory leaks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`或`Fragment`类的实例具有由方法表示的生命周期，例如`onCreate`和`onDestroy`。我们应该使用`onDestroy`方法清理所有资源，以避免内存泄漏。'
- en: 'The `subscribe` method returns an instance of the `Disposable` type, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`方法返回一个`Disposable`类型的实例，如下所示：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Disposable` interface contains two methods, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Disposable`接口包含两个方法，如下所示：'
- en: '`dispose` cancels a publisher'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispose` 取消发布者'
- en: '`isDisposed` returns `true` if a publisher has already been cancelled'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDisposed` 如果发布者已经被取消返回 `true`'
- en: 'The following example code shows how to cancel a publisher when the `onDestroy`
    method is invoked:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了在调用 `onDestroy` 方法时如何取消发布者：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the `onDestroy` method invokes the `dispose` method to unsubscribe
    from an instance of the `Flux` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`onDestroy` 方法调用 `dispose` 方法来取消对 `Flux` 类实例的订阅。
- en: The Mono publisher
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono 发布者
- en: The *Mono* publisher works in a similar way to Flux, but can only emit no values
    or a single value. We can use this to perform a request to a server and return
    the result.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mono* 发布者与 Flux 的工作方式类似，但只能发出没有值或单个值。我们可以使用这个来向服务器发起请求并返回结果。'
- en: 'The following example code makes a request and receives an instance of the
    `Comic` class, loading an instance of the `Bitmap` class and displaying the retrieved
    image:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码发起请求并接收 `Comic` 类的实例，加载 `Bitmap` 类的实例并显示检索到的图像：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `subscribeOn` method is used to specify a scheduler for long-term tasks.
    Let''s run this example, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn` 方法用于指定长期任务的调度器。让我们按照以下方式运行此示例：'
- en: '![](img/ccdc8149-79fb-47e2-8256-2abea4f4de2b.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccdc8149-79fb-47e2-8256-2abea4f4de2b.png)'
- en: The preceding snippet retrieves an instance of the `Comic` class, transforms
    it to a path to an image, loads the image, and then shows a downloaded image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段检索 `Comic` 类的实例，将其转换为图像路径，加载图像，然后显示下载的图像。
- en: Blocking and non-blocking
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞和非阻塞
- en: When we work with Android, we should remember that we have a main thread that
    is responsible for a user interface. First, it is not a good idea to invoke long-term
    operations in the main thread, because in that case, a user interface freezes.
    Secondly, when we invoke a synchronous method, this blocks a thread. Our user
    interface is unresponsive until a function that is invoked from the main thread
    returns the result. That is why we should invoke a long-term operation asynchronously,
    and reactive programming can help us to do just that.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与 Android 一起工作时，我们应该记住我们有一个负责用户界面的主线程。首先，在主线程中调用长期操作不是一个好主意，因为在这种情况下，用户界面会冻结。其次，当我们调用同步方法时，它会阻塞一个线程。我们的用户界面在主线程调用的函数返回结果之前不会响应。这就是为什么我们应该异步调用长期操作，响应式编程可以帮助我们做到这一点。
- en: The `Mono` and `Flux` classes contain the `publishOn` and `subscribeOn` methods
    that can switch threads when operators are invoked. The `subscribeOn` method is
    used to specify a scheduler that produces emitted values, and the `publishOn`
    is used to specify a thread scheduler for the downstream of an `observable`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono` 和 `Flux` 类包含 `publishOn` 和 `subscribeOn` 方法，可以在调用操作符时切换线程。`subscribeOn`
    方法用于指定产生发出值的调度器，而 `publishOn` 用于指定 `observable` 的下游的线程调度器。'
- en: 'Scheduler is an abstraction over thread pool. The following example code creates
    our own scheduler that uses the main thread:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器是对线程池的抽象。以下示例代码创建了一个使用主线程的自己的调度器：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can rewrite an example from the Mono publisher section, in the following
    way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以以下方式重写 Mono 发布者部分的一个示例：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The single function of the `Schedulers` class returns an instance of the `Scheduler`
    type that creates and uses a single thread under the hood. The `subscribeOn` method
    specifies that all operators from the upstream have to use a scheduler that is
    returned by the `single()` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers` 类的单个函数返回一个 `Scheduler` 类型的实例，该实例在底层创建和使用单个线程。`subscribeOn` 方法指定上游的所有操作符都必须使用由
    `single()` 函数返回的调度器。'
- en: We pass our own scheduler that uses **the main thread** under the hood. For
    this reason, the lambda that is passed to the `subscribe` method is performed
    on **the main thread**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个使用 **主线程** 的自己的调度器。因此，传递给 `subscribe` 方法的 lambda 表达式在 **主线程** 上执行。
- en: 'The following diagram shows how this works:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这是如何工作的：
- en: '![](img/3aa52423-0a10-4ee4-add9-a75f074422fe.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aa52423-0a10-4ee4-add9-a75f074422fe.png)'
- en: The diagram shows that **the main thread** is not blocked, and runs with a background,
    in parallel.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示 **主线程** 没有被阻塞，并且以后台并行运行。
- en: RxJava
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava
- en: '**RxJava** is another popular library that implements the concept of reactive
    programming. It also provides types, such as Observable or Single, that emit values.
    All of these classes also provide static factories and operators.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**RxJava** 是另一个流行的库，它实现了响应式编程的概念。它还提供了类型，如 Observable 或 Single，可以发出值。所有这些类也提供了静态工厂和操作符。'
- en: 'In this section, we will cover the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下内容：
- en: How to use the Flowable class
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Flowable 类
- en: How to use the Observable class
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Observable 类
- en: How to use the Single class
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Single 类
- en: How to use the Maybe class
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Maybe 类
- en: How to use the Completable class
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Completable 类
- en: Flowable
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flowable
- en: The `Flowable` class was introduced in the second version of the RxJava library.
    This class represents a stream of events, such as Flux from Reactor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flowable` 类是在 RxJava 库的第二版中引入的。此类表示事件流，如 Reactor 中的 Flux。'
- en: 'You should consider using `Flowable` when you read data from a file, database,
    or network. The following example code shows how to create and use `Flowable`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从文件、数据库或网络读取数据时，应考虑使用 `Flowable`。以下示例代码展示了如何创建和使用 `Flowable`：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shows how to create an instance of the `Flowable` class that emits values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何创建一个发出值的 `Flowable` 类的实例。
- en: Observable
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察性
- en: The `Observable` class is similar to `Flowable`, but it can throw a `MissingBackpressureException`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 类类似于 `Flowable`，但它可以抛出 `MissingBackpressureException`。'
- en: '**Backpressure** is a case when an observable produces values faster than a
    subscriber can consume them. In this case, a `MissingBackpressureException` is
    thrown.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**背压**是指可观察性产生的值比订阅者消耗得快的情形。在这种情况下，会抛出 `MissingBackpressureException`。'
- en: 'An example use case is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例用例如下：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding snippet shows how to create an instance of the `Observable` class
    that emits values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了如何创建一个发出值的 `Observable` 类的实例。
- en: It is worth mentioning that `Observable` has lower overhead than `Flowable`.
    You should consider using `Observable` when you handle user interface events.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Observable` 的开销低于 `Flowable`。当您处理用户界面事件时，应考虑使用 `Observable`。
- en: There are operators that can help you to deal with backpressure, such as *debounce*
    or *throttle*. Let's take a look at each one of them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些操作符可以帮助您处理背压，例如 *debounce* 或 *throttle*。让我们来看看每一个。
- en: The debounce operator
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`debounce` 操作符'
- en: 'The `debounce` method takes a duration and returns an instance of the `Observable`
    class that only emits a value if a time frame that is equal to the passed time
    from the moment when the previous value was emitted. The following diagram explains
    how this works:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounce` 方法接受一个持续时间，并返回一个 `Observable` 类的实例，该实例仅在从上次发出值的时间点开始的时间段等于传递的时间时才发出值。以下图表解释了这是如何工作的：'
- en: '![](img/ece06aa2-c584-4858-a7bf-cff9f5acff35.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ece06aa2-c584-4858-a7bf-cff9f5acff35.png)'
- en: The preceding diagram shows how the `debounce` method reduces events. The debounce
    method takes a time frame and returns a new instance of the `Observable` type
    that only emits the last value that was produced during this timeframe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了 `debounce` 方法如何减少事件。`debounce` 方法接受一个时间框架，并返回一个新的 `Observable` 类型的实例，该实例仅在当前时间框架内发出在此期间产生的最后一个值。
- en: The throttle operator
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节流操作符
- en: The `throttle` operator returns an instance of the `Observable` that only emits one
    item from the upstream during the sequential time window that has passed. The
    throttle is a family of methods, such as `throttleFirst` or `throttleLast`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttle` 操作符返回一个 `Observable` 实例，该实例在上游的顺序时间窗口内只发出一个项目。节流是一系列方法，如 `throttleFirst`
    或 `throttleLast`。'
- en: 'The following diagram shows how the `throttleFirst` method works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了 `throttleFirst` 方法的工作方式：
- en: '![](img/e702ec52-aa91-4f9c-abdf-c139accd427e.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e702ec52-aa91-4f9c-abdf-c139accd427e.png)'
- en: 'The `throttleLast` method works as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleLast` 方法的工作方式如下：'
- en: '![](img/91a1c65d-c65a-40a5-afda-80dfc4aad7c7.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91a1c65d-c65a-40a5-afda-80dfc4aad7c7.png)'
- en: The preceding diagrams shows that the `throttleFirst` and `throttleLast` methods
    can be used to reduce the emitted values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示，`throttleFirst` 和 `throttleLast` 方法可以用来减少发出的值。
- en: Single
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Single
- en: The `Single` class works in a similar way to `Mono` from the Reactor library.
    This can also be used to perform a request to a server. We should consider using
    `Flowable` when a source returns only one item.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single` 类的工作方式与 Reactor 库中的 `Mono` 类似。这也可以用来向服务器发起请求。当源只返回一个项目时，我们应该考虑使用 `Flowable`。'
- en: 'The following example code shows how `Single` can be used:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何使用 `Single`：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This snippet contains an instance of the `Single` class that emits one value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段包含一个发出单个值的 `Single` 类的实例。
- en: Maybe
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maybe
- en: 'An instance of the `Maybe` type can emit no value, or a single value. The following
    example code shows how to use `Maybe` and the `test` method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe` 类型的实例可以不发出值，或者发出单个值。以下示例代码展示了如何使用 `Maybe` 和 `test` 方法：'
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `test` method returns an instance of the `TestObservable` that is used for
    testing and contains methods such as `assertResult`. The `defaultIfEmpty` method
    of the `Maybe` class allows us to specify a default value that can be emitted
    if an instance of the `Maybe` class is empty.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 方法返回一个用于测试的 `TestObservable` 类的实例，其中包含 `assertResult` 等方法。`Maybe` 类的
    `defaultIfEmpty` 方法允许我们指定一个默认值，当 `Maybe` 类的实例为空时可以发出。'
- en: Completable
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Completable
- en: An instance of the `Completable` class doesn't emit a value at all. It can be
    used to notify the user of task completion. In addition, it can be used when we
    delete an item from a database, for instance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Completable` 类的实例根本不发出任何值。它可以用来通知用户任务完成。此外，当我们从数据库中删除项时，也可以使用它。'
- en: 'The following example code shows a case of deleting an item from a database:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了从数据库中删除项的情况：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `test` method returns an instance of the `TestObservable` class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 方法返回 `TestObservable` 类的实例。'
- en: RxJava in Android
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava in Android
- en: RxJava is a very popular library for Android development, and there are a lot
    of other libraries that are based on RxJava, such as RxAndroid and RxBinding.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 是 Android 开发中非常流行的库，还有许多基于 RxJava 的其他库，例如 RxAndroid 和 RxBinding。
- en: 'This section will cover the following topics:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下主题：
- en: The RxAndroid library
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The RxAndroid library
- en: The RxBinding library
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The RxBinding library
- en: The RxAndroid library
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The RxAndroid library
- en: 'The RxAndroid library provides a scheduler that uses the main thread. The following
    example code shows how to use this scheduler:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: RxAndroid 库提供了一个使用主线程的调度器。以下示例代码展示了如何使用此调度器：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding snippet shows how to use the `observeOn` method to handle emitted
    values on the main thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了如何使用 `observeOn` 方法在主线程上处理发出的值。
- en: The RxBinding library
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The RxBinding library
- en: The RxBinding library provides a reactive application programming interface.
    Let's imagine that we want to observe an input of `EditText` and display this
    text in `TextView`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: RxBinding 库提供了一个响应式应用程序编程接口。让我们想象一下，我们想要观察 `EditText` 的输入并显示此文本在 `TextView`
    中。
- en: 'The RxBinding library provides extension functions for user interface components,
    such as `textChanges`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: RxBinding 库为用户界面组件提供了扩展函数，例如 `textChanges`：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can implement our example by using the `textChanges` function, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `textChanges` 函数来实现我们的示例，如下所示：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding snippet, we invoked the `textChanges` function and subscribed
    to a retrieved subscriber. The `textChanges` method returns an instance of the
    `Observable` class that emits the text from the input.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们调用了 `textChanges` 函数并订阅了一个检索到的订阅者。`textChanges` 方法返回一个发出输入文本的 `Observable`
    类的实例。
- en: 'The result looks as follows, and shows that the text from the input immediately
    appears on the screen:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示，显示输入文本立即出现在屏幕上：
- en: '![](img/f82913ad-fc10-497b-93e3-39d42e582950.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f82913ad-fc10-497b-93e3-39d42e582950.png)'
- en: 'The RxBinding library also contains the `clicks` extension function, which
    looks as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: RxBinding 库还包含 `clicks` 扩展函数，如下所示：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `clicks` extension function returns an instance of the `ViewClickObservable`
    class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`clicks` 扩展函数返回一个 `ViewClickObservable` 类的实例。'
- en: 'Furthermore, the `ViewClickObservable` looks as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ViewClickObservable` 看起来如下：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It uses the `subscribeActual` method to pass an instance of the `Observer` class
    to the `setOnClickListener` of an instance of the `View` class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `subscribeActual` 方法将 `Observer` 类的实例传递给 `View` 类实例的 `setOnClickListener`。
- en: The `ViewClickObservable` class inherits from the `Observable` class and overrides
    the `subscribeActual` method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewClickObservable` 类继承自 `Observable` 类并重写了 `subscribeActual` 方法。'
- en: 'Finally, the `Observer` class looks as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Observer` 类看起来如下：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding snippet invokes the `onNext` method when the `onClick` method
    is invoked.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段在 `onClick` 方法被调用时调用 `onNext` 方法。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at reactive programming and how it can help us to
    handle asynchronous events. We also introduced the React and RxJava libraries
    that provide classes such as `Mono`, `Flux`, `Single`, and `Observable`, which
    follow reactive programming concepts.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了响应式编程以及它是如何帮助我们处理异步事件的。我们还介绍了 React 和 RxJava 库，它们提供了遵循响应式编程概念的类，如
    `Mono`、`Flux`、`Single` 和 `Observable`。
- en: Reactive programming allows us to use different thread schedulers to process
    and transform events with multithreading. The Blocking and Non-Blocking section
    showed us how to work with thread schedulers. You also learned that reactive programming
    is based on the Observer pattern.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程允许我们使用不同的线程调度器以多线程方式处理和转换事件。阻塞和非阻塞部分向我们展示了如何与线程调度器协同工作。你也了解到响应式编程基于观察者模式。
- en: Modern Android applications handle a lot of different asynchronous events, such
    as user interactions and push notifications. Learning about Reactive programming
    is important, because it can help us to better manage our resources through asynchronous
    processing, allowing us to build more complex applications that are capable of
    multitasking.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现代安卓应用程序处理许多不同的异步事件，例如用户交互和推送通知。了解响应式编程非常重要，因为它可以帮助我们通过异步处理更好地管理资源，使我们能够构建能够进行多任务处理的应用程序。
- en: In the next chapter, you will learn how to create the `Application` class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何创建 `Application` 类。
- en: Questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is reactive programming?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: What is the Mono class?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Mono 类？
- en: What is the Observable class?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Observable 类？
- en: What is a scheduler?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是调度器？
- en: Further reading
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To gain more comprehensive knowledge about applying reactive programming with
    Reactor, I recommend reading *Hands-On Reactive Programming with Reactor* ([https://www.packtpub.com/application-development/hands-reactive-programming-reactor](https://www.packtpub.com/application-development/hands-reactive-programming-reactor)),
    by Rahul Sharma.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更全面地了解如何使用 Reactor 进行响应式编程，我推荐阅读 *《Reactors 响应式编程实战》* ([https://www.packtpub.com/application-development/hands-reactive-programming-reactor](https://www.packtpub.com/application-development/hands-reactive-programming-reactor))，作者：Rahul
    Sharma。
