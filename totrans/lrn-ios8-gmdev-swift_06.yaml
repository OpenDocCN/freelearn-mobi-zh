- en: Chapter 6. Audio and Parallax Effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding background music and sound effects in SpriteKit is very easy, as it is
    just a one-line code that you need to call. There are a few important things that
    need to be considered while adding the effects; for example, will the scene change
    after asking SpriteKit to play a sound? And what format should be used for the
    sound file?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be adding background music to the game and sound effects
    for the moments when the rocket gets fired, the enemy gets hit by a rocket, a
    button on the screen is pressed, and the game ends. We will also look at a free
    application that can be used to convert a sound file from one format to the other.
    In the end, we will add a nice scrolling effect to the background, for extra fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Audio file formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading and installing Audacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the audio format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding background music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallax background—theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the parallax effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio file formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpriteKit allows us to use the OSX standard `.caf` audio file format, but it
    also supports `.mp3` files. In theory, you can use any of these formats to play
    audio or effects in the game. All you will need to do is change the name of the
    file called when asking SpriteKit to play the file. But for the sake of optimization,
    we will be using an `.mp3` file format. The reason is that `.mp3` files are a
    lot smaller in size compared to `.caf` files. Take the example of the background
    music file, for instance; the `.caf` file size is 5.2 megabytes, compared to the
    `.mp3` file, which is just 475 kilobytes—roughly 10 times less than a `.caf` file,
    and the player experience won't be any different.
  prefs: []
  type: TYPE_NORMAL
- en: The more audio files you add, the more it will add to the bundle size, which
    will drastically increase the size of the game and take longer for the player
    to download and play the game. For a small game, such as ours, it might not matter
    much, but when you start making bigger games with more sound effects and background
    music, this is something to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Although `.mp3` is a very popular format, there might be times when you will
    need to convert audio file formats to `.mp3`. In the next section, we will see
    exactly how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Audacity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Audacity is a free cross-platform audio recording and editing software. You
    can download the latest version from [http://audacity.sourceforge.net/](http://audacity.sourceforge.net/).
    Although Version 2.06 says it is for Mac OS X 10.4 to 10.9.x, it will also work
    for Yosemite.
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and installing Audacity](img/B04014_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Download the DMG file, double-click on it, and drag the Audacity folder into
    your **Applications** directory. From the launch pad, click on the **Audacity**
    application to open it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and installing Audacity](img/B04014_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can click on the **Quick Help**, **Manual**, **Wiki**, and **Forum** links
    to understand more about the software and its features. Click on **OK** to continue.
  prefs: []
  type: TYPE_NORMAL
- en: I am not a sound engineer, so I am really not the right person to tell you or
    explain what each of the headings does. All I can really say is that if you know
    a thing or two about sound programming or engineering, you can really do magic
    with this free and open source application. For example, we can reduce the size
    of a file by lowering the frequency of a file from 44 kHz to 22 kHz, as shown
    in the following screenshot, or reduce the format from two channels or stereo
    to mono.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the frequency, click on the down arrow next to the name of the file,
    select **Set Rate**, and choose **22050 Hz** instead of **44100 Hz**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and installing Audacity](img/B04014_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Converting the audio format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert the format to MP3, navigate to **File** | **Import** | **Audio**.
    In the `Resources` folder for this chapter, you will find a folder called `Game
    Audio Files`. Inside this folder, there is another folder called `caf`. Within
    this folder, you will have all the audio files in the `.caf` format. Select all
    the files in the folder and click on **Open**. Now all the files will be imported
    to the current project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting the audio format](img/B04014_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once all the files are imported, to convert them to MP3 files, you will need
    to install the lame library from [http://lame.buanzo.org/#lameosxdl](http://lame.buanzo.org/#lameosxdl).
    I know it has a very corny name, but it really works. Download the first link,
    which says **For Audacity 1.3.3 or Later**. Download the DMG file, open the package,
    and install it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting the audio format](img/B04014_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now go back to Audacity and navigate to **File** | **Export Multiple**. The
    following window will open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting the audio format](img/B04014_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the window that opens, select the format as **MP3 Files**. For the export
    location, I created a new folder called `mp3` in the `Game Audio Files` folder.
    For the name of the file, select the first choice so that it will keep the same
    label name as the file we are giving it. You can check or uncheck the **Overwrite
    existing Files** box as per your preference.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that if you check this box, all the files with the same name with
    be overwritten in future, so be careful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Export** to start the process. Then click on **OK** for all the
    files that are getting exported. You will get a confirmation that all the files
    were converted successfully, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting the audio format](img/B04014_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you check out the `mp3` folder, you will see that all the files have
    been converted to the `.mp3` format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting the audio format](img/B04014_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the files ready, we can add sound and effects to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, adding sounds and effects in SpriteKit is very simple.
    It is really one line of code that needs to be added to create the desired sound
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will import all the files to the project. So, select all the `.mp3`
    files in the folder you created earlier, and drag them into the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sound effects](img/B04014_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure that you check **Copy items if needed** and your project is selected
    as the target.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sound effects](img/B04014_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also, make sure that the files exist under **Copy Bundle Resources in the Build
    Phases**, as the files sometimes don't get copied, even after you select the project
    as the target. If the files don't exist here, then you will get a build error
    saying the said file can't be found, even though the file exits in the project
    hierarchy. In that case, click on the **+** button and add the files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sound effects](img/B04014_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the fireRocket sound effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay! With all the files imported, let''s call the `fireRocket` sound effect
    whenever the hero fires a rocket. At the end of the `addRockets` function in the
    `GamePlayScene.swift` file, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To play sounds, you will also use the `SKAction` class. The `SKAction` class
    has a property for playing sounds called `playSoundFileNamed`, and it takes two
    parameters. The first parameter is the name of the sound file, and the second
    is a Boolean value that determines the length of the action. If it is `true`,
    then the duration of the action is equal to the length of the audio track. Otherwise,
    it is understood that the action terminated immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have to provide the full name along with the extension when playing
    the sound. So, if you are using a `.caf` file in the project and you want to call
    the file, you must replace the extension accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If you build and run the game, you will hear the sound effect whenever you click
    on the right of the screen. Yes, it is really that easy!
  prefs: []
  type: TYPE_NORMAL
- en: Although this is easy, you might have noticed that the first time you fired
    the rocket, there was a bit of a delay between you tapping the screen and the
    sound file actually playing. This is because when the sound effect is called for
    the first time, the system has to fetch the file from the memory. The system has
    to do this for each of the files we will be calling. Once it has loaded initially,
    from the next time onwards, the file is already stored in the memory, so it is
    called instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the enemy-kill sound effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will add an effect that will occur whenever an enemy gets killed.
    So, in the `checkCollision` function, where we check for a collision between the
    player''s rocket and the enemies, add the following code after the code by which
    we increase the score in the `GamePlayScene.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And ta-da! The effect will start playing each time an enemy gets killed. You
    can run the action on the enemy or on the class itself by saying `self`; it doesn't
    really make any difference, as long you make sure you call the action on something,
    otherwise, the sound won't get played.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sound effect at GameOver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will add a sound for when the game is over. So, in the `GameOver`
    function, add the line highlighted in the following code snippet after we removed
    action on the self and the hero. This is important because if you add it before,
    then the action will be removed immediately and you will be sitting there scratching
    your head, thinking that you did add the sound, but yet no sound is playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a pop sound effect for whenever an on-screen button is pressed.
    So, in the `touchesbegan` function, where we check whether the `menuBtn` is pressed,
    we add the following code just before presenting the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the game and let it get over. When you press the home button, there
    is no sound. There is no sound!?!
  prefs: []
  type: TYPE_NORMAL
- en: Well, since the scene was changed as we moved from `GameplayScene` to `MainMenuScene`,
    the sound wasn't played.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple fix to this problem would be to call `MainMenuScene` after a small
    delay so that in the meantime, the sound will be played. To do this, create a
    function called `btnPressed` and copy and paste all of the code that calls `MainMenuScene`
    in it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, remove the following lines as they are already getting called in the
    `btnPressed` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, right after where we call `popSound`, we add the following lines of code,
    in which we create `SKAction`. This will call the `btnPressed` function after
    a 1-second delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you press the home button now, the sound will be played, and after a second,
    the scene will change to `MainMenuScene`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to how you added `popSound` here, in `MainMenuScene`, you can add the
    sound effect when the reset and play buttons are clicked on. When the reset button
    is pressed, you can just call `popSound`, as it will play without any trouble—this
    is because the scene is not changing. You will need to use a `btnPressed` function
    when `playBtn` is pressed, as the scene will change instantaneously and the sound
    will be not be played. So, make sure you create a `btnPressed` function and call
    it after a delay when the play button is pressed to hear the sound effect play
    out completely. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding background music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game is now populated with sound effects, but it will be so much more awesome
    if we add background music. Since the player will need to keep switching between
    `MainMenuSceen` and `GameplayScene`, there is no point in using `SKAction` to
    play sounds, as it won't play correctly or will get truncated each time the scene
    is changed.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we will have to use Apple's audio visual class called `AVFoundation`
    to help us get around this issue. As you might have guessed, `AVFoundation` is
    a superclass that handles both the audio and video functionalities, so if you
    want any video to be played in your game (say, for a tutorial), then you can very
    well use this class—that is why it was created. But let's get back to including
    the background music in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding audio loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create audio loops, we have to import `AVFoundation`, and since we have
    to play the audio track as soon as the game starts, let''s add it in the `GameViewController`
    class. So, add the following at the top of the class, as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, after we create the class, we include the following highlighted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new constant called `bgMusic`. To it, we assign the `AVAudioPlayer`
    function. It takes two parameters. The first is the location of the file, and
    the second is the error message to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In the first parameter, we pass the name and extension so that the file can
    be retrieved from the resource location of main bundle. In the `URLForResource`
    function, we pass the name of the file, which is `bgMusic`, and provide the extension,
    which is of the MP3 format. This will get the `bgMusic.mp3` file, which was previously
    added in **Copy Bundle Resources** under the **Build Phases** section.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this needs to be retrieved before the view is loaded. If we add this line
    to `viewDidLoad`, then it won't cause errors, but the file will not play properly,
    so it is called outside the `viewDidLoad` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is loaded in the `viewDidLoad` function, add the following line
    to tell the file to loop forever and start playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By assigning a value of `-1` to the number of loops, we are telling it to play
    the sound file in a loop continuously. If we assign `0`, it will play it once;
    if we assign `1`, it will play the sound file twice; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: And that is all! Now, build and run the game to enjoy the awesome background
    music.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added sound in our game, let's also add a scrolling background
    for fun.
  prefs: []
  type: TYPE_NORMAL
- en: Parallax background theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add a parallax or scrolling background. This is a very
    popular effect in games where the objects in the foreground will move faster than
    the objects in the background, which will move much slower and give the illusion
    of depth and motion. This is much similar to the movies of the yesteryears, where
    the hero or the subject will be stationary and act as if they are galloping on
    a horse, and the background will be looped to give the illusion that the hero
    is actually moving forward in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: We will be implementing a very simple parallax effect, where all the objects
    in the background such as the trees, bushes, and grass will move at the same speed.
    So, we will just take the background image and make it move in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is how the parallax effect is achieved: instead of one sprite of the background
    image, we will use two sprites and place them adjacent to each other horizontally
    at the start of the game, as seen in the following image. The first sprite will
    be visible but the second sprite will be offscreen and won''t be visible to the
    player initially.'
  prefs: []
  type: TYPE_NORMAL
- en: When the game starts, both the sprites will be moved with a certain speed in
    the negative *x* direction, that is, towards the left of the screen. Both the
    sprites will be moving at the same speed. So, once the game starts, `sprite1`
    will slowly go offscreen bit by bit and the second sprite will start becoming
    visible.
  prefs: []
  type: TYPE_NORMAL
- en: Once the first sprite goes completely offscreen, it is quickly moved to the
    end of the second sprite, which is the same position the second sprite was at
    the start of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Parallax background theory](img/B04014_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then process continues in a loop. Both the sprites always move towards the left
    of the screen. After each sprite goes offscreen on the left, it is placed at offscreen
    on the right of the screen and continues to move left.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things that need to be kept in mind when creating assets
    for parallax scrolling and coding a parallax effect. The first is that when creating
    assets for a parallax effect, the art needs to be continuous. For example, if
    you look at middle of the preceding image, you will see that the mountains look
    like a continuous mountain range. Even though `sprite1` and `sprite2` are two
    different images, when put together, they appear to be a single image. This can
    again be seen in the light-green bush below the mountain. The left part of the
    bush is in `sprite1` and the right is in `sprite2`, yet when the two sprites are
    kept adjacent to each other, it gives a seamless illusion of being part of a single
    bush.
  prefs: []
  type: TYPE_NORMAL
- en: The second aspect to keep in mind is the image gaps. Even if you make the images
    seamless and make the sprites move at the same speed, you might sometimes encounter
    gaps between the sprites. This is not a very common problem, but in some frameworks,
    it might exist. To counter it, you can stretch the images just by a bit so that
    the sprites overlap each other and it is not very obvious to the player. The other
    method is to make sure you manually place the sprites at the end of the on-screen
    sprite and also make the necessary adjustments, if required, to bridge the gap
    between the sprites.
  prefs: []
  type: TYPE_NORMAL
- en: This is the main theory behind parallax scrolling. Let's look at it in practice
    in the upcoming code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the parallax effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a parallax effect for the background, we have to create a new class
    similar to how we created the `MovingSprite` class. So, go to **File** | **New**
    | **File** and create a new swift file called `ParallaxSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file, import SpriteKit at the top of the file and create some constants.
    In the class, we will just take the name of the file that we want for the parallax
    effect. Then we will create two sprites called `sprite1` and `sprite2` from it.
    We will take a value of speed at which we want to move the sprites. We will then
    take the instance of the `GameplayScene` class so that we can add the sprites
    to the gameplay class. We will also create a global constant to get the size of
    the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the `init` function for the class in which we will take
    the *names* of sprite to be parallax, the *speed*, and the gameplay scene, and
    initialize the constants we created at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init` function, we initialize the speed variable with whatever value
    was passed in. We will also assign the size of the view that can be retrieved
    from the global constant we created in the `GameplayScene` class. We also assign
    the two sprite names passed into the local sprite variables: `_sprite1` and `_sprite2`.'
  prefs: []
  type: TYPE_NORMAL
- en: The _`sprite1` object is positioned at the center of the view, so the `x` and
    `y` position is obtained by diving the width and height of `viewSize` by half.
  prefs: []
  type: TYPE_NORMAL
- en: For the second sprite, _`sprite2`, the height is kept at half the height of
    the screen, but as for the position, it is placed so that the left edge of `sprite2`
    overlaps the right edge of `sprite1`. So, the second sprite is kept at the `x`
    position equal to the width of `sprite2`. The `-2` is small adjustment factor
    that is used to make sure that the two sprites overlap each other. This was added
    after some trial and error to arrive at the number.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can increase or decrease this value to see what effect it has, and if you
    want, you can add more or less overlapping, depending on your preference.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the sprites are not added to the current class but to the `GameplayScene`
    class. We can't add the sprites to the current class because we don't inherit
    from `SKNode` or `SKSpriteNode`, so the current class doesn't have the `addChild`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `update` function, as we will need to update the positions
    of `sprite1` and `sprite2` continuously. So, right after the `init` function,
    add the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `update` function, we increment the position of the sprites with a speed,
    so that the sprites move. So, since we are incrementing and not decrementing the
    value, when we create an instance of this class, we will need to remember to provide
    a negative speed value so that sprite moves towards the left, or else sprite will
    start going in the positive *x* direction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the right edge of `sprite1` has gone beyond the left
    end of the screen. If the sprite has gone off-screen, we get the position of `sprite2`,
    place `sprite1` at the end of the sprite, and subtract it by the adjustment factor
    to avoid the gap. The similar process is done for `sprite2` also, but here we
    place it at the end of `sprite1`.
  prefs: []
  type: TYPE_NORMAL
- en: That is for the `ParallaxSprite` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this class, go to the `GameplayScene` class and add a global constant
    after `var score:Int = 0` at the top of the class. Type `ParallaxSprite` with
    the name as `scrollingBg`, as shown in the following code. Don''t forget the exclamation
    mark at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we remove the code we added to include the BG sprite in the `init` function,
    and add these lines in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We create two sprite constants called `BG1` and `BG2`, and pass the image `BG`.
    Next, we initiate the `scrollingBg` class. In it, we pass the names of the image
    that we want to create scrolling effect for, which is the `BG1` and `BG2` sprites.
    We give it a speed of `-5.0` and give the current instance of the gameplay scene
    to it, that is, `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to call the update function of the `ParallaxSprite` class so
    that the objects'' positions get updated, and then we should have our scrolling
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Implementing the parallax effect](img/B04014_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So finally, in this chapter, we have added some music and effects to go along
    with the gameplay. We also looked at the difference in audio formats and how we
    can convert one audio format to other.
  prefs: []
  type: TYPE_NORMAL
- en: To top it all, we added a parallax effect to the game, making it look livelier.
    Like the background, you can also pass other objects to create an even better
    parallax effect. For free royalty effects and music, you can visit [www.freesound.org](http://www.freesound.org)
    or [www.soundbible.com](http://www.soundbible.com).
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to add an opening splash screen, add icons, upload the game
    to the App Store, and add the final touches to the game in [Chapter 10](ch10.html
    "Chapter 10. Publishing and Distribution"), *Publishing and Distribution*. In
    the next chapter, we will look at some of the more advanced features of SpriteKit
    such as physics, lighting, and so on. See you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
