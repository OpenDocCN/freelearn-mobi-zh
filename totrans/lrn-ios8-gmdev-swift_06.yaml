- en: Chapter 6. Audio and Parallax Effect
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：音频和视差效果
- en: Adding background music and sound effects in SpriteKit is very easy, as it is
    just a one-line code that you need to call. There are a few important things that
    need to be considered while adding the effects; for example, will the scene change
    after asking SpriteKit to play a sound? And what format should be used for the
    sound file?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SpriteKit 中添加背景音乐和音效非常简单，因为它只需要调用一行代码。在添加效果时需要考虑一些重要的事情；例如，在请求 SpriteKit 播放声音后，场景会改变吗？以及应该使用哪种格式的音频文件？
- en: In this chapter, we will be adding background music to the game and sound effects
    for the moments when the rocket gets fired, the enemy gets hit by a rocket, a
    button on the screen is pressed, and the game ends. We will also look at a free
    application that can be used to convert a sound file from one format to the other.
    In the end, we will add a nice scrolling effect to the background, for extra fun.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为游戏添加背景音乐，并为火箭发射、敌人被火箭击中、屏幕上的按钮被按下以及游戏结束时添加音效。我们还将查看一个可以用来将一个音频文件从一种格式转换为另一种格式的免费应用程序。最后，我们将为背景添加一个漂亮的滚动效果，以增加额外的乐趣。
- en: 'Here are the topics that are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Audio file formats
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频文件格式
- en: Downloading and installing Audacity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载和安装 Audacity
- en: Converting the audio format
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换音频格式
- en: Adding sound effects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加音效
- en: Adding background music
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加背景音乐
- en: Parallax background—theory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视差背景——理论
- en: Implementing the parallax effect
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现视差效果
- en: Audio file formats
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频文件格式
- en: SpriteKit allows us to use the OSX standard `.caf` audio file format, but it
    also supports `.mp3` files. In theory, you can use any of these formats to play
    audio or effects in the game. All you will need to do is change the name of the
    file called when asking SpriteKit to play the file. But for the sake of optimization,
    we will be using an `.mp3` file format. The reason is that `.mp3` files are a
    lot smaller in size compared to `.caf` files. Take the example of the background
    music file, for instance; the `.caf` file size is 5.2 megabytes, compared to the
    `.mp3` file, which is just 475 kilobytes—roughly 10 times less than a `.caf` file,
    and the player experience won't be any different.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 允许我们使用 OSX 标准的 `.caf` 音频文件格式，但它也支持 `.mp3` 文件。理论上，你可以使用这些格式中的任何一个来在游戏中播放音频或效果。你所需做的只是更改在请求
    SpriteKit 播放文件时调用的文件名。但为了优化，我们将使用 `.mp3` 文件格式。原因是 `.mp3` 文件的大小比 `.caf` 文件小得多。以背景音乐文件为例；`.caf`
    文件大小为 5.2 兆字节，而 `.mp3` 文件仅为 475 千字节——大约是 `.caf` 文件大小的十分之一，玩家的体验不会有任何不同。
- en: The more audio files you add, the more it will add to the bundle size, which
    will drastically increase the size of the game and take longer for the player
    to download and play the game. For a small game, such as ours, it might not matter
    much, but when you start making bigger games with more sound effects and background
    music, this is something to keep in mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的音频文件越多，它将增加捆绑包的大小，这将极大地增加游戏的大小，并使玩家下载和玩游戏的时间更长。对于像我们这样的小型游戏，这可能不是很重要，但当你开始制作包含更多音效和背景音乐的更大游戏时，这是需要记住的事情。
- en: Although `.mp3` is a very popular format, there might be times when you will
    need to convert audio file formats to `.mp3`. In the next section, we will see
    exactly how to do this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `.mp3` 是一个非常流行的格式，但有时你可能需要将音频文件格式转换为 `.mp3`。在下一节中，我们将看到如何确切地做到这一点。
- en: Downloading and installing Audacity
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和安装 Audacity
- en: Audacity is a free cross-platform audio recording and editing software. You
    can download the latest version from [http://audacity.sourceforge.net/](http://audacity.sourceforge.net/).
    Although Version 2.06 says it is for Mac OS X 10.4 to 10.9.x, it will also work
    for Yosemite.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Audacity 是一款免费的跨平台音频录制和编辑软件。你可以从 [http://audacity.sourceforge.net/](http://audacity.sourceforge.net/)
    下载最新版本。尽管版本 2.06 表示它是为 Mac OS X 10.4 到 10.9.x 设计的，但它也可以在 Yosemite 上运行。
- en: '![Downloading and installing Audacity](img/B04014_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![下载和安装 Audacity](img/B04014_06_01.jpg)'
- en: Download the DMG file, double-click on it, and drag the Audacity folder into
    your **Applications** directory. From the launch pad, click on the **Audacity**
    application to open it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 DMG 文件，双击它，然后将 Audacity 文件夹拖到你的 **应用程序** 目录中。从启动台，点击 **Audacity** 应用程序以打开它。
- en: '![Downloading and installing Audacity](img/B04014_06_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![下载和安装 Audacity](img/B04014_06_02.jpg)'
- en: You can click on the **Quick Help**, **Manual**, **Wiki**, and **Forum** links
    to understand more about the software and its features. Click on **OK** to continue.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以点击**快速帮助**、**手册**、**Wiki**和**论坛**链接来了解更多关于软件及其功能的信息。点击**确定**继续。
- en: I am not a sound engineer, so I am really not the right person to tell you or
    explain what each of the headings does. All I can really say is that if you know
    a thing or two about sound programming or engineering, you can really do magic
    with this free and open source application. For example, we can reduce the size
    of a file by lowering the frequency of a file from 44 kHz to 22 kHz, as shown
    in the following screenshot, or reduce the format from two channels or stereo
    to mono.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是声音工程师，所以我真的不是告诉您或解释每个标题做什么的合适人选。我真正能说的是，如果您对声音编程或工程有所了解，您可以用这个免费开源应用程序真正施展魔法。例如，我们可以通过将文件频率从44
    kHz降低到22 kHz来减小文件大小，如下面的截图所示，或者将格式从双声道或立体声减少到单声道。
- en: 'To change the frequency, click on the down arrow next to the name of the file,
    select **Set Rate**, and choose **22050 Hz** instead of **44100 Hz**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改频率，点击文件名称旁边的向下箭头，选择**设置速率**，并选择**22050 Hz**而不是**44100 Hz**：
- en: '![Downloading and installing Audacity](img/B04014_06_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![下载和安装Audacity](img/B04014_06_03.jpg)'
- en: Converting the audio format
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换音频格式
- en: To convert the format to MP3, navigate to **File** | **Import** | **Audio**.
    In the `Resources` folder for this chapter, you will find a folder called `Game
    Audio Files`. Inside this folder, there is another folder called `caf`. Within
    this folder, you will have all the audio files in the `.caf` format. Select all
    the files in the folder and click on **Open**. Now all the files will be imported
    to the current project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要将格式转换为MP3，请转到**文件** | **导入** | **音频**。在本章的`Resources`文件夹中，您将找到一个名为`Game Audio
    Files`的文件夹。在这个文件夹内，还有一个名为`caf`的文件夹。在这个文件夹中，您将找到所有`.caf`格式的音频文件。选择文件夹中的所有文件，然后点击**打开**。现在所有文件都将导入到当前项目中。
- en: '![Converting the audio format](img/B04014_06_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![转换音频格式](img/B04014_06_04.jpg)'
- en: Once all the files are imported, to convert them to MP3 files, you will need
    to install the lame library from [http://lame.buanzo.org/#lameosxdl](http://lame.buanzo.org/#lameosxdl).
    I know it has a very corny name, but it really works. Download the first link,
    which says **For Audacity 1.3.3 or Later**. Download the DMG file, open the package,
    and install it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有文件都导入，要将它们转换为MP3文件，您需要从[http://lame.buanzo.org/#lameosxdl](http://lame.buanzo.org/#lameosxdl)安装lame库。我知道它的名字很俗气，但它确实有效。下载第一个链接，上面写着**适用于Audacity
    1.3.3或更高版本**。下载DMG文件，打开包，并安装它。
- en: '![Converting the audio format](img/B04014_06_05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![转换音频格式](img/B04014_06_05.jpg)'
- en: 'Now go back to Audacity and navigate to **File** | **Export Multiple**. The
    following window will open:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到Audacity，导航到**文件** | **导出多个**。以下窗口将打开：
- en: '![Converting the audio format](img/B04014_06_06.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![转换音频格式](img/B04014_06_06.jpg)'
- en: In the window that opens, select the format as **MP3 Files**. For the export
    location, I created a new folder called `mp3` in the `Game Audio Files` folder.
    For the name of the file, select the first choice so that it will keep the same
    label name as the file we are giving it. You can check or uncheck the **Overwrite
    existing Files** box as per your preference.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的窗口中，选择格式为**MP3文件**。对于导出位置，我在`Game Audio Files`文件夹中创建了一个名为`mp3`的新文件夹。对于文件名，选择第一个选项，以便它将保持与我们要提供的文件相同的标签名称。您可以根据您的偏好勾选或取消勾选**覆盖现有文件**框。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that if you check this box, all the files with the same name with
    be overwritten in future, so be careful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您勾选此框，所有具有相同名称的文件在将来都会被覆盖，所以请小心。
- en: 'Click on **Export** to start the process. Then click on **OK** for all the
    files that are getting exported. You will get a confirmation that all the files
    were converted successfully, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**导出**开始转换过程。然后点击所有正在导出的文件的**确定**。您将收到一条确认信息，表明所有文件都已成功转换，如下所示：
- en: '![Converting the audio format](img/B04014_06_07.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![转换音频格式](img/B04014_06_07.jpg)'
- en: Now, if you check out the `mp3` folder, you will see that all the files have
    been converted to the `.mp3` format.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看`mp3`文件夹，您将看到所有文件都已转换为`.mp3`格式。
- en: '![Converting the audio format](img/B04014_06_08.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![转换音频格式](img/B04014_06_08.jpg)'
- en: With the files ready, we can add sound and effects to the game.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 文件准备就绪后，我们可以为游戏添加声音和效果。
- en: Adding sound effects
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音效
- en: As I mentioned earlier, adding sounds and effects in SpriteKit is very simple.
    It is really one line of code that needs to be added to create the desired sound
    effect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，在SpriteKit中添加声音和效果非常简单。实际上只需要添加一行代码来创建所需的音效。
- en: First, we will import all the files to the project. So, select all the `.mp3`
    files in the folder you created earlier, and drag them into the project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将所有文件导入到项目中。因此，选择您之前创建的文件夹中的所有`.mp3`文件，并将它们拖入项目中。
- en: '![Adding sound effects](img/B04014_06_09.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![添加音效](img/B04014_06_09.jpg)'
- en: Make sure that you check **Copy items if needed** and your project is selected
    as the target.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已勾选**“如有需要则复制项目”**，并且您的项目已选为目标。
- en: '![Adding sound effects](img/B04014_06_10.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![添加音效](img/B04014_06_10.jpg)'
- en: Also, make sure that the files exist under **Copy Bundle Resources in the Build
    Phases**, as the files sometimes don't get copied, even after you select the project
    as the target. If the files don't exist here, then you will get a build error
    saying the said file can't be found, even though the file exits in the project
    hierarchy. In that case, click on the **+** button and add the files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保文件位于**构建阶段中的“复制资源包”**下，因为有时即使您已将项目选为目标，文件也可能没有被复制。如果文件不在这里，那么您将收到一个构建错误，表示找不到该文件，尽管文件确实存在于项目层次结构中。在这种情况下，点击**+**按钮并添加文件。
- en: '![Adding sound effects](img/B04014_06_11.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![添加音效](img/B04014_06_11.jpg)'
- en: Adding the fireRocket sound effect
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加fireRocket音效
- en: 'Okay! With all the files imported, let''s call the `fireRocket` sound effect
    whenever the hero fires a rocket. At the end of the `addRockets` function in the
    `GamePlayScene.swift` file, add the following line of code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！所有文件都已导入，让我们在英雄发射火箭时调用`fireRocket`音效。在`GamePlayScene.swift`文件中的`addRockets`函数末尾，添加以下代码行：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To play sounds, you will also use the `SKAction` class. The `SKAction` class
    has a property for playing sounds called `playSoundFileNamed`, and it takes two
    parameters. The first parameter is the name of the sound file, and the second
    is a Boolean value that determines the length of the action. If it is `true`,
    then the duration of the action is equal to the length of the audio track. Otherwise,
    it is understood that the action terminated immediately.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放声音，您还将使用`SKAction`类。`SKAction`类有一个名为`playSoundFileNamed`的属性用于播放声音，它接受两个参数。第一个参数是声音文件的名称，第二个是一个布尔值，它确定动作的长度。如果是`true`，则动作的持续时间等于音频轨道的长度。否则，动作将立即终止。
- en: Notice that we have to provide the full name along with the extension when playing
    the sound. So, if you are using a `.caf` file in the project and you want to call
    the file, you must replace the extension accordingly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，播放声音时我们必须提供包括扩展名在内的完整名称。所以，如果您在项目中使用`.caf`文件，并且想要调用该文件，您必须相应地替换扩展名。
- en: If you build and run the game, you will hear the sound effect whenever you click
    on the right of the screen. Yes, it is really that easy!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您构建并运行游戏，您将在点击屏幕右侧时听到音效。是的，这真的很简单！
- en: Although this is easy, you might have noticed that the first time you fired
    the rocket, there was a bit of a delay between you tapping the screen and the
    sound file actually playing. This is because when the sound effect is called for
    the first time, the system has to fetch the file from the memory. The system has
    to do this for each of the files we will be calling. Once it has loaded initially,
    from the next time onwards, the file is already stored in the memory, so it is
    called instantaneously.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很简单，但你可能已经注意到，您第一次发射火箭时，从您轻触屏幕到音文件实际播放之间有一点点延迟。这是因为当第一次调用音效时，系统必须从内存中检索文件。系统必须为我们将要调用的每个文件都这样做。一旦初始加载完成，从下一次开始，文件就已经存储在内存中，因此可以立即调用。
- en: Adding the enemy-kill sound effect
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加敌人击杀音效
- en: 'Next, we will add an effect that will occur whenever an enemy gets killed.
    So, in the `checkCollision` function, where we check for a collision between the
    player''s rocket and the enemies, add the following code after the code by which
    we increase the score in the `GamePlayScene.swift` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个效果，该效果将在敌人被击杀时发生。因此，在`checkCollision`函数中，我们检查玩家火箭与敌人之间的碰撞，在`GamePlayScene.swift`文件中增加分数的代码之后，添加以下代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And ta-da! The effect will start playing each time an enemy gets killed. You
    can run the action on the enemy or on the class itself by saying `self`; it doesn't
    really make any difference, as long you make sure you call the action on something,
    otherwise, the sound won't get played.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！每次敌人被击败时效果都会开始播放。你可以通过说 `self` 在敌人或类本身上运行动作，这实际上并没有什么区别，只要你确保在某个东西上调用动作，否则音效不会播放。
- en: Adding a sound effect at GameOver
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游戏结束时添加音效
- en: 'Next, we will add a sound for when the game is over. So, in the `GameOver`
    function, add the line highlighted in the following code snippet after we removed
    action on the self and the hero. This is important because if you add it before,
    then the action will be removed immediately and you will be sitting there scratching
    your head, thinking that you did add the sound, but yet no sound is playing:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为游戏结束添加音效。因此，在 `GameOver` 函数中，在我们移除 self 和英雄的动作之后，添加以下代码片段中高亮显示的行。这很重要，因为如果你在之前添加它，那么动作将会立即被移除，你将坐在那里挠头，认为你已经添加了音效，但音效却没有播放：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will add a pop sound effect for whenever an on-screen button is pressed.
    So, in the `touchesbegan` function, where we check whether the `menuBtn` is pressed,
    we add the following code just before presenting the scene:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为屏幕上的按钮按下时添加一个弹出音效。因此，在 `touchesbegan` 函数中，我们检查 `menuBtn` 是否被按下，在呈现场景之前添加以下代码：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, run the game and let it get over. When you press the home button, there
    is no sound. There is no sound!?!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行游戏并让它结束。当你按下主页按钮时，没有声音。没有声音？！
- en: Well, since the scene was changed as we moved from `GameplayScene` to `MainMenuScene`,
    the sound wasn't played.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，由于我们从 `GameplayScene` 切换到 `MainMenuScene` 时场景已经改变，所以音效没有播放。
- en: 'A simple fix to this problem would be to call `MainMenuScene` after a small
    delay so that in the meantime, the sound will be played. To do this, create a
    function called `btnPressed` and copy and paste all of the code that calls `MainMenuScene`
    in it, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是在小延迟后调用 `MainMenuScene`，这样在同时，音效将会播放。为此，创建一个名为 `btnPressed` 的函数，并将调用
    `MainMenuScene` 的所有代码复制粘贴到其中，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, remove the following lines as they are already getting called in the
    `btnPressed` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，删除以下行，因为它们已经在 `btnPressed` 函数中被调用：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, right after where we call `popSound`, we add the following lines of code,
    in which we create `SKAction`. This will call the `btnPressed` function after
    a 1-second delay:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，紧接着我们在调用 `popSound` 之后，添加以下代码行，其中我们创建 `SKAction`。这将延迟1秒后调用 `btnPressed` 函数：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you press the home button now, the sound will be played, and after a second,
    the scene will change to `MainMenuScene`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在按下主页按钮，音效将会播放，并且一秒后场景将切换到 `MainMenuScene`。
- en: 'Similar to how you added `popSound` here, in `MainMenuScene`, you can add the
    sound effect when the reset and play buttons are clicked on. When the reset button
    is pressed, you can just call `popSound`, as it will play without any trouble—this
    is because the scene is not changing. You will need to use a `btnPressed` function
    when `playBtn` is pressed, as the scene will change instantaneously and the sound
    will be not be played. So, make sure you create a `btnPressed` function and call
    it after a delay when the play button is pressed to hear the sound effect play
    out completely. The code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在这里添加 `popSound` 的方式类似，在 `MainMenuScene` 中，你可以在重置和播放按钮被点击时添加音效。当按下重置按钮时，你只需调用
    `popSound` 即可，因为它会毫无问题地播放——这是因为场景没有改变。当按下 `playBtn` 时，你需要使用 `btnPressed` 函数，因为场景会瞬间改变，音效将不会播放。所以，确保你创建一个
    `btnPressed` 函数，并在按下播放按钮后延迟调用它，以便完全播放音效。代码如下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding background music
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加背景音乐
- en: Our game is now populated with sound effects, but it will be so much more awesome
    if we add background music. Since the player will need to keep switching between
    `MainMenuSceen` and `GameplayScene`, there is no point in using `SKAction` to
    play sounds, as it won't play correctly or will get truncated each time the scene
    is changed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在已经充满了音效，但如果我们添加背景音乐将会更加精彩。由于玩家需要不断在 `MainMenuSceen` 和 `GameplayScene`
    之间切换，使用 `SKAction` 播放音效是没有意义的，因为它不会正确播放或者每次场景切换时都会被截断。
- en: For this purpose, we will have to use Apple's audio visual class called `AVFoundation`
    to help us get around this issue. As you might have guessed, `AVFoundation` is
    a superclass that handles both the audio and video functionalities, so if you
    want any video to be played in your game (say, for a tutorial), then you can very
    well use this class—that is why it was created. But let's get back to including
    the background music in our game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将不得不使用苹果的音频视觉类 `AVFoundation` 来帮助我们解决这个问题。正如你可能已经猜到的，`AVFoundation`
    是一个超类，它处理音频和视频功能，所以如果你想在你游戏中播放任何视频（比如教程），你完全可以使用这个类——这就是它被创建的原因。但让我们回到将背景音乐添加到我们的游戏中。
- en: Adding audio loops
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加音频循环
- en: 'To create audio loops, we have to import `AVFoundation`, and since we have
    to play the audio track as soon as the game starts, let''s add it in the `GameViewController`
    class. So, add the following at the top of the class, as highlighted:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建音频循环，我们必须导入 `AVFoundation`，并且由于我们必须在游戏开始时立即播放音频轨道，让我们在 `GameViewController`
    类中添加它。所以，在类的顶部添加以下内容，如高亮所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, after we create the class, we include the following highlighted line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在创建类之后，我们包含以下高亮显示的行：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we create a new constant called `bgMusic`. To it, we assign the `AVAudioPlayer`
    function. It takes two parameters. The first is the location of the file, and
    the second is the error message to be displayed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的常量，称为 `bgMusic`。我们将其赋值为 `AVAudioPlayer` 函数。它接受两个参数。第一个是文件的存储位置，第二个是要显示的错误信息。
- en: In the first parameter, we pass the name and extension so that the file can
    be retrieved from the resource location of main bundle. In the `URLForResource`
    function, we pass the name of the file, which is `bgMusic`, and provide the extension,
    which is of the MP3 format. This will get the `bgMusic.mp3` file, which was previously
    added in **Copy Bundle Resources** under the **Build Phases** section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个参数中，我们传递文件名和扩展名，以便可以从主包的资源位置检索文件。在 `URLForResource` 函数中，我们传递文件名，即 `bgMusic`，并提供扩展名，即
    MP3 格式。这将获取之前在 **Build Phases** 下的 **Copy Bundle Resources** 中添加的 `bgMusic.mp3`
    文件。
- en: Also, this needs to be retrieved before the view is loaded. If we add this line
    to `viewDidLoad`, then it won't cause errors, but the file will not play properly,
    so it is called outside the `viewDidLoad` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这需要在视图加载之前检索。如果我们将此行添加到 `viewDidLoad` 中，则不会导致错误，但文件将无法正确播放，因此它是在 `viewDidLoad`
    函数之外调用的。
- en: 'Once the file is loaded in the `viewDidLoad` function, add the following line
    to tell the file to loop forever and start playing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件在 `viewDidLoad` 函数中加载，添加以下行以告诉文件无限循环并开始播放：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By assigning a value of `-1` to the number of loops, we are telling it to play
    the sound file in a loop continuously. If we assign `0`, it will play it once;
    if we assign `1`, it will play the sound file twice; and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将循环次数的值设置为 `-1`，我们告诉它连续循环播放声音文件。如果我们设置为 `0`，它将只播放一次；如果设置为 `1`，它将播放声音文件两次；依此类推。
- en: And that is all! Now, build and run the game to enjoy the awesome background
    music.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，构建并运行游戏，享受美妙的背景音乐。
- en: Now that we have added sound in our game, let's also add a scrolling background
    for fun.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在游戏中添加了声音，让我们也添加一个滚动背景来增加趣味性。
- en: Parallax background theory
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视差背景理论
- en: In this section, we will add a parallax or scrolling background. This is a very
    popular effect in games where the objects in the foreground will move faster than
    the objects in the background, which will move much slower and give the illusion
    of depth and motion. This is much similar to the movies of the yesteryears, where
    the hero or the subject will be stationary and act as if they are galloping on
    a horse, and the background will be looped to give the illusion that the hero
    is actually moving forward in the scene.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个视差或滚动背景。这是游戏中非常流行的效果，其中前景中的对象移动速度比背景中的对象快，背景移动速度较慢，从而产生深度和运动的错觉。这与过去的电影非常相似，其中英雄或主题是静止的，并表现得好像他们在骑马奔跑，背景被循环播放，以产生英雄实际上在场景中向前移动的错觉。
- en: We will be implementing a very simple parallax effect, where all the objects
    in the background such as the trees, bushes, and grass will move at the same speed.
    So, we will just take the background image and make it move in a loop.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个非常简单的视差效果，其中背景中的所有对象，如树木、灌木丛和草地，将以相同的速度移动。因此，我们只需将背景图像移动并循环播放。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is how the parallax effect is achieved: instead of one sprite of the background
    image, we will use two sprites and place them adjacent to each other horizontally
    at the start of the game, as seen in the following image. The first sprite will
    be visible but the second sprite will be offscreen and won''t be visible to the
    player initially.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现视差效果的方法：我们不会使用一个背景图像的精灵，而是将使用两个精灵，并在游戏开始时将它们水平相邻放置，如下面的图像所示。第一个精灵将是可见的，但第二个精灵将位于屏幕外，最初对玩家不可见。
- en: When the game starts, both the sprites will be moved with a certain speed in
    the negative *x* direction, that is, towards the left of the screen. Both the
    sprites will be moving at the same speed. So, once the game starts, `sprite1`
    will slowly go offscreen bit by bit and the second sprite will start becoming
    visible.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，两个精灵将以一定的速度向负*x*方向移动，即向屏幕左侧移动。两个精灵将以相同的速度移动。因此，一旦游戏开始，`sprite1`将逐渐逐渐离开屏幕，而第二个精灵将开始变得可见。
- en: Once the first sprite goes completely offscreen, it is quickly moved to the
    end of the second sprite, which is the same position the second sprite was at
    the start of the game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个精灵完全离开屏幕时，它会迅速移动到第二个精灵的末尾，这是第二个精灵在游戏开始时的相同位置。
- en: '![Parallax background theory](img/B04014_06_12.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![视差背景理论](img/B04014_06_12.jpg)'
- en: Then process continues in a loop. Both the sprites always move towards the left
    of the screen. After each sprite goes offscreen on the left, it is placed at offscreen
    on the right of the screen and continues to move left.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后处理继续在循环中进行。两个精灵总是向屏幕的左侧移动。每个精灵在左侧离开屏幕后，它会被放置在屏幕右侧的离屏位置，并继续向左移动。
- en: There are a couple of things that need to be kept in mind when creating assets
    for parallax scrolling and coding a parallax effect. The first is that when creating
    assets for a parallax effect, the art needs to be continuous. For example, if
    you look at middle of the preceding image, you will see that the mountains look
    like a continuous mountain range. Even though `sprite1` and `sprite2` are two
    different images, when put together, they appear to be a single image. This can
    again be seen in the light-green bush below the mountain. The left part of the
    bush is in `sprite1` and the right is in `sprite2`, yet when the two sprites are
    kept adjacent to each other, it gives a seamless illusion of being part of a single
    bush.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用于视差滚动的资源和编码视差效果时，有几个需要注意的事项。首先，当创建用于视差效果的资源时，艺术作品需要是连续的。例如，如果你看前一个图像的中间，你会看到山脉看起来像是一个连续的山脉。尽管`sprite1`和`sprite2`是两个不同的图像，但当它们放在一起时，它们看起来像是一个单独的图像。这同样可以在山脉下面的浅绿色灌木丛中看到。灌木丛的左侧在`sprite1`中，而右侧在`sprite2`中，但当两个精灵保持相邻时，它给人一种无缝的错觉，好像它是单个灌木丛的一部分。
- en: The second aspect to keep in mind is the image gaps. Even if you make the images
    seamless and make the sprites move at the same speed, you might sometimes encounter
    gaps between the sprites. This is not a very common problem, but in some frameworks,
    it might exist. To counter it, you can stretch the images just by a bit so that
    the sprites overlap each other and it is not very obvious to the player. The other
    method is to make sure you manually place the sprites at the end of the on-screen
    sprite and also make the necessary adjustments, if required, to bridge the gap
    between the sprites.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的第二点是图像间隙。即使你使图像无缝并且使精灵以相同的速度移动，有时你可能会在精灵之间遇到间隙。这不是一个非常常见的问题，但在某些框架中可能存在。为了应对这个问题，你可以稍微拉伸图像，使精灵相互重叠，这样对玩家来说并不非常明显。另一种方法是确保你手动将精灵放置在屏幕上精灵的末尾，并在必要时进行必要的调整，以弥合精灵之间的间隙。
- en: This is the main theory behind parallax scrolling. Let's look at it in practice
    in the upcoming code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是视差滚动的理论基础。让我们在接下来的代码中看看它的实际应用。
- en: Implementing the parallax effect
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现视差效果
- en: To create a parallax effect for the background, we have to create a new class
    similar to how we created the `MovingSprite` class. So, go to **File** | **New**
    | **File** and create a new swift file called `ParallaxSprite`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要为背景创建视差效果，我们必须创建一个类似于我们创建`MovingSprite`类的新类。所以，转到**文件** | **新建** | **文件**，创建一个名为`ParallaxSprite`的新swift文件。
- en: 'In the file, import SpriteKit at the top of the file and create some constants.
    In the class, we will just take the name of the file that we want for the parallax
    effect. Then we will create two sprites called `sprite1` and `sprite2` from it.
    We will take a value of speed at which we want to move the sprites. We will then
    take the instance of the `GameplayScene` class so that we can add the sprites
    to the gameplay class. We will also create a global constant to get the size of
    the view:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，在文件顶部导入SpriteKit并创建一些常量。在类中，我们将只取我们想要用于视差效果的文件名。然后我们将从它创建两个名为`sprite1`和`sprite2`的精灵。我们将取一个我们想要移动精灵的速度值。然后我们将获取`GameplayScene`类的实例，以便我们可以将精灵添加到游戏类中。我们还将创建一个全局常量以获取视图的大小：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will create the `init` function for the class in which we will take
    the *names* of sprite to be parallax, the *speed*, and the gameplay scene, and
    initialize the constants we created at the top of the class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为类创建`init`函数，在这个函数中我们将获取要创建视差效果的精灵的*名称*、*速度*和游戏场景，并初始化我们在类顶部创建的常量：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `init` function, we initialize the speed variable with whatever value
    was passed in. We will also assign the size of the view that can be retrieved
    from the global constant we created in the `GameplayScene` class. We also assign
    the two sprite names passed into the local sprite variables: `_sprite1` and `_sprite2`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，我们将速度变量初始化为传入的任何值。我们还将分配从我们在`GameplayScene`类中创建的全局常量中检索到的视图大小。我们还将分配传入的两个精灵名称到本地精灵变量：`_sprite1`和`_sprite2`。
- en: The _`sprite1` object is positioned at the center of the view, so the `x` and
    `y` position is obtained by diving the width and height of `viewSize` by half.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`_sprite1`对象位于视图的中心，因此`x`和`y`位置是通过将`viewSize`的宽度和高度除以二得到的。'
- en: For the second sprite, _`sprite2`, the height is kept at half the height of
    the screen, but as for the position, it is placed so that the left edge of `sprite2`
    overlaps the right edge of `sprite1`. So, the second sprite is kept at the `x`
    position equal to the width of `sprite2`. The `-2` is small adjustment factor
    that is used to make sure that the two sprites overlap each other. This was added
    after some trial and error to arrive at the number.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个精灵，`_sprite2`，高度保持在屏幕高度的一半，但就位置而言，它被放置得使得`sprite2`的左边缘与`sprite1`的右边缘重叠。因此，第二个精灵保持在`sprite2`的`x`位置等于其宽度。`-2`是一个小的调整因子，用于确保两个精灵重叠。这是在经过一些尝试和错误后得到的数字。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can increase or decrease this value to see what effect it has, and if you
    want, you can add more or less overlapping, depending on your preference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以增加或减少此值以查看它的影响，并且如果您愿意，可以根据您的偏好添加更多或更少的重叠。
- en: Also, note that the sprites are not added to the current class but to the `GameplayScene`
    class. We can't add the sprites to the current class because we don't inherit
    from `SKNode` or `SKSpriteNode`, so the current class doesn't have the `addChild`
    property.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，精灵不是添加到当前类中，而是添加到`GameplayScene`类中。我们不能将精灵添加到当前类中，因为我们没有从`SKNode`或`SKSpriteNode`继承，所以当前类没有`addChild`属性。
- en: 'Next, we define the `update` function, as we will need to update the positions
    of `sprite1` and `sprite2` continuously. So, right after the `init` function,
    add the `update` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`update`函数，因为我们需要持续更新`sprite1`和`sprite2`的位置。因此，在`init`函数之后，添加`update`函数：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `update` function, we increment the position of the sprites with a speed,
    so that the sprites move. So, since we are incrementing and not decrementing the
    value, when we create an instance of this class, we will need to remember to provide
    a negative speed value so that sprite moves towards the left, or else sprite will
    start going in the positive *x* direction.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`函数中，我们以一定的速度增加精灵的位置，从而使精灵移动。因此，由于我们是增加而不是减少值，当我们创建这个类的实例时，我们需要记住提供一个负速度值，以便精灵向左移动，否则精灵将开始向正*x*方向移动。
- en: Next, we check whether the right edge of `sprite1` has gone beyond the left
    end of the screen. If the sprite has gone off-screen, we get the position of `sprite2`,
    place `sprite1` at the end of the sprite, and subtract it by the adjustment factor
    to avoid the gap. The similar process is done for `sprite2` also, but here we
    place it at the end of `sprite1`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`sprite1`的右边缘是否已经超过了屏幕的左端。如果精灵已经离开屏幕，我们获取`sprite2`的位置，将`sprite1`放置在精灵的末尾，并减去调整因子以避免间隙。对`sprite2`也执行类似的过程，但在这里我们将它放置在`sprite1`的末尾。
- en: That is for the `ParallaxSprite` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `ParallaxSprite` 类的内容。
- en: 'To implement this class, go to the `GameplayScene` class and add a global constant
    after `var score:Int = 0` at the top of the class. Type `ParallaxSprite` with
    the name as `scrollingBg`, as shown in the following code. Don''t forget the exclamation
    mark at the end:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个类，请转到 `GameplayScene` 类，并在类顶部 `var score:Int = 0` 之后添加一个全局常量。将名称为 `scrollingBg`
    的 `ParallaxSprite` 类型输入，如下面的代码所示。别忘了最后的感叹号：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we remove the code we added to include the BG sprite in the `init` function,
    and add these lines in its place:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们移除在 `init` 函数中添加的包含BG精灵的代码，并替换为以下这些行：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create two sprite constants called `BG1` and `BG2`, and pass the image `BG`.
    Next, we initiate the `scrollingBg` class. In it, we pass the names of the image
    that we want to create scrolling effect for, which is the `BG1` and `BG2` sprites.
    We give it a speed of `-5.0` and give the current instance of the gameplay scene
    to it, that is, `self`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个精灵常量，分别命名为 `BG1` 和 `BG2`，并将图像 `BG` 传递给它们。接下来，我们初始化 `scrollingBg` 类。在这个类中，我们传递了想要创建滚动效果的图像名称，即
    `BG1` 和 `BG2` 精灵。我们给它一个速度 `-5.0`，并将当前的游戏场景实例传递给它，即 `self`。
- en: 'Next, we need to call the update function of the `ParallaxSprite` class so
    that the objects'' positions get updated, and then we should have our scrolling
    background:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用 `ParallaxSprite` 类的更新函数，以便更新对象的位子，然后我们就可以拥有我们的滚动背景：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Implementing the parallax effect](img/B04014_06_13.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![实现视差效果](img/B04014_06_13.jpg)'
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: So finally, in this chapter, we have added some music and effects to go along
    with the gameplay. We also looked at the difference in audio formats and how we
    can convert one audio format to other.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们添加了一些音乐和效果，以配合游戏玩法。我们还探讨了音频格式的差异以及如何将一种音频格式转换为其他格式。
- en: To top it all, we added a parallax effect to the game, making it look livelier.
    Like the background, you can also pass other objects to create an even better
    parallax effect. For free royalty effects and music, you can visit [www.freesound.org](http://www.freesound.org)
    or [www.soundbible.com](http://www.soundbible.com).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们在游戏中添加了视差效果，使其看起来更加生动。就像背景一样，您也可以传递其他对象以创建更好的视差效果。对于免费的版权效果和音乐，您可以访问
    [www.freesound.org](http://www.freesound.org) 或 [www.soundbible.com](http://www.soundbible.com)。
- en: We will see how to add an opening splash screen, add icons, upload the game
    to the App Store, and add the final touches to the game in [Chapter 10](ch10.html
    "Chapter 10. Publishing and Distribution"), *Publishing and Distribution*. In
    the next chapter, we will look at some of the more advanced features of SpriteKit
    such as physics, lighting, and so on. See you in the next chapter!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [10 章](ch10.html "第10章。发布和分发") “发布和分发” 中看到如何添加开场屏幕、添加图标、将游戏上传到App Store以及为游戏添加最后的修饰。在下一章中，我们将探讨SpriteKit的一些更高级的功能，例如物理、光照等。下一章再见！
