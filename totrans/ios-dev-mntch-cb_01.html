<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Development Tools</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing pre-requisites</li><li class="listitem" style="list-style-type: disc">Creating an iPhone project with MonoDevelop</li><li class="listitem" style="list-style-type: disc">Interface builder</li><li class="listitem" style="list-style-type: disc">Creating the UI</li><li class="listitem" style="list-style-type: disc">Accessing the UI with outlets</li><li class="listitem" style="list-style-type: disc">Adding actions</li><li class="listitem" style="list-style-type: disc">Compiling</li><li class="listitem" style="list-style-type: disc">Debugging our application</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec01"/>Introduction</h1></div></div></div><p>One of the most important things professionals care about is the tools that are required to perform their work. Just as carpenters need a chisel to scrape wood, or photographers need a camera to capture light, we as developers need certain tools that we cannot work without.</p><p>In this chapter, we will provide information on what<strong> Integrated Development Environments  (IDEs)</strong> and<strong> Software Development Kits (SDKs)</strong>  are needed to develop applications for iOS, Apple's operating system for the company's mobile devices. We will describe what every tool's role is in the development cycle and step through each one's important features that are essential to develop our first application.<a id="id0" class="indexterm"/>
</p><p>The tools needed to develop applications for iOS are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>An Intel-based Mac computer running Snow Leopard (10.6.*) or Lion (10.7.*) operating system:</strong> The essential programs we need cannot be installed on other computer platforms.<a id="id1" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>iOS SDK version 3.2 or higher:</strong> To be able to download iOS SDK, a developer must be registered as an Apple developer. iOS SDK, among other things, includes two essential components.<a id="id3" class="indexterm"/><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Xcode:</strong> Apple's IDE for developing native applications for iOS and Mac with the Objective-C programming language.<a id="id4" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>iOS Simulator:</strong> An essential program to debug iOS apps on the computer, without the need of a device. Note that there are many iOS features that do not work on the simulator; hence, a device is needed if an app uses these features.<a id="id5" class="indexterm"/><p>Both the registration and SDK download are free of charge from Apple's Developer portal (<a class="ulink" href="http://developer.apple.com">http://developer.apple.com
</a>). If we want to run and debug our applications on the device or distribute them on the App Store, we need to enroll with the iOS developer program, which requires a subscription fee.
<a id="id6" class="indexterm"/>
</p></li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Mono for Mac:</strong> Mono is an open source implementation of Microsoft's .NET framework. It provides a multi-platform set of tools, libraries, and compilers to develop .NET applications on all mainstream computer operating systems (Linux, Mac, and Windows). We need the latest Mac installer, available from Mono's website.<a id="id7" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>MonoTouch:</strong> MonoTouch is an SDK, based on Mono. It provides .NET developers with the ability to develop applications for iOS, using C# as a programming language. A free evaluation version is available on the MonoTouch website (<a class="ulink" href="http://ios.xamarin.com">http://ios.xamarin.com
</a>), which has all the features of the commercial versions to debug and run applications on iOS Simulator, without an expiration limit. For deploying applications on a device, or distributing on Apple's App Store, purchasing a commercial license is required.<a id="id8" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>MonoDevelop:</strong> MonoDevelop is an open source IDE for .NET development. It provides developers with lots of features, such as code completion, database browsing, debuggers, and so on. The Mac version provides iOS project templates and MonoTouch integration.<a id="id9" class="indexterm"/></li></ul></div><p>This chapter will also describe how to create our first iPhone project with MonoDevelop, construct its UI with Interface Builder, and how to access the application's user interface from within our code, with the concepts of<strong> Outlets</strong> and<strong> Actions</strong>.<a id="id10" class="indexterm"/>
</p><p>Last but not least, we will learn how to compile our application, the available compilation options we have, and how to debug on the simulator.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec02"/>Installing pre-requisites</h1></div></div></div><p>Information on how to download and install the necessary tools to develop with MonoTouch.<a id="id11" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec01"/>Getting ready</h2></div></div></div><p>We need to download all the necessary components on our computer. The first thing to do is register as an Apple Developer on<a class="ulink" href="http://developer.apple.com">http://developer.apple.com
</a>. The registration is free and easy and provides access to all necessary development resources. After the registration is confirmed through e-mail, we can log in and download the iOS SDK from the address<code class="literal"> https://developer.apple.com/devcenter/ios/index.action#downloads</code>. At the time of writing, Xcode's latest version is 4.2, and iOS SDK's latest version is 5.0.<a id="id12" class="indexterm"/>
</p><p>At times, when Apple introduces beta versions of its components, they are made available through its portal. Although everyone registered can download and use these components, our already installed version of MonoTouch might not work correctly with the beta version of iOS SDK or Xcode. So, this must be taken into account when downloading and installing new beta versions from Apple Developer portal.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec02"/>How to do it...</h2></div></div></div><p>To prepare our computer for iOS development, we need to download and install the necessary components in the following order:<a id="id13" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><strong> Xcode and iOS SDK on OS X Snow Leopard:</strong> After downloading the image file, mount it, and in the window that will pop up, double-click on the Xcode and iOS SDK icon to start the installation. For the installation to proceed, it is necessary to read and accept the two licensing agreements that will be shown. After that, all you need to do is select the destination of the installation and click on<strong> Continue</strong>.<a id="id14" class="indexterm"/><div><img src="img/1468EXP_01_01.jpg" alt="How to do it..."/></div></li><li class="listitem"><strong> Xcode and iOS SDK on OS X Lion:</strong> To install Xcode and the SDK, a login to the Mac App Store is required. The downloaded files are basically an installer for Xcode and the SDK. When the download completes, run the Install Xcode application, and follow the installation instructions.<a id="id15" class="indexterm"/></li><li class="listitem"><strong> Download and install Mono for Mac:</strong> The Mac version of Mono can be downloaded through the Mono Project's website:<a class="ulink" href="http://www.mono-project.com"> http://www.mono-project.com</a>.<a id="id16" class="indexterm"/></li><li class="listitem"><strong> Download and install MonoTouch:</strong> The latest evaluation version can be downloaded from<a class="ulink" href="http://ios.xamarin.com/DownloadTrial"> http://ios.xamarin.com/DownloadTrial</a> by providing an e-mail address.<a id="id17" class="indexterm"/></li><li class="listitem"><strong> Download and install MonoDevelop 2.8+:</strong> Although creating iOS applications with MonoTouch does not require MonoDevelop, installing it will make developing much easier. It can be downloaded from<a class="ulink" href="http://monodevelop.com/Download"> http://monodevelop.com/Download</a>.<a id="id18" class="indexterm"/></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec03"/>How it works...</h2></div></div></div><p>Now that we have everything ready, let's see what each component is needed for.</p><p>As stated in the introduction of this chapter, the iOS SDK contains three important components. The first component,<strong> Xcode,</strong> is Apple's IDE for developing applications for both iOS and Mac platforms. It is targeted on the Objective-C programming language, which is the main language to program in, with the iOS SDK. Since MonoTouch is an SDK for the C# language, one might wonder what we need Xcode for. Apart from providing various tools for debugging iOS applications, Xcode provides us with three important components that we need. The first one is a device information window, called<strong> Organizer</strong>, shown in the following screenshot, which is necessary to install the various certificates and provisioning profiles that are required for deploying our application on a device or distributing through the App Store. From within the Organizer, we can view debugging information of our applications, crash logs, and even take screenshots from the device! Of course, these are only a few of the many features Xcode provides, but they are outside of the scope of this book to discuss.<a id="id19" class="indexterm"/>
</p><div><img src="img/1468EXP_01_02.jpg" alt="How it works..."/></div><p>The second component is<strong> Interface Builder.</strong> This is the user interface designer, which was formerly a standalone application. Starting with Xcode 4.0, it is integrated into the IDE. Interface Builder provides all the necessary functionality to construct an application user interface. It is also quite different to what .NET developers have been accustomed to.<a id="id20" class="indexterm"/>
</p><p>The third component is<strong> iOS Simulator</strong>. It is exactly what its name suggests: a device simulator, which we can use to run our applications on, without the need for an actual device. The important thing of iOS Simulator is that it has the option of simulating older iOS versions (if they are installed on the computer); both iPhone and iPad interfaces and device orientations. But, the simulator lacks some device features that are dependent on hardware, such as the compass or accelerometer. Applications using these features must be tested and debugged on an actual device.<a id="id21" class="indexterm"/>
</p><p>Mono is an open source implementation of the .NET framework. It has been around for quite some time now and provides .NET developers the ability to program applications with .NET languages, while targeting all mainstream operating systems: Linux, Mac, and Windows. Both MonoTouch and MonoDevelop depend heavily on Mono, making it a necessary asset.<a id="id22" class="indexterm"/>
</p><p>MonoDevelop is an open source IDE for developing applications with Mono (and the .NET framework on Windows). It provides code completion, database browser, GTK# designer, debuggers, and, in our case, the necessary components to develop iOS applications easily and effectively. It integrates with MonoTouch perfectly, classifying both as a complete iOS development environment.<a id="id23" class="indexterm"/>
</p><p>MonoTouch is the SDK that allows .NET developers to develop applications for the iOS, using the C# programming language. There is a common misconception, mostly among new developers: since MonoTouch provides the ability to program with C#, one can install and use it on a Windows computer. This is totally wrong, since MonoTouch is wrapped around iOS SDK's libraries, which can only be installed on a Mac computer. Another misconception is that applications developed with MonoTouch being ".NET capable" require a virtual machine of some kind to be installed on the device to run, and they will run slower due to this virtual machine. This is also wrong, since MonoTouch's advanced compiler takes care of it by compiling our C# ".NET powered" code to native machine code. Also, a virtual machine being installed on a device is against Apple's guidelines.<a id="id24" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec04"/>There's more...</h2></div></div></div><p>Applications developed with MonoTouch have the same chances of making it to the App Store as all other applications developed with the native Objective-C programming language! Meaning, if an application does not conform to Apple's strict policy about application acceptance, it will fail, whether it is written in either Objective-C or C#. The MonoTouch team has done a great job in creating an SDK that leaves the developer to only worry about the design and best practice of the code and nothing else. In April 2010, Apple made a modification on its application submission policy, which actually banned all applications from being submitted to the App Store that weren't created with the company's development tools. MonoTouch was one of them. Apart from the concern that emerged among developers who had already invested in MonoTouch, applications created with it were normally accepted on the App Store. In September 2010, Apple modified its policy and relaxed the matter, bringing relief to C# developers.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Useful links</h3></div></div></div><p>The following is a list of the links that contain the tools and information for installing them:<a id="id25" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Apple iOS developer portal:</strong><a class="ulink" href="http://developer.apple.com/devcenter/ios/%20index.action">http://developer.apple.com/devcenter/ios/
index.action
</a><a id="id26" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Mono:</strong><a class="ulink" href="http://www.mono-project.com">http://www.mono-project.com
</a><a id="id27" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>MonoDevelop:</strong><a id="id28" class="indexterm"/><a class="ulink" href="http://www.monodevelop.com">http://www.monodevelop.com
</a></li><li class="listitem" style="list-style-type: disc"><strong>MonoTouch:</strong><a class="ulink" href="http://ios.xamarin.com">http://ios.xamarin.com
</a><a id="id29" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>MonoTouch installation guide:</strong><a class="ulink" href="http://ios.xamarin.com/Documentation/%20Installation">http://ios.xamarin.com/Documentation/
Installation
</a><a id="id30" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Info about Apple developer tools:</strong><a class="ulink" href="http://developer.apple.com/%20technologies/tools/xcode.html">
http://developer.apple.com/
technologies/tools/xcode.html
</a><a id="id31" class="indexterm"/></li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Updates</h3></div></div></div><p>MonoDevelop has a feature for checking for available updates. Whenever the program starts, it checks for updates of MonoDevelop itself, MonoTouch, and the Mono framework. It can be turned off, but it is not recommended, since it helps staying up-to-date with the latest versions. It can be found under<strong> MonoDevelop | Check for Updates</strong>.<a id="id32" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec05"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Compiling</em></li><li class="listitem" style="list-style-type: disc"><em>Debugging our application</em></li></ul></div><p>
<a class="link" href="ch14.html" title="Chapter 14. Deploying">Chapter 14</a>,Deploying:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Debugging on other devices</em></li><li class="listitem" style="list-style-type: disc"><em>Preparing our application for the App Store</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec03"/>Creating an iPhone project with MonoDevelop</h1></div></div></div><p>In this task, we will discuss creating our first iPhone project with the MonoDevelop IDE.<a id="id33" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Getting ready...</h2></div></div></div><p>Now that we have all the pre-requisites installed, we will discuss how to create our first iPhone project with MonoDevelop.</p><p>Start MonoDevelop. It can be found in the<code class="literal"> Applications</code> folder. MonoDevelop's default project location is the folder<code class="literal"> /Users/{yourusername}/Projects</code>. If it does not exist on the hard disk, it will be created when we create our first project. If we want to change the folder, go to<strong> MonoDevelop | Preferences</strong> from the menu bar.<a id="id34" class="indexterm"/>
</p><p>Select<strong> Load/Save</strong> in the pane on the left, enter the preferred location for the projects in the field<strong> Default Solution</strong> location, and click on<strong> OK</strong>.</p><div><img src="img/1468EXP_01_03.jpg" alt="Getting ready..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> The first thing that is loaded when starting MonoDevelop is its<strong> Start</strong> page. Select<strong> File | New | Solution...</strong>. from the menu bar. A window will be shown that provides us with the available project options.</li><li class="listitem"> In this window, on the pane on the left, select<strong> C# | MonoTouch | iPhone</strong>. The iPhone project templates will be presented on the middle pane.<a id="id35" class="indexterm"/></li><li class="listitem"> Select<strong> iPhone Single View Application</strong>. Finally, enter<code class="literal"> MyFirstiPhoneProject</code> for<strong> Solution name</strong> and click on<strong> Forward</strong>. The following screenshot displays the<strong> New Solution</strong> window:</li></ol></div><div><img src="img/1468EXP_01_04.jpg" alt="How to do it..."/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">That was it! You have just created your first iPhone project! You can build and run it. The <strong>iOS Simulator</strong> will start, with just a blank light-gray screen nevertheless.</li></ul></div><div><h3 class="title"><a id="note02"/>Note</h3><p>If the MonoTouch section on the left pane is not shown for some reason, it means that something went wrong with the installation of MonoTouch and/or MonoDevelop. Refer to the previous recipe for proper installation.</p><p>If the project templates in the middle are different than what is shown in this screenshot, it must be because you have a different version of MonoTouch and/or MonoDevelop than what was used for this book.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How it works...</h2></div></div></div><p>Let's see what goes on behind the scenes.</p><p>When MonoDevelop creates a new iPhone, or better, iOS project, it creates a series of files. The solution structure is the same as if a .NET/Mono project was created, but with some extra files. The solution files can be viewed in the<strong> Solution</strong> pad on the left side of the MonoDevelop window. If the<strong> Solution</strong> pad is not visible, it can be activated by checking on<strong> View | Pads | Solution</strong> from the menu bar.<a id="id36" class="indexterm"/>
</p><p>These files are the essential files that form an iPhone project:</p><div><img src="img/1468EXP_01_05.jpg" alt="How it works..."/></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>MyFirstiPhoneProjectViewController.xib</h3></div></div></div><p>This file is the file that contains the view of the application.<code class="literal"> XIB</code> files are basically XML files with a specific structure that is readable from Interface Builder. They contain various information about the user interface, such as the type of controls it contains, their properties, Outlets, and so on.<a id="id37" class="indexterm"/>
</p><div><h3 class="title"><a id="note03"/>Note</h3><p>If<code class="literal"> MyFirstiPhoneProjectViewController.xib</code>, or any other file with the<code class="literal"> .xib</code> suffix is double-clicked, then MonoDevelop starts Xcode with the contents of the<code class="literal"> XIB</code> file open in Interface Builder.</p></div><p>When we create a new interface with Interface Builder and save it, it is saved in the XIB format.<a id="id38" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>MyFirstiPhoneProjectViewController.cs</h3></div></div></div><p>This is the file that implements the view's functionality. These are the contents of the file when it is created:<a id="id39" class="indexterm"/>
</p><div><pre class="programlisting">namespace MyFirstiPhoneProject{
public partial class MyFirstiPhoneProjectViewController : UIViewController{
public MyFirstiPhoneProjectViewController (string nibName, NSBundle bundle) : base (nibName, bundle){}
public override void DidReceiveMemoryWarning (){
// Releases the view if it doesn't have a superview.
base.DidReceiveMemoryWarning ();
// Release any cached data, images, and so on that aren't in use.
}
public override void ViewDidLoad (){
base.ViewDidLoad ();
//any additional setup after loading the view, typically from a nib.
}
public override void ViewDidUnload (){
base.ViewDidUnload ();
// Release any retained subviews of the main view.
// e.g. myOutlet = null;
}
public override bool ShouldAutorotateToInterfaceOrientation (UIInterfaceOrientation toInterfaceOrientation){
// Return true for supported orientations
return (toInterfaceOrientation != UIInterfaceOrientation.PortraitUpsideDown);
}
}
}
</pre></div><p>The code in this file contains the class that corresponds to the view that will be loaded, along with some default method overrides. These methods are the ones that we will be using more frequently when we create view controllers. A brief description of each method is listed as follows:<a id="id40" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ViewDidLoad:</code> This method is called when the view of the controller is loaded. This is the method we use to initialize any additional components.<a id="id41" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ViewDidUnload:</code> This method is called when the view is unloaded from memory.<a id="id42" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">DidReceiveMemoryWarning:</code> This method is called when the application receives a memory warning. This method is responsible for unloading the view.<a id="id43" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ShouldAutorotateToInterfaceOrientation:</code> We implement this method when we want our application to support multiple orientations.<a id="id44" class="indexterm"/></li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>MyFirstiPhoneProjectViewController.designer.cs</h3></div></div></div><p>This is the file that holds our main window's class information in C# code. MonoDevelop creates one<code class="literal"> .designer.cs</code> file for every<code class="literal"> XIB</code> that is added in a project. The file is auto-generated every time we save a change in our<code class="literal"> XIB</code> through Interface Builder. This is being taken care of by MonoDevelop, so that the changes we make in our interface are reflected right away in our code. We must not make changes to this file directly, since when the corresponding XIB is saved with Interface Builder, they will be lost. Also, if nothing is saved through Interface Builder, if changes are made to it manually, it will most likely result in a compilation error.<a id="id45" class="indexterm"/>
</p><p>These are the contents of the file when a new project is created:</p><div><pre class="programlisting">namespace MyFirstiPhoneProject{
[Register ("MyFirstiPhoneProjectViewController")]
partial class MyFirstiPhoneProjectViewController{}
}
</pre></div><p>Just like any other .NET project, a namespace is created with the name of the solution:</p><div><pre class="programlisting">namespace MyFirstiPhoneProject
</pre></div><p>This file contains the other partial declaration of our<code class="literal"> MyFirstiPhoneProjectViewController</code> class. It is decorated with the<code class="literal"> RegisterAttribute</code>.<a id="id46" class="indexterm"/>
</p><p>The<code class="literal"> RegisterAttribute</code> is used to expose classes to the underlying Objective-C runtime. The string parameter declares by what name our class will be exposed to the runtime. It can be whatever name we want it to be, but it is a good practice to always set it to our C# class' name. The attribute is used heavily in the internals of MonoTouch, since it is what binds all native<code class="literal"> NSObject</code> classes with their C# counterparts.<a id="id47" class="indexterm"/>
</p><div><h3 class="title"><a id="note04"/>Note</h3><p>
<code class="literal">NSObject</code> is a root class or base class. It is the equivalent of<code class="literal"> System.Object</code> in the .NET world. The only difference between the two is that all .NET objects inherit from<code class="literal"> System.Object</code>, but most, not all, Objective-C objects inherit from<code class="literal"> NSObject</code> in Objective-C. The C# counterparts of all native objects that inherit from<code class="literal"> NSObject</code> also inherit from its MonoTouch<code class="literal"> NSObject</code> counterpart.</p></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>AppDelegate.cs</h3></div></div></div><p>This file contains the class<code class="literal"> AppDelegate</code>. The contents of the file are listed below:<a id="id48" class="indexterm"/>
</p><div><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using MonoTouch.Foundation;
using MonoTouch.UIKit;
namespace MyFirstiPhoneProject{
// The UIApplicationDelegate for the application. This class is responsible for launching the
// User Interface of the application, as well as listening (and optionally responding) to application events from iOS.
[Register ("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate{
// class-level declarations
UIWindow window;
MyFirstiPhoneProjectViewController viewController;
// This method is invoked when the application has loaded and is ready to run. In this
// method, you should instantiate the window, load the UI into it, and then make the window visible.
// You have 17 seconds to return from this method, or iOS will terminate your application.
public override bool FinishedLaunching (UIApplication app, NSDictionary options){
window = new UIWindow (UIScreen.MainScreen.Bounds);
viewController = new MyFirstiPhoneProjectViewController ("MyFirstiPhoneProjectViewController", null);
window.RootViewController = viewController;
window.MakeKeyAndVisible ();
return true;
}
}
}
</pre></div><p>The first part is familiar to .NET developers and consists of the appropriate<code class="literal"> using</code> directives that import the required namespaces to use.<a id="id49" class="indexterm"/>
</p><div><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using MonoTouch.Foundation;
using MonoTouch.UIKit;
</pre></div><p>The first three<code class="literal"> using</code> directives allow us to use the specific and familiar namespaces from the .NET/Mono world with MonoTouch!</p><div><h3 class="title"><a id="note05"/>Note</h3><p>Although the functionality the three namespaces (System,<code class="literal"> System.Collections.Generic, System.Linq)</code> provide is almost identical to their well-known .NET/Mono counterparts, they are included in assemblies specifically created for use with MonoTouch and shipped with it, of course. An assembly compiled with .NET or Mono cannot be directly used in a MonoTouch project.</p></div><p>The<code class="literal"> MonoTouch.Foundation</code> namespace is a wrapper around the native Objective-C foundation framework, which contains classes that provide basic functionality. These objects' names share the same "NS" prefix that is found in the native foundation framework. Some examples are<code class="literal"> NSObject, NSString, NSValue</code>, and so on. Apart from<code class="literal"> NS-prefixed</code> objects, the<code class="literal"> MonoTouch.Foundation</code> namespace contains all of the attributes that are used for binding to native objects, such as the<code class="literal"> RegisterAttribute</code> that we saw earlier. The<code class="literal"> MonoTouch.UIKit</code> namespace is a wrapper around the native Objective-C<code class="literal"> UIKit</code> framework. As its name suggests, the namespace contains classes, delegates, and events that provide us with interface functionality. Except for two classes,<code class="literal"> DraggingEventArgs</code> and<code class="literal"> ZoomingEventArgs</code>, all the objects' names share the same "UI" prefix. It should be clear at this point that these two namespaces are essential for all MonoTouch applications, and their objects will be used quite frequently.<a id="id50" class="indexterm"/>
</p><p>The class inherits from the<code class="literal"> UIApplicationDelegate</code> class, qualifying it as our application's<code class="literal"> UIApplication</code>
<strong> Delegate</strong> object.<a id="id51" class="indexterm"/>
</p><div><h3 class="title"><a id="note06"/>Note</h3><p>The concept of a Delegate object in the Objective-C world is somewhat different than a delegate in C#. It will be explained in detail in<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views"> Chapter 2</a>, User Interface: Views.</p></div><p>The<code class="literal"> AppDelegate</code> class contains two fields and one method:<a id="id52" class="indexterm"/>
</p><div><pre class="programlisting">UIWindow window;
MyFirstiPhoneProjectViewController viewController;
public override bool FinishedLaunching (UIApplication app, NSDictionary options) {
</pre></div><p>The<code class="literal"> UIWindow</code> object defines the main window of our application, while the<code class="literal"> MyFirstiPhoneProjectViewController</code> is the variable, which will hold the application's view controller.</p><div><h3 class="title"><a id="note07"/>Note</h3><p>An iOS application typically has only one window, of type<code class="literal"> UIWindow</code>. The concept of a<code class="literal"> UIWindow</code> is somewhat different from a .NET<code class="literal"> System.Windows.Form</code>. The<code class="literal"> UIWindow</code> is the first control that is displayed when an application starts, and every subsequent views are hierarchically added below it.</p></div><p>The<code class="literal"> FinishedLaunching</code> method, as its name suggests, is called when the application has completed its initialization process. This is the method where we must present the user interface to the user. The implementation of this method must be lightweight, since if it does not return in time from the moment it is called, iOS will terminate the application. This is for providing faster user interface loading times to the user by preventing developers from performing complex and long-running tasks upon initialization, such as connecting to a web service to receive data. The application parameter is the application's<code class="literal"> UIApplication</code> object, which is also accessible through the static property<code class="literal"> UIApplication.SharedApplication</code>. The options parameter may or may not contain information about the way the application was launched. We do not need it for now.<a id="id53" class="indexterm"/>
</p><p>The<code class="literal"> FinishedLaunching</code> method, as its name suggests, is called when the application has completed its initialization process. This is the method where we must present the user interface to the user. The implementation of this method must be lightweight, since if it does not return in time from the moment it is called, iOS will terminate the application. This is for providing faster user interface loading times to the user by preventing developers from performing complex and long-running tasks upon initialization, such as connecting to a web service to receive data. The application parameter is the application's<code class="literal"> UIApplication</code> object, which is also accessible through the static property<code class="literal"> UIApplication.SharedApplication</code>. The options parameter may or may not contain information about the way the application was launched. We do not need it for now.</p><p>The default implementation of the<code class="literal"> FinishedLaunching</code> method for this type of project is the following:<a id="id54" class="indexterm"/>
</p><div><pre class="programlisting">window = new UIWindow (UIScreen.MainScreen.Bounds);
</pre></div><p>The<code class="literal"> UIWindow</code> object is initialized with the size of the screen.<a id="id55" class="indexterm"/>
</p><div><pre class="programlisting">viewController = new MyFirstiPhoneProjectViewController ("MyFirstiPhoneProjectViewController", null);
window.RootViewController = viewController;
</pre></div><p>The view controller is initialized and set as the window's root view controller.</p><div><pre class="programlisting">window.MakeKeyAndVisible ();
return true;
</pre></div><p>The window is displayed on the screen with the<code class="literal"> window.MakeKeyAndVisible()</code> call and the method returns. This method must be called inside the<code class="literal"> FinishedLaunching</code> method, otherwise the application's user interface will not be presented as it should to the user. Last but not least, the<code class="literal"> return true</code> line returns the method by marking its execution completion.<a id="id56" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Main.cs</h3></div></div></div><p>Inside the<code class="literal"> Main.cs</code> file is where the runtime life-cycle of the program starts:<a id="id57" class="indexterm"/>
</p><div><pre class="programlisting">namespace MyFirstiPhoneProject{
public class Application{
// This is the main entry point of the application.
static void Main (string[] args){
// if you want to use a different Application Delegate class from "AppDelegate",
// you can specify it here.
UIApplication.Main (args, null, "AppDelegate");
}
}
}
</pre></div><p>Much like the following call in a .NET<code class="literal"> System.Windows.Forms</code> application, the<code class="literal"> UIApplication.Main</code> method starts the message loop, or run loop that is responsible for dispatching notifications to the application through the<code class="literal"> AppDelegate</code> class, with event handlers that we can override.</p><div><pre class="programlisting">// In a .NET application
Application.Run(new Form1());
</pre></div><p>Event handlers such as<code class="literal"> FinishedLaunching, ReceiveMemoryWarning</code>, or<code class="literal"> DidEnterBackground</code> are only some of these notifications. Apart from the notification dispatching mechanism, the<code class="literal"> UIApplication</code> object holds a list of all<code class="literal"> UIWindow</code> objects that exist; typically one. An iOS application must have one<code class="literal"> UIApplication</code> object, or a class that inherits from it, and this object must have a corresponding<code class="literal"> UIApplicationDelegate</code> object. This is the<code class="literal"> AppDelegate</code> class implementation we saw earlier.<a id="id58" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Info.plist</h3></div></div></div><p>This file is basically the application's settings file. It has a simple structure of properties with values that define various settings for an iOS application, such as the orientations it supports, its icon, supported iOS versions, what devices it can be installed on, and so on. If we double-click on this file in MonoDevelop, it will open in the embedded editor, specifically designed for<code class="literal"> .plist</code> files. This is what our file in a new project looks like:<a id="id59" class="indexterm"/>
</p><div><img src="img/1468EXP_01_06.jpg" alt="Info.plist"/></div><p>The<code class="literal"> Info.plist</code> is an XML file. Although we can edit the file manually in a text editor, for example, it is not recommended. The embedded editor is the best way of editing.<a id="id60" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>There's more...</h2></div></div></div><p>MonoDevelop provides many different project templates for developing iOS applications. Here is a list that describes what each project template is for:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Empty project:</strong> It is an empty project without any views.<a id="id61" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Utility application:</strong> It is a utility application is a special type of iOS application that provides one screen for functionality, and in many cases another one for configuration.<a id="id62" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Master-detail application:</strong> This type of project creates a template that supports navigating through multiple screens. It contains two view controllers.<a id="id63" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Single view application:</strong> This template type is the one we used in this recipe.<a id="id64" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"> application:<strong>Tabbed</strong> It is a template that adds a tab bar controller that manages two view controllers in a tab-like interface.<a id="id65" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>OpenGL application:</strong> It is a template for creating OpenGL-powered applications or games.<a id="id66" class="indexterm"/></li></ul></div><p>These templates are available for the iPhone, the iPad, and Universal (both iPhone and iPad) projects. They are also available in Interface Builder's<strong> Storyboarding</strong> application design.<a id="id67" class="indexterm"/>
</p><div><h3 class="title"><a id="note08"/>Note</h3><p>Unless otherwise stated, all project templates referring to the iPhone are suitable for the iPod Touch as well.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec09"/>List of MonoTouch assemblies</h3></div></div></div><p>MonoTouch supported assemblies can be found in the following link:<a class="ulink" href="http://ios.xamarin.com/Documentation/Assemblies"> http://ios.xamarin.com/Documentation/Assemblies</a>.<a id="id68" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating the UI</em></li><li class="listitem" style="list-style-type: disc"><em>Accessing the UI with outlets</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>, User Interface: Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding and customizing views</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec05"/>Interface builder</h1></div></div></div><p>Introduction to Apple's user interface designer.<a id="id69" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How to do it...</h2></div></div></div><p>If you have installed the iOS SDK, then you already have Xcode with Interface Builder installed on your computer.</p><div><ol class="orderedlist"><li class="listitem"> Go to MonoDevelop and open the project<code class="literal"> MyFirstiPhoneProject</code> that we created earlier.<a id="id70" class="indexterm"/></li><li class="listitem"> In the<strong> Solution</strong> pad on the left, double-click on<strong> MyFirstiPhoneProjectViewController.xib</strong>. MonoDevelop starts Xcode with the file loaded in Interface Builder!</li><li class="listitem"> On the right side of the toolbar, on the top of the Xcode window, select the appropriate editor and viewing options, as shown below:</li></ol></div><div><img src="img/1468EXP_01_07.jpg" alt="How to do it..."/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The following screenshot demonstrates what Interface Builder looks like with a XIB file open:</li></ul></div><div><img src="img/1468EXP_01_08.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How it works...</h2></div></div></div><p>Now that we have loaded Interface Builder with the view controller of our application, let's familiarize ourselves with it.<a id="id71" class="indexterm"/>
</p><p>The user interface designer is directly connected to an Xcode project. When we add an object, Xcode automatically generates code to reflect the change we made. MonoDevelop takes care of this for us, as when we double-click on a XIB file, it automatically creates a temporary Xcode project so that we can make the changes we want in the user interface. Therefore, we have nothing more to do than just design the user interface for our application:<a id="id72" class="indexterm"/>
</p><p>Interface Builder is divided into three areas. A brief description of each area is described below.<a id="id73" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><strong> Navigator area:</strong> In this area, we can see the files included in the Xcode project.<a id="id74" class="indexterm"/></li><li class="listitem"><strong> Editor area:</strong> This area is where we design the user interface.<a id="id75" class="indexterm"/></li><li class="listitem"><strong> Utility area:</strong> This area contains the<strong> Inspector</strong> and<strong> Library</strong> panes. The<strong> Inspector</strong> is where we configure each object, while the<strong> Library</strong> pane is where we find the objects.<a id="id76" class="indexterm"/></li></ol></div><p>The Editor area is divided into two sections. The one on the left is the<strong> Designer</strong>, while the one on the right is the<strong> Assistant</strong> editor. Inside the assistant editor, we see the underlying Objective-C source code file that corresponds to the selected item in the designer. Although we do not need to edit the Objective-C source, we will need the assistant editor later.<a id="id77" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>There's more...</h2></div></div></div><p>We saw what a<code class="literal"> XIB</code> file looks like in Interface Builder. But, there is more as far as these files are concerned. We mentioned earlier that<code class="literal"> XIB</code> files are XML files with appropriate information readable by Interface Builder. The thing is that when a project is compiled, the compiler also compiles the<code class="literal"> XIB</code> file, converting it to its binary equivalent: the<code class="literal"> NIB</code> file. Both<code class="literal"> XIB</code> and<code class="literal"> NIB</code> files contain the exact same information. The only difference between them is that<code class="literal"> XIB</code> files are in a human-readable form, while the<code class="literal"> NIB</code> files are not. For example, when we compile the project we created, the<code class="literal"> MyFirstiPhoneProjectViewController.xib</code> file will become<code class="literal"> MyFirstiPhoneProjectViewController.nib</code> in the output folder. Apart from the binary conversion, the compiler also performs a compression on<code class="literal"> NIB</code> files. So, NIB files will be significantly smaller in size than<code class="literal"> XIB</code> files.<a id="id78" class="indexterm"/>
</p><p>That's not all about<code class="literal"> XIB</code> files. The way a developer manages the<code class="literal"> XIB</code> files in a project is very important in an application's performance and stability. It is better to have many, smaller in size<code class="literal"> XIB</code> files, instead of one or two large ones. This can be accomplished by dividing the user interface in many<code class="literal"> XIB</code> files. It may seem a bit difficult, but as we'll see later in this book, it is actually very easy. We need many, smaller<code class="literal"> XIB</code> files instead of few and large ones because of the way iOS manages its memory. When an application starts, iOS loads the<code class="literal"> NIB</code> files as a whole in memory, and thereafter, all the objects in it are instantiated. So, it is a waste of memory to keep objects in<code class="literal"> NIB</code> files that are not always going to be used. Also, remember that you are developing for a mobile device whose available resources are not a match against desktop computers', no matter what its capabilities are.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec10"/>More info</h3></div></div></div><p>You may have noticed that in the<strong> Attributes</strong> tab in the<strong> Inspector</strong> pane, there is a section called<strong> Simulated Metrics</strong>. Options under this section help us see directly in the designer what our interface looks like with the device's status bar, a toolbar, or a navigation bar. Although these options are saved in the<code class="literal"> XIB</code> files, they have nothing to do with the actual application at runtime. For example, if we set the<strong> Status Bar</strong> option to<strong> None</strong>, it does not mean that our application will start without a status bar.<a id="id79" class="indexterm"/>
</p><div><h3 class="title"><a id="note09"/>Note</h3><p>
<strong>Status Bar</strong> is the bar that is shown on the top portion of the device's screen, which displays certain information to the user, such as the current time, battery status, carrier name on the iPhone, and so on.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating the UI</em></li><li class="listitem" style="list-style-type: disc"><em>Accessing the UI with outlets</em></li><li class="listitem" style="list-style-type: disc"><em>Adding actions</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>, User Interface:Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding and customizing views</em></li></ul></div><p><a class="link" href="ch03.html" title="Chapter 3. User Interface: View Controllers">Chapter 3</a>: User Interface:View Controllers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>View controllers and views</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Creating the UI</h1></div></div></div><p>In this recipe, we will learn how to add and manage controls in the user interface.<a id="id80" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Getting ready</h2></div></div></div><p>Let's add a few controls in an interface. Start by creating a new iPhone Single View Application project in MonoDevelop. Name the project<code class="literal"> ButtonInput</code>. When it opens, double-click on<code class="literal"> ButtonInputViewController.xib</code> in the<strong> Solution</strong> pad to open it with Interface Builder.<a id="id81" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How to do it...</h2></div></div></div><p>Now that we have a new project and Interface Builder has opened the<code class="literal"> ButtonInputViewController.xib</code> file, we'll add some controls to it.<a id="id82" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Add a label</h3></div></div></div><div><ol class="orderedlist"><li class="listitem"> Go to the<strong> Library</strong> pane and select<strong> Objects</strong> from the drop-down list, if it is not already selected. Select the<strong> Label</strong> object.<a id="id83" class="indexterm"/></li><li class="listitem"> Drag-and-drop the<strong> Label</strong> onto the gray space of the view in the designer, somewhere in the top half.</li><li class="listitem"> Select and resize the<strong> Label</strong> from both the left and right side, so that it snaps to the dashed line that will show up when you reach close to the edges of the view.</li><li class="listitem"> Again, with the<strong> Label</strong> selected, go to the<strong> Inspector</strong> pane, select the<strong> Attributes</strong> tab, and in the<strong> Layout</strong> section, click on the middle alignment button. Congratulations, you have just added a<strong> Label</strong> in your application's main view!</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Add a button</h3></div></div></div><p>We will perform similar steps to add a button in our interface.<a id="id84" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Again, in the<strong> Library</strong> pane, in the<strong> Objects</strong> section, select the<strong> Button</strong> object. It is next to the<strong> Label</strong> object.</li><li class="listitem"> Drag-and-drop it onto the bottom half of the view. Align its center with the center of the<strong> Label</strong> we added earlier. A dashed line will show up, and the<strong> Button</strong> will snap to it when the centers of the two controls are almost aligned.</li><li class="listitem"> Resize the<strong> Button</strong> to the same width of the<strong> Label</strong>. Since the<strong> Label</strong> has a transparent background and you cannot see how wide it is exactly, you will know when the<strong> Button</strong> is the same width when three dashed lines will show up while you are resizing it.</li><li class="listitem"> Now, let's add some text to the<strong> Button</strong>. Select it and go to the<strong> Inspector</strong> pane. In the<strong> Attributes</strong> tab, in the<strong> Title</strong> field, enter<code class="literal"> Tap here please!</code>.</li><li class="listitem"> After adding the button, save the document through<strong> File | Save</strong> in the menu bar. The main view should now look like the following screenshot (shown resized here):</li></ol></div><div><img src="img/1468EXP_01_09.jpg" alt="Add a button"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How it works...</h2></div></div></div><p>As you can see, although some concepts of Interface Builder seem difficult, it is quite easy to use. It also provides a lot of feedback. When we drag objects, a green-circled cross appears on the cursor to declare that we can drop the object there. Also, when we resize a control, we see its dimensions next to it.<a id="id85" class="indexterm"/>
</p><p>You can also resize and position the controls by modifying the values in the<strong> Size</strong> tab of the<strong> Inspector</strong> pane. Another useful feature in the<strong> Size</strong> tab is<strong> Autosizing. Autosizing</strong> provides layout options for the controls and can be very useful when we want our application to support different device orientations. You can select a control you want, and then click on the lines that are outside or inside of the square on the left in the<strong> Autosizing</strong> section. The image next to it animates to give you an impression of how the control will behave when the layout changes.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>There's more...</h2></div></div></div><p>Now, let's try running the application on the iOS Simulator. Back at MonoDevelop, select the project configuration at<strong> Debug | iPhoneSimulator</strong> if it is not already selected. No need to do anything else in the code for now; just click on the<strong> Run</strong> button. It is the third button on the right of the configuration combo box, with the double gear icon. When the compilation finishes, iOS Simulator will start automatically and will run the application we just created! You can even "tap" on the<strong> Button</strong> by clicking on it with the mouse and see it responding. Of course, our application does not have any other functionality right now.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Setting titles on buttons</h3></div></div></div><p>Setting the title of a<strong> Button</strong> or a<strong> Label</strong> can easily be done just by double-clicking on it and typing the preferable title. Do it, and watch how Interface Builder behaves to show you what action is to be performed.<a id="id86" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Compiling</em></li><li class="listitem" style="list-style-type: disc"><em>Debugging our application</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>, User Interface: Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Receiving user input with buttons</em></li><li class="listitem" style="list-style-type: disc"><em>Using labels to display text</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Accessing the UI with outlets</h1></div></div></div><p>In this recipe, we will discuss the concept of<strong> Outlets</strong> and their usage with MonoTouch.<a id="id87" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Getting ready</h2></div></div></div><p>In the previous task, we learned how to add controls to form a basic interface for our application. In this task, we will discuss how to access and use these controls in our code. Launch MonoDevelop, and open the project<code class="literal"> ButtonInput</code> that we created earlier. Open the project's<code class="literal"> ButtonInputViewController.xib</code> in Interface Builder by double-clicking on it in the<strong> Solution</strong> pad.<a id="id88" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> With the<strong> Assistant Editor</strong> open,<em> Ctrl-drag</em> from the label to the Objective-C source file, as displayed in the following screenshot:<div><img src="img/1468EXP_01_10.jpg" alt="How to do it..."/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">When you release the cursor, a context window will appear, similar to the one in the following screenshot:<a id="id89" class="indexterm"/></li></ul></div><div><img src="img/1468EXP_01_11.jpg" alt="How to do it..."/></div></li><li class="listitem"> In the<strong> Name</strong> field of the context window, enter<code class="literal"> labelStatus,</code> and click on<strong> Connect</strong>.<a id="id90" class="indexterm"/></li><li class="listitem"> Do the same for the button, and name it<code class="literal"> buttonTap</code>. Save the Interface Builder document by selecting<strong> File | Save</strong> in the menu bar, or by pressing<em> Option</em> -<em> S</em> on the keyboard.<a id="id91" class="indexterm"/></li><li class="listitem"> Back in MonoDevelop, enter the following code in the<code class="literal"> ViewDidLoad</code> method of the<code class="literal"> ButtonInputViewController</code> class:<a id="id92" class="indexterm"/><div><pre class="programlisting">// Create and hook a handler to our button's TouchUpInside event
// through its outlet
this.buttonTap.TouchUpInside += delegate( object sender, EventArgs e) {
this.labelStatus.Text = "Button tapped!";
};
</pre></div></li><li class="listitem">This code snippet adds a handler to the button's TouchUpInside event. This event is similar to the Clicked event of a Button control in System.Windows.Forms. It also displays the usage of an anonymous method, which just shows how MonoTouch provides C# features to .NET developers. That's it! Our application is now ready with functional controls.<a id="id93" class="indexterm"/></li><li class="listitem"> Compile and run it on the simulator. See the label changing its text when you tap on the button.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How it works...</h2></div></div></div><p>The outlet mechanism is basically a way of connecting Interface Builder objects with the code. They are necessary, since it is the only way we can access user interface objects that we create with Interface Builder. This is how Interface Builder works, and it is not just a MonoTouch workaround. An outlet of an object provides a variable of this object, so that we will be able to use it in a project. MonoTouch makes a developer's life much easier, because when we create outlets in Interface Builder and connect them, MonoDevelop works in the background by auto-generating code regarding those outlets. This is what the<code class="literal"> ButtonInputViewController.designer.cs</code> has added to provide us access to the controls we created:<a id="id94" class="indexterm"/>
</p><div><pre class="programlisting">[Outlet]
MonoTouch.UIKit.UILabel labelStatus { get; set; }
[Outlet]
MonoTouch.UIKit.UIButton buttonTap { get; set; }
</pre></div><p>These are the properties that provide us access to the controls. They are decorated with the<code class="literal"> OutletAttribute</code>. You can see that the names of the properties are the exact same names we entered for our outlets. This is very important, since we only have to provide names once for the outlets and do not have to worry about repeating the same naming conventions in different parts of our code. Notice also that the types of the variables of the controls are exactly the same as the types of controls we dragged-and-dropped in our user interface. This information is stored in the<code class="literal"> XIB</code> file, and MonoDevelop reads this information accordingly.<a id="id95" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>There's more...</h2></div></div></div><p>To remove outlets, you first have to disconnect them. For example, to remove the<code class="literal"> buttonTap</code> outlet,<em> Ctrl</em> - click on the button. In the panel that will appear, click on the small 
<strong>
(x)</strong> next to the outlet. This will disconnect the outlet.<a id="id96" class="indexterm"/>
</p><div><img src="img/1468EXP_01_12.jpg" alt="There's more..."/></div><p>After that, delete the following code from the Objective-C source file:</p><div><pre class="programlisting">@property (retain, nonatomic) IBOutlet UIButton *buttonTap;
</pre></div><p>When you save the document, the outlet will be removed from the MonoDevelop project.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec14"/>Adding outlets through code</h3></div></div></div><p>Another way of adding outlets is to create a property in your C# class and decorate it with the<code class="literal"> OutletAttribute:</code>
<a id="id97" class="indexterm"/>
</p><div><pre class="programlisting">[Outlet]
UIButton ButtonTap { get; set; }
</pre></div><p>When you open the<code class="literal"> XIB</code> file in Interface Builder, the outlet will have been added to the user interface. However, you would still have to connect it to the corresponding control. The easiest way to do this is to<em> Ctrl</em> - click on the control the outlet corresponds to and click-drag from<strong> New Referencing Outlet</strong> to the<strong> File's Owner</strong> object on the left of the designer area:<a id="id98" class="indexterm"/>
</p><div><img src="img/1468EXP_01_13.jpg" alt="Adding outlets through code"/></div><p>When you release the cursor, select the<strong> ButtonTap</strong> outlet from the small context menu that will appear.</p><div><h3 class="title"><a id="note10"/>Note</h3><p>Note that it is MonoDevelop that monitors for changes made in Interface Builder and not the other way around. When making changes in the MonoDevelop project, make sure to always open the<code class="literal"> XIB</code> file from inside MonoDevelop.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Interface builder</em></li><li class="listitem" style="list-style-type: disc"><em>Creating the UI</em></li><li class="listitem" style="list-style-type: disc"><em>Adding actions</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>,User Interface: Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Adding and customizing views</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Adding actions</h1></div></div></div><p>In this recipe, we discuss the concept of<strong> Actions</strong> and their usage with MonoTouch.<a id="id99" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Getting ready</h2></div></div></div><p>In this task, we will discuss how to use actions with the controls of the user interface. Create a new iPhone Single View Application project in MonoDevelop, and name it<code class="literal"> ButtonInputAction</code>. Open<code class="literal"> ButtonInputActionViewController.xib</code> in Interface Builder, and add the same controls, outlets, and connections as the ones from project<code class="literal"> ButtonInput</code> from the previous task. Do not add any code in the project for now.<a id="id100" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How to do it...</h2></div></div></div><p>Adding actions to interface objects is similar to adding outlets.</p><div><ol class="orderedlist"><li class="listitem"> In Interface Builder,<em> Ctrl-drag</em> from the button to the source code file. In the context window that will be shown, change the<strong> Connection</strong> field from<strong> Outlet</strong> to<strong> Action</strong>.</li><li class="listitem"> Enter<code class="literal"> OnButtonTap</code> in the<strong> Name</strong> field, and select<strong> Touch Up</strong> Inside in the<strong> Event</strong> field, if it is not already selected.<a id="id101" class="indexterm"/></li><li class="listitem"> Click on the<strong> Connect</strong> button, and save the document.</li><li class="listitem"> In the<code class="literal"> ButtonInputActionViewController</code> class, add the following method:<a id="id102" class="indexterm"/><div><pre class="programlisting">partial void OnButtonTap(NSObject sender){
this.labelStatus.Text = "Button tapped!";
}
</pre></div></li><li class="listitem"> The application is ready! Compile and run in the simulator.</li><li class="listitem"> Tap on the button, and see the text in the label change, just like in the previous application we created.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How it works...</h2></div></div></div><p>Actions in Objective-C are the equivalent of control events in C#. They are responsible for delivering notification signals of various objects. In this example, instead of hooking up a handler on the<code class="literal"> TouchUpInside</code> event of the button, we have added an action for it. As you may already have noticed, the method we added to act as a handler for the action was declared as<code class="literal"> partial</code>. That is because MonoDevelop already declared a partial method declaration for us. This is the code that was produced when we saved the document in Interface Builder:<a id="id103" class="indexterm"/>
</p><div><pre class="programlisting">[Action ("OnButtonTap:")]
partial void OnButtonTap (MonoTouch.Foundation.NSObject sender);
</pre></div><p>The partial declaration of the method is marked with the<code class="literal"> ActionAttribute</code>. This is another attribute from the<code class="literal"> MonoTouch.Foundation</code> namespace that allows us to expose methods as Objective-C actions. You see that the string parameter passed in the attribute is exactly the same as the action name we entered in Interface Builder, with an appended colon (:) to it.<a id="id104" class="indexterm"/>
</p><div><h3 class="title"><a id="note11"/>Note</h3><p>Colons in Objective-C indicate the presence of parameters. For example,<code class="literal"> doSomething</code> is different than<code class="literal"> doSomething:</code>. Their difference is that the first one does not accept any parameters, while the second accepts one parameter.</p></div><p>The colon at the end of the action name indicates that there is one parameter; in this case, the parameter<code class="literal"> MonoTouch.UIKit.NSObject</code> sender. This is what our application looks like when we have tapped on the button in the simulator:<a id="id105" class="indexterm"/>
</p><div><img src="img/1468EXP_01_14.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>There's more...</h2></div></div></div><p>The previous example was created just to show how to implement actions in MonoTouch projects. Replacing an event with an action is basically at the discretion of the developer.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Interface builder</em></li><li class="listitem" style="list-style-type: disc"><em>Creating the UI</em></li><li class="listitem" style="list-style-type: disc"><em>Accessing the UI with outlets</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Compiling</h1></div></div></div><p>In this recipe, we will discuss how to compile a project with MonoDevelop.<a id="id106" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>Getting ready</h2></div></div></div><p>MonoDevelop provides many different options for compiling. In this task, we will discuss these options. We will be working with the project<code class="literal"> ButtonInput</code> that we created earlier in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> With the project loaded in MonoDevelop, go to<strong> Project | ButtonInput Options</strong>.</li><li class="listitem"> In the window that appears, select<strong> iPhone Build</strong> from the<strong> Build</strong> section on the left pad. Select<strong> Debug</strong> as project configuration and<strong> iPhoneSimulator</strong> as a platform. In the<strong> Linker behavior</strong> field, select<strong> Link all assemblies</strong> from the combo box. In the<strong> SDK version</strong> field, select<strong> Default</strong>, if it is not already selected.</li><li class="listitem"> Now, go to<strong> iPhone Application</strong> on the left pad.</li><li class="listitem"> In the<strong> Summary</strong> tab, enter<code class="literal"> Button Input</code> in the<strong> Application name</strong> field and<code class="literal"> 1.0</code> in the<strong> Version</strong> field. Select version<strong> 3.0</strong> in the<strong> Deployment Target</strong> combo box. The<strong> iPhone Application</strong> options window is shown in the following screenshot:<div><img src="img/1468EXP_01_15.jpg" alt="How to do it..."/></div></li><li class="listitem"> Click on the<strong> OK</strong> button, and compile the project by clicking on<strong> Build | Build All</strong> in the menu bar.<a id="id107" class="indexterm"/></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>How it works...</h2></div></div></div><p>We have set up some options for our project. Let's see what these options provide for compilation customization.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec15"/>iPhone build options</h3></div></div></div><p>The first option we set up regards the Linker. The<strong> Linker</strong> is a tool that was developed by the MonoTouch team and is provided in the SDK. Every time a MonoTouch project is compiled, the compiler does not only compile the project, but all the assemblies of the MonoTouch framework it needs, so that the final application will be able to run on the device (or the simulator). This actually means that every application comes with its own compiled version of the MonoTouch framework. Doing so means the final application bundle is quite large in size. This is where the Linker comes in. What it does is to strip down the assemblies of all the unused code so that the compiler will only compile what is needed and used by the application. This results in much smaller application bundles: a precious asset when it comes to mobile applications. Especially since Apple has a download limitation of 20 MB per file through the cellular network. The Linker options are the following:<a id="id108" class="indexterm"/>
</p><p>The first option we set up regards the Linker. The<strong> Linker</strong> is a tool that was developed by the MonoTouch team and is provided in the SDK. Every time a MonoTouch project is compiled, the compiler does not only compile the project, but all the assemblies of the MonoTouch framework it needs, so that the final application will be able to run on the device (or the simulator). This actually means that every application comes with its own compiled version of the MonoTouch framework. Doing so means the final application bundle is quite large in size. This is where the Linker comes in. What it does is to strip down the assemblies of all the unused code so that the compiler will only compile what is needed and used by the application. This results in much smaller application bundles: a precious asset when it comes to mobile applications. Especially since Apple has a download limitation of 20 MB per file through the cellular network. The Linker options are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Don't Link:</strong> Use this option when debugging on the simulator. The Linker is turned off, and all the assemblies are compiled as they are. This provides faster compilation times.<a id="id109" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Link SDK assemblies only:</strong> Here, the Linker only strips down the MonoTouch Framework assemblies. The project assemblies remain intact. This option also effectively reduces the final size of the application.<a id="id110" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Link all assemblies:</strong> Here, the Linker is activated on all assemblies. it reduces the size a bit more. Care needs to be taken when using this option, if<strong> Reflection</strong> or<strong> Serialization</strong> is used in the code. Types and methods that are used through Reflection in the code are transparent to the Linker. If a situation like this exists in the code, decorate these types or methods with the<code class="literal"> PreserveAttribute</code>. This attribute basically informs the Linker to be left out of the stripping down process.<a id="id111" class="indexterm"/></li></ul></div><p>In the SDK version field, we set the<strong> iOS SDK version</strong> that will be used to compile the application. Setting it to<strong> Default</strong> automatically selects the highest SDK version installed on the system.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec16"/>iPhone application options</h3></div></div></div><p>In the<strong> iPhone Application</strong> window of the<strong> Build</strong> section in the project options, we have set up three options. The first option is the<strong> Application name</strong>. This is the name of the application bundle that will be displayed on the simulator, the device, and on the App Store. As we can see here, we can normally add spaces to the name. The second option,<strong> Version</strong>, defines the version of the application. It is what will be displayed as the application's version when it is finally distributed through the App Store. The third option,<strong> Deployment target</strong>, is the minimum iOS version the application can be installed on.<a id="id112" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>There's more...</h2></div></div></div><p>There are two more option windows. These are<strong> iPhone Bundle Signing</strong> and<strong> iPhone IPA</strong> options. They will be discussed thoroughly in the recipes of<a class="link" href="ch14.html" title="Chapter 14. Deploying"> Chapter 14</a>,Deploying.<a id="id113" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec17"/>Linker usage</h3></div></div></div><div><h3 class="title"><a id="note12"/>Note</h3><p>When compiling for the simulator, turning the Linker on is not suggested. That is because the compiler is not compiling the MonoTouch assemblies in the<code class="literal"> iPhoneSimulator</code> platform; hence they are being used directly. Turning the Linker on only causes compilation to take more time to complete. It has no effect in reducing the final application bundle size.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>See also</h2></div></div></div><p>In this book:</p><p>
<a class="link" href="ch14.html" title="Chapter 14. Deploying">Chapter 14</a>,Deploying:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Preparing our application for the App Store</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Debugging our application</h1></div></div></div><p>In this recipe, we will discuss information on debugging a MonoTouch application on the simulator.<a id="id114" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>Getting ready</h2></div></div></div><p>MonoTouch, in combination with MonoDevelop, provides a debugger for debugging applications either on the simulator or on the device. In this task, we'll see how to use the debugger for debugging MonoTouch applications. Open MonoDevelop, and load the<code class="literal"> ButtonInput</code> project. Make sure the debugger toolbar is activated by checking on<strong> View | Toolbars | Debugger</strong> in the menu bar. Also, set the project configuration to<strong> Debug | iPhoneSimulator</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> MonoDevelop supports breakpoints. To activate a breakpoint on a line, click on the space on the left of the line number to set it. Set a breakpoint on the following line in the<code class="literal"> Main.cs</code> file:<a id="id115" class="indexterm"/><div><pre class="programlisting">this.labelStatus.Text = "Button tapped!";
</pre></div></li><li class="listitem">This is what a breakpoint in MonoDevelop looks like:<div><img src="img/1468EXP_01_16.jpg" alt="How to do it..."/></div></li><li class="listitem"> Compile and debug the project by clicking on the second button with the double gears icon from the left, or by clicking<strong> Run | Debug</strong> on the menu bar. MonoDevelop will display a message box with the message,<strong> Waiting for debugger to connect</strong>. When the simulator is open and the app is loaded, watch the information that is provided in the<strong> Application Output</strong> pad. Tap on the app button. Execution will pause, and MonoDevelop will highlight the breakpoint in yellow. Move the mouse over the<code class="literal"> labelStatus</code> variable in the breakpoint line. MonoDevelop will then display a window with all the evaluated variable's members:<a id="id116" class="indexterm"/><div><img src="img/1468EXP_01_17.jpg" alt="How to do it..."/></div></li><li class="listitem"> To stop debugging, click on the<strong> stop</strong> button on the toolbar, marked with a white (X) in a red circle.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>How it works...</h2></div></div></div><p>MonoTouch, in combination with MonoDevelop, uses a debugger called<strong> Soft Debugger</strong>. It is called this, because it depends on both the runtime and MonoDevelop combined to provide one unified debugging platform. When the debugging process starts, MonoDevelop begins listening for debugging information from the application. The same applies for debugging on both the simulator and the device. When the application executes, it starts sending information back to MonoDevelop, which then displays that information in the<strong> Application Output</strong> pad, which is automatically activated. A typical application output when debugging is the information on the assemblies that are loaded, the threads that begin execution, and the breakpoints, if any, that are available.<a id="id117" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>There's more...</h2></div></div></div><p>The<code class="literal"> Console.WriteLine()</code> method can also be used for debugging purposes. The debugger takes care of this and redirects the output of the method to MonoDevelop's<strong> Application Output</strong> pad.<a id="id118" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec18"/>Application performance when debugging</h3></div></div></div><p>When compiling for debugging purposes, the compiler produces larger and slower code. That is because it generates extra code that is needed to provide the appropriate debugging information. That is why when debugging an application, the execution of the application is much slower than on simple running situations. Before producing a release copy of the application, remember to compile it with the<strong> Release | iPhone project configuration</strong> to avoid slow runtime execution.<a id="id119" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec19"/>Breakpoints in the FinishedLaunching method</h3></div></div></div><p>One more reason not to have complicated code in the<code class="literal"> FinishedLaunching</code> method is that in most cases, you will not be able to debug it. If you set a breakpoint in<code class="literal"> FinishedLaunching</code>, application execution will pause, but iOS will terminate the application when the time limit is reached.<a id="id120" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec39"/>See also</h2></div></div></div><p>In this book:</p><p>
<a class="link" href="ch14.html" title="Chapter 14. Deploying">Chapter 14</a>,Deploying:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating profiles</em></li><li class="listitem" style="list-style-type: disc"><em>Debugging on other devices</em></li></ul></div></div></div></body></html>