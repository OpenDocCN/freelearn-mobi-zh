- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple introduced **Swift concurrency**, which adds support for structured asynchronous
    and parallel programming to Swift 5.5, during WWDC21\. It allows you to write
    concurrent code, which is more readable and easier to understand. During WWDC24,
    Apple introduced **Swift 6**, which makes concurrency programming easier by diagnosing
    **data races** at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: At the present time, it is not recommended to turn strict concurrency on for
    large existing projects, as it is likely to generate multiple errors and warnings.
    However, as this is Apple’s direction going forward, you will be turning it on
    for the project in this chapter and in *Part 3* of this book so you may learn
    and gain experience with it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn the basic concepts of Swift concurrency. Next,
    you will examine an app without concurrency and explore its issues. After that,
    you will use `async/await` to implement concurrency in the app. Finally, you’ll
    make your app more efficient by using `async-let`.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned the basics of how Swift concurrency
    works and how to update your own apps to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Swift concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining an app without concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the app using `async/await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving efficiency using `async-let`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use an example app, *BreakfastMaker*, to understand the concepts of
    Swift concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed Xcode project for this chapter is in the `Chapter09` folder of
    the code bundle for this book, which can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition](https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://youtu.be/uEckcWHFeiE](https://youtu.be/uEckcWHFeiE%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by learning about Swift concurrency in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Swift concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Swift 5.5, Apple added support for writing **asynchronous** and **parallel**
    code in a structured way.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous code allows your app to suspend and resume code. Parallel code
    allows your app to run multiple pieces of code simultaneously. This allows your
    app to do things like update the user interface while still performing operations
    like downloading data from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: You can find links to all of Apple’s Swift concurrency videos during WWDC21
    at [https://developer.apple.com/news/?id=2o3euotz](https://developer.apple.com/news/?id=2o3euotz).
  prefs: []
  type: TYPE_NORMAL
- en: You can read Apple’s Swift concurrency documentation at [https://developer.apple.com/news/?id=2o3euotz](https://developer.apple.com/news/?id=2o3euotz).
  prefs: []
  type: TYPE_NORMAL
- en: During WWDC24, Apple released Swift 6\. With the Swift 6 language mode, the
    compiler can now guarantee that concurrent programs are free of data races. This
    means that code from one part of your app can no longer access the same area of
    memory that is being modified by code from another part of your app. However,
    when you create a new Xcode project, it defaults to the Swift 5 language mode,
    and you have to turn on the Swift 6 language mode to enable this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view Apple’s WWDC24 video on migrating your app to Swift 6, click this link:
    [https://developer.apple.com/videos/play/wwdc2024/10169/](https://developer.apple.com/videos/play/wwdc2024/10169/%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view Apple’s documentation on migrating your app to Swift 6, click this
    link: [https://www.swift.org/migration/documentation/migrationguide/](https://www.swift.org/migration/documentation/migrationguide/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea of how Swift concurrency works, imagine that you are making
    soft-boiled eggs and toast for breakfast. Here is one way of doing it:'
  prefs: []
  type: TYPE_NORMAL
- en: Put two slices of bread into the toaster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait two minutes until the bread is toasted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put two eggs in a pan containing boiling water, and cover them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait seven minutes until the eggs are cooked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plate and serve your breakfast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This takes nine minutes in total. Now, think about this sequence of events.
    Do you spend that time just staring at the toaster and the pan? You’ll probably
    be using your phone while the bread is in the toaster and the eggs are in the
    pan. In other words, you can do other things while the toast and eggs are being
    prepared. So, the sequence of events would be more accurately described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Put two slices of bread into the toaster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your phone for two minutes until the bread is toasted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put two eggs in a pan containing boiling water, and cover them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your phone for seven minutes until the eggs are cooked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plate and serve your breakfast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, you can see that your interaction with the toaster and pan can be suspended
    and then resumed, which means these operations are asynchronous. The operation
    still takes nine minutes, but you were able to do other things during that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another factor to consider. You don’t need to wait for the bread to
    finish toasting before you put the eggs in the pan. This means you could modify
    the sequence of steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Put two slices of bread into the toaster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the bread is toasting, put two eggs in a pan containing boiling water,
    and cover them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your phone for seven minutes. During that time, the bread will be toasted
    and the eggs will be cooked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plate and serve your breakfast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toasting the bread and boiling the eggs are now carried out in parallel, which
    saves you two minutes. Great! However, do note that you have more things to keep
    track of.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the concepts of asynchronous and parallel operations,
    let’s study the issues that an app without concurrency has in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Examining an app without concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve seen how asynchronous and parallel operations can help you prepare breakfast
    faster and allow you to use your phone while you’re doing it. Now, let’s look
    at a sample app that simulates the process of preparing breakfast. Initially,
    this app does not have concurrency implemented so you can see how that affects
    the app. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not already done so, download the `Chapter09` folder of the code
    bundle for this book at this link: [https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Eighth-Edition](https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Eighth-Edition).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Chapter09` folder, and you’ll see two folders, `BreakfastMaker-start`
    and `BreakfastMaker-complete`. The first folder contains the app that you will
    be modifying in this chapter, and the second contains the completed app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `BreakfastMaker-start` folder and then the `BreakfastMaker` Xcode
    project. Click on the **Main** storyboard file in the Project navigator. You should
    see four labels and a button in the **View Controller Scene**, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Main storyboard file showing the View Controller Scene'
  prefs: []
  type: TYPE_NORMAL
- en: The app will display a screen that shows the status of the toast and eggs, and
    the time taken to plate and serve your breakfast. The app will also display a
    button that you can use to test the responsiveness of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if some of these concepts are not familiar to you. You will learn
    how to build user interfaces using storyboards for your apps in the next chapter,
    *Chapter 10*, *Setting Up the User Interface*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **ViewController** file in the Project navigator. You should see
    the following code in the Editor area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this code simulates the process of making breakfast that was
    described in the previous section. Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These outlets are linked to four labels in the `Main` storyboard file. When
    you run the app, these labels will display the status of the toast and eggs, plating,
    and serving, as well as the time taken to complete the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This statement method is called when the view controller’s view appears onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This statement sets startTime to the current time, so the app can later calculate
    how long it takes to make the meal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This statement makes toastLabel display the text Making toast....
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This statement calls the makeToast() method, which waits for two seconds to
    simulate the time taken to make toast, and then returns the text Toast done, which
    will be displayed by toastLabel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This statement makes eggLabel display the text Boiling eggs....
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This statement calls the boilEggs() method, which waits for seven seconds to
    simulate the time taken to boil two eggs, and then returns the text Eggs done,
    which will be displayed by eggLabel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This statement calls the plateAndServe() method, which returns the text Plating
    and serving done, which will be displayed by `plateAndServeLabel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This statement sets `endTime` to the current time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This statement calculates the elapsed time (approximately eight seconds), which
    will be displayed by elapsedTim`eLabel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method displays **Button tapped** in the Debug area each time the button
    onscreen is tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the app, and tap the button the moment the user interface appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31371_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: iOS Simulator running the BreakfastMaker app, showing the button
    to be tapped'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should notice the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Tapping the button has no effect initially, and you’ll only see **Button tapped**
    in the Debug area after approximately nine seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Making toast...** and **Boiling eggs...** are never displayed, and **Toast
    done** and **Eggs done** only appear after approximately nine seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason why this happens is that your app’s code did not update the user
    interface while the `makeToast()` and `boilEggs()` methods were running. Your
    app did register the button taps but was only able to process them and update
    the labels after `makeToast()` and `boilEggs()` had completed their execution.
    These issues do not offer a good user experience with your app.
  prefs: []
  type: TYPE_NORMAL
- en: You have now experienced the issues presented by an app that does not have concurrency
    implemented. In the next section, you’ll modify the app using `async/await` so
    that it can update the user interface while the `makeToast()` and `boilEggs()`
    methods are running.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the app using async/await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw previously, the app is unresponsive when the `makeToast()` and `poachEgg()`
    methods are running. To resolve this, you will use async/await in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the `async` keyword in the method declaration indicates that the method
    is asynchronous. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing the `await` keyword in front of a method call marks a point where execution
    may be suspended, thus allowing other operations to run. This is what it looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can watch Apple’s WWDC21 video discussing async/await at [https://developer.apple.com/videos/play/wwdc2021/10132/](https://developer.apple.com/videos/play/wwdc2021/10132/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will modify your app to use async/await. This will enable it to suspend
    the `makeToast()` and `poachEgg()` methods to process button taps, update the
    user interface, and then resume execution of both methods afterward. You will
    also enable strict concurrency checking for your app by turning on the Swift 6
    language mode. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project navigator, click the **BreakfastMaker** icon at the top and
    then the **BreakfastMaker** target. In the **Build Settings** tab, change **Swift
    Language Version** to **Swift 6**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: BreakfastMaker project with Swift Language Version set to Swift
    6'
  prefs: []
  type: TYPE_NORMAL
- en: This enables strict concurrency checking for your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **ViewController** file in the Project navigator. Modify the `makeToast()`
    and `boilEggs()` methods, as shown here, to make the code in their bodies asynchronous:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Task` represents a unit of asynchronous work. It has a static method, `sleep(for:)`,
    which pauses execution for a specified duration, measured in seconds. Since this
    method is a throwing method, you’ll use the `try?` keyword to call it without
    having to implement a `do-catch` block. The `await` keyword indicates that this
    code can be suspended to allow other code to run.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `try?` will result in any errors being suppressed or ignored. This is
    acceptable in this case because sleeping for 2 or 7 seconds is unlikely to generate
    an error. This may not be acceptable in other situations, where a `do-catch` block
    is a better solution. You may wish to reread *Chapter 8*, *Protocols, Extensions,
    and Error Handling* for information on how to implement a `do-catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors will appear for both `makeToast()` and `boilEggs()`. Click either error
    icon to display the error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Error message when the error icon is clicked'
  prefs: []
  type: TYPE_NORMAL
- en: The error is displayed because you’re calling an asynchronous method inside
    a method that does not support concurrency. You will need to add the `async` keyword
    to the method declaration to indicate that it is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: For each method, click the **Fix** button to add the `async` keyword to the
    method declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that your code looks like this after you’re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The errors in the `makeToast()` and `poachEgg()` methods should be gone, but
    new errors will appear in the `viewDidAppear()` method. Click one of the error
    icons to see the error message, which will be the same as the message you saw
    in *step 2*. This is because you’re calling an asynchronous method inside a method
    that does not support concurrency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Fix** button, and more errors will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ignore the error in the method declaration for now, and click the one next
    to the `makeToast()` method call to see the error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Error message when the error icon is clicked'
  prefs: []
  type: TYPE_NORMAL
- en: This error message is displayed because you did not use `await` when calling
    an asynchronous function.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Fix** button to insert the `await` keyword before the method call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 7* and *step 8* for the error next to the `boilEggs()` method call.
    The `await` keyword will be inserted for the `boilEggs()` method call as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the error icon in the `viewDidAppear()` method declaration to see the
    error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Error with the error icon highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: This error is displayed because you can’t use the `async` keyword to make the
    `viewDidAppear()` method asynchronous, as this capability is not present in the
    superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this issue, you’ll remove the `async` keyword and enclose all the
    code after `super.viewDidAppear()` in a `Task` block, which will allow it to execute
    asynchronously in a synchronous method. Modify your code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the app, and tap the button as soon as you see the user interface.
    Note that **Button tapped** now appears immediately in the Debug area, and the
    labels update as they should. This is because the app is now able to suspend the
    `makeToast()` and `boilEggs()` methods to respond to taps, update the user interface,
    and resume method execution later. Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you look at the elapsed time, you’ll see that the app takes slightly
    longer to prepare breakfast than it did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31371_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: iOS Simulator running the BreakfastMaker app, showing the elapsed
    time'
  prefs: []
  type: TYPE_NORMAL
- en: This is partly due to the additional processing required for the async/await
    suspending and resuming methods, but there is another factor involved. Even though
    the `makeToast()` and `boilEggs()` methods are now asynchronous, the `boilEggs()`
    method only starts execution after the `makeToast()` method has finished execution.
    In the next section, you’ll see how you can use `async-let` to run the `makeToast()`
    and `boilEggs()` methods in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Improving efficiency using async-let
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though your app is now responsive to button taps and can update the user
    interface while the `makeToast()` and `boilEggs()` methods are running, both methods
    still execute sequentially. The solution here is to use `async-let`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing `async` in front of a `let` statement when you define a constant, and
    then writing `await` when you access the constant, allows the parallel execution
    of asynchronous methods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `methodName1()` and `methodName2()` will run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will modify your app to use `async-let` to enable the `makeToast()` and
    `poachEgg()` methods to run in parallel. In the `ViewController` file, modify
    the code in the `Task` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the app. You’ll see that the elapsed time is now less than it
    was before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31371_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: iOS Simulator running the BreakfastMaker app, showing the elapsed
    time'
  prefs: []
  type: TYPE_NORMAL
- en: This is because using `async-let` allows both the `makeToast()` and `poachEgg()`
    methods to run in parallel, and the `poachEgg()` method no longer waits for the
    `makeToast()` method to complete before starting execution. Cool!
  prefs: []
  type: TYPE_NORMAL
- en: There is still lots more to learn about Swift concurrency, such as structured
    concurrency and actors, but that is beyond the scope of this chapter. You can
    learn more about structured concurrency at [https://developer.apple.com/videos/play/wwdc2021/10134/](https://developer.apple.com/videos/play/wwdc2021/10134/),
    and you can learn more about actors at [https://developer.apple.com/videos/play/wwdc2021/10133/](https://developer.apple.com/videos/play/wwdc2021/10133/).
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully implemented asynchronous code in your app. Fantastic!
    There are still a lot of things to learn about Swift concurrency, such as structured
    concurrency and actors, but that is beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Give yourself a pat on the back; you have completed the first part of this book!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Swift concurrency and how to implement it
    in the *BreakfastMaker* app.
  prefs: []
  type: TYPE_NORMAL
- en: You started by learning the basic concepts of Swift concurrency. Then, you examined
    an app without concurrency and explored its issues. After that, you turned on
    strict concurrency checking and implemented concurrency in the app, using `async`/`await`.
    Finally, you made your app more efficient by using `async let`.
  prefs: []
  type: TYPE_NORMAL
- en: You now understand the basics of Swift concurrency and will be able to use `async`/`await`
    and `async-let` in your own apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will start writing your first iOS application by creating
    the screens for it, using storyboards, which allow you to rapidly prototype an
    application without having to type a lot of code.
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you. Scan the QR code
    below or visit the link to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](https://packt.link/NzOWQ%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2370024260177460609.png)](https://packt.link/NzOWQ%0D)'
  prefs: []
  type: TYPE_NORMAL
