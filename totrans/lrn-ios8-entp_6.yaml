- en: Chapter 6. Using iCloud and Security Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。使用 iCloud 和安全服务
- en: In this chapter, you will learn how to store your data on cloud, that is, on
    iCloud and security services for iOS, through which we can secure our data, passwords,
    and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何将数据存储在云端，即 iCloud 和 iOS 的安全服务中，通过这些服务我们可以保护我们的数据、密码等。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with iCloud
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 iCloud 一起工作
- en: Saving data using the keychain process
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥链过程保存数据
- en: iOS Touch ID authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS Touch ID 验证
- en: Working with iCloud
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 iCloud 一起工作
- en: Basically, **iCloud** is a service that helps users synchronize their data across
    devices. The main purpose is to let users easily store their data, whether it's
    a file or document, so that they can access it on any of their iOS devices. While
    you can use other cloud services to save files or data, the core idea behind iCloud
    is to eliminate explicit or wired connection between devices. Apple does not want
    users to think of the cloud servers and the syncing. Everything simply works seamlessly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，**iCloud** 是一种帮助用户在不同设备间同步数据的云服务。其主要目的是让用户能够轻松存储文件或文档等数据，以便在任何 iOS 设备上访问。虽然您可以使用其他云服务来保存文件或数据，但
    iCloud 的核心思想是消除设备之间的显式或有线连接。苹果公司不希望用户将云服务器和同步过程联系起来。一切工作都简单无缝地完成。
- en: The same design philosophy also applies to developers. When we adopt iCloud,
    we do not need to know how to interact with the cloud server or upload data to
    iCloud. The iOS handles all the heavy lifting. Our focus is on the content such
    as managing the change of data or developing a connection between a cloud and
    a device.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的设计理念也适用于开发者。当我们采用 iCloud 时，我们不需要知道如何与云服务器交互或上传数据到 iCloud。iOS 会处理所有繁重的工作。我们的重点是内容，例如管理数据的变化或开发云与设备之间的连接。
- en: 'iCloud offers three kinds of storage:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: iCloud 提供三种类型的存储：
- en: '**Key-value storage**: This is used to store content such as settings, preferences,
    and app states.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值存储**：用于存储设置、偏好设置和应用程序状态等内容。'
- en: '**Document storage**: This is used to store file type content such as WordPress
    documents, drawings, and complex app states.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档存储**：用于存储文件类型内容，如 WordPress 文档、绘图和复杂的应用程序状态。'
- en: '**Core data storage**: This is used for multi-device database solutions for
    structured content. iCloud core data storage is built on document storage and
    employs the same iCloud APIs.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心数据存储**：用于结构化内容的跨设备数据库解决方案。iCloud 核心数据存储建立在文档存储之上，并使用相同的 iCloud API。'
- en: 'Let''s understand how iCloud actually works. To use iCloud, we need an iOS
    developer account. Assuming that we have an iOS developer account, proceed with
    the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 iCloud 实际上是如何工作的。要使用 iCloud，我们需要一个 iOS 开发者账户。假设我们有一个 iOS 开发者账户，请按照以下步骤操作：
- en: Go to [https://idmsa.apple.com/IDMSWebAuth/login?&appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&path=%2F%2Faccount%2Findex.action](https://idmsa.apple.com/IDMSWebAuth/login?&appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&path=%2F%2Faccount%2Findex.action).
    We will first create the app ID with the iCloud feature available.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://idmsa.apple.com/IDMSWebAuth/login?&appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&path=%2F%2Faccount%2Findex.action](https://idmsa.apple.com/IDMSWebAuth/login?&appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&path=%2F%2Faccount%2Findex.action)。我们首先创建具有可用
    iCloud 功能的应用程序 ID。
- en: Sign in to the iOS Provisioning Portal, select the app IDs, and then create
    a new app ID.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 iOS 配置文件门户，选择应用程序 ID，然后创建一个新的应用程序 ID。
- en: Enable the iCloud service for your app by selecting the **iCloud** option. Select
    the Xcode that you are using (if you are using Xcode 5, then select Xcode 5) and
    click on **Continue**, as shown in the following screenshot:![Working with iCloud](img/1829OT_06_01.jpg)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **iCloud** 选项为您的应用程序启用 iCloud 服务。选择您正在使用的 Xcode（如果您正在使用 Xcode 5，则选择 Xcode
    5）并点击 **继续**，如图所示：![与 iCloud 一起工作](img/1829OT_06_01.jpg)
- en: Now, give the name of our project in the **Name** text field, write the bundle
    ID in the **Bundle ID** text field, and click on **Continue**, as shown in the
    following screenshot:![Working with iCloud](img/1829OT_06_02.jpg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **名称** 文本框中输入我们项目的名称，在 **包 ID** 文本框中写入包 ID，然后点击 **继续**，如图所示：![与 iCloud
    一起工作](img/1829OT_06_02.jpg)
- en: Now, it will show the enabled services for our app. Make sure **iCloud** is
    enabled or configurable, as shown in the following screenshot:![Working with iCloud](img/1829OT_06_03.jpg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它将显示我们应用程序启用的服务。确保 **iCloud** 已启用或可配置，如图所示：![与 iCloud 一起工作](img/1829OT_06_03.jpg)
- en: Then, go to **Xcode** and build a new single-view application. After that, go
    to **Capabilities** in **Xcode** and turn on **iCloud**; this will include iCloud
    entitlements, iCloud containers, and the link to the Cloud framework, as shown
    in the following screenshot:![Working with iCloud](img/1829OT_06_04.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，进入**Xcode**并构建一个新的单视图应用程序。之后，进入**Xcode**中的**功能**并开启**iCloud**；这将包括iCloud权限、iCloud容器以及到Cloud框架的链接，如图下所示：![与iCloud一起工作](img/1829OT_06_04.jpg)
- en: Make sure that the entitlements are created automatically. The following screenshot
    shows the entitlements created:![Working with iCloud](img/1829OT_06_05.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保权限是自动创建的。以下截图显示了创建的权限：![与iCloud一起工作](img/1829OT_06_05.jpg)
- en: Delete the `ViewController` class and existing view in the storyboard.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除故事板中的`ViewController`类和现有视图。
- en: Now, we will empty the storyboard and create a new objective-C class, a subclass
    of `tableViewController`, and name it (for example, `NoteListViewController`).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将清空故事板并创建一个新的Objective-C类，它是`tableViewController`的子类，并将其命名为（例如，`NoteListViewController`）。
- en: Drag one table view controller to the storyboard and embed it in Navigation
    Controller. Now, give a name to this table view controller from the Attribute
    Inspector; it should be the same as the class name. Do the same thing one more
    time for a new class and name it (for example, `AddNoteViewController`).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个表格视图控制器拖到故事板中，并将其嵌入到导航控制器中。现在，从属性检查器为这个表格视图控制器命名；它应该与类名相同。为一个新的类重复此操作一次，并将其命名为（例如，`AddNoteViewController`）。
- en: Now, we have two table views in the storyboard. For `NoteListViewController`,
    drag a button to the top-right part of the navigation bar and set the identifier
    as `add`. This will automatically change the button to a **+** button, as shown
    in the following screenshot. Next, select the prototype cell and change its style
    to **Basic**.![Working with iCloud](img/1829OT_06_06.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在故事板中有两个表格视图。对于`NoteListViewController`，将一个按钮拖到导航栏的右上角，并将标识符设置为`add`。这将自动将按钮更改为**+**按钮，如图下所示。接下来，选择原型单元格并将其样式更改为**Basic**。![与iCloud一起工作](img/1829OT_06_06.jpg)
- en: Navigation Controller and Note List View Controller
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航控制器和笔记列表视图控制器
- en: For `AddNoteViewController`, drag the bar buttons into the navigation bar. Name
    one as `Cancel` and the other as `Save`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`AddNoteViewController`，将栏按钮拖到导航栏中。将一个命名为`Cancel`，另一个命名为`Save`。
- en: Then, select the table view and set the content to **Static Cells**. Finally,
    add one static row to the table view and add a text field, as shown here:![Working
    with iCloud](img/1829OT_06_07.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择表格视图并将其内容设置为**静态单元格**。最后，向表格视图中添加一个静态行并添加一个文本字段，如图所示：![与iCloud一起工作](img/1829OT_06_07.jpg)
- en: Navigation Controller and Note List View Controller
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航控制器和笔记列表视图控制器
- en: '`AddNoteViewController` will be shown when the user taps on the **+** button.
    So, press and hold the *Ctrl* key, click on the **+** button, and drag it to **Add
    Note View Controller**. Select **Modal** as the Segue action. Our storyboard should
    now look like this:![Working with iCloud](img/1829OT_06_08.jpg)'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击**+**按钮时，将显示`AddNoteViewController`。因此，按住*Ctrl*键，点击**+**按钮，并将其拖到**添加笔记视图控制器**。选择**模态**作为过渡动作。现在，我们的故事板应该看起来像这样：![与iCloud一起工作](img/1829OT_06_08.jpg)
- en: The table view showing Add Note View Controller
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示添加笔记视图控制器的表格视图
- en: 'Finally, link up the text field to `AddNoteViewController` and create two action
    methods: `Cancel` and `Save`. Our code in `AddNoteViewController.h` should like
    this:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将文本字段链接到`AddNoteViewController`并创建两个动作方法：`Cancel`和`Save`。我们的`AddNoteViewController.h`中的代码应该如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to implement the `NoteListViewController` class so that we can display
    the notes available on the cloud in the table view. Open `NoteListViewController.h`
    and add this property to it:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现`NoteListViewController`类，以便我们可以在表格视图中显示云上可用的笔记。打开`NoteListViewController.h`并将此属性添加到其中：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The purpose of the property is to save notes locally. We''ll display the notes
    in the table view when needed. Next, we need to make a lazy instantiation of this
    property. Lazy instantiation is a good technique if we have an object that only
    needs to be configured once and has some configuration involved that we don''t
    want to clutter in our `init` method. Add the following code in `NoteListViewController.m`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该属性的目的是在本地保存笔记。当需要时，我们将在表格视图中显示笔记。接下来，我们需要对此属性进行懒加载实例化。如果有一个只需要配置一次且涉及一些我们不想在`init`方法中混淆的配置的对象，懒加载实例化是一个很好的技术。在`NoteListViewController.m`中添加以下代码：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `viewDidLoad`, we need to create the notification method as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `viewDidLoad` 方法中，我们需要创建如下通知方法：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: iCloud data synchronization is achieved using the `NSUbiquitousKeyValueStore`
    class. `NSUbiquitousKeyValueStore` is a subclass of `NSObject`, and it is available
    in iOS 5.0 and later. An `NSNotificationCenter` object provides a mechanism to
    broadcast information or messages within a program. It is also a subclass of `NSObject`,
    and it is available in iOS 2.0 and later.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `NSUbiquitousKeyValueStore` 类实现 iCloud 数据同步。`NSUbiquitousKeyValueStore` 是
    `NSObject` 的子类，并在 iOS 5.0 及以后的版本中可用。`NSNotificationCenter` 对象提供了一种在程序内部广播信息或消息的机制。它也是一个
    `NSObject` 的子类，并在 iOS 2.0 及以后的版本中可用。
- en: 'Our `viewDidLoad` method will probably look like this:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `viewDidLoad` 方法可能看起来像这样：
- en: '![Working with iCloud](img/1829OT_06_09.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![与 iCloud 一起工作](img/1829OT_06_09.jpg)'
- en: 'Now, we have to implement methods that are executed when the preceding notifications
    are called. The `didAddNewNote` method will be invoked when users save a new note:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须实现当调用前面的通知时执行的方法。当用户保存新笔记时，将调用 `didAddNewNote` 方法：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to display the notes in table view. We have already retrieved the notes
    saved in iCloud; the rest of the implementation is to display the notes in the
    table view. In `NoteListViewController.m`, add the following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在表格视图中显示笔记。我们已经检索了保存在 iCloud 中的笔记；其余的实现是在表格视图中显示笔记。在 `NoteListViewController.m`
    中添加以下代码：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have now come to the last part of the process: implementing `AddNoteViewController`
    to add notes to the cloud. Go to the implementation file of `AddNoteViewController`
    and add the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经到达了过程的最后部分：实现 `AddNoteViewController` 以将笔记添加到云端。转到 `AddNoteViewController`
    的实现文件，并添加以下代码：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To test the note app, we have to compile and deploy it onto an actual device.
    If you are using a simulator that supports iOS 7.1 or later, then you will be
    able to use the simulator for testing. Make sure that you enable iCloud on both
    devices. Launch the app, add a note on one device, and you'll see the note appear
    on the other device.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试笔记应用程序，我们必须编译并将其部署到实际设备上。如果您使用的是支持 iOS 7.1 或更高版本的模拟器，那么您将能够使用模拟器进行测试。确保您在两个设备上都启用了
    iCloud。启动应用程序，在一台设备上添加笔记，您将在另一台设备上看到笔记出现。
- en: Keychain Services
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密钥链服务
- en: '**Keychain Services** is a programming interface that enables developers to
    add, find, modify, and remove keychain items. In iOS and OS X, a keychain is an
    encrypted container that stores passwords and other private data that need to
    be secured. In iOS, each application has its own keychain to which it has access.
    This ensures that our data is secured by the third party and other users.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥链服务** 是一个编程接口，允许开发者添加、查找、修改和删除密钥链项。在 iOS 和 OS X 中，密钥链是一个加密容器，用于存储需要安全保护的秘密数据，如密码和其他私人数据。在
    iOS 中，每个应用程序都有自己的密钥链，它可以访问。这确保了我们的数据由第三方和其他用户得到保护。'
- en: Keychain provides a small space on which we can only store specific data such
    as passwords, account numbers, private numbers, and so on. With this article,
    I hope to convince you of the value of using the keychain in iOS and OS X instead
    of, for example, the application's user-defaults database, which stores its data
    in plain text without any form of security. Saving our data in keychain is better
    than the default database, because keychain is far more secure and robust.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥链提供了一个小空间，我们只能在其中存储特定的数据，如密码、账户号码、私人号码等。通过这篇文章，我希望说服你使用 iOS 和 OS X 中的密钥链而不是，例如，应用程序的用户默认数据库的价值，该数据库以纯文本形式存储其数据，没有任何安全形式。在密钥链中保存我们的数据比默认数据库更好，因为密钥链更加安全和健壮。
- en: 'In iOS, an application can use the keychain through the Keychain Services API.
    This API provides a number of functionalities to manipulate the data stored in
    the application''s keychain. The APIs are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中，应用程序可以通过密钥链服务 API 使用密钥链。此 API 提供了多种功能来操作应用程序密钥链中存储的数据。API 如下：
- en: '`SecItemAdd`: This API is used to add data in keychain'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecItemAdd`：此 API 用于在密钥链中添加数据'
- en: '`SecItemCopyMatching`: This API is used to find the existing data in keychain'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecItemCopyMatching`：此 API 用于在密钥链中查找现有数据'
- en: '`SecItemDelete`: This API is used to remove the data from the application''s
    keychain'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecItemDelete`：此 API 用于从应用程序的密钥链中删除数据'
- en: '`SecItemUpdate`: This API is used to update the data in the application''s
    keychain'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecItemUpdate`：此 API 用于更新应用程序密钥链中的数据'
- en: The Keychain Services API is a C-based API, but this doesn't prevent us from
    using it. Each of the preceding functions accepts a dictionary (`CFDictionaryRef`).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Keychain Services API是一个基于C的API，但这并不妨碍我们使用它。前面提到的每个函数都接受一个字典（`CFDictionaryRef`）。
- en: Encryption and decryption
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密和解密
- en: 'Most of us know about two types of encryption: symmetric and asymmetric encryption.
    Symmetric encryption, on the one hand, uses one shared key to encrypt and decrypt
    data. Asymmetric encryption, on the other hand, uses one key to encrypt data and
    another separate, but related, key to decrypt data.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人知道两种加密类型：对称加密和非对称加密。对称加密一方面使用一个共享密钥来加密和解密数据。另一方面，非对称加密使用一个密钥来加密数据，并使用另一个单独但相关的密钥来解密数据。
- en: In iOS, to encrypt and decrypt data, a Security framework is available. This
    process takes place under the hood, so we won't be directly interacting with this
    framework. We'll use symmetric encryption in our example application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS中，为了加密和解密数据，有一个安全框架可用。这个过程在幕后进行，因此我们不会直接与这个框架交互。在我们的示例应用中，我们将使用对称加密。
- en: The Security framework offers a number of other services, such as Randomize
    services to generate cryptographically-secure random numbers; Certificate, Key
    and Trust services to manage certificates; public and private keys; and trust
    policies. The Security framework is a low-level framework available in both iOS
    and OS X with C-based APIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 安全框架提供了一些其他服务，例如随机化服务来生成加密安全的随机数；证书、密钥和信任服务来管理证书；公钥和私钥；以及信任策略。安全框架是一个在iOS和OS
    X中都可用且基于C的API的低级框架。
- en: iOS keychain concepts and structure
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS密钥链概念和结构
- en: The keychain is a secure and encrypted way to store our precious data. It is
    important that your app, and all subsequent versions of it, are signed by the
    same mobile-provision profile. If they aren't, you will have many troubles later
    on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥链是一种安全且加密的方式来存储我们的宝贵数据。确保你的应用及其所有后续版本都由相同的移动配置文件签名非常重要。如果不是这样，你以后会遇到很多麻烦。
- en: A keychain is a unit of sensitive data stored in your app. Keychain items are
    accompanied by one or more attributes. The attributes describe the keychain item,
    and which attributes we can use depends on the item class of the keychain item.
    The item class refers to the type of data we are going to store. This can be a
    username/password combination, a certificate, a generic password, and so on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥链是在你的应用中存储的敏感数据单元。密钥链项附带一个或多个属性。属性描述了密钥链项，我们可以使用哪些属性取决于密钥链项的类。项类指的是我们打算存储的数据类型。这可以是一个用户名/密码组合、一个证书、一个通用密码等等。
- en: Understanding the application flow
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解应用流程
- en: 'Before we start building the application, we need to know about the application
    flow, which is explained here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建应用之前，我们需要了解应用流程，这在此处解释：
- en: When the user launches the application, it presents the user with a view to
    sign in.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户启动应用时，它会向用户展示一个用于登录的视图。
- en: If it hasn't created an account yet, its credentials are added to the keychain
    and signed in. If it has an account but enters an incorrect password, an error
    message is shown.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有创建账户，其凭证将被添加到密钥链并登录。如果它有账户但输入了错误的密码，会显示错误消息。
- en: Once it has signed in, it has access to the data collected with the application.
    The data is securely stored by the application.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦登录，它就可以访问应用收集的数据。应用会安全地存储这些数据。
- en: Whenever it takes data with the text field, this data is encrypted and stored
    in the application's `Documents` directory.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次它使用文本字段获取数据时，这些数据都会被加密并存储在应用中的`Documents`目录下。
- en: Whenever it switches to another application or the device gets locked, it automatically
    signs out.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次它切换到另一个应用或设备被锁定时，它会自动登出。
- en: 'Let''s start an activity on the Keychain. Just follow these steps to accomplish
    the activity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在密钥链上开始一个活动。只需遵循以下步骤来完成活动：
- en: Open Xcode and make a single-view application. Then, go to **KeyChainSample**
    | **Capabilities** and turn on the **Keychain Sharing** option, as shown in the
    following screenshot:![Understanding the application flow](img/1829OT_06_11.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Xcode，创建一个单视图应用。然后，转到**KeyChainSample** | **Capabilities**并开启**Keychain Sharing**选项，如图所示：![理解应用流程](img/1829OT_06_11.jpg)
- en: After turning on the **Keychain Sharing** option, it will automatically create
    **Entitlements File** for us, as shown in the following screenshot:![Understanding
    the application flow](img/1829OT_06_12.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**钥匙串共享**选项后，它将自动为我们创建**权限文件**，如下截图所示：![理解应用程序流程](img/1829OT_06_12.jpg)
- en: Don't forget to add **Security framework** (shown in the following screenshot);
    without it, the keychain will not work:![Understanding the application flow](img/1829OT_06_13.jpg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记添加**安全框架**（如下截图所示）；没有它，钥匙串将无法工作：![理解应用程序流程](img/1829OT_06_13.jpg)
- en: Now, make a user interface in the storyboard like this:![Understanding the application
    flow](img/1829OT_06_14.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在故事板中创建一个如下所示的用户界面：![理解应用程序流程](img/1829OT_06_14.jpg)
- en: 'Add a new Objective-C file to the project subclass of `NSObject`. Then, write
    the following code in the interface file of the new file. Also, import `security.h`
    on the top of the file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的Objective-C文件添加到项目的`NSObject`子类中。然后，在新文件的接口文件中写下以下代码。同时，在文件顶部导入`security.h`：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our interface file will look like this:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的用户界面文件将看起来像这样：
- en: '![Understanding the application flow](img/1829OT_06_15.jpg)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![理解应用程序流程](img/1829OT_06_15.jpg)'
- en: 'Write the following code in the implementation file of the new file that we
    added:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们添加的新文件的实现文件中写下以下代码：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `_bridge` object is used to transfer a pointer between Objective-C and
    the core foundation, with no transfer of ownership. Our interface file will probably
    look like this:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_bridge`对象用于在Objective-C和核心基金会之间传递指针，不涉及所有权的转移。我们的接口文件可能看起来像这样：'
- en: '![Understanding the application flow](img/1829OT_06_16.jpg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![理解应用程序流程](img/1829OT_06_16.jpg)'
- en: Connect the UI components to our `viewController.h` file. Import `KeyChain`
    (the newly added Objective-C file) on top of the file and create an object of
    the `KeyChain` class in the interface as follows:![Understanding the application
    flow](img/1829OT_06_17.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UI组件连接到我们的`viewController.h`文件。在文件顶部导入`KeyChain`（新添加的Objective-C文件），并在接口中创建`KeyChain`类的对象，如下所示：![理解应用程序流程](img/1829OT_06_17.jpg)
- en: 'Add the code in the `IBAction` methods of our button with some more code as
    follows in the `viewController.m` file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`viewController.m`文件中按钮的`IBAction`方法中添加一些代码，如下所示：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our interface file will probably look like this:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的接口文件可能看起来像这样：
- en: '![Understanding the application flow](img/1829OT_06_18.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![理解应用程序流程](img/1829OT_06_18.jpg)'
- en: Compile and run the project; our simulator looks like the following screenshot.
    Enter the values and click on the **Save** button:![Understanding the application
    flow](img/1829OT_06_19.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行项目；我们的模拟器看起来如下截图所示。输入值并点击**保存**按钮：![理解应用程序流程](img/1829OT_06_19.jpg)
- en: After clicking on the **Save** button, one pop up will appear (as shown in the
    following screenshot) with a message that our data is saved in the keychain securely.![Understanding
    the application flow](img/1829OT_06_20.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮后，将出现一个弹出窗口（如下截图所示），显示我们的数据已安全保存在钥匙串中。![理解应用程序流程](img/1829OT_06_20.jpg)
- en: Now write the **Key** value in the text field that exists in the keychain storage
    and click on the **Find** button. It will show data in a pop-up message as follows:![Understanding
    the application flow](img/1829OT_06_21.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请在钥匙串存储中存在的文本字段中写入**Key**值，然后点击**查找**按钮。它将以如下弹出消息显示数据：![理解应用程序流程](img/1829OT_06_21.jpg)
- en: The Touch ID API
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Touch ID API
- en: Apple introduced a new feature in iOS 7 called **Touch ID authentication**.
    Previously, there was only four-digit passcode security in iPhones; now, Apple
    has extended security and introduced a new security pattern in iPhones. In Touch
    ID authentication, our fingerprint acts as a password. After launching the Touch
    ID fingerprint-recognition technology in the iPhone 5S last year, Apple is now
    providing it for developers with iOS 8\. Now, third-party apps will be able to
    use Touch ID for authentication in the new iPhone and iPad OSes. Accounting apps,
    and other apps that contain personal and important data, will be protected with
    Touch ID. Now, you can protect all your apps with your fingerprint password.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在iOS 7中引入了一个名为**Touch ID身份验证**的新功能。之前，iPhone中只有四位数密码安全；现在，苹果扩展了安全性，并在iPhone中引入了一种新的安全模式。在Touch
    ID身份验证中，我们的指纹充当密码。去年，苹果在iPhone 5S上启动了Touch ID指纹识别技术后，现在它通过iOS 8为开发者提供这项技术。现在，第三方应用将能够在新的iPhone和iPad
    OS中利用Touch ID进行身份验证。会计应用和其他包含个人和重要数据的应用将受到Touch ID的保护。现在，你可以用你的指纹密码保护所有应用。
- en: '![The Touch ID API](img/1829OT_06_22.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Touch ID API](img/1829OT_06_22.jpg)'
- en: There are two ways to use Touch ID as an authentication mechanism in our iOS
    8 applications. They are explained in the following sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的iOS 8应用中将Touch ID用作身份验证机制有两种方法。它们将在以下章节中解释。
- en: Touch ID through touch authentication
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过触摸身份验证使用Touch ID
- en: The Local Authentication API is an API that returns a Boolean value to accept
    and decline the fingerprint. If there is an error, then an error code gets executed
    and tells us what the issue is.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本地身份验证API是一个返回布尔值的API，用于接受和拒绝指纹。如果有错误，则执行错误代码并告诉我们问题所在。
- en: 'Certain conditions have to be met when using Local Authentication. They are
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地身份验证时必须满足某些条件。它们如下：
- en: The application must be in the foreground (this doesn't work with background
    processes)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须在前台（此功能不适用于后台进程）
- en: If you're using the straight Local Authentication method, you will be responsible
    for handling all the errors and properly responding with your UI to ensure that
    there is an alternative method to log in to your apps
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是直接的本地身份验证方法，你将负责处理所有错误，并使用你的UI正确响应，以确保有其他登录应用的方法
- en: Touch ID through Keychain Access
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Keychain Access使用Touch ID
- en: Keychain Access includes the new Touch ID integration in iOS 8\. In Keychain
    Access, we don't have to work on implementation details; it automatically handles
    the passcode implementation using the user's passcode. Several keychain items
    can be chosen to use Touch ID to unlock the item when requested in code through
    the use of the new **Access** **Control Lists** (**ACLs**). ACL is a feature of
    iOS 8\. If Touch ID has been locked out, then it will allow the user to enter
    the device's passcode to proceed without any interruption.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Keychain Access在iOS 8中包含了新的Touch ID集成。在Keychain Access中，我们不需要处理实现细节；它将自动使用用户的密码处理密码实现。可以通过使用新的**访问控制列表**（**ACLs**）选择多个密钥链项，通过代码请求使用Touch
    ID解锁项。ACL是iOS 8的一个特性。如果Touch ID已被锁定，则允许用户输入设备的密码，无需任何中断地继续操作。
- en: 'There are some features of Keychain Access that make it the best option for
    us. They are listed here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Keychain Access有一些特性使其成为我们的最佳选择。它们在此列出：
- en: Keychain Access uses Touch ID, and its attributes won't be synced by any cloud
    services. So, these features make it very safe to use.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keychain Access使用Touch ID，并且其属性不会被任何云服务同步。因此，这些功能使其非常安全使用。
- en: If users overlay more than one query, then the system gets confused about correct
    user, and it will pop up a dialog box with multiple touch issues.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户叠加了多个查询，则系统会混淆正确的用户，并会弹出包含多个触摸问题的对话框。
- en: Using the Local Authentication framework
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本地身份验证框架
- en: 'Apple provides a framework to use Touch ID in our app called **Local Authentication**.
    This framework was introduced for iOS 8\. To make an app, including the Touch
    ID authentication, we need to import this framework in our code. It is present
    in the framework library of Apple. Let''s see how to use the Local Authentication
    framework:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了一个名为**本地身份验证**的框架，用于在我们的应用中使用Touch ID。此框架是为iOS 8引入的。为了创建一个包含Touch ID身份验证的应用，我们需要在我们的代码中导入此框架。它存在于苹果的框架库中。让我们看看如何使用本地身份验证框架：
- en: 'Import the Local Authentication framework as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式导入本地身份验证框架：
- en: '[PRE10]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This framework will work on Xcode 6 and above.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此框架将在Xcode 6及以上版本中工作。
- en: 'To use this API, we have to create a Local Authentication context, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此API，我们必须创建一个本地身份验证上下文，如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, check whether Touch ID is available or not and whether it can be used
    for authentication:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查Touch ID是否可用以及是否可用于身份验证：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To display Touch ID, use the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示Touch ID，请使用以下代码：
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Take a look at the following example of Touch ID:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下Touch ID的示例：
- en: '[PRE14]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to push your data to iCloud and how to save
    your private data, such as passwords, account numbers, ATM pins, and so on, to
    Keychain. We also focused on the Touch ID API, which was introduced in iOS 8\.
    In the next chapter, you will learn how to push your app on the App Store.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将你的数据推送到iCloud以及如何将你的私人数据，如密码、账户号码、ATM密码等，保存到Keychain。我们还重点介绍了iOS
    8中引入的Touch ID API。在下一章中，你将学习如何将你的应用推送到App Store。
