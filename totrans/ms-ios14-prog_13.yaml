- en: '*Chapter 13*: Working with the Combine Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the launch of **Combine**, Apple provided developers with a new way of
    handling events in their code; a functional and declarative approach, where developers
    can implement streams and publisher/subscriber paradigms easily, without the need
    for external libraries. Centralizing event processing in your apps with the help
    of Combine makes your code easier to understand than using other traditional methods
    like nested closures or callbacks all around your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the Combine framework: We will review the basic components of
    the framework with code samples – publishers, subscribers, subjects, and operators.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combining publishers, subscribers, and operators: We will build a small feature
    in an example app mixing all these concepts together.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using operators to build error-proof streams: We will use `flatMap` and `catch`
    to create streams that can deal properly with errors in a real-world example app.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should be able to use Combine in multiple parts
    of your own apps to produce simple, effective, and easy to understand declarative
    code that will help your app's code be easy to understand, extend, and maintain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code bundle for this chapter includes two starter projects called **CombineExample_start**
    and **PublishersAndSubscribers_start**. You can find them in the code bundle repository:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Combine framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple released the Combine framework in 2019, and they defined it as a framework
    that provides a declarative Swift API for processing values over time. There are
    **publishers**, which produce those values, and **subscribers**, which consume
    them. These values that change over time may represent different asynchronous
    events.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an overview of the Publisher and Subscriber protocol definitions to
    understand their key concepts in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Publisher
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned before, publishers are used in Combine to produce values over
    time. Let''s dig into the Swift protocol that defines them to understand the key
    concepts. The `Publisher` definition in Swift looks as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s explain each numbered comment in more detail:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Every `Publisher` instance has an associated type, `Output`. This defines the
    type of values that the publisher will generate over time.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the same time, the `Publisher` can also generate errors, and the associated
    type `Failure` is used to define the type of those errors. If a `Publisher` never
    generates errors, the `Failure` can be defined as type `Never`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, a `Publisher` allows `Subscriber` entities to `subscribe` to it to
    receive the values that are being produced over time. Note that to generate a
    valid subscription, the publisher's `Output` type must match the subscriber's
    `Input` type. In the same way, the `Failure` type of both must match too.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figure shows a summary of the **Publisher**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Publisher summary'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.1_B14717.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Publisher summary
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an initial description of the critical concepts of a publisher,
    let's do the same with the `Subscriber` protocol.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Subscriber
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that `Publisher` entities produce values over time. Now let''s
    see how `Subscriber` entities can consume those values. `Publisher` and `Subscriber`
    work closely together in Combine, so let''s see their internal details. The `Subscriber`
    protocol in Swift looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, let''s review each numbered line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: A `Subscriber` entity is going to receive values over time. The associated type
    `Input` defines the type of those values.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the same time, the `Subscriber` can also receive errors, and the associated
    type `Failure` is used to define the type of those errors. If a `Subscriber` never
    receives errors, the `Failure` can be defined as type `Never`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method informs the `Subscriber` that the subscription to the `Publisher`
    is successful and it may start requesting elements.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Informs the `Subscriber` that the `Publisher` has produced a new item.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some subscriptions may end over time. In those scenarios, this method is called
    to inform the `Subscriber` that it will not receive any more values. It allows
    us to execute a completion block before finishing.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figure shows a summary of the **Subscriber**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Subscriber summary'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B14717.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Subscriber summary
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'If we put together both Publisher and Subscriber figures, we have the following
    schema:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Publisher and Subscriber schemas'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B14717.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Publisher and Subscriber schemas
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the output-input and the failure types of the publisher and the subscriber
    must be equal.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a basic idea of what a publisher and a subscriber look like,
    let''s see how they communicate. There are three steps, pictured in the following
    figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Publisher and Subscriber communication process'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.4_B14717.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – Publisher and Subscriber communication process
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list describes the process in more detail:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the `Subscriber` tells the `Publisher` that it wants to subscribe.
    The `Publisher` sends back a subscription. The `Subscriber` uses that subscription
    to start requesting elements. The subscriber can request from N to unlimited values.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the `Publisher` is free to send those values over time. The `Subscriber`
    will receive those inputs.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In subscriptions that are not expecting unlimited values, a completion event
    is sent to the `Subscriber`, so it is aware that the subscription is over.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we have a basic idea of what a publisher is and what a subscriber is. We
    also know the steps involved in their communication. That is enough theory! Here
    is a practical example of a single publisher sending the values of an array to
    a subscriber. You can open a new Xcode playground and try the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first comment, we create an array of integers from 1 to 4, and we use
    the convenience instance property `publisher` from the Sequence protocol to wrap
    it inside a new `Publisher` instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: In the second comment, we use the method `sink` to attach a subscriber to the
    publisher, defining inside its completion block an action to perform over each
    value received over time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute this code, the output will be like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The initial array contained the numbers from 1 to 4, and that is what we printed.
    But what if we just want to print the even numbers? How can we transform the data
    between the producer and the subscriber? Luckily for us, Combine provides **Operators**
    to help us. Let's see more about them next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Operators
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `filter`, `map`, `reduce`, `scan`, `combineLatest`, `merge`, and `zip`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Using filter
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `filter` operator is used to just remove values matching some condition
    out of the stream.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a fundamental example using the `filter` operator. Imagine that
    from the previous array (`[1,2,3,4]`), we only want to print the even numbers
    of the array. We do it as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how the `filter` operator sits between the publisher and the subscriber,
    and defines a modification of the elements in a declarative way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this code, you will obtain the following result in the console:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let's see another example of how operators can be handy when working with
    Combine. Remember that the first rule of the subscriber and publisher is that
    the `Input` of the subscriber must be equal to the `Output` of the publisher.
    What happens when they are not equal? Well, operators can help us to transform
    the `Output` of a publisher to adapt it to the proper `Input` type of the subscriber.
    One of the operators that helps us is `map`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Using map
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `map` operator helps us to apply a certain operation to every value of the
    stream, transforming it into a different type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the `map` operator to transform the `Output` of a publisher
    (`int` values) into the `Input` that our subscriber needs (`User` instances):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `map` operator is transforming a stream of `Int` values [`1,2,3,4`] into
    a stream of `User` instances. When we use the `sink`, we can call the `description()`
    method of those users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Using map to transform outputs on the stream'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.5_B14717.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – Using map to transform outputs on the stream
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The previous figure represents how `map` changes the **Output** type (while
    the **Failure** type, in this case, keeps being the same). When working with Combine,
    using this kind of graph (on a document or just in your mind) can be really helpful
    to work with the proper types at every step of the stream.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: There are more operators available rather than just `filter` and `map`. Let's
    see other useful ones like `reduce`, `scan`, `combineLatest`, `merge`, and `zip`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Using reduce
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `reduce` operator returns the result of combining all the values of the
    stream using a given operation to apply.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try out the following examples in an Xcode playground. Go ahead and
    check this example of `reduce`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you execute this code, the output in the console is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you have used the regular `reduce` function from the Swift standard library,
    the `reduce` version from Combine should be easy to understand. It works the same
    but using values that come from a publisher. What `reduce` does is apply an operation
    and accumulate the result for the next value, starting with a given value. In
    our example, `1, { $0 * $1 }`, the first param is the initial value, hence `1`,
    and the following param is the operation to perform: multiply the current value
    (stored as `$0`) by the next incoming value (`$1`), and keep it for the next iteration.
    So, if our input is `[1,2,3,4]` and our starting value is `1`, what `reduce` is
    doing is *1 x 1 x 2 x 3 x 4 = 24*. The next operator that we are going to explain
    is very similar to reduce. Let''s jump into `scan`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Using scan
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An operator very much related to `reduce` is `scan`. The `scan` operator does
    exactly the same as `reduce` but it emits the result at each step. Check this
    code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, executing this will result in the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, it is giving us the same final result as `reduce` (`scan` emits
    a value in each step, not just at the end. So, with `scan`, we get the following
    values over time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 1x1 = **1**
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x2 = **2**
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2x3 = **6**
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6x4 = **24**
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These operators (`filter`, `map`, `reduce`, and `scan`) helped us to transform
    the values coming from another publisher. But some operators combine multiple
    publishers'' input into one single stream output. Let''s see some of them: `combineLatest`,
    `merge`, and `zip`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Using combineLatest
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a publisher that combines the latest values from two other publishers.
    Both publishers must have the same failure type. The downstream subscriber will
    receive a tuple of the most recent elements from the upstream publishers when
    any of them emit a new value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following code in a playground:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output on the console is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how we don't have any output until `("a", 1).`, which means that `combineLatest`
    doesn't produce any output until all the inputs send an initial value. After that,
    it will produce a value every time an input sends a new value, sending the latest
    from each of the inputs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also other versions of `combineLatest` to combine three or even four
    inputs, instead of just two: `combineLatest3`, `combineLatest4`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: What if we only want to have the latest output of any of the input publishers
    (meaning just a value, not a tuple)? For those cases, we can use `merge`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Using merge
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `merge`, we will aggregate multiple input publishers into a single stream,
    and the output will be just the latest value from any of them. Check out this
    code in a playground:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will be as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the output is one value at a time, which differs from the tuple
    with all the latest values from all the inputs that we got with `combineLatest`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: There is another useful method to work with multiple publishers. Let's see what
    `zip` can do.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Using zip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`zip` is a publisher that emits a pair of elements when both input publishers
    have emitted a new value. Let''s see how it differs from `combineLatest` with
    the same example. Execute the following code in a playground:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Check out the comments under each line, representing what `combineLatest` and
    `zip` will output every given time. Notice how `zip` doesn't send a new pair of
    values downstream until both of the publishers have emitted a new value. And when
    that happens, it will send a tuple with the oldest non-emitted values of both
    of them. `CombineLatest` will use the most recent and will emit a tuple every
    time one of the publishers emits a single new value (it will not wait to have
    both publishers emitting!). That is the main difference.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'With the basics about publisher, subscriber, and operator entities explained,
    let''s see another useful entity in Combine in the next section: **Subject**.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Subject
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As per the Apple documentation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '"A subject is a publisher that exposes a method for outside callers to publish
    elements."'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The definition is pretty straightforward. Subjects are like publishers, but
    they have a method, `send(_:)`, which you can use to inject new elements into
    their stream. A single `Subject` allows multiple subscribers to be connected at
    the same time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of built-in subjects: `CurrentValueSubject` and `PassthroughSubject`.
    Let''s see the differences between them.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Working with CurrentValueSubject
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a subject that holds an initial value. It broadcasts the current value
    every time it changes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'When a subscriber connects to a `CurrentValueSubject`, it will receive the
    current value, and the next ones when it changes. This means that a `CurrentValueSubject`
    has state. Here is an example (you can try this code in a playground):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you execute this code, the output looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are the interesting bits:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: When we initialize the subject, we need to pass an initial value.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the subscriber subscribes, it gets the current value that is held in the
    subject. Note how in the console output, the subscriber has printed `first value`
    even though we subscribed to the subject after that value was generated.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time we call `send(_:)`, the subscribers get the next value.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's see the other built-in type of subject, `PassthroughSubject`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Working with PassthroughSubject
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main difference between `PassthroughSubject` and `CurrentValueSubject`
    is that `PassthroughSubject` doesn''t hold any state. Check the following code
    (you can try it out in a playground):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you execute this code, here is the output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how the subscriber is created after the first value is sent. This first
    value is not received, because there was no subscriber connected yet. However,
    the second value is displayed in the output because it was sent after the subscription
    was established.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the basic usage of `Publisher`, `Subscriber`, `Operator`, and `Subject`.
    Let's now create a bigger and more complex example to see how to apply Combine
    concepts to real-world apps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Combining Publishers, Subscribers, and Operators
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to mix the concepts of the previous section altogether
    in a real-world example feature. Let''s assume that we have an app that contains
    a newsletter, and we allow the users to subscribe to the newsletter by entering
    their email address, using two `UITextFields`: the **Email** and **Repeat Email**
    fields. Let''s assume that in our business logic, we need to check that the email
    is correct, and we are going to do the following checks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Local check: We will ask users to repeat the email address twice, and both
    should be the same.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local check: The email should contain an "@".'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local check: The email should be five characters long, at least.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remote check: We will also assume that we have a remote method to check in
    the backend that the email is unique, meaning it doesn''t exist yet.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all these conditions match, we will enable a `UITextfield` to repeat it.
    You will also see a `combineLatest`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ViewController.swift` file. You will notice a couple of vars that
    are tagged with the property wrapper `@Published`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What `@Published` is doing here is creating a Publisher from the property itself.
    So, every time `initialEmail` or `repeatedEmail` values change, they will get
    published to anyone subscribed to them. You can access the publisher of `initialEmail`
    by using `$initialEmail` (prefix a `$` to the property name). Notice the two `IBActions`
    defined in the same class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By combining `IBAction` and `@Published`, we are creating a funnel in which
    every time the user types something in the `initialEmail` `UITextField`, it will
    get published through the `$initialEmail` publisher.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this handy? Remember that according to the business logic defined above,
    we need to ensure that both `initialEmail` and `repeatedEmail` are equal. Now
    we have two publishers that will emit their value every time the user types in
    either of the two text fields. How can we combine those two values to compare
    them? The Combine framework has the perfect method for this: `CombineLatest`.
    Add the following vars to the `ViewController.swift` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s analyze the code comment by comment:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are using `Publishers.CombineLatest` to combine two different publishers
    into one: `$initialEmail` and `$repeatedEmail`. This will result in a new stream
    (publisher) of type `Publishers.CombineLatest<Published<String>.Publisher, Published<String>.Publisher>`.
    Don''t let the long type scare you. It means "a publisher of two string publishers."
    The magic of `CombineLatest` is that if either of the two inputs changes, you
    will get the new value, but also the latest value that the other input had, which
    is very useful for cases like this.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Second, we are applying the `map` operator over the "publisher of two string
    publishers." By using `map`, we are unwrapping the underlaying published strings
    to be able to use the string themselves and return a different result after working
    with them. Here is where we apply our business rules: If both emails are equal,
    they include an "@" and they are longer than five characters long, we return the
    `email`. Otherwise, we return `nil`. So, with `map`, we are transforming a stream
    output type into a new one, to adapt it to what we need.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, if we inspect the type of what we have, you will see this: `Publishers.Map<Publishers.CombineLatest<Published<String>.Publisher,
    Published<String>.Publisher>, String?>`. That is quite complex to read and use.
    But Combine provides us with a way to simplify this, because what is important
    is what is inside of the publisher itself, not all the wrappers around it. By
    using `eraseToAnyPublisher`, we are changing this type to just `AnyPublisher<String?,
    Never>`. This is much easier to understand and use (and if you want to publish
    it in an API, for example, it''s much easier to digest by other developers).'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a cancellable property var to use it in the following piece of code.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This flow can be represented as follows
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – validatedEmail stream'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.6_B14717.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – validatedEmail stream
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this line of code to the `viewDidLoad()` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By calling `sink`, we are attaching a subscriber to the `validatedEmail` publisher,
    and we store it in our new `var` property `cancellable`. Every time we receive
    a new value, we will just print it into the console for testing purposes. Let's
    try it out! Execute the app and type any email address (in both fields) that fulfills
    all the conditions (for example, `abc@email.com`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: When you type valid addresses, you will see it in the console. When the addresses
    are not valid, you will see `nil`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen a lot of new Combine concepts packed into very little code. Before
    continuing with our demo project, we are going to look at a quick summary of these
    new concepts:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Published` property wrapper: Allows us to create a Publisher from a property
    variable. We can access the publisher by prefixing `$` to the name of the property.
    It only works on class properties, not on structs.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publishers.CombineLatest`: Allows us to combine two publishers into a single
    one that will always push the latest value of each one when there is a change
    (or `nil`, if there wasn''t a previous value).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`: Allows us to transform the stream. We apply a `map` to a publisher with
    an `Output` type and we can transform it into a new, different `Output`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eraseToAnyPublisher`: Allows us to erase complex types to work with easier
    `AnyPublisher<Otutput, Failure>` streams. This is very handy when publishing our
    classes as an API, for example.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this little recap, we still have one feature pending to fulfill the list
    of requirements. We have implemented three local checks on the email addresses,
    but we still need to do the last one, which was this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Remote check: We will also assume that we have a remote method to check in
    the backend that the email is unique, meaning it doesn''t exist yet.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `ViewController.swift` file, there is a dummy method named `func emailAvailable(…)`.
    It just returns a completion block. This method is intended to represent a network
    call that returns `True` or `False` in the completion block according to whether
    the email already exists in the backend or not. For demo purposes, we are not
    going to implement the network call itself, just simulate the result.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this feature with Combine. We are going to create a new publisher
    that will emit a Bool indicating whether the email that the user types exists
    in the backend or not, using a fake network call, `emailAvailable(…)`. Add the
    following code to the `ViewController.swift` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are a lot of new concepts here, so let''s go through the numbered comments
    one by one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: We are defining a new publisher, `isNewEmail`, of type `<Bool, Never>`. This
    publisher will help us to emit events that indicate whether the email that the
    user is typing exists in our database or not.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fetch any new value that the user types in the email field, we start by using
    the published property defined earlier in the `$initialEmail` section.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Users can type/delete in text fields pretty fast. Our goal is to make a network
    call every time we receive a new value through the `$initialEmail` publisher (meaning
    every time the user is typing in the email field). That means that we will query
    the network a bit too much. The Combine `.debounce` method will help us to reduce
    the number of values we are processing. By using `.debounce`(`1…)`, we specify
    that from all the values that we get from `$initialEmail`, we will only process
    a value every `1` second. The rest of the values will be discarded. This is very
    helpful when working with publishers that are connected to the user interface
    and the network (text fields, buttons, search bars, and so on).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another useful method is `removeDuplicates()`. If the user types "`abc`" and
    then deletes the "`c`" to quickly type the "`c`" back, we will make several calls.
    But if we use `removeDuplicates()`, we will avoid this unnecessary behavior.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fifth step is a bit more complicated. This is where we perform a network
    call. First, we have a `.flatMap` wrapping everything. This function transforms
    elements from a publisher into a new type of publisher. Inside the `flatMap`,
    we have a `Future`. A `Future` is a publisher that eventually emits a single value
    and then finishes (or fails). Inside the `Future`, we have a `Promise`: A `Promise`
    in Combine is a `typealias` for a closure that takes a `Result`. Now let''s describe
    the whole process again, but from inside out: The network call `emailAvailable`
    returns a result in the form of `promise.success(…)`. This Promise is wrapped
    in a Future, to become a publisher stream. That stream is a `Future<Bool, Never>`
    at this point. Now, we wrap everything with `flatMap`, so the upstream `initialEmail:
    Published<String>.Publisher` becomes `AnyPublisher<Bool, Never>` (with the help
    of `eraseToAnyPublisher` too).'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the full flow to generate `isNewEmail`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – isNewEmail stream'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.7_B14717.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – isNewEmail stream
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: So, after all this chain of transformations, we have a publisher, `isNewEmail`,
    that will emit a `Bool` indicating whether an email address is unique or not in
    our backend every time (almost, except duplicates and debounced) the user types
    in the UI! That is pretty cool! And it's very useful for our business logic checks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last step is going to be to combine the publisher of the local checks (`validatedEmail`)
    with the remote publisher (`isNewEmail`) to have a final output. The business
    logic required to enable the `String` and a `True` value, so all our conditions
    are met. What is the best way to combine the latest values of two different publishers
    and work with them? We just used it above! It is `combineLatest`. Add the following
    code to the `ViewController.swift` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As detailed in the preceding code, we are using `CombineLatest` to work with
    the latest values of two different publishers. From `validatedEmail`, we get a
    valid email or a `nil` value otherwise. From `isNewEmail`, we get a `Bool` indicating
    whether the email exists in the database or not. The result of this is a new publisher,
    `finalEmail`, of type `<String?, Never>`. See the flow in the next figure:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – finalEmail stream'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.8_B14717.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – finalEmail stream
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how can we enable and disable the `viewDidLoad` function and let''s explain
    it in detail:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this code, we start with the `finalEmail` publisher `(<String?, Never>`),
    we `map` over it, transforming the stream into `<Bool, Never>`, then we apply
    `.receive` to make sure we are executing this in the main thread (because we are
    handling the UI here, a `UIButton`). Finally, we assign the value inside the stream
    `(<Bool>`) to the `signupButton` `isEnabled` property! Check out the next figure,
    which details the steps of the stream:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Assigning finalEmail to signUpButton'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.9_B14717.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – Assigning finalEmail to signUpButton
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is it[! Execute th](mailto:abc@email.com)e app, and try it yourself:
    If you type some email address that matches all the conditions (like `abc@email.com`),
    the **Sign-up** button will be enabled. Otherwise, it will be disabled.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about a lot of new Combine concepts and methods
    to combine different streams, transform outputs, modify the thread we are working
    on, handle user input, and so on. We used `flatMap` to transform elements of an
    upstream into a different type downstream. However, `flatMap` has more uses. One
    of them is to help streams recover from errors, with the help of `catch`. In the
    next section, we are going to see an example of how a stream can fail, and how
    to recover it using `flatMap` and `catch`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Using Operators to build error-proof streams
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, go ahead and open the project in the code bundle named `PublishersAndSubscribers_start`.
    Take a look at the file `ViewController.swift`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'This file contains a `User` struct:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `User` struct is quite simple. It contains a `String` property `id`, and
    a `static var` named `unknown` that returns a `User` instance with `id` equal
    to `-1`. Apart from the `User` struct, the file contains the `ViewController`
    itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The view controller contains two methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `postNotification()`: This just fires a notification in the Notification
    Center that contains a `User` instance with `id` equal to `123`. The name of the
    notification is `networkResult`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, `postNotificationThatFails()`: This just fires a notification in the
    Notification Center that contains random data that is Base-64 encoded, not a `User`
    instance this time. The name of the notification is `networkResult.`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use Combine to consume these two notifications. Both methods represent
    a dummy network call, whose result is being sent through the Notification Center
    in this way. So, think of them as the network call response that you will fetch
    from your backend when trying to query for some object (a user in this case) and
    propagate to your app with notifications.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to call `postNotification()` and consume the result using Combine.
    In the `viewDidLoad()` method, call `postNotification()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s create a publisher that emits values from the Notification Center
    and use the `cancellable` property to consume them as a subscriber. Change the
    `viewDidLoad()` method to this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s review the comments by lines:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: First, we are creating a publisher that emits any value from the Notification
    Center that arrives under the name `networkResult.` This matches the notification
    name we are sending in the `postNotification()` method.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are subscribing to the publisher created in the previous step, and we store
    the result in the `cancellable` property. We are using `sink` when creating the
    subscriber to define a completion block that will print to the console any value
    received.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we post a notification.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you execute this code and you check in the console, you should see this
    result:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This means that our stream worked! We have sent a notification, our publisher
    has forwarded it, and our subscriber has printed it into the console. As you can
    see on the console output, the notification has three properties: `name`, `object`,
    and `userInfo`. We want to unwrap what is inside the `object` attribute. So, let''s
    modify our publisher with an operator to transform what our subscriber receives.
    Change the publisher code for this one:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Execute it and check the output in the console:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this code, we are mapping over the notification value and sending the `object`
    content as `Data`. In the console output, you can see that our subscriber is receiving
    those bytes of data now, instead of the full notification. Great! The next step
    is going to be to transform these bytes of `Data` into a `User` instance. To do
    that, we need to decode the data. Combine has the perfect helper method for this.
    Change the publisher code to this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'By adding the preceding highlighted line, we are using the `Data` from the
    `map` operation and decoding it into a `User` instance! All in a single line.
    But if you try to execute now, you will get a compile error in the subscriber
    `sink` line saying the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This means: If you inspect the method sink that we are using, you will discover
    that it requires the `Failure` type of the publisher that is consuming to be `Never`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After adding the `decode` line, our publisher no longer has a `Never` type
    as failure, because `decode` can produce errors. So, the compiler is telling you
    that the types don''t match anymore. We need to do something that catches any
    error produced by `decode` and transforms that into a `Never`-failing operation.
    Combine has another useful operator that can help us in this scenario: `catch`.
    Change the publisher code into this new block:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's explain `catch` in more detail. `catch` will handle any error in the upstream,
    and instead of crashing the app, it will complete/finish the publisher that produced
    the error and replace it with a new publisher (that you must provide in the `return`
    block).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this scenario, if we get an error from the `decode` operation, our notification
    publisher will finish, and it will be replaced by `Just(User.unknown)`. `Just`
    is a publisher that only emits one value and then completes. Check the next figure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Catch replaces the failed stream with a new one'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B14717.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – Catch replaces the failed stream with a new one
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The top part of the previous figure shows the stream when an error happens in
    the `decode` stage and `catch` enters into action. In the bottom part of the figure,
    you can see how `catch` drops the initial publisher and replaces it with the one
    defined in the `catch` block (a `Just` publisher in this case).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out what will happen if we provide a value that will produce an
    error in the `decode` `stage`. At the end of the `viewDidLoad()`, just after `postNotification()`,
    add this line:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, we are now sending two notifications, one with user data inside, and the
    other with a random string. The second should fail on the `decode` step. Execute
    the app; you will see this output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That is great! The first notification got decoded and transformed into a proper
    user. The second failed to be decoded, but our `catch` block recovered the stream
    with a new publisher that passed an unknown `User` struct to the receiver.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a problem with our solution. Add this line after `postNotificationThatFails()`,
    at the end of the `viewDidLoad()` method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So now we are sending three notifications: first a regular one, then one that
    fails, then another regular one. Execute the app and notice the output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What is the issue here? The issue is that we only received two values, even
    though there are three notifications being sent! What is the problem then? The
    problem is that our `catch` block is replacing the failed stream with a `Just`
    publisher. As said before, a `Just` publisher only sends one value and then completes.
    Any value sent after the failure will be lost.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve this solution so we can keep processing values after recovering
    from an error with the `catch` block. Replace the `publisher` block with the following
    one:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding highlighted code, you can see that we have wrapped the `decode`
    and `catch` block in a `flatMap` + `Just` block. Check in the following figure
    the differences before and after the change:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Flow before and after flatMap'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.11_B14717.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – Flow before and after flatMap
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in the new code how, inside the `flatMap`, we are now creating a new
    second flow for every new value with this piece of code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is important because it means that when there is an error, and the `catch`
    replaces the stream with the `Just(User.unknown)` publisher, it will not replace
    the original stream; it will just replace the stream that we are creating for
    this specific element inside the `flatMap`. This means that for the next element
    that arrives from the Notification Center, we still have the main publisher working.
    Execute the app now and see the following results in the console:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That is great! Not only are we handling the errors, we still process new elements
    that arrive after!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have seen how to use `flatMap` and `catch` to make your
    streams error-proof. Let's wrap up the chapter now in the summary.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned about the basics of Combine: what a publisher
    is, what a subscriber is, why we need operators, which ones are more useful, and
    how all these elements chain together to help us.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We have built two different apps to demonstrate how Combine can help in our
    apps, from processing user interface events, decoding, and applying business rules,
    to creating error-proof streams and methods to recover from operations that fail.
    Combine provides us with a lot of built-in functionalities that will make our
    code easy to read and maintain.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了两个不同的应用程序来展示Combine如何帮助我们在应用程序中处理，从处理用户界面事件、解码和应用业务规则，到创建无错误的数据流和从失败的操作中恢复的方法。Combine为我们提供了许多内置功能，这将使我们的代码易于阅读和维护。
- en: 'In the next chapter, we are going to learn about one of the new features of
    iOS 14: App Clips.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习iOS 14的一个新特性：应用快照。
