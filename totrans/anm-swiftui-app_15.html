<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-208"><a id="_idTextAnchor219"/>15</h1>
<h1 id="_idParaDest-209"><a id="_idTextAnchor220"/>Integrating SpriteKit into Your SwiftUI Projects</h1>
<p>In this chapter, we will dive deeper into the world of animation in SwiftUI and create some mini-projects, highlighting different animations that can be made using other techniques and the SpriteKit framework. Some of the animations will be simpler, some will be more complex, and some will be dynamic and interactive animations too.</p>
<p>You will learn how to take advantage of the power of <strong class="bold">SpriteKit</strong> and <strong class="bold">particle emitters</strong>. SpriteKit is a game<a id="_idIndexMarker840"/> development framework<a id="_idIndexMarker841"/> that provides a convenient and efficient way to create 2D games for iOS and macOS platforms. Particle emitters, on the other hand, are powerful tools in the SpriteKit framework that allow you to create special effects such as fire, smoke, rain, wind, explosions, and more. These emitters will bring life to your apps, making them visually stunning and engaging for users.</p>
<p>So, here are the topics we will cover in this final chapter:</p>
<ul>
<li>Animating pipe smoke</li>
<li>Animating coffee steam</li>
<li>Animating rocket fire</li>
<li>Animating a blizzard</li>
<li>Animating rain</li>
<li>Animating a magic wand</li>
</ul>
<h1 id="_idParaDest-210"><a id="_idTextAnchor221"/>Technical requirements</h1>
<p>You can find the completed projects and their code in the <code>Chapter 15</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor222"/>Animating pipe smoke</h1>
<p>In this project, we will create<a id="_idIndexMarker842"/> a smoke effect using SpriteKit’s <strong class="bold">Smoke</strong> template, and make it come out of an image of a pipe. This is a good first project, as it’s not too complicated<a id="_idIndexMarker843"/> and gets you familiar with creating the needed <strong class="bold">SpriteKit Scene</strong> (<strong class="bold">SKS</strong>) particle file and how to configure it. </p>
<p>Let’s get started, first create a new SwiftUI project, and call it <code>Pipe Smoke</code>. We are going to need a couple of images for this project so you can grab them over at GitHub (<code>Chapter 15</code> | <code>Pipe Smoke</code>) and add them to the project’s Assets catalog. Now it’s time to create a SpriteKit particle file.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor223"/>Creating a SpriteKit particle file</h2>
<p>Next, let’s create<a id="_idIndexMarker844"/> a new file; this will be a SpriteKit<a id="_idIndexMarker845"/> particle file. The <strong class="bold">SpriteKit Scene</strong> (<strong class="bold">SKS</strong>) <strong class="bold">particle file</strong> is a scene file that has information about the particle system it contains, such as the shape, size, and position of the particle emitter, as well as the type of particles that will be emitted, their behavior, and movements.</p>
<p>To create an SKS particle file, in Xcode, you simply need to go to <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">File</strong> | <strong class="bold">SpriteKit Particle File</strong>, or press <em class="italic">Command + N</em> to bring up the template options, and scroll down until you come to a template called <strong class="bold">SpriteKit Particle File</strong>. </p>
<p>Now, we need to choose the type of template we want. There are several options and we’re going to explore them individually in separate projects, but the one we want now is <strong class="bold">Smoke</strong>:</p>
<div><div><img alt="Figure 15.1: Particle template options " src="img/B18674_15_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1: Particle template options</p>
<p>Once you click <code>Smoke</code>, choose a save<a id="_idIndexMarker846"/> location, and then click <strong class="bold">Create</strong>:</p>
<div><div><img alt="Figure 15.2: Creating the Smoke.sks file " src="img/B18674_15_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2: Creating the Smoke.sks file</p>
<p>Now, you will see a new<a id="_idIndexMarker847"/> particle file in your Xcode editor that has a smoke animation playing. That’s because we chose the <strong class="bold">Smoke</strong> template, so the particles are pre-configured to produce smoke. This smoke will need to be adjusted so it’s not as wide and thick. We want the effect to be thin and small enough that we can make it come out of a pipe.</p>
<p>To configure the smoke, go to the right side of Xcode and you’ll see four buttons; if you click on the fourth button, you open up the <strong class="bold">Attributes</strong> panel, which is where we can configure our particle file to create an infinite number of effects:</p>
<div><div><img alt="Figure 15.3: Xcode’s Attributes panel " src="img/B18674_15_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3: Xcode’s Attributes panel</p>
<p>There are quite a few settings<a id="_idIndexMarker848"/> in this panel, and since we will be creating different particle files in this chapter, it’s a good idea to have an understanding of what each field does. So, I will explain each field in order for you to create this first project in the chapter, and you can use these definitions for reference as you continue working through the other projects.</p>
<h3>Name</h3>
<p>The <strong class="bold">Name</strong> field is used to give a unique<a id="_idIndexMarker849"/> identifier to the particle emitter so that you can easily reference it within your code or in the editor. The field is a string value that you can set to anything you like, as long as it’s unique within the file. By giving your particle emitters descriptive names, they will act as a reminder of what they do and how they’re used in your project. </p>
<p>Additionally, you can use the <strong class="bold">Name</strong> field to access the particle emitter and modify its properties programmatically in your code.</p>
<h3>Background</h3>
<p>The <strong class="bold">Background</strong> field lets you set the background<a id="_idIndexMarker850"/> color of the editor. Sometimes, it’s useful to adjust this color to help make the particles stand out more.</p>
<h3>Texture</h3>
<p>The <strong class="bold">Texture</strong> field is used to specify the image file<a id="_idIndexMarker851"/> that will be used as the particle texture. The particle texture is essentially the appearance of the particles, and you can use any image file you like to create a wide range of particle effects. For example, you could use a simple dot or circle image for a simple particle effect, or a more complex image with multiple shapes and colors for a more elaborate effect. When you specify a particle texture in the <strong class="bold">Attributes</strong> panel, it will be used for all of the particles in the particle emitter. </p>
<h3>Emitter</h3>
<p><strong class="bold">Emitter</strong> is the object that defines the characteristics<a id="_idIndexMarker852"/> of a particle, such as its initial position, speed, and lifetime.</p>
<p>The <strong class="bold">Emitter Birthrate</strong> field specifies the number of particles that are emitted per second. It determines how quickly the particles will be generated by the emitter – a higher birthrate will result in more particles being emitted in a shorter amount of time, while a lower birthrate will result in fewer particles being emitted over a longer period of time.</p>
<p>The <strong class="bold">Emitter Maximum</strong> field sets the maximum number of particles that can exist at one time in the particle system. If <strong class="bold">Birthrate</strong> is set to a high value and <strong class="bold">Maximum</strong> is set to a low value, the emitter will emit particles at the specified rate until the maximum limit is reached. Once the maximum number of particles has been reached, the emitter will stop emitting new particles until some of the existing particles have disappeared. This allows you to control the overall<a id="_idIndexMarker853"/> number of particles in your particle system and optimize performance.</p>
<h3>Lifetime</h3>
<p>The <strong class="bold">Lifetime</strong> fields specify the amount of time that each particle<a id="_idIndexMarker854"/> in a particle system will be active before it disappears. </p>
<p>The <strong class="bold">Lifetime Start</strong> field specifies the length of time for which each particle will exist in the particle system. It determines how long each particle will stay visible in the scene before disappearing. A higher value will result in particles staying visible for a longer period of time, while a lower value will result in particles disappearing more quickly.</p>
<p>The <strong class="bold">Lifetime Range</strong> field sets the range of values that the <strong class="bold">Lifetime</strong> property can take. Instead of specifying a fixed value for the lifetime, you can specify a range of values, and the particle system will randomly choose a value from that range for each particle that is emitted. This allows you to add variation to your particle system, making it look more organic and natural. For example, if you set <strong class="bold">Lifetime Start</strong> to <strong class="bold">1.0</strong> and <strong class="bold">Lifetime Range</strong> to <strong class="bold">0.5</strong>, each particle’s lifetime will be a random value between 0.5 and 1.5 seconds.</p>
<h3>Position Range</h3>
<p>The <strong class="bold">Position Range</strong> fields specify the range of values<a id="_idIndexMarker855"/> for the initial position of the particles in each dimension – <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong> – allowing you to create particle systems that emit particles from a random position within a defined area. The particle system will randomly choose a position from within the specified range for each particle that is emitted, which can help add variety and realism to your particle<a id="_idIndexMarker856"/> systems.</p>
<h3>Angle</h3>
<p>The <strong class="bold">Angle</strong> fields in an SKS particle file control<a id="_idIndexMarker857"/> the initial direction and spread of particles when they are emitted. <strong class="bold">Angle Start</strong> sets the starting direction of the particles, while <strong class="bold">Angle Range</strong> determines the range of possible directions; the system then randomly chooses an angle within the range for each particle emitted. <strong class="bold">Angle Start</strong> is measured in degrees, with 0 degrees pointing to the right, and <strong class="bold">Angle Range</strong> specifies the spread of angles in a counterclockwise direction, again measured in degrees.</p>
<h3>Speed</h3>
<p>The <strong class="bold">Speed</strong> fields control the initial speed<a id="_idIndexMarker858"/> and variation of particles when emitted in an SKS particle file. <strong class="bold">Speed Start</strong> sets the starting speed, while <strong class="bold">Speed Range</strong> specifies the possible range of speeds; a random speed is then chosen within the specified range for each emitted particle. </p>
<p>Adjusting these fields allows you to create various particle effects, with a higher value resulting in faster particles and a lower value in slower particles. For example, setting <strong class="bold">Speed Start</strong> to <strong class="bold">100</strong> and <strong class="bold">Speed Range</strong> to <strong class="bold">0</strong> will emit particles at a constant speed, while setting <strong class="bold">Speed Start</strong> to <strong class="bold">50</strong> and <strong class="bold">Speed Range</strong> to <strong class="bold">25</strong> will create particles with varying speeds between 25 and 75. These values are generally understood to be points per second.</p>
<h3>Acceleration</h3>
<p>The <strong class="bold">Acceleration X</strong> and <strong class="bold">Acceleration Y</strong> fields control the acceleration<a id="_idIndexMarker859"/> of the particles in the <em class="italic">x</em> and <em class="italic">y</em> directions respectively. For example, you could set <strong class="bold">Acceleration X</strong> to <strong class="bold">0</strong> and <strong class="bold">Acceleration Y</strong> to <strong class="bold">-100</strong> to create a particle system that is affected by gravity, causing the particles to fall downward. Alternatively, you could set <strong class="bold">Acceleration X</strong> to <strong class="bold">50</strong> and <strong class="bold">Acceleration Y</strong> to <strong class="bold">0</strong> to create a particle system that moves to the right at a constant rate. </p>
<p>The <strong class="bold">Acceleration X</strong> and <strong class="bold">Acceleration Y</strong> fields are specified in points per second squared; positive values will cause the particles to accelerate in the positive direction, while negative values will cause the particles<a id="_idIndexMarker860"/> to decelerate or accelerate in the opposite direction. </p>
<h3>Alpha</h3>
<p><code>.sks</code> file refers to the opacity or transparency<a id="_idIndexMarker861"/> of particles in a particle system. The alpha value controls how much of the particle is visible, with a higher value making the particle more visible and a lower value making the particle more transparent.</p>
<p>The <strong class="bold">Alpha Start</strong> field specifies the starting alpha value for the particles, which can be used to control their initial transparency. The <strong class="bold">Alpha Range</strong> field specifies the range of possible alpha values that the particles can take, and when the particle emitter emits a particle, it will choose a random alpha value within the specified range. The <strong class="bold">Alpha Speed</strong> field specifies the rate at which the alpha value of the particles will change over time, and can be used to control the rate of fade-in or fade-out of the particles; a positive value for this field will cause the particles to fade in over time, while a negative value will cause the particles to fade out over time. </p>
<p>By adjusting the <strong class="bold">Alpha Start</strong>, <strong class="bold">Alpha Range</strong>, and <strong class="bold">Alpha Speed</strong> fields, you can control the transparency of the particles over their lifetime and create a wide range of particle effects. For example, you could set <strong class="bold">Alpha Start</strong> to <strong class="bold">1</strong> and <strong class="bold">Alpha Range</strong> to <strong class="bold">0</strong> to emit particles with a constant alpha value or set <strong class="bold">Alpha Start</strong> to <strong class="bold">1</strong>, <strong class="bold">Alpha Range</strong> to <strong class="bold">0</strong>, and <strong class="bold">Alpha Speed</strong> to <strong class="bold">-0.5</strong> to emit particles that fade out over time.</p>
<h3>Scale</h3>
<p>The <strong class="bold">Scale</strong> fields control the size <a id="_idIndexMarker862"/>of the particles over their lifetime. The <strong class="bold">Scale Start</strong> field specifies the starting size of the particles, which can be used to control their initial size. The <strong class="bold">Scale Range</strong> field specifies the range of possible sizes that the particles can take, and when the particle emitter emits a particle, it will choose a random size within the specified range. The <strong class="bold">Scale Speed</strong> field specifies the rate at which the size of the particles will change over time, and can be used to control the rate of growth or shrinkage of the particles; a positive value for this will cause the particles to grow over time, while a negative value will cause the particles to shrink over time. </p>
<p>As an example of using <strong class="bold">Scale</strong>, you could set <strong class="bold">Scale Start</strong> to <strong class="bold">1</strong> and <strong class="bold">Scale Range</strong> to <strong class="bold">0</strong> to emit particles with a constant size or set <strong class="bold">Scale Start</strong> to <strong class="bold">1</strong>, <strong class="bold">Scale Range</strong> to <strong class="bold">0.5</strong>, and <strong class="bold">Scale Speed</strong> to <strong class="bold">0.1</strong> to emit particles<a id="_idIndexMarker863"/> that grow over time.</p>
<h3>Rotation</h3>
<p>The <strong class="bold">Rotation Start</strong> field specifies the starting<a id="_idIndexMarker864"/> rotation of the particles, which can be used to control their initial orientation. The <strong class="bold">Rotation Range</strong> field specifies the range of possible rotations that the particles can take, and when the particle emitter emits a particle, it will choose a random rotation within the specified range. The <strong class="bold">Rotation Speed</strong> field specifies the rate at which the rotation of the particles will change over time, and can be used to control the rate of rotation of the particles; a positive value will cause the particles to rotate clockwise, while a negative value will cause the particles to rotate counterclockwise.</p>
<p>You could set <strong class="bold">Rotation Start</strong> to <strong class="bold">0</strong> and <strong class="bold">Rotation Range</strong> to <strong class="bold">0</strong> to emit particles with a constant orientation or set <strong class="bold">Rotation Start</strong> to <strong class="bold">0</strong>, <strong class="bold">Rotation Range</strong> to <strong class="bold">180</strong>, and <strong class="bold">Rotation Speed</strong> to <strong class="bold">180</strong> to emit particles that rotate rapidly over time.</p>
<h3>Color Blend</h3>
<p>The <strong class="bold">Color Blend</strong> fields control the color of the particles<a id="_idIndexMarker865"/> over their lifetime.</p>
<p>The <strong class="bold">Color Blend Factor</strong> field specifies the amount of color blending that will be applied to the particles. When the particle emitter emits a particle, it will choose a random color blend factor within the specified range. The particle’s color will be blended with the color of the particle’s texture according to this blend factor.</p>
<p>The <strong class="bold">Color Blend Factor Range</strong> field specifies the range of possible color blend factors that the particles can take. A value of <strong class="bold">0</strong> will result in no color blending, while a value of <strong class="bold">1</strong> will result in full color blending. </p>
<p>The <strong class="bold">Color Blend Factor Speed</strong> field specifies the rate at which the color blend factor of the particles will change over time, and can be used to control the rate at which the particles’ color will change. A positive value for the <strong class="bold">Color Blend Factor Speed</strong> field will cause the color of the particles to change over time, while a negative value will cause the color of the particles to change in reverse. </p>
<p>Looking an example, you could set <strong class="bold">Color Blend Factor</strong> to <strong class="bold">0</strong>, <strong class="bold">Color Blend Factor Range</strong> to <strong class="bold">0</strong>, and <strong class="bold">Color Blend Factor Speed</strong> to <strong class="bold">0</strong> to emit particles with constant color, or set <strong class="bold">Color Blend Factor</strong> to <strong class="bold">1</strong>, <strong class="bold">Color Blend Factor Range</strong> to <strong class="bold">1</strong>, and <strong class="bold">Color Blend Factor Speed</strong> to <strong class="bold">0.1</strong> to emit particles<a id="_idIndexMarker866"/> that change color rapidly over time.</p>
<h3>Color Ramp</h3>
<p>The <strong class="bold">Color Ramp</strong> field is used to specify a range of colors<a id="_idIndexMarker867"/> that particles can take on over their lifetime. The colors are defined using a ramp, which is a gradient that blends two or more colors.</p>
<p><strong class="bold">Color Ramp</strong> allows you to create particle effects with changing colors. By default, particles will be emitted with a single color, but by adjusting <strong class="bold">Color Ramp</strong>, you can set the particles to a fixed range of colors, change color over time, or randomize the color within a range. For example, you could set <strong class="bold">Color Ramp</strong> to shades of red and yellow to create a fire effect or shades of blue and white for a snow effect.</p>
<p>Additionally, <strong class="bold">Color Ramp</strong> can be used to create different blending modes, such as additive or subtractive blending. The blending mode determines how the colors of the particles are combined with the colors of the background or other particles in the scene.</p>
<h3>Blend Mode</h3>
<p>Blending is a process that combines<a id="_idIndexMarker868"/> the colors of the particles with the colors of the objects behind them on the screen. The <strong class="bold">Blend Mode</strong> field determines how the colors of the particles and the background will be combined. </p>
<p>There are several blend modes available in SpriteKit, the choice of which depends on the desired visual effect for the particles. For example, the <strong class="bold">Alpha</strong> blend mode will blend the colors of the particles and the background by taking the alpha channel of the particle’s color into account. The <strong class="bold">Add</strong> blend mode will add the colors of the particles and the background together. The <strong class="bold">Multiply</strong> blend mode will multiply the colors of the particles and the background together. </p>
<p>By adjusting the blend mode, you can control how the colors of the particles are blended with the colors of the objects behind them and create a wide range of particle effects. </p>
<h3>Field Mask</h3>
<p><strong class="bold">Field Mask</strong> takes an integer value that<a id="_idIndexMarker869"/> is used to specify a masking bit-field, and the bit-field defines which properties of the particle are affected by the mask. For example, if the bit-field includes the position bit, the mask will affect the position of the particles. If it includes the color bit, the mask will affect the color of the particles. By setting the value of <strong class="bold">Field Mask</strong>, you can control which properties of the particles are affected by the mask. This allows you to create complex and sophisticated particle effects.</p>
<p>For example, you could set <strong class="bold">Field Mask</strong> to include the position bit, which would cause the mask to affect the position of the particles, and create particles that follow a specific path or shape. Otherwise, you could set <strong class="bold">Field Mask</strong> to include the color bit, which would cause the mask to affect the color of the particles, and create particles with a specific color scheme or pattern.</p>
<h3>Custom Shader</h3>
<p>The <strong class="bold">Custom Shader</strong> field allows you to specify a custom shader<a id="_idIndexMarker870"/> to be used to render the particles. </p>
<p>A <strong class="bold">shader</strong> is a program that runs on the GPU<a id="_idIndexMarker871"/> and is used to define the appearance and behavior of the particles. By using a custom shader, you can create complex and sophisticated particle effects that would be difficult or impossible to achieve using the built-in properties of the particle emitter.</p>
<p>For example, you could use a custom shader to create particles that respond to changes in the environment, such as light or shadows, or create particles that change shape or appearance over time. To use one, you need<a id="_idIndexMarker872"/> to write the shader code in a language such as <strong class="bold">OpenGL Shading Language</strong> (<strong class="bold">GLSL</strong>) and then specify the shader code as the value of the <strong class="bold">Custom Shader</strong> field. Once you have specified the custom shader, SpriteKit will use it to render the particles, giving you complete control over the appearance and behavior of the particles. By combining custom shaders with other properties of the particle emitter, such as <strong class="bold">Birthrate</strong>, <strong class="bold">Lifetime</strong>, and <strong class="bold">Position Range</strong>, you can create a wide range of sophisticated and visually stunning particle effects.</p>
<p>Now, we have looked at all of the customization fields for the particle system. I know it can be a bit overwhelming, which is why I defined each field in the file so you can refer to it when you’re building your particle system.</p>
<p>Let’s use the following values<a id="_idIndexMarker873"/> to alter the smoke so it is similar to the smoke that you would see coming from a pipe. I have worked out all the values; you just need to fill them in:</p>
<div><div><img alt="Figure 15.4: Attributes for the pipe smoke animation " src="img/B18674_15_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4: Attributes for the pipe smoke animation</p>
<p>Make sure your file has those same values as well before proceeding, which will give you the correct smoke you need to come out of the pipe.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor224"/>Integrating the Smoke file into a SwiftUI View</h2>
<p>Before we get started<a id="_idIndexMarker874"/> with this<a id="_idIndexMarker875"/> section, a little bit of explanation is needed as to what the SpriteKit framework is all about and how it works. As I mentioned at the beginning of this chapter, SpriteKit is a game development framework that provides a convenient and efficient way to create 2D games for iOS and macOS platforms. Using the SpriteKit framework, you can create different sprites for your animation or game. </p>
<p>A sprite is represented by the <code>SKSpriteNode</code> class, which is a node that can display a textured image. A sprite can be thought of as a single frame of an animation and it can be moved, rotated, and scaled and have physics applied to it. A single sprite can also have multiple textures, allowing it to change appearance. In a game, sprites are used to represent characters, objects, and backgrounds.</p>
<p>You can create a sprite by initializing <code>SKSpriteNode</code> with an image or texture and then adding it to an <code>SKScene</code>. Once added to a scene, a sprite can be manipulated using various properties and methods, such as position, scale, and rotation, and you can also add actions, physics, and gestures to it.</p>
<p><code>SKView</code> is a <code>UIView</code> subclass that is used to display and interact with SpriteKit scenes. It acts as the container for an <code>SKScene</code> and provides the necessary infrastructure for displaying and animating sprites. An <code>SKScene</code> is a container for all the sprites in a SpriteKit-based project. It is responsible for updating and rendering the sprites, and also provides a way to handle user interactions with the sprites. A scene can also contain other nodes such as labels and shapes in addition to sprites. Each scene can have its own set of sprites, physics, and interactions. You will become more familiar with sprites and nodes as we progress through the projects in this chapter.</p>
<p>Let’s do some coding now. Go into <code>ContentView</code>, and we will create a smoke view struct in which we can use our <code>Smoke.sks</code> file. The first thing we need to do is import the SpriteKit framework so that we have access to the classes and methods. Add this line of code at the top of <code>ContentView</code>:</p>
<pre class="source-code">
import SpriteKit</pre>
<p>Now, let’s create that <code>SmokeView</code> struct I mentioned<a id="_idIndexMarker876"/> by adding this under<a id="_idIndexMarker877"/> the <code>ContentView</code> struct:</p>
<pre class="source-code">
struct SmokeView: UIViewRepresentable {
    func makeUIView(context: 
      UIViewRepresentableContext&lt;SmokeView&gt;) -&gt; SKView {
        let view = SKView(frame: CGRect(x: 0, y: 0, width: 
          400, height: 400))
        view.backgroundColor = .clear
        let scene = SKScene(size: CGSize(width: 400, 
          height: 600))
        ///set the scenes background color to clear because 
          we will set the color in the ContentView.
        ///You can also use any other valid color like 
          UIColor.lightGray, UIColor.green, 
          UIColor.init(red: 1, green: 1, blue: 1, alpha: 
          0.5) or any other UIColor initializer.
        scene.backgroundColor = UIColor.clear
        guard let smoke = SKEmitterNode(fileNamed: 
          "Smoke.sks") else { return SKView() }
        smoke.position = CGPoint(x: scene.size.width / 2, 
          y: scene.size.height / 2)
        // set the blend mode - scale - range
        smoke.particleBlendMode = .screen
        smoke.particleScale = 0.01
        smoke.particleScaleRange = 0.05
        ///add the smoke to the scene
        scene.addChild(smoke)
        view.presentScene(scene)
        return view
    }
    func updateUIView(_ uiView: SKView, context: 
      UIViewRepresentableContext&lt;SmokeView&gt;) {
      /// Update the smoke in this function if you need to
    }
}</pre>
<p>Here’s how the <code>SmokeView</code> struct works, line<a id="_idIndexMarker878"/> by line. Bear in mind that the SpriteKit framework<a id="_idIndexMarker879"/> uses methods and classes we have not used before, so the code may seem unfamiliar at first; as you work through the chapter though, you will understand it very quickly because it is Swift code after all, and is very readable:</p>
<ul>
<li>This code starts off by defining a struct named <code>SmokeView</code>, which is used to display the smoke effect that we configured in the <code>Smoke.sks</code> file. The struct conforms to the <code>UIViewRepresentable</code> protocol. This allows the struct to be used as a SwiftUI view.</li>
<li>Next, we add the <code>makeUIView</code> method, which is required by the <code>UIViewRepresentable</code> protocol. It creates and returns <code>SKView</code>, which is used to display the smoke effect.</li>
<li>Then, we create an instance of <code>SKView</code> with a specified frame (size and position). This frame is used to determine the size of the smoke effect.</li>
<li>We set the <code>backgroundColor</code> property of the <code>SKView</code> instance to <code>clear</code>. This means that the background of the view will be transparent and will not have a solid color background; this way, any underlying views or graphics can show through.</li>
<li>We create an instance of <code>SKScene</code> with a specified <code>size</code> property, which determines the size of the smoke effect, and a background <code>color</code> value of <code>clear</code> so that the background of the smoke effect will be transparent.</li>
<li>Next, we create an instance of <code>SKEmitterNode</code> using the particle system defined in the <code>Smoke.sks</code> file. The guard <code>let</code> statement is used to check whether the file was loaded correctly and if not, it returns an empty <code>SKView</code>.</li>
<li>Then, we position the smoke effect in the center of the scene; set the blend mode to <code>SKBlendMode.screen</code>, which will make the smoke blend with the background; set the initial scale of the smoke particles, which will make the particles smaller and thinner; and set the range of the scale of the smoke particles.</li>
<li>The <code>addChild</code> method is called on the <code>scene</code> instance, passing in the <code>smoke</code> node as an argument. This adds the particle emitter node as a child node to the scene, meaning it will be displayed in the scene.</li>
<li>The <code>presentScene</code> method is called on the <code>view</code> instance, passing in the <code>scene</code> instance as an argument. This sets the scene as the currently displayed scene in the view.</li>
<li>Then, the <code>return</code> keyword returns the <code>view</code> instance. </li>
<li>The <code>updateUIView</code> function is called when the view needs to be updated, such as when the view’s state changes. In this code, we leave it empty, as it is not needed in our example.</li>
</ul>
<p>To summarize, the code<a id="_idIndexMarker880"/> creates and returns an <code>SKView</code> instance<a id="_idIndexMarker881"/> that displays a SpriteKit particle emitter as a SwiftUI view. Now, we have a <code>SmokeView</code> ready to go and display the smoke.</p>
<p>Let’s come into <code>ContentView</code> and add a background for the scene, and a smiley image that has a pipe<a id="_idIndexMarker882"/> in his mouth. Then, we will call the <code>SmokeView</code> we just created<a id="_idIndexMarker883"/> to put the smoke into the pipe. To do this, modify <code>ContentView</code> like so:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        ZStack {
            ///adding the pipe image and setting the size 
              and scale to fit on it
            Image("pipe")
                .resizable().frame(width: 350, height: 350)
                .scaledToFit()
            ///calling and positioning the SmokeView
            SmokeView()
            .offset(x: -140, y: 105)
        }.background(Image("background"))
    }
}</pre>
<p>What we have done here is create a <code>ZStack</code> and put our image of the smiley, which is called <code>pipe</code>, into the scene. Then, we resized it with <code>width</code> and <code>height</code> values of <code>350</code> points and called our <code>SmokeView</code>.</p>
<p>Next, we positioned the smoke so that it is directly above the pipe and appears to come out of the pipe, achieved with the <code>offset</code> modifier. Finally, we add the background right onto the <code>ZStack</code>, and the project is finished.</p>
<p>If you run the project, you’ll see realistic pipe smoke coming out of the pipe:</p>
<div><div><img alt="Figure 15.5: The pipe smoke animation " src="img/B18674_15_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5: The pipe smoke animation</p>
<p>Now that you know how to create<a id="_idIndexMarker884"/> smoke and have a basic foundation<a id="_idIndexMarker885"/> of how to get the SpriteKit particle system operational in our SwiftUI project, let’s continue and solidify what you know and use the <strong class="bold">Smoke</strong> template once again, but vary the values to create a different effect. </p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor225"/>Animating coffee steam</h1>
<p>In this next project, we’ll modify<a id="_idIndexMarker886"/> the particle system file to create steam that we can use to create a steaming cup of coffee animation. Well also look at a technique where we can place the steam directly inside the coffee by overlapping images. To get started, create a new project and call it <code>Coffee</code>, and then we’ll move on to creating the SpriteKit particle file.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor226"/>Creating the Smoke SpriteKit particle file</h2>
<p>To create the file, like<a id="_idIndexMarker887"/> before, press <em class="italic">Command + N</em>, choose the <strong class="bold">SpriteKit Particle File</strong> template, and let’s pick <strong class="bold">Smoke</strong> from the particle template options again (yes, <strong class="bold">Smoke</strong> again, but we will make it look like steam this time).</p>
<p>Now, we will modify the various properties to create our animation. Change all the properties in your SKS file to look like the following figure:</p>
<div><div><img alt="Figure 15.6: The attributes of the coffee steam animation " src="img/B18674_15_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6: The attributes of the coffee steam animation</p>
<p>All of those properties have been<a id="_idIndexMarker888"/> explained in the previous project. If you’re unclear as to what each one does, revisit that section for a refresher.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor227"/>Creating the Coffee Steam struct</h2>
<p>Next, let’s go back<a id="_idIndexMarker889"/> into the <code>ContentView</code> file and we’ll start assembling the project. In the previous project, we learned how to use the <code>.sks</code> file inside the SwiftUI view, and we’re going to do almost the exact same thing here too. The first thing we did was create a separate struct and use the <code>UIViewRepresentable</code> protocol to use the <code>.sks</code> file within a SwiftUI view. So, in this project, underneath <code>ContentView</code>, add the following struct:</p>
<pre class="source-code">
struct CoffeeSteam: UIViewRepresentable {
    func makeUIView(context: 
      UIViewRepresentableContext&lt;CoffeeSteam&gt;) -&gt; SKView {
        let view = SKView(frame: CGRect(x: 0, y: 0, width: 
          400, height: 400))
        view.backgroundColor = .clear
        let scene = SKScene(size: CGSize(width: 400, 
          height: 600))
        ///set the scenes background color to clear - we 
          only want the particles seen
        scene.backgroundColor = UIColor.clear
        guard let steam = SKEmitterNode(fileNamed: 
          "CoffeeSteam.sks") else { return SKView() }
        steam.position = CGPoint(x: scene.size.width / 2, 
          y: scene.size.height / 2)
        /// set the blend mode - scale - range
        steam.particleBlendMode = .screen
        steam.particleScale = 0.01
        steam.particleScaleRange = 0.05
        ///add the smoke to the scene
        scene.addChild(steam)
        view.presentScene(scene)
        return view
    }
    func updateUIView(_ uiView: SKView, context: 
      UIViewRepresentableContext&lt;CoffeeSteam&gt;) {
      /// Update the steam in this function if you need to
    }
}</pre>
<p>I explained this code in the previous<a id="_idIndexMarker890"/> project, but I will go over it again to help solidify your understanding:</p>
<ul>
<li>The code starts off by defining a custom SwiftUI view named <code>CoffeeSteam</code>, which is used to display the steam effect that we configured in the <code>CoffeeSteam.sks</code> file. The struct conforms to the <code>UIViewRepresentable</code> protocol. This allows the struct to be used as a SwiftUI view.</li>
<li>Next, we add the <code>makeUIView</code> method, which is required by the <code>UIViewRepresentable</code> protocol. It creates and returns an <code>SKView</code>, which is used to display the steam effect.</li>
<li>We create an instance of <code>SKView</code> with a specified frame (size and position). This frame is used to determine the size of the steam effect.</li>
<li>We set the <code>backgroundColor</code> property of the <code>SKView</code> instance to <code>clear</code>. This means that the background of the view will be transparent and will not have a solid color background; this way, any underlying views or graphics can show through.</li>
<li>Then, we create an instance of <code>SKScene</code> with a specified size, which is used to determine the size of the steam effect, and set the background color to <code>clear</code>; this way, the background of the steam effect will be transparent too.</li>
<li>Next, we create an instance of <code>SKEmitterNode</code> using the particle system defined in the <code>CoffeeSteam.sks</code> file. The guard <code>let</code> statement is used to check whether the file was loaded correctly and if not, it returns an empty <code>SKView</code>.</li>
<li>Then, we position the steam<a id="_idIndexMarker891"/> in the center of the scene; set the blend mode of the steam to <code>SKBlendMode.screen</code>, which will help to make the steam blend in with the background; set the initial scale of the steam particles to help them resemble a steam effect; then, we set the range of the scale of the smoke particles. (Again, refer to the previous project where I defined each of these property fields in the SKS file).</li>
<li>The <code>addChild</code> method is called on the <code>scene</code> instance, passing in the <code>steam</code> node as an argument. This adds the particle emitter node as a child node to the scene, meaning it will be displayed in the scene.</li>
<li>The <code>presentScene</code> method is called on the <code>view</code> instance, passing in the <code>scene</code> instance as an argument. This sets the scene as the currently displayed scene in the view.</li>
<li>Then, the <code>return</code> keyword returns the <code>view</code> instance. </li>
<li>The <code>updateUIView</code> function is called when the view needs to be updated, such as when the view’s state changes. In this code, we leave it empty, as it is not needed in our example.</li>
</ul>
<p>So, all that code creates and returns an <code>SKView</code> instance that displays a SpriteKit particle emitter as a SwiftUI view. Noticed that I am setting some of the properties in code here? You have the option of setting the properties in the SKS file by adjusting the values there, or you can set them<a id="_idIndexMarker892"/> in code here; however, remember that when you set them in code, they override anything you set in the SKS file.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor228"/>Filling out ContentView</h2>
<p>Now, we can just do a little<a id="_idIndexMarker893"/> work in <code>ContentView</code> and display the steaming cup of coffee. If you haven’t already done so, drop the assets into the Asset Catalog that you can find in the <code>Chapter 15</code> folder titled <code>Coffee Steam</code> on GitHub.</p>
<p>Let’s modify <code>ContentView</code> to look like the following:</p>
<pre class="source-code">
struct ContentView: View {
  var body: some View {
    ZStack {
        Image("background")
            .resizable().frame(width: 600, height: 900)
            .aspectRatio(contentMode: .fit)
        ZStack {
            ///adding the whole cup
            Image("cup")
                .resizable().frame(width: 350, height: 300)
                .aspectRatio(contentMode: .fit)
            ///calling and positioning the SmokeView
            CoffeeSteam().offset(x: 15, y: 80)
            ///adding the altered cup
            Image("cup 2")
                .resizable().frame(width: 350, height: 300)
                .aspectRatio(contentMode: .fit)
        }.offset(y: 250)
    }
  }
}</pre>
<p>The code declares a <code>ZStack</code> that will hold<a id="_idIndexMarker894"/> our views. Inside <code>ZStack</code>, we add a background image, resize it, and set the aspect ratio on it.</p>
<p>Then, the code declares another <code>ZStack</code>, where we placed the first image titled <code>cup</code>, resizing it and setting its aspect ratio as well.</p>
<p>Next, we called the <code>CoffeeSteam</code> struct and offset it a little bit so it’s centered in the middle of the cup. </p>
<p>And after that, we added the <code>cup 2</code> image. This second image is used to make the steam appear as though it’s coming out of the center of the cup. So, what we’re essentially doing is sandwiching the animating steam in between two coffee cup images, in which one of the cup images has a little cut out in it; when we place the steam in between these two, we can create a nice steaming effect that appears to be originating from inside the coffee cup. </p>
<p>Finally, I called the <code>offset</code> modifier on the <code>ZStack</code> to position everything on the <em class="italic">y</em>-axis.</p>
<p>Now, run the project and you will see the steaming effect that’s coming right off the surface of the coffee. Also notice how the back of the cup glistens with the steam as it rises, as it would do in a real cup of coffee.</p>
<div><div><img alt="Figure 15.7: A cup of steaming coffee " src="img/B18674_15_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7: A cup of steaming coffee</p>
<p>Now, we have completed<a id="_idIndexMarker895"/> two projects using the <strong class="bold">Smoke</strong> particle template – creating pipe smoke and coffee steam – and we understand how to manipulate the particles in very different ways. Let’s continue and move on to the next project, where we’ll use a different particle system: fire.</p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor229"/>Animating rocket fire</h1>
<p>The SpriteKit Fire particle template<a id="_idIndexMarker896"/> generates particles that are typically colored shades of orange, yellow, and red, which give the impression of glowing embers and flames. The particles may also have a slight degree of transparency to mimic the flickering and shifting quality of a real fire. In terms of behavior, the particles are designed to move upward with a certain amount of randomness, representing the movement of hot air and flames. </p>
<p>Rather than creating some simple flames, though, we’re going to animate a rocket!</p>
<p>Press <em class="italic">Command + N</em>, then choose the <code>Rocket</code>. Xcode will go ahead and create the fire particles that you can see them running in the editor.</p>
<p>Now, let’s create the SwiftUI view that will bring this <code>.sks</code> file into our SwiftUI project.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor230"/>Adding FireView</h2>
<p>To create<a id="_idIndexMarker897"/> the view, press <em class="italic">Command + N</em> and make a <code>SwiftUIView</code> file. Then, call it <code>FireView</code>. Then, import SpriteKit, and add the following code at the top of the file:</p>
<pre class="source-code">
struct FireView: UIViewRepresentable {
    func makeUIView(context: 
      UIViewRepresentableContext&lt;FireView&gt;) -&gt; SKView {
        let view = SKView(frame: CGRect(x: 0, y: 0, width: 
          400, height: 400))
        view.backgroundColor = .clear
        scene.backgroundColor = UIColor.clear
        guard let fire = SKEmitterNode(fileNamed: 
          "Fire.sks") else { return SKView() }
        fire.position = CGPoint(x: scene.size.width / 2, y: 
          scene.size.height / 2)
        ///use the particlePositionRange property to 
          constrain the fire particles so they are not so 
          wide and can fit under the rockets exhaust
        fire.particlePositionRange = CGVector(dx: 5, dy: 0)
        ///add the fire to the scene
        scene.addChild(fire)
        view.presentScene(scene)
        return view
    }
    func updateUIView(_ uiView: SKView, context: 
      UIViewRepresentableContext&lt;FireView&gt;) {
        /// Update the fire in this function if you need to
    }
}</pre>
<p>I’m not going to go over this code because we have done this already, but you can refer back to the previous SpriteKit projects for all the explanations, and how we use the <code>UIViewRepresentable</code> protocol.</p>
<p>If you run a code<a id="_idIndexMarker898"/> in the previews, you’ll see that it works great and the fire is the correct dimensions to fit under the rocket. However, notice that the fire is upside down. Let’s look at how we can fix this so it looks like a proper thrust to place underneath a rocket.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor231"/>Adding RocketView</h2>
<p>Let’s now create one more<a id="_idIndexMarker899"/> view that we can use to put together the rocket and the fire, then rotate the fire around so it’s properly oriented under the rocket. Press <em class="italic">Command + N</em>, create a new SwiftUI View file, and call it <code>RocketView</code>. Then, add the following code inside the struct:</p>
<pre class="source-code">
struct RocketView: View {
        @State private var rocketAndFireOffset: CGFloat = 0
        var body: some View {
            ZStack {
                FireView().rotationEffect(Angle(degrees: 
                  180.0)).offset(y: 60)
                     ///move the fire upwards by changing y 
                       offset
                    .offset(x: 0, y: -rocketAndFireOffset)
                    /// position the fire at the bottom 
                      center of the screen
                    .position(x: 
                      UIScreen.main.bounds.width/2, y: 
                      UIScreen.main.bounds.height)
                Image("rocket")
                    .resizable().aspectRatio(contentMode: 
                      .fit).frame(width: 100, height: 200)
                     ///move the rocket upwards by changing 
                       y offset
                    .offset(x: 0, y: -rocketAndFireOffset)
                    ///position the rocket at the bottom 
                      center of the screen
                    .position(x: 
                      UIScreen.main.bounds.width/2, y: 
                      UIScreen.main.bounds.height)
                ///rotate the fire and offset it so its 
                  under the bottom of the rocket
            } .animation(Animation.linear(duration: 
              8).repeatForever(autoreverses: false),value: 
              rocketAndFireOffset) // increase the duration 
              of the animation
                .onAppear {
                    rocketAndFireOffset = 
                      UIScreen.main.bounds.height * 1.3 // 
                      move the rocket off the top of the 
                      screen, by increasing the offset
            }
        }
    }</pre>
<p>First, we create a <code>rocketAndFire</code> offset variable that we can use to move both the rocket and the fire upward on the screen.</p>
<p>Then, inside the <code>ZStack</code>, we take <code>FireView</code> and rotate it 180°, and offset it on the <em class="italic">y</em>-axis, which makes<a id="_idIndexMarker900"/> the fire extend further out from the rocket, which we will add shortly. Then, we animate the fire upward by changing the <code>y</code>-<code>offset</code>, and positioning the fire in the center of the screen on the <em class="italic">x</em>- and <em class="italic">y</em>-axes using the <code>UIScreen</code> property.</p>
<p>Then, we can add the <code>rocket</code> image, resize it, and animate it upward by offsetting the <em class="italic">y</em>-axis using the <code>rocketAndFire</code> variable. Next, we just need to position the rocket in the center of the screen using the <code>UIScreen</code> property.</p>
<p>Finally, we can add the animation to the closing brace of the <code>ZStack</code>, which will act on both <code>FireView</code> and the rocket image. Let’s give it a duration of <code>8</code> seconds, and make it repeat forever with no auto-reverse.</p>
<p>Now, we can launch the rocket in the <code>onAppear</code> method by changing the value of the <code>rocketAndFire</code> property. When the view appears, the rocket will lift off and continue off the top<a id="_idIndexMarker901"/> of the screen and come back up from the bottom and keep flying.</p>
<p>All we have to do now is add the background!</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor232"/>Putting things together inside ContentView</h2>
<p>Inside <code>ContentView</code>, we need very<a id="_idIndexMarker902"/> little code to get our rocket into space:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        ZStack {
            ///add the RocketView to the scene
            RocketView()
        }.background(Image("background")
            .resizable()
            .scaledToFill().edgesIgnoringSafeArea(.all))
    }
}</pre>
<p>And that’s it. Inside the <code>ZStack</code>, we added <code>RocketView()</code> to the scene, and then we added the background image right onto <code>ZStack</code>.</p>
<p>Check it out in the previews and you’ll see that we now have a rocket flying in space:</p>
<div><div><img alt="Figure 15.8: Our rocket blasting off " src="img/B18674_15_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8: Our rocket blasting off</p>
<p>By leveraging the power<a id="_idIndexMarker903"/> of particle systems, we were able to create a realistic and dynamic visual effect that brings our rocket to life. We explored the various parameters and properties of the emitter to fine-tune the look and feel of the thrust and learned how to integrate it with our SwiftUI view.</p>
<p>Looking at another example, we’re going to return to another effect that we’ve already seen before – snow – but modify it so it creates a blizzard-like effect.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor233"/>Animating a blizzard</h1>
<p>In this next project, we’re going to create<a id="_idIndexMarker904"/> a blizzard scene, and add a wind effect to make the snow blow from different directions. We will also use that wind to make the branches of a tree blow as well, by combining images and animating them. We created a snow scene in the breathing flower project in <a href="B18674_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, but this time, we’re going to create this snow scene using a particle file, which gives us more options for making and controlling the snow.</p>
<p>Let’s start by creating a new project and calling it <code>Snow</code>. Then, we will get right to work creating the SKS file that we need for the snow – this time, though, we’ll create two files.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor234"/>Creating two Snow SpriteKit particle files</h2>
<p>For this project, we will create<a id="_idIndexMarker905"/> two SpriteKit files – both will be from the <strong class="bold">Snow</strong> template, but we will use different values so the snow blows from different directions and at different velocities.</p>
<p>To create the first file, press <em class="italic">Command + N</em>, choose the <code>Snow</code>. Now, let’s configure the particle properties so we can create a nice heavy snowfall. Use the same values from the following figure:</p>
<div><div><img alt="Figure 15.9: The attributes for the Snow file " src="img/B18674_15_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9: The attributes for the Snow file</p>
<p>And that creates the desired<a id="_idIndexMarker906"/> snowfall we are going for. To help you in designing your unique snowfall, the following is a guide for making adjustments:</p>
<ul>
<li><strong class="bold">Particle Lifetime</strong>: Set the lifetime to a relatively long time so that the particles stay on the screen for a while</li>
<li><strong class="bold">Particle Birthrate</strong>: Increase the birthrate to generate more particles per second, which will create a denser snowfall effect</li>
<li><strong class="bold">Particle Size</strong>: Increase the size of the particles to make them appear larger and more prominent on the screen</li>
<li><strong class="bold">Particle Speed</strong>: Decrease the speed of the particles to make them fall slower and more gently</li>
<li><strong class="bold">Particle Color</strong>: Change the color of the particles to white or light blue to make them look more like snowflakes</li>
<li><strong class="bold">Emitter Shape</strong>: Change the emitter shape to a rectangle or a line to make the snowfall appear more natural</li>
<li><strong class="bold">Emitter Position</strong>: Adjust the emitter’s position to start the snowfall from the top of the screen</li>
</ul>
<p>If you look at that snow in the editor, you can see that it has a pretty heavy effect, just what we need for our scene. Now, let’s create the second file with different values for the snow; we’ll then combine both of these SKS files into one SwiftUI view that we can use to create a nice blizzard effect.</p>
<p>Follow the same steps to create a second file, but this time, call it <code>Blustery</code>. Now, let’s alter the attributes to the following values:</p>
<div><div><img alt="Figure 15.10: The attributes for the Blustery file " src="img/B18674_15_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10: The attributes for the Blustery file</p>
<p>This new file has different <strong class="bold">Birthrate</strong>, <strong class="bold">Angle</strong>, and <strong class="bold">Acceleration</strong> values to make the snow blow from different directions, as well as lift the snow up a little bit as if being carried by the wind. When we combine<a id="_idIndexMarker907"/> the two SKS files together, which will create a nice blizzard effect.</p>
<p>So, let’s do that now; we’ll need to create a struct in which you can put these two files together.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor235"/>Creating a view that combines the two SKS files</h2>
<p>Working inside the <code>ContentView</code> file, first, add<a id="_idIndexMarker908"/> the SpriteKit import. Then, create a new struct called <code>SnowView</code> after the <code>ContentView</code> struct. (You could create separate files and keep things neat in the project navigator, but I’m just going to put the rest of the code into the <code>ContentView</code> file for this project.)</p>
<p>With <code>SnowView</code> created, add the following code within it:</p>
<pre class="source-code">
struct SnowView: UIViewRepresentable {
  func makeUIView(context: 
    UIViewRepresentableContext&lt;SnowView&gt;) -&gt; SKView {
      let view = SKView(frame: CGRect(x: 0, y: 0, width: 
        400, height: 400))
      view.backgroundColor = .clear
      let scene = SKScene(size: CGSize(width: 500, 
        height: 800))
      scene.backgroundColor = UIColor.clear
      guard let snow = SKEmitterNode(fileNamed: 
        "Snow.sks") else { return SKView() }
      guard let blustery = SKEmitterNode(fileNamed: 
        "Blustery.sks") else { return SKView() }
      //snow sks file
      snow.position = CGPoint(x: scene.size.width / 2, y: 
        scene.size.height / 2)
      ///use the particlePositionRange property to spread 
        the snow particles on the screen for the x and y 
        axis
      snow.particlePositionRange = CGVector(dx: 500, dy: 
        900)
      //blustery sks file
      blustery.position = CGPoint(x: scene.size.width / 2, 
        y: scene.size.height / 2)
      ///use the particlePositionRange property to spread 
        the snow particles on the screen for the x and y 
        axis
      blustery.particlePositionRange = CGVector(dx: 500, 
        dy: 900)
      ///add the snow to the scene
      scene.addChild(snow)
      scene.addChild(blustery)
      view.presentScene(scene)
      return view
  }
  func updateUIView(_ uiView: SKView, context: 
    UIViewRepresentableContext&lt;SnowView&gt;) {
      /// Update the snow in this function if you need to
  }
}</pre>
<p>The code positions<a id="_idIndexMarker909"/> both nodes, the <code>snow</code> node and the <code>blustery</code> node, using the <code>position</code> property, and then sets the <code>particlePositionRange</code> property on both as well. <code>particlePositionRange</code> is the range of allowed random values for a particle’s position. Finally, as we’ve done with our other particle files, we add them to the scene using the <code>addChild</code> function and passing in the view that we want to add to the scene.</p>
<p>Now, we can call this struct in <code>ContentView</code> to check out the blizzard, and in fact, let’s also add a background snow scene too:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        ZStack {
            Image("background")
                .resizable().frame(width: 600, height: 900)
                .aspectRatio(contentMode: .fit)
            SnowView()
        }
    }
}</pre>
<p>Now, run the previews and check out the blizzard effect:</p>
<div><div><img alt="Figure 15.11: Our blizzard scene " src="img/B18674_15_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11: Our blizzard scene</p>
<p>Now, let’s continue<a id="_idIndexMarker910"/> with the project and add another animation to it. For this one, we want to make the branches of the tree blow in the wind. </p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor236"/>Animating the tree branches</h2>
<p>To animate the tree<a id="_idIndexMarker911"/> branches, we’re going to wrap all the code up into several <code>ZStack</code>. Then, we will use one image of a snowy branch, replicate it many times with a <code>ForEach</code> loop, place the branch images over a portion of the tree, and put rotation animations on each of the axes of those images. We will also randomize the animation so that it doesn’t follow a set pattern.</p>
<p>Let’s start by creating the struct that we need to hold these views:</p>
<pre class="source-code">
struct Branches: View {
 var body: some View {
     }
}</pre>
<p>Next, let’s add the variables<a id="_idIndexMarker912"/> we need to keep track of the animations and set some initial values:</p>
<pre class="source-code">
   @State private var anglesX = [Double](repeating: 0, 
     count: 25)
    @State private var anglesY = [Double](repeating: 0, 
      count: 25)
    @State private var anglesZ = [Double](repeating: 0, 
      count: 25)
    @State private var positions = [CGPoint](repeating: 
      .zero, count: 25)
    @State private var durations = [Double](repeating: 0, 
      count: 25)</pre>
<p>This code defines five state properties in a SwiftUI view.</p>
<p>The <code>anglesX</code>, <code>anglesY</code>, and <code>anglesZ</code> properties are arrays of <code>Double</code> values, each with a length of <code>25</code>. These arrays are used to store the rotation angles around the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axes, respectively. The <code>repeating:</code> parameter is used to initialize all the values in each array to 0.</p>
<p>The <code>positions</code> property is an array of <code>CGPoint</code> values, also with a length of <code>25</code>. This array is used to store the positions of the views. The <code>repeating:</code> parameter is used to initialize all the values in the array to the zero point, <code>(</code><code>0, 0)</code>.</p>
<p>The <code>durations</code> property is an array of <code>Double</code> values, again with a length of <code>25</code>. This array is used to store the durations of the animations associated with each view. The <code>repeating:</code> parameter is used to initialize all the values in the array to 0.</p>
<p>As we have seen, the <code>@State</code> property wrapper<a id="_idIndexMarker913"/> is used to make each of these arrays a mutable state property of the view. This means that whenever any of the arrays are modified, SwiftUI will automatically re-render the view to reflect the changes.</p>
<p>Next, let’s move into the <code>body</code> property and add a <code>ZStack</code> that contains the image we want to manipulate and reproduce, as well as the animation we’re going to put on it:</p>
<pre class="source-code">
ZStack {
    ForEach(0..&lt;8) { index in
         Image("branch")
            .resizable()
            .aspectRatio(contentMode: .fit)
            .rotationEffect(Angle(degrees: anglesX[index]))
            .rotationEffect(Angle(degrees: anglesY[index]), 
              anchor: .center)
            .rotationEffect(Angle(degrees: anglesZ[index]), 
              anchor: .center)
            .position(positions[index])
            .frame(width: 200, height: 700)
            .animation(
                Animation.easeInOut(duration: 
                  durations[index])
                    .repeatForever(autoreverses: true), 
                      value: anglesX)
            .onAppear {
                anglesX[index] = Double.random(in: 2...4)
                anglesY[index] = Double.random(in: 2...3)
                anglesZ[index] = Double.random(in: 1...3)
                positions[index] = CGPoint(x: 
                  CGFloat.random(in: 0...10), y: 
                  CGFloat.random(in: 0...5))
                durations[index] = Double.random(in: 3...5)
            }
    }
} .offset(x: 50, y: 200)</pre>
<p>Here’s what we’re doing<a id="_idIndexMarker914"/> in here. We start off with a <code>ZStack</code> so we can stack our views on top of each other. Next is a <code>ForEach</code> loop, which iterates over a range of integers from 0 to 7; the <code>index</code> parameter is used to access the current iteration value in the loop.</p>
<p>Then, we add the branch image and the following modifiers: </p>
<ul>
<li>The <code>resizable</code> modifier resizes the image.</li>
<li>The <code>rotationEffect(_:)</code> modifier is used to rotate the image around the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axes. The angle of rotation is specified by the corresponding value in the <code>anglesX</code>, <code>anglesY</code>, and <code>anglesZ</code> arrays, respectively. The <code>anchor</code> parameter is used to specify the center of rotation. In this case, <code>.center</code> is used for both the <code>anglesY</code> and <code>anglesZ</code> rotations, so the image is rotated around its center point.</li>
<li>The <code>position(_:)</code> modifier is used to position the image on the screen. The <code>positions</code> array stores the position for each image instance based on its index.</li>
<li>The <code>frame(width:height:)</code> modifier sets the size of the image.</li>
<li>The <code>animation(_:, value:)</code> modifier is used to animate the rotation of the image. The duration of the animation is based on the value stored in the <code>durations</code> array, while the <code>value</code> parameter specifies that the animation should be re-evaluated whenever the <code>anglesX</code> array changes.</li>
<li>The <code>onAppear</code> modifier is used to randomly generate new values for the <code>anglesX</code>, <code>anglesY</code>, <code>anglesZ</code> positions, and <code>durations</code> arrays whenever an image appears on the screen.</li>
<li>Finally, the <code>offset</code> modifier applies an offset of <code>50</code> points on the <em class="italic">x</em>-axis and <code>200</code> points on the <em class="italic">y</em>-axis to the entire <code>ZStack</code>, which positions the tree branches in the middle-right portion of the tree.</li>
</ul>
<p>To summarize, what we’re doing<a id="_idIndexMarker915"/> is creating eight image views of snow-covered branches, each with a different rotation, position, duration, and animation. The views are stacked on top of each other within <code>ZStack</code> and have an offset applied to place them in the tree.</p>
<p>Now, I’d like to replicate the <code>ZStack</code> several more times so we can cover the whole tree with snowy branches, rather than covering only a portion of the tree. So, we’ll make four more ZStacks but with slightly different values to make the wind-blowing effect seem more random and natural:</p>
<pre class="source-code">
ZStack {
    ForEach(0..&lt;10) { index in
        Image("branch")
            .resizable()
            .aspectRatio(contentMode: .fit)
            .rotationEffect(Angle(degrees: anglesX[index]))
            .rotationEffect(Angle(degrees: anglesY[index]), 
              anchor: .center)
            .rotationEffect(Angle(degrees: anglesZ[index]), 
              anchor: .center)
    .position(positions[index])
            .frame(width: 200, height: 700)
            .offset(x: 50, y: 200)
            .animation(
                Animation.easeInOut(duration: 
                  durations[index])
                    .repeatForever(autoreverses: 
                      true),value: anglesY)
            .onAppear {
                anglesX[index] = Double.random(in: 3...4)
                anglesY[index] = Double.random(in: 2...5)
                anglesZ[index] = Double.random(in: 1...4)
                positions[index] = CGPoint(x: 
                  CGFloat.random(in: 0...10), y: 
                  CGFloat.random(in: 0...14))
                durations[index] = Double.random(in: 2...6)
            }
    }
}.offset(x: -80, y: -156)
  ZStack {
    ForEach(0..&lt;15) { index in
      Image("branch")
          .resizable()
          .aspectRatio(contentMode: .fit)
          .rotationEffect(Angle(degrees: anglesX[index]))
          .rotationEffect(Angle(degrees: anglesY[index]), 
            anchor: .center)
          .rotationEffect(Angle(degrees: anglesZ[index]), 
            anchor: .center)
          .position(positions[index])
          .frame(width: 200, height: 700)
          .offset(x: 50, y: 200)
          .animation(
              Animation.easeInOut(duration: 
                durations[index])
                  .repeatForever(autoreverses: true)
              ,value: anglesZ)
          .onAppear {
              anglesX[index] = Double.random(in: 1...3)
              anglesY[index] = Double.random(in: 2...4)
              anglesZ[index] = Double.random(in: 3...6)
              positions[index] = CGPoint(x: 
                CGFloat.random(in: 0...10), y: 
                CGFloat.random(in: 0...8))
              durations[index] = Double.random(in: 4...6)
          }
  }
}.offset(x: -120, y: 0)
    
    ZStack {
      ForEach(0..&lt;7) { index in
        Image("branch")
          .resizable()
          .aspectRatio(contentMode: .fit)
          .rotationEffect(Angle(degrees: anglesX[index]))
          .rotationEffect(Angle(degrees: anglesY[index]), 
            anchor: .center)
          .rotationEffect(Angle(degrees: anglesZ[index]), 
            anchor: .center)
          .position(positions[index])
          .frame(width: 200, height: 700)
          .offset(x: 50, y: 200)
          .animation(
              Animation.easeInOut(duration: 
                durations[index])
                  .repeatForever(autoreverses: true)
              ,value: anglesX)
          .onAppear {
              anglesX[index] = Double.random(in: 1...3)
              anglesY[index] = Double.random(in: 2...3)
              anglesZ[index] = Double.random(in: 3...5)
              positions[index] = CGPoint(x: 
                CGFloat.random(in: 0...10), y: 
                CGFloat.random(in: 0...12))
              durations[index] = Double.random(in: 4...6)
          }
  }
  }.offset(x: -100, y: 160)
  
  ZStack {
    ForEach(0..&lt;7) { index in
      Image("branch")
          .resizable()
          .aspectRatio(contentMode: .fit)
          .rotationEffect(Angle(degrees: anglesX[index]))
          .rotationEffect(Angle(degrees: anglesY[index]), 
            anchor: .center)
          .rotationEffect(Angle(degrees: anglesZ[index]), 
            anchor: .center)
          .position(positions[index])
          .frame(width: 180, height: 700)
          .offset(x: 50, y: 200)
          .animation(
              Animation.easeInOut(duration: 
                durations[index])
                  .repeatForever(autoreverses: true)
              ,value: anglesY)
          .onAppear {
              anglesX[index] = Double.random(in: 0...2)
              anglesY[index] = Double.random(in: 0...3)
              anglesZ[index] = Double.random(in: 0...1)
              positions[index] = CGPoint(x: 
                CGFloat.random(in: 0...10), y: 
                CGFloat.random(in: 0...12))
              durations[index] = Double.random(in: 3...6)
          }
  }
  }.offset(x: 10, y: 100)</pre>
<p>All of these <code>ZStack</code> do essentially<a id="_idIndexMarker916"/> the same thing, except that the code uses different values. For example, in the <code>ForEach</code> loop, we’re using a different range of values, and we’re also changing the random values for the <em class="italic">x</em>-, <em class="italic">y</em>-, and <em class="italic">z</em>-axes, as well as the <code>position</code> and <code>duration</code> values. Also, each <code>ZStack</code> has its own <code>onAppear</code> modifier, so it could randomly move its set of branches at a different pace and on a different axis.</p>
<p>Now, let’s call this struct inside <code>ContentView</code>. We will call it just before the <code>SnowView</code> call; this way, the snow will appear on top of the tree images:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
        ZStack {
            Image("background")
                .resizable().frame(width: 600, height: 900)
                .aspectRatio(contentMode: .fit)
            Branches()
            SnowView()
        }
    }
}</pre>
<p>Now, run the code and check out the really cool animation of the tree branches blowing in the wind as the snow falls.</p>
<p>Play around with all the values that we’ve used in the various parameters and customize them to your liking. Maybe<a id="_idIndexMarker917"/> you want fewer branches for a thinner-looking tree, maybe you want the wind to blow much stronger, or maybe you want to animate all the trees in the background image... you can change all the settings to do just that. </p>
<p>Let’s continue our exploration of some interesting animations. Up next, we will look at the rain particle system.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor237"/>Animating rain</h1>
<p>In our next project, let’s make<a id="_idIndexMarker918"/> it rain. We’re going to create a realistic effect by creating rain from the <strong class="bold">Rain</strong> particle template and making it bounce off the ground as you would see in a rainstorm. We’ll also create a puddle that will subtly grow and shrink, appearing to react to the falling rain, and it will also look like water, as we will add some blending options to it to give it a transparent look for a spectacular effect that even shows some of the ground underneath it.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor238"/>Creating the Rain SpriteKit particle file</h2>
<p>Let’s get started. You know<a id="_idIndexMarker919"/> how to do this now – create an SKS file, choose <code>Rain</code> too. Now, configure the file to have the following attributes:</p>
<div><div><img alt="Figure 15.12: The attributes of the rain animation " src="img/B18674_15_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.12: The attributes of the rain animation</p>
<p>Using the <strong class="bold">Rain</strong> particle template gives us rain right out of the box, but with some slight adjustments to the <strong class="bold">Birthrate</strong> and <strong class="bold">Lifetime</strong> options, we can alter how much of a rainstorm we want.</p>
<p>Let’s now create another<a id="_idIndexMarker920"/> new file, this time, a SwiftUI file, which we will use to bring the rain effects into a SwiftUI view. </p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor239"/>Creating the raindrops</h2>
<p>To create<a id="_idIndexMarker921"/> the SwiftUI file, press <em class="italic">Command + N</em> and call this file <code>DropView</code>. The code we will add to this file will be responsible for creating the collision effect between a raindrop and the ground. We’ll also alter the opacity and the blur to really help it blend into the scene. </p>
<p>Let’s now add the following code inside the <code>DropView</code> struct:</p>
<pre class="source-code">
struct DropView: View {
  @State private var dropScale: CGFloat = 0.1
  @State private var xOffsets = (0..&lt;300).map { _ in 
    CGFloat.random(in: -150...UIScreen.main.bounds.width)}
  @State private var yOffsets = (0..&lt;240).map { _ in 
    CGFloat.random(in: UIScreen.main.bounds.height/5...
    UIScreen.main.bounds.height)}
  @State private var durations = (0..&lt;150).map { _ in 
    Double.random(in: 0.3...1.0)}
  var body: some View {
      //Color.clear.edgesIgnoringSafeArea(.all)
          ForEach(0..&lt;150) { index in
              Circle()
                  .fill(Color.white)
                      .opacity(0.6)
                    .blur(radius: 3)
                  .frame(width: 15, height: 15)
                  .scaleEffect(dropScale)
                  .rotation3DEffect(Angle(degrees: 80.0), 
                    axis: (x: 1, y: 0, z: 0))
                  .offset(x: xOffsets[index] - 140, y: 
                    yOffsets[index])
                  .animation(Animation.easeInOut(duration: 
                    durations[index]).repeatForever
                    (autoreverses: true), value: dropScale)
                  .onAppear {
                      dropScale = 0.8
                  }
          }
  }
}</pre>
<p>There’s a lot going<a id="_idIndexMarker922"/> on here, so let’s break it down line by line. </p>
<p>There are four <code>State</code> variables we need and each one has a specific task:</p>
<ul>
<li>The first variable is of the <code>CGFloat</code> type and gets an initial value of <code>0.1</code>. This variable is used to control the scale of the drops.</li>
<li>The next two variables create arrays of <code>CGFloat</code> values, stored in the <code>xOffsets</code> and <code>yOffsets</code> state variables. The <code>map</code> method is used to generate random <code>CGFloat</code> values and the <code>CGFloat.random(in:)</code> method is used to generate a random <code>CGFloat</code> value within a given range. In short, these variables are used to set a random <em class="italic">x</em>- and <em class="italic">y</em>-coordinate position for each drop.</li>
<li>The final variable is the <code>durations</code> variable, which randomizes the duration of the animation.</li>
</ul>
<p>Let’s take a closer look at the <code>map</code> method since it is being used by three of our properties. The <code>map</code> method is a higher-order function in Swift that transforms an array of values into a new array<a id="_idIndexMarker923"/> of different values. It takes a closure expression as an argument, which is executed for each element in the original array and returns a new value for that element. The resulting array is then the combination of all of these new values.</p>
<p>In the code, the <code>map</code> method is being used to transform the range of integers between 0 and &lt;300 into an array of <code>CGFloat</code> values, by using the <code>CGFloat.random(in:)</code> method to generate a random value for each element in the range. The closure expression passed to the <code>map</code> method takes a single argument, <code>_</code>, which is a placeholder for the current element of the range, and returns a new <code>CGFloat</code> value, generated by <code>CGFloat.random(in: -150...UIScreen.main.bounds.width)</code>. The <code>map</code> method combines all of these new values into a single array, which is then assigned to the <code>xOffsets</code> variable.</p>
<p>The <code>map</code> method is an important and versatile function in Swift, as it allows you to easily transform arrays and sequences of values into new arrays and sequences. Additionally, the <code>map</code> method is often used in combination with other functional programming techniques such as filter and reduce, to perform complex operations on arrays and sequences in a more efficient and maintainable way.</p>
<p>Now, let’s move into the <code>body</code> property and look at what the code is doing there.</p>
<p>We use a <code>ForEach</code> loop to iterate through a range from 0 and &lt;150, and create a <code>Circle</code> view with each iteration – the circle will be the raindrop. Then, we set the <code>fill</code> color of the <code>Circle</code> view to <code>white</code>, the <code>width</code> and <code>height</code> values to <code>15</code>, and apply a <code>scaleEffect</code> with the value determined by the <code>dropScale</code> variable.</p>
<p>Next, we apply <code>rotation3DEffect</code> to the <code>Circle</code> view, with an angle of 80 degrees on the <em class="italic">x</em>-axis; we want to rotate the drop so that it appears more like a raindrop colliding with the ground. Following that, we set its offset using the <code>xOffsets</code> and <code>yOffsets</code> variables with a value determined by the index.</p>
<p>We then add the animation, setting the duration to be determined by the <code>index</code> constant, and repeating the animation with <code>autoreverse</code> set to <code>true</code> to create the realistic collision of the raindrop with the ground. </p>
<p>Finally, in the <code>onAppear</code> modifier, we give the <code>DropScale</code> variable a value of <code>0.8</code>.</p>
<p>Running that in the previews<a id="_idIndexMarker924"/> will be a little difficult to see because of the white background, but let’s keep going and we’ll check out the results shortly. </p>
<p>Let’s now create a new view that will make a puddle of water that we can animate and add to the scene.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor240"/>Creating the puddle</h2>
<p>Let’s now add a puddle<a id="_idIndexMarker925"/> to our scene, which we’ll do in a new SwiftUI View file called <code>PuddleView</code>. I’m going to add all the code for this view and then we’ll review how it works:</p>
<pre class="source-code">
struct PuddleView: View {
  @State private var scaleX: CGFloat = 0.5
  @State private var scaleY: CGFloat = 0.5
  var body: some View {
    ZStack {
      Capsule()
          .fill(LinearGradient(gradient: Gradient(colors: 
            [.white,  .black,.gray, .white,.black]), 
            startPoint: .topLeading, endPoint:  
            .bottomTrailing))
          .opacity(0.5)
          .blur(radius: 5)
          .frame(width: 600, height: 500)
          .scaleEffect(x: scaleX, y: scaleY, anchor: 
        .center)
      .animation(Animation.easeInOut(duration: 
        8.0).repeatForever(autoreverses: true),value: 
        scaleX)
      //creates the ripple
          .overlay(
              Capsule()
                  .stroke(Color.gray, lineWidth: 5)
                  .opacity(0.5 )
                  .frame(width: 350, height: 200)
                  .offset(x: 0, y: -15)
                  .scaleEffect(x: scaleX + 0.03, y: scaleY 
                    + 0.03, anchor: .center)
                  .animation(Animation.easeInOut(duration: 
                    8.0).repeatForever(autoreverses: true), 
                    value: scaleY)
                  .onAppear {
                      scaleX = 0.54
                      scaleY = 0.6
                  }).rotation3DEffect(Angle(degrees: 81.0), 
                    axis: (x: 1, y: 0, z: 0))
      
  } .offset(x: -50, y: 300)
      .onAppear {
          scaleX = 0.55
          scaleY = 0.6
      }
  }
}</pre>
<p>This code defines a struct<a id="_idIndexMarker926"/> called <code>PuddleView</code> that has two properties, <code>scaleX</code> and <code>scaleY</code>, which are both <code>CGFloat</code> values. The <code>body</code> property of the struct is defined as follows:</p>
<ul>
<li>A <code>ZStack</code> view is created, which arranges views on top of each other.</li>
<li>Inside <code>ZStack</code>, a <code>Capsule</code> view is created, which will be the shape of a puddle. The <code>Capsule</code> view is filled with a <code>LinearGradient</code> of colors and is then modified with several modifiers:<ul><li>The <code>opacity</code> modifier is set to <code>0.5</code>, making it partially transparent.</li><li>The <code>blur</code> modifier is set with a radius of <code>5</code> pixels.</li><li>The <code>frame</code> modifier sets the <code>width</code> property to <code>600</code> pixels and <code>height</code> to <code>500</code> pixels.</li><li>The <code>scaleEffect</code> modifier is set with the <em class="italic">x</em> and <em class="italic">y</em> scale values set to <code>scaleX</code> and <code>scaleY</code>, respectively. The <code>anchor</code> parameter is set to <code>.center</code>, indicating that the scaling should be the center of the capsule.</li><li>The <code>animation</code> modifier has a <code>scaleX</code> value, with an <code>easeInOut</code> timing function and a <code>duration</code> value of <code>8</code> seconds, and is set to repeat forever with <code>autoreverses</code>.</li></ul></li>
<li>Then,<code>.overlay()</code> is used to create a new <code>Capsule</code> view that is placed on top of the previous one. This new <code>Capsule</code> view is also modified with several modifiers:<ul><li>The <code>stroke</code> modifier adds a gray stroke with a line width of <code>5</code> pixels.</li><li>The <code>opacity</code> modifier is set to <code>0.5</code>, making it partially transparent.</li><li>The <code>frame</code> modifier sets the <code>width</code> property to <code>350</code> pixels and <code>height</code> to <code>200</code> pixels. </li><li>The <code>offset</code> modifier shifts the capsule slightly upward.</li><li>The <code>scaleEffect</code> modifier sets the <em class="italic">x</em> and <em class="italic">y</em> scale values, with <code>scaleX</code> set to <code>+ 0.03</code> and <code>scaleY</code> to <code>+ 0.03</code>, respectively. The <code>anchor</code> parameter is set to <code>.center</code>, indicating that the scaling should be centered on the capsule.</li><li>The <code>animation</code> modifier has a <code>scaleY</code> value, with an <code>easeInOut</code> timing function and a <code>duration</code> value of <code>8</code> seconds, and is set to repeat forever with <code>autoreverses</code>.</li><li>The <code>onAppear</code> modifier sets the initial value of <code>scaleX</code> and <code>scaleY</code> to <code>0.54</code> and <code>0.6</code>, respectively.</li><li>The <code>rotation3DEffect</code> modifiers set an angle of <code>81</code> degrees on the <em class="italic">x</em>-axis.</li></ul></li>
<li>The <code>ZStack</code> view is then modified with <code>.offset(x: -50, y: 300)</code> and <code>.onAppear { scaleX = 0.55; scaleY = 0.6 }</code>. This shifts the group view 50 pixels to the left and 300 pixels downward. This code block is executed when the view appears and sets the initial values of <code>scaleX</code> and <code>scaleY</code> to <code>0.55</code> and <code>0.6</code>, respectively.</li>
</ul>
<p>In summary, this code creates<a id="_idIndexMarker927"/> a view that looks like a puddle of water by using a gradient fill that’s partially transparent and blurred, and with a ripple effect added. The ripple effect is created by applying a scale effect to the second capsule view and animating the <code>scaleX</code> and <code>scaleY</code> properties so that it appears to be moving. The ripple effect is also rotated on the <em class="italic">x</em>-axis to make it more interesting.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor241"/>Putting it all together</h2>
<p>With <code>PuddleView</code> done, let’s just fill out <code>ContentView</code> and check<a id="_idIndexMarker928"/> out the<a id="_idIndexMarker929"/> animation. Add the following code to modify <code>ContentView</code>:</p>
<pre class="source-code">
import SpriteKit
import SwiftUI
struct ContentView: View {
    var body: some View {
        ZStack {
            Image("street")
                   .resizable()
                   .scaledToFill()
            PuddleView()//.blendMode(.hardLight)
            RainView()
            DropView()
            RainView()
        }.edgesIgnoringSafeArea(.all)
    }
}</pre>
<p>In <code>ContentView</code>, we added an image of a street, resized and scaled it, then called <code>PuddleView</code>. In <code>PuddleView</code>, <code>blendMode</code> is set to <code>hardLight</code>. Play around with the blend mode options <a id="_idIndexMarker930"/>for different looks and effects, but I think the hard<a id="_idIndexMarker931"/> light gives the best water effect so far, creating a glass-like look that is perfect for making a puddle of water where you can see some of the ground underneath. </p>
<p>Next, I called <code>RainView</code> to add the rain, then <code>DropView</code> to add the collision effect of the raindrops hitting the ground, and then <code>Rainview</code> again just to add a little more rain to the mix. This is the result:</p>
<div><div><img alt="Figure 15.13: The raindrops " src="img/B18674_15_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.13: The raindrops</p>
<p>This creates a nice effect<a id="_idIndexMarker932"/> of raindrops colliding with the ground and even with<a id="_idIndexMarker933"/> the puddle.</p>
<p>Let’s continue and take a look at the <strong class="bold">Magic</strong> particle template and we will see how we can use an image to make the particles.</p>
<h1 id="_idParaDest-231"><a id="_idTextAnchor242"/>Animating a magic wand</h1>
<p>In this project, we’re going<a id="_idIndexMarker934"/> to use the <strong class="bold">Magic</strong> particle system, and we will display that magic from the tip of a wand. You will be able to move the wand around the screen with your finger, and as it moves, magic will emanate from its tip. We will also have a cemetery background including a gravestone, and when you tap on the gravestone, a skeleton will rise up from it.</p>
<p>So, let’s get started with our spooky animation. Create a new project and call this one <code>Magic</code>. Next, add the resources for this project by dragging them from the <code>Chapter 15</code> | <code>Magic</code> folder on GitHub into the Asset Catalog. Then, we can make our particle file.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor243"/>Creating the magic SpriteKit particle file</h2>
<p>As we’ve done before, create<a id="_idIndexMarker935"/> a new SpriteKit particle file, but select the <code>Magic</code>. Now, let’s do something a little different this time – using the <strong class="bold">Texture</strong> field in the <strong class="bold">Attributes</strong> panel, select the <strong class="bold">star</strong> image that you placed into the Asset Catalog. We’re going to make the particle system based on that image, so all the particles will be stars. Next, change the rest of the fields so the values look like the following:</p>
<div><div><img alt="Figure 15.14: The attributes of the magic animation " src="img/B18674_15_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.14: The attributes of the magic animation</p>
<p>Notice the <strong class="bold">Color Ramp</strong> field. It has three colors<a id="_idIndexMarker936"/> selected. If you would like to select a color for the <strong class="bold">Color Ramp</strong> field, simply click anywhere along the color selector, and then a pop-up color box will come up allowing you to choose a color. I’ve chosen three colors here: red will be the center of the animation, green will surround it, and the third color is yellow, which will be the outer part of the magic animation.</p>
<p>Next, we want to make this <code>Magic.sks</code> file available as a SwiftUI view. So, let’s create a new Swift file, and call it <code>MagicView</code>. Then, add the following code to the file:</p>
<pre class="source-code">
import SwiftUI
import SpriteKit
struct MagicView: UIViewRepresentable {
    func makeUIView(context: 
      UIViewRepresentableContext&lt;MagicView&gt;) -&gt; SKView {
        let view = SKView(frame: CGRect(x: 0, y: 0, width: 
          400, height: 400))
        view.backgroundColor = .clear
        let scene = MagicScene(size: CGSize(width: 900, 
          height: 600))
        scene.backgroundColor = UIColor.clear
        scene.scaleMode = .aspectFill
        view.presentScene(scene)
        return view
    }
    func updateUIView(_ uiView: SKView, context: 
      UIViewRepresentableContext&lt;MagicView&gt;) {
    }
}</pre>
<p>We’ve worked with this code in previous projects, so we’re familiar with it by now.</p>
<p>The code defines a struct called <code>MagicView</code>, which conforms to the <code>UIViewRepresentable</code> protocol in SwiftUI. The <code>makeUIView</code> function creates an instance of an <code>SKView</code> with a given frame size and sets its background color to <code>clear</code>.</p>
<p>It then creates an instance<a id="_idIndexMarker937"/> of <code>MagicScene</code>, specifying its size, setting its background color to <code>clear</code>, and scaling it to <code>aspectFill</code>. Finally, the created scene is presented on <code>SKView</code>, and the <code>SKView</code> instance is returned.</p>
<p>The <code>updateUIView</code> function does not perform any actions for us, as we don’t need to update anything, but it is a required method for the <code>UIViewRepresentable</code> protocol.</p>
<p>Now, the code will give us an error because of this line: <code>let scene = MagicScene(size: CGSize(width: 900, height: 600))</code>. This is because we’re creating a scene and setting it to the <code>MagicScene</code> class, but we haven’t created a <code>MagicScene</code> class yet. </p>
<p>So, let’s do that now. Let’s create the <code>MagicScene</code> class, which will contain the  properties and functions we need to manipulate the magic coming from the wand, as well as making the skeleton rise up from the ground. Create a new Swift file and call this <code>Magic</code>. I’m going to place all of the code here and then I’ll explain how it works:</p>
<pre class="source-code">
import Foundation
import SwiftUI
import SpriteKit
class MagicScene: SKScene {
  var magic: SKEmitterNode!
  var wand: SKSpriteNode!
  override func touchesMoved(_ touches: Set&lt;UITouch&gt;, 
    with event: UIEvent?) {
      let touch = touches.first!
      let touchLocation = touch.location(in: self)
      wand.position = CGPoint(x: touchLocation.x - 30, y: 
        touchLocation.y + wand.frame.size.height / 2 - 20)
      ///make the skeleton appear
      if touchLocation.x &lt; frame.size.width * 0.55 &amp;&amp; 
        touchLocation.y &lt; frame.size.height * 0.12 {
          let skeleton = SKSpriteNode(imageNamed: 
            "skeleton")
          skeleton.position = CGPoint(x: frame.size.width / 
            2 - 80, y: 175)
          skeleton.size = CGSize(width: skeleton.size.width 
            / 2, height: skeleton.size.height / 2)
          addChild(skeleton)
          let moveAction = SKAction.move(to: CGPoint(x: 
            frame.size.width / 2 - 50, y: frame.size.height 
            / 2), duration: 2.0)
          skeleton.run(moveAction)
      }
      wand.zPosition = 2
      let trail = SKEmitterNode(fileNamed: "Magic.sks")!
      trail.particlePositionRange = CGVector(dx: 5, dy: 5)
      trail.particleSpeed = 50
      trail.position = CGPoint(x: wand.position.x - 40, y: 
        wand.position.y + wand.frame.size.height / 2 + 
        trail.particlePositionRange.dy)
      addChild(trail)
      let fadeAway = SKAction.fadeOut(withDuration: 1.2)
      trail.run(fadeAway) {
          trail.removeFromParent()
      }
  }
  override func didMove(to view: SKView) {
      let stone = SKSpriteNode(imageNamed: "stone")
      stone.position = CGPoint(x: frame.size.width / 2.3, 
        y: frame.size.height / 2 - 150)
      stone.size = CGSize(width: 120, height: 175)
      stone.zRotation = CGFloat(Double.pi / 20)
      stone.zPosition = 2
         addChild(stone)
      guard let magic = SKEmitterNode(fileNamed: 
        "Magic.sks") else { return }
      magic.particlePositionRange = CGVector(dx: 5, dy: 5)
      magic.particleSpeed = 50
      addChild(magic)
      self.magic = magic
      wand = SKSpriteNode(imageNamed: "wand")
      wand.position = CGPoint(x: frame.size.width / 2, y: 
        frame.size.height / 3)
      wand.size = CGSize(width: 80, height: 180)
      addChild(wand)
  }
}</pre>
<p>Okay, let’s break down<a id="_idIndexMarker938"/> the code and see what it’s doing here.</p>
<p>Inside the <code>MagicScene</code> class, there are two instance variables declared:</p>
<ul>
<li><code>magic</code> is an instance of <code>SKEmitterNode</code>, which is a class from SpriteKit that represents an emitter that can create particles. </li>
<li><code>wand</code> is an instance of <code>SKSpriteNode</code>, which is a class from SpriteKit that represents a textured rectangle.</li>
</ul>
<p>The <code>MagicScene</code> class overrides two methods from <code>SKScene</code>:</p>
<ul>
<li>The <code>touchesMoved(_:with:)</code> method is called when the user moves their finger across the screen. Inside this method, the position of the wand sprite is updated to follow the user’s touch location. If the touch location is in a specific area of the screen, a skeleton sprite is created and animated to move to a specific location on the screen, straight up. Then, a new <code>SKEmitterNode</code> instance is created and added as a child of the <code>MagicScene</code> instance. This emitter is positioned relative to the wand sprite and emits particles that we created in the <code>.sks</code> file, and simulates the magic. After a duration of 1.2 seconds, the emitter fades away and is removed from the scene.</li>
<li>The <code>didMove(to:)</code> method is called once when the scene is first presented. Inside this method, a stone sprite is created and positioned on the screen. Then, an <code>SKEmitterNode</code> instance is created and added as a child of the <code>MagicScene</code> instance. This emitter will also simulate magic particles. Finally, a wand sprite is created and positioned on the screen.</li>
</ul>
<p>That completes the code for the <code>magic.sks</code> file. Let’s continue and head into <code>ContentView</code> and add a little bit of code there so we can see the magic. All we need to do is add the graveyard background scene and call <code>MagicView</code>. To do this, change your <code>ContentView</code> to the following:</p>
<pre class="source-code">
struct ContentView: View {
    var body: some View {
    ZStack {
        Image("graveyard")
            .resizable()
            .scaledToFill().frame(width: 500, height: 900)
        MagicView()
      }
  }
}</pre>
<p>With that bit of code, the project<a id="_idIndexMarker939"/> is done. Run the animation and start <a id="_idIndexMarker940"/>making magic:</p>
<div><div><img alt="Figure 15.15: The magic wand and graveyard scene " src="img/B18674_15_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.15: The magic wand and graveyard scene</p>
<p>Move the wand around and see the magic coming out of its tip, then tap on the gravestone to wake the skeleton!</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor244"/>Summary</h1>
<p>With SpriteKit’s extensive support for physics and particle systems, combined with SwiftUI’s easy-to-use interface and modern design capabilities, you can create dynamic, engaging animations that bring your apps to life. As we have seen here, you can create smoke, rain, fire, snow, and magic, but there are even more particle systems to try and experiment with.</p>
<p>As always, alter each project to your liking, and add your own unique creativity and ideas. Add sound to various parts of each project if you want – for example, in the magic wand project, maybe when the wand is moving, play a wand sound effect. Enhance the animations by altering the values, changing the images, or building out more complex scenes using the tools you now have. Just have fun because the effects are only limited by your imagination.</p>
<p>And with that, we have completed the final projects, and also the final chapter.</p>
<p>Throughout the book, we delved into both implicit and explicit animations, exploring the differences between them and how to use them to achieve different effects. As we progressed through the book, we gradually introduced different modifiers and more challenging animation techniques, from basic bounces to more advanced moves. We also built two complete games that you can modify in many different ways.</p>
<p>You now have the knowledge, skills, and a deeper understanding of SwiftUI animations to be able to implement a wide range of effects that will take your app to the next level and create engaging and dynamic user experiences.</p>
<p>Happy animating!</p>
</div>
<div><div></div>
</div>
</body></html>