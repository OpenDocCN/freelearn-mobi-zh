<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Discovering All the Underlying Swift Power</h1></div></div></div><p class="calibre8">In previous chapters, we covered many topics about Swift, its powerful features, and how to improve an application's performance and make a solid application architecture. In this chapter, we will take a look at some tools and cover these topics:</p><div><ul class="itemizedlist"><li class="listitem">How Swift is so fast</li><li class="listitem">The Swift compiler and tools</li><li class="listitem">Analyzing the assembly code</li><li class="listitem">A recap of the important information learned</li><li class="listitem">Feature reading</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec62" class="calibre1"/>How Swift is so fast</h1></div></div></div><p class="calibre8">First, let's have <a id="id448" class="calibre1"/>a quick recap—that is, <em class="calibre10">why Swift is swift</em>—and see what is so special about Swift and its cool features.</p><p class="calibre8">Swift is a strongly typed compiled programming language. This makes it a very safe programming language. Swift is very strict about types, and it verifies that all types are used correctly in the source code. It catches a large number of issues at compile time.</p><p class="calibre8">Swift is also a static programming language. Its source code is compiled to the assembly code and the assembly code is compiled to the machine code using the LLVM tool. Running native machine code instructions is the fastest way of doing this. In comparison, Java and C# are compiled to a piece of intermediate code, and it needs a virtual machine to run it, or another tool that will translate it into machine instructions. Because Swift doesn't do this at runtime, it has a very big performance gain.</p><p class="calibre8">By mixing strongly typed rules and compiling to assembly code, Swift is able to analyze code very well and perform very good assembly code optimization. Swift is also built to be nice to write, with a pleasant and clean syntax and modern features and types. This unique combination of syntax, powerful features, safety, and performance makes Swift a very amazing programming language.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec63" class="calibre1"/>Swift command line tools</h1></div></div></div><p class="calibre8">In this book, we<a id="id449" class="calibre1"/> have already worked with a terminal tool—a Swift REPL console. We<a id="id450" class="calibre1"/> start it by entering the <code class="literal">xcrun swift</code> command in the terminal. It starts the REPL, and we can enter Swift code and evaluate it.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec77" class="calibre1"/>xcrun</h2></div></div></div><p class="calibre8">To start a REPL, we actually used two<a id="id451" class="calibre1"/> tools: <code class="literal">xcrun</code> and <code class="literal">swift</code>. <code class="literal">xcrun</code> is an Xcode command-line tool runner. It helps you run a command-line tool by its name from the active developer directory. When you have installed many versions of Xcode, you can select which one to use while executing a command-line tool. You can do this in Xcode by going to <strong class="calibre9">Xcode</strong> | <strong class="calibre9">Preference</strong> | <strong class="calibre9">Locations</strong> | <strong class="calibre9">Command Line Tools</strong>, or by running the <code class="literal">xcode-select</code> command from the terminal. In this way, <code class="literal">xcrun</code> allows you to avoid specifying the full path in the command-line tool you want to run, and makes the process of running it much simpler.</p><p class="calibre8">
<code class="literal">xcrun</code> has a few more interesting options, and you should experiment with them. To get help, run the <code class="literal">xcrun -h</code> help command, which is usually available for most other command-line tools as well.</p><div><h3 class="title2"><a id="tip39" class="calibre1"/>Tip</h3><p class="calibre8">Some command-line tools require the use of the full command notation: <code class="literal">–help</code>. An example of this is <code class="literal">xcrun --help</code>.</p></div><p class="calibre8">This means that by running the <code class="literal">xcrun swift</code> command, we are actually launching a <code class="literal">swift</code> command-line tool. If you run the <code class="literal">xcrun swift -h</code> command to get help, you will see that <code class="literal">swift</code> is actually a Swift compiler that has many options to choose from.</p><p class="calibre8">The other interesting feature that is available in <code class="literal">xcrun</code> is getting a path to the tool by its name. This is very useful because in this way, we can explore the folder in which this tool is located and find other available tools. As an example, let's see the <code class="literal">swift</code> command-line tool's location. To do this, you need to run the <code class="literal">xcrun -f swift</code> command, and the result is this:</p><div><pre class="programlisting">
<strong class="calibre9">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift</strong>
</pre></div><p class="calibre8">We can simply open this folder from the terminal by changing the directory with <code class="literal">cd</code> and executing the <code class="literal">open .</code> command, which will open the current directory from the terminal in the finder:</p><div><pre class="programlisting">
<strong class="calibre9">cd /Applications ... /usr/bin/</strong>
<strong class="calibre9">open .</strong>
</pre></div><p class="calibre8">In this folder, there are more than 50 different command-line tools available, such as <code class="literal">libtool</code>, <code class="literal">otool</code>, <code class="literal">swift</code>, <code class="literal">swift-demangle</code>, and others. There is also another directory that contains many interesting tools, such as <code class="literal">ibtool</code>, <code class="literal">simctl</code>, and <code class="literal">xcrun</code>:</p><div><pre class="programlisting">
<strong class="calibre9">/Applications/Xcode.app/Contents/Developer/usr/bin</strong>
</pre></div><p class="calibre8">We are not going to cover all of them here; we will leave it as homework for you to play with them and explore their power.</p><p class="calibre8">Another way of discovering <a id="id452" class="calibre1"/>tools that are available for running in the current directory through <code class="literal">xcrun</code> is by starting to type the commands and pressing the <em class="calibre10">Tab</em> key. This will show suggestions from the available commands.</p><div><img src="img/00027.jpeg" alt="xcrun" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec64" class="calibre1"/>The Swift compiler</h1></div></div></div><p class="calibre8">In the previous step, while playing<a id="id453" class="calibre1"/> with <code class="literal">xcrun</code>, we discovered that there are two different swift compiler tools: <code class="literal">swift</code> and <code class="literal">swiftc</code>. If you get help for with the <code class="literal">-h </code>command, you will notice that they are both Swift compilers with similar options, but there is a difference.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec78" class="calibre1"/>swift</h2></div></div></div><p class="calibre8">The <code class="literal">swift</code> tool<a id="id454" class="calibre1"/> compiles and executes swift code. If you run it without any arguments, it will launch a REPL and give you the ability to evaluate the Swift code.</p><div><img src="img/00028.jpeg" alt="swift" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">You can also pass a Swift file that you want to run as a parameter. We can simply create a swift file from the command line:</p><div><pre class="programlisting">
<strong class="calibre9">echo 'print("Hello World")' &gt; main.swift </strong>
<strong class="calibre9">xcrun swift main.swift</strong>
<strong class="calibre9">Hello World</strong>
</pre></div><p class="calibre8">You can also pass<a id="id455" class="calibre1"/> additional options, such as <code class="literal">-O</code> to enable optimization:</p><div><pre class="programlisting">
<strong class="calibre9">xcrun swift -O main.swift</strong>
</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec79" class="calibre1"/>swiftc</h2></div></div></div><p class="calibre8">The <code class="literal">swiftc</code> compiler<a id="id456" class="calibre1"/> compiles swift code and produces the result, but it doesn't execute it. Depending on the option, you can get a binary file, an assembly, an LLVM IR representation, or something else.</p><p class="calibre8">Unlike the swift tool, <code class="literal">swiftc</code> has a one required parameter: an input swift file. If you try to run it without this parameter, you will get an error:</p><div><pre class="programlisting">
<strong class="calibre9">xcrun swiftc</strong>
<strong class="calibre9">&lt;unknown&gt;:0: error: no input files</strong>
</pre></div><p class="calibre8">If you run it and pass a Swift file as a parameter, it will produce an executable file. Let's use the same <code class="literal">main.swift</code> file:</p><div><pre class="programlisting">
<strong class="calibre9">xcrun swiftc main.swift</strong>
</pre></div><p class="calibre8">As a result, you get an executable file with the same name—<code class="literal">main</code>. If you run it, you will get the same output, <code class="literal">Hello World</code>, in the console. The interesting thing about <code class="literal">swiftc</code> is that it allows you to pass many Swift files as input, compile them together, and produce the executable. Let's create one more swift file, called <code class="literal">file.swift</code>, and add this function to it:</p><div><pre class="programlisting">func bye() {
  print("Bye bye")
}</pre></div><p class="calibre8">Now, we will edit our <code class="literal">main.swift</code> file and the call to the <code class="literal">bye()</code> function in it. If we try to compile the <code class="literal">main.swift</code> file now, it will show us an error:</p><div><pre class="programlisting">
<strong class="calibre9">xcrun swiftc main.swift </strong>
<strong class="calibre9">main.swift:2:1: error: use of unresolved identifier 'bye'</strong>
<strong class="calibre9">bye()</strong>
<strong class="calibre9">^</strong>
</pre></div><p class="calibre8">Not surprisingly, the Swift compiler can't find the <code class="literal">bye</code> function declaration and so it fails. What we need to do is compile both the <code class="literal">file.swift</code> and <code class="literal">main.swift</code> files at the same time:</p><div><pre class="programlisting">
<strong class="calibre9">xcrun swiftc main.swift file.swift</strong>
</pre></div><p class="calibre8">The order of the files that you pass to <code class="literal">swiftc</code> is not important; we could have called them as <code class="literal">swiftc file.swift main.swift</code> as well. If you run this executable file now, you will see two sentences in the console:</p><div><pre class="programlisting">
<strong class="calibre9">Hello World</strong>
<strong class="calibre9">Bye bye</strong>

<strong class="calibre9">[Process completed] </strong>
</pre></div><p class="calibre8">Now that you know<a id="id457" class="calibre1"/> how to use a Swift compiler, let's move on to the fun part. Let's use a swift compiler to produce different results. For simplicity, we will merge our swift code with the <code class="literal">main.swift</code> file and add more instructions to get a more interesting result. Here is the final code:</p><div><pre class="programlisting">func bye() {
  print("bye")
}

print("Hello World")

let a = 10
let b = 20
let c = a  + b
print(c)
bye()</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec65" class="calibre1"/>The Swift compilation process and swiftc</h1></div></div></div><p class="calibre8">The compilation of the<a id="id458" class="calibre1"/> Swift<a id="id459" class="calibre1"/> source code is quite an interesting process, and it involves several steps. The Swift compiler uses LLVM for optimization and binary generation. To better understand the entire process, refer to this flow diagram:</p><div><img src="img/00029.jpeg" alt="The Swift compilation process and swiftc" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">First, the Swift source <a id="id460" class="calibre1"/>code is transformed into an <strong class="calibre9">AST</strong> (short for <a id="id461" class="calibre1"/>
<strong class="calibre9">Abstract Syntax Tree</strong>). Then, it is transformed into <strong class="calibre9">SIL</strong>
<a id="id462" class="calibre1"/> (short for <strong class="calibre9">Swift Intermediate Language</strong>), first into a raw SIL and then into a canonical SIL. After that, it is transformed into LLVM <strong class="calibre9">IR</strong>
<a id="id463" class="calibre1"/> (short for <strong class="calibre9">Intermediate Representation</strong>). In this step, LLVM takes care of the rest. It takes IR, does an optimization, and produces an assembly and, after that, an executable for a specific architecture.</p><p class="calibre8">The interesting part in preceding diagram is the steps for generating SIL. It's a Swift-specific optimization and it was created specifically for swift. Other programming languages, such as C, don't do this optimization before they generate LLVM IR, and they have one less optimization step.</p><div><img src="img/00030.jpeg" alt="The Swift compilation process and swiftc" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">With <code class="literal">swiftc</code>, it's possible to generate the results for each of those steps. It's incredibly useful for code optimization analysis. To see all the available modes, just run <code class="literal">xcrun swiftc -h</code>. Now, let's quickly take a look on them.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec80" class="calibre1"/>Swift AST</h2></div></div></div><p class="calibre8">Swiftc has three different options for<a id="id464" class="calibre1"/> generating AST. Each of them generates AST with different levels of details. The AST code representation shows us how the Swift compiler sees and analyzes the code:</p><div><pre class="programlisting">xcrun swiftc -dump-ast main.swift
xcrun swiftc -dump-parse main.swift
xcrun swiftc -print-ast main.swift</pre></div><p class="calibre8">The output of <code class="literal">-dump-ast</code> contains the maximum details, and it could be hard to analyze. Let's take a look at the <code class="literal">-dump-parse</code> example first:</p><div><pre class="programlisting">(source_file
  (var_decl "a" type='&lt;null type&gt;' let storage_kind=stored)
  (top_level_code_decl
    (brace_stmt
      (pattern_binding_decl
        (pattern_named 'a')
        (integer_literal_expr type='&lt;null&gt;' value=10)))</pre></div><p class="calibre8">This AST code represents the <code class="literal">var a = 10</code> Swift code. Each instruction is parsed into a separate tree node and then put together in a tree representation. You can find more information about <a id="id465" class="calibre1"/>Clang's AST at <a class="calibre1" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec81" class="calibre1"/>SIL</h2></div></div></div><p class="calibre8">The <a id="id466" class="calibre1"/>
<strong class="calibre9">Swift Intermediate Language</strong> (<strong class="calibre9">SIL</strong>) is one of the most useful tools for analyzing Swift code. It contains many details and is very readable and easy to analyze. For generating a SIL, xcrun has two modes; <code class="literal">-emit-silgen</code> generates raw SIL and <code class="literal">-emit-sil</code> generates canonical SIL:</p><div><pre class="programlisting">xcrun swiftc -emit-silgen main.swift
xcrun swiftc -emit-sil main.swift</pre></div><p class="calibre8">Raw SIL and canonical SIL are almost the same. Raw SIL is a bit simpler and it doesn't include the details of private function implementations and some global objects. Let's take a look at the generated raw SIL:</p><div><pre class="programlisting">sil_stage raw

import Builtin
import Swift
import SwiftShims

// main.a : Swift.Int
sil_global [let] @_Tv4main1aSi : $Int
...

// main
sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;) -&gt; Int32 {
...
}

// main.bye () -&gt; ()
sil hidden @_TF4main3byeFT_T_ : $@convention(thin) () -&gt; () {...
}

// static Swift.+ infix (Swift.Int, Swift.Int) -&gt; Swift.Int
sil [transparent] [fragile] @_TZFSsoi1pFTSiSi_Si : $@convention(thin) (Int, Int) -&gt; Int</pre></div><p class="calibre8">A really nice feature of <a id="id467" class="calibre1"/>SIL is that it contains comments that explain the generated code. The <code class="literal">let a: Int</code> statement would be translated into <code class="literal">@_Tv4main1aSi : $Int</code> and we can see this from the comment that stays above the generated SIL:</p><div><pre class="programlisting">// main.a : Swift.Int
sil_global @_Tv4main1aSi : $Int</pre></div><p class="calibre8">The SIL represents Swift code in a mangled format. The names contain a lot of information about the type, the count of symbols in the name, and so on. Some mangled names can be very long and really hard to read, such as <code class="literal">_TZvOSs7Process11_unsafeArgvGVSs20UnsafeMutablePointerGS0_VSs4Int8__</code>.</p><p class="calibre8">We can demangle a name back to its normal notation with the <code class="literal">swift-demangle</code> tool. Let's try to demangle <code class="literal">@_Tv4main1aSi</code> and see whether it really translates into <code class="literal">main.a : Swift.Int</code>:</p><div><pre class="programlisting">xcrun swift-demangle _Tv4main1aSi
_Tv4main1aSi ---&gt; main.a : Swift.Int </pre></div><p class="calibre8">If you want to learn more about <a id="id468" class="calibre1"/>name mangling, you can read a great post about it written by Mike Ash at <a class="calibre1" href="https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html">https://mikeash.com/pyblog/friday-qa-2014-08-15-swift-name-mangling.html</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec82" class="calibre1"/>LLVM IR</h2></div></div></div><p class="calibre8">
<strong class="calibre9">Intermediate Representation</strong> (<strong class="calibre9">IR</strong>)<a id="id469" class="calibre1"/> is a more low-level code representation. It is not as human-friendly and<a id="id470" class="calibre1"/> readable as SIL. This is because it has more information for the compiler than for humans. We can use IR to compare different programming languages. To get Swift's IR, use the <code class="literal">-emit-ir</code> options, and to get IR for C, we can use <code class="literal">clang -emit-llvm</code>:</p><div><pre class="programlisting">xcrun swiftc -emit-ir main.swift
clang -S -emit-llvm  main.c -o C-IR.txt</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec83" class="calibre1"/>Other swiftc options</h2></div></div></div><p class="calibre8">The <code class="literal">swiftc</code> compiler is <a id="id471" class="calibre1"/>very powerful and has many more modes and options. You can create an assembly, a binary, a linked library, and object files. You can also specify many options, such as an output file with the <code class="literal">-o</code> option, optimization <code class="literal">-O</code>, <code class="literal">-Onone</code>, and many others:</p><div><pre class="programlisting">xcrun swiftc -emit-assembly main.swift -o assembly</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec66" class="calibre1"/>Analyzing executable files</h1></div></div></div><p class="calibre8">It is very difficult to<a id="id472" class="calibre1"/> analyze the assembly code generated by the swiftc compiler. To make our lives easier, we will use a Hopper Disassembler tool to disassemble executable files, generating a piece of pseudocode and analyzing it. You can download the free version of Hopper<a id="id473" class="calibre1"/> from <a class="calibre1" href="http://www.hopperapp.com">http://www.hopperapp.com</a>.</p><p class="calibre8">The Hopper Disassembler tool can work with binary, executable, and object files. The easiest way of using it is by generating an executable file with the <code class="literal">swiftc main.swift</code> command and opening it in Hopper. You can simply drag and drop the <code class="literal">main</code> executable file to open it in Hopper.</p><div><img src="img/00031.jpeg" alt="Analyzing executable files" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">On the left-hand side, you<a id="id474" class="calibre1"/> can find all the labels for functions and variables and navigate to them. The search feature is very useful when you are analyzing a big project with many functions. In the center is an assembly code; you can press <em class="calibre10">Alt</em> + <em class="calibre10">Enter</em> to see the pseudocode for the current procedure. It is much easier to analyze high-level pseudocode.</p><p class="calibre8">We can also compile an application in Xcode and disassemble our <code class="literal">SimpleApp.app</code> in Hopper. This allows us to analyze very large and complex applications as well.</p><p class="calibre8">As an experiment, let's compile the same swift file in two ways—with optimization enabled and without it—and compare the generated assembly code. Thus, you will see the power of the optimization option:</p><div><pre class="programlisting">swiftc main.swift -O -o mainOptimized</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec67" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter illustrated the Swift compiler, command-line tools, and the process of compilation of the Swift source code. Knowing the available tools and mastering them is very important because it makes you much more productive. Xcode has many tools, and we showed you how to find and use them.</p><p class="calibre8">For analyzing and optimizing Swift code, it's very useful to know and understand the compilation process. In this chapter, we took you through an entire journey of the Swift compiler, starting from the source code and ending with the executable file. We also showed you how to get the result for a specific complication step, such as getting the SIL or IR code representation.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec68" class="calibre1"/>Final thoughts</h1></div></div></div><p class="calibre8">Our learning journey in this book comes to an end, and now you have mastered Swift's techniques for creating high-performance applications. Let's have a quick recap.</p><p class="calibre8">By now, you have learned how to use the power of Swift and optimize your Swift code, but you should remember the main rule of optimization—optimize only when needed, not upfront.</p><p class="calibre8">Solid architecture and well-structured and clean code are two of the most important characteristics of a good application. We have been expressing this throughout the book, and an entire chapter (<a class="calibre1" title="Chapter 2. Making a Good Application Architecture in Swift" href="part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0">Chapter 2</a>, <em class="calibre10">Making a Good Application Architecture in Swift</em>) was dedicated to it.</p><p class="calibre8">Performance optimization doesn't always have to bring much complexity to the source code. Sometimes, applying small changes, such as adding the <code class="literal">@noescape</code> attribute, removing a few <code class="literal">print</code> statements, using the correct data structures, and other techniques presented in the book, could improve performance with no negative effect on the source code. Sometimes, the source code can become even cleaner and more readable; for example, by using <code class="literal">@noescape</code>, we don't need to explicitly specify <code class="literal">self.</code> when referencing instance members.</p><p class="calibre8">Learning Swift's features and tools that are at your disposal before you start creating an application is very important. It is much easier to create a good application from the start by spending some time on planning and preparation than to try to refactor it and fix performance and code architecture issues later.</p><p class="calibre8">Now, you are ready for the journey of creating incredible applications with Swift!</p></div></body></html>