- en: Getting Familiar with Behavioral Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses behavioral patterns with Kotlin. Behavioral patterns
    deal with how objects interact with one another.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how an object can behave in a totally different manner based on the
    situation, how objects can communicate without knowledge of one another, and how
    we can iterate over complex structures easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember *Maronic,* the platformer we were designing in [Chapter 3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7), *Understanding
    Structural Patterns*, while discussing the **Facade** design pattern?
  prefs: []
  type: TYPE_NORMAL
- en: Well, canary Michael, who acts as a game designer in our small indie game development
    company, came up with a great idea. What if we were to give our hero an arsenal
    of weapons to protect us from those horrible carnivorous snails?
  prefs: []
  type: TYPE_NORMAL
- en: 'Weapons all shoot projectiles (you don''t want to get close to those dangerous
    snails) in the direction our hero is facing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All projectiles should have a pair of coordinates (our game is 2D, remember?)
    and a direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to shoot only one type of projectile, that would be simple, since
    we already covered the **Factory** pattern in [Chapter 2](part0054.html#1JFUC0-6704093aa34748cfa77c54bdc1a20dc7),
    *Working with Creational Patterns*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But Michael wants our hero to have at least three different weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peashooter**: Shoots small peas that fly straight. Our hero starts with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pomegranate**: Explodes when hitting an enemy, much like a grenade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Banana**: Returns like a boomerang when it reaches the end of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Come on, Michael, give us some slack! Can't you just stick with regular guns
    that all work the same?!
  prefs: []
  type: TYPE_NORMAL
- en: Fruit arsenal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's discuss how we could solve this in *the Java way*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we would have created an interface, that abstracts the changes. In
    our case, what changes is our hero''s weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then all other weapons would implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our hero would hold a reference to a weapon (`Peashooter` at the beginning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It would delegate the actual shooting process to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s left is the ability to equip another weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And that's what the **Strategy** design pattern is all about. Now, our algorithms
    (Maronic's weapons, in that case) are interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: Citizen function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Kotlin, there's a more efficient way to implement the same functionality
    using fewer classes. That's thanks to the fact that functions in Kotlin are *first-class
    citizens*.
  prefs: []
  type: TYPE_NORMAL
- en: What does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: For one, we can assign functions to the variables of our class, like any other
    normal value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes sense that you can assign a primitive value to your variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You could either assign an object to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, why should you be able to assign a function to your variable? As follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With Kotlin, this is totally valid.
  prefs: []
  type: TYPE_NORMAL
- en: Switching sides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how do higher-order functions help us here?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a namespace for all our weapons. This is not mandatory,
    but helps to keep everything in check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, instead of classes, each of our weapons will become a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting part is our hero. It now holds two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The interchangeable part is `currentWeapon`, while `shoot` is now an anonymous
    function that wraps it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test that our idea works, we can shoot the default weapon once, then switch
    to `Banana` and shoot it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this dramatically reduces the number of classes we have to write,
    while keeping the functionality the same.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were discussing the **Composite** design pattern in the previous chapter,
    we noted that the design pattern felt a bit incomplete. Now is the time to reunite
    the twins separated at birth. Much like Arnold Schwarzenegger and Danny DeVito,
    they're very different, but complement each other well.
  prefs: []
  type: TYPE_NORMAL
- en: One, two... many
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re back to our squads and platoons in our *CatsCraft 2: Revenge of the
    Dogs* strategy game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember from the previous chapter, `Squad` consists of `InfantryUnits`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each squad should also get a commander now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commander of a squad called `Sergeant` is also an `InfantryUnit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Please disregard the fact that our sergeant doesn't have a name and gets created
    on the fly. We're two days short of releasing this game and beating the competition.
    Names are not important now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The platoon is a collection of squads, and it also has a commander, called `Lieutenant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What our CEO wants is a platoon, and to be able to know which units it consists
    of.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when we have the following lines in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We would print by order of seniority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Nowadays, this task may seem trivial to you, especially if you come from the
    Java world. But back in '94, data structures were mostly arrays of primitive types.
    Yes, `Array<Int>`, I'm looking at you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating over an array wouldn''t be that hard, even in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What are we to do with something much more complex?
  prefs: []
  type: TYPE_NORMAL
- en: Running through the values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''re using an IDE such as IntelliJ, it will give you a hint on what the
    problem may be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, our Platoon needs to have a function called `iterator()`. And since it's
    a special function, we'll need to use the `operator` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What our function returns is an anonymous object that implements the `Iterator<T>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea behind the iterator design pattern is to separate how the object stores
    data (in our case, it''s something like a tree) and how we can go over this data.
    As you may know, trees can be iterated in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: depth-first (also known as **depth-first search** (**DFS**))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: breadth-first (also known as **breadth-first search** (**BFS**))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But do we really care when we need to fetch all the elements?
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we separate these two concerns: storage aside, repeating aside.'
  prefs: []
  type: TYPE_NORMAL
- en: To go over all the elements, we need to implement two methods, one to fetch
    the next element, and one to let the loop know when to stop.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we'll implement this object for `Squad`. For Platoon, the logic
    would be similar, but requires a bit more math.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a state for our iterator. It will remember that the last element
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to tell it when to stop. In our case, the total number of elements
    is all the units of the squad, plus the sergeant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to know which unit to return. If that was the first call,
    we''ll return the sergeant. The next calls will return one of the squad members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that we want to return the next unit, but also to increase our counter.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we use the also `{}` block.
  prefs: []
  type: TYPE_NORMAL
- en: That's only one of the usages of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The same object may also have more than one iterator. For example, we could
    have the second iterator for our squad that would go over elements in reverse
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we''ll need to call it by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it''s just a simple function that returns an iterator now, we don''t
    need the `operator` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The only changes are coming in the `next()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it also makes sense to receive an iterator as a parameter for a
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will iterate over anything that supplies an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will print our squad members twice, once in regular and once in reverse
    order.
  prefs: []
  type: TYPE_NORMAL
- en: As a regular developer who doesn't invent new data structures for his or her
    living, you may now implement iterators often. But it's important to know how
    they work behind the scenes nevertheless.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of the **State** design pattern as an opinionated Strategy, which
    we discuss at the beginning of this chapter. But while Strategy is changed from
    the outside, by the *client*, the State may change internally, based solely on
    the input it gets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this dialog a client wrote with Strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Client: Here’s a new thing to do, start doing it from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strategy: OK, no problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client: What I like about you is that you never argue with me.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare it with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client: Here’s some new input I got from you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'State: Oh, I don''t know. Maybe I''ll start doing something differently. Maybe
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client should also expect that the State may even reject some of its inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client: Here''s something for you to ponder, State.'
  prefs: []
  type: TYPE_NORMAL
- en: 'State: I don''t know what it is! Don''t you see I''m busy? Go bother some Strategy
    with this!'
  prefs: []
  type: TYPE_NORMAL
- en: So, why do clients still tolerate that State of ours? Well, State is really
    good at keeping everything under control.
  prefs: []
  type: TYPE_NORMAL
- en: Fifty shades of State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Carnivorous snails have had enough of this Maronic hero. He throws peas and
    bananas at them, only to get to another sorry castle. Now they shall act!
  prefs: []
  type: TYPE_NORMAL
- en: By default, the snail should stand still to conserve snail energy. But when
    the hero gets close, it dashes towards him aggressively.
  prefs: []
  type: TYPE_NORMAL
- en: If the hero manages to injure it, it should retreat to lick its wounds. Then
    it will repeat attacking, until one of them is dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll declare what can happen during a snail''s life:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our snail implements this interface, so it can get notified of anything that
    may happen to it and act accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we declare the `Mood` class, which we mark with the `sealed` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Sealed classes are abstract and cannot be instantiated. We''ll see the benefit
    of using them in a moment. But before that, let''s declare other states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Those are all different states, sorry, moods, of our snail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In State design pattern terms, `Snail` is the context. It holds the state.
    So, we declare a member for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define what `Snail` should do when it sees our hero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Compilation error! Well, that's where the `sealed` class comes into play. Much
    like with an `enum`, Kotlin knows that there's a finite number of classes that
    extend from it. So, it requires that our `when` is exhaustive and specifies all
    different cases in it.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using IntelliJ as your IDE, it will even suggest you "add remaining
    branches" automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, `else` still works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When the snail gets hit, we need to decide if it''s dead or not. For that,
    we can use `when` without an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `is` keyword, which is the same as `instanceof` in Java,
    but more concise.
  prefs: []
  type: TYPE_NORMAL
- en: State of the Nation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous approach has most of the logic in our *context*. You may sometimes see
    a different approach, which is valid as your *context* grows bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this approach, `Snail` would become really thin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that we marked `mood` as `internal`. That lets other classes in that package
    alter it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of `Snail` implementing `WhatCanHappen`, our Mood will:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the logic resides within our state objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that our state objects now receive a reference to their context in the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the first time we''ve met the `run` extension function. It''s equivalent
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By using run, we can preserve the same logic, but omit the function body.
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to decide what approach to use. In our example, this will actually
    produce much more code, will have to implement all the methods by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern allows you to encapsulate action inside an object to be
    executed sometime later.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if we can execute one action later on, why not execute many? Why
    not schedule exactly when to execute?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s exactly what we need to do in our *CatsCraft 2: Revenge of the Dogs* game
    now*. *Dave, a new developer that we''ve hired lately, was working hard the whole
    weekend, while no one was allowed to bother him. He implemented the following
    abstract methods for our furry soldiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: He probably even used the **Bridge** design pattern from the previous chapter
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem we need to solve now is that the soldier can remember exactly one
    *command*. That''s it. If he starts at `(0, 0)`, the top of the screen, we first
    tell him to `move(20, 0)`, that''s 20 steps right, and then to `move(20, 20)`,
    so he''ll move straight to `(20, 20)`, and will probably get totally destroyed,
    because there are dog enemies to avoid at all costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you've been following this book from the start, or at least joined at [Chapter
    3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7), *Understanding Structural
    Patterns*, you probably have an idea of what we need to do, since we already discussed
    the concept of *functions as first-class citizens* in the language.
  prefs: []
  type: TYPE_NORMAL
- en: But even if you decided to just figure out how the Command design pattern should
    work in Kotlin, or opened this book randomly to this section, we'll give you a
    brief explanation on how that dog obstacle could be solved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sketch a skeleton for that. We know that we want to hold a list of objects,
    but we don''t know yet what type they should be. So we''ll use `Any` for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to iterate over the list and execute the orders we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So, even if you''re not familiar with the Command design pattern, you can guess
    that we can define an interface with a single method, `execute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And then hold a list of the same time in a member property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Implement this interface as needed. That's basically what the Java implementation
    of this pattern would suggest in most cases. But isn't there a better way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the Command again. Its `execute()` method receives nothing,
    returns nothing, and does something. It''s the same as writing the following code
    then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not different at all. We could simplify this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having an interface for that called `Command`, we''ll have a `typealias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this line stops compiling again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that''s because `execute()` is just some name we invented. In Kotlin,
    functions use `invoke()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That's nice, but the functions Dave wrote receive arguments, and our function
    has no parameters at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option would be to change the signature of our `Command` to receive two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: But what if some commands receive no arguments, or only one, or more than two?
    We also need to remember what to pass to `invoke()` at each step.
  prefs: []
  type: TYPE_NORMAL
- en: A much better way is to have a function generator. That is, a function that
    returns another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever worked with JavaScript language, that''s a common practice to use
    closures to limit the scope and *remember* stuff. We''ll do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When called with proper arguments, `moveGenerator` will return a new function.
    That function can be invoked whenever we find it suitable, and it will *remember*:'
  prefs: []
  type: TYPE_NORMAL
- en: What method to call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With which arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On which object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, our `Soldier` may have a method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'It provides us with a nice fluent syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Undoing commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While not directly related, one of the advantages of the Command design pattern
    is the ability to undo commands. What if we wanted to support such a functionality?
  prefs: []
  type: TYPE_NORMAL
- en: 'Undoing is usually very tricky, because it involves one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the previous state (impossible if there's more than one client,
    requires a lot of memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing deltas (tricky to implement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining opposite operations (not always possible)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, the opposite of the command *move from (0,0) to (0, 20)* would
    be *move from wherever you''re now to (0,0)*. This could be achieved by storing
    a pair of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add pairs of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Actually, computing the opposite move is quite complex, as we don't save the
    position of our soldier currently (it was something Dave should have implemented
    anyway), and we'll also have to deal with some edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm a horrible software architect, and I don't like to speak with people. Hence,
    while sitting in The Ivory Tower (that's the name of the cafe I often visit),
    I wrote a small web application. If a developer has a question, he shouldn't approach
    me directly, oh no. He'll need to send me a proper request through this system,
    and I shall answer him only if I deem this request worthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A filter chain is a very common concept in web servers. Usually, when a request
    reaches to you, it''s expected that:'
  prefs: []
  type: TYPE_NORMAL
- en: Its parameters are already validated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user is already authenticated, if possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User roles and permissions are known, and the user is authorized to perform
    an action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the code I initially wrote looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: A bit messy, but it works.
  prefs: []
  type: TYPE_NORMAL
- en: Then I noticed that some developers decide they can send me two questions at
    once. Gotta add some more logic to this function. But wait, I'm an architect,
    after all. Isn't there a better way to *delegate* this?
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we won''t learn new Kotlin tricks, but use those that we already
    learned. We could start with implementing an interface such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We never discussed what my response to one of the developers looked like. That''s
    because I keep my chain of responsibility so long and complex that usually, they
    tend to solve problems by themselves. I''ve never had to answer one of them, quite
    frankly. But at least we know what their requests look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we could do it the Java way, and start implementing each piece of logic
    inside its own handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Other filters would look very similar to this one. We can compose them in any
    order we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'But I won''t even ask you the rhetoric question this time about better ways.
    Of course there''s a better way, we''re in the Kotlin world now. And we''ve seen
    the usage of functions in the previous section. So, we''ll define a function for
    that task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Why have a separate class and interface for something that receives a request
    and returns a response in a nutshell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, `authentication` is a function that literally receives a function and
    returns a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we can compose those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: It's up to you which method you choose. Using interfaces is more explicit, and
    would better suit you if you're creating your own library or framework that others
    may want to extend.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions is more concise, and if you just want to split your code in
    a more manageable way, it may be the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern may seem very simple or very hard, all based on how much
    background you have in computer science. Some books that discuss classical software
    design patterns even decide to omit it altogether, or put it somewhere at the
    end, for curious readers only.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind this is that the interpreter design pattern deals with translating
    certain languages. But why would we need that? Don't we have compilers to do that
    anyway?
  prefs: []
  type: TYPE_NORMAL
- en: We need to go deeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we discuss that all developers have to speak many languages
    or sub-languages. Even as regular developers, we use more than one language. Think
    of tools that build your projects, like Maven or Gradle. You can consider their
    configuration files, **build scripts**, as languages with specific grammar. If
    you put elements out of order, your project won't be built correctly. And that's
    because such projects have interpreters to analyze configuration files and act
    upon them.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples would be **query languages**, be it one of the SQL variations
    or one of the languages specific to NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: If you're an Android developer, you may think of XML layouts as such languages
    too. Even HTML could be considered a language that defines **user interfaces**.
    And there are others, of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe you''ve worked with one of the **testing frameworks** that define a custom
    language for testing, such as Cucumber: [github.com/cucumber](https://github.com/cucumber).'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these examples can be called a **Domain Specific Language** (**DSL**).
    A language inside a language. We'll discuss how it works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A language of your own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll define a simple DSL-for-SQL language. We won''t define
    the format or grammar for it, but only an example of what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The goal of our language is to improve readability and prevent some common SQL
    mistakes, such as typos (like FORM instead of FROM). We'll get compile time validations
    and autocompletion along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the easiest part—`select`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We could write this using single expression notation, but we use the more verbose
    version for clarity of the example.
  prefs: []
  type: TYPE_NORMAL
- en: This is a function that has two parameters. The first is a `String`, which is
    simple. The second is another function that receives nothing and returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting part is that we specify the receiver for our lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very smart trick, so be sure to follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Although it may seem that this lambda receives nothing, it actually receives
    one argument, an object of type `SelectClause`.
  prefs: []
  type: TYPE_NORMAL
- en: The second trick lies in the usage of the `apply()` function we've seen before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It translates to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the steps the preceding code will perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize `SelectClause`, which is a simple object that receives one argument
    in its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `from()` function with an instance of `SelectClause` as its only argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return an instance of `SelectClause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That code only makes sense if `from()` does something useful with `SelectClause`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our DSL example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We've made the receiver explicit now, meaning that the `from()` function will
    call the `from()` method on the `SelectClause` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start guessing what this method looks like. It clearly receives a `String`
    as its first argument, and another lambda as its second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This could again be shortened, but then we'd need to use `apply()` within `apply()`,
    which may seem confusing at this point.
  prefs: []
  type: TYPE_NORMAL
- en: That's the first time we've met the `lateinit` keyword. This keyword is quite
    dangerous, so use it with some restraint. Remember that the Kotlin compiler is
    very serious about null safety. If we omit `lateinit`, it will require us to initialize
    the variable with a default value. But since we'll know it only at a later time,
    we ask the compiler to relax a bit. Note that if we don't make good on our promises
    and forget to initialize it, we'll get `UninitializedPropertyAccessException` when
    first accessing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our code; all we do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of `FromClause`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store it as a member of `SelectClause`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass an instance of `FromClause` to the `where` lambda
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return an instance of `FromClause`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hopefully, you''re starting to get the gist of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'What does it mean? After understanding the `from()` method, this should be
    much simpler. The `FromClause` must have a method called `where()` that receives
    one argument, of the `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note that we made good on our promise and shortened the method this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialized an instance of `WhereClause` with the string we received, and
    returned it. Simple as that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '`WhereClause` only prints the word `WHERE` and the conditions it received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`FromClause` prints the word `FROM` as well as the table name it received,
    and everything `WhereClause` printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`SelectClause` prints the word `SELECT`, the columns it got, and whatever `FromClause`
    printed.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking a break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin provides beautiful capabilities to create readable and type-safe DSLs.
    But the interpreter design pattern is one of the hardest in the toolbox. If you
    didn't get it from the get-go, take some time to debug this code. Understand what
    `this` means at each step, as well as when we call a function and when we call
    a method of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Call suffix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order not to confuse you, we left out one last notion of Kotlin DSL until
    the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This is common practice in Kotlin. If our function receives another function
    as its last argument, we can pass it out of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: This results in a much clearer DSL, but may be confusing at first.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's no way around it. The **Mediator** design pattern is simply a control
    freak. It doesn't like it when one object speaks to the other directly. It gets
    mad sometimes when that happens. No, everybody should speak only through him.
    What's his explanation? It reduces coupling between objects. Instead of knowing
    some other objects, everybody should know only him, the Mediator.
  prefs: []
  type: TYPE_NORMAL
- en: Trouble in the Jungle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architectural jokes aside, we, the *Maronic* development team, have some real
    problems. And they're not related to code directly. As you may remember, our little
    indie company consists of only me, a canary named Michael that acts as a product
    manager, and two cat designers that sleep most of the day, but do produce some
    decent mockups from time to time. We have no QA (that's quality assurance guys)
    whatsoever. Maybe that's one of the reasons our game keeps crashing all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lately, Michael has introduced me to a parrot named `Kenny`, who happens to
    be QA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This section will use objects for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parrot QAs are very motivated. They''re ready to test the latest version of
    my game any time. But they really don''t like to be bothered when they are either
    sleeping or eating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In case `Kenny` had any questions, I gave him my direct number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`Kenny` was a hard-working parrot. But we had so many bugs that we also had
    to hire a second parrot QA, Brad. If `Kenny` is free, I give the job to him, as
    he''s more acquainted with our project. But if he''s busy, I check if Brad is
    free, and give this task to him:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '`Brad`, being more junior, usually checks up with `Kenny` first. And `Kenny`
    also gave my number to him:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Then Brad introduces me to `George`. `George` is an owl, so he sleeps at different
    times than `Kenny` and Brad. That means that he can check my code at night. The
    problem is, `George` is an avid football fan. So before calling him, we need to
    check if he''s watching a game now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '`Kenny` as a habit checks with `George` too, because `George` is a very knowledgeable
    owl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'And `George` checks with `Kenny`, because `Kenny` is also into football, it
    seems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`George` loves to call me during the night with his questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then there''s `Sandra`. She''s a different kind of bird, because she''s not
    a QA, but a copywriter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'I try not to bother her, unless it''s a major release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, now I have a few problems:'
  prefs: []
  type: TYPE_NORMAL
- en: First, my mind almost explodes trying to remember all those names. So might
    yours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, I also need to remember how to interact with each one. I'm the one doing
    all the checks before calling them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, notice how George tries to confirm everything with Kenny, and Kenny with
    George? Luckily, up until now, George is always watching a football game when
    Kenny calls him. And Kenny is asleep when George needs to confirm something with
    him. Otherwise, they would get stuck on the phone for eternity...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, and what bothers me the most, is that Kenny plans to leave soon to open
    his own startup, ParrotPi. Imagine all the code we'll have to change now!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All I want to do is to check if everything is alright with my code. Someone
    else should do all this talking!
  prefs: []
  type: TYPE_NORMAL
- en: The middleman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, I decided that Michael should manage all those processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Only he will know all the other *birds*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll remember only him, and he''ll do the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll also change my phone number, and make sure that everybody gets only Michael''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Now, if somebody needs somebody else's opinion, they need to go through Michael
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Flavors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two *flavors* to Mediator. We'll call them *strict* and *loose*. The
    strict version we've seen previously. We tell Mediator exactly what to do, and
    expect an answer from it.
  prefs: []
  type: TYPE_NORMAL
- en: The *loose* version will expect us to notify Mediator of what happened, but
    not to expect an immediate answer. Instead, if he needs to notify us in return,
    he should call us instead.
  prefs: []
  type: TYPE_NORMAL
- en: Caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Michael suddenly becomes ever so important. Everybody knows only him, and only
    he can manage their interactions. He may even become a *God Object*, all-knowing
    and almighty, which is an antipattern from [Chapter 9](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7),
    *Designed for Concurrency*. Even if he's so important, be sure to define what
    this Mediator should, and, even more importantly, what it shouldn't, do.
  prefs: []
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Michael became a manager, it's been very hard to catch him if I have a
    question. And when I do ask him something, he just throws something and runs to
    the next meeting.
  prefs: []
  type: TYPE_NORMAL
- en: Yesterday, I asked him what the next weapon we would introduce in our *Maronic*
    game should be. He told me it should be a Coconut Cannon, clear as day. But today,
    when I presented him with this feature, he chirped at me angrily! He said he told
    me to implement a Pineapple Launcher instead. I'm lucky he's just a canary still...
  prefs: []
  type: TYPE_NORMAL
- en: But it would be great if I could just record him, and when we have another meeting
    that goes awry because he's not paying full attention, I would just replay everything
    he said.
  prefs: []
  type: TYPE_NORMAL
- en: Remembrance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Summing up my problems first—Michael''s thoughts are his and his only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, they''re quite complex and scattered. I have no access to them, but
    only to their byproduct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Even recording what he says is quite hard (because he doesn't return anything).
  prefs: []
  type: TYPE_NORMAL
- en: 'And even if I did record him, Michael can claim it''s what he said, not what
    he meant:'
  prefs: []
  type: TYPE_NORMAL
- en: Why did you bring me tea? I wanted coffee!
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution may seem quite obvious. Let''s use an inner class, thought, that
    will capture this last thought:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The only problem is that this code doesn't compile. It's because we're missing
    a new keyword, `inner`, to mark our class. If we omit this keyword, the class
    is called `Nested`, and is similar to the static nested class from Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can *record* what Michael says at this moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that Michael changes his mind at some point. We''ll add another
    function for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can always repeat the thought that we captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check what we''ve captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even rewind Michael''s thoughts if he would allow it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Note how here we use the `with` standard function to avoid repeating `previousThought`
    on each line.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern is usually a close friend of the **Composite** design pattern
    that we discussed in [Chapter 3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7), *Understanding
    Structural Patterns*. It can either extract data from a complex tree-like structure
    or add behavior to each node of the tree, much like the **Decorator** design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: So, my plan, being a lazy software architect, worked out quite well. Both my
    mail-sending system from **Builder** and my request-answering system from **Chain
    of Responsibility** worked quite well. But some developers still begin to suspect
    that I'm a bit of a fraud.
  prefs: []
  type: TYPE_NORMAL
- en: To confuse them, I plan to produce weekly emails with links to all the latest
    buzzword articles. Of course, I don't plan to read them myself, just collect them
    from some popular technology sites.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a crawler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following structure, which is very similar to what we had
    when discussing the **Iterator** design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The `Page` is a container for other `HtmlElements`, but not `HtmlElement` by
    itself. `Container` holds other containers, tables, links, and images. `Image`
    holds its link in the `src` attribute. `Link` has the `href` attribute instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a function that will receive the root of our object tree,
    a `Page` in this case, and return a list of all available links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Using `run` allows us to control what we return from the block body. In this
    case, we would return the `links` we've gathered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, the suggested way to implement the **Visitor** design pattern is to
    add a method for each class that would accept our new functionality. We''ll do
    the same, but not for all classes. Instead, we''ll define this method only for
    container elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Our feature will need to hold a collection internally, and expose it only for
    read purposes. In Java, we would specify only the getter and no setter for that
    member. In Kotlin, we can specify the value without a backing field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: We wish for our data structure to be immutable. That's the reason we're calling
    `toList()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: The functions that iterate over branches could be further simplified if we use
    the **Iterator** design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'For containers, we simply pass their elements further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying the parent class as `sealed` helps the compiler further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting logic is in the leaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Note that in some cases, we don't want to do anything. That's specified by an
    empty block in our else: `else -> {}`.
  prefs: []
  type: TYPE_NORMAL
- en: That's the first time we've seen **smart casts** in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that after we checked that the element is a `Link`, we gained type-safe
    access to its `href` attribute. That's because the compiler is doing the casts
    for us. The same holds true for the `Image` element as well.
  prefs: []
  type: TYPE_NORMAL
- en: Although we achieved our goals, the usability of this pattern can be argued.
    As you can see, it's one of the more verbose elements, and introduces tight coupling
    between classes receiving additional behavior and Visitor itself.
  prefs: []
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some lazy people make art out of their laziness. Take me for example. Here''s
    my daily schedule:'
  prefs: []
  type: TYPE_NORMAL
- en: '8:00–9:00: Arrive at the office'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9:00–10:00: Drink coffee'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '10:00–12:00: Attend some meetings or review code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '12:00–13:00: Go out for lunch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 13:00–16:00: Attend some meetings or review code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '16:00: Sneak out home'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, some of the parts of the schedule never change, and some do.
    At first, I thought I could *decorate* my changing schedule with that `setup`
    and `teardown` logic, which happens *before* and *after*. But then there's lunch,
    which is holy for architects and happens *in between*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java is pretty clear on what you should do. First, you create an abstract class.
    All methods that you want to implement by yourself you mark as private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'For all methods that are changing from day to day, you define an abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'If you allow the changing of a method, but want to provide a default implementation,
    you leave it public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, you have a method that executes your algorithm. It''s final by
    default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now want to have a schedule for Monday, we simply implement the missing
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: What does Kotlin add on top of that? What it usually does—conciseness. As we've
    seen previously, this can be achieved through functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three *moving parts*—two mandatory activities (the software architect
    must do something before and after lunch) and one optional (the boss may stop
    him before he sneaks off home or not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have a function that accepts up to three other functions as its arguments.
    The first two are mandatory, and the third may not be supplied at all, or assigned
    with `null` to explicitly state that we don''t want that function to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Inside this function, we'll have our algorithm. Invocations of `beforeLunch()`
    and `afterLunch()` should be clear; after all, those are the functions that are
    passed to us as arguments. The third one, bossHook, may be null, so we execute
    it only if it's not: `?.let { it() }`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about the other functions, those we want to always implement by ourselves?
    Kotlin has a notion of local functions. Those are functions that reside in other
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Those are all valid ways to declare a local function. No matter how you define
    them, they're invoked in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re left with the same result, as you can see. Define the algorithm structure,
    but let others decide what to do at some points: that''s what the Template Method
    is all about.'
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably one of the highlights of this chapter, this design pattern will provide
    us with a bridge to the following chapters, dedicated to functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is Observer pattern about? You have one *publisher*, which may also
    be called a *subject*, that may have many *subscribers*, which may also be called *observers*.
    Each time something interesting happens with the publisher, it should update all
    of its subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: This may look a lot like the Mediator design pattern, but there's a twist. Subscribers
    should be able to register or unregister themselves at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the classical implementation, all subscribers/observers need to implement
    a certain interface in order for the publisher to be able to update them. But
    since Kotlin has higher-order functions, we can omit this part. The publisher
    will still have to provide means for observers to be able to subscribe and unsubscribe.
  prefs: []
  type: TYPE_NORMAL
- en: Animal Choir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, animals have decided to have a choir of their own. The cat was elected as
    the conductor of the choir (it didn't like to sing anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that animals escaped from the Java world, and don''t have a
    common interface. Instead, each has a different method to make a sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, the cat was elected not only because it was vocally challenged, but
    also because it was smart enough to follow this chapter until now. So it knows
    that in the Kotlin world, it can accept functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we've seen how to pass a new function as an argument, as well as
    passing a literal function. But how do we pass a reference to a member function?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s what member reference operator is for—`::`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the cat needs to save all those subscribers somehow. Luckily, we can put
    them on a map. What would be the key? It could be the function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: If all those `()->Unit` instances are making you dizzy, be sure to use `typealias`
    to give them more semantic meaning, such as subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bat decides to leave the choir. After all, no one is able to hear its beautiful
    singing anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'All `Bat` needs to do is to pass its subscriber function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the reason we used the map in the first place. Now `Cat` can call all
    its choir members and tell them to sing. Well, produce sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The rehearsal went well. But `Cat` feels very tired after doing all those loops.
    It would rather delegate the job to choir members. That''s not a problem at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Our subscribers all look like turkeys here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, it is a bit of a problem. What if the `Cat` was to tell each animal
    what sound to make: high or low? We''ll have to change all subscribers again,
    and the `Cat` too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While designing your publisher, pass single data classes with many properties,
    instead of sets of data classes or other types. That way, you''ll have to refactor
    your subscribers less, in case new properties are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that your messages are immutable. Otherwise, you may experience strange
    behavior!
  prefs: []
  type: TYPE_NORMAL
- en: What if you have sets of different messages you're sending from the same publisher?
  prefs: []
  type: TYPE_NORMAL
- en: 'Use smart casts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a long chapter. But we've also learned a lot. We finished covering
    all classical design patterns, including eleven behavioral ones. In Kotlin, functions
    can be passed to other functions, returned from functions, and assigned to variables.
    That's what the "functions as first-class citizens" concept is all about. If your
    class is all about behavior, it often makes sense to replace it with a function. Iterator
    is yet another `operator` in the language. Sealed classes help in making `when`
    statements exhaustive. The `run` extension function allows for controlling what
    will be returned from it. A lambda with a receiver allows more clear syntax in
    your DSLs. Another keyword, `lateinit`, tells the compiler to relax a bit in its
    null safety checks. Use with care! And finally, we covered how to reference an
    existing method with `::`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll move on from an object-oriented programming paradigm
    with its well-known design patterns to another paradigm—functional programming.
  prefs: []
  type: TYPE_NORMAL
