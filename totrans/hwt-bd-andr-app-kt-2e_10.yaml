- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Tests and Integration Tests with JUnit, Mockito, and Espresso
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about testing on the Android platform and how
    to create unit tests, integration tests, and UI tests. You will see how to create
    each of these types of tests, analyze how they run, and work with frameworks such
    as JUnit, Mockito, Robolectric, and Espresso.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn about test-driven development (TDD), a software development
    practice that prioritizes tests over implementation. By the end of this chapter,
    you will be able to combine your new testing skills to work on a realistic project.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, you learned about how to load background data and display
    it in the UI and how to set up API calls to retrieve data. But how can you be
    sure that things work well? What if you’re in a situation where you have to fix
    a bug in a project that you haven’t interacted much with in the past? How can
    you know that the fix you are applying won’t trigger another bug? The answer to
    these questions is through tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will analyze the types of tests developers can write and
    we will look at available testing tools to ease the testing experience. The first
    issue that arises is the fact that desktops or laptops (which have different operating
    systems) are used to develop mobile applications. This implies that the tests
    must also be run on the device or an emulator, which will slow the tests down.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this issue, we are presented with two types of tests: `test` folder
    and will run on your machine, and `androidTest` folder and will run on the device
    or emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio testing tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/pNbuk](https://packt.link/pNbuk)
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both tests rely on the Java **JUnit** library, which helps developers set up
    their tests and group them into different categories. It also provides different
    configuration options, as well as extensions that other libraries can build upon.
    We will also investigate the testing pyramid, which helps guide developers as
    to how to structure their tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start at the bottom of the pyramid, which is represented by **unit
    tests**, move upward through **integration tests**, and finally, reach the top,
    which is represented by **end-to-end tests** (UI tests). You’ll have the opportunity
    to learn about the tools that aid in writing each of these types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mockito-kotlin`, which help mainly in unit tests and are useful for creating
    mocks or test doubles in which we can manipulate inputs so that we can assert
    different scenarios. (A mock or test double is an object that mimics the implementation
    of another object. Every time a test interacts with mocks, you can specify the
    behavior of these interactions.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robolectric**, which is an open source library that brings the Android framework
    onto your machine, allows you to test activities and fragments locally and not
    on the emulator. This can be used for both unit tests and integration tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditText` components, and so on) and assertions (verifying that views display
    certain text, are currently being displayed to the user, are enabled, and so on)
    on an app’s UI in an instrumented test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will also look at **TDD**. This is a software development
    process where tests take priority. A simple way of describing it is writing the
    test first. We will analyze how this approach is taken when developing features
    for Android applications. One of the things to keep in mind is that for an application
    to be properly tested, its classes must be properly written. One way to do this
    is by clearly defining the boundaries between your classes and splitting them
    based on the tasks you want them to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have achieved this, you can also rely on the **dependency inversion**
    and **dependency injection** principles when writing your classes. When these
    principles are applied properly, you should be able to inject fake objects into
    the subjects of your tests and manipulate the input to suit your testing scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection also helps when writing instrumented tests to help you
    swap modules that make network calls with local data in order to make your tests
    independent of external factors, such as networks. Instrumented tests are tests
    that run on a device or an emulator. The `instrument` keyword comes from the instrumentation
    framework, which assembles these tests and then executes them on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, each application should have three types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These are local tests that validate individual classes and
    methods. They should represent most of your tests and they should be fast, easy
    to debug, and easy to maintain. They are also known as small tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: These are either local tests with Robolectric or instrumented
    tests that validate interactions between your app’s modules and components. These
    are slower and more complex than unit tests. The increase in complexity is due
    to the interaction between the components. These are also known as medium tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI tests (end-to-end tests)**: These are instrumented tests that verify complete
    user journeys and scenarios. This makes them more complex and harder to maintain;
    they should represent the smallest number of your total test number. These are
    also known as large tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can observe the **testing pyramid**. The recommendation
    from Google is to keep a ratio of 70:20:10 (unit tests: integration tests: UI
    tests) for your tests:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.1 – Test\uFEFFing pyramid](img/B19411_10_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Testing pyramid
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, a unit test is a test that verifies a
    small portion of your code, and most of your tests should be unit tests that cover
    all sorts of scenarios (success, errors, limits, and more). Ideally, these tests
    should be local, but there are a few exceptions where you can make them instrumented.
    Those cases are rare and should be limited to when you want to interact with specific
    hardware of the device.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUnit is a framework for writing unit tests both in Java and Android. It is
    responsible for how tests are executed, allowing developers to configure their
    tests. It offers a multitude of features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Before` and `@``After` annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertions**: These are used to verify the result of an operation against
    an expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rules**: These allow developers to set up inputs that are common for multiple
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runners**: Using these, you can specify how the tests can be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: These allow a test method to be executed with multiple inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orderings**: These specify in which order the tests should be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matchers**: These allow you to define patterns that can then be used to validate
    the results of the subject of your tests, or help you control the behavior of
    mocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Android Studio, when a new project is created, the `app` module comes with
    the JUnit library in Gradle. This should be visible in `app/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the following class that we need to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This method should return the factorial of the number `n`. We can start with
    a simple test that checks the value. To create a new unit test, you will need
    to create a new class in the `test` directory of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical convention most developers follow is to add the `Test` suffix to
    your class name and place it under the same package in the `test` directory. For
    example, `com.mypackage.ClassA` will have the test in `com.mypackage.ClassATest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, you can see that we initialize the class under test, and the
    test method itself is annotated with the `@Test` annotation. The test method itself
    will assert that `(3!)==6`. The assertion is done using the `assertEquals` method
    from the JUnit library. A common practice in development is to split the test
    into three areas, also known as **Arrange-Act-Assert** (**AAA**):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: Where the input is initialized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: Where the method under test is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: Where the verification is done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write another test to make sure that the value is correct, but we will
    end up duplicating the code. We can now attempt to write a parameterized test.
    To do this, we will need to use the parameterized test runner. The preceding test
    has its own built-in runner provided by JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameterized runner will run the test repeatedly for different values
    that we provide, and it will look like the following – please note that `import`
    statements have been removed for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will run six tests. The usage of the `@Parameterized` annotation tells
    JUnit that this is a test with multiple parameters and allows us to add a constructor
    for the test that will represent the input value for our `factorial` function
    and the output. We then defined a collection of parameters with the use of the
    `@``Parameterized.Parameters` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Each parameter for this test is a separate list containing the input and the
    expected output. When JUnit runs this test, it will run a new instance for each
    parameter and then execute the test method. This will produce five successes and
    one failure when we test `0!`, meaning that we have found a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'We never accounted for a situation when `n = 0`. Now, we can go back to our
    code to fix the failure. We can do this by replacing the `reduce` function, which
    doesn’t allow us to specify an initial value, with a `fold` function, which allows
    us to give the initial value of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running the tests now, they will all pass. But that doesn’t mean we are done
    here. There are many things that can go wrong. What happens if `n` is a negative
    number? Since we are dealing with factorials, we may get large numbers. We are
    working with integers in our examples, which means that the integer will overflow
    after `12!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, we would create new test methods in the `MyClassTest` class, but
    since the parameterized runner is used, all our new methods will be run multiple
    times, which will cost us time, so we will create a new test class to check our
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This would lead to the following change in the class that was tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s solve the issue with very large factorials. We can use the `BigInteger`
    class, which can hold large numbers. We can update the test as follows (`import`
    statements not shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class under test now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we implemented the factorial with the help of `IntArray`.
    This implementation is based more on Kotlin’s ability to chain methods together,
    but it has one drawback: the fact that it uses memory for the array when it doesn’t
    need to.'
  prefs: []
  type: TYPE_NORMAL
- en: We only care about the factorial and not storing all the numbers from `1` to
    `n`. We can change the implementation to a simple `for` loop and use the tests
    to guide us during the refactoring process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe here two benefits of having tests in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: They serve as updated documentation of how the features should be implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They guide us when refactoring code by maintaining the same assertion and detecting
    whether new changes to the code broke it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s update the code to get rid of `IntArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we modify the `factorial` function, as in the preceding example, and run
    the tests, we should see them all passing.
  prefs: []
  type: TYPE_NORMAL
- en: In certain situations, your tests will use a resource that is common to the
    test or the application (databases, files, and so on). Ideally, this shouldn’t
    happen for unit tests, but there can always be exceptions to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze that scenario and see how JUnit can aid us with it. We will add
    a `companion` object, which will store the result, to simulate this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we execute the tests for the preceding code, we will start seeing that some
    will fail. That’s because after the first tests execute the `factorial` function,
    the result will have the value of the executed tests, and when a new test is executed,
    the result of the factorial will be multiplied by the previous value of the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, this would be good because the tests tell us that we are doing something
    wrong and we should remedy this, but for this example, we will address the issue
    directly in the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the tests, we’ve added two methods with the `@Before` and `@After` annotations.
    When these methods are introduced, JUnit will change the execution flow as follows:
    all methods with the `@Before` annotation will be executed, a method with the
    `@Test` annotation will be executed, and then all methods with the `@After` annotation
    will be executed. This process will repeat for every `@Test` method in your class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find yourself repeating the same statements in your `@Before` method,
    you can consider using `@Rule` to remove the repetition. We can set up a test
    rule for the preceding example. Test rules should be in the `test` or `androidTest`
    packages, as their usage is only limited to testing. They tend to be used in multiple
    tests, so you can place your rules in a `rules` package (`import` statements not
    shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can see that the rule will implement `TestRule`,
    which, in turn, comes with the `apply()` method. We then create a new `Statement`
    object that will execute the `base` statement (the test itself) and reset the
    value of the result before and after the statement. We can now modify the test
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To add the rule to the test, we use the `@Rule` annotation. Since the test is
    written in Kotlin, we are using `@JvmField` to avoid generating getters and setters
    because `@Rule` requires a public field and not a method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how we can use JUnit to write tests that can
    verify small units of our code, by verifying the results, errors, or behavior
    for different parameters. We’ve also learned how each test is run when they are
    part of a testing class and the order of operations being invoked. In the next
    section, we will look at how we can use Android Studio to understand how we can
    run tests and view the results.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio testing tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio comes with a good set of shortcuts and visual tools to help with
    testing. If you want to create a new test for your class or go to existing tests
    for your class, you can use the *Ctrl* + *Shift* + *T* (Windows) or *Command*
    + *Shift* + *T* (Mac) shortcut. You will need to make sure that the contents of
    your class are currently in focus in the editor for the keyboard shortcut to take
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run tests, there are multiple options: right-click your file or
    the package and select the **Run ''Tests in…''** option, or if you want to run
    a test independently, you can go to the particular test method and select the
    green icon at the top of the class, which will execute all the tests in the class.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Running a group of tests](img/B19411_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Running a group of tests
  prefs: []
  type: TYPE_NORMAL
- en: For an individual test, you can click the green icon next to the `@Test` annotated
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Icons for running individual tests](img/B19411_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Icons for running individual tests
  prefs: []
  type: TYPE_NORMAL
- en: 'This will trigger the test execution, which will be displayed in the **Run**
    tab, as shown in the following screenshot. When the tests are completed, they
    will become either red or green, depending on their success state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Test output in Android Studio](img/B19411_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Test output in Android Studio
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature that can be found in tests is the debug one. This
    is important because you can debug both the test and the method under test, so
    if you find problems in fixing an issue, you can use this to view what the test
    used as input and how your code handles the input. The third feature you can find
    in the green icon next to a test is the **Run With** **Coverage** option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This helps developers identify which lines of code are covered by the test
    and which ones are skipped. The higher the coverage, the higher the chances of
    finding crashes and bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Test coverage in Android Studio](img/B19411_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Test coverage in Android Studio
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see the coverage of our class broken down into
    the number of classes under test, the number of methods under test, and the number
    of lines under test.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to run tests for your Android app is through the command line. This
    is usually handy in situations where your project has **continuous integration**
    set up, meaning that every time you upload your code to a repository in the cloud,
    a set of scripts will be triggered to test it and ensure functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is done in the cloud, there is no need for Android Studio to be installed.
    For simplicity, we will be using the **Terminal** tab in Android Studio to emulate
    that behavior. The **Terminal** tab is usually located in the bottom bar in Android
    Studio near the **Logcat** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'In every Android Studio project, a file called `gradlew` is present. This is
    an executable file that allows developers to execute Gradle commands. To run your
    local unit tests, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gradlew.bat test` (for Windows)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./gradlew test` (for macOS and Linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once that command is executed, the app will be built and tested. You can find
    a variety of commands that you can input in **Terminal** in the **Gradle** tab
    located on the right-hand side of Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: If you see the message saying **Task list has not been built**, click it and
    uncheck **Do not build Gradle task list during Gradle Sync**, click **OK**, and
    then sync the project’s Gradle files. The task list should then appear in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the tests, when executed from either the `app/build/reports` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Gradle commands in Android Studio](img/B19411_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Gradle commands in Android Studio
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the various options for testing that
    Android Studio provides and how we can visualize testing results. In the section
    that follows, we will look at how we can mock objects in tests and how we can
    use Mockito to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, we looked at how to set up a unit test and how to
    use assertions to verify the result of an operation. What if we want to verify
    whether a certain method was called? Or what if we want to manipulate the test
    input to test a specific scenario? In these types of situations, we can use **Mockito**.
  prefs: []
  type: TYPE_NORMAL
- en: This is a library that helps developers set up dummy objects that can be injected
    into the objects under test and allows them to verify method calls, set up inputs,
    and even monitor the test objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library should be added to your `test` Gradle setup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at the following code example (please note that, for brevity,
    `import` statements have been removed from the following code snippets):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the `Context` object, which normally cannot be unit-tested because
    it’s part of the Android framework. We can use `mockito` to create a test double
    and inject it into the `StringConcatenator` object. Then, we can manipulate the
    call to `getString()` to return whatever input we chose. This process is referred
    to as **mocking**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the test, we created a `mock` context. When the `concatenate` method was
    tested, we used Mockito to return a specific string when the `getString()` method
    was called with a particular input. This allowed us to then assert the result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`` ` `` is an escape character present in Kotlin and should not be confused
    with a quote mark. It allows the developer to give methods any name that they
    want, including special characters or reserved words.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mockito is not limited to mocking Android framework classes only. We can create
    a `SpecificStringConcatenator` class, which will use `StringConcatenator` to concatenate
    two specific strings from `strings.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write the test for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are mocking the previous `StringConcatenator` and instructing the mock
    to return a specific result. If we run the test, it will fail because Mockito
    is not able to mock final classes. Here, it encounters a conflict with Kotlin
    that makes all classes *final* unless we specify them as *open*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is a configuration we can apply that solves this dilemma without
    making the classes under test *open*:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `resources` in the `test` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `resources`, create a folder named `mockito-extensions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `mockito-extensions` folder, create a file named `org.mockito.plugins.MockMaker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the file, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In situations where you have callbacks or asynchronous work and cannot use
    the JUnit assertions, you can use `mockito` to verify the invocation on the callback
    or lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have added the `concatenateWithCallback` method,
    which will invoke the callback with the result of the `concatenateSpecificStrings`
    method. The test for this method would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a mock `Callback` object, which we can then verify at the end
    with the expected result. Notice that we had to duplicate the setup of the `concatenateSpecificStrings`
    method to test the `concatenateWithCallback` method. You should never mock the
    objects you are testing; however, you can use `spy` to change their behavior.
    We can spy the `stringConcatenator` object to change the outcome of the `concatenateSpecificStrings`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Mockito also relies on dependency injection to initialize class variables and
    has a custom build JUnit test runner. This can simplify the initialization of
    our variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `MockitoRunner` will inject the variables with the
    `@Mock` annotation with mocks. Next, it will create a new non-mocked instance
    of the field with the `@InjectMocks` annotation. When this instance is created,
    Mockito will try to inject the mock objects that match the signature of the constructor
    of that object.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can mock objects when we write tests
    and how we can use Mockito to do so. In the section that follows, we will look
    at a specialized library for Mockito that is better suited to be used with the
    Kotlin programming language, mockito-kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed in the preceding example that the `when` method from Mockito
    has escaped. This is because of a conflict with the Kotlin programming language.
    Mockito is built mainly for Java, and when Kotlin was created, it introduced the
    `this` keyword. Conflicts like this are escaped using the `` ` `` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'This, along with some other minor issues, causes some inconvenience when using
    Mockito in Kotlin. A few libraries were introduced to wrap Mockito and provide
    a nicer experience when using it. One of those is `mockito-kotlin`. You can add
    this library to your module using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A big visible change this library adds is replacing the `when` method with `whenever`.
    Another useful change is replacing the `mock` method to rely on generics, rather
    than class objects. The rest of the syntax is like the Mockito syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update the previous tests with the new library, starting with `StringConcatenatorTest`
    (`import` statements have been removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can observe, the `` ` `` character has disappeared, and our mock initialization
    for the `Context` object has been simplified. We can apply the same thing for
    the `SpecificStringConcatenatorTest` class (`import` statements have been removed
    for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have looked at how we can use the `mockito-kotlin` library
    and how it can simplify the Mockito functions in Kotlin. In what follows, we will
    do an exercise on how we can write unit tests with JUnit and Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.01 – testing the sum of numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using JUnit, Mockito, and `mockito-kotlin`, write a set of tests for the following
    class that should cover the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Assert the values for `0`, `1`, `5`, `20`, and `Int.MAX_VALUE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert the outcome for a negative number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix the code and replace the sum of numbers with the formula *n*(n+1)/2*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this exercise, `import` statements are not shown. To see the full
    code files, refer to [https://packt.link/rv8C2](https://packt.link/rv8C2).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make sure the necessary libraries are added to the `app/build.gradle`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a class named `NumberAdder` and copy the preceding code inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the cursor inside the newly created class and, with *Command* + *Shift*
    + *T* or *Ctrl* + *Shift* + *T*, create a test class called `NumberAdderParameterTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a parameterized test inside this class that will assert the outcomes
    for the `0`, `1`, `5`, `20`, and `Int.MAX_VALUE` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a separate test class that handles the exception thrown when there are
    negative numbers, named `NumberAdderErrorHandlingTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since *1 + 2 + ...n = n * (n + 1) / 2*, we can use the formula in the code,
    and this would make the execution of the method run faster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the tests by right-clicking the package in which the tests are located
    and selecting **Run all in** [**package_name**]. An output similar to the following
    will appear, signifying that the tests have passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Output of Exercise 10.01](img/B19411_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Output of Exercise 10.01
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, we have taken the first steps into unit testing,
    managed to create multiple test cases for a single operation, taken the first
    steps into understanding Mockito, and used tests to guide us on how to refactor
    code without introducing any new issues.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume your project is covered by unit tests where a lot of your logic
    is held. You now have to add these tested classes to an activity or a fragment
    and require them to update your UI. How can you be certain that these classes
    will work well with each other? The answer to that question is through integration
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind this type of testing is to ensure that different components
    within your application integrate well with each other. Some examples include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that your API-related components parse the data well and interact well
    with your storage components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The storage components are capable of storing and retrieving the data correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI components load and display the appropriate data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transition between different screens in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To aid with integration testing, the requirements are sometimes written in
    the format `Given - When - Then`. These usually represent acceptance criteria
    for a user story. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can use these steps to approach how we can write the integration tests for
    the feature we are developing.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Android platform, integration testing can be achieved with two libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Robolectric**: This library gives developers the ability to test Android
    components as unit tests – that is, executing integration tests without an actual
    device or emulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Espresso**: This library is helpful in instrumentation tests on an Android
    device or emulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll have a look at these libraries in detail in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Robolectric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Robolectric** started as an open source library, which was meant to give
    users the ability to unit test classes from the Android framework as part of their
    local tests instead of the instrumented tests. Recently, it has been endorsed
    by Google and has been integrated with AndroidX Jetpack components.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main benefits of this library is the simplicity of testing activities
    and fragments. This is a benefit when it comes to integration tests because we
    can use this feature to make sure that our components integrate well with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of Robolectric’s features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The possibility to instantiate and test the activity and fragment lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to test view inflation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to provide configurations for different Android APIs, orientations,
    screen sizes, layout directions, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to change the `Application` class, which then helps to change
    the modules to permit data mocks to be inserted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add Robolectric, along with the AndroidX integration, we will need the following
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The second library will bring a set of utility methods and classes required
    for testing Android components.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we have to deliver a feature in which we display the text `Result
    x`, where `x` is the `factorial` function for a number that the user will insert
    in the `EditText` element. We will assume that we will use an Activity with an
    `EditText`, a `TextView`, and a `Button`. When the button is clicked, then we
    display in the `TextView` the factorial result of the number entered in the `EditText`.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we have two classes, one that computes the factorial and another
    that concatenates the word `Result` with the factorial if the number is positive,
    or it will return the text `Error` if the number is negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `factorial` class will look something like this (throughout this example,
    `import` statements have been removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TextFormatter` class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine these two components in our activity and have something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can observe three components interacting with each other in this case. We
    can use Robolectric to test our activity. By testing the activity that creates
    the components, we can also test the interaction between all three of the components.
    We can write a test that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see the AndroidX support for the activity test.
    The `AndroidJUnit4` test runner will set up Robolectric and create the necessary
    configurations, while the `launch` method will return a `scenario` object, which
    we can then play with to achieve the necessary conditions for the test. We can
    also observe how we can use the `` ` `` character to provide longer names to our
    functions, in which we can include whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add configurations for the test, we can use the `@Config` annotation
    both on the class and on each of the test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify global configurations in the `test/resources` folder in
    the `robolectric.properties` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Another important feature that has recently been added to Robolectric is support
    for the Espresso library. This allows developers to use the syntax from Espresso
    to interact with views and make assertions on the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another library that can be used in combination with Robolectric is `FragmentScenario`,
    which allows the possibility to test fragments. These libraries can be added in
    Gradle using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing fragments is like activities using the `scenario` setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Espresso
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Espresso is a library designed to perform interactions and assertions in a
    concise way. It was initially designed to be used in instrumented tests, and now
    it has migrated to be used with Robolectric as well. The typical usage for performing
    an action is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For verification, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can provide custom `ViewMatchers` if none can be found in the `ViewMatchers`
    class. Some of the most common ones are `withId` and `withText`. These two allow
    us to identify views based on their `R.id.myId` identifier or text identifier.
    Ideally, the first one should be used to identify a particular view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting aspect of Espresso is the reliance on the `Hamcrest` library
    for matchers. This is a Java library that aims to improve testing. This allows
    multiple matchers to be combined if necessary. Let’s say that the same ID is present
    in different views on your UI. You can narrow your search for a specific view
    using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `allOf` expression will evaluate all of the other operators and will pass
    only if all of the operators inside pass. The preceding expressions will translate
    to *Find the view with id=edit_text that has the parent with id=R.id.root*. Other
    `Hamcrest` operators may include `anyOf`, `both`, `either`, `is`, `isA`, `hasItem`,
    `equalTo`, `any`, `instanceOf`, `not`, `null`, and `notNull`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewActions` have a similar approach to `ViewMatchers`. We can find common
    ones in the `ViewActions` class. Common ones include `typeText`, `click`, `scrollTo`,
    `clearText`, `swipeLeft`, `swipeRight`, `swipeUp`, `swipeDown`, `closeSoftKeyboard`,
    `pressBack`, `pressKey`, `doubleClick`, and `longClick`. If you have custom views
    and certain actions are required, then you can implement your own `ViewAction`
    element by implementing the `ViewAction` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the preceding examples, `ViewAssertions` have their own class. Typically,
    the `matches` method is used, where you can then use `ViewMatchers` and `Hamcrest`
    matchers to validate the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example will verify that the view with the `text_view` ID will
    contain the text `My text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will click the view with the ID button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now rewrite the Robolectric test and add Espresso, which will give us
    this (the `import` statement is not shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, we can observe how, using Espresso, we input the
    number `5` into `EditText`, then click on the button, and then assert the text
    displayed in `TextView` with the help of the `onView()` method to obtain a reference
    to the view, and then execute actions using `perform()` or make assertions using
    `check()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the following exercise, you will need an emulator or a physical device with
    USB debugging enabled. You can do so by selecting **Tools** | **AVD Manager**
    in Android Studio. Then, you can create one with the **Create Virtual Device**
    option by selecting the type of emulator, clicking **Next**, and then selecting
    an x86 image. Any image larger than Lollipop should be alright for this exercise.
    Next, you can give your image a name and click **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.02 – double integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Develop an application that observes the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You should implement both unit tests and integration tests using Robolectric
    and Espresso and migrate the integration tests to become instrumentation tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this exercise, `import` statements are not shown. To see the full
    code files, refer to [https://packt.link/EcmiV](https://packt.link/EcmiV).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the necessary test libraries to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Robolectric, we will need to add extra configurations, the first of which
    is to add the following line to `app/build.gradle` in the `android` closure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `resources` directory in the `test` package. You will need to switch
    your Android Studio project view from **Android** to **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `robolectric.properties` file and add the following configuration to
    that file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `resources`, create a folder named `mockito-extensions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `mockito-extensions` folder, create a file named `org.mockito.plugins.MockMaker`,
    and inside the file, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `NumberAdder` class. This is similar to the one in *Exercise 10.01*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the tests for `NumberAdder` in the `test` folder. First, create `NumberAdder``ParameterTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/ghcTs](https://packt.link/ghcTs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create the `NumberAdderErrorHandlingTest` test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` folder in the root package, create a class that will format the
    sum and concatenate it with the necessary strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unit-test this class for both the success and error scenarios. Start with the
    success scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the test for the error scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main/res/values/strings.xml`, add the following strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the layout for `activity_main.xml` in the `main/res/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/hxZ0I](https://packt.link/hxZ0I).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` folder in the root package, create the `MainActivity` class,
    which will contain all the other components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a test for `MainActivity` and place it in the `test` directory. It will
    contain two test methods, one for success and one for errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/fZI3u](https://packt.link/fZI3u).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the tests by right-clicking the package in which the tests are located
    and selecting **Run all in** [**package_name**], then an output like the following
    will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Result of executing the tests in the test folder for Exercise
    10.02](img/B19411_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Result of executing the tests in the test folder for Exercise
    10.02
  prefs: []
  type: TYPE_NORMAL
- en: If you execute the preceding tests, you should see an output like *Figure 10**.8*.
    The Robolectric test is executed in the same way as a regular unit test; however,
    there is an increase in the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now migrate the preceding test to an instrumented integration test. To
    do this, we will copy the preceding test from the `test` package into the `androidTest`
    package and remove the code related to scenarios from our tests. Make sure that
    in the `androidTest` folder, there is a Java folder that contains a package with
    the same name as the `main/java` folder. You will need to move your tests to this
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After copying the file, we will use `ActivityTestRule`, which will launch our
    activity before every test is executed. We will also need to rename the class
    to avoid duplicates and rename the test methods because the syntax is not supported
    for instrumented tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/hNB4A](https://packt.link/hNB4A).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the tests by right-clicking the package in which the tests are located
    and selecting **Run all in** [**package_name**], then an output like the following
    will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Result of executing the tests in the androidTest folder for
    Exercise 10.02](img/B19411_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Result of executing the tests in the androidTest folder for Exercise
    10.02
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10**.9*, we can see what Android Studio displays as an output for
    the result. If you pay attention to the emulator while the tests are executing,
    you can see that for each test, your activity will be opened, the input will be
    set in the field, and the button will be clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Both of our integration tests (on the workstation and the emulator) try to match
    the accepted criteria of the requirement. The integration tests verify the same
    behavior, the only difference is that one checks it locally and the other checks
    it on an Android device or emulator. The main benefit here is the fact that Espresso
    was able to bridge the gap between them, making integration tests easier to set
    up and execute.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have implemented an exercise in which we have written tests
    with the Robolectric library combined with the Espresso library and looked at
    how we can migrate our Robolectric tests from the `test` folder to the `androidTest`
    folder. In the section that follows, we will look at how we can build upon the
    existing testing suite with instrumented tests that run on physical devices or
    emulators.
  prefs: []
  type: TYPE_NORMAL
- en: UI tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI tests are instrumented tests where developers can simulate user journeys
    and verify the interactions between different modules of the application. They
    are also referred to as end-to-end tests. For small applications, you can have
    one test suite, but for larger applications, you should split your test suites
    to cover user journeys (logging in, creating an account, setting up flows, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because they are executed on the device, you will need to write them in the
    `androidTest` package, which means they will run with the **Instrumentation**
    framework. Instrumentation works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The app is built and installed on the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A testing app will also be installed on the device that will monitor your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing app will execute the tests on your app and record the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the drawbacks of this is the fact that the tests will share persisted
    data, so if a test stores data on the device, then the second test can have access
    to that data, which means that there is a risk of failure. Another drawback is
    that if a test comes across a crash, this will stop the entire testing because
    the application under test is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: These issues were solved in the Jetpack updates with the introduction of the
    **orchestrator** framework. Orchestrators give you the ability to clear the data
    after each test is executed, sparing developers the need to make any adjustments.
    The orchestrator is represented by another application that will manage how the
    testing app will coordinate the tests and the data between the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add it to your project, you need a configuration similar to this
    in the `app/build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can execute the orchestrator test on a connected device using Gradle’s `connectedCheck`
    command, either from Terminal or from the list of Gradle commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the configuration, you will notice the following line: `testInstrumentationRunner`.
    This allows us to create a custom configuration for the test, which gives us the
    opportunity to inject mock data into the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`CustomTestRunner` looks like this (`import` statements are not shown in the
    following code snippets):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The test classes themselves can be written by applying the JUnit4 syntax with
    the help of the `androidx.test.ext.junit.runners.AndroidJUnit4` test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Test` methods themselves run in a dedicated test thread, which is why
    a library such as Espresso is helpful. Espresso will automatically move every
    interaction with a view on the UI thread. Espresso can be used for UI tests in
    a similar way as it is used with Robolectric tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, in UI tests, you will find interactions and assertions that may
    get repetitive. In order to avoid duplicating multiple scenarios in your code,
    you can apply a pattern called `Robot` class in which the interactions and assertions
    can be grouped into specific methods. Your test code will use the robots and assert
    them. A typical robot will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The test will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Because apps can be multithreaded and sometimes it takes a while to load data
    from various sources (internet, files, local storage, and so on), the UI tests
    will have to know when the UI is available for interactions. One way to implement
    this is through the use of idling resources.
  prefs: []
  type: TYPE_NORMAL
- en: These are objects that can be registered to Espresso before the test and injected
    into your application’s components where multithreaded work is done. The apps
    will mark them as non-idle when the work is in progress and idle when the work
    is done. It is at this point that Espresso will then start executing the test.
    One of the most commonly used ones is `CountingIdlingResource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specific implementation uses a counter that should be incremented when
    you want Espresso to wait for your code to complete its execution and decremented
    when you want to let Espresso verify your code. When the counter reaches `0`,
    Espresso will resume testing. An example of a component with an idling resource
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Application` class can be used to inject the idling resource, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the test, we can access the `Application` class and register the resource
    to Espresso:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Espresso comes with a set of extensions that can be used to assert different
    Android components. One extension is intents testing. This is useful when you
    want to test an activity in isolation (more appropriate for integration tests).
    In order to use this, you need to add the library to Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: After you add the library, you need to set up the necessary intent monitoring
    using the `init` method from the `Intents` class, and to stop monitoring, you
    can use the `release` method from the same class. These operations can be done
    in the `@Before` and `@After` annotated methods of your test class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assert the values of the intent, you need to trigger the appropriate action
    and then use the `intended` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `intended` method works in a similar way to the `onView` method. It requires
    a matcher that can be combined with a `Hamcrest` matcher. The intent-related matchers
    can be found in the `IntentMatchers` class. This class contains methods to assert
    different methods of the `Intent` class: extras, data, components, bundles, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important extension library comes to the aid of `RecyclerView`. The
    `onData` method from Espresso is only capable of testing `AdapterViews` such as
    `ListView` and isn’t capable of asserting `RecyclerView`. In order to use the
    extension, you need to add the following library to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This library provides a `RecyclerViewActions` class, which contains a set of
    methods that allow you to perform actions on items inside `RecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement will click the item at position `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This will scroll to the 10th item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will check whether a view with the `myText` text is displayed,
    which will also apply to `RecyclerView` items.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Jetpack Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jetpack Compose offers the ability to test `@Composable` functions with a similar
    approach to Espresso. If we are using Robolectric, we can write our testing code
    in the `test` folder, and if not, we can use the `androidTest` folder and our
    tests will be viewed as instrumented tests. The testing library is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to also test the `Activity` that sets the `@Composable` function
    as content, then we will also need to add the following library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, we would need to use a test rule that provides a set of methods used
    for interacting with the `@Composable` elements and performing assertions on them.
    We have multiple ways of obtaining that rule through the following approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have two test rules. The first one, `composeTestRuleForActivity`,
    will start the `Activity` that holds the `@Composable` function that we want to
    test and will hold all the nodes we want to assert.
  prefs: []
  type: TYPE_NORMAL
- en: The second one, `composeTestRuleForNoActivity`, provides the ability to set
    as content the function we want to test. This will then allow the rule to have
    access to all the `@``Composable` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to identify elements from our function, we have the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have the `onNodeWithText` method, which will identify
    a particular UI element using a text label that’s visible to the user. The `onNodeWithContentDescription`
    method will identify an element using the content description set, and `onNodeWithTag`
    will identify an element using the test tag, which is set using the `Modifier.testTag`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Espresso, once we identify the element we want to interact with or perform
    assertions on, we have similar methods for both situations. For interacting with
    the element, we have methods such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we perform a click, scroll, text insertion, and gesture
    into the element. For assertions, some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we assert whether an element is displayed, not displayed,
    enabled, not enabled, selected, or not selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our user interface has multiple elements with the same text, we have the
    option to extract all of them using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we extract all the nodes that have `My text` as a text, `My content description`
    as a content description, and `My test tag` as a test tag. The return is a collection,
    which allows us to assert each element of the collection individually, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we assert that the first element that has `My text` is displayed. We
    also can perform assertions on the collection, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assert that the number of elements that have `My text` as a text set
    is three, assert whether all elements match a `SemanticsMatcher`, or assert whether
    any of the elements match a `SemanticMatcher`. In this case, it would assert that
    all the elements are selected and at least one element is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another similarity to Espresso that we have when testing Jetpack Compose is
    the usage of `IdlingResource`. Compose provides its own `IdlingResource` abstraction,
    which is separate from Espresso and can be registered to our test rule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we register `IdlingResource` in the `@Before` annotated
    method and unregister it in the `@``After` method.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.03 – random waiting times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write an application that will have two screens. The first screen will have
    a button. When the user presses the button, it will wait a random time between
    1 and 5 seconds and then launch the second screen, which will display the text
    **Opened after x seconds**, where **x** is the number of seconds that passed.
    Write a UI test that will cover this scenario with the following features adjusted
    for the test:'
  prefs: []
  type: TYPE_NORMAL
- en: The `random` function will return a value of `1` when the test is run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CountingIdlingResource` will be used to indicate when the timer has stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this exercise, `import` statements are not shown. To see the full
    code files, refer to [https://packt.link/GG32r](https://packt.link/GG32r).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio Project with no Activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following libraries to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` folder in the root package, create a class; start with a `Randomizer`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` folder in the root package, create a class; create a `Synchronizer`
    class, which will use `Randomizer` and `Timer` to wait for the random time interval.
    It will also use `CountingIdlingResource` to mark the start of the task and the
    end of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create an `Application` class, which will be responsible for creating
    all the instances of the preceding classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `MyApplication` class to `AndroidManifest` in the `application` tag
    with the `android:name` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `activity_1` layout file, which will contain a parent layout and
    a button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `activity_2` layout file, which will contain a parent layout and
    `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Activity1` class, which will implement the logic for the button
    click:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Activity2` class, which will display the received data through
    the intent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure that the relevant strings are added to `strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure that the two activities are added to `AndroidManifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/TkEX9](https://packt.link/TkEX9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `FlowTest` class in the `androidTest` directory, which will register
    `IdlingResource` from the `MyApplication` object and will assert the outcome of
    the click:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code for this step can be found at [https://packt.link/711Vw](https://packt.link/711Vw).
  prefs: []
  type: TYPE_NORMAL
- en: Run the test multiple times and check the test results. Notice that the test
    will have a 20% chance of success, but it will wait until the button from `Activity1`
    is clicked. This means that the idling resource is working. Another thing to observe
    is that there is an element of randomness here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tests don’t like randomness, so we need to eliminate it by making the `Randomizer`
    class open and creating a subclass in the `androidTest` directory. We can do the
    same for the `MyApplication` class and provide a different randomizer called `TestRandomizer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, modify the `MyApplication` class in a way in which we can override the
    randomizer from a subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `androidTest` directory, create `TestMyApplication`, which will extend
    `MyApplication` and override the `createRandomizer` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the `androidTest/java` folder in the root package, create an instrumentation
    test runner that will use this new `Application` class inside the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new test runner to the Gradle configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run the test now, the test should pass; however, we have a couple of problems
    with our dependencies. For the `Randomizer` class, we had to make our class open
    so that it could be extended in the `androidTest` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is the fact that our application code contains references to idling
    resources that are part of the testing libraries. To solve both problems, we will
    need to define abstractions for the `Randomizer` and `Synchronizer` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main/java` folder in the root package, create an interface called `Randomizer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename the previous `Randomizer` class `RandomizerImpl` and implement the `Randomizer`
    interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `MyApplication`, modify the `createRandomizer` method to have the `Randomizer`
    return type, which will return an instance of `RandomizerImpl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `TestRandomizer` to implement the `Randomizer` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `TestMyApplication` to correct the compile errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `app/build.gradle`, make the idling resource dependency `androidTestImplementation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main/java` folder in the root package, create an interface called `Synchronizer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename the previous `Synchronizer` class `SynchronizerImpl`, implement the
    `Synchronizer` interface, and remove the usages of `CountingIdlingResource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `MyApplication` so that it will open the ability to provide different
    `Synchronizer` instances from the `TestMyApplication` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `androidTest` folder, create a class called `TestSynchronizer`, which
    will wrap a `Synchronizer`, and then use `CountingIdlingResource` to increment
    and decrement a counter when `executeAfterDelay` is started and finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we have a reference to a `Synchronizer` instance.
    When `executeAfterDelay` is called, then we inform Espresso to wait. We then invoke
    the actual `Synchronizer` instance, and when it finishes the execution, we then
    inform Espresso to resume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `TestMyApplication` to provide an instance of `TestSynchronizer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we create a new `TestSynchronizer` that wraps the
    `Synchronizer` defined in `MyApplication` and adds the `CountingIdlingResource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `FlowTest`, change the reference to `MyApplication` with `TestMyApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When running the test now, everything should pass, as shown in *Figure 10**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Output of Exercise 10.03](img/B19411_10_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Output of Exercise 10.03
  prefs: []
  type: TYPE_NORMAL
- en: This type of exercise shows how to avoid randomness in a test and provides concrete
    and repeatable input to make our tests reliable. Similar approaches are taken
    with dependency injection frameworks, where entire modules can be replaced in
    the test suite to ensure the test’s reliability.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common things to be replaced is API communication. Another issue
    this approach solves is the decrease in waiting time. If this type of scenario
    were to have been repeated across your tests, then the execution time of them
    would have increased because of this.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have looked at how we can write instrumented tests and
    execute them on an emulator or physical device. We have also analyzed how we can
    decorate our objects with `CountingIdlingResources` to be able to monitor asynchronous
    operations, and how we can switch dependencies that cause flakiness and provide
    stub data instead.
  prefs: []
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that you are tasked with building an activity that displays a calculator
    with the add, subtract, multiply, and divide options. You must also write tests
    for your implementation. Typically, you would build your UI and your activity
    and a separate `Calculator` class. Then, you would write the unit tests for your
    `Calculator` class and then for your `activity` class.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to translate the TDD process to implementing features on an Android
    app, you would have to write your UI test with your scenarios first. To achieve
    this, you can create a skeleton UI to avoid compile-time errors. After your UI
    test, you would need to write your `Calculator` test. Here, you would also need
    to create the necessary methods in the `Calculator` class to avoid compile-time
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ran your tests in this phase, they would fail. This would force you
    to implement your code until the tests pass. Once your `Calculator` tests pass,
    you can connect your calculator to your UI until your UI tests pass. While this
    seems like a counter-intuitive approach, it solves two issues once the process
    is mastered:'
  prefs: []
  type: TYPE_NORMAL
- en: Less time will be spent writing code because you will ensure that your code
    is testable, and you need to write only the amount of code necessary for the test
    to pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fewer bugs will be introduced because developers will be able to analyze different
    outcomes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram, which shows the TDD cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – TDD cycle](img/B19411_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – TDD cycle
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see the development cycle in a TDD process.
    You should start from a point where your tests are failing. Implement changes
    for the tests to pass. When you update or add new features, you can repeat the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our factorial examples, we started with a `factorial` function
    that didn’t cover all our scenarios and had to keep updating the function every
    time a new test was added. TDD is built with that idea in mind. You start with
    an empty function. You start defining your testing scenarios: what are the conditions
    for success? What’s the minimum? What’s the maximum? Are there any exceptions
    to the main rule? What are they? These questions can help developers define their
    test cases. Then, these cases can be written. Let’s now see how this can be done
    practically through the next exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.04 – using TDD to calculate the sum of numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a function that has as input the integer `n` and will return the sum
    of numbers from `1` to `n`. The function should be written with a TDD approach,
    and the following criteria should be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: For `n<=0`, the function will return the value `-1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function should be able to return the correct value for `Int.MAX_VALUE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function should be quick, even for `Int.MAX_VALUE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio Project with No Activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the following library is added to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main/java` folder in the root package, create an `Adder` class with
    the `sum` method, which will return `0`, to satisfy the compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `AdderTest` class in the `test` directory and define our test cases.
    We will have the following test cases: `n=1`, `n=2`, `n=0`, `n=-1`, `n=10`, `n=20`,
    and `n=Int.MAX_VALUE`. We can split the successful scenarios into one method and
    the unsuccessful ones into a separate method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the tests for the `AdderTest` class, we will see an output like the
    following figure, meaning that all our tests failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Initial test status for Exercise 10.04](img/B19411_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Initial test status for Exercise 10.04
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first address the success scenarios by implementing the sum in a loop
    from `1` to `n`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the tests now, you will see that one will pass and the other will
    fail, like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Test status after resolving the success scenario for Exercise
    10.04](img/B19411_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Test status after resolving the success scenario for Exercise
    10.04
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the time it took to execute the successful test, it seems a bit
    long. This can add up when thousands of unit tests are present in one project.
    We can now optimize our code to deal with the issue by applying the *n(n+1)/2*
    formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the tests now will drastically reduce the execution time to a few milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s focus on solving our failure scenarios. We can do this by adding
    a condition for when `n` is smaller than or equal to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the tests now, we should see them all passing, like the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Passing tests for Exercise 10.04](img/B19411_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Passing tests for Exercise 10.04
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have applied the concept of TDD to a very small example
    to demonstrate how the technique can be used. We have observed how, starting from
    the skeleton code, we can create a suite of tests to verify our conditions, and
    how by constantly running tests, we improved the code until a point where all
    the tests pass. As you have probably noticed, the concept isn’t an intuitive one.
    Some developers find it hard to define how big skeleton code should be to start
    creating the test cases, while others, out of habit, focus on writing the code
    first and then developing the test. In either case, developers will need a lot
    of practice with the technique until it’s properly mastered.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 10.01 – developing with TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the TDD approach, develop an application that contains three activities
    and works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In activity 1, you will display a numeric `EditText` element and a button. When
    the button is clicked, the number in `EditText` will be passed to activity 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity 2 will generate a list of items asynchronously. The number of items
    will be represented by the number passed from activity 1\. You can use the `Timer`
    class with a delay of 1 second. Each item in the list will display the text `Item
    x` where `x` is the position in the list. When an item is clicked, you should
    pass the clicked item to activity 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity 3 will display the text `You clicked y`, where `y` is the text of the
    item the user has clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tests for the app will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests with Mockito and `mockito-kotlin` annotated with `@SmallTest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests with Robolectric and Espresso annotated with `@MediumTest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI tests with Espresso annotated with `@LargeTest` and using the `Robot` pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the test commands from the command line. To complete this activity, you
    need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need Android Studio 4.1.1 or higher with Kotlin 1.4.21 or higher for
    the Parcelize Kotlin plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the three activities and the UI for each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `androidTest` folder, create three robots, one for each activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Robot 1 will contain the interaction with `EditText` and the button
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Robot 2 will assert the number of items on the screen and interact with an item
    in the list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Robot 3 will assert the text displayed in `TextView`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an instrumented test class that will have one test method using the preceding
    robots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `Application` class that will hold instances of all the classes that
    will be unit-tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three classes representing integration tests, one for each of the activities.
    Each of these classes will contain one test method for interactions and data loading.
    Each integration test will assert the intents passed between the activities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that will provide the text required for the UI. It will have
    a reference to a `Context` object and will contain two methods that will provide
    the text for the UI, which will return an empty string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the test for the preceding class in which the two methods are tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the class for the preceding tests to pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that will be responsible for loading the list in `Activity2`,
    and provide an empty method for loading. The class will have a reference to the
    timer and the idling resource. Here, you should also create a data class that
    will represent the model for `RecyclerView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a unit test for the preceding class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the implementation for the preceding class and run the unit tests until
    they pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Application` class, instantiate the classes that were unit-tested and
    start using them in your activities. Do this until your integration tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide `IntegrationTestApplication`, which will return a new implementation
    of the class responsible for loading. This is to avoid making your integration
    test for `Activity2` wait until loading is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide `UiTestApplication`, which will again reduce the loading time of your
    models and connect the idling resource to Espresso. Implement the remaining work
    for the UI test to pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/Ma4tD](https://packt.link/Ma4tD).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the different types of testing and the frameworks
    available for implementing these tests. We also looked at the testing environment
    and how to structure it for each environment, as well as structuring your code
    into multiple components that can be individually unit-tested.
  prefs: []
  type: TYPE_NORMAL
- en: We analyzed different ways to test code, how we should approach testing, and
    how, by looking at different test results, we can improve our code. With TDD,
    we learned that by starting with testing, we can write our code faster and ensure
    it is less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: The activity is where all these concepts came together into building a simple
    Android application, and we can observe how, by adding tests, the development
    time increases, but this pays off in the long term by eliminating possible bugs
    that appear when the code is modified.
  prefs: []
  type: TYPE_NORMAL
- en: The frameworks we have studied are some of the most common ones, but there are
    others that build on top of these and are used by developers in their projects,
    such as Mockk (a mocking library designed for Kotlin that takes advantage of a
    lot of the features of the language) and Barista (written on top of Espresso and
    simplifies the syntax of UI tests), to note a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of all the concepts presented here as building blocks that fit into two
    processes present in the software engineering world: automation and continuous
    integration. Automation takes redundant and repetitive work out of the hands of
    developers and puts it into the hands of machines.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having a team of quality assurance people testing your application
    to make sure the requirements are met, you can instruct a machine through a variety
    of tests and test cases to test the application instead and just have one person
    reviewing the results of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous integration builds on the concept of automation to verify your code
    the moment you submit it for review from other developers. A project with continuous
    integration would have a setup along the following lines: a developer submits
    work for review in a source control repository such as GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: A machine in the cloud would then start executing the tests for the entire project,
    making sure that nothing was broken, and the developer can move on to a new task.
    If the tests pass, then the rest of the developers can review the code, and when
    it is correct, it can be merged, and a new build can be created in the cloud and
    distributed to the rest of the team and the testers.
  prefs: []
  type: TYPE_NORMAL
- en: All of this takes place while the initial developer can safely work on something
    else. If anything fails in the process, then they can pause the new task and go
    and address any issues in their work. The continuous integration process can then
    be expanded into continuous delivery, where similar automation can be set up when
    preparing a submission to Google Play that can be handled almost entirely by machines
    with minor involvement from developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapters that follow, you will learn about how to organize your code
    when building more complex applications that use the storage capabilities of the
    device and connect to the cloud to request data. Each of those components can
    be individually unit-tested, and you can apply integration tests to assert a successful
    integration of multiple components.
  prefs: []
  type: TYPE_NORMAL
