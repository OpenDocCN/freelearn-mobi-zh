- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Unit Tests and Integration Tests with JUnit, Mockito, and Espresso
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JUnit、Mockito和Espresso进行单元测试和集成测试
- en: In this chapter, you will learn about testing on the Android platform and how
    to create unit tests, integration tests, and UI tests. You will see how to create
    each of these types of tests, analyze how they run, and work with frameworks such
    as JUnit, Mockito, Robolectric, and Espresso.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解在Android平台上的测试以及如何创建单元测试、集成测试和UI测试。你将看到如何创建每种类型的测试，分析它们的运行方式，并使用JUnit、Mockito、Robolectric和Espresso等框架进行工作。
- en: You will also learn about test-driven development (TDD), a software development
    practice that prioritizes tests over implementation. By the end of this chapter,
    you will be able to combine your new testing skills to work on a realistic project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将了解测试驱动开发（TDD），这是一种软件开发实践，它将测试优先于实现。在本章结束时，你将能够结合你的新测试技能来参与一个真实的项目。
- en: In previous chapters, you learned about how to load background data and display
    it in the UI and how to set up API calls to retrieve data. But how can you be
    sure that things work well? What if you’re in a situation where you have to fix
    a bug in a project that you haven’t interacted much with in the past? How can
    you know that the fix you are applying won’t trigger another bug? The answer to
    these questions is through tests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何加载后台数据并在UI中显示它，以及如何设置API调用以检索数据。但你如何确保一切正常工作？如果你处于必须修复一个你过去很少与之交互的项目中的bug的情况怎么办？你如何知道你正在应用修复不会触发另一个bug？这些问题的答案是测试。
- en: In this chapter, we will analyze the types of tests developers can write and
    we will look at available testing tools to ease the testing experience. The first
    issue that arises is the fact that desktops or laptops (which have different operating
    systems) are used to develop mobile applications. This implies that the tests
    must also be run on the device or an emulator, which will slow the tests down.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析开发者可以编写的测试类型，并查看可用的测试工具以简化测试体验。首先出现的问题是，桌面或笔记本电脑（它们具有不同的操作系统）用于开发移动应用程序。这意味着测试也必须在设备或模拟器上运行，这将减慢测试速度。
- en: 'To solve this issue, we are presented with two types of tests: `test` folder
    and will run on your machine, and `androidTest` folder and will run on the device
    or emulator.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们提供了两种类型的测试：`test`文件夹将在你的机器上运行，而`androidTest`文件夹将在设备或模拟器上运行。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: JUnit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit
- en: Android Studio testing tips
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio 测试技巧
- en: Mockito
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mockito
- en: Integration tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: UI tests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI测试
- en: TDD
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/pNbuk](https://packt.link/pNbuk)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在GitHub上找到：[https://packt.link/pNbuk](https://packt.link/pNbuk)
- en: Types of testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: Both tests rely on the Java **JUnit** library, which helps developers set up
    their tests and group them into different categories. It also provides different
    configuration options, as well as extensions that other libraries can build upon.
    We will also investigate the testing pyramid, which helps guide developers as
    to how to structure their tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种测试都依赖于Java **JUnit**库，它帮助开发者设置他们的测试并将它们分组到不同的类别。它还提供了不同的配置选项，以及其他库可以构建在其上的扩展。我们还将研究测试金字塔，它有助于指导开发者如何构建他们的测试。
- en: 'We will start at the bottom of the pyramid, which is represented by **unit
    tests**, move upward through **integration tests**, and finally, reach the top,
    which is represented by **end-to-end tests** (UI tests). You’ll have the opportunity
    to learn about the tools that aid in writing each of these types of tests:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从金字塔的底部开始，底部由**单元测试**表示，然后向上通过**集成测试**，最终达到顶部，顶部由**端到端测试**（UI测试）表示。你将有机会了解辅助编写这些测试类型所需的工具：
- en: '`mockito-kotlin`, which help mainly in unit tests and are useful for creating
    mocks or test doubles in which we can manipulate inputs so that we can assert
    different scenarios. (A mock or test double is an object that mimics the implementation
    of another object. Every time a test interacts with mocks, you can specify the
    behavior of these interactions.)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockito-kotlin`主要帮助进行单元测试，并且对于创建我们可以操作输入以断言不同场景的模拟或测试双倍对象非常有用。（模拟或测试双倍对象是模仿另一个对象实现的对象。每次测试与模拟交互时，你都可以指定这些交互的行为。）'
- en: '**Robolectric**, which is an open source library that brings the Android framework
    onto your machine, allows you to test activities and fragments locally and not
    on the emulator. This can be used for both unit tests and integration tests.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Robolectric**，这是一个开源库，将Android框架带到您的机器上，允许您在本地测试活动片段，而不是在模拟器上。这可以用于单元测试和集成测试。'
- en: '`EditText` components, and so on) and assertions (verifying that views display
    certain text, are currently being displayed to the user, are enabled, and so on)
    on an app’s UI in an instrumented test.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditText`组件等）以及断言（验证视图是否显示特定文本、是否正在向用户显示、是否启用等）在仪器化测试中的应用程序UI上。'
- en: In this chapter, we will also look at **TDD**. This is a software development
    process where tests take priority. A simple way of describing it is writing the
    test first. We will analyze how this approach is taken when developing features
    for Android applications. One of the things to keep in mind is that for an application
    to be properly tested, its classes must be properly written. One way to do this
    is by clearly defining the boundaries between your classes and splitting them
    based on the tasks you want them to accomplish.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨**TDD**。这是一种软件开发流程，其中测试优先。描述它的简单方法是先编写测试。我们将分析在开发Android应用程序功能时如何采取这种方法的实例。要记住的一件事是，为了使应用程序得到适当的测试，其类必须得到适当的编写。做到这一点的一种方法是通过明确定义类之间的边界，并根据您希望它们完成的任务来拆分它们。
- en: Once you have achieved this, you can also rely on the **dependency inversion**
    and **dependency injection** principles when writing your classes. When these
    principles are applied properly, you should be able to inject fake objects into
    the subjects of your tests and manipulate the input to suit your testing scenario.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您实现了这一点，您也可以在编写类时依赖**依赖倒置**和**依赖注入**原则。当这些原则得到正确应用时，您应该能够将假对象注入到测试的主题中，并操纵输入以适应您的测试场景。
- en: Dependency injection also helps when writing instrumented tests to help you
    swap modules that make network calls with local data in order to make your tests
    independent of external factors, such as networks. Instrumented tests are tests
    that run on a device or an emulator. The `instrument` keyword comes from the instrumentation
    framework, which assembles these tests and then executes them on the device.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入在编写仪器化测试时也有帮助，可以帮助您交换执行网络调用的模块与本地数据，以便使您的测试独立于外部因素，例如网络。仪器化测试是在设备或模拟器上运行的测试。`instrument`关键字来自仪器化框架，该框架组装这些测试，然后在设备上执行它们。
- en: 'Ideally, each application should have three types of tests:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每个应用程序都应该有三种类型的测试：
- en: '**Unit tests**: These are local tests that validate individual classes and
    methods. They should represent most of your tests and they should be fast, easy
    to debug, and easy to maintain. They are also known as small tests.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些是本地测试，用于验证单个类和方法。它们应该代表您的大部分测试，并且应该快速、易于调试和易于维护。它们也被称为小型测试。'
- en: '**Integration tests**: These are either local tests with Robolectric or instrumented
    tests that validate interactions between your app’s modules and components. These
    are slower and more complex than unit tests. The increase in complexity is due
    to the interaction between the components. These are also known as medium tests.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些是使用Robolectric的本地测试或验证应用程序模块和组件之间交互的仪器化测试。它们比单元测试更慢、更复杂。复杂性的增加是由于组件之间的交互。它们也被称为中型测试。'
- en: '**UI tests (end-to-end tests)**: These are instrumented tests that verify complete
    user journeys and scenarios. This makes them more complex and harder to maintain;
    they should represent the smallest number of your total test number. These are
    also known as large tests.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI测试（端到端测试）**：这些是验证完整用户旅程和场景的仪器化测试。这使得它们更复杂，更难维护；它们应该代表您总测试数量中最小的一部分。它们也被称为大型测试。'
- en: 'In the following figure, you can observe the **testing pyramid**. The recommendation
    from Google is to keep a ratio of 70:20:10 (unit tests: integration tests: UI
    tests) for your tests:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，您可以观察到**测试金字塔**。谷歌的建议是保持测试的70:20:10（单元测试：集成测试：UI测试）的比例：
- en: "![Figure 10.1 – Test\uFEFFing pyramid](img/B19411_10_01.jpg)"
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 测试金字塔](img/B19411_10_01.jpg)'
- en: Figure 10.1 – Testing pyramid
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 测试金字塔
- en: As mentioned in the previous section, a unit test is a test that verifies a
    small portion of your code, and most of your tests should be unit tests that cover
    all sorts of scenarios (success, errors, limits, and more). Ideally, these tests
    should be local, but there are a few exceptions where you can make them instrumented.
    Those cases are rare and should be limited to when you want to interact with specific
    hardware of the device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，单元测试是验证代码一小部分的测试，并且大多数测试应该是覆盖所有各种场景（成功、错误、限制等）的单元测试。理想情况下，这些测试应该是本地的，但有一些例外，你可以使它们成为可测量的。这些情况很少见，应该限制在你想与设备的具体硬件交互时。
- en: JUnit
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit
- en: 'JUnit is a framework for writing unit tests both in Java and Android. It is
    responsible for how tests are executed, allowing developers to configure their
    tests. It offers a multitude of features, such as the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是一个用于在Java和Android中编写单元测试的框架。它负责测试的执行方式，允许开发者配置他们的测试。它提供了许多功能，例如以下内容：
- en: '`@Before` and `@``After` annotations.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before`和`@After`注解。'
- en: '**Assertions**: These are used to verify the result of an operation against
    an expected value.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这些用于验证操作的结果与预期值是否一致。'
- en: '**Rules**: These allow developers to set up inputs that are common for multiple
    tests.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则**：这些允许开发者设置多个测试共有的输入。'
- en: '**Runners**: Using these, you can specify how the tests can be executed.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行器**：使用这些，你可以指定测试如何执行。'
- en: '**Parameters**: These allow a test method to be executed with multiple inputs.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这些允许测试方法使用多个输入执行。'
- en: '**Orderings**: These specify in which order the tests should be executed.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：这些指定了测试应该执行的顺序。'
- en: '**Matchers**: These allow you to define patterns that can then be used to validate
    the results of the subject of your tests, or help you control the behavior of
    mocks.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配器**：这些允许你定义可以用来验证测试主题结果的模式，或者帮助你控制模拟的行为。'
- en: 'In Android Studio, when a new project is created, the `app` module comes with
    the JUnit library in Gradle. This should be visible in `app/build.gradle`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，创建新项目时，`app`模块在Gradle中带有JUnit库。这应该在`app/build.gradle`中可见：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s look at the following class that we need to test:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要测试的以下类：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method should return the factorial of the number `n`. We can start with
    a simple test that checks the value. To create a new unit test, you will need
    to create a new class in the `test` directory of your project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法应返回数字`n`的阶乘。我们可以从一个简单的测试开始，检查值。要创建一个新的单元测试，你需要在项目的`test`目录下创建一个新类。
- en: 'The typical convention most developers follow is to add the `Test` suffix to
    your class name and place it under the same package in the `test` directory. For
    example, `com.mypackage.ClassA` will have the test in `com.mypackage.ClassATest`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者遵循的典型约定是在类名后添加`Test`后缀，并将其放置在`test`目录下的同一包中。例如，`com.mypackage.ClassA`的测试将在`com.mypackage.ClassATest`中：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this test, you can see that we initialize the class under test, and the
    test method itself is annotated with the `@Test` annotation. The test method itself
    will assert that `(3!)==6`. The assertion is done using the `assertEquals` method
    from the JUnit library. A common practice in development is to split the test
    into three areas, also known as **Arrange-Act-Assert** (**AAA**):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，你可以看到我们初始化了被测试的类，并且测试方法本身被`@Test`注解所标记。测试方法本身将断言`(3!)==6`。断言是通过JUnit库中的`assertEquals`方法完成的。开发中的常见做法是将测试分为三个区域，也称为**安排-执行-断言**（**AAA**）：
- en: '**Arrange**: Where the input is initialized'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：初始化输入的地方'
- en: '**Act**: Where the method under test is called'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：测试方法被调用的地方'
- en: '**Assert**: Where the verification is done'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：验证的地方'
- en: We can write another test to make sure that the value is correct, but we will
    end up duplicating the code. We can now attempt to write a parameterized test.
    To do this, we will need to use the parameterized test runner. The preceding test
    has its own built-in runner provided by JUnit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再写一个测试来确保值是正确的，但最终我们会重复代码。现在我们可以尝试编写一个参数化测试。为此，我们需要使用参数化测试运行器。前面的测试由JUnit提供的内置运行器提供。
- en: 'The parameterized runner will run the test repeatedly for different values
    that we provide, and it will look like the following – please note that `import`
    statements have been removed for brevity:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化运行器将针对我们提供的不同值重复运行测试，并且看起来如下——请注意，为了简洁起见，已经删除了`import`语句：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will run six tests. The usage of the `@Parameterized` annotation tells
    JUnit that this is a test with multiple parameters and allows us to add a constructor
    for the test that will represent the input value for our `factorial` function
    and the output. We then defined a collection of parameters with the use of the
    `@``Parameterized.Parameters` annotation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行六个测试。`@Parameterized`注解的使用告诉JUnit这是一个具有多个参数的测试，并允许我们为测试添加一个构造函数，该构造函数将代表我们的`factorial`函数的输入值和输出。然后我们使用`@Parameterized.Parameters`注解定义了一个参数集合。
- en: Each parameter for this test is a separate list containing the input and the
    expected output. When JUnit runs this test, it will run a new instance for each
    parameter and then execute the test method. This will produce five successes and
    one failure when we test `0!`, meaning that we have found a bug.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的每个参数都是一个包含输入和预期输出的单独列表。当JUnit运行这个测试时，它将为每个参数运行一个新实例，然后执行测试方法。当我们测试`0!`时，这将产生五个成功和一个失败，这意味着我们找到了一个错误。
- en: 'We never accounted for a situation when `n = 0`. Now, we can go back to our
    code to fix the failure. We can do this by replacing the `reduce` function, which
    doesn’t allow us to specify an initial value, with a `fold` function, which allows
    us to give the initial value of `1`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未考虑到`n = 0`的情况。现在，我们可以回到我们的代码中修复失败。我们可以通过用允许我们指定初始值的`fold`函数替换不允许我们指定初始值的`reduce`函数来实现这一点：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running the tests now, they will all pass. But that doesn’t mean we are done
    here. There are many things that can go wrong. What happens if `n` is a negative
    number? Since we are dealing with factorials, we may get large numbers. We are
    working with integers in our examples, which means that the integer will overflow
    after `12!`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试，它们都将通过。但这并不意味着我们已经完成了。还有很多事情可能会出错。如果`n`是一个负数会发生什么？由于我们处理的是阶乘，我们可能会得到很大的数。在我们的例子中，我们使用整数，这意味着整数将在`12!`之后溢出。
- en: 'Normally, we would create new test methods in the `MyClassTest` class, but
    since the parameterized runner is used, all our new methods will be run multiple
    times, which will cost us time, so we will create a new test class to check our
    errors:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在`MyClassTest`类中创建新的测试方法，但由于使用了参数化运行器，我们所有的新方法都将多次运行，这将花费我们时间，因此我们将创建一个新的测试类来检查我们的错误：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This would lead to the following change in the class that was tested:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下被测试的类中的变化：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s solve the issue with very large factorials. We can use the `BigInteger`
    class, which can hold large numbers. We can update the test as follows (`import`
    statements not shown):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决非常大的阶乘的问题。我们可以使用`BigInteger`类，它可以存储大数。我们可以按如下方式更新测试（省略了`import`语句）：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The class under test now looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的类现在看起来像这样：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, we implemented the factorial with the help of `IntArray`.
    This implementation is based more on Kotlin’s ability to chain methods together,
    but it has one drawback: the fact that it uses memory for the array when it doesn’t
    need to.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过`IntArray`实现了阶乘。这种实现更多地基于Kotlin将方法链在一起的能力，但它有一个缺点：当它不需要时，它仍然使用内存来存储数组。
- en: We only care about the factorial and not storing all the numbers from `1` to
    `n`. We can change the implementation to a simple `for` loop and use the tests
    to guide us during the refactoring process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只关心阶乘，而不是存储从`1`到`n`的所有数字。我们可以将实现更改为简单的`for`循环，并在重构过程中使用测试来引导我们。
- en: 'We can observe here two benefits of having tests in your application:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到在应用程序中拥有测试的两个好处：
- en: They serve as updated documentation of how the features should be implemented
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们作为如何实现特性的更新文档。
- en: They guide us when refactoring code by maintaining the same assertion and detecting
    whether new changes to the code broke it
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当重构代码时，它们通过保持相同的断言并检测代码的新更改是否破坏了它来引导我们。
- en: 'Let’s update the code to get rid of `IntArray`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新代码以去除`IntArray`：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we modify the `factorial` function, as in the preceding example, and run
    the tests, we should see them all passing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改`factorial`函数，如前例所示，并运行测试，我们应该看到它们都通过。
- en: In certain situations, your tests will use a resource that is common to the
    test or the application (databases, files, and so on). Ideally, this shouldn’t
    happen for unit tests, but there can always be exceptions to this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你的测试将使用测试或应用程序共有的资源（数据库、文件等）。理想情况下，单元测试不应该发生这种情况，但总会有例外。
- en: 'Let’s analyze that scenario and see how JUnit can aid us with it. We will add
    a `companion` object, which will store the result, to simulate this behavior:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个场景，看看JUnit如何帮助我们。我们将添加一个`companion`对象，用于存储结果，以模拟这种行为：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we execute the tests for the preceding code, we will start seeing that some
    will fail. That’s because after the first tests execute the `factorial` function,
    the result will have the value of the executed tests, and when a new test is executed,
    the result of the factorial will be multiplied by the previous value of the result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面代码的测试，我们会开始看到一些测试会失败。这是因为第一次测试执行`factorial`函数后，结果将具有已执行测试的值，当执行新的测试时，阶乘的结果将被乘以前一个结果值。
- en: 'Normally, this would be good because the tests tell us that we are doing something
    wrong and we should remedy this, but for this example, we will address the issue
    directly in the tests:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这会很好，因为测试告诉我们我们在做错事，我们应该纠正它，但在这个例子中，我们将直接在测试中解决这个问题：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the tests, we’ve added two methods with the `@Before` and `@After` annotations.
    When these methods are introduced, JUnit will change the execution flow as follows:
    all methods with the `@Before` annotation will be executed, a method with the
    `@Test` annotation will be executed, and then all methods with the `@After` annotation
    will be executed. This process will repeat for every `@Test` method in your class.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们添加了两个带有`@Before`和`@After`注解的方法。当这些方法被引入时，JUnit将改变执行流程如下：所有带有`@Before`注解的方法将被执行，一个带有`@Test`注解的方法将被执行，然后所有带有`@After`注解的方法将被执行。这个过程将针对您类中的每个`@Test`方法重复。
- en: 'If you find yourself repeating the same statements in your `@Before` method,
    you can consider using `@Rule` to remove the repetition. We can set up a test
    rule for the preceding example. Test rules should be in the `test` or `androidTest`
    packages, as their usage is only limited to testing. They tend to be used in multiple
    tests, so you can place your rules in a `rules` package (`import` statements not
    shown):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己正在`@Before`方法中重复相同的语句，您可以考虑使用`@Rule`来消除重复。我们可以为前面的例子设置一个测试规则。测试规则应在`test`或`androidTest`包中，因为它们的用途仅限于测试。它们通常在多个测试中使用，因此您可以将您的规则放在一个`rules`包中（未显示`import`语句）：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, we can see that the rule will implement `TestRule`,
    which, in turn, comes with the `apply()` method. We then create a new `Statement`
    object that will execute the `base` statement (the test itself) and reset the
    value of the result before and after the statement. We can now modify the test
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到规则将实现`TestRule`，它反过来又带有`apply()`方法。然后我们创建一个新的`Statement`对象，该对象将执行`base`语句（即测试本身）并在语句前后重置结果值。现在我们可以按如下方式修改测试：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To add the rule to the test, we use the `@Rule` annotation. Since the test is
    written in Kotlin, we are using `@JvmField` to avoid generating getters and setters
    because `@Rule` requires a public field and not a method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将规则添加到测试中，我们使用`@Rule`注解。由于测试是用Kotlin编写的，我们使用`@JvmField`来避免生成getter和setter，因为`@Rule`需要一个公共字段而不是方法。
- en: In this section, we have learned how we can use JUnit to write tests that can
    verify small units of our code, by verifying the results, errors, or behavior
    for different parameters. We’ve also learned how each test is run when they are
    part of a testing class and the order of operations being invoked. In the next
    section, we will look at how we can use Android Studio to understand how we can
    run tests and view the results.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用JUnit编写测试，通过验证不同参数的结果、错误或行为来验证我们代码的小单元。我们还学习了当它们是测试类的一部分时，每个测试是如何运行的以及操作调用的顺序。在下一节中，我们将探讨如何使用Android
    Studio来了解如何运行测试和查看结果。
- en: Android Studio testing tips
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Studio测试技巧
- en: Android Studio comes with a good set of shortcuts and visual tools to help with
    testing. If you want to create a new test for your class or go to existing tests
    for your class, you can use the *Ctrl* + *Shift* + *T* (Windows) or *Command*
    + *Shift* + *T* (Mac) shortcut. You will need to make sure that the contents of
    your class are currently in focus in the editor for the keyboard shortcut to take
    effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio自带了一套良好的快捷键和可视化工具，有助于进行测试。如果您想为您的类创建一个新的测试或转到您类中的现有测试，您可以使用*Ctrl*
    + *Shift* + *T*（Windows）或*Command* + *Shift* + *T*（Mac）快捷键。您需要确保在编辑器中当前聚焦的是您类的内容，以便快捷键生效。
- en: 'In order to run tests, there are multiple options: right-click your file or
    the package and select the **Run ''Tests in…''** option, or if you want to run
    a test independently, you can go to the particular test method and select the
    green icon at the top of the class, which will execute all the tests in the class.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试有多种选项：右键单击文件或包，然后选择 **运行 'Tests in…'** 选项，或者如果您想独立运行测试，可以进入特定的测试方法，并选择类顶部的绿色图标，这将执行该类中的所有测试。
- en: '![Figure 10.2 – Running a group of tests](img/B19411_10_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 运行测试组](img/B19411_10_02.jpg)'
- en: Figure 10.2 – Running a group of tests
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 运行测试组
- en: For an individual test, you can click the green icon next to the `@Test` annotated
    methods.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个测试，您可以点击 `@Test` 注释方法旁边的绿色图标。
- en: '![Figure 10.3 – Icons for running individual tests](img/B19411_10_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 运行单个测试的图标](img/B19411_10_03.jpg)'
- en: Figure 10.3 – Icons for running individual tests
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 运行单个测试的图标
- en: 'This will trigger the test execution, which will be displayed in the **Run**
    tab, as shown in the following screenshot. When the tests are completed, they
    will become either red or green, depending on their success state:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发测试执行，将在 **运行** 选项卡中显示，如下面的截图所示。当测试完成后，它们将根据其成功状态变为红色或绿色：
- en: '![Figure 10.4 – Test output in Android Studio](img/B19411_10_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – Android Studio 中的测试输出](img/B19411_10_04.jpg)'
- en: Figure 10.4 – Test output in Android Studio
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – Android Studio 中的测试输出
- en: Another important feature that can be found in tests is the debug one. This
    is important because you can debug both the test and the method under test, so
    if you find problems in fixing an issue, you can use this to view what the test
    used as input and how your code handles the input. The third feature you can find
    in the green icon next to a test is the **Run With** **Coverage** option.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中可以找到的另一个重要功能是调试功能。这很重要，因为您既可以调试测试，也可以调试被测试的方法，所以如果您在修复问题时遇到问题，可以使用此功能查看测试使用的输入以及您的代码如何处理输入。在测试旁边的绿色图标旁边，您还可以找到的第三个功能是
    **带有覆盖率运行** 选项。
- en: 'This helps developers identify which lines of code are covered by the test
    and which ones are skipped. The higher the coverage, the higher the chances of
    finding crashes and bugs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于开发者识别哪些代码行被测试覆盖，哪些被跳过。覆盖率越高，发现崩溃和错误的机会就越大：
- en: '![Figure 10.5 – Test coverage in Android Studio](img/B19411_10_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – Android Studio 中的测试覆盖率](img/B19411_10_05.jpg)'
- en: Figure 10.5 – Test coverage in Android Studio
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – Android Studio 中的测试覆盖率
- en: In the preceding figure, you can see the coverage of our class broken down into
    the number of classes under test, the number of methods under test, and the number
    of lines under test.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到我们类的覆盖率分解为受测试的类数量、受测试的方法数量和受测试的行数。
- en: Another way to run tests for your Android app is through the command line. This
    is usually handy in situations where your project has **continuous integration**
    set up, meaning that every time you upload your code to a repository in the cloud,
    a set of scripts will be triggered to test it and ensure functionality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Android 应用测试的另一种方式是通过命令行。这在项目设置了 **持续集成** 的情况下通常很方便，这意味着每次您将代码上传到云端的代码库时，都会触发一系列脚本来测试它并确保其功能。
- en: Since this is done in the cloud, there is no need for Android Studio to be installed.
    For simplicity, we will be using the **Terminal** tab in Android Studio to emulate
    that behavior. The **Terminal** tab is usually located in the bottom bar in Android
    Studio near the **Logcat** tab.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是在云端完成的，因此不需要安装 Android Studio。为了简化，我们将使用 Android Studio 中的 **终端** 选项卡来模拟这种行为。**终端**
    选项卡通常位于 Android Studio 底部栏中，靠近 **日志输出** 选项卡。
- en: 'In every Android Studio project, a file called `gradlew` is present. This is
    an executable file that allows developers to execute Gradle commands. To run your
    local unit tests, you can use the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 Android Studio 项目中，都存在一个名为 `gradlew` 的文件。这是一个可执行文件，允许开发者执行 Gradle 命令。要运行本地单元测试，您可以使用以下命令：
- en: '`gradlew.bat test` (for Windows)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gradlew.bat test`（适用于 Windows）'
- en: '`./gradlew test` (for macOS and Linux)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./gradlew test`（适用于 macOS 和 Linux）'
- en: Once that command is executed, the app will be built and tested. You can find
    a variety of commands that you can input in **Terminal** in the **Gradle** tab
    located on the right-hand side of Android Studio.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，应用将被构建和测试。您可以在 Android Studio 右侧的 **Gradle** 选项卡中找到可以在 **终端** 中输入的各种命令。
- en: If you see the message saying **Task list has not been built**, click it and
    uncheck **Do not build Gradle task list during Gradle Sync**, click **OK**, and
    then sync the project’s Gradle files. The task list should then appear in the
    list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到消息说**任务列表尚未构建**，请点击它并取消选中**在Gradle同步期间不构建Gradle任务列表**，点击**确定**，然后同步项目的Gradle文件。然后任务列表应出现在列表中。
- en: The output of the tests, when executed from either the `app/build/reports` folder.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当从`app/build/reports`文件夹执行测试时，测试的输出。
- en: '![Figure 10.6 – Gradle commands in Android Studio](img/B19411_10_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – Android Studio中的Gradle命令](img/B19411_10_06.jpg)'
- en: Figure 10.6 – Gradle commands in Android Studio
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – Android Studio中的Gradle命令
- en: In this section, we have learned about the various options for testing that
    Android Studio provides and how we can visualize testing results. In the section
    that follows, we will look at how we can mock objects in tests and how we can
    use Mockito to do so.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Android Studio提供的各种测试选项以及我们如何可视化测试结果。在下一节中，我们将探讨如何在测试中模拟对象以及如何使用Mockito来实现这一点。
- en: Mockito
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito
- en: In the preceding examples, we looked at how to set up a unit test and how to
    use assertions to verify the result of an operation. What if we want to verify
    whether a certain method was called? Or what if we want to manipulate the test
    input to test a specific scenario? In these types of situations, we can use **Mockito**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何设置单元测试以及如何使用断言验证操作的结果。如果我们想验证某个方法是否被调用呢？或者如果我们想操纵测试输入以测试特定场景呢？在这些情况下，我们可以使用**Mockito**。
- en: This is a library that helps developers set up dummy objects that can be injected
    into the objects under test and allows them to verify method calls, set up inputs,
    and even monitor the test objects themselves.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个帮助开发者设置可以注入到测试对象中的虚拟对象并允许他们验证方法调用、设置输入，甚至监控测试对象的库。
- en: 'The library should be added to your `test` Gradle setup, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应将此库添加到您的`test` Gradle 设置中，如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let’s look at the following code example (please note that, for brevity,
    `import` statements have been removed from the following code snippets):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下代码示例（请注意，为了简洁，以下代码片段中已删除`import`语句）：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we have the `Context` object, which normally cannot be unit-tested because
    it’s part of the Android framework. We can use `mockito` to create a test double
    and inject it into the `StringConcatenator` object. Then, we can manipulate the
    call to `getString()` to return whatever input we chose. This process is referred
    to as **mocking**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`Context`对象，它通常不能进行单元测试，因为它属于Android框架的一部分。我们可以使用`mockito`创建一个测试替身并将其注入到`StringConcatenator`对象中。然后，我们可以操纵对`getString()`的调用，使其返回我们选择的任何输入。这个过程被称为**模拟**：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the test, we created a `mock` context. When the `concatenate` method was
    tested, we used Mockito to return a specific string when the `getString()` method
    was called with a particular input. This allowed us to then assert the result.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们创建了一个`mock`上下文。当测试`concatenate`方法时，我们使用Mockito在调用`getString()`方法并传入特定输入时返回一个特定的字符串。这允许我们随后断言结果。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`` ` `` is an escape character present in Kotlin and should not be confused
    with a quote mark. It allows the developer to give methods any name that they
    want, including special characters or reserved words.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`` ` ``是Kotlin中存在的一个转义字符，不应与引号混淆。它允许开发者给方法起任何他们想要的名称，包括特殊字符或保留字。'
- en: 'Mockito is not limited to mocking Android framework classes only. We can create
    a `SpecificStringConcatenator` class, which will use `StringConcatenator` to concatenate
    two specific strings from `strings.xml`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito不仅限于模拟Android框架类。我们可以创建一个`SpecificStringConcatenator`类，它将使用`StringConcatenator`将`strings.xml`中的两个特定字符串连接起来：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can write the test for it as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式编写测试：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are mocking the previous `StringConcatenator` and instructing the mock
    to return a specific result. If we run the test, it will fail because Mockito
    is not able to mock final classes. Here, it encounters a conflict with Kotlin
    that makes all classes *final* unless we specify them as *open*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在模拟之前的`StringConcatenator`并指示模拟返回一个特定的结果。如果我们运行测试，它将失败，因为Mockito无法模拟最终类。在这里，它与Kotlin发生冲突，使得所有类都成为*final*，除非我们指定它们为*open*。
- en: 'Luckily, there is a configuration we can apply that solves this dilemma without
    making the classes under test *open*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个配置我们可以应用，以解决这个困境，而不必使测试中的类成为*open*：
- en: Create a folder named `resources` in the `test` package.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test`包中创建一个名为`resources`的文件夹。
- en: In `resources`, create a folder named `mockito-extensions`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources`中，创建一个名为`mockito-extensions`的文件夹。
- en: In the `mockito-extensions` folder, create a file named `org.mockito.plugins.MockMaker`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mockito-extensions`文件夹中，创建一个名为`org.mockito.plugins.MockMaker`的文件。
- en: 'Inside the file, add the following line:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件内部，添加以下行：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In situations where you have callbacks or asynchronous work and cannot use
    the JUnit assertions, you can use `mockito` to verify the invocation on the callback
    or lambdas:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在你拥有回调或异步工作且不能使用JUnit断言的情况下，你可以使用`mockito`来验证回调或lambda的调用：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding example, we have added the `concatenateWithCallback` method,
    which will invoke the callback with the result of the `concatenateSpecificStrings`
    method. The test for this method would look something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们添加了`concatenateWithCallback`方法，它将使用`concatenateSpecificStrings`方法的输出调用回调。这个方法的测试可能看起来像这样：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we create a mock `Callback` object, which we can then verify at the end
    with the expected result. Notice that we had to duplicate the setup of the `concatenateSpecificStrings`
    method to test the `concatenateWithCallback` method. You should never mock the
    objects you are testing; however, you can use `spy` to change their behavior.
    We can spy the `stringConcatenator` object to change the outcome of the `concatenateSpecificStrings`
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个模拟的`Callback`对象，我们可以在最后用预期结果来验证它。注意，我们必须复制`concatenateSpecificStrings`方法的设置来测试`concatenateWithCallback`方法。你永远不应该模拟你正在测试的对象；然而，你可以使用`spy`来改变它们的行为。我们可以监视`stringConcatenator`对象来改变`concatenateSpecificStrings`方法的输出：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Mockito also relies on dependency injection to initialize class variables and
    has a custom build JUnit test runner. This can simplify the initialization of
    our variables, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito还依赖于依赖注入来初始化类变量，并有一个自定义构建的JUnit测试运行器。这可以简化我们的变量初始化，如下所示：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, `MockitoRunner` will inject the variables with the
    `@Mock` annotation with mocks. Next, it will create a new non-mocked instance
    of the field with the `@InjectMocks` annotation. When this instance is created,
    Mockito will try to inject the mock objects that match the signature of the constructor
    of that object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`MockitoRunner`将使用带有`@Mock`注解的模拟对象注入变量。接下来，它将创建一个新的带有`@InjectMocks`注解的非模拟实例。当这个实例被创建时，Mockito将尝试注入与该对象构造函数签名匹配的模拟对象。
- en: In this section, we have looked at how we can mock objects when we write tests
    and how we can use Mockito to do so. In the section that follows, we will look
    at a specialized library for Mockito that is better suited to be used with the
    Kotlin programming language, mockito-kotlin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在编写测试时如何模拟对象，以及如何使用Mockito来实现这一点。在接下来的章节中，我们将探讨一个更适合与Kotlin编程语言一起使用的Mockito专用库，即mockito-kotlin。
- en: You may have noticed in the preceding example that the `when` method from Mockito
    has escaped. This is because of a conflict with the Kotlin programming language.
    Mockito is built mainly for Java, and when Kotlin was created, it introduced the
    `this` keyword. Conflicts like this are escaped using the `` ` `` character.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在前面的例子中，Mockito的`when`方法已经逃逸了。这是因为与Kotlin编程语言的冲突。Mockito主要是为Java构建的，当Kotlin被创建时，它引入了`this`关键字。像这样的冲突可以通过反引号字符``
    ` ``来避免。
- en: 'This, along with some other minor issues, causes some inconvenience when using
    Mockito in Kotlin. A few libraries were introduced to wrap Mockito and provide
    a nicer experience when using it. One of those is `mockito-kotlin`. You can add
    this library to your module using the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这，加上一些其他小问题，在使用Mockito时造成了一些不便。一些库被引入来包装Mockito，并提供更好的使用体验。其中之一是`mockito-kotlin`。你可以使用以下命令将此库添加到你的模块中：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A big visible change this library adds is replacing the `when` method with `whenever`.
    Another useful change is replacing the `mock` method to rely on generics, rather
    than class objects. The rest of the syntax is like the Mockito syntax.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库带来的一个重大可见变化是用`whenever`替换了`when`方法。另一个有用的变化是将`mock`方法改为依赖于泛型，而不是类对象。其余的语法与Mockito语法类似。
- en: 'We can now update the previous tests with the new library, starting with `StringConcatenatorTest`
    (`import` statements have been removed for brevity):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用新库更新之前的测试，从`StringConcatenatorTest`开始（为了简洁，已删除`import`语句）：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can observe, the `` ` `` character has disappeared, and our mock initialization
    for the `Context` object has been simplified. We can apply the same thing for
    the `SpecificStringConcatenatorTest` class (`import` statements have been removed
    for brevity):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，反引号 ` `` 字符已经消失，我们对 `Context` 对象的模拟初始化已经简化。我们可以对 `SpecificStringConcatenatorTest`
    类（为了简洁，已删除 `import` 语句）做同样的事情：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section, we have looked at how we can use the `mockito-kotlin` library
    and how it can simplify the Mockito functions in Kotlin. In what follows, we will
    do an exercise on how we can write unit tests with JUnit and Mockito.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用 `mockito-kotlin` 库以及它如何简化 Kotlin 中的 Mockito 函数。在接下来的内容中，我们将进行一项练习，展示如何使用
    JUnit 和 Mockito 编写单元测试。
- en: Exercise 10.01 – testing the sum of numbers
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.01 – 测试数字之和
- en: 'Using JUnit, Mockito, and `mockito-kotlin`, write a set of tests for the following
    class that should cover the following scenarios:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JUnit、Mockito 和 `mockito-kotlin` 为以下类编写一组测试，以覆盖以下场景：
- en: Assert the values for `0`, `1`, `5`, `20`, and `Int.MAX_VALUE`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言 `0`、`1`、`5`、`20` 和 `Int.MAX_VALUE` 的值
- en: Assert the outcome for a negative number
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言负数的输出结果
- en: Fix the code and replace the sum of numbers with the formula *n*(n+1)/2*
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复代码，并将数字之和替换为公式 *n*(n+1)/2*
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this exercise, `import` statements are not shown. To see the full
    code files, refer to [https://packt.link/rv8C2](https://packt.link/rv8C2).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个练习过程中，没有显示 `import` 语句。要查看完整的代码文件，请参阅 [https://packt.link/rv8C2](https://packt.link/rv8C2)。
- en: 'The code to test is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试的代码如下：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个练习：
- en: 'Let’s make sure the necessary libraries are added to the `app/build.gradle`
    file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将必要的库添加到 `app/build.gradle` 文件中：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Create a class named `NumberAdder` and copy the preceding code inside it.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `NumberAdder` 的类，并将前面的代码复制到其中。
- en: Move the cursor inside the newly created class and, with *Command* + *Shift*
    + *T* or *Ctrl* + *Shift* + *T*, create a test class called `NumberAdderParameterTest`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移至新创建的类内部，使用 *Command* + *Shift* + *T* 或 *Ctrl* + *Shift* + *T* 创建一个名为 `NumberAdderParameterTest`
    的测试类。
- en: 'Create a parameterized test inside this class that will assert the outcomes
    for the `0`, `1`, `5`, `20`, and `Int.MAX_VALUE` values:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类内部创建一个参数化测试，该测试将断言 `0`、`1`、`5`、`20` 和 `Int.MAX_VALUE` 的输出结果：
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a separate test class that handles the exception thrown when there are
    negative numbers, named `NumberAdderErrorHandlingTest`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单独的测试类来处理当存在负数时抛出的异常，命名为 `NumberAdderErrorHandlingTest`：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since *1 + 2 + ...n = n * (n + 1) / 2*, we can use the formula in the code,
    and this would make the execution of the method run faster:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 *1 + 2 + ...n = n * (n + 1) / 2*，我们可以在代码中使用这个公式，这将使方法的执行速度更快：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the tests by right-clicking the package in which the tests are located
    and selecting **Run all in** [**package_name**]. An output similar to the following
    will appear, signifying that the tests have passed:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击包含测试的包并选择 **Run all in** [**package_name**] 来运行测试。将出现类似于以下输出的结果，表示测试已通过：
- en: '![Figure 10.7 – Output of Exercise 10.01](img/B19411_10_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 练习 10.01 的输出](img/B19411_10_07.jpg)'
- en: Figure 10.7 – Output of Exercise 10.01
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 练习 10.01 的输出
- en: By completing this exercise, we have taken the first steps into unit testing,
    managed to create multiple test cases for a single operation, taken the first
    steps into understanding Mockito, and used tests to guide us on how to refactor
    code without introducing any new issues.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们迈出了单元测试的第一步，为单个操作创建了多个测试用例，迈出了理解 Mockito 的第一步，并使用测试来指导我们如何重构代码而不引入任何新问题。
- en: Integration tests
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Let’s assume your project is covered by unit tests where a lot of your logic
    is held. You now have to add these tested classes to an activity or a fragment
    and require them to update your UI. How can you be certain that these classes
    will work well with each other? The answer to that question is through integration
    testing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的项目已经覆盖了单元测试，其中包含大量的逻辑。现在你必须将这些测试过的类添加到活动或片段中，并要求它们更新你的 UI。你如何确保这些类能够很好地协同工作？这个问题的答案是通过对集成测试。
- en: 'The idea behind this type of testing is to ensure that different components
    within your application integrate well with each other. Some examples include
    the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试类型背后的思想是确保你的应用程序内部的不同组件能够很好地相互集成。以下是一些例子：
- en: Ensuring that your API-related components parse the data well and interact well
    with your storage components
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的API相关组件能够很好地解析数据并与您的存储组件良好交互
- en: The storage components are capable of storing and retrieving the data correctly
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储组件能够正确存储和检索数据
- en: The UI components load and display the appropriate data
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI组件加载并显示适当的数据
- en: The transition between different screens in your application
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中不同屏幕之间的转换
- en: 'To aid with integration testing, the requirements are sometimes written in
    the format `Given - When - Then`. These usually represent acceptance criteria
    for a user story. Take the following example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助进行集成测试，有时要求以`Given - When - Then`的格式编写。这些通常代表用户故事的验收标准。以下是一个例子：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can use these steps to approach how we can write the integration tests for
    the feature we are developing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些步骤来探讨我们如何为正在开发的功能编写集成测试。
- en: 'On the Android platform, integration testing can be achieved with two libraries:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上，可以通过两个库来实现集成测试：
- en: '**Robolectric**: This library gives developers the ability to test Android
    components as unit tests – that is, executing integration tests without an actual
    device or emulator'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Robolectric**：这个库让开发者能够将Android组件作为单元测试进行测试——也就是说，在没有实际设备或模拟器的情况下执行集成测试'
- en: '**Espresso**: This library is helpful in instrumentation tests on an Android
    device or emulator'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Espresso**：这个库在Android设备或模拟器上的仪器化测试中非常有用'
- en: We’ll have a look at these libraries in detail in the next sections.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细探讨这些库。
- en: Robolectric
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Robolectric
- en: '**Robolectric** started as an open source library, which was meant to give
    users the ability to unit test classes from the Android framework as part of their
    local tests instead of the instrumented tests. Recently, it has been endorsed
    by Google and has been integrated with AndroidX Jetpack components.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**Robolectric**最初是一个开源库，旨在让用户能够在本地测试中作为单元测试的一部分对Android框架中的类进行测试，而不是使用仪器化测试。最近，它得到了谷歌的支持，并已与AndroidX
    Jetpack组件集成。'
- en: One of the main benefits of this library is the simplicity of testing activities
    and fragments. This is a benefit when it comes to integration tests because we
    can use this feature to make sure that our components integrate well with each
    other.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的主要好处之一是测试活动和片段的简单性。当涉及到集成测试时，这是一个优点，因为我们可以使用这个特性来确保我们的组件能够很好地相互集成。
- en: 'Some of Robolectric’s features are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Robolectric的一些功能如下：
- en: The possibility to instantiate and test the activity and fragment lifecycle
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化和测试活动和片段生命周期的可能性
- en: The possibility to test view inflation
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试视图膨胀的可能性
- en: The possibility to provide configurations for different Android APIs, orientations,
    screen sizes, layout directions, and so on
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供不同Android API、方向、屏幕尺寸、布局方向等配置的可能性
- en: The possibility to change the `Application` class, which then helps to change
    the modules to permit data mocks to be inserted
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变`Application`类的可能性，这有助于将模块更改以允许插入数据模拟
- en: 'To add Robolectric, along with the AndroidX integration, we will need the following
    libraries:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加Robolectric以及AndroidX集成，我们需要以下库：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The second library will bring a set of utility methods and classes required
    for testing Android components.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个库将提供一组用于测试Android组件的实用方法和类。
- en: Let’s assume we have to deliver a feature in which we display the text `Result
    x`, where `x` is the `factorial` function for a number that the user will insert
    in the `EditText` element. We will assume that we will use an Activity with an
    `EditText`, a `TextView`, and a `Button`. When the button is clicked, then we
    display in the `TextView` the factorial result of the number entered in the `EditText`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须交付一个功能，其中我们显示文本`Result x`，其中`x`是用户将在`EditText`元素中输入的数字的阶乘函数。我们将假设我们将使用一个带有`EditText`、`TextView`和`Button`的活动。当按钮被点击时，我们将在`TextView`中显示在`EditText`中输入的数字的阶乘结果。
- en: To achieve this, we have two classes, one that computes the factorial and another
    that concatenates the word `Result` with the factorial if the number is positive,
    or it will return the text `Error` if the number is negative.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们有两个类，一个用于计算阶乘，另一个将单词`Result`与正数的阶乘连接起来，如果数字是负数，它将返回文本`Error`。
- en: 'The `factorial` class will look something like this (throughout this example,
    `import` statements have been removed for brevity):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial`类看起来可能如下（在整个示例中，为了简洁起见，已删除`import`语句）：'
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `TextFormatter` class will look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextFormatter` 类将看起来像这样：'
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can combine these two components in our activity and have something like
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的活动中结合这两个组件，得到如下所示的内容：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can observe three components interacting with each other in this case. We
    can use Robolectric to test our activity. By testing the activity that creates
    the components, we can also test the interaction between all three of the components.
    We can write a test that looks like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以观察到三个组件正在相互交互。我们可以使用 Robolectric 来测试我们的活动。通过测试创建组件的活动，我们也可以测试所有三个组件之间的交互。我们可以编写如下所示的测试：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, we can see the AndroidX support for the activity test.
    The `AndroidJUnit4` test runner will set up Robolectric and create the necessary
    configurations, while the `launch` method will return a `scenario` object, which
    we can then play with to achieve the necessary conditions for the test. We can
    also observe how we can use the `` ` `` character to provide longer names to our
    functions, in which we can include whitespace characters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到 AndroidX 对活动测试的支持。`AndroidJUnit4` 测试运行器将设置 Robolectric 并创建必要的配置，而
    `launch` 方法将返回一个 `scenario` 对象，然后我们可以通过它来达到测试所需的条件。我们还可以观察到我们如何使用 `` ` `` 字符来为我们的函数提供更长的名称，其中可以包括空白字符。
- en: 'If we want to add configurations for the test, we can use the `@Config` annotation
    both on the class and on each of the test methods:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为测试添加配置，我们可以在类和每个测试方法上使用 `@Config` 注解：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also specify global configurations in the `test/resources` folder in
    the `robolectric.properties` file, like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `test/resources` 文件夹中的 `robolectric.properties` 文件中指定全局配置，如下所示：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another important feature that has recently been added to Robolectric is support
    for the Espresso library. This allows developers to use the syntax from Espresso
    to interact with views and make assertions on the views.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最近添加到 Robolectric 中的另一个重要功能是对 Espresso 库的支持。这允许开发者使用 Espresso 的语法与视图交互并对视图进行断言。
- en: 'Another library that can be used in combination with Robolectric is `FragmentScenario`,
    which allows the possibility to test fragments. These libraries can be added in
    Gradle using the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以与 Robolectric 结合使用的库是 `FragmentScenario`，它允许测试片段。这些库可以通过以下方式添加到 Gradle
    中：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Testing fragments is like activities using the `scenario` setup:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `scenario` 设置测试片段就像活动一样：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Espresso
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Espresso
- en: 'Espresso is a library designed to perform interactions and assertions in a
    concise way. It was initially designed to be used in instrumented tests, and now
    it has migrated to be used with Robolectric as well. The typical usage for performing
    an action is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 是一个旨在以简洁方式执行交互和断言的库。它最初是为了在仪器化测试中使用而设计的，现在它已经迁移到与 Robolectric 一起使用。执行操作的典型用法如下：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For verification, we can use the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证，我们可以使用以下方法：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can provide custom `ViewMatchers` if none can be found in the `ViewMatchers`
    class. Some of the most common ones are `withId` and `withText`. These two allow
    us to identify views based on their `R.id.myId` identifier or text identifier.
    Ideally, the first one should be used to identify a particular view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `ViewMatchers` 类中找不到任何自定义的 `ViewMatchers`，我们可以提供自定义的 `ViewMatchers`。其中一些最常见的是
    `withId` 和 `withText`。这两个允许我们根据它们的 `R.id.myId` 标识符或文本标识符来识别视图。理想情况下，第一个应该用来识别特定的视图。
- en: 'Another interesting aspect of Espresso is the reliance on the `Hamcrest` library
    for matchers. This is a Java library that aims to improve testing. This allows
    multiple matchers to be combined if necessary. Let’s say that the same ID is present
    in different views on your UI. You can narrow your search for a specific view
    using the following expression:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 的另一个有趣方面是它依赖于 `Hamcrest` 库进行匹配器。这是一个旨在改进测试的 Java 库。这允许在必要时组合多个匹配器。假设相同的
    ID 出现在您的 UI 的不同视图中。您可以使用以下表达式来缩小对特定视图的搜索：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `allOf` expression will evaluate all of the other operators and will pass
    only if all of the operators inside pass. The preceding expressions will translate
    to *Find the view with id=edit_text that has the parent with id=R.id.root*. Other
    `Hamcrest` operators may include `anyOf`, `both`, `either`, `is`, `isA`, `hasItem`,
    `equalTo`, `any`, `instanceOf`, `not`, `null`, and `notNull`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`allOf` 表达式将评估所有其他操作符，并且只有当所有内部操作符都通过时才会通过。前面的表达式将翻译为“找到具有 id=edit_text 的视图，其父视图具有
    id=R.id.root”。其他 `Hamcrest` 操作符可能包括 `anyOf`、`both`、`either`、`is`、`isA`、`hasItem`、`equalTo`、`any`、`instanceOf`、`not`、`null`
    和 `notNull`。'
- en: '`ViewActions` have a similar approach to `ViewMatchers`. We can find common
    ones in the `ViewActions` class. Common ones include `typeText`, `click`, `scrollTo`,
    `clearText`, `swipeLeft`, `swipeRight`, `swipeUp`, `swipeDown`, `closeSoftKeyboard`,
    `pressBack`, `pressKey`, `doubleClick`, and `longClick`. If you have custom views
    and certain actions are required, then you can implement your own `ViewAction`
    element by implementing the `ViewAction` interface.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewActions` 与 `ViewMatchers` 有相似的方法。我们可以在 `ViewActions` 类中找到共同的实现。常见的包括 `typeText`、`click`、`scrollTo`、`clearText`、`swipeLeft`、`swipeRight`、`swipeUp`、`swipeDown`、`closeSoftKeyboard`、`pressBack`、`pressKey`、`doubleClick`
    和 `longClick`。如果你有自定义视图并且需要某些特定操作，那么你可以通过实现 `ViewAction` 接口来创建自己的 `ViewAction`
    元素。'
- en: 'Similar to the preceding examples, `ViewAssertions` have their own class. Typically,
    the `matches` method is used, where you can then use `ViewMatchers` and `Hamcrest`
    matchers to validate the result:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例类似，`ViewAssertions` 有自己的类。通常使用 `matches` 方法，然后你可以使用 `ViewMatchers` 和 `Hamcrest`
    匹配器来验证结果：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding example will verify that the view with the `text_view` ID will
    contain the text `My text`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将验证具有 `text_view` ID 的视图将包含文本 `My text`：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will click the view with the ID button.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将点击具有 ID 按钮的视图。
- en: 'We can now rewrite the Robolectric test and add Espresso, which will give us
    this (the `import` statement is not shown):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以重写 Robolectric 测试并添加 Espresso，这将给我们以下结果（这里没有显示 `import` 语句）：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code sample, we can observe how, using Espresso, we input the
    number `5` into `EditText`, then click on the button, and then assert the text
    displayed in `TextView` with the help of the `onView()` method to obtain a reference
    to the view, and then execute actions using `perform()` or make assertions using
    `check()`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以观察到如何使用 Espresso 将数字 `5` 输入到 `EditText` 中，然后点击按钮，然后使用 `onView()`
    方法获取视图引用，并通过 `perform()` 执行操作或使用 `check()` 进行断言来断言 `TextView` 中显示的文本。
- en: Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the following exercise, you will need an emulator or a physical device with
    USB debugging enabled. You can do so by selecting **Tools** | **AVD Manager**
    in Android Studio. Then, you can create one with the **Create Virtual Device**
    option by selecting the type of emulator, clicking **Next**, and then selecting
    an x86 image. Any image larger than Lollipop should be alright for this exercise.
    Next, you can give your image a name and click **Finish**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下练习，你需要一个启用了 USB 调试的模拟器或物理设备。你可以在 Android Studio 中通过选择 **工具** | **AVD 管理器**
    来这样做。然后，你可以通过选择模拟器类型，点击 **下一步**，然后选择一个 x86 图像来创建一个。对于这个练习，任何大于 Lollipop 的图像都将是合适的。接下来，你可以给你的图像命名并点击
    **完成**。
- en: Exercise 10.02 – double integration
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.02 – 双重积分
- en: 'Develop an application that observes the following requirements:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个满足以下要求的应用程序：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You should implement both unit tests and integration tests using Robolectric
    and Espresso and migrate the integration tests to become instrumentation tests.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用 Robolectric 和 Espresso 实现单元测试和集成测试，并将集成测试迁移为仪器测试。
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this exercise, `import` statements are not shown. To see the full
    code files, refer to [https://packt.link/EcmiV](https://packt.link/EcmiV).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个练习过程中，没有显示 `import` 语句。要查看完整的代码文件，请参考 [https://packt.link/EcmiV](https://packt.link/EcmiV)。
- en: 'Implement the following steps to complete this exercise:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 实现以下步骤来完成这个练习：
- en: 'Let’s start by adding the necessary test libraries to `app/build.gradle`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向 `app/build.gradle` 添加必要的测试库开始：
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For Robolectric, we will need to add extra configurations, the first of which
    is to add the following line to `app/build.gradle` in the `android` closure:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Robolectric，我们需要添加额外的配置，首先是向 `app/build.gradle` 中的 `android` 封闭添加以下行：
- en: '[PRE50]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Create a `resources` directory in the `test` package. You will need to switch
    your Android Studio project view from **Android** to **Project**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test` 包中创建一个 `resources` 目录。你需要将 Android Studio 项目视图从 **Android** 切换到 **Project**。
- en: 'Add the `robolectric.properties` file and add the following configuration to
    that file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `robolectric.properties` 文件，并将以下配置添加到该文件中：
- en: '[PRE51]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In `resources`, create a folder named `mockito-extensions`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources` 中创建一个名为 `mockito-extensions` 的文件夹。
- en: 'In the `mockito-extensions` folder, create a file named `org.mockito.plugins.MockMaker`,
    and inside the file, add the following line:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mockito-extensions` 文件夹中，创建一个名为 `org.mockito.plugins.MockMaker` 的文件，并在文件中添加以下行：
- en: '[PRE52]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create the `NumberAdder` class. This is similar to the one in *Exercise 10.01*:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `NumberAdder` 类。这与 *练习 10.01* 中的类似：
- en: '[PRE53]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the tests for `NumberAdder` in the `test` folder. First, create `NumberAdder``ParameterTest`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test`文件夹中为`NumberAdder`创建测试。首先创建`NumberAdderParameterTest`：
- en: '[PRE54]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The complete code for this step can be found at [https://packt.link/ghcTs](https://packt.link/ghcTs).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在[https://packt.link/ghcTs](https://packt.link/ghcTs)找到。
- en: 'Then, create the `NumberAdderErrorHandlingTest` test:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建`NumberAdderErrorHandlingTest`测试：
- en: '[PRE55]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `main` folder in the root package, create a class that will format the
    sum and concatenate it with the necessary strings:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main`文件夹中，创建一个将格式化总和并将其与必要的字符串连接的类：
- en: '[PRE56]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Unit-test this class for both the success and error scenarios. Start with the
    success scenario:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对此类进行单元测试，以测试成功和错误场景。从成功场景开始：
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, create the test for the error scenario:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建错误场景的测试：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `main/res/values/strings.xml`, add the following strings:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main/res/values/strings.xml`中添加以下字符串：
- en: '[PRE59]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create the layout for `activity_main.xml` in the `main/res/layout` folder:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main/res/layout`文件夹中创建`activity_main.xml`布局：
- en: '[PRE60]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The complete code for this step can be found at [https://packt.link/hxZ0I](https://packt.link/hxZ0I).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在[https://packt.link/hxZ0I](https://packt.link/hxZ0I)找到。
- en: 'In the `main` folder in the root package, create the `MainActivity` class,
    which will contain all the other components:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main`文件夹中，创建`MainActivity`类，它将包含所有其他组件：
- en: '[PRE61]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a test for `MainActivity` and place it in the `test` directory. It will
    contain two test methods, one for success and one for errors:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test`目录中创建`MainActivity`的测试，它将包含两个测试方法，一个用于成功，一个用于错误：
- en: '[PRE62]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The complete code for this step can be found at [https://packt.link/fZI3u](https://packt.link/fZI3u).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在[https://packt.link/fZI3u](https://packt.link/fZI3u)找到。
- en: 'If you run the tests by right-clicking the package in which the tests are located
    and selecting **Run all in** [**package_name**], then an output like the following
    will appear:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过右键单击包含测试的包并选择**运行所有在** [**包名**]，则会显示如下输出：
- en: '![Figure 10.8 – Result of executing the tests in the test folder for Exercise
    10.02](img/B19411_10_08.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 执行10.02练习测试文件夹中测试的结果](img/B19411_10_08.jpg)'
- en: Figure 10.8 – Result of executing the tests in the test folder for Exercise
    10.02
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 执行10.02练习测试文件夹中测试的结果
- en: If you execute the preceding tests, you should see an output like *Figure 10**.8*.
    The Robolectric test is executed in the same way as a regular unit test; however,
    there is an increase in the execution time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行前面的测试，您应该会看到一个类似*图10**.8*的输出。Robolectric测试的执行方式与常规单元测试相同；然而，执行时间有所增加。
- en: Let’s now migrate the preceding test to an instrumented integration test. To
    do this, we will copy the preceding test from the `test` package into the `androidTest`
    package and remove the code related to scenarios from our tests. Make sure that
    in the `androidTest` folder, there is a Java folder that contains a package with
    the same name as the `main/java` folder. You will need to move your tests to this
    package.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将前面的测试迁移到仪器化集成测试。为此，我们将从`test`包中复制前面的测试到`androidTest`包，并从测试中删除与场景相关的代码。确保在`androidTest`文件夹中有一个包含与`main/java`文件夹同名包的Java文件夹。您需要将测试移动到这个包。
- en: 'After copying the file, we will use `ActivityTestRule`, which will launch our
    activity before every test is executed. We will also need to rename the class
    to avoid duplicates and rename the test methods because the syntax is not supported
    for instrumented tests:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复制文件后，我们将使用`ActivityTestRule`，它将在每个测试执行之前启动我们的活动。我们还需要重命名类以避免重复，并重命名测试方法，因为语法不支持对仪器化测试的支持：
- en: '[PRE63]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The complete code for this step can be found at [https://packt.link/hNB4A](https://packt.link/hNB4A).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在[https://packt.link/hNB4A](https://packt.link/hNB4A)找到。
- en: 'If you run the tests by right-clicking the package in which the tests are located
    and selecting **Run all in** [**package_name**], then an output like the following
    will appear:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过右键单击包含测试的包并选择**运行所有在** [**包名**]，则会显示如下输出：
- en: '![Figure 10.9 – Result of executing the tests in the androidTest folder for
    Exercise 10.02](img/B19411_10_09.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 执行10.02练习androidTest文件夹中测试的结果](img/B19411_10_09.jpg)'
- en: Figure 10.9 – Result of executing the tests in the androidTest folder for Exercise
    10.02
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 执行10.02练习androidTest文件夹中测试的结果
- en: In *Figure 10**.9*, we can see what Android Studio displays as an output for
    the result. If you pay attention to the emulator while the tests are executing,
    you can see that for each test, your activity will be opened, the input will be
    set in the field, and the button will be clicked.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.9*中，我们可以看到Android Studio显示的结果输出。如果在测试执行时注意模拟器，你可以看到对于每个测试，你的活动将被打开，输入将被设置在字段中，按钮将被点击。
- en: Both of our integration tests (on the workstation and the emulator) try to match
    the accepted criteria of the requirement. The integration tests verify the same
    behavior, the only difference is that one checks it locally and the other checks
    it on an Android device or emulator. The main benefit here is the fact that Espresso
    was able to bridge the gap between them, making integration tests easier to set
    up and execute.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个集成测试（在工作站和模拟器上）都试图匹配需求的接受标准。集成测试验证相同的行为，唯一的区别是其中一个在本地检查，而另一个在Android设备或模拟器上检查。这里的主要好处是Espresso能够弥合它们之间的差距，使得集成测试更容易设置和执行。
- en: In this section, we have implemented an exercise in which we have written tests
    with the Robolectric library combined with the Espresso library and looked at
    how we can migrate our Robolectric tests from the `test` folder to the `androidTest`
    folder. In the section that follows, we will look at how we can build upon the
    existing testing suite with instrumented tests that run on physical devices or
    emulators.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了一个练习，其中我们使用Robolectric库和Espresso库编写了测试，并探讨了如何将我们的Robolectric测试从`test`文件夹迁移到`androidTest`文件夹。在接下来的部分，我们将探讨如何通过在物理设备或模拟器上运行的instrumented测试来扩展现有的测试套件。
- en: UI tests
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI测试
- en: UI tests are instrumented tests where developers can simulate user journeys
    and verify the interactions between different modules of the application. They
    are also referred to as end-to-end tests. For small applications, you can have
    one test suite, but for larger applications, you should split your test suites
    to cover user journeys (logging in, creating an account, setting up flows, and
    so on).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试是instrumented测试，开发者可以模拟用户旅程并验证应用程序不同模块之间的交互。它们也被称为端到端测试。对于小型应用程序，你可以有一个测试套件，但对于大型应用程序，你应该将测试套件拆分以覆盖用户旅程（登录、创建账户、设置流程等）。
- en: 'Because they are executed on the device, you will need to write them in the
    `androidTest` package, which means they will run with the **Instrumentation**
    framework. Instrumentation works as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是在设备上执行的，所以你需要将它们写入`androidTest`包中，这意味着它们将使用**Instrumentation**框架运行。Instrumentation的工作原理如下：
- en: The app is built and installed on the device
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序在设备上构建和安装
- en: A testing app will also be installed on the device that will monitor your app
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还将在设备上安装一个测试应用程序来监控你的应用程序
- en: The testing app will execute the tests on your app and record the results
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应用程序将在你的应用程序上执行测试并记录结果
- en: One of the drawbacks of this is the fact that the tests will share persisted
    data, so if a test stores data on the device, then the second test can have access
    to that data, which means that there is a risk of failure. Another drawback is
    that if a test comes across a crash, this will stop the entire testing because
    the application under test is stopped.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中的一个缺点是测试将共享持久数据，所以如果一个测试在设备上存储了数据，那么第二个测试就可以访问这些数据，这意味着存在失败的风险。另一个缺点是如果测试遇到崩溃，这将停止整个测试，因为被测试的应用程序已经停止。
- en: These issues were solved in the Jetpack updates with the introduction of the
    **orchestrator** framework. Orchestrators give you the ability to clear the data
    after each test is executed, sparing developers the need to make any adjustments.
    The orchestrator is represented by another application that will manage how the
    testing app will coordinate the tests and the data between the tests.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题在Jetpack更新中通过引入**orchestrator**框架得到了解决。Orchestrators允许你在每个测试执行后清除数据，从而免除开发者进行任何调整的需要。Orchestrator由另一个应用程序表示，该应用程序将管理测试应用程序如何协调测试和数据。
- en: 'In order to add it to your project, you need a configuration similar to this
    in the `app/build.gradle` file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其添加到你的项目中，你需要在`app/build.gradle`文件中有一个类似的配置：
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can execute the orchestrator test on a connected device using Gradle’s `connectedCheck`
    command, either from Terminal or from the list of Gradle commands.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Gradle的`connectedCheck`命令在连接的设备上执行orchestrator测试，无论是从终端还是从Gradle命令列表中。
- en: 'In the configuration, you will notice the following line: `testInstrumentationRunner`.
    This allows us to create a custom configuration for the test, which gives us the
    opportunity to inject mock data into the modules:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，您会注意到以下行：`testInstrumentationRunner`。这允许我们为测试创建一个自定义配置，这给了我们向模块注入模拟数据的机会：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`CustomTestRunner` looks like this (`import` statements are not shown in the
    following code snippets):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomTestRunner` 看起来像这样（以下代码片段中未显示 `import` 语句）：'
- en: '[PRE66]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The test classes themselves can be written by applying the JUnit4 syntax with
    the help of the `androidx.test.ext.junit.runners.AndroidJUnit4` test runner:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类本身可以通过使用 `androidx.test.ext.junit.runners.AndroidJUnit4` 测试运行器的帮助，应用 JUnit4
    语法来编写：
- en: '[PRE67]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `@Test` methods themselves run in a dedicated test thread, which is why
    a library such as Espresso is helpful. Espresso will automatically move every
    interaction with a view on the UI thread. Espresso can be used for UI tests in
    a similar way as it is used with Robolectric tests:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Test` 方法本身在专用的测试线程中运行，这就是为什么像 Espresso 这样的库很有帮助。Espresso 将自动将每个与 UI 上的视图交互的操作移动到
    UI 线程。Espresso 可以像 Robolectric 测试一样用于 UI 测试：'
- en: '[PRE68]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Typically, in UI tests, you will find interactions and assertions that may
    get repetitive. In order to avoid duplicating multiple scenarios in your code,
    you can apply a pattern called `Robot` class in which the interactions and assertions
    can be grouped into specific methods. Your test code will use the robots and assert
    them. A typical robot will look something like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 UI 测试中，您会发现可能重复的交互和断言。为了避免在您的代码中重复多个场景，您可以使用名为 `Robot` 类的模式，其中交互和断言可以组合到特定的方法中。您的测试代码将使用机器人并断言它们。一个典型的机器人可能如下所示：
- en: '[PRE69]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The test will look like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将看起来像这样：
- en: '[PRE70]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Because apps can be multithreaded and sometimes it takes a while to load data
    from various sources (internet, files, local storage, and so on), the UI tests
    will have to know when the UI is available for interactions. One way to implement
    this is through the use of idling resources.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序可以是多线程的，并且有时需要一段时间从各种来源（互联网、文件、本地存储等）加载数据，UI 测试将需要知道何时 UI 可用于交互。实现这一点的其中一种方法是通过使用空闲资源。
- en: These are objects that can be registered to Espresso before the test and injected
    into your application’s components where multithreaded work is done. The apps
    will mark them as non-idle when the work is in progress and idle when the work
    is done. It is at this point that Espresso will then start executing the test.
    One of the most commonly used ones is `CountingIdlingResource`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在测试之前可以注册到 Espresso 中，并注入到应用程序组件中进行多线程工作的对象。当工作正在进行时，应用程序将它们标记为非空闲，当工作完成时，它们将变为空闲。Espresso
    将在此时开始执行测试。最常用的之一是 `CountingIdlingResource`。
- en: 'This specific implementation uses a counter that should be incremented when
    you want Espresso to wait for your code to complete its execution and decremented
    when you want to let Espresso verify your code. When the counter reaches `0`,
    Espresso will resume testing. An example of a component with an idling resource
    looks something like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的实现使用一个计数器，当您希望 Espresso 等待您的代码完成执行时，计数器应该增加；当您希望 Espresso 验证您的代码时，计数器应该减少。当计数器达到
    `0` 时，Espresso 将继续测试。一个具有空闲资源的组件示例可能如下所示：
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Application` class can be used to inject the idling resource, like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Application` 类注入空闲资源，如下所示：
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, in the test, we can access the `Application` class and register the resource
    to Espresso:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在测试中，我们可以访问 `Application` 类并将资源注册到 Espresso 中：
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Espresso comes with a set of extensions that can be used to assert different
    Android components. One extension is intents testing. This is useful when you
    want to test an activity in isolation (more appropriate for integration tests).
    In order to use this, you need to add the library to Gradle:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 附带一套可以用来断言不同 Android 组件的扩展。其中一个扩展是意图测试。当您想单独测试一个活动时，这很有用（更适合集成测试）。为了使用此功能，您需要将库添加到
    Gradle：
- en: '[PRE74]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: After you add the library, you need to set up the necessary intent monitoring
    using the `init` method from the `Intents` class, and to stop monitoring, you
    can use the `release` method from the same class. These operations can be done
    in the `@Before` and `@After` annotated methods of your test class.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加库之后，您需要使用 `Intents` 类的 `init` 方法设置必要的意图监控，并且要停止监控，可以使用同一类的 `release` 方法。这些操作可以在您的测试类的
    `@Before` 和 `@After` 注解方法中完成。
- en: 'To assert the values of the intent, you need to trigger the appropriate action
    and then use the `intended` method:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了断言意图的值，你需要触发适当的行为，然后使用 `intended` 方法：
- en: '[PRE75]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `intended` method works in a similar way to the `onView` method. It requires
    a matcher that can be combined with a `Hamcrest` matcher. The intent-related matchers
    can be found in the `IntentMatchers` class. This class contains methods to assert
    different methods of the `Intent` class: extras, data, components, bundles, and
    so on.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`intended` 方法与 `onView` 方法的工作方式类似。它需要一个可以与 `Hamcrest` 匹配器结合的匹配器。与意图相关的匹配器可以在
    `IntentMatchers` 类中找到。这个类包含了一系列断言 `Intent` 类不同方法的方法：extras、data、components、bundles
    等。'
- en: 'Another important extension library comes to the aid of `RecyclerView`. The
    `onData` method from Espresso is only capable of testing `AdapterViews` such as
    `ListView` and isn’t capable of asserting `RecyclerView`. In order to use the
    extension, you need to add the following library to your project:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的扩展库也帮助了 `RecyclerView`。Espresso 的 `onData` 方法只能测试 `AdapterViews`，例如 `ListView`，而不能断言
    `RecyclerView`。为了使用这个扩展，你需要将以下库添加到你的项目中：
- en: '[PRE76]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This library provides a `RecyclerViewActions` class, which contains a set of
    methods that allow you to perform actions on items inside `RecyclerView`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库提供了一个 `RecyclerViewActions` 类，它包含了一系列允许你在 `RecyclerView` 内部项目上执行操作的方法：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The preceding statement will click the item at position `0`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将点击位置 `0` 的项目：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This will scroll to the 10th item in the list:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这将滚动到列表中的第 10 个项目：
- en: '[PRE79]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding code will check whether a view with the `myText` text is displayed,
    which will also apply to `RecyclerView` items.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将检查是否显示了带有 `myText` 文本的视图，这同样适用于 `RecyclerView` 项目。
- en: Testing in Jetpack Compose
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 中的测试
- en: 'Jetpack Compose offers the ability to test `@Composable` functions with a similar
    approach to Espresso. If we are using Robolectric, we can write our testing code
    in the `test` folder, and if not, we can use the `androidTest` folder and our
    tests will be viewed as instrumented tests. The testing library is the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 提供了使用与 Espresso 类似的方法来测试 `@Composable` 函数。如果我们使用 Robolectric，我们可以在
    `test` 文件夹中编写我们的测试代码；如果不使用，我们可以使用 `androidTest` 文件夹，并且我们的测试将被视为仪器化测试。测试库如下：
- en: '[PRE80]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If we want to also test the `Activity` that sets the `@Composable` function
    as content, then we will also need to add the following library:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想测试设置 `@Composable` 函数作为内容的 `Activity`，那么我们还需要添加以下库：
- en: '[PRE81]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To test, we would need to use a test rule that provides a set of methods used
    for interacting with the `@Composable` elements and performing assertions on them.
    We have multiple ways of obtaining that rule through the following approaches:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行测试，我们需要使用一个提供用于与 `@Composable` 元素交互和对其执行断言的方法集的测试规则。我们可以通过以下方法获得该规则：
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the preceding snippet, we have two test rules. The first one, `composeTestRuleForActivity`,
    will start the `Activity` that holds the `@Composable` function that we want to
    test and will hold all the nodes we want to assert.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有两条测试规则。第一条，`composeTestRuleForActivity`，将启动包含我们想要测试的 `@Composable`
    函数的 `Activity`，并将包含我们想要断言的所有节点。
- en: The second one, `composeTestRuleForNoActivity`, provides the ability to set
    as content the function we want to test. This will then allow the rule to have
    access to all the `@``Composable` elements.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`composeTestRuleForNoActivity`，提供了将我们想要测试的函数设置为内容的权限。这样，规则就可以访问所有的 `@Composable`
    元素。
- en: 'If we want to identify elements from our function, we have the following methods:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从我们的函数中识别元素，我们有以下方法：
- en: '[PRE83]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding snippet, we have the `onNodeWithText` method, which will identify
    a particular UI element using a text label that’s visible to the user. The `onNodeWithContentDescription`
    method will identify an element using the content description set, and `onNodeWithTag`
    will identify an element using the test tag, which is set using the `Modifier.testTag`
    method.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有 `onNodeWithText` 方法，它将使用用户可见的文本标签来识别特定的 UI 元素。`onNodeWithContentDescription`
    方法将使用设置的内容描述来识别元素，而 `onNodeWithTag` 将使用测试标签来识别元素，该标签是通过 `Modifier.testTag` 方法设置的。
- en: 'Like Espresso, once we identify the element we want to interact with or perform
    assertions on, we have similar methods for both situations. For interacting with
    the element, we have methods such as the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Espresso 类似，一旦我们确定了想要与之交互或对其执行断言的元素，我们就有类似的方法来处理这两种情况。对于与元素交互，我们有以下方法：
- en: '[PRE84]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the preceding snippet, we perform a click, scroll, text insertion, and gesture
    into the element. For assertions, some examples are as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们对元素执行了点击、滚动、文本插入和手势操作。对于断言，以下是一些示例：
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the preceding example, we assert whether an element is displayed, not displayed,
    enabled, not enabled, selected, or not selected.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们断言元素是显示的、未显示的、启用的、未启用的、选中的或未选中的。
- en: 'If our user interface has multiple elements with the same text, we have the
    option to extract all of them using the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户界面有多个具有相同文本的元素，我们可以使用以下方法提取所有这些元素：
- en: '[PRE86]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here, we extract all the nodes that have `My text` as a text, `My content description`
    as a content description, and `My test tag` as a test tag. The return is a collection,
    which allows us to assert each element of the collection individually, like so:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提取所有具有`My text`作为文本、`My content description`作为内容描述和`My test tag`作为测试标签的节点。返回的是一个集合，允许我们单独断言集合中的每个元素，如下所示：
- en: '[PRE87]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here, we assert that the first element that has `My text` is displayed. We
    also can perform assertions on the collection, like so:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们断言第一个具有`My text`文本的元素是显示的。我们还可以对集合执行断言，如下所示：
- en: '[PRE88]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, we assert that the number of elements that have `My text` as a text set
    is three, assert whether all elements match a `SemanticsMatcher`, or assert whether
    any of the elements match a `SemanticMatcher`. In this case, it would assert that
    all the elements are selected and at least one element is selected.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们断言具有`My text`作为文本集的元素数量为三个，断言所有元素是否匹配`SemanticsMatcher`，或断言任何元素是否匹配`SemanticMatcher`。在这种情况下，它将断言所有元素都是选中的，并且至少有一个元素被选中。
- en: 'Another similarity to Espresso that we have when testing Jetpack Compose is
    the usage of `IdlingResource`. Compose provides its own `IdlingResource` abstraction,
    which is separate from Espresso and can be registered to our test rule as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试Jetpack Compose时，与Espresso相似的一个相似之处是`IdlingResource`的使用。Compose提供自己的`IdlingResource`抽象，它独立于Espresso，可以注册到我们的测试规则中，如下所示：
- en: '[PRE89]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the preceding snippet, we register `IdlingResource` in the `@Before` annotated
    method and unregister it in the `@``After` method.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`@Before`注解的方法中注册`IdlingResource`，并在`@After`方法中注销它。
- en: Exercise 10.03 – random waiting times
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03 – 随机等待时间
- en: 'Write an application that will have two screens. The first screen will have
    a button. When the user presses the button, it will wait a random time between
    1 and 5 seconds and then launch the second screen, which will display the text
    **Opened after x seconds**, where **x** is the number of seconds that passed.
    Write a UI test that will cover this scenario with the following features adjusted
    for the test:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个应用程序，它将有两个屏幕。第一个屏幕将有一个按钮。当用户按下按钮时，它将在1到5秒之间等待随机的时间，然后启动第二个屏幕，该屏幕将显示文本**在x秒后打开**，其中**x**是经过的秒数。编写一个UI测试，以涵盖此场景，并调整以下功能以进行测试：
- en: The `random` function will return a value of `1` when the test is run
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试运行时，`random`函数将返回`1`的值
- en: '`CountingIdlingResource` will be used to indicate when the timer has stopped'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountingIdlingResource`将用于指示计时器何时停止'
- en: Note
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this exercise, `import` statements are not shown. To see the full
    code files, refer to [https://packt.link/GG32r](https://packt.link/GG32r).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个练习中，没有显示`import`语句。要查看完整的代码文件，请参阅[https://packt.link/GG32r](https://packt.link/GG32r)。
- en: 'Take the following steps to complete this exercise:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤完成此练习：
- en: Create a new Android Studio Project with no Activity.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的没有Activity的Android Studio项目。
- en: 'Add the following libraries to `app/build.gradle`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下库添加到`app/build.gradle`：
- en: '[PRE90]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the `main` folder in the root package, create a class; start with a `Randomizer`
    class:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main`文件夹中创建一个类；从`Randomizer`类开始：
- en: '[PRE91]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In the `main` folder in the root package, create a class; create a `Synchronizer`
    class, which will use `Randomizer` and `Timer` to wait for the random time interval.
    It will also use `CountingIdlingResource` to mark the start of the task and the
    end of the task:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main`文件夹中创建一个类；创建一个`Synchronizer`类，该类将使用`Randomizer`和`Timer`来等待随机的时长间隔。它还将使用`CountingIdlingResource`来标记任务的开始和结束：
- en: '[PRE92]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, create an `Application` class, which will be responsible for creating
    all the instances of the preceding classes:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`Application`类，它将负责创建前面所有类的实例：
- en: '[PRE93]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Add the `MyApplication` class to `AndroidManifest` in the `application` tag
    with the `android:name` attribute.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MyApplication`类添加到`AndroidManifest`中的`application`标签，并使用`android:name`属性。
- en: 'Create an `activity_1` layout file, which will contain a parent layout and
    a button:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`activity_1`布局文件，它将包含一个父布局和一个按钮：
- en: '[PRE94]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create an `activity_2` layout file, which will contain a parent layout and
    `TextView`:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`activity_2`布局文件，它将包含一个父布局和一个`TextView`：
- en: '[PRE95]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create the `Activity1` class, which will implement the logic for the button
    click:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Activity1`类，它将实现按钮点击的逻辑：
- en: '[PRE96]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Create the `Activity2` class, which will display the received data through
    the intent:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Activity2`类，它将通过intent显示接收到的数据：
- en: '[PRE97]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Make sure that the relevant strings are added to `strings.xml`:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将相关字符串添加到`strings.xml`中：
- en: '[PRE98]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Make sure that the two activities are added to `AndroidManifest.xml`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将两个活动添加到`AndroidManifest.xml`中：
- en: '[PRE99]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The complete code for this step can be found at [https://packt.link/TkEX9](https://packt.link/TkEX9).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤的完整代码可以在[https://packt.link/TkEX9](https://packt.link/TkEX9)找到。
- en: 'Create a `FlowTest` class in the `androidTest` directory, which will register
    `IdlingResource` from the `MyApplication` object and will assert the outcome of
    the click:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`androidTest`目录中创建一个`FlowTest`类，它将注册来自`MyApplication`对象的`IdlingResource`并断言点击的结果：
- en: '[PRE100]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The complete code for this step can be found at [https://packt.link/711Vw](https://packt.link/711Vw).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤的完整代码可以在[https://packt.link/711Vw](https://packt.link/711Vw)找到。
- en: Run the test multiple times and check the test results. Notice that the test
    will have a 20% chance of success, but it will wait until the button from `Activity1`
    is clicked. This means that the idling resource is working. Another thing to observe
    is that there is an element of randomness here.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次运行测试并检查测试结果。注意，测试有20%的成功率，但它会等待`Activity1`中的按钮被点击。这意味着idling资源正在工作。另一个需要注意的事情是这里存在随机性元素。
- en: 'Tests don’t like randomness, so we need to eliminate it by making the `Randomizer`
    class open and creating a subclass in the `androidTest` directory. We can do the
    same for the `MyApplication` class and provide a different randomizer called `TestRandomizer`:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试不喜欢随机性，因此我们需要通过使`Randomizer`类对外开放并在`androidTest`目录中创建一个子类来消除它。我们也可以对`MyApplication`类做同样的事情，并提供一个名为`TestRandomizer`的不同随机器：
- en: '[PRE101]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, modify the `MyApplication` class in a way in which we can override the
    randomizer from a subclass:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以可以覆盖子类中的随机器的方式修改`MyApplication`类：
- en: '[PRE102]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the `androidTest` directory, create `TestMyApplication`, which will extend
    `MyApplication` and override the `createRandomizer` method:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`androidTest`目录下创建`TestMyApplication`，它将扩展`MyApplication`并重写`createRandomizer`方法：
- en: '[PRE103]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Finally, in the `androidTest/java` folder in the root package, create an instrumentation
    test runner that will use this new `Application` class inside the test:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在根包的`androidTest/java`文件夹中创建一个instrumentation测试运行器，它将在测试中使用这个新的`Application`类：
- en: '[PRE104]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Add the new test runner to the Gradle configuration:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的测试运行器添加到Gradle配置中：
- en: '[PRE105]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If we run the test now, the test should pass; however, we have a couple of problems
    with our dependencies. For the `Randomizer` class, we had to make our class open
    so that it could be extended in the `androidTest` folder.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，测试应该通过；然而，我们在依赖项上遇到了一些问题。对于`Randomizer`类，我们不得不使我们的类对外开放，以便在`androidTest`文件夹中扩展它。
- en: Another issue is the fact that our application code contains references to idling
    resources that are part of the testing libraries. To solve both problems, we will
    need to define abstractions for the `Randomizer` and `Synchronizer` classes.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们应用程序代码中包含了对测试库中idling资源的引用。为了解决这两个问题，我们需要为`Randomizer`和`Synchronizer`类定义抽象。
- en: 'In the `main/java` folder in the root package, create an interface called `Randomizer`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main/java`文件夹中创建一个名为`Randomizer`的接口：
- en: '[PRE106]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Rename the previous `Randomizer` class `RandomizerImpl` and implement the `Randomizer`
    interface as follows:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前的`Randomizer`类重命名为`RandomizerImpl`并按照以下方式实现`Randomizer`接口：
- en: '[PRE107]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In `MyApplication`, modify the `createRandomizer` method to have the `Randomizer`
    return type, which will return an instance of `RandomizerImpl`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyApplication`中修改`createRandomizer`方法，使其返回类型为`Randomizer`，这将返回一个`RandomizerImpl`实例：
- en: '[PRE108]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Modify `TestRandomizer` to implement the `Randomizer` interface:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`TestRandomizer`以实现`Randomizer`接口：
- en: '[PRE109]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Modify `TestMyApplication` to correct the compile errors:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`TestMyApplication`以纠正编译错误：
- en: '[PRE110]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In `app/build.gradle`, make the idling resource dependency `androidTestImplementation`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`中，将idling资源依赖项设置为`androidTestImplementation`：
- en: '[PRE111]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In the `main/java` folder in the root package, create an interface called `Synchronizer`:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main/java`文件夹中创建一个名为`Synchronizer`的接口：
- en: '[PRE112]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Rename the previous `Synchronizer` class `SynchronizerImpl`, implement the
    `Synchronizer` interface, and remove the usages of `CountingIdlingResource`:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前的 `Synchronizer` 类重命名为 `SynchronizerImpl`，实现 `Synchronizer` 接口，并删除对 `CountingIdlingResource`
    的使用：
- en: '[PRE113]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Modify `MyApplication` so that it will open the ability to provide different
    `Synchronizer` instances from the `TestMyApplication` class:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MyApplication` 以使其能够从 `TestMyApplication` 类中提供不同的 `Synchronizer` 实例：
- en: '[PRE114]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In the `androidTest` folder, create a class called `TestSynchronizer`, which
    will wrap a `Synchronizer`, and then use `CountingIdlingResource` to increment
    and decrement a counter when `executeAfterDelay` is started and finished:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `androidTest` 文件夹中，创建一个名为 `TestSynchronizer` 的类，它将包装一个 `Synchronizer`，然后使用
    `CountingIdlingResource` 在 `executeAfterDelay` 开始和结束时增加和减少计数器：
- en: '[PRE115]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the preceding example, we have a reference to a `Synchronizer` instance.
    When `executeAfterDelay` is called, then we inform Espresso to wait. We then invoke
    the actual `Synchronizer` instance, and when it finishes the execution, we then
    inform Espresso to resume.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个对 `Synchronizer` 实例的引用。当调用 `executeAfterDelay` 时，我们通知 Espresso
    等待。然后我们调用实际的 `Synchronizer` 实例，当它完成执行后，我们通知 Espresso 继续执行。
- en: 'Modify `TestMyApplication` to provide an instance of `TestSynchronizer`:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `TestMyApplication` 以提供 `TestSynchronizer` 的实例：
- en: '[PRE116]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In the preceding snippet, we create a new `TestSynchronizer` that wraps the
    `Synchronizer` defined in `MyApplication` and adds the `CountingIdlingResource`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个新的 `TestSynchronizer`，它包装了在 `MyApplication` 中定义的 `Synchronizer`
    并添加了 `CountingIdlingResource`。
- en: 'In `FlowTest`, change the reference to `MyApplication` with `TestMyApplication`:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `FlowTest` 中，将 `MyApplication` 的引用更改为 `TestMyApplication`:'
- en: '[PRE117]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'When running the test now, everything should pass, as shown in *Figure 10**.10*:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在运行测试时，一切应该通过，如图 *图 10.10* 所示：
- en: '![Figure 10.10 – Output of Exercise 10.03](img/B19411_10_010.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 练习 10.03 的输出](img/B19411_10_010.jpg)'
- en: Figure 10.10 – Output of Exercise 10.03
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 练习 10.03 的输出
- en: This type of exercise shows how to avoid randomness in a test and provides concrete
    and repeatable input to make our tests reliable. Similar approaches are taken
    with dependency injection frameworks, where entire modules can be replaced in
    the test suite to ensure the test’s reliability.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的练习展示了如何避免测试中的随机性，并提供具体且可重复的输入以使我们的测试可靠。在依赖注入框架中，也采取了类似的方法，可以在测试套件中替换整个模块以确保测试的可靠性。
- en: One of the most common things to be replaced is API communication. Another issue
    this approach solves is the decrease in waiting time. If this type of scenario
    were to have been repeated across your tests, then the execution time of them
    would have increased because of this.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见需要替换的是 API 通信。这种方法解决的另一个问题是减少等待时间。如果这种类型的场景在测试中重复出现，那么它们的执行时间会因为这一点而增加。
- en: In this exercise, we have looked at how we can write instrumented tests and
    execute them on an emulator or physical device. We have also analyzed how we can
    decorate our objects with `CountingIdlingResources` to be able to monitor asynchronous
    operations, and how we can switch dependencies that cause flakiness and provide
    stub data instead.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探讨了如何编写仪器化测试并在模拟器或物理设备上执行它们。我们还分析了如何使用 `CountingIdlingResources` 装饰我们的对象以监控异步操作，以及如何切换导致不稳定的依赖并提供存根数据。
- en: TDD
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD
- en: Let’s assume that you are tasked with building an activity that displays a calculator
    with the add, subtract, multiply, and divide options. You must also write tests
    for your implementation. Typically, you would build your UI and your activity
    and a separate `Calculator` class. Then, you would write the unit tests for your
    `Calculator` class and then for your `activity` class.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被分配了一个任务来构建一个显示带有加、减、乘、除选项的计算器的活动。你还必须为你的实现编写测试。通常，你会构建你的 UI 和活动以及一个单独的 `Calculator`
    类。然后，你会为你的 `Calculator` 类编写单元测试，然后为你的 `activity` 类编写测试。
- en: If you were to translate the TDD process to implementing features on an Android
    app, you would have to write your UI test with your scenarios first. To achieve
    this, you can create a skeleton UI to avoid compile-time errors. After your UI
    test, you would need to write your `Calculator` test. Here, you would also need
    to create the necessary methods in the `Calculator` class to avoid compile-time
    errors.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 TDD 流程转换为在 Android 应用中实现功能，你将需要首先编写你的 UI 测试用例。为了实现这一点，你可以创建一个骨架 UI 以避免编译时错误。在完成
    UI 测试后，你需要编写你的 `Calculator` 测试。在这里，你还需要在 `Calculator` 类中创建必要的函数以避免编译时错误。
- en: 'If you ran your tests in this phase, they would fail. This would force you
    to implement your code until the tests pass. Once your `Calculator` tests pass,
    you can connect your calculator to your UI until your UI tests pass. While this
    seems like a counter-intuitive approach, it solves two issues once the process
    is mastered:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个阶段运行了测试，它们将失败。这将迫使你实现代码直到测试通过。一旦你的`Calculator`测试通过，你就可以将计算器连接到你的UI，直到你的UI测试通过。虽然这看起来像是一种反直觉的方法，但一旦掌握了这个过程，它就能解决两个问题：
- en: Less time will be spent writing code because you will ensure that your code
    is testable, and you need to write only the amount of code necessary for the test
    to pass
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你需要确保你的代码是可测试的，并且只需编写通过测试所需的最少代码，因此编写代码所需的时间会更少
- en: Fewer bugs will be introduced because developers will be able to analyze different
    outcomes
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于开发者将能够分析不同的结果，因此引入的bug会更少
- en: 'Have a look at the following diagram, which shows the TDD cycle:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下图，它显示了TDD周期：
- en: '![Figure 10.11 – TDD cycle](img/B19411_10_011.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – TDD周期](img/B19411_10_011.jpg)'
- en: Figure 10.11 – TDD cycle
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – TDD周期
- en: In the preceding figure, we can see the development cycle in a TDD process.
    You should start from a point where your tests are failing. Implement changes
    for the tests to pass. When you update or add new features, you can repeat the
    process.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到TDD过程中的开发周期。你应该从一个测试失败的点开始。实现更改以通过测试。当你更新或添加新功能时，你可以重复此过程。
- en: 'Going back to our factorial examples, we started with a `factorial` function
    that didn’t cover all our scenarios and had to keep updating the function every
    time a new test was added. TDD is built with that idea in mind. You start with
    an empty function. You start defining your testing scenarios: what are the conditions
    for success? What’s the minimum? What’s the maximum? Are there any exceptions
    to the main rule? What are they? These questions can help developers define their
    test cases. Then, these cases can be written. Let’s now see how this can be done
    practically through the next exercise.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的阶乘示例，我们从一个没有涵盖所有场景的`factorial`函数开始，每次添加新测试时都必须更新该函数。TDD正是基于这个想法构建的。你从一个空函数开始。你开始定义你的测试场景：成功的条件是什么？最小值是多少？最大值是多少？是否有任何违反主要规则的例外情况？它们是什么？这些问题可以帮助开发者定义他们的测试用例。然后，这些案例可以编写。现在让我们通过下一个练习看看如何实际操作。
- en: Exercise 10.04 – using TDD to calculate the sum of numbers
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.04 – 使用TDD计算数字之和
- en: 'Write a function that has as input the integer `n` and will return the sum
    of numbers from `1` to `n`. The function should be written with a TDD approach,
    and the following criteria should be satisfied:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数以整数`n`作为输入，并返回从`1`到`n`的数字之和。该函数应使用TDD方法编写，并满足以下标准：
- en: For `n<=0`, the function will return the value `-1`
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`n<=0`，函数将返回值`-1`
- en: The function should be able to return the correct value for `Int.MAX_VALUE`
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该能够返回`Int.MAX_VALUE`的正确值
- en: The function should be quick, even for `Int.MAX_VALUE`
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该快速，即使是对于`Int.MAX_VALUE`
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: Create a new Android Studio Project with No Activity.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的没有活动的Android Studio项目
- en: 'Make sure that the following library is added to `app/build.gradle`:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将以下库添加到`app/build.gradle`中：
- en: '[PRE118]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In the `main/java` folder in the root package, create an `Adder` class with
    the `sum` method, which will return `0`, to satisfy the compiler:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main/java`文件夹中，创建一个`Adder`类，并带有返回`0`的`sum`方法，以满足编译器：
- en: '[PRE119]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Create an `AdderTest` class in the `test` directory and define our test cases.
    We will have the following test cases: `n=1`, `n=2`, `n=0`, `n=-1`, `n=10`, `n=20`,
    and `n=Int.MAX_VALUE`. We can split the successful scenarios into one method and
    the unsuccessful ones into a separate method:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test`目录下创建一个`AdderTest`类并定义我们的测试用例。我们将有以下测试用例：`n=1`，`n=2`，`n=0`，`n=-1`，`n=10`，`n=20`，以及`n=Int.MAX_VALUE`。我们可以将成功的场景拆分到一个方法中，而将不成功的场景拆分到另一个方法中：
- en: '[PRE120]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'If we run the tests for the `AdderTest` class, we will see an output like the
    following figure, meaning that all our tests failed:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`AdderTest`类的测试，我们将看到以下图所示的输出，这意味着所有测试都失败了：
- en: '![Figure 10.12 – Initial test status for Exercise 10.04](img/B19411_10_012.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 练习10.04的初始测试状态](img/B19411_10_012.jpg)'
- en: Figure 10.12 – Initial test status for Exercise 10.04
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 练习10.04的初始测试状态
- en: 'Let’s first address the success scenarios by implementing the sum in a loop
    from `1` to `n`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先通过在`1`到`n`的循环中实现求和来处理成功场景：
- en: '[PRE121]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If we run the tests now, you will see that one will pass and the other will
    fail, like the following figure:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，你会看到其中一个会通过，另一个会失败，就像以下图所示：
- en: '![Figure 10.13 – Test status after resolving the success scenario for Exercise
    10.04](img/B19411_10_013.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 解决 10.04 练习的成功场景后的测试状态](img/B19411_10_013.jpg)'
- en: Figure 10.13 – Test status after resolving the success scenario for Exercise
    10.04
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 解决 10.04 练习的成功场景后的测试状态
- en: 'If we look at the time it took to execute the successful test, it seems a bit
    long. This can add up when thousands of unit tests are present in one project.
    We can now optimize our code to deal with the issue by applying the *n(n+1)/2*
    formula:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们看看执行成功测试所需的时间，似乎有点长。当在一个项目中存在成千上万的单元测试时，这可能会累积起来。现在，我们可以通过应用 *n(n+1)/2*
    公式来优化我们的代码以处理这个问题：
- en: '[PRE122]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Running the tests now will drastically reduce the execution time to a few milliseconds.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试将大大减少执行时间到几毫秒。
- en: 'Now, let’s focus on solving our failure scenarios. We can do this by adding
    a condition for when `n` is smaller than or equal to `0`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们专注于解决我们的失败场景。我们可以通过添加一个当 `n` 小于或等于 `0` 的条件来完成这个任务：
- en: '[PRE123]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If we run the tests now, we should see them all passing, like the following
    figure:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，我们应该看到它们都通过，就像以下图所示：
- en: '![Figure 10.14 – Passing tests for Exercise 10.04](img/B19411_10_014.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 10.04 练习的通过测试](img/B19411_10_014.jpg)'
- en: Figure 10.14 – Passing tests for Exercise 10.04
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 10.04 练习的通过测试
- en: In this exercise, we have applied the concept of TDD to a very small example
    to demonstrate how the technique can be used. We have observed how, starting from
    the skeleton code, we can create a suite of tests to verify our conditions, and
    how by constantly running tests, we improved the code until a point where all
    the tests pass. As you have probably noticed, the concept isn’t an intuitive one.
    Some developers find it hard to define how big skeleton code should be to start
    creating the test cases, while others, out of habit, focus on writing the code
    first and then developing the test. In either case, developers will need a lot
    of practice with the technique until it’s properly mastered.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将 TDD 的概念应用于一个非常小的示例，以展示该技术如何被使用。我们观察到，从骨架代码开始，我们可以创建一系列测试来验证我们的条件，并且通过不断运行测试，我们改进了代码，直到所有测试都通过。正如你可能已经注意到的，这个概念并不是直观的。一些开发者发现很难定义骨架代码应该有多大才能开始创建测试用例，而另一些开发者，出于习惯，首先编写代码然后再开发测试。在任何情况下，开发者都需要大量练习这项技术，直到熟练掌握。
- en: Activity 10.01 – developing with TDD
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.01 活动活动 – 使用 TDD 进行开发
- en: 'Using the TDD approach, develop an application that contains three activities
    and works as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TDD 方法，开发一个包含三个活动并按以下方式工作的应用程序：
- en: In activity 1, you will display a numeric `EditText` element and a button. When
    the button is clicked, the number in `EditText` will be passed to activity 2.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动 1 中，你将显示一个数字 `EditText` 元素和一个按钮。当按钮被点击时，`EditText` 中的数字将被传递到活动 2。
- en: Activity 2 will generate a list of items asynchronously. The number of items
    will be represented by the number passed from activity 1\. You can use the `Timer`
    class with a delay of 1 second. Each item in the list will display the text `Item
    x` where `x` is the position in the list. When an item is clicked, you should
    pass the clicked item to activity 3.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动二将异步生成一个项目列表。项目的数量将由活动 1 传递的数字表示。你可以使用具有 1 秒延迟的 `Timer` 类。列表中的每个项目将显示文本 `Item
    x`，其中 `x` 是列表中的位置。当点击一个项目时，你应该将点击的项目传递到活动 3。
- en: Activity 3 will display the text `You clicked y`, where `y` is the text of the
    item the user has clicked.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动三将显示文本 `您点击了 y`，其中 `y` 是用户点击的项目文本。
- en: 'The tests for the app will be the following:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的测试如下：
- en: Unit tests with Mockito and `mockito-kotlin` annotated with `@SmallTest`
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mockito 和 `mockito-kotlin` 注解的 `@SmallTest` 的单元测试
- en: Integration tests with Robolectric and Espresso annotated with `@MediumTest`
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Robolectric 和 Espresso 注解的 `@MediumTest` 的集成测试
- en: UI tests with Espresso annotated with `@LargeTest` and using the `Robot` pattern
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Robot` 模式并注解为 `@LargeTest` 的 Espresso 的 UI 测试
- en: 'Run the test commands from the command line. To complete this activity, you
    need to take the following steps:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行测试命令。为了完成这个活动，你需要采取以下步骤：
- en: You will need Android Studio 4.1.1 or higher with Kotlin 1.4.21 or higher for
    the Parcelize Kotlin plugin.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要 Android Studio 4.1.1 或更高版本，以及 Kotlin 1.4.21 或更高版本，用于 Parcelize Kotlin 插件。
- en: Create the three activities and the UI for each of them.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个活动以及每个活动的 UI。
- en: 'In the `androidTest` folder, create three robots, one for each activity:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`androidTest`文件夹中，为每个活动创建三个机器人：
- en: Robot 1 will contain the interaction with `EditText` and the button
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人1将包含与`EditText`和按钮的交互
- en: Robot 2 will assert the number of items on the screen and interact with an item
    in the list
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人2将断言屏幕上的项目数量并与列表中的项目进行交互
- en: Robot 3 will assert the text displayed in `TextView`
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人3将断言在`TextView`中显示的文本
- en: Create an instrumented test class that will have one test method using the preceding
    robots.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有一个使用前面机器人的测试方法的仪器化测试类。
- en: Create an `Application` class that will hold instances of all the classes that
    will be unit-tested.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Application`类，该类将包含所有将进行单元测试的类的实例。
- en: Create three classes representing integration tests, one for each of the activities.
    Each of these classes will contain one test method for interactions and data loading.
    Each integration test will assert the intents passed between the activities.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个类来表示集成测试，每个活动一个类。这些类中的每一个将包含一个用于交互和数据加载的测试方法。每个集成测试都将断言活动之间传递的意图。
- en: Create a class that will provide the text required for the UI. It will have
    a reference to a `Context` object and will contain two methods that will provide
    the text for the UI, which will return an empty string.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类，该类将提供所需的UI文本。它将引用一个`Context`对象，并包含两个方法，这些方法将提供UI的文本，并返回一个空字符串。
- en: Create the test for the preceding class in which the two methods are tested.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为前面的类创建测试，以测试这两个方法。
- en: Implement the class for the preceding tests to pass.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现前面的类，以便测试通过。
- en: Create a class that will be responsible for loading the list in `Activity2`,
    and provide an empty method for loading. The class will have a reference to the
    timer and the idling resource. Here, you should also create a data class that
    will represent the model for `RecyclerView`.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类，该类将负责在`Activity2`中加载列表，并提供一个用于加载的空方法。该类将引用计时器和空闲资源。在这里，你还应该创建一个数据类，该类将代表`RecyclerView`的模型。
- en: Create a unit test for the preceding class.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为前面的类创建一个单元测试。
- en: Create the implementation for the preceding class and run the unit tests until
    they pass.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为前面的类创建实现并运行单元测试，直到它们通过。
- en: In the `Application` class, instantiate the classes that were unit-tested and
    start using them in your activities. Do this until your integration tests pass.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Application`类中，实例化已进行单元测试的类，并在您的活动中开始使用它们。这样做，直到您的集成测试通过。
- en: Provide `IntegrationTestApplication`, which will return a new implementation
    of the class responsible for loading. This is to avoid making your integration
    test for `Activity2` wait until loading is complete.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供`IntegrationTestApplication`，这将返回负责加载的新实现类。这是为了避免使您的`Activity2`集成测试等待加载完成。
- en: Provide `UiTestApplication`, which will again reduce the loading time of your
    models and connect the idling resource to Espresso. Implement the remaining work
    for the UI test to pass.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供`UiTestApplication`，这将再次减少您模型的加载时间，并将空闲资源连接到Espresso。实现剩余的UI测试，以便通过。
- en: Note
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/Ma4tD](https://packt.link/Ma4tD).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在[https://packt.link/Ma4tD](https://packt.link/Ma4tD)找到。
- en: Summary
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the different types of testing and the frameworks
    available for implementing these tests. We also looked at the testing environment
    and how to structure it for each environment, as well as structuring your code
    into multiple components that can be individually unit-tested.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了不同的测试类型和实现这些测试的框架。我们还探讨了测试环境，以及如何为每个环境构建它，以及如何将代码结构化成多个组件，这些组件可以单独进行单元测试。
- en: We analyzed different ways to test code, how we should approach testing, and
    how, by looking at different test results, we can improve our code. With TDD,
    we learned that by starting with testing, we can write our code faster and ensure
    it is less error-prone.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了不同的测试代码的方法，我们应该如何进行测试，以及通过查看不同的测试结果，我们可以如何改进我们的代码。通过TDD，我们了解到，通过从测试开始，我们可以更快地编写代码，并确保它更少出错。
- en: The activity is where all these concepts came together into building a simple
    Android application, and we can observe how, by adding tests, the development
    time increases, but this pays off in the long term by eliminating possible bugs
    that appear when the code is modified.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 活动是所有这些概念汇集在一起构建简单Android应用程序的地方，我们可以观察到，通过添加测试，开发时间会增加，但长期来看，这通过消除代码修改时可能出现的潜在错误而得到回报。
- en: The frameworks we have studied are some of the most common ones, but there are
    others that build on top of these and are used by developers in their projects,
    such as Mockk (a mocking library designed for Kotlin that takes advantage of a
    lot of the features of the language) and Barista (written on top of Espresso and
    simplifies the syntax of UI tests), to note a few.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究过的框架是最常见的其中一些，但还有其他一些建立在它们之上，并被开发者在他们的项目中使用，例如Mockk（一个为Kotlin设计的模拟库，利用了语言的大量功能）和Barista（基于Espresso编写，简化了UI测试的语法），仅举几个例子。
- en: 'Think of all the concepts presented here as building blocks that fit into two
    processes present in the software engineering world: automation and continuous
    integration. Automation takes redundant and repetitive work out of the hands of
    developers and puts it into the hands of machines.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 将这里提出的所有概念视为构建块，它们适合软件工程世界中存在的两个过程：自动化和持续集成。自动化将冗余和重复的工作从开发者的手中移走，并将其交给机器。
- en: Instead of having a team of quality assurance people testing your application
    to make sure the requirements are met, you can instruct a machine through a variety
    of tests and test cases to test the application instead and just have one person
    reviewing the results of the tests.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让一个质量保证团队测试你的应用程序以确保满足要求，你可以通过各种测试和测试案例指导机器来测试应用程序，并且只需要一个人来审查测试结果。
- en: 'Continuous integration builds on the concept of automation to verify your code
    the moment you submit it for review from other developers. A project with continuous
    integration would have a setup along the following lines: a developer submits
    work for review in a source control repository such as GitHub.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成建立在自动化的概念之上，以便在你将代码提交给其他开发者进行审查时立即验证你的代码。具有持续集成功能的项目将按照以下方式进行设置：开发者将工作提交到源代码控制仓库，例如GitHub。
- en: A machine in the cloud would then start executing the tests for the entire project,
    making sure that nothing was broken, and the developer can move on to a new task.
    If the tests pass, then the rest of the developers can review the code, and when
    it is correct, it can be merged, and a new build can be created in the cloud and
    distributed to the rest of the team and the testers.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，云中的机器将开始执行整个项目的测试，确保没有出现任何问题，开发者可以继续新的任务。如果测试通过，那么其他开发者可以审查代码，当代码正确时，它可以被合并，并在云中创建一个新的构建版本，然后分发到整个团队和测试人员。
- en: All of this takes place while the initial developer can safely work on something
    else. If anything fails in the process, then they can pause the new task and go
    and address any issues in their work. The continuous integration process can then
    be expanded into continuous delivery, where similar automation can be set up when
    preparing a submission to Google Play that can be handled almost entirely by machines
    with minor involvement from developers.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在初始开发者安全地从事其他工作的同时进行。如果在过程中有任何失败，他们可以暂停新任务，并去解决他们工作中出现的问题。然后可以将持续集成过程扩展到持续交付，当准备提交到Google
    Play时，可以设置类似的自动化，几乎可以由机器完全处理，开发者的参与度很小。
- en: In the chapters that follow, you will learn about how to organize your code
    when building more complex applications that use the storage capabilities of the
    device and connect to the cloud to request data. Each of those components can
    be individually unit-tested, and you can apply integration tests to assert a successful
    integration of multiple components.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将了解如何在构建更复杂的应用程序时组织代码，这些应用程序利用设备的存储功能并连接到云以请求数据。这些组件中的每一个都可以单独进行单元测试，并且你可以应用集成测试来断言多个组件的成功集成。
