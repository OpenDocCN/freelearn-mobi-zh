<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;The Best of Both Worlds &#x2013; Combining FP Paradigms with OOP"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. The Best of Both Worlds – Combining FP Paradigms with OOP</h1></div></div></div><div class="blockquote"><table border="0" cellpadding="0" cellspacing="0" class="blockquote" summary="Block quote" width="100%"><tr><td valign="top"> </td><td valign="top"><p>
<span class="emphasis"><em>"Objects are closures with multiple methods, closures are objects with a single method. So yes [OOP and FP can be used together.]"</em></span>
</p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td align="right" colspan="2" style="text-align: center" valign="top">--<span class="attribution"><span class="emphasis"><em>Erik Meijer</em></span></span></td></tr></table></div><p>In previous chapters, we talked about <span class="strong"><strong>functional programming</strong></span> (<span class="strong"><strong>FP</strong></span>) most of the time. You learned various techniques and paradigms of FP. In contrast, we barely touched on <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>). Mostly, we talked about the disadvantages of imperative programming. In practice, most of us have to work on applications that are designed by OOP principles. The reality is that even if we do not like OOP, we are stuck with it. For instance, in iOS and macOS development, we have to deal with Cocoa and <span class="strong"><strong>Cocoa Touch</strong></span> frameworks that are designed by OOP principles.</p><p>On the other hand, we are familiar with OOP because most of us learned it at some point and some of us find it natural to model real-world problems with it.</p><p>There is a huge discussion about benefits of one paradigm over the other. Some claim that they can be unified; some claim that they are exclusive and we should choose one paradigm over the other. Also, different programming languages and their communities follow different approaches. For instance, Haskell is a purely functional programming language and it is almost impossible to do OOP with it. In fact, it is absurd to do OOP with it. On the other hand, languages such as Java, Ruby, Python, and C# are OOP languages with limited FP capabilities. There are also languages such as Scala that mix OOP with FP and embrace both worlds.</p><p>How would we picture Swift in these settings? We know that Swift is not a pure FP language and has FP capabilities but we need to further evaluate it in this regard.</p><p>In addition to these, the Swift programming community has been introduced to another paradigm: <span class="strong"><strong>protocol-oriented programming</strong></span> (<span class="strong"><strong>POP</strong></span>). Furthermore, <span class="strong"><strong>Functional Reactive Programming</strong></span> (<span class="strong"><strong>FRP</strong></span>) became very popular and is loved by lots of developers.</p><p>What are the advantages and disadvantages of a paradigm over the others? How would we design our applications to benefit from all these paradigms? These are the questions that we will try to answer in this chapter. Hence, we will start by introducing OOP, POP, and FRP, and then we will mix OOP paradigms with FP.</p><p>This chapter will cover the following topics with coding examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A brief introduction to OOP paradigms</li><li class="listitem" style="list-style-type: disc">OOP design patterns/principles</li><li class="listitem" style="list-style-type: disc">A brief introduction to POP</li><li class="listitem" style="list-style-type: disc">Functional Reactive Programming</li><li class="listitem" style="list-style-type: disc">Mixing OOP and FP</li></ul></div><div class="section" title="OOP paradigms"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec83"/>OOP paradigms</h1></div></div></div><p>In this section, we will examine general paradigms in OOP. We start with objects because they are the most fundamental artifacts in OOP. Next, we will look into classes that are blueprints to create objects. Then we will continue with paradigms such as inheritance, polymorphism, and dynamic binding.</p><div class="section" title="Objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec76"/>Objects</h2></div></div></div><p>In an OOP application, objects are the runtime entities or instances that take space in memory, more specifically, in the heap. Objects have an associated/allocated memory address to store their state and a set of functions or methods that define the suitable operations on the object state. In short, in OOP, an object encapsulates state and behavior.</p><p>To create an object, a blueprint or recipe is required, which is called class in OOP. The following section will explore the class concept in more detail. For now, we will define a very simple class in order to be able to talk about objects:</p><pre class="programlisting">class User { &#13;
  let name = "Constant name" &#13;
  var age: Int = 0 &#13;
     &#13;
  func incrementUserAgeByOne() { &#13;
    self.age += 1 &#13;
  } &#13;
}&#13;
</pre><p>In this example, <code class="literal">name</code> and <code class="literal">age</code> are constants and variables that can be used to store the state of the object. The <code class="literal">incrementUserAgeByOne</code> method is a behavior definition that changes the state of the object. We have to create an instance/object of this class to be able to use it:</p><pre class="programlisting">let object1 = User() &#13;
object1.age = 2 &#13;
object1.incrementUserAgeByOne()&#13;
</pre><p>In the first line of our preceding example, we created an object with our <code class="literal">User</code> recipe. At the same time, we allocated a memory address to our object and initialized it. The object, which is an instance of <code class="literal">User</code>, can be used; we can change its state and use its methods to do operations or change its state.</p><p>From a design perspective, objects model the entities in the application domain. In our example, object represents <code class="literal">User</code>.</p><p>It is important to understand the following about classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Classes are reference types</li><li class="listitem" style="list-style-type: disc">Classes encapsulate states that are mutable</li></ul></div><p>Suppose that we create a new instance of class as follows:</p><pre class="programlisting">let object2 = object1&#13;
</pre><p>This assignment is not going to copy <code class="literal">object1</code> and will make <code class="literal">object2</code> refer to the same instance. Let's examine the following:</p><pre class="programlisting">print(object2.age) &#13;
object2.incrementUserAgeByOne() &#13;
print(object1.age)&#13;
</pre><p>Here, when we print <code class="literal">object2.age</code>, it will produce the same result with <code class="literal">object1.age</code> and when we call <code class="literal">incrementUserAgeByOne</code>, it will change the instance's age; therefore, it will be changed for the <code class="literal">object1</code> as well as <code class="literal">object2</code>.</p><p>This behavior can be helpful in some circumstances, for instance, if we need to share an instance between different objects. Examples can be database or file management system operations and <code class="literal">AppDelegate</code> in iOS and macOS applications.</p><p>On the other hand, it can complicate the reasoning about the code. For instance, if we had lots of references to the same instance and changing one of them would change all the instances, we would need to react to those changes for all the instances.</p><p>If we do not need to share instances, then we can create a new object and use it:</p><pre class="programlisting">let object3 = User() &#13;
object3.age = 5 &#13;
 &#13;
object3.incrementUserAgeByOne() &#13;
print(object3.age) &#13;
print(object1.age)&#13;
</pre><p>In the preceding example, as we allocate and initialize a new memory space for our <code class="literal">object3</code>, it does not refer to the same instance with <code class="literal">object1</code> and <code class="literal">object2</code>. Any changes on <code class="literal">object3</code> are not going to affect <code class="literal">object1</code> and <code class="literal">object2</code>.</p></div><div class="section" title="Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec77"/>Classes</h2></div></div></div><p>A class defines a set of properties and suitable operations. From a type-safe programming language point of view, a class is a structure to implement a user-defined type such as our <code class="literal">User</code> class in the preceding example.</p><p>Preferably, a class should be an implementation of an <span class="strong"><strong>Abstract Data Type</strong></span> (<span class="strong"><strong>ADT</strong></span>) that hides the implementation details.</p><p>An implementation of an ADT as a class can be composed of two kinds of methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Methods that return meaningful abstractions about the state of an instance</li><li class="listitem" style="list-style-type: disc">Transformational methods to move from a valid instance state to another valid state</li></ul></div><p>To be able to hide implementation details and for the sake of abstraction, all the data within a class should be private to the class.</p><p>Let's improve the abstraction in our <code class="literal">User</code> class example:</p><pre class="programlisting">class User { &#13;
  private let name: String &#13;
  private var age: Int &#13;
     &#13;
  init(name: String, age: Int) { &#13;
    self.name = name &#13;
    self.age = age &#13;
  } &#13;
     &#13;
  func incrementUserAgeByOne() { &#13;
    self.age += 1 &#13;
  } &#13;
}&#13;
</pre><p>We made our properties <code class="literal">private</code> so that no other object can access/change them unless it is inside the same Swift file. Also, we added an <code class="literal">init</code> method to initialize the object from our <code class="literal">User</code> class. Class clients will use the <code class="literal">init</code> method to initialize the object with the initial <code class="literal">name</code> and <code class="literal">age</code> information:</p><pre class="programlisting">let object1 = User(name: "John Doe", age: 34)&#13;
</pre><p>Finally, we left the access level of <code class="literal">incrementUserAgeByOne</code> as internal (by default it is internal); therefore, any other object in the same module will be able to use it.</p><p>The <code class="literal">incrementUserAgeByOne</code> method changes the state of our object and this change will affect all objects that refer to the same instance. We can change it as follows:</p><pre class="programlisting">func incrementUserAge(n: Int) -&gt; Int { &#13;
  return self.age + n &#13;
}&#13;
</pre><p>Our <code class="literal">incrementUserAge</code> method returns the new <code class="literal">age</code> and does not modify the state of the object. We will need to initialize a new object and use this <code class="literal">age</code> instead.</p><p>Finally, as we do not need to modify <code class="literal">age</code>, we can make it immutable. Our <code class="literal">User</code> class has two immutable properties with a method that does not modify its properties. Therefore, despite the fact that it is a very simple class, it is functional.</p></div><div class="section" title="Inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec78"/>Inheritance</h2></div></div></div><p>Inheritance is a relation between classes that makes it possible to define and implement a class based on other existing classes.</p><p>Also, inheritance helps code reusability and allows independent extensions of the original class (the <code class="literal">super</code> class) through public classes and interfaces. The relationship between classes through inheritance causes a hierarchy.</p><p>Inheritance inevitably minimizes the amount of rework when we need to add additional information and functionalities to an existing class as we can use the class as the <code class="literal">super</code> class and subclass it to add new state information and behavior.</p><p>Moreover, when it is coupled with polymorphisms and dynamic binding, inheritance minimizes the amount of existing code that should be changed when extending a class.</p><p>In programming languages such as C++, it is possible to inherit from more than one class, but in Swift, a class can only subclass one other class. The following example presents a <code class="literal">UIViewController</code> subclassing:</p><pre class="programlisting">class BaseViewController: UIViewController { &#13;
     &#13;
}&#13;
</pre><p>Our <code class="literal">BaseViewController</code> will inherit all behaviors and properties of the <code class="literal">UIViewController</code> class and we will be able to add new properties and behaviors to it. This way, we do not need to rewrite everything from scratch and can reuse properties and behaviors in <code class="literal">UIViewController</code>.</p><div class="section" title="Overriding"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec58"/>Overriding</h3></div></div></div><p>Swift permits a class or object to replace the implementation of a behavior/property that it has inherited. This process is called overriding. The <code class="literal">override</code> keyword is used to specify overridden methods in subclasses.</p><p>We can override an inherited instance or class property to provide our own custom/computed getters and setters or add property observers to enable the overriding property to observe when the underlying property value changes.</p><p>We can mark a property or behavior as <code class="literal">final</code> to prevent overriding it in subclasses.</p><p>Overriding brings a complication that needs to be handled. We need to ensure which version of the behavior/property should an instance of the subclass use: the one that is part of its own class (<code class="literal">self</code>) or the one from the parent (<code class="literal">super</code>) class?</p><p>In Swift, <code class="literal">self</code> and <code class="literal">super</code> keywords can be used as prefixes to specify the version of the required behavior/property.</p></div><div class="section" title="Design constraints"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec59"/>Design constraints</h3></div></div></div><p>Using inheritance extensively in designing applications imposes certain constraints.</p><p>For instance, suppose we define a subclass of <code class="literal">User</code> called <code class="literal">WebAppUser</code> that contains the extra acceptable behaviors and another subclass of <code class="literal">User</code> called <code class="literal">MobileAppUser</code> that contains the mobile app modules of <code class="literal">User</code>.</p><p>In defining this inheritance hierarchy, we have already defined certain restrictions, not all of them desirable.</p><div class="section" title="Singleness"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec21"/>Singleness</h4></div></div></div><p>In Swift, a subclass can inherit from only one superclass. From the preceding example, <code class="literal">User</code> can be either <code class="literal">WebAppUser</code> or <code class="literal">MobileAppUser</code>, but not both.</p></div><div class="section" title="Static"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec22"/>Static</h4></div></div></div><p>The inheritance hierarchy of an object is fixed at initiation while the object's type is selected and does not change with time. For example, the inheritance graph does not allow a <code class="literal">MobileAppUser</code> object to become a <code class="literal">WebAppUser</code> object while retaining the state of its <code class="literal">User</code> superclass (this can be achieved with the decorator pattern).</p></div><div class="section" title="Visibility"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec23"/>Visibility</h4></div></div></div><p>Whenever client code has access to an object, it generally has access to all the object's superclass data. Even if the superclass has not been declared public, the client can still cast the object to its superclass type.</p></div><div class="section" title="Composite reuse"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec24"/>Composite reuse</h4></div></div></div><p>The composite reuse principle is an alternative to inheritance. This technique supports polymorphism and code reuse by separating behaviors from the primary class hierarchy and including specific behavior classes as required in any class. This approach avoids the static nature of a class hierarchy by allowing behavior changes at runtime and permitting a subclass to implement behaviors selectively, instead of being restricted to the behaviors of its super classes.</p></div></div><div class="section" title="Issues and alternatives"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec60"/>Issues and alternatives</h3></div></div></div><p>Implementation inheritance is controversial among OOP programmers and theoreticians. For instance, the authors, <span class="emphasis"><em>Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm</em></span>, of the book, <span class="emphasis"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></span>, advocate interface inheritance instead of implementation inheritance and recommend to prefer composition over inheritance.</p><p>For example, the decorator pattern (as stated earlier) has been proposed to overcome the static nature of inheritance between classes.</p><p>Furthermore, the OOP community agrees that inheritance introduces unnecessary coupling and breaks encapsulation so modifications to the super classes can cause undesirable behavioral changes in subclasses.</p><p>In Swift, the usage of protocols and extensions is encouraged. Using protocols avoids the coupling problem because no implementation is shared. We will talk more about protocols and protocol extensions in the <span class="emphasis"><em>POP</em></span> section of this chapter.</p></div><div class="section" title="When to inherit"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec61"/>When to inherit</h3></div></div></div><p>There are circumstances where we do not have any other choice but subclassing. Here are some of the examples where subclassing is required:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When it is required by the APIs: For instance, many of Cocoa APIs require the use of classes and being controversial is not recommended. For instance, <code class="literal">UIViewController</code> has to be subclassed.</li><li class="listitem" style="list-style-type: disc">When we need to manage and communicate our value types between instances of other classes: For example, when we need to draw a custom view in a Cocoa class provided by another drawing class, we will need to communicate it between them. Using a value type in this case is not beneficial.</li><li class="listitem" style="list-style-type: disc">When we need to share an instance between multiple owners: Core Data persistence is an example. It can be very useful to have a synchronization mechanism across multiple owners while using Core Data. This will cause concurrency issues but we have to deal with them as we require mutable data.</li><li class="listitem" style="list-style-type: disc">When the lifetime of an instance is connected to external effects or we require a stable identity: Singletons and AppDelegate are some of the examples.</li></ul></div></div></div><div class="section" title="Polymorphism"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec79"/>Polymorphism</h2></div></div></div><p>Polymorphism means many forms. In general, the ability to take more than one form is called polymorphism. In an object-oriented language such as Swift, a polymorphic reference is one that can, over time, refer to instances of more than one class. Let's examine an example of the iOS SDK, <code class="literal">UIView</code>. There are lots of <code class="literal">UIView</code> subclasses including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UILabel</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UITextField</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIButton</code></li></ul></div><p>We can declare a view that can take many forms such as the following:</p><pre class="programlisting">var view: UIView &#13;
 &#13;
view = UIButton() &#13;
view = UILabel() &#13;
view = UITextField()&#13;
</pre><p>Polymorphism allows us to write a more generic code that works with families of objects rather than writing code for a specific class. In this example, regardless of which class we initiate, we can access all the properties and methods declared in the <code class="literal">UIView</code> class that are inherited by all the subclasses. For instance, we will be able to check the bounds and origins of any of them as follows:</p><pre class="programlisting">view.bounds &#13;
view.frame.origin&#13;
</pre><p>We are able to refer to more than one type of objects; therefore, a polymorphic reference has both a static and dynamic type associated with it.</p><p>The static type is determined from the declaration of the object in the code. It is known at compile time and determines the set of valid types that the object can accept at runtime. This determination is made from an analysis of the inheritance graphs in the system.</p><p>The dynamic type of the reference may change over time during the application execution. In Swift, the runtime system keeps all polymorphic references automatically tagged with their dynamic type.</p></div><div class="section" title="Dynamic binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec80"/>Dynamic binding</h2></div></div></div><p>Associating a method call to the code to be executed is called binding. As opposed to static binding where the code associated with the method call is bound during the compile time, dynamic binding means that the code associated with a given method call is not known and will be determined during runtime.</p><p>Dynamic binding is associated with polymorphism and inheritance because a method call associated with a polymorphic reference may depend on the dynamic type of that reference.</p><p>For instance, our view's static type is <code class="literal">UIView</code> and its dynamic type may be <code class="literal">UILabel</code>, <code class="literal">UITextField</code>, or <code class="literal">UIButton</code>. Let's suppose that some of the methods in <code class="literal">UIView</code> are overridden for <code class="literal">UIButton</code>. When we call those methods, runtime will dynamically bind the method that needs to be called.</p></div></div></div>
<div class="section" title="OOP design principles"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec84"/>OOP design principles</h1></div></div></div><p>In this section, we will look at some of the problems with the OOP approach and OOP solutions and FP solutions to these problems.</p><p>In general, OOP is being criticized in the following manner:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Binding a data structure to behavior is a mechanism of state encapsulation that hides the underlying problem instead of solving it.</li><li class="listitem" style="list-style-type: disc">A great deal of effort goes into making inheritance possible. Ironically, object-orientated patterns themselves favor composition over inheritance. Ultimately, in handling two responsibilities—subtyping and reusing—inheritance is not good with either subtyping or reusing.</li></ul></div><p>OOP solutions to these problems include SOLID and DDD principles. The following are the SOLID principles:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>single responsibility principle</strong></span> (<span class="strong"><strong>SRP</strong></span>)</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>open/closed principle</strong></span> (<span class="strong"><strong>OCP</strong></span>)</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Liskov substitution principle</strong></span> (<span class="strong"><strong>LSP</strong></span>)</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>interface segregation principle</strong></span> (<span class="strong"><strong>ISP</strong></span>)</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>dependency inversion principle</strong></span> (<span class="strong"><strong>DIP</strong></span>)</li></ul></div><p>
<span class="strong"><strong>Domain-driven Design</strong></span> (<span class="strong"><strong>DDD</strong></span>) principles are proposed to solve OOP problems.</p><p>Also, FP addresses these problems by the following distinguishing characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Explicit management of state is avoided through <span class="strong"><strong>immutability</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Explicit return values</strong></span> are favored over implicit side-effects</li><li class="listitem" style="list-style-type: disc">Powerful <span class="strong"><strong>composition</strong></span> facilities promote reuse without compromising encapsulation</li><li class="listitem" style="list-style-type: disc">The culmination of these characteristics is a more <span class="strong"><strong>declarative</strong></span> paradigm</li></ul></div><div class="section" title="SRP"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec81"/>SRP</h2></div></div></div><p>The SRP states that every class should have a single responsibility where a responsibility is defined as a reason to change.</p><p>This principle supports the anti-pattern where large classes play multiple roles. Classes can be large for a few reasons. A core principle of OOP is the binding of the data structure to behavior. The problem is that optimizing for data structure encapsulation not only weakens composition characteristics, but also hides the underlying problem of explicit state. As a result, OOP code typically contains many data structures with relatively few functions per data structure. Adding methods to a class brings pressure on the SRP and reducing the number of methods can either make the data structure difficult to compose or altogether useless. Furthermore, the simple syntactical cost of declaring a class often compels programmers to marginalize.</p><div class="section" title="The FP counterpart"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec62"/>The FP counterpart</h3></div></div></div><p>In FP, the fundamental unit of abstraction is the function. Given that a function has a single output, functions naturally have a single responsibility. One could certainly define an arbitrarily generic function, though this would not be intuitive. Moreover, functions are syntactically less resource-hungry.</p></div></div><div class="section" title="OCP"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec82"/>OCP</h2></div></div></div><p>The OCP states that software entities should be open for extension but closed for modification.</p><p>The ambiguity of this statement can be resolved through two variations of the principle:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Existing classes should be modified only in order to correct bugs. This restriction delivers the closed aspect of the principle. The open aspect is delivered through implementation inheritance or, in other words, inheritance with the goal of reusing rather than subtyping.</li><li class="listitem" style="list-style-type: disc">Openness through polymorphism, which by definition also provides for closure, as extensibility is supported through substitution rather than modification. Unfortunately, substitution often leads to accidental complexity, which must be addressed by yet another principle—the LSP.</li></ul></div><p>The primary utility of the OCP is the confinement of cascading changes while providing extensibility. This is achieved by designing for extensibility and prohibiting changes to existing entities. Extensibility is attained by fancy tricks with abstract classes and virtual functions. Closure is achieved by encapsulation or rather by the hiding of moving parts.</p><div class="section" title="The FP counterpart"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec63"/>The FP counterpart</h3></div></div></div><p>In FP, functions can be substituted at will and as such, there is no need to design for extensibility. Functionality requiring parameterization is naturally declared as such. Instead of inventing a concept of a virtual method and inheritance, one can rely on an existing, elementary concept—the higher-order function.</p></div></div><div class="section" title="LSP"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec83"/>LSP</h2></div></div></div><p>The LSP states that objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.</p><p>The LSP is essentially a restricted instance of subtyping, which aims to guarantee semantic portability across class hierarchies. Portability is achieved by ensuring that whatever is true of a base type is also true of all subtypes. Subclasses must not strengthen preconditions. They must accept all input and initial states that the base class accepts and subclasses must not weaken post-conditions. Behavioral expectations declared by the super class must be met by the subclass. These characteristics cannot be enforced by the type system alone.</p><p>The LSP as a relation of inheritance is thus deceptive, hence the need for a compensating principle. As such, the need for this principle demonstrates a pitfall in subtype (inclusion-based) polymorphism. Implicit factoring by class hierarchy imposes the needless inclusion of restrictions and requires complex principles to place a boundary on accidental complexity.</p><div class="section" title="The FP counterpart"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec64"/>The FP counterpart</h3></div></div></div><p>Functional languages favor parametric polymorphism with bounded quantification, thereby avoiding some of the pitfalls of inheritance. Informally, functional languages emphasize substitutability and de-emphasize implementation reuse as reuse is better achieved through composition. Most ambitions of the LSP are effectively trivial in FP languages.</p></div></div><div class="section" title="ISP"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec84"/>ISP</h2></div></div></div><p>The ISP states that many client-specific interfaces are better than one general-purpose interface. In other words, no client should be forced to depend on methods that it does not use.</p><p>In essence, ISP is a restatement of the SRP for interfaces and reflects the same underlying problem—the difficulty of balancing responsibility assignment, composition, and encapsulation in object-oriented design. On the one hand, it is desirable to encapsulate; on the other hand, it is desirable to compose. Furthermore, the problem with employing the ISP alone is that it doesn't directly protect against large classes and in some ways hides the problem.</p><div class="section" title="The FP counterpart"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec65"/>The FP counterpart</h3></div></div></div><p>Functional programming reduces the need for encapsulation by eschewing state and breeds composition at the core. There is no augmented concept of role-based interfaces because function roles are explicit at the onset. Functions are segregated by default.</p></div></div><div class="section" title="DIP"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec85"/>DIP</h2></div></div></div><p>The DIP states that one should depend upon abstractions. Do not depend upon concretions. In other words, high-level modules should be decoupled from low-level modules through abstractions. This principle states that code should be structured around the problem domain, and the domain should declare dependencies on required infrastructure as protocols. Dependencies thus point inward to the domain model.</p><p>The reason that this principle is an inversion is because typical architectures promoted by OOP (via layer architecture) exhibit dependency graphs where high-level modules consume low-level modules directly. Initially, this dependency graph seems natural as, in expressing domain models in code, one inevitably depends upon the constructs of the language. Procedural programming allows dependencies to be encapsulated by procedures.</p><p>Subtype polymorphism defers procedure implementation. Unfortunately, the use of protocols is often overlooked to express domain dependencies in OOP implementations. Given that infrastructure code is typically more voluminous, the focus of the code drifts away from the domain. DDD was devised in part to balance this drift.</p><div class="section" title="The FP counterpart"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec66"/>The FP counterpart</h3></div></div></div><p>The declarative and side-effect-free nature of FP provides dependency inversion. In OOP, high-level modules depend on infrastructure modules primarily to invoke side-effects. In FP, side-effects are more naturally triggered in response to domain behavior as opposed to being directly invoked by domain behavior. Thus, dependencies become not merely inverted, but pushed to outer layers altogether.</p></div></div><div class="section" title="DDD"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec86"/>DDD</h2></div></div></div><p>DDD is an approach to software development for complex needs by connecting the implementation to an evolving model.</p><div class="section" title="Concepts"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec67"/>Concepts</h3></div></div></div><p>Concepts of the model include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Context</strong></span>: The setting in which a word or statement appears that determines its meaning.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Domain</strong></span>: An ontology, influence, or activity. The subject area to which the user applies a program is the domain of the software.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Model</strong></span>: A system of abstractions that describes selected aspects of a domain and can be used to solve problems related to that domain.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ubiquitous language</strong></span>: A language structured around the domain model and used by all team members to connect all the activities of the team with the software.</li></ul></div></div><div class="section" title="Premise"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec68"/>Premise</h3></div></div></div><p>The premise of DDD is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Placing the project's primary focus on the core domain and domain logic</li><li class="listitem" style="list-style-type: disc">Basing complex designs on a model of the domain</li><li class="listitem" style="list-style-type: disc">Initiating a creative collaboration between technical and domain experts to iteratively refine a conceptual model that addresses particular domain problems</li></ul></div></div><div class="section" title="Building blocks"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec69"/>Building blocks</h3></div></div></div><p>In DDD, there are artifacts to express, create, and retrieve domain models that are explored from an FP perspective in the following sections.</p><div class="section" title="Aggregate"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec25"/>Aggregate</h4></div></div></div><p>A collection of objects that are bound together by a root entity, otherwise known as an aggregate root. The aggregate root guarantees the consistency of changes being made within the aggregate by forbidding external objects from holding references to its members.</p><p>The concept of the aggregate remains in FP; however, it is not represented in terms of a class. Instead, it can be expressed as a structure, including a set of aggregate states, initial state, set of commands, set of events, and function-mapping the set of commands to the set of events given a state. Cohesion is provided by a module mechanism.</p></div><div class="section" title="Immutable value objects"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec26"/>Immutable value objects</h4></div></div></div><p>Immutable value objects are objects that contain attributes but have no conceptual identity. They should be treated as immutable.</p><p>In a previous chapter, we saw that Swift provides immutable product and sum types with auto-implemented structural equality, which addresses this pattern trivially. Heavy reliance on state in OOP makes references first-class citizens rather than the structure of the data itself.</p></div><div class="section" title="Domain events"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec27"/>Domain events</h4></div></div></div><p>A domain event is a domain object that defines an event.</p><p>Domain events are powerful mechanisms to keep domain models encapsulated. This can be accomplished by allowing various observers from outer layers to register for a domain event (<code class="literal">signal</code>).</p><p>The problem with domain events in OOP is that the typical implementation is complex and relies on side-effects. Event observations are typically declared in the composition root and thus, it is not immediately obvious from the perspective of the producer which observers will be invoked. In FP, a domain event is simply a value returned by a function in an aggregate. Observers can be explicitly registered as filters.</p><p>Furthermore, FRP can handle domain events very effectively. On the other hand, returning domain events from aggregate methods in OOP is prohibitive due to the lack of union types and pattern matching.</p></div><div class="section" title="Intention-revealing interface"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec28"/>Intention-revealing interface</h4></div></div></div><p>In imperative OOP code, intent leaks through side-effects and focuses on the how rather than the what. Always having to bind behavior to the data structure can also be problematic.</p><p>As FP is more declarative, function names and interfaces tend to be more focused on intent rather than the the underlying mechanics. In addition, the interfaces of side-effect-free functions are by nature more revealing because behavior is made explicit through the return value. As a result, in addition to the purely linguistic benefit of naming with intent, intent is also encoded by the type system. This is not to say that expressing intent is effortless in FP—only that it is better supported by the FP paradigm.</p></div><div class="section" title="Side-effect-free functions"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec29"/>Side-effect-free functions</h4></div></div></div><p>Side-effects are in direct opposition to encapsulation, yet all too often they are the most useful tools.</p><p>Unlike imperative programming, FP avoids side-effects. This pattern is yet another example of how a well-crafted object-oriented design converges upon a functional style.</p></div><div class="section" title="Assertions"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec30"/>Assertions</h4></div></div></div><p>Like many patterns rooted in imperative object-oriented design, assertions claim to use implicit side-effects.</p><p>As with intention-revealing interfaces, assertions in FP languages are automatically encoded in the return type of a function in addition to the function name.</p></div><div class="section" title="Conceptual contours"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec31"/>Conceptual contours</h4></div></div></div><p>Conceptual contours emerge when domain knowledge is spread throughout the code to a sufficient degree. In OOP, this can be achieved by carefully following the principles of DDD.</p><p>In FP, conceptual contours emerge more readily, once again due to the declarative and side-effect-free nature of the paradigm. Specifically, clients of the domain model can rely on cohesive functionality attained with composition and yet still have access to constituents without breaking encapsulation.</p></div><div class="section" title="Closure of operations"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl4sec32"/>Closure of operations</h4></div></div></div><p>Closure of operations illustrates yet another example of coercing composition and structure upon object-oriented designs.</p><p>Essentially, closure simplifies reasoning about a problem by restricting the domain of the discourse. The example of a functional implementation of a domain exhibits this characteristic at a fundamental level. The operation of applying a domain event is closed under the set of domain states. In terms of persistence, this naturally translates to event-sourcing but also supports persistence in a key-value store or ORM with no required modification.</p></div></div><div class="section" title="Declarative design"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec70"/>Declarative design</h3></div></div></div><p>The overall intent of the aforementioned patterns is to cultivate a declarative design. As witnessed, FP is inherently more declarative and therefore more accommodating in this regard. Through declarative design, we can distill distinguishing characteristics of the domain better and reduce or eliminate coupling to orthogonal concerns of infrastructure. Consequently, re-usability, testability, correctness, maintainability, and productivity are tremendously enhanced.</p></div></div></div>
<div class="section" title="Protocol-oriented programming (POP)"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec85"/>Protocol-oriented programming (POP)</h1></div></div></div><p>POP encourages us to develop protocols and extend them instead of classes and inheritance. POP is new in the Objective-C and Swift development community, but what it provides is not very different from the concept of <code class="literal">Abstract</code> classes in languages such as Java and C# and <code class="literal">pure-virtual</code> functions in C++.</p><p>In Swift, classes, structs, and enumerations can conform to protocols. This makes protocols more usable because inheritance does not work for structs and enumerations.</p><div class="section" title="POP paradigms"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec87"/>POP paradigms</h2></div></div></div><p>In this section, we will explore POP paradigms. To start with, we will look at an example:</p><pre class="programlisting">protocol UserProtocol { &#13;
    func greet(name: String) -&gt; String &#13;
    func login(username: String, password:String) -&gt; Bool &#13;
}&#13;
</pre><p>This protocol defines two functions to be implemented by the struct, enumeration, or classes that need to conform to this protocol.</p><div class="section" title="Protocol composition"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec71"/>Protocol composition</h3></div></div></div><p>Protocol composition allows types to conform to more than one protocol. This is one of the many advantages that POP has over OOP. With OOP, a class can have only one superclass, which can lead to very monolithic super classes. With POP, we are encouraged to create multiple smaller protocols with very specific requirements.</p></div><div class="section" title="Protocol extensions"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec72"/>Protocol extensions</h3></div></div></div><p>Protocol extensions are one of the most important parts of the POP paradigm. They allow us to add functionality to all types that conform to a given protocol. Without protocol extensions, if we had common functionality that was necessary for all types that conformed to a particular protocol, then we would need to add that functionality to each type. This would lead to large amounts of duplicated code. The following example extends our protocol by adding a <code class="literal">logout</code> method and its implementation; thus any struct, enum or class that conforms to <code class="literal">UserProtocol</code> will have the <code class="literal">logout</code> functionality:</p><pre class="programlisting">extension UserProtocol { &#13;
    func logout(userName: String) -&gt; Bool { &#13;
      return true &#13;
  } &#13;
}&#13;
</pre></div><div class="section" title="Protocol inheritance"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec73"/>Protocol inheritance</h3></div></div></div><p>Protocol inheritance is where one protocol can inherit the requirements from one or more other protocols, as shown in the following code:</p><pre class="programlisting">protocol MobileAppUserProtocol: UserProtocol { &#13;
     &#13;
}&#13;
</pre><p>
<code class="literal">MobileAppUserProtocol</code> inherits from <code class="literal">UserProtocol</code> so it will have all the defined and extended methods.</p></div><div class="section" title="Associated types"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec74"/>Associated types</h3></div></div></div><p>Associated types can be used to make our protocols work with generic types:</p><pre class="programlisting">protocol MobileAppUserProtocol: UserProtocol { &#13;
  associatedtype applicationModuleList &#13;
  func listSelectedModules() -&gt; [applicationModuleList] &#13;
}&#13;
</pre></div><div class="section" title="Conforming to a protocol"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec75"/>Conforming to a protocol</h3></div></div></div><p>The following code presents an example of protocol conformance with associated type usage:</p><pre class="programlisting">enum MobileAppUserType: MobileAppUserProtocol { &#13;
    case admin &#13;
    case endUser &#13;
     &#13;
    func greet(name: String) -&gt; String { &#13;
        switch self { &#13;
        case .admin: &#13;
          return "Welcome \(name) - You are Admin" &#13;
        case .endUser: &#13;
          return "Welcome \(name)!" &#13;
      } &#13;
    } &#13;
    func login(username: String, password:String) -&gt; Bool { &#13;
      return true &#13;
    } &#13;
    func listSelectedModules() -&gt; [String] { &#13;
      return ["Accounting", "CRM"] &#13;
    }   &#13;
  }&#13;
</pre><p>Then we can create a new mobile user as follows:</p><pre class="programlisting">let mobileUser: MobileAppUserType = MobileAppUserType.Admin &#13;
mobileUser.logout("cindy") &#13;
 &#13;
mobileUser.listSelectedModules()&#13;
</pre><p>POP minimizes the inheritance and subclassing necessities by enabling us to conform to protocols and extend them with default implementations.</p></div></div></div>
<div class="section" title="Functional Reactive Programming (FRP)"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Functional Reactive Programming (FRP)</h1></div></div></div><p>Functional programming avoids immutability and side-effects. In some circumstances, the application should react to dynamic value/data changes. For instance, we may need to change the user interface of an iOS application to reflect received data from a backend or database system. How would we do this without states and mutable values?</p><p>Imperative programming captures these dynamic values only indirectly, through state and mutations. The complete history (past, present, and future) has no first-class representation. Moreover, only discretely-evolving values can be (indirectly) captured as the imperative paradigm is temporally discrete.</p><p>FRP provides a way to handle dynamic value changes while still retaining the FP style. FRP, as its name suggests, is a combination of FP and reactive programming. Reactive programming makes it possible to deal with certain data types that represent values over time. These data types are called time flow or event streams in different functional programming languages. Computations that involve these changing-over-time/evolving values will themselves have values that change over time. FRP captures these evolving values directly and has no difficulty with continuously evolving values.</p><p>In addition, FRP can be presented as the following set of principles/rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data types or dynamic/evolving over time values should be first-class citizens. We should be able to define, combine, and pass them to functions and return them from functions.</li><li class="listitem" style="list-style-type: disc">Data types should be built from a few primitives such as constant/static values and time with sequential and parallel combinations. The n behaviors are combined by applying an n-ary function to static values continuously over time.</li><li class="listitem" style="list-style-type: disc">To account for discrete phenomena, we should have additional event types, each of which has a stream (finite or infinite) of occurrences. Each occurrence has an associated time and value.</li><li class="listitem" style="list-style-type: disc">To come up with the compositional vocabulary out of which all behaviors and events can be built, play with some examples. Keep deconstructing into pieces that are more general/simple.</li><li class="listitem" style="list-style-type: disc">We should be able to compose the whole model, using the technique of denotational semantics:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each type has a corresponding simple and precise mathematical type of meaning</li><li class="listitem" style="list-style-type: disc">Each primitive and operator has a simple and precise meaning as a function of the meanings of the constituents</li></ul></div></li></ul></div><div class="section" title="Building blocks of FRP"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec88"/>Building blocks of FRP</h2></div></div></div><p>It is important to understand FRP building blocks to be able to understand FRP. The following sections explain these building blocks with one of the great FRP libraries for the Cocoa framework called ReactiveCocoa developed by GitHub. ReactiveCocoa was developed for Objective-C and, as of version 3.0, all major feature development is concentrated on the Swift API.</p><div class="section" title="Signals"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec76"/>Signals</h3></div></div></div><p>Signals are event streams that send values over time that are already in progress. We can imagine them as pipes that send values without knowing about the previous values that they sent or future values that they are going to send. Signals can be composed, combined, and chained declaratively. Signals can unify all Cocoa common patterns for asynchrony and event handling:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Delegate methods</li><li class="listitem" style="list-style-type: disc">Callback blocks</li><li class="listitem" style="list-style-type: disc">Notifications</li><li class="listitem" style="list-style-type: disc">Control actions and responder chain events</li><li class="listitem" style="list-style-type: disc">Future and Promises</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Key-value observing</strong></span> (<span class="strong"><strong>KVO</strong></span>)</li></ul></div><p>As all of these mechanisms can be represented in the same way, it is easy to declaratively chain and combine them together.</p><p>ReactiveCocoa represents signals as <code class="literal">Signal</code>. Signals can be used to represent notifications, user input, and so on. As work is performed or data is received, events are sent on the signal, which pushes them out to any observers. All observers see the events at the same time.</p><p>Users must observe a signal in order to access its events. Observing a signal does not trigger any side-effects. In other words, signals are entirely producer-driven and push-based, and observers cannot have any effect on the signal's lifetime. While observing a signal, the user can only evaluate the events in the same order as they are sent on the signal. There is no random access to values of a signal.</p><p>Signals can be manipulated by applying the following operations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">reduce</code> to manipulate a single signal</li><li class="listitem" style="list-style-type: disc"><code class="literal">zip</code> to manipulate multiple signals at once</li></ul></div><p>These operations can be applied only on the next events of a signal.</p><p>The lifetime of a signal may consist of a various number of next events, followed by one terminating event, which may be any one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Failed</li><li class="listitem" style="list-style-type: disc">Completed</li><li class="listitem" style="list-style-type: disc">Interrupted</li></ul></div><p>Terminating events are not included in the signal's values and they should be handled specially.</p></div><div class="section" title="Pipes"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec77"/>Pipes</h3></div></div></div><p>A <code class="literal">signal</code> that can be manually controlled is called <code class="literal">pipe</code>. In ReactiveCocoa, we can create a <code class="literal">pipe</code> by calling <code class="literal">Signal.pipe()</code>.</p><p>The <code class="literal">pipe</code> method returns <code class="literal">signal</code> and <code class="literal">observer</code>. The <code class="literal">signal</code> can be controlled by sending events to the observer.</p></div><div class="section" title="Signal producers"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec78"/>Signal producers</h3></div></div></div><p>A signal producer creates signals and performs side-effects. <code class="literal">SignalProducer</code> can be used to represent operations or tasks such as network requests, where each invocation of <code class="literal">start()</code> will create a new underlying operation and allow the caller to observe the result. Unlike a signal, no work is started (and thus no events are generated) until an observer is attached, and the work is restarted for each additional observer.</p><p>Starting a signal producer returns a disposable that can be used to interrupt/cancel the work associated with the produced signal.</p><p>Signal producers can also be manipulated via operations such as map, filter, and reduce. Every signal operation can be <span class="emphasis"><em>lifted</em></span> to operate upon signal producers instead, using the <code class="literal">lift</code> method.</p></div><div class="section" title="Buffers"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec79"/>Buffers</h3></div></div></div><p>A buffer is an optionally bounded queue for events. A buffer replays these events when new signals are created from <code class="literal">SignalProducer</code>. A <code class="literal">buffer</code> is created by calling <code class="literal">SignalProducer.buffer()</code>. Similar to <code class="literal">pipe</code>, the method returns <code class="literal">observer</code>. Events sent to this observer will be added to the queue. If the buffer is already at capacity when a new value arrives, the oldest value will be dropped to make room for it.</p></div><div class="section" title="Observers"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec80"/>Observers</h3></div></div></div><p>An observer is anything that observes or is capable of observing <code class="literal">events</code> from a <code class="literal">signal</code>. Observers can be implicitly created using the callback-based versions of the <code class="literal">Signal.observe()</code> or <code class="literal">SignalProducer.start()</code> methods.</p></div><div class="section" title="Actions"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec81"/>Actions</h3></div></div></div><p>An action will do some work when executed with an input. Actions are useful in performing side-effecting work upon user interaction, such as when a button is clicked. Actions can also be automatically disabled based on a property, and this disabled state can be represented in a user interface by disabling any controls associated with the action.</p></div><div class="section" title="Properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec82"/>Properties</h3></div></div></div><p>A property stores a value and notifies observers about future changes to that value. The current value of a property can be obtained from the value getter. The producer getter returns a signal producer that will send the property's current value, followed by all changes over time.</p></div><div class="section" title="Disposables"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec83"/>Disposables</h3></div></div></div><p>A disposable is a mechanism for memory management and cancellation. When starting a signal producer, a disposable will be returned. This disposable can be used by the caller to cancel the work that has been started, clean up all temporary resources, and then send a final Interrupted event with regard to the particular signal that was created.</p></div><div class="section" title="Schedulers"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec84"/>Schedulers</h3></div></div></div><p>A scheduler is a serial execution queue to perform work or deliver results upon. <code class="literal">Signals</code> and <code class="literal">signal producers</code> can be ordered to deliver events on a specific scheduler. <code class="literal">Signal producers</code> can additionally be ordered to start their work on a specific scheduler.</p><p>Schedulers are similar to the <span class="strong"><strong>Grand Central Dispatch</strong></span> (<span class="strong"><strong>GCD</strong></span>) queues, but schedulers support cancellation via disposables and always execute serially. With the exception of <code class="literal">ImmediateScheduler</code>, schedulers do not offer synchronous execution. This helps avoid deadlocks and encourages the use of <code class="literal">signal</code> and <code class="literal">signal producer</code> operations instead of blocking work.</p><p>Schedulers are also somewhat similar to <code class="literal">NSOperationQueue</code>, but schedulers do not allow tasks to be reordered or depend on one another.</p></div></div><div class="section" title="An example"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec89"/>An example</h2></div></div></div><p>Let's suppose that we have an outlet and we want to observe its changes:</p><pre class="programlisting">@IBOutlet weak var textFieldUserName: UITextField!&#13;
</pre><p>We can create <code class="literal">SignalProducer</code> as follows:</p><pre class="programlisting">let userNameSignalProducer = &#13;
  textFieldUserName.rac_textSignal().toSignalProducer.map { &#13;
  text in text as! String }</pre><p>The <code class="literal">rac_textSignal</code> method is a ReactiveCocoa extension for <code class="literal">UITextField</code> that can be used to create the signal producer.</p><p>Then, we can start our <code class="literal">SignalProducer</code> as follows:</p><pre class="programlisting">userNameSignalProducer.startWithNext { results in &#13;
      print("User name:\(results)") &#13;
}&#13;
</pre><p>This will print any changes in our <code class="literal">textField</code> to the console.</p><p>Also, we can execute operations such as <code class="literal">map</code>, <code class="literal">flatMap</code>, <code class="literal">filter</code>, and <code class="literal">reduce</code> on this signal producer, which we covered in <a class="link" href="ch06.html" title="Chapter 6. Map, Filter, and Reduce">Chapter 6</a>, <span class="emphasis"><em>Map, Filter, and Reduce</em></span>.</p></div></div>
<div class="section" title="Mixing OOP and FP"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Mixing OOP and FP</h1></div></div></div><p>So far, we have seen that adding FP capabilities to an OOP language leads to benefits in the OOP design.</p><p>In summary, OOP fits perfectly with FP when our objects are as immutable as possible. To make our objects as immutable as possible, we can consider the following principles:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Objects should be types that encapsulate related pieces of data</li><li class="listitem" style="list-style-type: disc">Objects can have methods; however, these methods shouldn't change the object and should instead return a new one of the appropriate type</li><li class="listitem" style="list-style-type: disc">All the required state data should be injected into the class's initialization so that it will be ready to use immediately</li><li class="listitem" style="list-style-type: disc">Static methods can be used freely and static variables should be avoided</li><li class="listitem" style="list-style-type: disc">Protocols and generics should be used to avoid code duplicates</li></ul></div><p>These principles not only empower us to employ functional design patterns, but also enrich our object-oriented code.</p><div class="section" title="Problems"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec90"/>Problems</h2></div></div></div><p>There are a few problems in unifying and mixing OOP with FP, which we will cover in the following sections.</p><div class="section" title="Granularity mismatch"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec85"/>Granularity mismatch</h3></div></div></div><p>FP and OOP operate on different design granularity levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">FP: Function/method programming on small level</li><li class="listitem" style="list-style-type: disc">OOP: Classes / objects / modules programming on large level</li></ul></div><p>To overcome this granularity mismatch, we need to find answers for the following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Where do we locate the source of individual functions in an OOP architecture?</li><li class="listitem" style="list-style-type: disc">Where do we relate such individual functions to an OOP architecture?</li></ul></div><p>In Swift, we can place functions inside source files and outside of classes or we can place them as static or class methods.</p></div></div><div class="section" title="FP paradigm availability"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec91"/>FP paradigm availability</h2></div></div></div><p>So far, we explored a lot of different FP paradigms in Swift. Here, we check conceptually whether Swift is a capable language for FP. We will explore the paradigms in the following sections.</p><div class="section" title="First-class values"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec86"/>First-class values</h3></div></div></div><p>In an FP language, functions/methods should be first-class citizens. First-class citizen functions will enable us to use most FP paradigms if they satisfy the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functions/methods should be usable as function/method parameters and arguments</li><li class="listitem" style="list-style-type: disc">Functions/methods can be returned as a result of a function/method</li><li class="listitem" style="list-style-type: disc">Functions can take place in data structures</li></ul></div><p>So far, we have seen an example implementation of all these rules.</p></div><div class="section" title="Closures"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec87"/>Closures</h3></div></div></div><p>First-class functions/methods should be implemented as closures. For instance, they should be associated with specific private environments.</p><p>Swift functions are implemented as closures.</p></div><div class="section" title="FP-OOP interrelation tools"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec88"/>FP-OOP interrelation tools</h3></div></div></div><p>Standalone functions/methods should be explicitly relatable to the class/object level.</p><p>Swift extensions enable us to add methods to existing classes without creating new derived classes.</p></div></div><div class="section" title="FP support"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec92"/>FP support</h2></div></div></div><p>FP paradigms should be reinforced by related constructs, predefined definitions, occurrences in standard libraries, and so on.</p><p>They should satisfy the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overloading for generic function types</li><li class="listitem" style="list-style-type: disc">First-class multiple invocation and multicasting</li><li class="listitem" style="list-style-type: disc">Function marshalling and serialization (closures as data structures)</li></ul></div><p>Swift supports the preceding FP paradigms.</p></div><div class="section" title="Effects of having FP capabilities in OOP"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec93"/>Effects of having FP capabilities in OOP</h2></div></div></div><p>Having FP capabilities in the OOP language causes idiomatic and architectural effects, which are explored in the following sections.</p><div class="section" title="Idiomatic effects"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec89"/>Idiomatic effects</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Code factoring (abstraction) at a function/method granularity level</li><li class="listitem" style="list-style-type: disc">Generic iterator and loop operations (map)</li><li class="listitem" style="list-style-type: disc">Operation composition and sequence comprehensions (chained function calls)</li><li class="listitem" style="list-style-type: disc">Function partial applications and currying</li></ul></div></div><div class="section" title="Architectural effects"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec90"/>Architectural effects</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reduction of the number of object/class definitions: Avoids cluttering the OOP architecture with new classes</li><li class="listitem" style="list-style-type: disc">Name abstraction at a function method level: Using first-class methods allows parameters to be instantiated by any method satisfying their declared type</li><li class="listitem" style="list-style-type: disc">Operation compositions (and sequence comprehensions)</li><li class="listitem" style="list-style-type: disc">Function partial applications and currying</li></ul></div></div></div><div class="section" title="OOP design patterns - an FP perspective"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec94"/>OOP design patterns - an FP perspective</h2></div></div></div><p>Design patterns describe recurring solutions to common problems in object-oriented software design. Patterns are categorized into three types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creational</li><li class="listitem" style="list-style-type: disc">Structural</li><li class="listitem" style="list-style-type: disc">Behavioral</li></ul></div><p>This section introduces some of OOP design patterns on a very high level and introduces the FP counterparts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Strategy</li><li class="listitem" style="list-style-type: disc">Command</li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Observer</li><li class="listitem" style="list-style-type: disc">Proxy</li><li class="listitem" style="list-style-type: disc">Visitor</li></ul></div><div class="section" title="Strategy pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec91"/>Strategy pattern</h3></div></div></div><p>The strategy pattern is a behavioral pattern that lets an algorithm vary independently of clients that use it. In other words, it allows one of a family of algorithms to be selected on-the-fly at runtime.</p><p>From an FP perspective, a strategy is just a case of abstracting code at a method level.</p></div><div class="section" title="Command pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec92"/>Command pattern</h3></div></div></div><p>The command pattern is a behavioral pattern that encapsulates requests (method calls) as objects so that they can be transmitted, stored, and applied easily.</p><p>FP provides closures and first-class functions.</p></div><div class="section" title="Observer pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec93"/>Observer pattern</h3></div></div></div><p>The observer pattern is a behavioral pattern that allows a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated.</p><p>FRP handles this pattern very effectively and declaratively.</p></div><div class="section" title="Virtual proxy pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec94"/>Virtual proxy pattern</h3></div></div></div><p>The virtual proxy pattern is a structural pattern that provides placeholders for other objects in such a way that their data is created/computed only when needed.</p><p>FP provides lazy instantiation and evaluation.</p></div><div class="section" title="Visitor pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec95"/>Visitor pattern</h3></div></div></div><p>The visitor pattern is a behavioral pattern that allows us to define new operations without changing the classes of the elements on which they operate.</p><p>FP makes functions independent of object changes.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Summary</h1></div></div></div><p>In this chapter, we covered object-oriented programming principles and paradigms. Then we discussed protocol-oriented programming. Next, we introduced FRP. Finally, we explored how to mix FP with OOP paradigms.</p><p>In the following chapter, we will develop a Todo backend and an iOS application employing the concepts that we have covered so far.</p><p>We will use functional programming techniques to parse and map the data, and we will use FRP to reactively manage the events in the applications. Additionally, we will employ protocol-oriented programming and object-oriented programming techniques.</p></div></body></html>