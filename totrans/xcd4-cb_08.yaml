- en: Chapter 8. Working with the CoreData and GameKit Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 使用CoreData和GameKit框架
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Adding the GameKit and MessageUI frameworks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加GameKit和MessageUI框架
- en: Building the Core Data data-model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Core Data数据模型
- en: Creating the Core Data model files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Core Data模型文件
- en: Adding and configuring the Storyboard
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和配置Storyboard
- en: Creating the Books Library user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Books Library用户界面
- en: Displaying data within the Table View
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表格视图中显示数据
- en: Inserting data within our Core Data data-model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Core Data数据模型中插入数据
- en: Deleting an item from the Table View using Core Data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Core Data从表格视图中删除项目
- en: Reordering rows within a Table View
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表格视图中重新排序行
- en: Filtering and searching for data within a Table View
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表格视图中过滤和搜索数据
- en: Working with the different keyboard styles
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的键盘样式
- en: Transferring data to another device using Bluetooth
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝牙将数据传输到另一台设备
- en: Implementing e-mail messaging
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现电子邮件消息
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Both the iPhone and iPad devices come with a built-in Bluetooth functionality,
    allowing it to communicate with other Bluetooth-capable devices, such as other
    iOS devices or Bluetooth-compatible headsets. In this chapter, we will take a
    look at how to create a simple `BooksLibrary` application, making use of Apple's
    powerful **Core Data** framework that will allow you to directly interface with
    an **SQLite** database to create and store client information using a form.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone和iPad设备都内置了蓝牙功能，允许它与其他蓝牙设备通信，例如其他iOS设备或蓝牙兼容的耳机。在本章中，我们将探讨如何创建一个简单的`BooksLibrary`应用程序，利用苹果强大的**Core
    Data**框架，允许您直接通过表单与**SQLite**数据库接口创建和存储客户信息。
- en: We will then take a look at how you can incorporate the Bluetooth functionality
    within your application so that you can send this information by communicating
    with another iOS device, and have this information received wirelessly and stored
    within the database at the other end.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看看如何将蓝牙功能集成到您的应用程序中，以便您可以通过与其他iOS设备通信来发送此信息，并且这些信息可以在另一端无线接收并存储在数据库中。
- en: This may all sound a bit confusing at first, but you will soon come to see that
    by using the iOS SDK, Bluetooth programming is actually quite simple and this
    functionality is nicely encapsulated within the **GameKit** framework. Finally,
    we will be taking a look at how we can use the **MessageUI** framework and the
    `MFMailComposeViewController` class to send an e-mail message containing the selected
    Book Details chosen within the table view as well as learning how to reorder and
    delete records within the `UITableView` control.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切一开始可能听起来有些令人困惑，但很快你就会发现，通过使用iOS SDK，蓝牙编程实际上相当简单，并且这个功能被很好地封装在**GameKit**框架中。最后，我们将探讨如何使用**MessageUI**框架和`MFMailComposeViewController`类发送包含在表格视图中选择的书本详情的电子邮件消息，以及学习如何在`UITableView`控件中重新排序和删除记录。
- en: Adding the GameKit and MessageUI frameworks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加GameKit和MessageUI框架
- en: In this recipe we will learn how to add the `GameKit` and `MessageUI` frameworks
    to provide the ability of sending information using Bluetooth, as well as sending
    e-mails.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何添加`GameKit`和`MessageUI`框架，以提供使用蓝牙发送信息以及发送电子邮件的能力。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to proceed, we need to create a new application and add the frameworks
    to our project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续，我们需要创建一个新的应用程序并将框架添加到我们的项目中。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下顺序遵循以下简单步骤：
- en: Launch `Xcode` from the `/Xcode4/Applications` folder.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`/Xcode4/Applications`文件夹启动`Xcode`。
- en: Choose **Create a new Xcode project**, or **File | New | Project…**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建一个新的Xcode项目**，或**文件 | 新 | 项目…**。
- en: Choose the **Empty Application** template from the list of available templates.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的模板列表中选择**Empty Application**模板。
- en: Click on the **Next** button to proceed to the next step in the wizard.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Next**按钮继续向导的下一步。
- en: Enter in **BooksLibrary** as the name for your project.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称输入为**BooksLibrary**。
- en: Select **iPhone** from under the **Devices** drop down.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Devices**下拉菜单下选择**iPhone**。
- en: Ensure that the **Use Core Data** checkbox has been ticked.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选**Use Core Data**复选框。
- en: Ensure that the **Use Automatic Reference Counting** checkbox has been ticked.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已勾选**Use Automatic Reference Counting**复选框。
- en: Ensure that the **Include Unit Tests** checkbox has not been ticked.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保未勾选**Include Unit Tests**复选框。
- en: Click on the **Next** button to proceed to the next step in the wizard and specify
    the location where you would like to save your project.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮继续到向导的下一步，并指定您想要保存项目的位置。
- en: Then, click on the **Create** button to continue and display the Xcode workspace.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **创建** 按钮继续，并显示 Xcode 工作区。
- en: Next, add the `GameKit.framework` and `MessageUI.framework` frameworks to your
    project.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `GameKit.framework` 和 `MessageUI.framework` 框架添加到您的项目中。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we learned how to add both the `GameKit` and `MessageUI` frameworks
    to our project that will enable us to perform the ability of transmitting information
    over a Bluetooth network to other iOS devices, as well as providing the ability
    to send e-mail messages within our application using the `MFMailComposeViewController`
    class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们学习了如何将 `GameKit` 和 `MessageUI` 框架添加到我们的项目中，这将使我们能够执行通过蓝牙网络向其他 iOS 设备传输信息的能力，以及使用
    `MFMailComposeViewController` 类在我们的应用程序中发送电子邮件消息的能力。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Building the Core Data data model* recipe
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建核心数据数据模型* 菜单'
- en: The *Adding the CoreLocation and MapKit frameworks* recipe in [Chapter 5](ch05.html
    "Chapter 5. Working with the Location Services and the MapKit Frameworks"), *Location
    Services and Maps*
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。使用位置服务和 MapKit 框架") 的 *添加 CoreLocation 和 MapKit 框架*
    菜单中，*位置服务和地图*
- en: Building the Core Data data model
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建核心数据数据模型
- en: In this recipe we will learn how to use the Core Data Model Editor to build
    our database schema for our **BooksLibrary** application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何使用核心数据模型编辑器为我们的 **BooksLibrary** 应用程序构建数据库模式。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, ensure that our **BooksLibrary** project
    file is open.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱的基础上，确保我们的 **BooksLibrary** 项目文件已打开。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下顺序遵循以下简单步骤：
- en: Select the `BooksLibrary.xcdatamodel` file from **Project Navigator**.![How
    to do it...](img/3349OT_08_01.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目导航器** 中选择 `BooksLibrary.xcdatamodel` 文件。![如何操作...](img/3349OT_08_01.jpg)
- en: Next, click on the **+Add Entity** button and name this entity **Books**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 **+添加实体** 按钮，并将此实体命名为 **Books**。
- en: Then click on the **+Add Attribute** button or alternatively from the **Attributes**
    pane.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击 **+添加属性** 按钮，或者从 **属性** 面板中。
- en: 'Create each of the **Attributes** and **Type**, as shown in the following table:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建每个 **属性** 和 **类型**，如以下表格所示：
- en: '| Attribute | Type |'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 属性 | 类型 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `author` | `String` |'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `author` | `String` |'
- en: '| `displayOrder` | `Integer 16` |'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `displayOrder` | `Integer 16` |'
- en: '| `publisher` | `String` |'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `publisher` | `String` |'
- en: '| `title` | `String` |'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `title` | `String` |'
- en: Save your project using **File | Save**, as we are done defining our database
    table schema.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **文件 | 保存** 保存您的项目，因为我们已经定义了数据库表模式。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Core Data database model is stored within `BooksLibrary.xcdatamodel`, located
    within the `BooksLibrary` group within the **Project Navigator** window. In this
    recipe, we learned how to define the database schema for our SQLite database and
    create the entities (table) and attributes (fields) that will enable our application
    to write to these fields within the database, so that it can be queried later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 核心数据数据库模型存储在 `BooksLibrary.xcdatamodel` 中，位于 **项目导航器** 窗口内的 `BooksLibrary` 组中。在本菜谱中，我们学习了如何定义我们的
    SQLite 数据库的数据库模式，并创建实体（表）和属性（字段），这将使我们的应用程序能够将这些字段写入数据库，以便以后可以查询。
- en: In our next recipe, we will take a look at how to create the core data model
    files that will allow us to access the table definitions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个菜谱中，我们将探讨如何创建允许我们访问表定义的核心数据模型文件。
- en: See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating the Core Data model files* recipe
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建核心数据模型文件* 菜单'
- en: Creating the Core Data model files
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建核心数据模型文件
- en: In this recipe we will learn how to create the associated Core Data model file
    object definitions for our `BooksLibrary` database schema.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何为我们的 `BooksLibrary` 数据库模式创建相关的核心数据模型文件对象定义。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, ensure that our **BooksLibrary** project
    file is open.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱的基础上，确保我们的 **BooksLibrary** 项目文件已打开。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Before our application can start to use our `BooksLibrary` database, we need
    to create the entity class definitions that will define the variables the database
    store contains so that we can access these through code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序开始使用我们的 `BooksLibrary` 数据库之前，我们需要创建实体类定义，这些定义将定义数据库存储中包含的变量，以便我们可以通过代码访问它们。
- en: Select the `BooksLibrary.xcdatamodel` file from **Project** **Navigator** window.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目导航器** 窗口中选择 `BooksLibrary.xcdatamodel` 文件。
- en: Choose **File | New | File…** or press *Command + N*.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件 | 新建 | 文件…** 或按 *Command + N*。
- en: Next, choose **Core Data** from within the **iOS** group.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 **iOS** 组中选择 **Core Data**。
- en: Then, select the **NSManagedObject subclass** from the list of available templates.![How
    to do it...](img/3349OT_08_02.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从可用模板列表中选择 **NSManagedObject 子类**。![如何操作...](img/3349OT_08_02.jpg)
- en: Click on the **Next** button to proceed with the next step within the wizard.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮继续向导中的下一步。
- en: Click on the **Create** button to save the file to the folder location specified.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 按钮将文件保存到指定的文件夹位置。
- en: Next, we need to define the entities for which we want to create the `NSManagedObject`
    classes for.![How to do it...](img/3349OT_08_03.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们想要为它们创建 `NSManagedObject` 类的实体。![如何操作...](img/3349OT_08_03.jpg)
- en: Select the **Books** entity from the **Select the entities you would like to
    manage** list and then click on the **Next** button to proceed with the next step
    in the wizard.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **选择您要管理的实体** 列表中选择 **Books** 实体，然后点击 **下一步** 按钮继续向导中的下一步。
- en: Ensure that the **Use scalar properties for primitive data types option** has
    not been ticked, then click on the **Create** button to generate the `NSManagedObject`
    class files.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保未勾选 **对于原始数据类型使用标量属性** 选项，然后点击 **创建** 按钮以生成 `NSManagedObject` 类文件。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we learned about the `NSManagedObject` class, and how we can
    use this to define the class for the `Books` entity that we created in the Core
    Data store, as well as defining the table schema fields so that when we want to
    use the `Books` class, we can access the attributes at runtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们了解了 `NSManagedObject` 类，以及我们如何使用这个类来定义在 Core Data 存储中创建的 `Books` 实体的类，以及定义表模式字段，以便当我们想要使用
    `Books` 类时，我们可以在运行时访问属性。
- en: The Core Data model wizard generated two files for us. The `Books.h` interface
    file and a `Books.m` implementation file. The `Books.h` interface file contains
    each of our entity attribute fields with each being declared based on their object
    types, and the `Books.m` implementation file contains each of our entity attribute
    fields with each being declared as `dynamic`. This defines the entity attribute
    properties so that they can be used when data is being written or retrieved from
    the Core Data Model
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data 模型向导为我们生成了两个文件。`Books.h` 接口文件和 `Books.m` 实现文件。`Books.h` 接口文件包含我们每个实体属性字段，每个字段都是根据其对象类型声明的，而
    `Books.m` 实现文件包含我们每个实体属性字段，每个字段都被声明为 `dynamic`。这定义了实体属性属性，以便在向 Core Data 模型写入或从
    Core Data 模型检索数据时可以使用。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the dynamic data type, you can refer to the Apple
    Developer documentation at the following URL: [https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html%23//apple_ref/doc/uid/TP40002154-SW9](https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html%23//apple_ref/doc/uid/TP40002154-SW9)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动态数据类型的信息，您可以参考以下 Apple 开发者文档：[https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html%23//apple_ref/doc/uid/TP40002154-SW9](https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html%23//apple_ref/doc/uid/TP40002154-SW9)
- en: There's more…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: One thing to keep in mind when working with Core Data is that if you try to
    add a new field to the data-model schema, your application will crash. You will
    need to regenerate the `NSManagedObject` files, and then reset the simulator or
    delete the application from the iOS device.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Core Data 时需要注意的一点是，如果你尝试向数据模型模式中添加新字段，你的应用程序将会崩溃。你需要重新生成 `NSManagedObject`
    文件，然后重置模拟器或从 iOS 设备中删除应用程序。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Adding and configuring the storyboard* recipe
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和配置 Storyboard* 菜谱'
- en: Adding and configuring the Storyboard
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和配置 Storyboard
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will learn how to add and configure an application's project
    properties using Xcode so that it is set up correctly to use a Storyboard file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Xcode 添加和配置应用程序的项目属性，以便正确设置以使用 Storyboard 文件。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下顺序遵循以下简单步骤：
- en: Select the **BooksLibrary** project from the **Project Navigator** window.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目导航器** 窗口中选择 **BooksLibrary** 项目。
- en: Choose **File | New | File…**or press *Command + N*
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件 | 新建 | 文件…** 或按 *Command + N*
- en: Choose the **Storyboard** template from the list of available templates, located
    under the **User Interface** option within the **iOS** section.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **iOS** 部分下的 **用户界面** 选项中，从可用的模板列表中选择 **Storyboard** 模板。
- en: Click on the **Next** button to proceed to the next step in the wizard.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮继续向导的下一个步骤。
- en: Ensure that you have selected **iPhone** from under the **Device Family** drop
    down.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已从 **设备家族** 下拉菜单中选择 **iPhone**。
- en: Click on the **Next** button to proceed to the next step in the wizard.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮继续向导的下一个步骤。
- en: Specify **MainStoryboard.storyboard** as the name of the Storyboard file within
    the **Save As** field as the name of the file to be created.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **另存为** 字段中指定 `MainStoryboard.storyboard` 作为 Storyboard 文件的名称，作为要创建的文件名称。
- en: Click on the **Create** button to save the file to the folder specified.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 按钮将文件保存到指定的文件夹中。
- en: 'Our next step is to manually configure our project so that it recognizes and
    uses this file for our application. This can be achieved by following these steps:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是手动配置我们的项目，使其能够识别并使用此文件来构建我们的应用程序。这可以通过以下步骤实现：
- en: Select the **BooksLibrary** project from the **Project Navigator** window.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **项目导航器** 窗口中选择 **BooksLibrary** 项目。
- en: Next, select your project target from under the **TARGETS** group and select
    the **Summary** tab.![How to do it...](img/3349OT_08_04.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 **TARGETS** 组中选择您的项目目标，并选择 **摘要** 选项卡。![如何操作...](img/3349OT_08_04.jpg)
- en: Select **MainStoryboard** from the **Main Storyboard** drop down.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **主Storyboard** 下拉菜单中选择 **MainStoryboard**。
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we learned how to manually add new Storyboard template to your
    project. We then looked at how to configure our project properties so that it
    is set up to use the Storyboard user interface file by our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们学习了如何手动将新的 Storyboard 模板添加到项目中。然后我们查看如何配置项目属性，以便应用程序能够使用 Storyboard
    用户界面文件。
- en: There's more…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'Finally, when using Storyboards, we don''t need to create a new `UIWindow`
    as this will create another window instance, and place this on top of the Storyboard.
    We need to modify our application''s delegate `AppDelegate.m` class as shown in
    the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当使用 Storyboards 时，我们不需要创建一个新的 `UIWindow`，因为这将会创建另一个窗口实例，并将其放置在 Storyboard
    之上。我们需要修改应用程序的代理类 `AppDelegate.m`，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about using Storyboards in your applications, you can
    refer to the Apple Developer Documentation located at: [https://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/Xcode4UserGuide/InterfaceBuilder/InterfaceBuilder](https://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/Xcode4UserGuide/InterfaceBuilder/InterfaceBuilder)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在应用程序中使用 Storyboards 的更多信息，您可以参考位于：[https://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/Xcode4UserGuide/InterfaceBuilder/InterfaceBuilder](https://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/Xcode4UserGuide/InterfaceBuilder/InterfaceBuilder)
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关信息
- en: The *Creating the Books Library user interface* recipe
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建书籍库用户界面* 食谱'
- en: Creating the Books Library user interface
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建书籍库用户界面
- en: In this recipe we will learn how to build the user interface for our Books Library
    project, as well as creating a custom table view controller to act as the data
    source.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何构建我们的书籍库项目的用户界面，以及创建一个自定义的表格视图控制器作为数据源。
- en: Getting ready…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: In this section, we will start by building the components that will comprise
    of our user interface for our application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先构建将构成我们应用程序用户界面的组件。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下顺序执行以下简单步骤：
- en: From the **Project** **Navigator** window, select the file named `MainStoryboard.storyboard`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目导航器** 窗口中，选择名为 `MainStoryboard.storyboard` 的文件。
- en: From the **Object** library, select and drag a new (`UITableViewController`)
    **Table ViewController** control, and add this to the view.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **对象库** 中选择并拖动一个新的 (`UITableViewController`) **表格视图控制器** 控件，并将其添加到视图中。
- en: Next, select the `UITableViewController` control that we just added, and then
    choose **Editor | Embed In | Navigation Controller**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择我们刚刚添加的 `UITableViewController` 控件，然后选择 **编辑 | 嵌入 | 导航控制器**。
- en: On the **Navigation Controller** window, ensure that the **Shows Navigation
    Bar** and **Shows Toolbar** are both ticked under the **Bar Visibility** section
    of the **Navigation Controller** window.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Navigation Controller**窗口中，确保在**Navigation Controller**窗口的**Bar Visibility**部分下，**Shows
    Navigation Bar**和**Shows Toolbar**都已被勾选。
- en: Next, select the `UITableViewController` control and then click on the **Table**
    **View** **Cell** tab, then choose the **Prototype** cell from the **Prototype
    Cells** section.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择`UITableViewController`控件，然后点击**Table View Cell**标签，然后从**Prototype Cells**部分选择**Prototype**单元格。
- en: From the **Attributes Inspector** section, change the **Style** to **Subtitle**.
    This will change the cell's appearance to contain two labels.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Attributes Inspector**部分，将**Style**更改为**Subtitle**。这将改变单元格的外观，使其包含两个标签。
- en: Select the **Identifier** item and enter in **BookCell** as its unique identifier.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Identifier**项目，并输入**BookCell**作为其唯一标识符。
- en: Next, from the **Object Library** window, select and drag a (`UIBarButtonItem`),
    and add this to the left of the navigation bar on our **Table** **View** **Controller**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从**Object Library**窗口中选择并拖动一个(`UIBarButtonItem`)，并将其添加到我们的**Table View Controller**导航栏的左侧。
- en: From the **Attributes Inspector** section, change the value of **Title** to
    **Add**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Attributes Inspector**部分，将**Title**的值更改为**Add**。
- en: Add another `UIBarButtonItem` to the right of the navigation bar on our **Table**
    **View** **Controller** and change the value of **Title** to **Sort Order**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的**Table View Controller**的导航栏右侧添加另一个`UIBarButtonItem`，并将**Title**的值更改为**Sort
    Order**。
- en: Add another `UIBarButtonItem` to the bottom left of the navigation bar on our
    **Table** **View** **Controller** and change the value of **Title** to **Connect**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的**Table View Controller**的导航栏底部左端添加另一个`UIBarButtonItem`，并将**Title**的值更改为**Connect**。
- en: Add a **Flexible Space Bar Button** item next to the **Connect** button.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Connect**按钮旁边添加一个**Flexible Space Bar Button**项目。
- en: Add another `UIBarButtonItem` to the bottom right of the navigation bar on our
    **Table** **View** **Controller** and change the value of **Title** to **Transfer**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的**Table View Controller**的导航栏底部右端添加另一个`UIBarButtonItem`，并将**Title**的值更改为**Transfer**。
- en: Next, we need to create our very own custom `UITableViewController` subclass
    that will act as the data source for our table.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建并设置我们自己的自定义`UITableViewController`子类，该子类将作为我们表格的数据源。
- en: Select the `BooksLibary` folder, choose **File | New | File…** or press *Command
    + N*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`BooksLibary`文件夹，选择**File | New | File…**或按*Command + N*。
- en: Select the **Objective-C class** template from inside the **Cocoa Touch** group.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Cocoa Touch**组中选择**Objective-C class**模板。
- en: Click on the **Next** button to proceed to the next step in the wizard.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击向导中的**Next**按钮以进入下一步。
- en: Enter in **BooksViewController** as the name of the file to create.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**BooksViewController**作为要创建的文件名。
- en: Ensure that you have selected **UITableViewController** as the type of subclass
    to create from the **Subclass** of drop down.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已从**Subclass**下拉菜单中选择**UITableViewController**作为要创建的子类的类型。
- en: Next, click on the **Next** button to proceed to the next step in the wizard,
    and then click on the **Create** button to save the file.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击向导中的**Next**按钮以进入下一步，然后点击**Create**按钮以保存文件。
- en: Next, select the `MainStoryboard.storyboard` file from the **Project** **Navigator**
    window.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从**Project Navigator**窗口中选择`MainStoryboard.storyboard`文件。
- en: Select the `UITableViewController` control and click on the **Identity Inspector**
    section, change the value of the **Custom Class** property to read `BooksViewController`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`UITableViewController`控件，并点击**Identity Inspector**部分，将**Custom Class**属性的值更改为`BooksViewController`。
- en: 'Next, we are going to create and set up the `outlets` and `action` methods
    for each of our buttons, with the following names: `btnAdd`, `btnSortOrder`, `btnConnect`,
    and `btnTransfer`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为每个按钮创建和设置`outlets`和`action`方法，名称如下：`btnAdd`、`btnSortOrder`、`btnConnect`和`btnTransfer`。
- en: Next, we need to set up references for both the `NSManagedObjectContext` and
    `NSFetchedResultsController` objects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`NSManagedObjectContext`和`NSFetchedResultsController`对象设置引用。
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Project Navigator**窗口中打开`BooksViewController.h`接口文件。
- en: Next, modify the interface file as shown by the highlighted code sections.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据突出显示的代码部分修改接口文件。
- en: '[PRE1]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, open the `AppDelegate.m` implementation file, located within the **BooksLibrary**
    folder, and enter in the following highlighted code.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开位于**BooksLibrary**文件夹中的`AppDelegate.m`实现文件，并输入以下突出显示的代码。
- en: '[PRE2]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, modify the `didFinishLaunchingWithOptions` method, located within the
    `AppDelegate.m` implementation file.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改位于`AppDelegate.m`实现文件中的`didFinishLaunchingWithOptions`方法。
- en: '[PRE3]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, **Build** and **Run** the application by choosing **Product | Run** from
    the **Product** menu, or alternatively pressing *Command + R*.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过从**产品**菜单选择**产品 | 运行**或按*Command + R*来**构建**和**运行**应用程序。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we started by building our user interface for our **BooksLibrary**
    application, as well as properly configuring our **Table** **View** **Controller**.
    We then created our very own custom `UITableViewController` subclass that will
    act as the data source for our table so that it will know how many rows to be
    displayed when it retrieves the information from our database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先构建了我们的**BooksLibrary**应用程序的用户界面，以及正确配置了我们的**表格****视图****控制器**。然后，我们创建了自己的自定义`UITableViewController`子类，它将作为表格的数据源，以便在从数据库检索信息时知道要显示多少行。
- en: Next, we updated the class of our `UITableViewController` to use our newly created
    class instead of the default `UITableViewController` class, and included a reference
    to the `NSManagedObjectContext` and `NSFetchedResultsController` objects, that
    provides us with all of the Core Data fetch-related functions, needed to perform
    when populating our table view with data. These functions encapsulate the common
    functions that are associated with the table and the Core Data model. We created
    an `NSArray` array property that is used to store the retrieved data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的`UITableViewController`类的类型更新为使用我们新创建的类，而不是默认的`UITableViewController`类，并包含了`NSManagedObjectContext`和`NSFetchedResultsController`对象的引用，这些对象为我们提供了所有与Core
    Data数据检索相关的函数，这些函数在填充我们的表格视图时需要执行。这些函数封装了与表格和Core Data模型相关联的常用函数。我们创建了一个`NSArray`数组属性，用于存储检索到的数据。
- en: Finally, we initialized the data source for our `booksViewController` using
    the `managedObjectContext` method. This ensures that our controller has access
    to all of the required properties and methods required to add and retrieve the
    information from our data model. Before this can happen, we need to first cycle
    through each scene within our Storyboard in order to get a reference to the `BooksViewController`.
    This is so that we can initialize its data source, so that it points to our database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`managedObjectContext`方法初始化了`booksViewController`的数据源。这确保了我们的控制器可以访问所有必要的属性和方法，以便从我们的数据模型中添加和检索信息。在此之前，我们需要首先遍历Storyboard中的每个场景，以便获取对`BooksViewController`的引用。这样我们就可以初始化其数据源，使其指向我们的数据库。
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying data within the Table View* recipe
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在表格视图中显示数据**的菜谱'
- en: Displaying data within the Table View
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表格视图中显示数据
- en: In this recipe we will learn how to populate a Table View Control with some
    data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何用一些数据填充表格视图控制。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will learn how to populate our `UITableViewControl`
    from our Core Data database model.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的菜谱基础上，我们将学习如何从我们的Core Data数据库模型中填充我们的`UITableViewControl`。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下顺序遵循以下简单步骤：
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件。
- en: Next, modify the implementation file as shown by the highlighted code sections.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据高亮显示的代码部分修改实现文件。
- en: '[PRE4]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Modify the `viewDidLoad:` and `viewDidAppear:` methods as shown by the highlighted
    code sections.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据高亮显示的代码部分修改`viewDidLoad:`和`viewDidAppear:`方法。
- en: '[PRE5]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, create the following code sections, as specified in the code snippet.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据代码片段中的说明创建以下代码部分。
- en: '[PRE6]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we begin by setting the title for our navigation bar, and then
    call the `populateBookDetails` method that will be used to populate the database
    object items to our table view. We then defined the table entity that we want
    to use as our main data source and then created an instance to our `fetchRequest`
    object that will be used to hold the returned items. Next, we specified that we
    would like to have the results sorted by `displayOrder` in ascending order and
    proceeded to execute the record set and check for any errors that occurred using
    the `performFetch` method and then save the result set to our `fetchedObjects`
    property, and call the `reloadData` method on our table view control to redisplay
    the records. Next, we modified our `viewDidAppear` method to handle the refreshing
    of our table view control whenever the view reappears, and then set the number
    of sections and rows that our table view will contain. Finally, we supply the
    cells to reuse identifier of the `UITableViewController` cell that we set up previously,
    then assigned each of the properties from our `BookDetails` array, and write it
    to each of the cell labels.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先为我们的导航栏设置标题，然后调用`populateBookDetails`方法，该方法将用于将数据库对象项填充到我们的表格视图中。然后我们定义了我们要用作主要数据源的表格实体，并创建了一个`fetchRequest`对象的实例，该实例将用于存储返回的项。接下来，我们指定我们希望结果按`displayOrder`升序排序，并继续执行记录集，使用`performFetch`方法检查是否发生任何错误，然后将结果集保存到我们的`fetchedObjects`属性中，并在我们的表格视图控件上调用`reloadData`方法以重新显示记录。接下来，我们修改了`viewDidAppear`方法以处理视图出现时表格视图控件的刷新，然后设置表格视图将包含的节数和行数。最后，我们提供了之前设置的`UITableViewController`单元格的重用标识符，然后从我们的`BookDetails`数组中分配每个属性，并将其写入每个单元格标签。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever you reference the `reuse` identifier as a parameter to the following
    method called `dequeueReusableCellWithIdentifier`, this automatically creates
    a new copy of the prototype, and returns the object back to you.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您将`reuse`标识符作为以下方法`dequeueReusableCellWithIdentifier`的参数时，这会自动创建一个原型的新副本，并将对象返回给您。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Inserting data within our Core Data data model* recipe
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在我们的Core Data数据模型中插入数据*的菜谱'
- en: Inserting data within our Core Data data model
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Core Data数据模型中插入数据
- en: In this recipe we will learn how to write to the data fields contained within
    our core data model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何写入我们核心数据模型中包含的数据字段。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will learn how simple it is to update
    the contents of our Core Data database fields with some data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的菜谱之后，我们将学习如何使用一些数据更新我们的Core Data数据库字段内容。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下顺序遵循以下简单步骤：
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件。
- en: Modify the `btnAdd:` method as shown in the following code snippet.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改如下代码片段所示的`btnAdd:`方法。
- en: '[PRE7]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, create the following code sections, as specified in the code snippet.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据代码片段中的指定创建以下代码部分。
- en: '[PRE8]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we start by dynamically creating each of our fields that will
    be accepting user input and positioning these within a `UIAlertView` dialog, and
    then adding this as a subview to the initial view controller. Next, we check to
    see if we have pressed the **OK** button before we create a managed object context
    that is used to create a new managed object using the `Books` entity description.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先动态创建每个将接受用户输入的字段，并将这些字段定位在`UIAlertView`对话框中，然后将其添加到初始视图控制器作为子视图。然后，在创建用于创建新管理对象的托管对象上下文之前，我们检查是否已按下**确定**按钮。使用`Books`实体描述。
- en: We use the `getters` and `setters` method for each of the schema fields of the
    managed object to set each of the attributes values of the managed object based
    on what has been entered by the user, earlier. Finally the context is instructed
    to save the changes to the persistent store, with a call to the context's `save`
    method. Any errors detected during the save operation to our Core Data data model
    will be displayed within the `UIAlertView` dialog box. To conclude, we refresh
    the table view to show that the new record was added.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用每个托管对象模式字段的`getters`和`setters`方法，根据用户之前输入的内容设置托管对象的每个属性值。最后，上下文被指示调用上下文的`save`方法将更改保存到持久存储中。如果在Core
    Data数据模型的保存操作中检测到任何错误，这些错误将在`UIAlertView`对话框中显示。最后，我们刷新表格视图以显示新记录已被添加。
- en: See also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Delete an item from the Table View using Core Data* recipe
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Core Data从表格视图中**删除一个项目**的配方
- en: Delete an item from the Table View using Core Data
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Core Data从表格视图中删除一个项目
- en: In this recipe we will learn how to delete an item from a Table View, as well
    our Core Data model.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何从表格视图中删除一个项目，以及我们的Core Data模型。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will learn how to delete a row from
    our Table View, and permanently remove this from our Core Data database.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的配方基础上，我们将学习如何从我们的表格视图中删除一行，并永久从我们的Core Data数据库中删除它。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，按照以下顺序遵循以下简单步骤：
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件。
- en: Modify the `tableView:commitEditingStyle:` method as shown in the following
    code snippet.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改如下代码片段所示的`tableView:commitEditingStyle:`方法。
- en: '[PRE9]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, **Build** and **Run** the application by choosing **Product | Run** from
    the **Product** menu, or alternatively pressing *Command + R*.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过从**产品**菜单中选择**产品 | 运行**或按*Command + R*来**构建**和**运行**应用程序。
- en: When the compilation completes, swipe a selected row to display the **Delete**
    button.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译完成时，从选定的行向左滑动以显示**删除**按钮。
- en: '![How to do it...](img/3349OT_08_05.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3349OT_08_05.jpg)'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we start by determining the type of action currently being performed
    within the Table View, which is determined by the `UITableViewCellEditingStyle`
    class. Next, we compare this against the `UITableViewCellEditingStyleDelete` constant
    variable, and if the condition is met, we remove the selected book details at
    the selected row from our `Books` database, and then refresh the Table View data
    source. If any errors have been detected during the removal process, these are
    then logged out to the Debug window.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们首先确定当前在表格视图中正在执行的操作类型，这由`UITableViewCellEditingStyle`类确定。然后，我们将它与`UITableViewCellEditingStyleDelete`常量变量进行比较，如果条件满足，我们将从`Books`数据库中删除所选行的所选书籍详情，然后刷新表格视图数据源。如果在删除过程中检测到任何错误，这些错误将被记录到调试窗口中。
- en: Reordering rows within a Table View
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表格视图中**重新排序行**
- en: In this recipe we will learn how to delete an item from a Table View, as well
    our core data model.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何从表格视图中删除一个项目，以及我们的核心数据模型。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will learn how to delete a row from
    our Table View, and permanently remove this from our Core Data database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的配方基础上，我们将学习如何从我们的表格视图中删除一行，并永久从我们的Core Data数据库中删除它。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，按照以下顺序遵循以下简单步骤：
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件。
- en: Modify the `btnSortOrder:` method as shown in the following code snippet.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改如下代码片段所示的`btnSortOrder:`方法。
- en: '[PRE10]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, create the following code sections, as specified in the code snippet.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建如下代码片段中指定的以下代码部分。
- en: '[PRE11]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, **Build** and **Run** the application by choosing **Product | Run** from
    the **Product** menu, or alternatively pressing *Command + R*.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过从**产品**菜单中选择**产品 | 运行**或按*Command + R*来**构建**和**运行**应用程序。
- en: When the compilation completes, tap the **Sort Order** button to enable our
    table view to support editing, and allow rows to be moved around.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译完成时，轻触**排序顺序**按钮以启用我们的表格视图支持编辑，并允许行移动。
- en: '![How to do it...](img/3349OT_08_06.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3349OT_08_06.jpg)'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we start by turning on table editing when the **Sort Order**
    button is pressed by setting the `self.tableView.editing` property to `YES`. Next,
    we implement the `canMoveRowAtIndexPath:` method that will be used to determine
    whether a row can be moved within the table view. In the `moveRowAtIndexPath:`
    method, we create an `NSMutableArray` that will be used to store our data model
    results, returned by the `NSFetchedResultsController` class. Next, we then reiterate
    over the items and update the `displayOrder` field for each item, before saving
    the managed object context with the reordered results.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先在按下**排序顺序**按钮时，通过将`self.tableView.editing`属性设置为`YES`来开启表格编辑。接下来，我们实现`canMoveRowAtIndexPath:`方法，该方法将用于确定行是否可以在表格视图中移动。在`moveRowAtIndexPath:`方法中，我们创建一个`NSMutableArray`，它将用于存储由`NSFetchedResultsController`类返回的数据模型结果。然后，我们遍历项目并更新每个项目的`displayOrder`字段，在保存带有重新排序结果的托管对象上下文之前。
- en: There's more…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The reason we use an `NSMutableArray` array is because we can insert and remove
    managed object pointers to and from the array without triggering any changes to
    the data store. Any changes you make to the object will be reflected immediately,
    which is often what you want to do, but in cases like this one, we don't want
    to apply these immediately.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`NSMutableArray`数组的原因是因为我们可以在不触发数据存储任何变化的情况下，从数组中插入和移除管理对象指针。你对对象所做的任何更改都将立即反映出来，这通常是您想要做的，但在这种情况下，我们不想立即应用这些更改。
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Filtering and searching for data within a Table View* recipe
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格视图中过滤和搜索数据*菜谱'
- en: Filtering and searching for data within a Table View
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表格视图中过滤和搜索数据
- en: In this recipe we will learn how to search through our Table View to filter
    list items.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何通过搜索表格来过滤列表项。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will learn how to use the `UISearchBar`
    control to allow us to filter and narrow down the results of our book details.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的菜谱之后，我们将学习如何使用`UISearchBar`控件来允许我们过滤和缩小书籍详情的结果。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下顺序遵循以下简单步骤：
- en: Select the `MainStoryboard.storyboard` file from the **Project Navigator** window.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口选择`MainStoryboard.storyboard`文件。
- en: From **Object Library**, select and drag a (`UISearchBar`) **Search** **Bar**
    and **Search Display Controller** control to the top of the navigation bar of
    our (`UITableViewController`) control that we added in previous steps.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**对象库**中选择并拖动一个（`UISearchBar`）**搜索****栏**和**搜索显示控制器**控件到我们在上一步中添加的（`UITableViewController`）控件导航栏的顶部。
- en: Next, create the `outlet` method for the search bar and name it `filteredResults`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为搜索栏创建`outlet`方法，并将其命名为`filteredResults`。
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.h`接口文件。
- en: Next, modify the interface file and add the following highlighted code sections.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改接口文件并添加以下突出显示的代码部分。
- en: '[PRE12]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have created our outlets and extended our class to include the `UISearchBarDelegate`
    object so that we can access the properties and methods. Our next step is to,
    start adding the additional content to our `BooksViewController` class that will
    provide us with the ability to filter the results of our list.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了出口并扩展了我们的类以包括`UISearchBarDelegate`对象，以便我们可以访问属性和方法。我们的下一步是开始向我们的`BooksViewController`类添加额外的内容，这将使我们能够过滤列表的结果。
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window and create the following code sections, as specified in the code snippet.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件，并创建以下代码部分，如代码片段中指定。
- en: '[PRE13]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we start by extending our `BooksViewController` class to use
    the `UISearchBarDelegate` class protocols so that we have access to its properties
    and methods and then change the appearance of the **Search** bar when a user taps
    in it. Next, we specify to show the **Cancel** button when the user is in **Edit**
    mode, and then turn off the **Auto Correction** feature and then proceed to hide
    the **Cancel** button of the **Search** bar when the user has finished with editing.
    In our next step, we call our `populateBookDetails` method to get the updated
    records from the database, and populate this to our Table View control before
    proceeding to cycle through our data source and select those objects that have
    the occurrence of the search string.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先扩展我们的`BooksViewController`类以使用`UISearchBarDelegate`类协议，以便我们可以访问其属性和方法，然后当用户点击时更改**搜索**栏的外观。接下来，我们指定在用户处于**编辑**模式时显示**取消**按钮，然后关闭**自动更正**功能，并在用户完成编辑后隐藏**搜索**栏的**取消**按钮。在我们的下一步中，我们调用我们的`populateBookDetails`方法来从数据库中获取更新后的记录，并在继续遍历数据源并选择那些包含搜索字符串的对象之前，将这些记录填充到我们的表格视图控制中。
- en: Finally, we proceed to reload our Table View with the search data that was returned
    to be matching, and then display the total number of records that match our search
    string within a `UIAlertView` dialog box. If the **Search** criterion is empty,
    we perform a comparison using the `isEqualToString` method and check to see if
    the string is empty. We then resign the keyboard and reload all book details from
    our data model.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们继续用返回的搜索数据重新加载我们的表格视图，然后在`UIAlertView`对话框中显示与我们的搜索字符串匹配的记录总数。如果**搜索**标准为空，我们使用`isEqualToString`方法执行比较，并检查字符串是否为空。然后我们放弃键盘并从我们的数据模型重新加载所有书籍详情。
- en: See also
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Working with the different keyboard styles* recipe
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理不同的键盘样式*菜谱'
- en: Working with the different keyboard styles
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不同的键盘样式
- en: In this recipe we will learn how to delete an item from a table view, as well
    our core data model.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何从表格视图中删除一个项目，以及我们的核心数据模型。
- en: Getting Ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will learn how to apply customized
    keyboard styles to fields within our `UIAlertView` as defined in our `btnAdd`
    method that we defined in an earlier recipe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的菜谱基础上，我们将学习如何将自定义键盘样式应用到我们`UIAlertView`中的字段，正如我们在之前的菜谱中定义的`btnAdd`方法中所述。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下顺序遵循以下简单步骤：
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件。
- en: Modify the `btnAdd` method to apply a custom keyboard type for our `bookTitle`
    field, as shown by the highlighted code section in the following code snippet.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`btnAdd`方法以应用我们的`bookTitle`字段的自定义键盘类型，如下面的代码片段中突出显示的代码部分所示。
- en: '[PRE14]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we begin by updating the `keyboardType` property of the `bookTitleUITextField`
    control and then specify the `UIKeyboardTypeAlphabet` variable as the keyboard
    type to use.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先更新`bookTitleUITextField`控制的`keyboardType`属性，然后指定`UIKeyboardTypeAlphabet`变量作为要使用的键盘类型。
- en: There's more…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `keyboardType` property accepts an enumeration type named `UIKeyboardType`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyboardType`属性接受一个名为`UIKeyboardType`的枚举类型。'
- en: 'The following table explains some of these types:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下表解释了这些类型中的一些：
- en: '| Keyboard type | Description |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 键盘类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `UIKeyboardTypeDefault` | Default keyboard for the current input method.
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeDefault` | 当前输入方法的默认键盘。|'
- en: '| `UIKeyboardTypeASCIICapable` | Displays standard ASCII characters. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeASCIICapable` | 显示标准ASCII字符。|'
- en: '| `UIKeyboardTypeNumbersAndPunctuation` | Displays numbers and punctuation
    keyboard. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeNumbersAndPunctuation` | 显示数字和标点符号键盘。|'
- en: '| `UIKeyboardTypeURL` | Displays a keyboard optimized for URL entry. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeURL` | 显示一个针对URL输入优化的键盘。|'
- en: '| `UIKeyboardTypeNumberPad` | Displays a numeric keypad designed for PIN entry.
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeNumberPad` | 显示一个为PIN输入设计的数字键盘。|'
- en: '| `UIKeyboardTypePhonePad` | Displays a keypad designed for entering telephone
    numbers. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypePhonePad` | 显示一个为输入电话号码设计的键盘。|'
- en: '| `UIKeyboardTypeNamePhonePad` | Displays a keypad designed for entering a
    person''s name or phone number. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeNamePhonePad` | 显示一个为输入人名或电话号码设计的键盘。|'
- en: '| `UIKeyboardTypeEmailAddress` | Displays a keyboard optimized for specifying
    email addresses. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeEmailAddress` | 显示一个针对指定电子邮件地址优化的键盘。|'
- en: '| `UIKeyboardTypeDecimalPad` | Displays a keyboard with numbers and a decimal
    point. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeDecimalPad` | 显示一个带有数字和小数点的键盘。|'
- en: '| `UIKeyboardTypeTwitter` | Displays a keyboard optimized for twitter text
    entry, with easy access to the @ and # characters. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeTwitter` | 显示一个针对twitter文本输入优化的键盘，易于访问@和#字符。|'
- en: '| `UIKeyboardTypeAlphabet` | This has been depreciated, but uses the keyboard
    that displays standard ASCII characters. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `UIKeyboardTypeAlphabet` | 已弃用，但使用显示标准ASCII字符的键盘。|'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the `UIKeyboardType` class, as well as the various
    keyboard types, refer to the Apple Developer Documentation located at: [http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UITextInputTraits_Protocol/Reference/UITextInputTraits.html](http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UITextInputTraits_Protocol/Reference/UITextInputTraits.html)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`UIKeyboardType`类以及各种键盘类型的更多信息，请参阅位于[http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UITextInputTraits_Protocol/Reference/UITextInputTraits.html](http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UITextInputTraits_Protocol/Reference/UITextInputTraits.html)的Apple开发者文档。
- en: See also
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Inserting data within our Core Data data model* recipe
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Core Data数据模型中插入数据*的食谱'
- en: Transferring data to another device using bluetooth
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝牙将数据传输到另一台设备
- en: In this recipe we will l earn how to use the `GameKit` framework APIs that allow
    for communication over a Bluetooth network.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用允许通过蓝牙网络进行通信的`GameKit`框架API。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will look at how we can implement
    these features into our application, to handle transfer our book details from
    one iOS device to another.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的食谱基础上，我们将探讨如何将这些功能实现到我们的应用程序中，以处理将书籍详情从一个iOS设备传输到另一个设备。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请按照以下顺序遵循以下简单步骤：
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.h`接口文件。
- en: Next, modify the interface file and add the following highlighted code sections.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改接口文件并添加以下高亮显示的代码部分。
- en: '[PRE15]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have created our properties and extended our class to include the
    `GKSessionDelegate` and `GKPeerPickerControllerDelegate` objects so that we can
    access their properties and methods. Our next step is to start adding the additional
    content to our `BooksViewController` class that will provide us with the ability
    to send details over Bluetooth.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的属性，并将我们的类扩展到包括`GKSessionDelegate`和`GKPeerPickerControllerDelegate`对象，以便我们可以访问它们的属性和方法。我们的下一步是开始向`BooksViewController`类添加额外的内容，这将使我们能够通过蓝牙发送详情。
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window and enter in the following code highlighted sections.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件，并输入以下高亮显示的代码部分。
- en: '[PRE16]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, modify the `btnConnect` method, as shown in the following code snippet.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`btnConnect`方法，如下面的代码片段所示。
- en: '[PRE17]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, modify the `btnTransfer` method, as shown in the following code snippet.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`btnTransfer`方法，如下面的代码片段所示。
- en: '[PRE18]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, create the following code sections, as specified in the code snippet.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据代码片段中的说明创建以下代码部分。
- en: '[PRE19]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we start by extending our `BooksViewController` class to use
    the `GKSessionDelegate` and `GKPeerPickerControllerDelegate` class protocols so
    that we have access to its properties and methods that are responsible for handling
    the Bluetooth functionality, and a `NSString` object variable `itemSelected` which
    will be used to store the selected book item from our Table View.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们首先扩展我们的`BooksViewController`类以使用`GKSessionDelegate`和`GKPeerPickerControllerDelegate`类协议，这样我们就可以访问其属性和方法，这些属性和方法负责处理蓝牙功能，以及一个`NSString`对象变量`itemSelected`，它将用于存储从我们的表格视图中选择的书本项。
- en: Next, we declare a `GKSessionDelegate` object that is used to represent an active
    session between two connected Bluetooth devices, and it allows for sending and
    receiving of data between the two. `GKPeerPickerControllerDelegate` provides a
    standard UI to let your application discover and connect to another Bluetooth
    device, and is the easiest way of connecting between devices.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个 `GKSessionDelegate` 对象，用于表示两个连接的蓝牙设备之间的活动会话，并允许在两个设备之间发送和接收数据。`GKPeerPickerControllerDelegate`
    提供一个标准用户界面，让您的应用程序发现并连接到另一个蓝牙设备，这是在设备之间连接的最简单方法。
- en: The `btnConnect:` method checks to see the current value of our button using
    the `isEqualToString` method and if the value reads **Connect**, we make a call
    to the `GKPeerPickerController` class, which displays a standard UI for which
    you can connect to another Bluetooth device. Alternatively, if you click on **Disconnect**,
    we make a call to the `disconnectFromAllPeers` method from the **GKSession** object
    to close the connection between the two devices. The `connectionTypesMask` property
    indicates the types of connections that the user can choose from.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`btnConnect:` 方法通过使用 `isEqualToString` 方法检查我们按钮的当前值，如果值显示为 **Connect**，我们将调用
    `GKPeerPickerController` 类，该类显示一个标准用户界面，您可以通过它连接到另一个蓝牙设备。或者，如果您点击 **Disconnect**，我们将从
    **GKSession** 对象调用 `disconnectFromAllPeers` 方法来关闭两个设备之间的连接。`connectionTypesMask`
    属性指示用户可以选择的连接类型。'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two types of connections: `GKPeerPickerConnectionTypeNearby` and
    `GKPeerPickerConnectionTypeOnline`. When using Bluetooth communication, use the
    **GKPeerPickerConnectionTypeNearby** constant. Alternatively, if you want to use
    Internet-based connectivity use the **GKPeerPickerConnectionTypeOnline** constant.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种连接类型：`GKPeerPickerConnectionTypeNearby` 和 `GKPeerPickerConnectionTypeOnline`。当使用蓝牙通信时，使用
    **GKPeerPickerConnectionTypeNearby** 常量。或者，如果您想使用基于互联网的连接，请使用 **GKPeerPickerConnectionTypeOnline**
    常量。
- en: When a Bluetooth connection has been detected between the two devices and the
    user has selected one of the items to connect to from the list of available devices,
    the `peerPickerController:didConnectPeer:toSession:` method is called and we enable
    our **Transfer** button. Once the user has connected to the peer Bluetooth device,
    you save the `GKSession` object to the `currentSession` property, which enables
    you to use the `GKSession` object to communicate with the remote device.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到两个设备之间的蓝牙连接，并且用户已从可用设备列表中选择了一个要连接的项目时，将调用 `peerPickerController:didConnectPeer:toSession:`
    方法，并启用我们的 **Transfer** 按钮。一旦用户连接到对等蓝牙设备，您将 `GKSession` 对象保存到 `currentSession`
    属性中，这样您就可以使用 `GKSession` 对象与远程设备进行通信。
- en: When the user presses the **Transfer** button, it calls the `btnTransfer:` method
    that calls the `sendDataToAllPeers:` method of the `GKSession` object to send
    data to the other device via the `NSData` object. We use a variable called `itemSelected`,
    which contains the contact address information to be sent.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下 **Transfer** 按钮时，它调用 `btnTransfer:` 方法，该方法调用 `GKSession` 对象的 `sendDataToAllPeers:`
    方法，通过 `NSData` 对象将数据发送到另一台设备。我们使用一个名为 `itemSelected` 的变量，其中包含要发送的联系人地址信息。
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `GKSendDataReliable` constant, the `GKSession` object will continue
    to send the data until it successfully transmits the data or the connection times
    out. Alternatively, using `GKSendDataUnreliable` indicates that the `GKSession`
    object should send the data only once with no retry.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `GKSendDataReliable` 常量时，`GKSession` 对象将继续发送数据，直到成功传输数据或连接超时。或者，使用 `GKSendDataUnreliable`
    表示 `GKSession` 对象应仅发送一次数据，不进行重试。
- en: The `receiveData:fromPeer:inSession:context:` method of the `GKSession` object
    is called once connection has been made between the two devices, to handle receiving
    of data that is sent as a `NSData` delimited string. This data needs to be converted
    into an `NSString` object before using the `componentsSeparatedByString` string
    class to split out each field individually, and place these into our `NSMutableArray`
    object variable `myArray`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个设备之间建立连接后，`GKSession` 对象的 `receiveData:fromPeer:inSession:context:` 方法会被调用一次，以处理接收作为
    `NSData` 分隔字符串发送的数据。在可以使用 `componentsSeparatedByString` 字符串类将每个字段单独分割出来并将这些放入我们的
    `NSMutableArray` 对象变量 `myArray` 之前，需要将这些数据转换为 `NSString` 对象。
- en: Next, we create a new `managedObjectContext` instance that points to our `Books`
    entity, and uses the `getter` and `setter` methods of our `NSManagedObject` to
    assign each array element from our `myArray` object, to each of the entity field
    attributes before the details are then written to the database. Any errors detected
    during the save operation to our data model, Core Data, will be displayed within
    a `UIAlertView` dialog box. The `peerPickerControllerDidCancel:` method gets called
    whenever the user cancels out from the Bluetooth picker. Once this happens, we
    change the title of our **Connect** button and disable our **Transfer** button,
    before closing the `peerPicker` dialog box, releasing the memory allocated.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的`managedObjectContext`实例，该实例指向我们的`Books`实体，并使用我们的`NSManagedObject`的`getter`和`setter`方法将`myArray`对象中的每个数组元素分配给实体的每个字段属性，然后在将详细信息写入数据库之前。在将数据模型Core
    Data的保存操作中检测到的任何错误将在`UIAlertView`对话框中显示。当用户从蓝牙选择器取消时，将调用`peerPickerControllerDidCancel:`方法。一旦发生这种情况，我们更改**连接**按钮的标题并禁用**传输**按钮，然后在关闭`peerPicker`对话框之前释放分配的内存。
- en: The method `didChangeState:` gets called whenever a device is connected or disconnected
    from a session and is smart enough to know when a connection has been established
    or ended by checking the `state` property of the `GKPeerConnectionState` class
    and the constants to determine the type of connection. After we have determined
    the `state` type, we write the connection `state` to the console window using
    the `NSLog` statement.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备连接或从会话断开时，`didChangeState:`方法会被调用，并且足够智能，能够知道连接是否已经建立或结束，通过检查`GKPeerConnectionState`类的`state`属性和常量来确定连接类型。在确定`state`类型后，我们使用`NSLog`语句将连接`state`写入控制台窗口。
- en: In our final step, we use the `didSelectRowAtIndexPath:` method, we construct
    the book detail information for the selected row. We use the row property of `indexPath`
    to seek inside our `Books` array, and extract the record information. We then
    construct the record as a delimited string and assign it to our `itemSelected`
    variable, which will be used by the **Transfer** button.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一步，我们使用`didSelectRowAtIndexPath:`方法，为所选行构造书籍详细信息。我们使用`indexPath`的行属性在我们的`Books`数组中查找，并提取记录信息。然后我们将记录作为分隔字符串构造，并将其分配给我们的`itemSelected`变量，该变量将被**传输**按钮使用。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the `NSMutableArray` object, you can refer to the Apple
    Developer documentation at the following URL: [https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html](https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`NSMutableArray`对象的更多信息，您可以参考以下URL的Apple开发者文档：[https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html](https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html)
- en: See also
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing e-mail messaging* recipe
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现电子邮件消息*配方'
- en: Implementing e-mail messaging
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现电子邮件消息
- en: In this recipe we will learn about the `MFMailComposeViewController` class,
    and how we can use this to incorporate e-mail messaging within our application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将了解`MFMailComposeViewController`类，以及我们如何使用它将电子邮件消息集成到我们的应用程序中。
- en: Getting ready
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Following on from our previous recipe, we will look at how to implement the
    `sendEmail` method to compose an e-mail with the selected book details whenever
    a transfer has taken place.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的配方基础上，我们将探讨如何实现`sendEmail`方法，以便在发生传输时用所选书籍详情编写电子邮件。
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To begin, follow these simple steps as outlined in the following order:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下顺序遵循以下简单步骤：
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目** **导航器**窗口打开`BooksViewController.h`接口文件。
- en: Next, modify the interface file and add the following highlighted code sections.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改接口文件并添加以下高亮代码部分。
- en: '[PRE20]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目导航器**窗口打开`BooksViewController.m`实现文件。
- en: Next, modify the `sendEmail:` method, as shown in the following code snippet.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`sendEmail:`方法，如下所示代码片段。
- en: '[PRE21]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we need to modify the `receiveData:` method to enable e-mailing, as shown
    in the following code highlighted sections:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`receiveData:`方法以启用电子邮件发送，如下所示代码高亮部分：
- en: '[PRE22]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a new object instance of the `MFMailComposeViewController`
    class delegate that controls the mail dialog view, thus allowing the user to compose
    and send e-mail without leaving the application. We proceed to change the color
    of the mail composition sheet using the `navigationBar:setTintColor:` method of
    the controller to red, and set the subject heading and body of our e-mail message.
    In our next step, we set the controllers `mailComposeDelegate` to itself, this
    ensures that our controller receives the `mailComposeController:didFinishWithResult:error:`
    message from the `MFMailComposeViewControllerDelegate` protocol when the user
    finishes with the e-mail dialog box. Finally, we call the controller's `dismissViewControllerAnimated:`
    method to display the e-mail dialog box.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个新的`MFMailComposeViewController`类代理对象实例，该对象控制邮件对话框视图，从而允许用户在不离开应用程序的情况下编写和发送电子邮件。我们继续使用控制器的`navigationBar:setTintColor:`方法将邮件编写表单的颜色更改为红色，并设置我们的电子邮件消息的主题标题和正文。在下一步中，我们将控制器的`mailComposeDelegate`设置为自身，这确保了当用户完成电子邮件对话框时，我们的控制器会从`MFMailComposeViewControllerDelegate`协议接收到`mailComposeController:didFinishWithResult:error:`消息。最后，我们调用控制器的`dismissViewControllerAnimated:`方法来显示电子邮件对话框。
- en: There's more…
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Deploy the application onto two different iOS devices, and then **Build** and
    **Run** the application by choosing **Product | Run** from the **Product** menu,
    or alternatively pressing *Command + R*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到两台不同的iOS设备上，然后通过从**产品**菜单选择**产品 | 运行**或按*Command + R*来**构建**和**运行**应用程序。
- en: When the compilation completes, connect each of the devices using Bluetooth,
    select a book from the list, and click on the **Connect** button. After a few
    seconds, a pop up is displayed, and contains a list of the nearby Bluetooth devices
    that the user can choose from. Once the user has selected a device, confirmation
    is required from that device to allow the iOS Simulator to establish a connection
    with it. Once a connection has been established, click on the **Transfer** button
    to transmit the book details to the other device. The following screenshot shows
    the application running within the iOS Simulator and the other running on an iOS
    device with an Internet connection and Bluetooth connectivity, as well as showing
    the generated e-mail for the item selected in the list.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译完成后，使用蓝牙连接每个设备，从列表中选择一本书，然后点击**连接**按钮。几秒钟后，会弹出一个窗口，其中包含用户可以选择的附近蓝牙设备列表。一旦用户选择了设备，需要从该设备获取确认，以便iOS模拟器能够与其建立连接。一旦建立连接，点击**传输**按钮将书籍详情传输到另一台设备。以下截图显示了在iOS模拟器中运行的应用程序以及另一台具有互联网连接和蓝牙连接的iOS设备，以及显示在列表中选定的项目的生成电子邮件。
- en: '![There''s more…](img/3349OT_08_07.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容…](img/3349OT_08_07.jpg)'
- en: See also
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Transferring data to another device using Bluetooth* recipe
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝牙将数据传输到另一台设备的配方
