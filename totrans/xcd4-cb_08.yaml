- en: Chapter 8. Working with the CoreData and GameKit Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GameKit and MessageUI frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Core Data data-model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Core Data model files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and configuring the Storyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Books Library user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data within the Table View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting data within our Core Data data-model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an item from the Table View using Core Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reordering rows within a Table View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and searching for data within a Table View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the different keyboard styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring data to another device using Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing e-mail messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the iPhone and iPad devices come with a built-in Bluetooth functionality,
    allowing it to communicate with other Bluetooth-capable devices, such as other
    iOS devices or Bluetooth-compatible headsets. In this chapter, we will take a
    look at how to create a simple `BooksLibrary` application, making use of Apple's
    powerful **Core Data** framework that will allow you to directly interface with
    an **SQLite** database to create and store client information using a form.
  prefs: []
  type: TYPE_NORMAL
- en: We will then take a look at how you can incorporate the Bluetooth functionality
    within your application so that you can send this information by communicating
    with another iOS device, and have this information received wirelessly and stored
    within the database at the other end.
  prefs: []
  type: TYPE_NORMAL
- en: This may all sound a bit confusing at first, but you will soon come to see that
    by using the iOS SDK, Bluetooth programming is actually quite simple and this
    functionality is nicely encapsulated within the **GameKit** framework. Finally,
    we will be taking a look at how we can use the **MessageUI** framework and the
    `MFMailComposeViewController` class to send an e-mail message containing the selected
    Book Details chosen within the table view as well as learning how to reorder and
    delete records within the `UITableView` control.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GameKit and MessageUI frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to add the `GameKit` and `MessageUI` frameworks
    to provide the ability of sending information using Bluetooth, as well as sending
    e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to proceed, we need to create a new application and add the frameworks
    to our project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch `Xcode` from the `/Xcode4/Applications` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Create a new Xcode project**, or **File | New | Project…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Empty Application** template from the list of available templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in **BooksLibrary** as the name for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **iPhone** from under the **Devices** drop down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Use Core Data** checkbox has been ticked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Use Automatic Reference Counting** checkbox has been ticked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Include Unit Tests** checkbox has not been ticked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard and specify
    the location where you would like to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the **Create** button to continue and display the Xcode workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the `GameKit.framework` and `MessageUI.framework` frameworks to your
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned how to add both the `GameKit` and `MessageUI` frameworks
    to our project that will enable us to perform the ability of transmitting information
    over a Bluetooth network to other iOS devices, as well as providing the ability
    to send e-mail messages within our application using the `MFMailComposeViewController`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Building the Core Data data model* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding the CoreLocation and MapKit frameworks* recipe in [Chapter 5](ch05.html
    "Chapter 5. Working with the Location Services and the MapKit Frameworks"), *Location
    Services and Maps*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Core Data data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to use the Core Data Model Editor to build
    our database schema for our **BooksLibrary** application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, ensure that our **BooksLibrary** project
    file is open.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `BooksLibrary.xcdatamodel` file from **Project Navigator**.![How
    to do it...](img/3349OT_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **+Add Entity** button and name this entity **Books**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click on the **+Add Attribute** button or alternatively from the **Attributes**
    pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create each of the **Attributes** and **Type**, as shown in the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Attribute | Type |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `author` | `String` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `displayOrder` | `Integer 16` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `publisher` | `String` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `title` | `String` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Save your project using **File | Save**, as we are done defining our database
    table schema.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Core Data database model is stored within `BooksLibrary.xcdatamodel`, located
    within the `BooksLibrary` group within the **Project Navigator** window. In this
    recipe, we learned how to define the database schema for our SQLite database and
    create the entities (table) and attributes (fields) that will enable our application
    to write to these fields within the database, so that it can be queried later.
  prefs: []
  type: TYPE_NORMAL
- en: In our next recipe, we will take a look at how to create the core data model
    files that will allow us to access the table definitions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating the Core Data model files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Core Data model files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to create the associated Core Data model file
    object definitions for our `BooksLibrary` database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, ensure that our **BooksLibrary** project
    file is open.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before our application can start to use our `BooksLibrary` database, we need
    to create the entity class definitions that will define the variables the database
    store contains so that we can access these through code.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `BooksLibrary.xcdatamodel` file from **Project** **Navigator** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **File | New | File…** or press *Command + N*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose **Core Data** from within the **iOS** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the **NSManagedObject subclass** from the list of available templates.![How
    to do it...](img/3349OT_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed with the next step within the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button to save the file to the folder location specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to define the entities for which we want to create the `NSManagedObject`
    classes for.![How to do it...](img/3349OT_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Books** entity from the **Select the entities you would like to
    manage** list and then click on the **Next** button to proceed with the next step
    in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Use scalar properties for primitive data types option** has
    not been ticked, then click on the **Create** button to generate the `NSManagedObject`
    class files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned about the `NSManagedObject` class, and how we can
    use this to define the class for the `Books` entity that we created in the Core
    Data store, as well as defining the table schema fields so that when we want to
    use the `Books` class, we can access the attributes at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The Core Data model wizard generated two files for us. The `Books.h` interface
    file and a `Books.m` implementation file. The `Books.h` interface file contains
    each of our entity attribute fields with each being declared based on their object
    types, and the `Books.m` implementation file contains each of our entity attribute
    fields with each being declared as `dynamic`. This defines the entity attribute
    properties so that they can be used when data is being written or retrieved from
    the Core Data Model
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about the dynamic data type, you can refer to the Apple
    Developer documentation at the following URL: [https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html%23//apple_ref/doc/uid/TP40002154-SW9](https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreData/Articles/cdAccessorMethods.html%23//apple_ref/doc/uid/TP40002154-SW9)'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to keep in mind when working with Core Data is that if you try to
    add a new field to the data-model schema, your application will crash. You will
    need to regenerate the `NSManagedObject` files, and then reset the simulator or
    delete the application from the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding and configuring the storyboard* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and configuring the Storyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add and configure an application's project
    properties using Xcode so that it is set up correctly to use a Storyboard file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **BooksLibrary** project from the **Project Navigator** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **File | New | File…**or press *Command + N*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Storyboard** template from the list of available templates, located
    under the **User Interface** option within the **iOS** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you have selected **iPhone** from under the **Device Family** drop
    down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify **MainStoryboard.storyboard** as the name of the Storyboard file within
    the **Save As** field as the name of the file to be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button to save the file to the folder specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next step is to manually configure our project so that it recognizes and
    uses this file for our application. This can be achieved by following these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **BooksLibrary** project from the **Project Navigator** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select your project target from under the **TARGETS** group and select
    the **Summary** tab.![How to do it...](img/3349OT_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **MainStoryboard** from the **Main Storyboard** drop down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned how to manually add new Storyboard template to your
    project. We then looked at how to configure our project properties so that it
    is set up to use the Storyboard user interface file by our application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, when using Storyboards, we don''t need to create a new `UIWindow`
    as this will create another window instance, and place this on top of the Storyboard.
    We need to modify our application''s delegate `AppDelegate.m` class as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about using Storyboards in your applications, you can
    refer to the Apple Developer Documentation located at: [https://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/Xcode4UserGuide/InterfaceBuilder/InterfaceBuilder](https://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/Xcode4UserGuide/InterfaceBuilder/InterfaceBuilder)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating the Books Library user interface* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Books Library user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to build the user interface for our Books Library
    project, as well as creating a custom table view controller to act as the data
    source.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will start by building the components that will comprise
    of our user interface for our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Project** **Navigator** window, select the file named `MainStoryboard.storyboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Object** library, select and drag a new (`UITableViewController`)
    **Table ViewController** control, and add this to the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the `UITableViewController` control that we just added, and then
    choose **Editor | Embed In | Navigation Controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Navigation Controller** window, ensure that the **Shows Navigation
    Bar** and **Shows Toolbar** are both ticked under the **Bar Visibility** section
    of the **Navigation Controller** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the `UITableViewController` control and then click on the **Table**
    **View** **Cell** tab, then choose the **Prototype** cell from the **Prototype
    Cells** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Attributes Inspector** section, change the **Style** to **Subtitle**.
    This will change the cell's appearance to contain two labels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Identifier** item and enter in **BookCell** as its unique identifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, from the **Object Library** window, select and drag a (`UIBarButtonItem`),
    and add this to the left of the navigation bar on our **Table** **View** **Controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Attributes Inspector** section, change the value of **Title** to
    **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another `UIBarButtonItem` to the right of the navigation bar on our **Table**
    **View** **Controller** and change the value of **Title** to **Sort Order**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another `UIBarButtonItem` to the bottom left of the navigation bar on our
    **Table** **View** **Controller** and change the value of **Title** to **Connect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Flexible Space Bar Button** item next to the **Connect** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another `UIBarButtonItem` to the bottom right of the navigation bar on our
    **Table** **View** **Controller** and change the value of **Title** to **Transfer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create our very own custom `UITableViewController` subclass
    that will act as the data source for our table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `BooksLibary` folder, choose **File | New | File…** or press *Command
    + N*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Objective-C class** template from inside the **Cocoa Touch** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button to proceed to the next step in the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter in **BooksViewController** as the name of the file to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you have selected **UITableViewController** as the type of subclass
    to create from the **Subclass** of drop down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Next** button to proceed to the next step in the wizard,
    and then click on the **Create** button to save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the `MainStoryboard.storyboard` file from the **Project** **Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `UITableViewController` control and click on the **Identity Inspector**
    section, change the value of the **Custom Class** property to read `BooksViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we are going to create and set up the `outlets` and `action` methods
    for each of our buttons, with the following names: `btnAdd`, `btnSortOrder`, `btnConnect`,
    and `btnTransfer`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to set up references for both the `NSManagedObjectContext` and
    `NSFetchedResultsController` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, modify the interface file as shown by the highlighted code sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open the `AppDelegate.m` implementation file, located within the **BooksLibrary**
    folder, and enter in the following highlighted code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, modify the `didFinishLaunchingWithOptions` method, located within the
    `AppDelegate.m` implementation file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, **Build** and **Run** the application by choosing **Product | Run** from
    the **Product** menu, or alternatively pressing *Command + R*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we started by building our user interface for our **BooksLibrary**
    application, as well as properly configuring our **Table** **View** **Controller**.
    We then created our very own custom `UITableViewController` subclass that will
    act as the data source for our table so that it will know how many rows to be
    displayed when it retrieves the information from our database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we updated the class of our `UITableViewController` to use our newly created
    class instead of the default `UITableViewController` class, and included a reference
    to the `NSManagedObjectContext` and `NSFetchedResultsController` objects, that
    provides us with all of the Core Data fetch-related functions, needed to perform
    when populating our table view with data. These functions encapsulate the common
    functions that are associated with the table and the Core Data model. We created
    an `NSArray` array property that is used to store the retrieved data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we initialized the data source for our `booksViewController` using
    the `managedObjectContext` method. This ensures that our controller has access
    to all of the required properties and methods required to add and retrieve the
    information from our data model. Before this can happen, we need to first cycle
    through each scene within our Storyboard in order to get a reference to the `BooksViewController`.
    This is so that we can initialize its data source, so that it points to our database.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data within the Table View* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data within the Table View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to populate a Table View Control with some
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will learn how to populate our `UITableViewControl`
    from our Core Data database model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, modify the implementation file as shown by the highlighted code sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the `viewDidLoad:` and `viewDidAppear:` methods as shown by the highlighted
    code sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create the following code sections, as specified in the code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we begin by setting the title for our navigation bar, and then
    call the `populateBookDetails` method that will be used to populate the database
    object items to our table view. We then defined the table entity that we want
    to use as our main data source and then created an instance to our `fetchRequest`
    object that will be used to hold the returned items. Next, we specified that we
    would like to have the results sorted by `displayOrder` in ascending order and
    proceeded to execute the record set and check for any errors that occurred using
    the `performFetch` method and then save the result set to our `fetchedObjects`
    property, and call the `reloadData` method on our table view control to redisplay
    the records. Next, we modified our `viewDidAppear` method to handle the refreshing
    of our table view control whenever the view reappears, and then set the number
    of sections and rows that our table view will contain. Finally, we supply the
    cells to reuse identifier of the `UITableViewController` cell that we set up previously,
    then assigned each of the properties from our `BookDetails` array, and write it
    to each of the cell labels.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you reference the `reuse` identifier as a parameter to the following
    method called `dequeueReusableCellWithIdentifier`, this automatically creates
    a new copy of the prototype, and returns the object back to you.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Inserting data within our Core Data data model* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting data within our Core Data data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to write to the data fields contained within
    our core data model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will learn how simple it is to update
    the contents of our Core Data database fields with some data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `btnAdd:` method as shown in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create the following code sections, as specified in the code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we start by dynamically creating each of our fields that will
    be accepting user input and positioning these within a `UIAlertView` dialog, and
    then adding this as a subview to the initial view controller. Next, we check to
    see if we have pressed the **OK** button before we create a managed object context
    that is used to create a new managed object using the `Books` entity description.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `getters` and `setters` method for each of the schema fields of the
    managed object to set each of the attributes values of the managed object based
    on what has been entered by the user, earlier. Finally the context is instructed
    to save the changes to the persistent store, with a call to the context's `save`
    method. Any errors detected during the save operation to our Core Data data model
    will be displayed within the `UIAlertView` dialog box. To conclude, we refresh
    the table view to show that the new record was added.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Delete an item from the Table View using Core Data* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete an item from the Table View using Core Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to delete an item from a Table View, as well
    our Core Data model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will learn how to delete a row from
    our Table View, and permanently remove this from our Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `tableView:commitEditingStyle:` method as shown in the following
    code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, **Build** and **Run** the application by choosing **Product | Run** from
    the **Product** menu, or alternatively pressing *Command + R*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the compilation completes, swipe a selected row to display the **Delete**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3349OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we start by determining the type of action currently being performed
    within the Table View, which is determined by the `UITableViewCellEditingStyle`
    class. Next, we compare this against the `UITableViewCellEditingStyleDelete` constant
    variable, and if the condition is met, we remove the selected book details at
    the selected row from our `Books` database, and then refresh the Table View data
    source. If any errors have been detected during the removal process, these are
    then logged out to the Debug window.
  prefs: []
  type: TYPE_NORMAL
- en: Reordering rows within a Table View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to delete an item from a Table View, as well
    our core data model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will learn how to delete a row from
    our Table View, and permanently remove this from our Core Data database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `btnSortOrder:` method as shown in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create the following code sections, as specified in the code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, **Build** and **Run** the application by choosing **Product | Run** from
    the **Product** menu, or alternatively pressing *Command + R*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the compilation completes, tap the **Sort Order** button to enable our
    table view to support editing, and allow rows to be moved around.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3349OT_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we start by turning on table editing when the **Sort Order**
    button is pressed by setting the `self.tableView.editing` property to `YES`. Next,
    we implement the `canMoveRowAtIndexPath:` method that will be used to determine
    whether a row can be moved within the table view. In the `moveRowAtIndexPath:`
    method, we create an `NSMutableArray` that will be used to store our data model
    results, returned by the `NSFetchedResultsController` class. Next, we then reiterate
    over the items and update the `displayOrder` field for each item, before saving
    the managed object context with the reordered results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason we use an `NSMutableArray` array is because we can insert and remove
    managed object pointers to and from the array without triggering any changes to
    the data store. Any changes you make to the object will be reflected immediately,
    which is often what you want to do, but in cases like this one, we don't want
    to apply these immediately.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Filtering and searching for data within a Table View* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and searching for data within a Table View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to search through our Table View to filter
    list items.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will learn how to use the `UISearchBar`
    control to allow us to filter and narrow down the results of our book details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `MainStoryboard.storyboard` file from the **Project Navigator** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From **Object Library**, select and drag a (`UISearchBar`) **Search** **Bar**
    and **Search Display Controller** control to the top of the navigation bar of
    our (`UITableViewController`) control that we added in previous steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create the `outlet` method for the search bar and name it `filteredResults`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, modify the interface file and add the following highlighted code sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have created our outlets and extended our class to include the `UISearchBarDelegate`
    object so that we can access the properties and methods. Our next step is to,
    start adding the additional content to our `BooksViewController` class that will
    provide us with the ability to filter the results of our list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window and create the following code sections, as specified in the code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we start by extending our `BooksViewController` class to use
    the `UISearchBarDelegate` class protocols so that we have access to its properties
    and methods and then change the appearance of the **Search** bar when a user taps
    in it. Next, we specify to show the **Cancel** button when the user is in **Edit**
    mode, and then turn off the **Auto Correction** feature and then proceed to hide
    the **Cancel** button of the **Search** bar when the user has finished with editing.
    In our next step, we call our `populateBookDetails` method to get the updated
    records from the database, and populate this to our Table View control before
    proceeding to cycle through our data source and select those objects that have
    the occurrence of the search string.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we proceed to reload our Table View with the search data that was returned
    to be matching, and then display the total number of records that match our search
    string within a `UIAlertView` dialog box. If the **Search** criterion is empty,
    we perform a comparison using the `isEqualToString` method and check to see if
    the string is empty. We then resign the keyboard and reload all book details from
    our data model.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Working with the different keyboard styles* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the different keyboard styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn how to delete an item from a table view, as well
    our core data model.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will learn how to apply customized
    keyboard styles to fields within our `UIAlertView` as defined in our `btnAdd`
    method that we defined in an earlier recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `btnAdd` method to apply a custom keyboard type for our `bookTitle`
    field, as shown by the highlighted code section in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we begin by updating the `keyboardType` property of the `bookTitleUITextField`
    control and then specify the `UIKeyboardTypeAlphabet` variable as the keyboard
    type to use.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `keyboardType` property accepts an enumeration type named `UIKeyboardType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains some of these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyboard type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeDefault` | Default keyboard for the current input method.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeASCIICapable` | Displays standard ASCII characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeNumbersAndPunctuation` | Displays numbers and punctuation
    keyboard. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeURL` | Displays a keyboard optimized for URL entry. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeNumberPad` | Displays a numeric keypad designed for PIN entry.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypePhonePad` | Displays a keypad designed for entering telephone
    numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeNamePhonePad` | Displays a keypad designed for entering a
    person''s name or phone number. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeEmailAddress` | Displays a keyboard optimized for specifying
    email addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeDecimalPad` | Displays a keyboard with numbers and a decimal
    point. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeTwitter` | Displays a keyboard optimized for twitter text
    entry, with easy access to the @ and # characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIKeyboardTypeAlphabet` | This has been depreciated, but uses the keyboard
    that displays standard ASCII characters. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the `UIKeyboardType` class, as well as the various
    keyboard types, refer to the Apple Developer Documentation located at: [http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UITextInputTraits_Protocol/Reference/UITextInputTraits.html](http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UITextInputTraits_Protocol/Reference/UITextInputTraits.html)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Inserting data within our Core Data data model* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring data to another device using bluetooth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will l earn how to use the `GameKit` framework APIs that allow
    for communication over a Bluetooth network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will look at how we can implement
    these features into our application, to handle transfer our book details from
    one iOS device to another.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, modify the interface file and add the following highlighted code sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have created our properties and extended our class to include the
    `GKSessionDelegate` and `GKPeerPickerControllerDelegate` objects so that we can
    access their properties and methods. Our next step is to start adding the additional
    content to our `BooksViewController` class that will provide us with the ability
    to send details over Bluetooth.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window and enter in the following code highlighted sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, modify the `btnConnect` method, as shown in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, modify the `btnTransfer` method, as shown in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create the following code sections, as specified in the code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we start by extending our `BooksViewController` class to use
    the `GKSessionDelegate` and `GKPeerPickerControllerDelegate` class protocols so
    that we have access to its properties and methods that are responsible for handling
    the Bluetooth functionality, and a `NSString` object variable `itemSelected` which
    will be used to store the selected book item from our Table View.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a `GKSessionDelegate` object that is used to represent an active
    session between two connected Bluetooth devices, and it allows for sending and
    receiving of data between the two. `GKPeerPickerControllerDelegate` provides a
    standard UI to let your application discover and connect to another Bluetooth
    device, and is the easiest way of connecting between devices.
  prefs: []
  type: TYPE_NORMAL
- en: The `btnConnect:` method checks to see the current value of our button using
    the `isEqualToString` method and if the value reads **Connect**, we make a call
    to the `GKPeerPickerController` class, which displays a standard UI for which
    you can connect to another Bluetooth device. Alternatively, if you click on **Disconnect**,
    we make a call to the `disconnectFromAllPeers` method from the **GKSession** object
    to close the connection between the two devices. The `connectionTypesMask` property
    indicates the types of connections that the user can choose from.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of connections: `GKPeerPickerConnectionTypeNearby` and
    `GKPeerPickerConnectionTypeOnline`. When using Bluetooth communication, use the
    **GKPeerPickerConnectionTypeNearby** constant. Alternatively, if you want to use
    Internet-based connectivity use the **GKPeerPickerConnectionTypeOnline** constant.'
  prefs: []
  type: TYPE_NORMAL
- en: When a Bluetooth connection has been detected between the two devices and the
    user has selected one of the items to connect to from the list of available devices,
    the `peerPickerController:didConnectPeer:toSession:` method is called and we enable
    our **Transfer** button. Once the user has connected to the peer Bluetooth device,
    you save the `GKSession` object to the `currentSession` property, which enables
    you to use the `GKSession` object to communicate with the remote device.
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses the **Transfer** button, it calls the `btnTransfer:` method
    that calls the `sendDataToAllPeers:` method of the `GKSession` object to send
    data to the other device via the `NSData` object. We use a variable called `itemSelected`,
    which contains the contact address information to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `GKSendDataReliable` constant, the `GKSession` object will continue
    to send the data until it successfully transmits the data or the connection times
    out. Alternatively, using `GKSendDataUnreliable` indicates that the `GKSession`
    object should send the data only once with no retry.
  prefs: []
  type: TYPE_NORMAL
- en: The `receiveData:fromPeer:inSession:context:` method of the `GKSession` object
    is called once connection has been made between the two devices, to handle receiving
    of data that is sent as a `NSData` delimited string. This data needs to be converted
    into an `NSString` object before using the `componentsSeparatedByString` string
    class to split out each field individually, and place these into our `NSMutableArray`
    object variable `myArray`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new `managedObjectContext` instance that points to our `Books`
    entity, and uses the `getter` and `setter` methods of our `NSManagedObject` to
    assign each array element from our `myArray` object, to each of the entity field
    attributes before the details are then written to the database. Any errors detected
    during the save operation to our data model, Core Data, will be displayed within
    a `UIAlertView` dialog box. The `peerPickerControllerDidCancel:` method gets called
    whenever the user cancels out from the Bluetooth picker. Once this happens, we
    change the title of our **Connect** button and disable our **Transfer** button,
    before closing the `peerPicker` dialog box, releasing the memory allocated.
  prefs: []
  type: TYPE_NORMAL
- en: The method `didChangeState:` gets called whenever a device is connected or disconnected
    from a session and is smart enough to know when a connection has been established
    or ended by checking the `state` property of the `GKPeerConnectionState` class
    and the constants to determine the type of connection. After we have determined
    the `state` type, we write the connection `state` to the console window using
    the `NSLog` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In our final step, we use the `didSelectRowAtIndexPath:` method, we construct
    the book detail information for the selected row. We use the row property of `indexPath`
    to seek inside our `Books` array, and extract the record information. We then
    construct the record as a delimited string and assign it to our `itemSelected`
    variable, which will be used by the **Transfer** button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on the `NSMutableArray` object, you can refer to the Apple
    Developer documentation at the following URL: [https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html](https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSMutableArray_Class/Reference/Reference.html)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Implementing e-mail messaging* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing e-mail messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will learn about the `MFMailComposeViewController` class,
    and how we can use this to incorporate e-mail messaging within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following on from our previous recipe, we will look at how to implement the
    `sendEmail` method to compose an e-mail with the selected book details whenever
    a transfer has taken place.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, follow these simple steps as outlined in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BooksViewController.h` interface file from the **Project** **Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, modify the interface file and add the following highlighted code sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `BooksViewController.m` implementation file from the **Project Navigator**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, modify the `sendEmail:` method, as shown in the following code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to modify the `receiveData:` method to enable e-mailing, as shown
    in the following code highlighted sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a new object instance of the `MFMailComposeViewController`
    class delegate that controls the mail dialog view, thus allowing the user to compose
    and send e-mail without leaving the application. We proceed to change the color
    of the mail composition sheet using the `navigationBar:setTintColor:` method of
    the controller to red, and set the subject heading and body of our e-mail message.
    In our next step, we set the controllers `mailComposeDelegate` to itself, this
    ensures that our controller receives the `mailComposeController:didFinishWithResult:error:`
    message from the `MFMailComposeViewControllerDelegate` protocol when the user
    finishes with the e-mail dialog box. Finally, we call the controller's `dismissViewControllerAnimated:`
    method to display the e-mail dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploy the application onto two different iOS devices, and then **Build** and
    **Run** the application by choosing **Product | Run** from the **Product** menu,
    or alternatively pressing *Command + R*.
  prefs: []
  type: TYPE_NORMAL
- en: When the compilation completes, connect each of the devices using Bluetooth,
    select a book from the list, and click on the **Connect** button. After a few
    seconds, a pop up is displayed, and contains a list of the nearby Bluetooth devices
    that the user can choose from. Once the user has selected a device, confirmation
    is required from that device to allow the iOS Simulator to establish a connection
    with it. Once a connection has been established, click on the **Transfer** button
    to transmit the book details to the other device. The following screenshot shows
    the application running within the iOS Simulator and the other running on an iOS
    device with an Internet connection and Bluetooth connectivity, as well as showing
    the generated e-mail for the item selected in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/3349OT_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Transferring data to another device using Bluetooth* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
