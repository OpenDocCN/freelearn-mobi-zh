["```kt\nval range: IntRange = 0.rangeTo(1000)\n```", "```kt\nval range: IntRange = 0..1000\n```", "```kt\n'Z' downTo 'A'\n```", "```kt\nfor (letter in 'Z' downTo 'A') print(letter)\n```", "```kt\nZYXWVUTSRQPONMLKJIHGFEDCBA\n```", "```kt\nval daysOfYear: IntRange = 1..365\nfor(day in daysOfYear.reversed()) {\n    println(\"Remaining days: $day\")\n}\n```", "```kt\nRemaining days: 365\nRemaining days: 364\nRemaining days: 363\nâ€¦\nRemaining days: 2\nRemaining days: 1\n```", "```kt\nval container: ViewGroup = activity.findViewById(R.id.container) as ViewGroup\n(0 until container.childCount).forEach {\n    val child: View = container.getChildAt(it)\n    child.visibility = View.INVISIBLE\n}\n```", "```kt\nval progression: IntProgression = 0..1000 step 100\n```", "```kt\nval progression: IntProgression = 0..1000 step 100\nfor (i in progression) {\n    println(i)\n}\n```", "```kt\nvar i = 0\nwhile (i <= 1000) {\n    println(i)\n    i += 100\n}\n```", "```kt\n'z' downTo 'a'\n```", "```kt\n'z' downTo 'a' step 2\n```", "```kt\n('z' downTo 'a' step 2).forEach { character -> print(character) }\n```", "```kt\nzxvtrpnljhfdb\n```", "```kt\npublic interface ClosedRange<T: Comparable<T>> {\n    public val start: T\n    public val endInclusive: T\n    public operator fun contains(value: T): Boolean {\n        return value >= start && value <= endInclusive\n    }                                      \n    public fun isEmpty(): Boolean = start > endInclusive\n}\n```", "```kt\npublic interface Iterator<out T> {\n    public operator fun next(): T\n    public operator fun hasNext(): Boolean\n}\n```", "```kt\nclass DateIterator(startDate: LocalDate,\n                   val endDateInclusive: LocalDate,\n                   val stepDays: Long) : Iterator<LocalDate> {\n    private var currentDate = startDate\n    override fun hasNext() = currentDate <= endDateInclusive\n    override fun next(): LocalDate {\n        val next = currentDate\n        currentDate = currentDate.plusDays(stepDays)\n        return next\n    }\n}\n```", "```kt\nclass DateProgression(override val start: LocalDate,\n                      override val endInclusive: LocalDate,\n                      val stepDays: Long = 1) : \n                                                Iterable<LocalDate>, \n                                                ClosedRange<LocalDate> {\n    override fun iterator(): Iterator<LocalDate> {\n        return DateIterator(start, endInclusive, stepDays)\n    } \n\n    infix fun step(days: Long) = DateProgression(start, endInclusive, days)\n}\n```", "```kt\noperator fun LocalDate.rangeTo(other: LocalDate) = DateProgression(this, other)\n```", "```kt\nval startDate = LocalDate.of(2020, 1, 1)\nval endDate = LocalDate.of(2020, 12, 31)\nfor (date in startDate..endDate step 7) {\n    println(\"${date.dayOfWeek} $date \")\n}\n```", "```kt\nWEDNESDAY 2020-01-01\nWEDNESDAY 2020-01-08\nWEDNESDAY 2020-01-15\nWEDNESDAY 2020-01-22\nWEDNESDAY 2020-01-29\nWEDNESDAY 2020-02-05\n...\nWEDNESDAY 2020-12-16\nWEDNESDAY 2020-12-23\nWEDNESDAY 2020-12-30\n```", "```kt\nval randomInt = Random().nextInt()\n```", "```kt\nif (randomInt in 0..10) {\n    print(\"$randomInt belongs to <0, 10> range\")\n} else {\n    print(\"$randomInt doesn't belong to <0, 10> range\")\n}\n```", "```kt\nval randomInt = Random(20).nextInt()\nif (randomInt >= 0 && randomInt <= 10) {\n    print(\"$randomInt belongs to <0, 10> range\")\n} else {\n    print(\"$randomInt doesn't belong to <0, 10> range\")\n}\n```", "```kt\nenum class Grade { A, B, C, D }\n```", "```kt\nfun computeGrade(score: Int): Grade =\n        when (score) {\n            in 90..100 -> Grade.A\n            in 75 until 90 -> Grade.B\n            in 60 until 75 -> Grade.C\n            in 0 until 60 -> Grade.D\n            else -> throw IllegalStateException(\"Wrong score value!\")\n        }\n```", "```kt\nval collection = listOf(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\")\nval transformedCollection = collection.map {\n    println(\"Applying map function for $it\")\n    it\n}\nprintln(transformedCollection.take(2))\n```", "```kt\nApplying map function for a\nApplying map function for b\nApplying map function for c\nApplying map function for d\nApplying map function for e\nApplying map function for f\nApplying map function for g\nApplying map function for h\n[a, b]\n```", "```kt\nval sequence = sequenceOf(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\")\n```", "```kt\nval sequence = sequenceOf(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\")\nval transformedSequence = sequence.map {\n    println(\"Applying map function for $it\")\n it\n} \n```", "```kt\nval sequence = sequenceOf(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\")\n\nval transformedSequence = sequence.map {\n    println(\"Applying map function for $it\")\n    it\n}\nprintln(transformedSequence.take(2).toList())\n```", "```kt\nApplying map function for a\nApplying map function for b\n[a, b]\n```", "```kt\nprintln(transformedSequence.take(2).toList())\n```", "```kt\nfun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T>\n```", "```kt\nvar counter = 10\nval sequence: Sequence<Int> = generateSequence {\n    counter--.takeIf { value: Int -> value >= 0 }\n}\nprint(sequence.toList())\n```", "```kt\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n```", "```kt\nfun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T>\n```", "```kt\nfun fibonacci(): Sequence<Int> {\n    return generateSequence(Pair(0, 1)) { Pair(it.second, it.first + it.second) }\n            .map { it.first }\n}\n```", "```kt\nprintln(fibonacci().take(20).toList())\n```", "```kt\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]\n```"]