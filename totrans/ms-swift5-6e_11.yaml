- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Generics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: My first experience with generics was back in 2004, when they were first introduced
    in the Java programming language. I can still remember picking up my copy of *The
    Java Programming Language, Fourth Edition*, which covered Java 5, and reading
    about Java's implementation of generics. Since then, I have used generics in several
    projects, not only in Java but also in other languages. If you are familiar with
    generics in other languages, such as Java, the syntax that Swift uses will be
    very familiar. Generics allow us to write very flexible and reusable code; however,
    just like with subscripts, we need to make sure that we use them properly and
    do not overuse them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触泛型是在 2004 年，当时它们首次在 Java 编程语言中引入。我仍然记得我拿起我的 *《Java 编程语言，第四版》* 的副本，它涵盖了
    Java 5，并阅读了关于 Java 泛型实现的内容。从那时起，我在几个项目中使用了泛型，不仅是在 Java 中，还在其他语言中。如果你熟悉其他语言中的泛型，如
    Java，Swift 使用的语法将会非常熟悉。泛型允许我们编写非常灵活和可重用的代码；然而，就像与子脚本一样，我们需要确保我们正确地使用它们，并且不要过度使用它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are generics?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是泛型？
- en: How to create and use generic functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用泛型函数
- en: How to create and use generic types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用泛型类型
- en: How to use associated types with protocols
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用协议关联类型
- en: Introducing generics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型的介绍
- en: The concept of generics has been around for a while, so it should not be a new
    concept to developers coming from languages such as Java or C#. The Swift implementation
    of generics is very similar to these languages. For those developers coming from
    languages that do not have generics, such as **Objective-C**, they might seem
    a bit foreign at first, but once you start using them, you will realize how powerful
    they are.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的概念已经存在了一段时间，所以对于来自像 Java 或 C# 这样的语言的开发者来说，这应该不是一个新的概念。Swift 的泛型实现与这些语言非常相似。对于那些来自没有泛型的语言，如
    **Objective-C** 的开发者来说，它们可能一开始看起来有些陌生，但一旦开始使用，你就会意识到它们是多么强大。
- en: Generics allow us to write very flexible and reusable code that avoids duplication.
    With a type-safe language, such as Swift, we often need to write functions, classes,
    and structures that are valid for multiple types. Without generics, we need to
    write separate functions for each type we wish to support; however, with generics,
    we can write one generic function to provide the functionality for multiple types.
    Generics allow us to tell a function or type, "*I know Swift is a type-safe language,
    but I do not know the type that will be needed yet. I will give you a placeholder
    for now and will let you know what type to enforce later.*"
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许我们编写非常灵活和可重用的代码，从而避免重复。在像 Swift 这样的类型安全语言中，我们经常需要编写适用于多种类型的函数、类和结构体。没有泛型，我们需要为每个我们希望支持的类型编写单独的函数；然而，有了泛型，我们可以编写一个通用的函数来为多种类型提供功能。泛型允许我们告诉一个函数或类型，“*我知道
    Swift 是一个类型安全语言，但我还不知道需要哪种类型。我现在给你一个占位符，稍后我会告诉你应该使用哪种类型。*”
- en: In Swift, we have the ability to define both generic functions and generic types.
    Let's look at generic functions first.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们有能力定义泛型函数和泛型类型。让我们首先看看泛型函数。
- en: Generic functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用函数
- en: 'Let''s begin by examining the problem that generics try to solve, and then
    we will see how generics solve this problem. Let''s say that we wanted to create
    functions that swapped the values of two variables, as described in the first
    part of this chapter; however, for our application, we need to swap two `integer`
    types, two `Double` types, and two `String` types. The following code shows what
    these functions could look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来分析泛型试图解决的问题，然后我们将看到泛型是如何解决这个问题的。假设我们想要创建交换两个变量值的函数，正如本章第一部分所描述的；然而，对于我们的应用程序，我们需要交换两个
    `integer` 类型、两个 `Double` 类型以及两个 `String` 类型的值。以下代码展示了这些函数可能的样子：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With these three functions, we can swap the original values of two `Integer`
    types, two `Double` types, and two `String` types. Now, let''s say, as we develop
    our application further, we find out that we also need to swap the values of two
    unsigned `Integer` types, two `Float` types, and even a couple of custom types.
    We might easily end up with eight or more swap functions. The worst part is that
    each of these functions contains duplicate code. The only difference between these
    functions is that the parameter types change. While this solution does work, generics
    offer a much simpler and more elegant solution that eliminates all the duplicate
    code. Let''s see how we would condense all three of the preceding functions into
    a single generic function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个函数，我们可以交换两个 `Integer` 类型、两个 `Double` 类型以及两个 `String` 类型的原始值。现在，假设我们在进一步开发应用程序时发现我们还需要交换两个无符号
    `Integer` 类型、两个 `Float` 类型以及一些自定义类型的值。我们可能会轻易地得到八个或更多的交换函数。最糟糕的部分是，这些函数之间唯一的区别是参数类型的变化。虽然这个解决方案是可行的，但泛型提供了一个更简单、更优雅的解决方案，消除了所有重复的代码。让我们看看如何将前面三个函数压缩成一个泛型函数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's look at how we defined the `swapGeneric` function. The function itself
    looks pretty similar to a normal function, except for the capital `T`. The capital
    `T`, as used in the `swapGeneric` function, is a placeholder type, and tells Swift
    that we will be defining the type later. When a type is defined, it will be used
    in place of all the placeholders.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何定义 `swapGeneric` 函数的。函数本身看起来与普通函数非常相似，只是多了个大写 `T`。在 `swapGeneric`
    函数中使用的大写 `T` 是一个占位符类型，告诉 Swift 我们将在稍后定义该类型。当类型被定义时，它将替换所有占位符。
- en: To define a generic function, we include the placeholder type between two angular
    brackets `(<T>)` after the function's name. We can then use that placeholder type
    in place of any type definition within the parameter definitions, the return type,
    or the function itself. The big thing to keep in mind is that, once the placeholder
    is defined as a type, all the other placeholders assume that type. Therefore,
    any variable or constant defined with that placeholder must conform to that type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个泛型函数，我们在函数名称后面包含两个尖括号 `(<T>)` 中的占位符类型。然后我们可以使用该占位符类型来代替参数定义、返回类型或函数本身中的任何类型定义。需要记住的是，一旦占位符被定义为类型，所有其他占位符都假定该类型。因此，使用该占位符定义的任何变量或常量都必须符合该类型。
- en: 'There is nothing special about the capital `T`; we could use any valid identifier
    in place of `T`. We can also use descriptive names, such as key and value, as
    the Swift language does with dictionaries. The following definitions are perfectly
    valid:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大写 `T` 没有什么特别之处；我们可以用任何有效的标识符代替 `T`。我们还可以使用描述性的名称，例如键和值，就像 Swift 语言在字典中使用的那样。以下定义是完全有效的：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In most documentation, generic placeholders are defined with either `T` (for
    type) or `E` (for element). We will, for the purposes of this chapter, use the
    capital `T` to define generic placeholders. It is also good practice to use the
    capital `T` to define a generic placeholder within our code so that the placeholder
    is easily recognized when we are looking at the code at a later time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数文档中，通用占位符是用 `T`（表示类型）或 `E`（表示元素）定义的。在本章的目的上，我们将使用大写 `T` 来定义通用占位符。在代码中定义通用占位符时使用大写
    `T` 也是一个好的实践，这样在稍后查看代码时可以轻松识别占位符。
- en: If you do not like using the capital `T` or capital `E` to define generics,
    try to be consistent. I would recommend that you avoid the use of different identifiers
    to define generics throughout your code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢使用大写 `T` 或大写 `E` 来定义泛型，尽量保持一致性。我建议你在整个代码中避免使用不同的标识符来定义泛型。
- en: 'If we need to use multiple generic types, we can create multiple placeholders
    by separating them with commas. The following example shows how to define multiple
    placeholders for a single function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使用多个泛型类型，我们可以通过逗号分隔来创建多个占位符。以下示例展示了如何为单个函数定义多个占位符：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are defining two generic placeholders, `T` and `E`. In this
    case, we can set the `T` placeholder to one type and the `E` placeholder to a
    different type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了两个通用的占位符，`T` 和 `E`。在这种情况下，我们可以将 `T` 占位符设置为一种类型，而将 `E` 占位符设置为不同的类型。
- en: 'Let''s look at how to call a generic function. The following code will swap
    two integers using the `swapGeneric<T>(inout a: T, inout b: T)` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看如何调用一个泛型函数。以下代码将使用 `swapGeneric<T>(inout a: T, inout b: T)` 函数交换两个整数：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run this code, the output will be `a: 10 b: 5`. We can see that we do
    not have to do anything special to call a generic function. The function infers
    the type from the first parameter and then sets all the remaining placeholders
    to that type. Now, if we need to swap the values of two strings, we will call
    the same function, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that the function is called in exactly the same way as we called
    it when we wanted to swap two integers. One thing that we cannot do is pass two
    different types into the swap function, because we defined only one generic placeholder.
    If we attempt to run the following code, we will receive an error:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The error that we will receive is that it cannot convert the value of type `String`
    to expected argument type `Int`, which tells us that we are attempting to use
    a `String` value when an `Int` value is expected. The reason the function is looking
    for an `Int` value is because the first parameter that we pass into the function
    is an `Int` value, and, therefore, all the generic types in the function become
    `Int` types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say we have the following function, which has multiple generic
    types defined:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function would accept parameters of different types; however, since they
    are of different types, we would be unable to swap the values because they are
    different. There are also other limitations to generics. For example, we may think
    that the following generic function would be valid; however, we would receive
    an error if we tried to implement it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We receive an error because the binary operator `==` cannot be applied to two
    `T` operands. Since the type of the arguments is unknown at the time the code
    is compiled, Swift does not know whether it can use the equal operator on the
    types, and, therefore, an error is thrown. We might think that this is a limit
    that will make generics hard to use. However, we have a way to tell Swift that
    we expect the type, represented by a placeholder, to have a certain functionality.
    This is done with type constraints.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'A type constraint specifies that a generic type must inherit from a specific
    class or conform to a particular protocol. This allows us to use the methods or
    properties defined by the parent class or protocol within the generic function.
    Let''s look at how to use type constraints by rewriting the `genericEqual` function
    to use the `Comparable` protocol:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To specify the type constraint, we put the class or protocol constraint after
    the generic placeholder, where the generic placeholder and the constraint are
    separated by a colon. This new function works as we might expect, and it will
    compare the values of the two parameters and return `true` if they are equal or
    `false` if they are not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare multiple constraints just like we declare multiple generic types.
    The following example shows how to declare two generic types with different constraints:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this function, the type defined by the `T` placeholder must inherit from
    the `MyClass` class, and the type defined by the `E` placeholder must conform
    to the `MyProtocol` protocol. Now that we have looked at generic functions, let's
    look at generic types.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，由 `T` 占位符定义的类型必须继承自 `MyClass` 类，由 `E` 占位符定义的类型必须符合 `MyProtocol` 协议。现在我们已经了解了泛型函数，让我们看看泛型类型。
- en: Generic types
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: We already had a general introduction to how generic types work when we looked
    at Swift arrays and dictionaries. A generic type is a class, structure, or enumeration
    that can work with any type, just like the way Swift arrays and dictionaries work.
    As we recall, Swift arrays and dictionaries are written so that they can contain
    any type. The catch is that we cannot mix and match different types within an
    array or dictionary. When we create an instance of our generic type, we define
    the type that the instance will work with. After we define that type, we cannot
    change the type for that instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 Swift 数组和字典时，我们已经对泛型类型的工作原理有一个一般性的介绍。泛型类型是一个类、结构体或枚举，它可以与任何类型一起工作，就像 Swift
    数组和字典一样工作。正如我们回忆的那样，Swift 数组和字典被编写成可以包含任何类型。问题是，我们无法在数组或字典中混合和匹配不同的类型。当我们创建泛型类型的实例时，我们定义了实例将与之一起工作的类型。在定义了那个类型之后，我们无法为那个实例更改类型。
- en: To demonstrate how to create a generic type, let's create a simple `List` class.
    This class will use a Swift array as the backend storage for the list, and will
    let us add items to the list or retrieve values from the list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何创建泛型类型，让我们创建一个简单的 `List` 类。这个类将使用 Swift 数组作为列表的后端存储，并允许我们向列表中添加项目或从列表中检索值。
- en: 'Let''s begin by seeing how to define our generic `List` type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何定义我们的泛型 `List` 类型：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code defines the generic `List` type. We can see that we use the
    `<T>` tag to define a generic placeholder, just like we did when we defined a
    generic function. This `T` placeholder can then be used anywhere within the type
    instead of a concrete type definition.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了通用的 `List` 类型。我们可以看到，我们使用 `<T>` 标签来定义一个通用的占位符，就像我们在定义通用函数时做的那样。这个 `T`
    占位符然后可以在类型的任何地方使用，而不是使用具体的类型定义。
- en: 'To create an instance of this type, we would need to define the type of items
    that our list will hold. The following example shows how to create instances of
    the generic `List` type for various types:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此类型的实例，我们需要定义列表将包含的项目类型。以下示例展示了如何为各种类型创建泛型 `List` 类型的实例：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding example creates three instances of the `List` class. The `stringList`
    instance can be used with instances of the `String` type, the `intList` instance
    can be used with instances of the `integer` type, and the `customList` instance
    can be used with instances of the `MyObject` type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例创建了 `List` 类的三个实例。`stringList` 实例可以与 `String` 类型的实例一起使用，`intList` 实例可以与
    `integer` 类型的实例一起使用，而 `customList` 实例可以与 `MyObject` 类型的实例一起使用。
- en: 'We are not limited to using generics only with classes. We can also define
    structures and enumerations as generics. The following example shows how to define
    a generic structure and a generic enumeration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于在类中使用泛型。我们还可以将结构和枚举定义为泛型。以下示例展示了如何定义一个泛型结构和泛型枚举：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s add the backend storage array to our `List` class. The items that
    are stored in this array need to be of the same type that we define when we initiate
    the class; therefore, we will use the `T` placeholder for the array''s definition.
    The following code shows the `List` class with an array named `items`. The `items`
    array will be defined using the `T` placeholder, so it will hold the same types
    that we defined for the class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将后端存储数组添加到我们的 `List` 类中。存储在这个数组中的项目需要与我们初始化类时定义的类型相同；因此，我们将使用 `T` 占位符来定义数组的定义。以下代码显示了具有名为
    `items` 的数组的 `List` 类。`items` 数组将使用 `T` 占位符定义，因此它将包含我们为类定义的相同类型：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code defines our generic `List` type and uses `T` as the type placeholder.
    We can then use this `T` placeholder anywhere in the class to define the type
    of an item. That item will then be of the same type that we defined when we created
    the instance of the `List` class. Therefore, if we create an instance of the `List`
    type, such as `var stringList = List<String>()`, the `items` array will be an
    array of string instances. If we created an instance of the `List` type, such
    as `var intList = List<Int>()`, the `items` array will be an array of integer
    instances.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to create the `add()` method, which will be used to add an item
    to the list. We will use the `T` placeholder within the method declaration to
    define that the `item` parameter will be of the same type that we declared when
    we initiated the class. Therefore, if we create an instance of the `List` type
    to use the `String` type, we will be required to use an instance of the `String`
    type as the parameter for the `add()` method. However, if we create an instance
    of the `List` type to use the `Int` type, we will be required to use an instance
    of the `Int` type as the parameter for the `add()` method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `add()` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To create a standalone generic function, we add the `<T>` declaration after
    the function name to declare that it is a generic function; however, when we use
    a generic method within a generic type, we do not need the `<T>` declaration.
    Instead, we just need to use the type that we defined in the class declaration.
    If we wanted to introduce another generic type, we could define it with the method
    declaration.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the `getItemAtIndex()` method, which will return the item from
    the backend array, at the specified index:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `getItemAtIndex()` method accepts one argument, which is the index of the
    item we want to retrieve. We then use the `T` placeholder to specify that our
    return type is an optional that might be of the `T` type or that might be nil.
    If the backend storage array contains an item at the specified index, we will
    return that item; otherwise, we return `nil`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our entire generic `List` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, we initially defined the generic `T` placeholder type in the
    class declaration. We then used this placeholder type within our class. In our
    `List` class, we used this placeholder in three places. We used it as the type
    for our `items` array, as the parameter type for our `add()` method, and as the
    optional return type in the `getItemAtIndex()` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to use the `List` class. When we use a generic type,
    we define the type to be used within the class between angled brackets, such as
    `<type>`. The following code shows how to use the `List` class to store instances
    of the `String` type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we start off by creating an instance of the `List` type,
    called `list`, and specify that it will store instances of the `String` type.
    We then use the `add()` method twice to store two items in the `list` instance.
    Finally, we use the `getItemAtIndex()` method to retrieve the item at index number
    `1`, which will display `Optional(World)` to the console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define our generic types with multiple placeholder types, similarly
    to how we use multiple placeholders in our generic methods. To use multiple placeholder
    types, we separate them with commas. The following example shows how to define
    multiple placeholder types:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then create an instance of the `MyClass` type that uses instances of the
    `String` and `Int` types, like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also use type constraints with generic types. Once again, using a type
    constraint for a generic type is exactly the same as using one with a generic
    function. The following code shows how to use a type constraint to ensure that
    the generic type conforms to the `Comparable` protocol:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So far in this chapter, we have seen how to use placeholder types with functions
    and types. Now let's see how we can conditionally add extensions to a generic
    type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally adding extensions with generics
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add extensions to a generic type conditionally if the type conforms
    to a protocol. For example, if we wanted to add a `sum()` method to our generic
    `List` type only if the type for `T` conforms to the numeric protocol, we could
    do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This extension adds the `sum()` method to any `list` instance where the `T`
    type conforms to the numeric protocol. This means that the `list` instance in
    the previous example, where the list was created to hold `String` instances, would
    not receive this method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, where we create an instance of the `List` type that
    contains integers, the instance will receive `sum()` and can be used as shown:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output of this would be `12`. We are also able to conditionally add functions
    inside a generic type or extension.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally adding functions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditionally adding extensions, as we saw in the last section, works great;
    however, if we had separate functionality that we wished to add for different
    conditions, we would have to create separate extensions for each condition. Starting
    in Swift 5.3 with SE-0267, we are able to conditionally add functions to a generic
    type or extension. Let''s take a look at this by rewriting the extension in the
    previous section:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this code, we moved the `where T: Numeric` clause out of the extensions
    declaration and into the function declaration. This will conditionally add the
    function if the type conforms to the `Numeric` protocol. Now we can add additional
    functions to the extension with different conditions as shown in the following
    code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous code, we added an additional function named `sorted()` that
    will only be applied to instances where the type conforms to the `Comparable`
    protocol. This enables us to put functions with different conditions in the same
    extension or generic type rather than creating multiple extensions. I would definitely
    recommend conditionally adding functions, as shown in this section, over conditionally
    adding extensions, as shown in the previous section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at conditional conformance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Conditional conformance
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditional conformance allows a generic type to conform to a protocol only
    if the type meets certain conditions. For example, if we wanted our `List` type
    to conform to the `Equatable` protocol only if the type stored in the list also
    conformed to the `Equatable` protocol, we could use the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code will add conformance to the `Equatable` protocol to any instance of
    the `List` type where the type that is stored in the list also conforms to the
    `Equatable` protocol.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a new function shown here that we have not talked about: the `zip()`
    function. This function will loop through two sequences, in our case arrays, simultaneously
    and create pairs (`e1` and `e2`) that we can compare.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The comparison function will first check to see that each array contains the
    same number of elements and if not, it will return `false`. It then loops through
    each array, simultaneously comparing the elements of the arrays; if any of the
    pairs do not match, it will return `false`. If the previous tests pass, `true`
    is returned, which indicates that the `list` instances are equal because the elements
    in the list are the same.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we can add generic subscripts to a non-generic type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Generic subscripts
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Swift 4, if we wanted to use generics with a subscript, we had to
    define the subscript at the class or structure level. This forced us to make generic
    methods when it felt like we should be using subscripts. Starting with Swift 4,
    we can create generic subscripts, where either the subscript''s return type or
    its parameters may be generic. Let''s look at how we can create a generic subscript.
    In this first example, we will create a subscript that will accept one generic
    parameter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we create a generic subscript, we define the placeholder type after the
    `subscript` keyword. In the previous example, we define the `T` placeholder type
    and use a type constraint to ensure that the type conforms to the `Hashable` protocol.
    This will allow us to pass in an instance of any type that conforms to the `Hashable`
    protocol.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned at the start of this section, we can also use generics for
    the return type of a subscript. We define the generic placeholder for the return
    type exactly as we did for the generic parameter. The following example illustrates
    this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we define the `T` placeholder type after the `subscript` keyword,
    as we did in the previous example. We then use this type as our return type for
    the `subscript`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Associated types
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An associated type declares a placeholder name that can be used instead of a
    type within a protocol. The actual type to be used is not specified until the
    protocol is adopted. When creating generic functions and types, we used a very
    similar syntax, as we have seen throughout this chapter. Defining associated types
    for a protocol, however, is very different. We specify an associated type using
    the `associatedtype` keyword.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use associated types when we define a protocol. In this example,
    we will define the `QueueProtocol` protocol, which defines the capabilities that
    need to be implemented by the queue that implements it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this protocol, we defined one associated type, named `QueueType`. We then
    used this associated type twice within the protocol: once as the parameter type
    for the `add()` method and once when we defined the return type of the `getItem()`
    method as an optional type that might return an associated type of `QueueType`
    or `nil`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Any type that implements the `QueueProtocol` protocol must be able to specify
    the type to use for the `QueueType` placeholder, and must also ensure that only
    items of that type are used where the protocol uses the `QueueType` placeholder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to implement `QueueProtocol` in a non-generic class called
    `IntQueue`. This class will implement the `QueueProtocol` protocol using the `Integer`
    type:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `IntQueue` class, we begin by defining our backend storage mechanism
    as an array of integer types. We then implement each of the methods defined in
    the `QueueProtocol` protocol, replacing the `QueueType` placeholder defined in
    the protocol with the `Int` type. In the `add()` method, the `parameter` type
    is defined as an instance of `Int` type, and in the `getItem()` method, the `return`
    type is defined as an optional that might return an instance of `Int` type or
    `nil`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `IntQueue` class as we would use any other class. The following
    code shows this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We begin by creating an instance of the `IntQueue` class, named `intQ`. We then
    call the `add()` method twice to add two values of the integer type to the `intQ`
    instance. We then retrieve the first item in the `intQ` instance by calling the
    `getItem()` method. This line will print the number `2` to the console. The final
    line of code adds another instance of the integer type to the `intQ` instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we implemented the `QueueProtocol` protocol in a
    non-generic way. This means that we replaced the placeholder types with an actual
    type. `QueueType` was replaced by the `Int` type. We can also implement `QueueProtocol`
    with a generic type. Let''s see how we would do this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, the `GenericQueue` implementation is very similar to the `IntQueue`
    implementation, except that we define the type to use as the generic placeholder
    `T`. We can then use the `GenericQueue` class as we would use any generic class.
    Let''s look at how to use the `GenericQueue` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`GenericQueue` 的实现与 `IntQueue` 的实现非常相似，除了我们定义了要使用的类型为泛型占位符 `T`。然后我们可以像使用任何泛型类一样使用
    `GenericQueue` 类。让我们看看如何使用 `GenericQueue` 类：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We begin by creating an instance of the `GenericQueue` class that will use the
    `Int` type and name it `intQ2`. Next, we call the `add()` method twice to add
    two instances of the integer type to the `intQ2` instance. We then retrieve the
    first item in the queue that was added using the `getItem()` method and print
    the value to the console. This line will print the number `2` to the console.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `GenericQueue` 类的实例，该实例将使用 `Int` 类型，并将其命名为 `intQ2`。然后，我们调用 `add()`
    方法两次，将两个整型实例添加到 `intQ2` 实例中。接着，我们使用 `getItem()` 方法检索队列中添加的第一个项目，并将值打印到控制台。这一行将在控制台打印数字
    `2`。
- en: 'We can also use type constraints with associated types. When the protocol is
    adopted, the type defined for the associated type must inherit from the class
    or conform to the protocol defined by the type constraint. The following line
    defines an associated type with a type constraint:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用关联类型与类型约束。当采用协议时，为关联类型定义的类型必须从类继承或遵守类型约束定义的协议。以下行定义了一个具有类型约束的关联类型：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we specify that when the protocol is implemented, the type
    defined for the associated type must conform to the `Hashable` protocol.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们指定当实现协议时，为关联类型定义的类型必须遵守 `Hashable` 协议。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Generic types can be incredibly useful, and they are also the basis of the Swift
    standard collection types (arrays and dictionaries); however, as mentioned in
    the introduction to this chapter, we have to be careful to use them correctly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型非常有用，它们也是 Swift 标准集合类型（数组和字典）的基础；然而，正如本章引言中提到的，我们必须小心正确地使用它们。
- en: We saw a couple of examples in this chapter that show how generics can make
    our lives easier. The `swapGeneric()` function that was shown at the beginning
    of the chapter is a good use of a generic function because it allows us to swap
    two values of any type we choose, while only implementing the swap code once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了几个示例，展示了泛型如何使我们的生活变得更简单。本章开头展示的 `swapGeneric()` 函数是一个很好的泛型函数的例子，因为它允许我们交换任何类型的选择的两个值，而只需实现一次交换代码。
- en: The generic `List` type is also a good example of how to make custom collection
    types that can be used to hold any type. The way that we implemented the generic
    `List` type in this chapter is similar to how Swift implements an array and dictionary
    with generics.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 `List` 类型也是一个很好的例子，说明了如何创建自定义集合类型，这些类型可以用来存储任何类型的对象。在本章中，我们实现通用 `List` 类型的方法与
    Swift 使用泛型实现数组和字典的方法类似。
- en: In the next chapter, we will look at error handling with Swift and how we can
    make a feature available only if the device that the user is using has a certain
    version of the OS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Swift 中的错误处理以及如何使某些功能仅在用户使用的设备运行特定版本的操作系统时才可用。
