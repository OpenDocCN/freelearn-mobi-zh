- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My first experience with generics was back in 2004, when they were first introduced
    in the Java programming language. I can still remember picking up my copy of *The
    Java Programming Language, Fourth Edition*, which covered Java 5, and reading
    about Java's implementation of generics. Since then, I have used generics in several
    projects, not only in Java but also in other languages. If you are familiar with
    generics in other languages, such as Java, the syntax that Swift uses will be
    very familiar. Generics allow us to write very flexible and reusable code; however,
    just like with subscripts, we need to make sure that we use them properly and
    do not overuse them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are generics?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and use generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and use generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use associated types with protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of generics has been around for a while, so it should not be a new
    concept to developers coming from languages such as Java or C#. The Swift implementation
    of generics is very similar to these languages. For those developers coming from
    languages that do not have generics, such as **Objective-C**, they might seem
    a bit foreign at first, but once you start using them, you will realize how powerful
    they are.
  prefs: []
  type: TYPE_NORMAL
- en: Generics allow us to write very flexible and reusable code that avoids duplication.
    With a type-safe language, such as Swift, we often need to write functions, classes,
    and structures that are valid for multiple types. Without generics, we need to
    write separate functions for each type we wish to support; however, with generics,
    we can write one generic function to provide the functionality for multiple types.
    Generics allow us to tell a function or type, "*I know Swift is a type-safe language,
    but I do not know the type that will be needed yet. I will give you a placeholder
    for now and will let you know what type to enforce later.*"
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, we have the ability to define both generic functions and generic types.
    Let's look at generic functions first.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by examining the problem that generics try to solve, and then
    we will see how generics solve this problem. Let''s say that we wanted to create
    functions that swapped the values of two variables, as described in the first
    part of this chapter; however, for our application, we need to swap two `integer`
    types, two `Double` types, and two `String` types. The following code shows what
    these functions could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With these three functions, we can swap the original values of two `Integer`
    types, two `Double` types, and two `String` types. Now, let''s say, as we develop
    our application further, we find out that we also need to swap the values of two
    unsigned `Integer` types, two `Float` types, and even a couple of custom types.
    We might easily end up with eight or more swap functions. The worst part is that
    each of these functions contains duplicate code. The only difference between these
    functions is that the parameter types change. While this solution does work, generics
    offer a much simpler and more elegant solution that eliminates all the duplicate
    code. Let''s see how we would condense all three of the preceding functions into
    a single generic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at how we defined the `swapGeneric` function. The function itself
    looks pretty similar to a normal function, except for the capital `T`. The capital
    `T`, as used in the `swapGeneric` function, is a placeholder type, and tells Swift
    that we will be defining the type later. When a type is defined, it will be used
    in place of all the placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: To define a generic function, we include the placeholder type between two angular
    brackets `(<T>)` after the function's name. We can then use that placeholder type
    in place of any type definition within the parameter definitions, the return type,
    or the function itself. The big thing to keep in mind is that, once the placeholder
    is defined as a type, all the other placeholders assume that type. Therefore,
    any variable or constant defined with that placeholder must conform to that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing special about the capital `T`; we could use any valid identifier
    in place of `T`. We can also use descriptive names, such as key and value, as
    the Swift language does with dictionaries. The following definitions are perfectly
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In most documentation, generic placeholders are defined with either `T` (for
    type) or `E` (for element). We will, for the purposes of this chapter, use the
    capital `T` to define generic placeholders. It is also good practice to use the
    capital `T` to define a generic placeholder within our code so that the placeholder
    is easily recognized when we are looking at the code at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not like using the capital `T` or capital `E` to define generics,
    try to be consistent. I would recommend that you avoid the use of different identifiers
    to define generics throughout your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to use multiple generic types, we can create multiple placeholders
    by separating them with commas. The following example shows how to define multiple
    placeholders for a single function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are defining two generic placeholders, `T` and `E`. In this
    case, we can set the `T` placeholder to one type and the `E` placeholder to a
    different type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to call a generic function. The following code will swap
    two integers using the `swapGeneric<T>(inout a: T, inout b: T)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, the output will be `a: 10 b: 5`. We can see that we do
    not have to do anything special to call a generic function. The function infers
    the type from the first parameter and then sets all the remaining placeholders
    to that type. Now, if we need to swap the values of two strings, we will call
    the same function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the function is called in exactly the same way as we called
    it when we wanted to swap two integers. One thing that we cannot do is pass two
    different types into the swap function, because we defined only one generic placeholder.
    If we attempt to run the following code, we will receive an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The error that we will receive is that it cannot convert the value of type `String`
    to expected argument type `Int`, which tells us that we are attempting to use
    a `String` value when an `Int` value is expected. The reason the function is looking
    for an `Int` value is because the first parameter that we pass into the function
    is an `Int` value, and, therefore, all the generic types in the function become
    `Int` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say we have the following function, which has multiple generic
    types defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function would accept parameters of different types; however, since they
    are of different types, we would be unable to swap the values because they are
    different. There are also other limitations to generics. For example, we may think
    that the following generic function would be valid; however, we would receive
    an error if we tried to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We receive an error because the binary operator `==` cannot be applied to two
    `T` operands. Since the type of the arguments is unknown at the time the code
    is compiled, Swift does not know whether it can use the equal operator on the
    types, and, therefore, an error is thrown. We might think that this is a limit
    that will make generics hard to use. However, we have a way to tell Swift that
    we expect the type, represented by a placeholder, to have a certain functionality.
    This is done with type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type constraint specifies that a generic type must inherit from a specific
    class or conform to a particular protocol. This allows us to use the methods or
    properties defined by the parent class or protocol within the generic function.
    Let''s look at how to use type constraints by rewriting the `genericEqual` function
    to use the `Comparable` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To specify the type constraint, we put the class or protocol constraint after
    the generic placeholder, where the generic placeholder and the constraint are
    separated by a colon. This new function works as we might expect, and it will
    compare the values of the two parameters and return `true` if they are equal or
    `false` if they are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare multiple constraints just like we declare multiple generic types.
    The following example shows how to declare two generic types with different constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the type defined by the `T` placeholder must inherit from
    the `MyClass` class, and the type defined by the `E` placeholder must conform
    to the `MyProtocol` protocol. Now that we have looked at generic functions, let's
    look at generic types.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already had a general introduction to how generic types work when we looked
    at Swift arrays and dictionaries. A generic type is a class, structure, or enumeration
    that can work with any type, just like the way Swift arrays and dictionaries work.
    As we recall, Swift arrays and dictionaries are written so that they can contain
    any type. The catch is that we cannot mix and match different types within an
    array or dictionary. When we create an instance of our generic type, we define
    the type that the instance will work with. After we define that type, we cannot
    change the type for that instance.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to create a generic type, let's create a simple `List` class.
    This class will use a Swift array as the backend storage for the list, and will
    let us add items to the list or retrieve values from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by seeing how to define our generic `List` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines the generic `List` type. We can see that we use the
    `<T>` tag to define a generic placeholder, just like we did when we defined a
    generic function. This `T` placeholder can then be used anywhere within the type
    instead of a concrete type definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an instance of this type, we would need to define the type of items
    that our list will hold. The following example shows how to create instances of
    the generic `List` type for various types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates three instances of the `List` class. The `stringList`
    instance can be used with instances of the `String` type, the `intList` instance
    can be used with instances of the `integer` type, and the `customList` instance
    can be used with instances of the `MyObject` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not limited to using generics only with classes. We can also define
    structures and enumerations as generics. The following example shows how to define
    a generic structure and a generic enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the backend storage array to our `List` class. The items that
    are stored in this array need to be of the same type that we define when we initiate
    the class; therefore, we will use the `T` placeholder for the array''s definition.
    The following code shows the `List` class with an array named `items`. The `items`
    array will be defined using the `T` placeholder, so it will hold the same types
    that we defined for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code defines our generic `List` type and uses `T` as the type placeholder.
    We can then use this `T` placeholder anywhere in the class to define the type
    of an item. That item will then be of the same type that we defined when we created
    the instance of the `List` class. Therefore, if we create an instance of the `List`
    type, such as `var stringList = List<String>()`, the `items` array will be an
    array of string instances. If we created an instance of the `List` type, such
    as `var intList = List<Int>()`, the `items` array will be an array of integer
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to create the `add()` method, which will be used to add an item
    to the list. We will use the `T` placeholder within the method declaration to
    define that the `item` parameter will be of the same type that we declared when
    we initiated the class. Therefore, if we create an instance of the `List` type
    to use the `String` type, we will be required to use an instance of the `String`
    type as the parameter for the `add()` method. However, if we create an instance
    of the `List` type to use the `Int` type, we will be required to use an instance
    of the `Int` type as the parameter for the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `add()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To create a standalone generic function, we add the `<T>` declaration after
    the function name to declare that it is a generic function; however, when we use
    a generic method within a generic type, we do not need the `<T>` declaration.
    Instead, we just need to use the type that we defined in the class declaration.
    If we wanted to introduce another generic type, we could define it with the method
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the `getItemAtIndex()` method, which will return the item from
    the backend array, at the specified index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `getItemAtIndex()` method accepts one argument, which is the index of the
    item we want to retrieve. We then use the `T` placeholder to specify that our
    return type is an optional that might be of the `T` type or that might be nil.
    If the backend storage array contains an item at the specified index, we will
    return that item; otherwise, we return `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our entire generic `List` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we initially defined the generic `T` placeholder type in the
    class declaration. We then used this placeholder type within our class. In our
    `List` class, we used this placeholder in three places. We used it as the type
    for our `items` array, as the parameter type for our `add()` method, and as the
    optional return type in the `getItemAtIndex()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to use the `List` class. When we use a generic type,
    we define the type to be used within the class between angled brackets, such as
    `<type>`. The following code shows how to use the `List` class to store instances
    of the `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start off by creating an instance of the `List` type,
    called `list`, and specify that it will store instances of the `String` type.
    We then use the `add()` method twice to store two items in the `list` instance.
    Finally, we use the `getItemAtIndex()` method to retrieve the item at index number
    `1`, which will display `Optional(World)` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define our generic types with multiple placeholder types, similarly
    to how we use multiple placeholders in our generic methods. To use multiple placeholder
    types, we separate them with commas. The following example shows how to define
    multiple placeholder types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create an instance of the `MyClass` type that uses instances of the
    `String` and `Int` types, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use type constraints with generic types. Once again, using a type
    constraint for a generic type is exactly the same as using one with a generic
    function. The following code shows how to use a type constraint to ensure that
    the generic type conforms to the `Comparable` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So far in this chapter, we have seen how to use placeholder types with functions
    and types. Now let's see how we can conditionally add extensions to a generic
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally adding extensions with generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add extensions to a generic type conditionally if the type conforms
    to a protocol. For example, if we wanted to add a `sum()` method to our generic
    `List` type only if the type for `T` conforms to the numeric protocol, we could
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This extension adds the `sum()` method to any `list` instance where the `T`
    type conforms to the numeric protocol. This means that the `list` instance in
    the previous example, where the list was created to hold `String` instances, would
    not receive this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, where we create an instance of the `List` type that
    contains integers, the instance will receive `sum()` and can be used as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output of this would be `12`. We are also able to conditionally add functions
    inside a generic type or extension.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally adding functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditionally adding extensions, as we saw in the last section, works great;
    however, if we had separate functionality that we wished to add for different
    conditions, we would have to create separate extensions for each condition. Starting
    in Swift 5.3 with SE-0267, we are able to conditionally add functions to a generic
    type or extension. Let''s take a look at this by rewriting the extension in the
    previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, we moved the `where T: Numeric` clause out of the extensions
    declaration and into the function declaration. This will conditionally add the
    function if the type conforms to the `Numeric` protocol. Now we can add additional
    functions to the extension with different conditions as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we added an additional function named `sorted()` that
    will only be applied to instances where the type conforms to the `Comparable`
    protocol. This enables us to put functions with different conditions in the same
    extension or generic type rather than creating multiple extensions. I would definitely
    recommend conditionally adding functions, as shown in this section, over conditionally
    adding extensions, as shown in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at conditional conformance.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional conformance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditional conformance allows a generic type to conform to a protocol only
    if the type meets certain conditions. For example, if we wanted our `List` type
    to conform to the `Equatable` protocol only if the type stored in the list also
    conformed to the `Equatable` protocol, we could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code will add conformance to the `Equatable` protocol to any instance of
    the `List` type where the type that is stored in the list also conforms to the
    `Equatable` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a new function shown here that we have not talked about: the `zip()`
    function. This function will loop through two sequences, in our case arrays, simultaneously
    and create pairs (`e1` and `e2`) that we can compare.'
  prefs: []
  type: TYPE_NORMAL
- en: The comparison function will first check to see that each array contains the
    same number of elements and if not, it will return `false`. It then loops through
    each array, simultaneously comparing the elements of the arrays; if any of the
    pairs do not match, it will return `false`. If the previous tests pass, `true`
    is returned, which indicates that the `list` instances are equal because the elements
    in the list are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we can add generic subscripts to a non-generic type.
  prefs: []
  type: TYPE_NORMAL
- en: Generic subscripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Swift 4, if we wanted to use generics with a subscript, we had to
    define the subscript at the class or structure level. This forced us to make generic
    methods when it felt like we should be using subscripts. Starting with Swift 4,
    we can create generic subscripts, where either the subscript''s return type or
    its parameters may be generic. Let''s look at how we can create a generic subscript.
    In this first example, we will create a subscript that will accept one generic
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we create a generic subscript, we define the placeholder type after the
    `subscript` keyword. In the previous example, we define the `T` placeholder type
    and use a type constraint to ensure that the type conforms to the `Hashable` protocol.
    This will allow us to pass in an instance of any type that conforms to the `Hashable`
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned at the start of this section, we can also use generics for
    the return type of a subscript. We define the generic placeholder for the return
    type exactly as we did for the generic parameter. The following example illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define the `T` placeholder type after the `subscript` keyword,
    as we did in the previous example. We then use this type as our return type for
    the `subscript`.
  prefs: []
  type: TYPE_NORMAL
- en: Associated types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An associated type declares a placeholder name that can be used instead of a
    type within a protocol. The actual type to be used is not specified until the
    protocol is adopted. When creating generic functions and types, we used a very
    similar syntax, as we have seen throughout this chapter. Defining associated types
    for a protocol, however, is very different. We specify an associated type using
    the `associatedtype` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use associated types when we define a protocol. In this example,
    we will define the `QueueProtocol` protocol, which defines the capabilities that
    need to be implemented by the queue that implements it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this protocol, we defined one associated type, named `QueueType`. We then
    used this associated type twice within the protocol: once as the parameter type
    for the `add()` method and once when we defined the return type of the `getItem()`
    method as an optional type that might return an associated type of `QueueType`
    or `nil`.'
  prefs: []
  type: TYPE_NORMAL
- en: Any type that implements the `QueueProtocol` protocol must be able to specify
    the type to use for the `QueueType` placeholder, and must also ensure that only
    items of that type are used where the protocol uses the `QueueType` placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to implement `QueueProtocol` in a non-generic class called
    `IntQueue`. This class will implement the `QueueProtocol` protocol using the `Integer`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `IntQueue` class, we begin by defining our backend storage mechanism
    as an array of integer types. We then implement each of the methods defined in
    the `QueueProtocol` protocol, replacing the `QueueType` placeholder defined in
    the protocol with the `Int` type. In the `add()` method, the `parameter` type
    is defined as an instance of `Int` type, and in the `getItem()` method, the `return`
    type is defined as an optional that might return an instance of `Int` type or
    `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `IntQueue` class as we would use any other class. The following
    code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating an instance of the `IntQueue` class, named `intQ`. We then
    call the `add()` method twice to add two values of the integer type to the `intQ`
    instance. We then retrieve the first item in the `intQ` instance by calling the
    `getItem()` method. This line will print the number `2` to the console. The final
    line of code adds another instance of the integer type to the `intQ` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we implemented the `QueueProtocol` protocol in a
    non-generic way. This means that we replaced the placeholder types with an actual
    type. `QueueType` was replaced by the `Int` type. We can also implement `QueueProtocol`
    with a generic type. Let''s see how we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `GenericQueue` implementation is very similar to the `IntQueue`
    implementation, except that we define the type to use as the generic placeholder
    `T`. We can then use the `GenericQueue` class as we would use any generic class.
    Let''s look at how to use the `GenericQueue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating an instance of the `GenericQueue` class that will use the
    `Int` type and name it `intQ2`. Next, we call the `add()` method twice to add
    two instances of the integer type to the `intQ2` instance. We then retrieve the
    first item in the queue that was added using the `getItem()` method and print
    the value to the console. This line will print the number `2` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use type constraints with associated types. When the protocol is
    adopted, the type defined for the associated type must inherit from the class
    or conform to the protocol defined by the type constraint. The following line
    defines an associated type with a type constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we specify that when the protocol is implemented, the type
    defined for the associated type must conform to the `Hashable` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic types can be incredibly useful, and they are also the basis of the Swift
    standard collection types (arrays and dictionaries); however, as mentioned in
    the introduction to this chapter, we have to be careful to use them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We saw a couple of examples in this chapter that show how generics can make
    our lives easier. The `swapGeneric()` function that was shown at the beginning
    of the chapter is a good use of a generic function because it allows us to swap
    two values of any type we choose, while only implementing the swap code once.
  prefs: []
  type: TYPE_NORMAL
- en: The generic `List` type is also a good example of how to make custom collection
    types that can be used to hold any type. The way that we implemented the generic
    `List` type in this chapter is similar to how Swift implements an array and dictionary
    with generics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at error handling with Swift and how we can
    make a feature available only if the device that the user is using has a certain
    version of the OS.
  prefs: []
  type: TYPE_NORMAL
