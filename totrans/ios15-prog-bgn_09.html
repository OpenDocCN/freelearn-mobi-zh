<html><head></head><body>
		<div id="_idContainer066">
			<h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor123"/>Chapter 8</em>: Protocols, Extensions, and Error Handling</h1>
			<p>In the previous chapter, you've learned how to represent complex objects using classes or structures and how to use enumerations to group related values together.</p>
			<p>To end the section on Swift, you'll learn about <strong class="bold">protocols</strong>, <strong class="bold">extensions</strong>, and <strong class="bold">error handling</strong>. Protocols define a blueprint of methods, properties, and other requirements that can be adopted by a class, structure, or enumeration. Extensions enable you to provide new functionality for an existing class, structure, or enumeration. Error handling covers how to respond to and recover from errors in your program.</p>
			<p>By the end of this chapter, you'll be able to write your own protocols to meet the requirements of your apps, use extensions to add new capabilities to existing types, and handle error conditions in your apps without crashing.</p>
			<p>The following topics will be covered in this chapter: </p>
			<ul>
				<li>Understanding protocols</li>
				<li>Understanding extensions</li>
				<li>Exploring error handling</li>
			</ul>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor124"/>Technical requirements </h1>
			<p>The Xcode playground for this chapter is in the <strong class="source-inline">Chapter08</strong> folder of the code bundle for this book, which can be downloaded here:</p>
			<p><a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a></p>
			<p>Check out the following video to see the code in action:</p>
			<p><a href="https://bit.ly/3H1XWkQ">https://bit.ly/3H1XWkQ</a></p>
			<p>If you wish to start from scratch, create a new playground and name it <strong class="source-inline">Protocols, ExtensionsAndErrorHandling</strong>. You can type in and run all of the code in this chapter as you go along. Let's start with protocols, which is a way of specifying properties and methods that a class, structure or enumeration should have.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor125"/>Understanding protocols</h1>
			<p>Protocols <a id="_idIndexMarker246"/>are like blueprints that determine what properties or methods an object should have. After you've declared a protocol, classes, structures, and enumerations can adopt this protocol, and provide their own implementation for the required properties and methods.</p>
			<p>Here's what a protocol declaration looks like:</p>
			<p class="source-code">protocol ProtocolName {</p>
			<p class="source-code">   var readWriteProperty1 {get set}</p>
			<p class="source-code">   var readOnlyProperty2 {get}</p>
			<p class="source-code">   methodName1()</p>
			<p class="source-code">   methodName2()</p>
			<p class="source-code">}</p>
			<p>Just like classes and structures, protocol names start with an uppercase letter.  Properties need to be declared using the <strong class="source-inline">var</strong> keyword. You use <strong class="source-inline">{get set}</strong> if you want a property that can be read from or written to, and <strong class="source-inline">{get}</strong> if you want a read-only property. Note that you just specify property and method names. The implementation is done within the adopting class, structure, or enumeration.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">For more<a id="_idIndexMarker247"/> information on protocols, visit: <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">https://docs.swift.org/swift-book/LanguageGuide/Protocols.html</a>.</p>
			<p>To help you understand protocols, imagine an app used by a fast-food restaurant. The management has decided to show calorie counts for the meals being served. The app currently has the following class, structure, and enumeration, and none of them have calorie counts implemented:</p>
			<ul>
				<li>A <strong class="source-inline">Burger</strong> class</li>
				<li>A <strong class="source-inline">Fries</strong> structure</li>
				<li>A <strong class="source-inline">Sauce</strong> enumeration</li>
			</ul>
			<p>Add the<a id="_idIndexMarker248"/> following code to your playground to declare the <strong class="source-inline">Burger</strong> class, the <strong class="source-inline">Fries </strong>structure, and the <strong class="source-inline">Sauce</strong> enumeration:</p>
			<p class="source-code">class Burger {</p>
			<p class="source-code">}</p>
			<p class="source-code">struct Fries {</p>
			<p class="source-code">}</p>
			<p class="source-code">enum Sauce { </p>
			<p class="source-code">   case chili </p>
			<p class="source-code">   case tomato</p>
			<p class="source-code">}</p>
			<p>These represent the existing class, structure, and enumeration in the app. Don't worry about the empty definitions, as they are not required for this lesson. As you can see, none of them have calorie counts at present. Let's look at how to work with protocols to specify the properties and methods needed to implement calorie counts. You'll start by declaring a protocol that specifies the required properties and methods in the next section.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor126"/>Creating a protocol declaration</h2>
			<p>Let's create a <a id="_idIndexMarker249"/>protocol that specifies a required property, <strong class="source-inline">calories</strong>, and a method, <strong class="source-inline">description()</strong>. Type the following into your playground above the class, structure, and enumeration declarations:</p>
			<p class="source-code">protocol CalorieCount {</p>
			<p class="source-code">   var calories: Int { get }</p>
			<p class="source-code">   func description() -&gt; String</p>
			<p class="source-code">}</p>
			<p>This protocol is named <strong class="source-inline">CalorieCount</strong>. It specifies that any object that adopts it must have a property, <strong class="source-inline">calories</strong>, that holds the calorie count, and a method, <strong class="source-inline">description()</strong>, that returns a string. <strong class="source-inline">{ get }</strong> means that you only need to be able to read the value stored in <strong class="source-inline">calories</strong>, and you don't have to write to it. Note that the definition<a id="_idIndexMarker250"/> of the <strong class="source-inline">description()</strong> method is not specified as that will be done in the class, structure, or enumeration. All you need to do to adopt a protocol is type a colon after the class name followed by the protocol name, and implement the required properties and methods.</p>
			<p>To make the <strong class="source-inline">Burger</strong> class conform to this protocol, modify your code as follows:</p>
			<p class="source-code">class Burger<strong class="bold">: CalorieCount</strong> {</p>
			<p class="source-code"><strong class="bold">   let calories = 800</strong></p>
			<p class="source-code"><strong class="bold">   func description() -&gt; String {</strong></p>
			<p class="source-code"><strong class="bold">      return "This burger has \(calories) calories"</strong></p>
			<p class="source-code"><strong class="bold">   }</strong></p>
			<p class="source-code">}</p>
			<p>As you can see, the <strong class="source-inline">calories</strong> property and the <strong class="source-inline">description()</strong> method have been added to the <strong class="source-inline">Burger</strong> class. Even though the protocol specifies a variable, you can use a constant here because the protocol only requires that you can get the value for <strong class="source-inline">calories</strong>, and not set it.</p>
			<p>Let's make the <strong class="source-inline">Fries</strong> structure adopt this protocol as well. Modify your code for the <strong class="source-inline">Fries</strong> structure as follows:</p>
			<p class="source-code">struct Fries<strong class="bold">: CalorieCount</strong> {</p>
			<p class="source-code"><strong class="bold">   let calories = 500</strong></p>
			<p class="source-code"><strong class="bold">   func description() -&gt; String {</strong></p>
			<p class="source-code"><strong class="bold">      return "These fries have \(calories) calories"</strong></p>
			<p class="source-code"><strong class="bold">   }</strong></p>
			<p class="source-code">}</p>
			<p>The same process that was used for the <strong class="source-inline">Burger</strong> class is used for the <strong class="source-inline">Fries</strong> structure, and it now conforms to the <strong class="source-inline">CalorieCount</strong> protocol as well.</p>
			<p>You could modify the <strong class="source-inline">Sauce</strong> enumeration in the same way, but let's do it using extensions instead. Extensions <a id="_idIndexMarker251"/>extend an existing class's capabilities. You'll add the <strong class="source-inline">CalorieCount</strong> protocol to the <strong class="source-inline">Sauce</strong> enumeration using an extension in the next section.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor127"/>Understanding extensions </h1>
			<p>Extensions allow <a id="_idIndexMarker252"/>you to provide extra capabilities to an object without modifying the original object definition. You can use them on Apple-provided objects (where you don't have access to the object definition) or when you wish to segregate your code for readability and ease of maintenance. Here's what an extension looks like:</p>
			<p class="source-code">class ExistingType {</p>
			<p class="source-code">   property1</p>
			<p class="source-code">   method1()</p>
			<p class="source-code">}</p>
			<p class="source-code">extension ExistingType : ProtocolName {</p>
			<p class="source-code">   property2</p>
			<p class="source-code">   method2()</p>
			<p class="source-code">}</p>
			<p>Here, an extension is used to provide an additional property and method to an existing class.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">For more<a id="_idIndexMarker253"/> information on extensions, visit <a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html">https://docs.swift.org/swift-book/LanguageGuide/Extensions.html</a>.</p>
			<p>Let's look at how <a id="_idIndexMarker254"/>to use extensions. You'll start by making the <strong class="source-inline">Sauce</strong> enumeration conform to the <strong class="source-inline">CalorieCount</strong> protocol using an extension in the next section.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor128"/>Adopting a protocol via an extension</h2>
			<p>At present, the <strong class="source-inline">Sauce</strong> enumeration does not conform to the <strong class="source-inline">CalorieCount</strong> protocol. You'll use <a id="_idIndexMarker255"/>an extension to add the properties and methods required to make it conform. Type in the<a id="_idIndexMarker256"/> following code after the declaration for the <strong class="source-inline">Sauce</strong> enumeration:</p>
			<p class="source-code">enum Sauce {</p>
			<p class="source-code">   case chili </p>
			<p class="source-code">   case tomato</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">extension Sauce: CalorieCount {</strong></p>
			<p class="source-code"><strong class="bold">   var calories: Int {</strong></p>
			<p class="source-code"><strong class="bold">      switch self {</strong></p>
			<p class="source-code"><strong class="bold">      case .chili:</strong></p>
			<p class="source-code"><strong class="bold">         return 20 </strong></p>
			<p class="source-code"><strong class="bold">      case .tomato: </strong></p>
			<p class="source-code"><strong class="bold">         return 15</strong></p>
			<p class="source-code"><strong class="bold">      }</strong></p>
			<p class="source-code"><strong class="bold">   }</strong></p>
			<p class="source-code"><strong class="bold">   func description() -&gt; String {</strong></p>
			<p class="source-code"><strong class="bold">      return "This sauce has \(calories) calories"</strong></p>
			<p class="source-code"><strong class="bold">   }</strong></p>
			<p class="source-code"><strong class="bold">} </strong></p>
			<p>As you can see, no changes were made to the original definition for the <strong class="source-inline">Sauce</strong> enumeration. This is also really useful if you want to extend the capabilities of existing Swift standard types, such as <strong class="source-inline">String</strong> and <strong class="source-inline">Int</strong>.</p>
			<p>Enumerations can't have stored properties, so a <strong class="source-inline">switch</strong> statement is used to return the number of calories based on the enumeration's value, using the <strong class="source-inline">self</strong> keyword. The <strong class="source-inline">description()</strong> method<a id="_idIndexMarker257"/> is the same as the one in the <strong class="source-inline">Burger</strong> class and the <strong class="source-inline">Fries</strong> structure.</p>
			<p>At this point, all<a id="_idIndexMarker258"/> three objects have a <strong class="source-inline">calories</strong> property and a <strong class="source-inline">description()</strong> method. Great!</p>
			<p>Let's see how you can put them in an array and perform an operation to get the total calorie count for a meal.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor129"/>Creating an array of different types of objects</h2>
			<p>Ordinarily, an array's elements <a id="_idIndexMarker259"/>must be of the same type. However, since the <strong class="source-inline">Burger</strong> class, the <strong class="source-inline">Fries</strong> structure, and the <strong class="source-inline">Sauce</strong> enumeration all conform to the <strong class="source-inline">CalorieCount</strong> protocol, you can make an array that contains elements conforming to this protocol. Follow these steps:</p>
			<ol>
				<li>To add instances of the <strong class="source-inline">Burger</strong> class, the <strong class="source-inline">Fries</strong> structure and the <strong class="source-inline">Sauce </strong>enumeration to an array, type in the following code after all the protocol and object declarations:<p class="source-code">let burger = Burger()</p><p class="source-code">let fries = Fries()</p><p class="source-code">let sauce = Sauce.tomato</p><p class="source-code">let foodArray: [CalorieCount] = [burger, fries, sauce]</p></li>
				<li>To get the total calorie count, add the following code after the line where you created the <strong class="source-inline">foodArray</strong> constant:<p class="source-code">var totalCalories = 0</p><p class="source-code">for food in foodArray {</p><p class="source-code">   totalCalories += food.calories</p><p class="source-code">}</p><p class="source-code">print(totalCalories)</p><p>The <strong class="source-inline">for</strong> loop iterates through each element in the <strong class="source-inline">foodArray</strong> array. For each iteration, the value in the <strong class="source-inline">calories</strong> property for each food item will be added to <strong class="source-inline">totalCalories</strong>, and<a id="_idIndexMarker260"/> the total amount, <strong class="source-inline">1315</strong>, will be displayed in the Debug area.</p></li>
			</ol>
			<p>You have learned how to create a protocol and make a class, structure or enumeration conform to it, either within the class definition or via extensions. Let's look at error handling next, which looks at how to respond to or recover from errors in your program.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Exploring error handling</h1>
			<p>When you <a id="_idIndexMarker261"/>write apps, bear in mind that error conditions may happen, and error handling is how your app would respond to and recover from such conditions.</p>
			<p>First, you create a type that conforms to Swift's <strong class="source-inline">Error</strong> protocol, which lets this type be used for error handling. Enumerations are normally used, as you can specify associated values for different kinds of errors. When something unexpected happens, you can stop program execution by throwing an error. You use the <strong class="source-inline">throw</strong> statement for this, and provide an instance of the type conforming to the <strong class="source-inline">Error</strong> protocol with the appropriate value. This allows you to see what went wrong.</p>
			<p>Of course, it would be better if you can respond to an error without stopping your program. For this, you can use a <strong class="source-inline">do-catch</strong> block, which looks like this:</p>
			<p class="source-code">do {</p>
			<p class="source-code">   try expression1</p>
			<p class="source-code">   statement1</p>
			<p class="source-code">} catch {</p>
			<p class="source-code">   statement2</p>
			<p class="source-code">}</p>
			<p>Here, you attempt to execute code in the <strong class="source-inline">do</strong> block using the <strong class="source-inline">try</strong> keyword. If an error is thrown, the statements in the <strong class="source-inline">catch</strong> block are executed. You can have multiple <strong class="source-inline">catch</strong> blocks to handle different error types.</p>
			<p class="callout-heading">Important Information:</p>
			<p class="callout">For more<a id="_idIndexMarker262"/> information on error handling, visit <a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html">https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html</a>.</p>
			<p>As an example, let's <a id="_idIndexMarker263"/>say you have an app that needs to access a web page. However, if the server where that web page is located is down, it is up to you to write the code to handle the error, such as trying an alternative web server or informing the user that the server is down.</p>
			<p>Let's create an enumeration that conforms to the <strong class="source-inline">Error</strong> protocol, use a <strong class="source-inline">throw</strong> statement to stop program execution when an error occurs, and use a <strong class="source-inline">do-catch</strong> block to handle an error. Follow these steps:</p>
			<ol>
				<li value="1">Type the following code into your playground:<p class="source-code">enum WebsiteError: Error {</p><p class="source-code">   case noInternetConnection</p><p class="source-code">   case siteDown</p><p class="source-code">   case wrongURL</p><p class="source-code">}</p><p>This declares an enumeration, <strong class="source-inline">WebsiteError</strong>, that adopts the <strong class="source-inline">Error</strong> protocol. It covers three possible error conditions; there is no internet connection, the website is down, or the URL could not be resolved.</p></li>
				<li>Type in the following code to declare a function that checks if a website is up after the <strong class="source-inline">WebpageError</strong> declaration:<p class="source-code">func checkWebsite(siteUp: Bool) throws -&gt; String {</p><p class="source-code">   if siteUp == false {</p><p class="source-code">     throw WebsiteError.siteDown</p><p class="source-code">   }</p><p class="source-code">   return "Site is up"</p><p class="source-code">}</p><p>If <strong class="source-inline">siteUp</strong> is <strong class="source-inline">true</strong>, <strong class="source-inline">"Site is up"</strong> is returned. If <strong class="source-inline">siteUp</strong> is <strong class="source-inline">false</strong>, the program will stop executing and throw an error.</p></li>
				<li>Type in<a id="_idIndexMarker264"/> the following code after the function declaration to call your function, and run your program:<p class="source-code">let siteStatus = true</p><p class="source-code">try checkWebsite(siteUp: siteStatus)</p><p>Since <strong class="source-inline">siteStatus</strong> is <strong class="source-inline">true</strong>, <strong class="source-inline">Site is up</strong> will appear in the Results area.</p></li>
				<li>Change the value of <strong class="source-inline">siteStatus</strong> to <strong class="source-inline">false</strong> and run your program. Your program crashes and the following error message is displayed in the Debug area:<p class="source-code">Playground execution terminated: An error was thrown and was not caught:</p><p class="source-code">__lldb_expr_5.WebsiteError.siteDown</p></li>
				<li>Of course, it is always better if you can handle errors without making your program crash. You can do this by using a <strong class="source-inline">do-catch</strong> block. Modify your code as shown and run it:<p class="source-code">let siteStatus = false</p><p class="source-code"><strong class="bold">do {</strong></p><p class="source-code"><strong class="bold">   print(</strong>try checkWebsite(siteUp: siteStatus)<strong class="bold">)</strong></p><p class="source-code"><strong class="bold">} catch {</strong></p><p class="source-code"><strong class="bold">   print(error)</strong></p><p class="source-code"><strong class="bold">}</strong></p><p>The <strong class="source-inline">do</strong> block tries to execute the <strong class="source-inline">checkWebsite(siteUp:)</strong> function and prints the status if successful. If there is an error, instead of crashing, the statements in the <strong class="source-inline">catch</strong> block are executed, and the error message <strong class="source-inline">siteDown</strong> appears in the Debug area.</p><p class="callout-heading">Tip</p><p class="callout">You can make your<a id="_idIndexMarker265"/> program handle different error conditions by implementing multiple <strong class="source-inline">catch</strong> blocks. See this link for details: <a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html">https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html</a>.</p></li>
			</ol>
			<p>You have learned <a id="_idIndexMarker266"/>how to handle errors in your app without making it crash. Give yourself a pat on the back; you have completed the first part of this book!</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor131"/>Summary</h1>
			<p>In this chapter, you learned how to write protocols and how to make classes, structures, and enumerations conform to them. You also learned how to extend the capabilities of a class by using an extension. Finally, you learned how to handle errors using the <strong class="source-inline">do-catch</strong> block.</p>
			<p>It may seem rather abstract and hard to understand now, but as you will see in <em class="italic">Part 3</em> of this book, you will use protocols to implement common functionalities in different parts of your program instead of writing the same program over and over. You will see how useful extensions are in organizing your code, which makes it easy to maintain. Last but not least, you'll see how good error handling makes it easy to pinpoint the mistakes you made while coding your app.</p>
			<p>In the next chapter, you will start writing your first iOS application by creating the screens for it using storyboards, which allow you to rapidly prototype an application without having to type a lot of code.</p>
		</div>
	</body></html>