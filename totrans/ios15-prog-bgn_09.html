<html><head></head><body>
		<div><h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor123"/>Chapter 8</em>: Protocols, Extensions, and Error Handling</h1>
			<p>In the previous chapter, you've learned how to represent complex objects using classes or structures and how to use enumerations to group related values together.</p>
			<p>To end the section on Swift, you'll learn about <strong class="bold">protocols</strong>, <strong class="bold">extensions</strong>, and <strong class="bold">error handling</strong>. Protocols define a blueprint of methods, properties, and other requirements that can be adopted by a class, structure, or enumeration. Extensions enable you to provide new functionality for an existing class, structure, or enumeration. Error handling covers how to respond to and recover from errors in your program.</p>
			<p>By the end of this chapter, you'll be able to write your own protocols to meet the requirements of your apps, use extensions to add new capabilities to existing types, and handle error conditions in your apps without crashing.</p>
			<p>The following topics will be covered in this chapter: </p>
			<ul>
				<li>Understanding protocols</li>
				<li>Understanding extensions</li>
				<li>Exploring error handling</li>
			</ul>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor124"/>Technical requirements </h1>
			<p>The Xcode playground for this chapter is in the <code>Chapter08</code> folder of the code bundle for this book, which can be downloaded here:</p>
			<p><a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a></p>
			<p>Check out the following video to see the code in action:</p>
			<p><a href="https://bit.ly/3H1XWkQ">https://bit.ly/3H1XWkQ</a></p>
			<p>If you wish to start from scratch, create a new playground and name it <code>Protocols, ExtensionsAndErrorHandling</code>. You can type in and run all of the code in this chapter as you go along. Let's start with protocols, which is a way of specifying properties and methods that a class, structure or enumeration should have.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor125"/>Understanding protocols</h1>
			<p>Protocols <a id="_idIndexMarker246"/>are like blueprints that determine what properties or methods an object should have. After you've declared a protocol, classes, structures, and enumerations can adopt this protocol, and provide their own implementation for the required properties and methods.</p>
			<p>Here's what a protocol declaration looks like:</p>
			<pre>protocol ProtocolName {
   var readWriteProperty1 {get set}
   var readOnlyProperty2 {get}
   methodName1()
   methodName2()
}</pre>
			<p>Just like classes and structures, protocol names start with an uppercase letter.  Properties need to be declared using the <code>var</code> keyword. You use <code>{get set}</code> if you want a property that can be read from or written to, and <code>{get}</code> if you want a read-only property. Note that you just specify property and method names. The implementation is done within the adopting class, structure, or enumeration.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">For more<a id="_idIndexMarker247"/> information on protocols, visit: <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">https://docs.swift.org/swift-book/LanguageGuide/Protocols.html</a>.</p>
			<p>To help you understand protocols, imagine an app used by a fast-food restaurant. The management has decided to show calorie counts for the meals being served. The app currently has the following class, structure, and enumeration, and none of them have calorie counts implemented:</p>
			<ul>
				<li>A <code>Burger</code> class</li>
				<li>A <code>Fries</code> structure</li>
				<li>A <code>Sauce</code> enumeration</li>
			</ul>
			<p>Add the<a id="_idIndexMarker248"/> following code to your playground to declare the <code>Burger</code> class, the <code>Fries </code>structure, and the <code>Sauce</code> enumeration:</p>
			<pre>class Burger {
}
struct Fries {
}
enum Sauce { 
   case chili 
   case tomato
}</pre>
			<p>These represent the existing class, structure, and enumeration in the app. Don't worry about the empty definitions, as they are not required for this lesson. As you can see, none of them have calorie counts at present. Let's look at how to work with protocols to specify the properties and methods needed to implement calorie counts. You'll start by declaring a protocol that specifies the required properties and methods in the next section.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor126"/>Creating a protocol declaration</h2>
			<p>Let's create a <a id="_idIndexMarker249"/>protocol that specifies a required property, <code>calories</code>, and a method, <code>description()</code>. Type the following into your playground above the class, structure, and enumeration declarations:</p>
			<pre>protocol CalorieCount {
   var calories: Int { get }
   func description() -&gt; String
}</pre>
			<p>This protocol is named <code>CalorieCount</code>. It specifies that any object that adopts it must have a property, <code>calories</code>, that holds the calorie count, and a method, <code>description()</code>, that returns a string. <code>{ get }</code> means that you only need to be able to read the value stored in <code>calories</code>, and you don't have to write to it. Note that the definition<a id="_idIndexMarker250"/> of the <code>description()</code> method is not specified as that will be done in the class, structure, or enumeration. All you need to do to adopt a protocol is type a colon after the class name followed by the protocol name, and implement the required properties and methods.</p>
			<p>To make the <code>Burger</code> class conform to this protocol, modify your code as follows:</p>
			<pre>class Burger<strong class="bold">: CalorieCount</strong> {
<strong class="bold">   let calories = 800</strong>
<strong class="bold">   func description() -&gt; String {</strong>
<strong class="bold">      return "This burger has \(calories) calories"</strong>
<strong class="bold">   }</strong>
}</pre>
			<p>As you can see, the <code>calories</code> property and the <code>description()</code> method have been added to the <code>Burger</code> class. Even though the protocol specifies a variable, you can use a constant here because the protocol only requires that you can get the value for <code>calories</code>, and not set it.</p>
			<p>Let's make the <code>Fries</code> structure adopt this protocol as well. Modify your code for the <code>Fries</code> structure as follows:</p>
			<pre>struct Fries<strong class="bold">: CalorieCount</strong> {
<strong class="bold">   let calories = 500</strong>
<strong class="bold">   func description() -&gt; String {</strong>
<strong class="bold">      return "These fries have \(calories) calories"</strong>
<strong class="bold">   }</strong>
}</pre>
			<p>The same process that was used for the <code>Burger</code> class is used for the <code>Fries</code> structure, and it now conforms to the <code>CalorieCount</code> protocol as well.</p>
			<p>You could modify the <code>Sauce</code> enumeration in the same way, but let's do it using extensions instead. Extensions <a id="_idIndexMarker251"/>extend an existing class's capabilities. You'll add the <code>CalorieCount</code> protocol to the <code>Sauce</code> enumeration using an extension in the next section.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor127"/>Understanding extensions </h1>
			<p>Extensions allow <a id="_idIndexMarker252"/>you to provide extra capabilities to an object without modifying the original object definition. You can use them on Apple-provided objects (where you don't have access to the object definition) or when you wish to segregate your code for readability and ease of maintenance. Here's what an extension looks like:</p>
			<pre>class ExistingType {
   property1
   method1()
}
extension ExistingType : ProtocolName {
   property2
   method2()
}</pre>
			<p>Here, an extension is used to provide an additional property and method to an existing class.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">For more<a id="_idIndexMarker253"/> information on extensions, visit <a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html">https://docs.swift.org/swift-book/LanguageGuide/Extensions.html</a>.</p>
			<p>Let's look at how <a id="_idIndexMarker254"/>to use extensions. You'll start by making the <code>Sauce</code> enumeration conform to the <code>CalorieCount</code> protocol using an extension in the next section.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor128"/>Adopting a protocol via an extension</h2>
			<p>At present, the <code>Sauce</code> enumeration does not conform to the <code>CalorieCount</code> protocol. You'll use <a id="_idIndexMarker255"/>an extension to add the properties and methods required to make it conform. Type in the<a id="_idIndexMarker256"/> following code after the declaration for the <code>Sauce</code> enumeration:</p>
			<pre>enum Sauce {
   case chili 
   case tomato
}
<strong class="bold">extension Sauce: CalorieCount {</strong>
<strong class="bold">   var calories: Int {</strong>
<strong class="bold">      switch self {</strong>
<strong class="bold">      case .chili:</strong>
<strong class="bold">         return 20 </strong>
<strong class="bold">      case .tomato: </strong>
<strong class="bold">         return 15</strong>
<strong class="bold">      }</strong>
<strong class="bold">   }</strong>
<strong class="bold">   func description() -&gt; String {</strong>
<strong class="bold">      return "This sauce has \(calories) calories"</strong>
<strong class="bold">   }</strong>
<strong class="bold">} </strong></pre>
			<p>As you can see, no changes were made to the original definition for the <code>Sauce</code> enumeration. This is also really useful if you want to extend the capabilities of existing Swift standard types, such as <code>String</code> and <code>Int</code>.</p>
			<p>Enumerations can't have stored properties, so a <code>switch</code> statement is used to return the number of calories based on the enumeration's value, using the <code>self</code> keyword. The <code>description()</code> method<a id="_idIndexMarker257"/> is the same as the one in the <code>Burger</code> class and the <code>Fries</code> structure.</p>
			<p>At this point, all<a id="_idIndexMarker258"/> three objects have a <code>calories</code> property and a <code>description()</code> method. Great!</p>
			<p>Let's see how you can put them in an array and perform an operation to get the total calorie count for a meal.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor129"/>Creating an array of different types of objects</h2>
			<p>Ordinarily, an array's elements <a id="_idIndexMarker259"/>must be of the same type. However, since the <code>Burger</code> class, the <code>Fries</code> structure, and the <code>Sauce</code> enumeration all conform to the <code>CalorieCount</code> protocol, you can make an array that contains elements conforming to this protocol. Follow these steps:</p>
			<ol>
				<li>To add instances of the <code>Burger</code> class, the <code>Fries</code> structure and the <code>Sauce </code>enumeration to an array, type in the following code after all the protocol and object declarations:<pre>let burger = Burger()
let fries = Fries()
let sauce = Sauce.tomato
let foodArray: [CalorieCount] = [burger, fries, sauce]</pre></li>
				<li>To get the total calorie count, add the following code after the line where you created the <code>foodArray</code> constant:<pre>var totalCalories = 0
for food in foodArray {
   totalCalories += food.calories
}
print(totalCalories)</pre><p>The <code>for</code> loop iterates through each element in the <code>foodArray</code> array. For each iteration, the value in the <code>calories</code> property for each food item will be added to <code>totalCalories</code>, and<a id="_idIndexMarker260"/> the total amount, <code>1315</code>, will be displayed in the Debug area.</p></li>
			</ol>
			<p>You have learned how to create a protocol and make a class, structure or enumeration conform to it, either within the class definition or via extensions. Let's look at error handling next, which looks at how to respond to or recover from errors in your program.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Exploring error handling</h1>
			<p>When you <a id="_idIndexMarker261"/>write apps, bear in mind that error conditions may happen, and error handling is how your app would respond to and recover from such conditions.</p>
			<p>First, you create a type that conforms to Swift's <code>Error</code> protocol, which lets this type be used for error handling. Enumerations are normally used, as you can specify associated values for different kinds of errors. When something unexpected happens, you can stop program execution by throwing an error. You use the <code>throw</code> statement for this, and provide an instance of the type conforming to the <code>Error</code> protocol with the appropriate value. This allows you to see what went wrong.</p>
			<p>Of course, it would be better if you can respond to an error without stopping your program. For this, you can use a <code>do-catch</code> block, which looks like this:</p>
			<pre>do {
   try expression1
   statement1
} catch {
   statement2
}</pre>
			<p>Here, you attempt to execute code in the <code>do</code> block using the <code>try</code> keyword. If an error is thrown, the statements in the <code>catch</code> block are executed. You can have multiple <code>catch</code> blocks to handle different error types.</p>
			<p class="callout-heading">Important Information:</p>
			<p class="callout">For more<a id="_idIndexMarker262"/> information on error handling, visit <a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html">https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html</a>.</p>
			<p>As an example, let's <a id="_idIndexMarker263"/>say you have an app that needs to access a web page. However, if the server where that web page is located is down, it is up to you to write the code to handle the error, such as trying an alternative web server or informing the user that the server is down.</p>
			<p>Let's create an enumeration that conforms to the <code>Error</code> protocol, use a <code>throw</code> statement to stop program execution when an error occurs, and use a <code>do-catch</code> block to handle an error. Follow these steps:</p>
			<ol>
				<li value="1">Type the following code into your playground:<pre>enum WebsiteError: Error {
   case noInternetConnection
   case siteDown
   case wrongURL
}</pre><p>This declares an enumeration, <code>WebsiteError</code>, that adopts the <code>Error</code> protocol. It covers three possible error conditions; there is no internet connection, the website is down, or the URL could not be resolved.</p></li>
				<li>Type in the following code to declare a function that checks if a website is up after the <code>WebpageError</code> declaration:<pre>func checkWebsite(siteUp: Bool) throws -&gt; String {
   if siteUp == false {
     throw WebsiteError.siteDown
   }
   return "Site is up"
}</pre><p>If <code>siteUp</code> is <code>true</code>, <code>"Site is up"</code> is returned. If <code>siteUp</code> is <code>false</code>, the program will stop executing and throw an error.</p></li>
				<li>Type in<a id="_idIndexMarker264"/> the following code after the function declaration to call your function, and run your program:<pre>let siteStatus = true
try checkWebsite(siteUp: siteStatus)</pre><p>Since <code>siteStatus</code> is <code>true</code>, <code>Site is up</code> will appear in the Results area.</p></li>
				<li>Change the value of <code>siteStatus</code> to <code>false</code> and run your program. Your program crashes and the following error message is displayed in the Debug area:<pre>Playground execution terminated: An error was thrown and was not caught:
__lldb_expr_5.WebsiteError.siteDown</pre></li>
				<li>Of course, it is always better if you can handle errors without making your program crash. You can do this by using a <code>do-catch</code> block. Modify your code as shown and run it:<pre>let siteStatus = false
<code>do</code> block tries to execute the <code>checkWebsite(siteUp:)</code> function and prints the status if successful. If there is an error, instead of crashing, the statements in the <code>catch</code> block are executed, and the error message <code>siteDown</code> appears in the Debug area.</p><p class="callout-heading">Tip</p><p class="callout">You can make your<a id="_idIndexMarker265"/> program handle different error conditions by implementing multiple <code>catch</code> blocks. See this link for details: <a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html">https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html</a>.</p></li>
			</ol>
			<p>You have learned <a id="_idIndexMarker266"/>how to handle errors in your app without making it crash. Give yourself a pat on the back; you have completed the first part of this book!</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor131"/>Summary</h1>
			<p>In this chapter, you learned how to write protocols and how to make classes, structures, and enumerations conform to them. You also learned how to extend the capabilities of a class by using an extension. Finally, you learned how to handle errors using the <code>do-catch</code> block.</p>
			<p>It may seem rather abstract and hard to understand now, but as you will see in <em class="italic">Part 3</em> of this book, you will use protocols to implement common functionalities in different parts of your program instead of writing the same program over and over. You will see how useful extensions are in organizing your code, which makes it easy to maintain. Last but not least, you'll see how good error handling makes it easy to pinpoint the mistakes you made while coding your app.</p>
			<p>In the next chapter, you will start writing your first iOS application by creating the screens for it using storyboards, which allow you to rapidly prototype an application without having to type a lot of code.</p>
		</div>
	</body></html>