- en: Chapter 5. Physics in Sprite Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we had gone through essentials to develop a game in Sprite
    Kit. Also, we have already developed starting scenes, which are different screen
    views associated with menu items.
  prefs: []
  type: TYPE_NORMAL
- en: To recap the previous chapter, where we discussed about nodes in detail, we
    studied the `SKNode` class and its associated properties and functions. Along
    with this, we discussed about building a node tree and actions on a node tree.
    We also applied major subclasses in our game, such as `SKLabelNode`, `SKCropNode`,
    `SKShapeNode`, `SKEmitterNode`, `SKLightNode`, and `SKVideoNode` to create the
    menu scene. Now, the time has come to venture further into Sprite Kit.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world we are affected by many physical laws, such as mass, gravity,
    velocity, and so on. To make a game more realistic, Sprite Kit provides us with
    some classes and functions, which are used to make nodes act like bodies as in
    a real environment. By applying these classes to characters, environment, and
    so on, our game becomes realistic.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a platform game which involves a player walking on a road. It
    will be better to have gravity, force, friction, and so on, being applied to the
    player, the road or any other obstacle. Now, we are going to discuss about simulating
    physics in our game *Platformer*.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating physics in Sprite Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the game engines have an inbuilt physics engine, and you can also add
    an external physics engine to a game engine. Fortunately, Apple provides a physics
    engine in Sprite Kit. In Sprite Kit, physics properties are applied by an object
    of the class, `SKPhysicsBody`. As we have already learned that objects are connected
    to a node in a node tree, physics simulation uses a node''s orientation and position
    for simulation. In Sprite Kit, when a game renders, each frame invokes some functions
    in a cycle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After actions (such as image changing in a node for animation) `SKScene` simulates
    physics to do all the actions, such as gravity on a physics body, velocity change,
    collision between two physics bodies, and so on. If we go through our `SKNode`
    class, we will see there is a property called `physicsBody`. It takes the `SKPhysicsBody`
    object as a parameter and defines physics laws on those objects; it is obvious
    it will be inherited from its subclasses, such as `SKSpriteNode`, `SKEmitterNode`,
    `SKVideoNode`, and more. So, we can make any `SKNode` subclass a physics body
    by setting the `physicsBody` property on it.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to dive into some necessary documentation of the essential class
    responsible for the physics behavior of a node in a scene. Let's discuss about
    the `SKPhysicsBody` class.
  prefs: []
  type: TYPE_NORMAL
- en: SKPhysicsBody
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A node's `physicsBody` property uses the `SKPhysicsBody` class object. In the
    life cycle of a frame, the `didSimulatePhysics` function is called just after
    actions are evaluated. The work of this function is to calculate the physical
    properties, such as gravity, velocity, friction, restitution, collision, or other
    forces. After these calculations are done, the positions and orientations of nodes
    are updated in the `update` function. If we are going to apply some force on a
    node, it is necessary that we assign the `SKPhysicsBody` object to that node first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sprite Kit provides us with two kinds of physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume-based**: These are the kind of physics bodies that have mass and volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge-based**: These are the kind of physics bodies that don''t have mass
    and volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In volume-based bodies, we can control if it should be affected by gravity,
    friction, collision, and so on, by setting it as `static` or `dynamic`. This property
    is very useful as we can make a static platform or a moving object by just tweaking
    this property. These bodies are defined within specified boundaries, such as circle,
    rectangle, polygon, and so on. Irregular shapes are not allowed. For an irregular
    shaped body one can join small volume-based bodies to achieve desired pattern
    for a physics object.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, edge-based bodies are used to make volume-less spaces in
    the game scene. That means they are not solid and allow other physics body inside
    their own boundaries. Edge-based physics bodies are always treated as if their
    `dynamic` property is `false` and could collide only with other volume-based physics
    bodies. To understand the concept of edge-based body, think of a scene having
    clouds; a cloud can never be solid, a volume-based physics object can enter into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![SKPhysicsBody](img/4201_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A graphical example of volume-based and edge-based physics bodies
  prefs: []
  type: TYPE_NORMAL
- en: These two kinds of physics bodies are made by calling appropriate initialization
    of `SKPhysicsBody`. We mostly use volume-based physics bodies in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: As we define that, we need to instantiate the `SKPhysicsBody` class for making
    volume-based or edge-based physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization of volume-based physics bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the initializers for volume-based physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init(circleOfRadius r: CGFloat) -> SKPhysicsBody`: This initializer is used
    to make a circular physics body. It takes radius as a parameter and returns an
    `SKPhysicsBody` object. The center of gravity of this body lies in the center
    of the receiving node, that is, the, node on which this function is applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init(circleOfRadius r: CGFloat,center center: CGPoint) -> SKPhysicsBody`:
    This initializer is very similar to the previous one except in that it takes one
    more parameter, that is, the origin of the physics body. We can shift our gravity
    or circular physics body''s center with respect to the receiving coordinate system
    assigned by this initializer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init!(rectangleOfSize s: CGSize) -> SKPhysicsBody`: This initializer is used
    to make rectangle shaped physics bodies. It takes a `rectangle` as a parameter
    and returns an `SKPhysicsBody` object, containing its center on the receiving
    node''s center.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init!(rectangleOfSize s: CGSize,center center: CGPoint) -> SKPhysicsBody`:
    This initializer is very similar to the previous one except in that it takes one
    more parameter that is, origin of the physics body. We can shift gravity on a
    rectangular physics body to the center with respect to the receiving coordinate
    system assigned by this initializer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init(bodies bodies: [AnyObject]) -> SKPhysicsBody`: This initializer is used
    to make a new physics body by using the array of existing physics bodies. For
    this we have to pass only volume-based physics body objects in the array. The
    resultant area of the physics body from this initializer, is the union of the
    other child physics body inside the array. As it uses the shapes of its children''s
    bodies, it means it can have spaces inside it, or even blank fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init!(polygonFromPath path: CGPath!) -> SKPhysicsBody`: This initializer is
    used to make a polygon shaped physics body. It takes a convex polygon path with
    counterclockwise winding as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init!(texture texture: SKTexture!,size size: CGSize) -> SKPhysicsBody`: This
    initializer is used to make a physics body using a texture. This is used when
    we need a physics body shape as per the texture shape. It is called per pixel
    physics and is very useful when the shape is neither rectangular nor circular.
    It was introduced in iOS 8\. In this initializer, a texture and a size are used
    as parameters. First, texture is scaled to that size and then, the shape of the
    newly created physics body is decided by all of the pixels having a non-zero alpha
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init!(texture texture: SKTexture!,alphaThreshold alphaThreshold: Float,size
    size: CGSize) -> SKPhysicsBody`: This initializer is very similar to the previous
    one and was also introduced in iOS 8, except that it takes one more argument,
    `alpha`, as parameter. We can define what should be the alpha value below which
    the pixels will be ignored, in order to create the new physics body. The rest
    of the process is the same as the previous one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, let's have a look at how to create an edge-based physics body.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization of edge-based physics bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is the list of initializers used to make an edge-based physics body:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init (edgeLoopFromRect rect: CGRect) -> SKPhysicsBody`: This initializer takes
    a rectangle as a parameter and returns a new rectangular edge-based physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init (edgeFromPoint p1: CGPoint, toPoint p2: CGPoint) -> SKPhysicsBody`: This
    initializer takes two points as parameters and returns an edge-based physics body
    between those two points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init (edgeLoopFromPath path: CGPath!) -> SKPhysicsBody`: This initializer
    takes a `path` as a parameter and returns an edge-based physics body based on
    that path. The path must not intersect itself. If the path is not closed, it creates
    a loop by joining the first and the last point of that path automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init (edgeChainFromPath path: CGPath!) -> SKPhysicsBody`: This initializer
    takes a `path` as a parameter and returns an edge chain-based physics body based
    on that path. The path must not intersect itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the initialization processes for the physics body—both for volume-based
    and edge-based ones. We can customize a physics body's behavior by tweaking some
    of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior controller properties of a physics body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is the list of properties from which we can control the behavior
    of a physics body:'
  prefs: []
  type: TYPE_NORMAL
- en: '`affectedByGravity`: This is a Boolean value. It determines if a physics body
    will be affected by gravity in the scene. Edge-based physics bodies simply ignore
    this property as they are not affected by gravity. The default value is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowsRotation`: This is also a Boolean value. It determines if a physics
    body will be affected by angular forces and impulses applied to it in the scene.
    An edge-based physics body simply ignores this property. The default value is
    `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic`: This is a Boolean value too. It determines if a physics body will
    be moved by the physics simulation in the scene. Edge-based physics bodies simply
    ignore this property. The default value is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the behavior controller properties for a volume-based physics body.
    Along with this, a physics body has some of its own physical properties too.
  prefs: []
  type: TYPE_NORMAL
- en: The physical properties of a physics body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the properties possessed by a physics body. As you know, the velocity,
    force, gravity, collision, and so on, depend upon the mass, density, area, and
    so on, of a body.
  prefs: []
  type: TYPE_NORMAL
- en: Following is the list of physical properties of a physics body.
  prefs: []
  type: TYPE_NORMAL
- en: '`mass`: It is the mass of the body in kilograms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`density`: It is the density of the body in kilograms per square meter. The
    density and mass properties are interrelated. One property is recalculated every
    time the other is changed. The default value is 1.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`area`: It is the area covered by the body. This is a read-only property and
    is used to define the mass of the physics body with the help of the `density`
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`friction`: It is used to determine how much friction force should be applied
    to the other physics body in contact with the current body. This property has
    a value between 0.0 and 1.0\. The default value is 0.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restitution`: It is used to determine the bounciness of the physics body.
    This property has a value between 0.0 and 1.0\. The default value is 0.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linearDamping`: It is used to reduce the linear velocity of a physics body.
    This property has a value between 0.0 and 1.0\. The default value is 0.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angularDamping`: It is used to reduce the angular velocity of a physics body.
    This property has a value between 0.0 and 1.0\. The default value is 0.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties define the physical behavior of a physics body.
  prefs: []
  type: TYPE_NORMAL
- en: The `SKPhysicsBody` class provides some properties and functions for collision
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Collision control properties and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Physics bodies use some category for collision detection with other physics
    bodies. Collision is very important in almost every game. When objects collide,
    there is a change in the velocity and discretion of the object, which needs precise
    calculation of the change in the physical parameters. We have to specify the category
    of the physics bodies in our game. There is a limitation as we can only define
    32 different kinds of categories for the physics bodies in our game. We use these
    categories to define whether a physics body should collide with another physics
    body or not. This is very useful behavior and is used in a physics game in Sprite
    Kit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the list of collision control properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`categoryBitMask`: This is a mask which defines the category of the physics
    body. We can have up to 32 different categories. With the help of a category bitmask,
    you can define which physics bodies should interact with each other. This property
    is used along with `contactTestBitMark`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collisionBitMask`: This property is used to define the categories of physics
    bodies which could collide. It is used to determine whether a collision occurs
    using an AND operation with the other physics body. If the result is a nonzero
    value, this body will be affected by the collision, otherwise not. This helps
    you skip collision calculations in case of a minute velocity change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usesPreciseCollisionDetection: Bool`: If `true`, this body will be affected
    by the collision, otherwise it will pass through the other body in a single frame.
    A `true` value on either of the bodies will lead to a collision, which means that
    more computation power will be used by Sprite Kit to detect collisions and perform
    precise calculations. For very small and fast moving objects, this property can
    be set to `true`, otherwise the default value is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contactTestBitMask`: This property defines which category a `BitMask` physics
    body should notify the intersection with the receiving physics body through an
    AND gate operation. If the value is non-zero, the `SKPhysicsContact` object is
    created and passed to the physics world delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allContactedBodies() -> [AnyObject]`: This is the function which is used to
    determine if one or more bodies is in contact with the receiving physics body.
    It simply returns an array of all physics body objects that are in contact with
    the receiving physics body, that is, the body on which this function is applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These collision control properties and functions determine the behavior of two
    or more physics body collisions or contacts in a physics simulation. But sometimes
    we need to give velocity or force to a physics body for some specific behavior.
    The `SKPhysicsBody` class defines some functions which are used to apply force
    and impulse on physics bodies for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Forces and impulses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To move a space ship or a car, we need to apply force in the direction of motion;
    to keep it moving one has to apply force continuously. Impulse is to change the
    momentum of an object, for example, to fire a bullet, we need not apply any force
    once it starts moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the list of functions that are used to apply force and impulse
    on a physics body:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func applyForce(_ force: CGVector)`: This function is used to apply a force
    on the receiving physics body. It takes `force` as a parameter and accelerates
    the receiving physics body without any angular acceleration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func applyTorque(_ torque: CGFloat)`: This function is used to apply an angular
    force on the receiving physics body. It takes `torque` as a parameter and applies
    angular acceleration to the receiving physics body. It does not apply any linear
    acceleration on the receiving physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func applyForce(_ force: CGVector,atPoint point: CGPoint)`: This function
    is used to apply a force on the receiving physics body at a specific point. As
    it is applied on a specific point on the physics body, it could change both the
    angular and linear acceleration of the body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func applyImpulse(_ impulse: CGVector)`: This function is used to apply an
    impulse to the center of gravity of the receiving physics body. It takes `impulse`
    as a parameter and affects linear velocity, without changing angular velocity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func applyImpulse(_ impulse: CGVector,atPoint point: CGPoint)`: This function
    is used to apply an impulse on the receiving physics body at the specific point.
    As it is applied on a specific point on the physics body, it could change both
    angular and linear velocity of the receiving physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func applyAngularImpulse(_ impulse: CGFloat)`: This function is used to apply
    an angular impulse on the receiving physics body. It takes `impulse` as a parameter
    and applies angular velocity on the receiving physics body. It does not apply
    any linear velocity on the receiving physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with these functions, we also need to know the resultant velocity and
    angular velocity of the physics body. For this purpose, the `SKPhysicsBody` class
    has some properties.
  prefs: []
  type: TYPE_NORMAL
- en: The velocity of a physics body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following is the list of functions which are used to apply velocity on a physics
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '`velocity`: It is used to determine the linear velocity of the physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angularVelocity`: It is used to determine the angular velocity of the physics
    body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resting`: It determines if the physics object is at rest in the physics world.
    This means that it is not taking part in physics simulation, until awakened by
    a force or collision. This property helps reduce the calculation in physics simulation,
    and thus, improves the performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKPhysicsBody`: It provides us with some other important properties. Other
    property `joints`, this property holds an array of `SKPhysicsJoint` objects, which
    are connected to the receiving physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fieldBitMask`: This property is applied on the physics body. Once this body
    is inside of an `SKFieldNode` object, the `fieldBitMask` property will perform
    a logical AND operation with the `categoryBitMask` property of the field node.
    The field node''s effect will be applied to this body in case of a nonzero value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charge`: It is used to calculate the electromagnetic field force of an `SKFieldNode`
    object on the receiver''s physics body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pinned`: It determines whether the receiver will be fixed in position with
    respect to its parent or not. Its default value is `false`. If it is `true`, then
    the node can freely rotate around its position with respect to its parent, applying
    physics to our *Platformer* game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we are going to continue with our *Platformer* game and implement various
    physics engine capabilities in it. Before we start to apply physics in our game,
    we need to first make sure that the menu scene that loads initially is `MenuScene`
    (as discussed in [Chapter 3](ch03.html "Chapter 3. Sprites"), *Sprites*) and not
    `NodeMenuScene`. We will be implementing the `NodeMenuScene` class when we discuss
    about shaders and particle emitters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please go over to the `GameViewController.swift` file and in the `GameViewController`
    class, comment out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The above code will make your game load the `MenuScene` class. Now, head over
    to the `GameScene.swift` file to add physics bodies in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Using GameScene.swift to add physics bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by opening your `GameScene.swift` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `GameScene` class declaration to add `SKPhysicsContactSelegate` as
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have a look at the preceding code, you will see that we have added three
    new images: one is running the bar on top, which our player will run or appear
    to run, the other two are `block1` and `block2`. These two images are obstacles,
    with which our player will collide. Apart from this, we have also initialized
    some physical property values such as velocity, gravity, and so on. We also have
    defined an enum to control the collision type between `Blocks` and `Player`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add this function to start the execution flow, and to define the contact
    delegate to detect touch/contact on the screen (touch will help us determine the
    jump intensity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, the `#1` code block is used for adding the background,
    running bar, player, and blocks into the scene with the methods. And also for
    setting up the physics properties, such as `categoryBitMask`, `ContactTestBitMask`,
    `CollisionBitMask`, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the following function to generate blocks randomly, taking a number
    between `50` and `200`; this is used to randomly display blocks on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the next function for using sprite without texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next function to insert the background in the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function to define the physics property for the player/character
    in our game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, set up the running bar; the bar on which the player will appear to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Time to insert the following function to add the blocks in the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function, which is called when the user touches the screen.
    It leads the character to jump:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also add the next function, which is called when the screen touch is released.
    It will bring down the character after the jump:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next method to define actions to perform scene-specific updates that
    need to occur before the scene''s actions are evaluated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following function to make the blocks run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also create one more `swift` file by the name of `BlockStatus.swift`, in Xcode.
    This file contains code to initialize and run the blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now go ahead and run the game; make sure to experiment with various values to
    discover the behavior of your game. This will increase your understanding of physics
    in Sprite Kit.![Using GameScene.swift to add physics bodies](img/4201_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And following is the second image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using GameScene.swift to add physics bodies](img/4201_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding two screenshots display the character as static and blocks as
    moving. We can also perform jumps by touching on the character on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using GameScene.swift to add physics bodies](img/4201_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Did you notice that the player is not running, but instead, the bar under the
    player and the blocks colliding with it are moving. The character just appears
    to be running; in this case, we have just implemented the velocity method of jumping,
    instead of applying force in the y-direction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the physics engine. We learned about `SKPhysicsBody`.
    Now we know very well about edge-based and volume-based physics bodies in Sprite
    Kit. In our game, blocks coming towards the character are volume-based bodies.
    We also learned about the various initialization methods for these kinds of physics
    bodies. We learned how to apply the physics engine of Sprite Kit in a game, so
    as to explore its features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about animating sprites in Sprite Kit and
    adding various types of controls in our game. Also, we will discuss about collisions
    and SceneKit integration through Sprite Kit.
  prefs: []
  type: TYPE_NORMAL
