- en: Chapter 5. Physics in Sprite Kit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. Sprite Kit中的物理
- en: In previous chapters, we had gone through essentials to develop a game in Sprite
    Kit. Also, we have already developed starting scenes, which are different screen
    views associated with menu items.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了在Sprite Kit中开发游戏的基本知识。此外，我们已经开始开发起始场景，这些场景是与菜单项关联的不同屏幕视图。
- en: To recap the previous chapter, where we discussed about nodes in detail, we
    studied the `SKNode` class and its associated properties and functions. Along
    with this, we discussed about building a node tree and actions on a node tree.
    We also applied major subclasses in our game, such as `SKLabelNode`, `SKCropNode`,
    `SKShapeNode`, `SKEmitterNode`, `SKLightNode`, and `SKVideoNode` to create the
    menu scene. Now, the time has come to venture further into Sprite Kit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾上一章，我们详细讨论了节点，我们研究了`SKNode`类及其相关的属性和函数。此外，我们还讨论了构建节点树和节点树上的动作。我们还应用了我们在游戏中创建菜单场景的主要子类，如`SKLabelNode`、`SKCropNode`、`SKShapeNode`、`SKEmitterNode`、`SKLightNode`和`SKVideoNode`。现在，是时候进一步探索Sprite
    Kit了。
- en: In the real world we are affected by many physical laws, such as mass, gravity,
    velocity, and so on. To make a game more realistic, Sprite Kit provides us with
    some classes and functions, which are used to make nodes act like bodies as in
    a real environment. By applying these classes to characters, environment, and
    so on, our game becomes realistic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们受到许多物理定律的影响，例如质量、重力、速度等。为了使游戏更加逼真，Sprite Kit为我们提供了一些类和函数，这些类和函数用于使节点像在真实环境中一样行动。通过将这些类应用于角色、环境等，我们的游戏变得逼真。
- en: For example, in a platform game which involves a player walking on a road. It
    will be better to have gravity, force, friction, and so on, being applied to the
    player, the road or any other obstacle. Now, we are going to discuss about simulating
    physics in our game *Platformer*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个涉及玩家在道路上行走的平台游戏中。给玩家、道路或任何其他障碍物应用重力、力、摩擦等将更好。现在，我们将讨论在我们的游戏*Platformer*中模拟物理。
- en: Simulating physics in Sprite Kit
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Sprite Kit中模拟物理
- en: 'Most of the game engines have an inbuilt physics engine, and you can also add
    an external physics engine to a game engine. Fortunately, Apple provides a physics
    engine in Sprite Kit. In Sprite Kit, physics properties are applied by an object
    of the class, `SKPhysicsBody`. As we have already learned that objects are connected
    to a node in a node tree, physics simulation uses a node''s orientation and position
    for simulation. In Sprite Kit, when a game renders, each frame invokes some functions
    in a cycle, as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏引擎都有内置的物理引擎，你还可以向游戏引擎添加外部物理引擎。幸运的是，Apple在Sprite Kit中提供了一个物理引擎。在Sprite Kit中，物理属性通过`SKPhysicsBody`类的对象应用。正如我们已经学到的，对象与节点树中的节点相关联，物理模拟使用节点的方向和位置进行模拟。在Sprite
    Kit中，当游戏渲染时，每一帧都会在循环中调用一些函数，如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After actions (such as image changing in a node for animation) `SKScene` simulates
    physics to do all the actions, such as gravity on a physics body, velocity change,
    collision between two physics bodies, and so on. If we go through our `SKNode`
    class, we will see there is a property called `physicsBody`. It takes the `SKPhysicsBody`
    object as a parameter and defines physics laws on those objects; it is obvious
    it will be inherited from its subclasses, such as `SKSpriteNode`, `SKEmitterNode`,
    `SKVideoNode`, and more. So, we can make any `SKNode` subclass a physics body
    by setting the `physicsBody` property on it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作（例如节点动画中的图像变化）之后，`SKScene`会模拟物理以执行所有动作，例如物理体上的重力、速度变化、两个物理体之间的碰撞等。如果我们查看我们的`SKNode`类，我们会看到一个名为`physicsBody`的属性。它接受`SKPhysicsBody`对象作为参数，并定义了这些对象上的物理定律；很明显，它将从其子类继承，例如`SKSpriteNode`、`SKEmitterNode`、`SKVideoNode`等。因此，我们可以通过在它上面设置`physicsBody`属性，使任何`SKNode`子类成为一个物理体。
- en: Now it is time to dive into some necessary documentation of the essential class
    responsible for the physics behavior of a node in a scene. Let's discuss about
    the `SKPhysicsBody` class.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入研究负责场景中节点物理行为的必要文档了。让我们来讨论一下`SKPhysicsBody`类。
- en: SKPhysicsBody
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SKPhysicsBody
- en: A node's `physicsBody` property uses the `SKPhysicsBody` class object. In the
    life cycle of a frame, the `didSimulatePhysics` function is called just after
    actions are evaluated. The work of this function is to calculate the physical
    properties, such as gravity, velocity, friction, restitution, collision, or other
    forces. After these calculations are done, the positions and orientations of nodes
    are updated in the `update` function. If we are going to apply some force on a
    node, it is necessary that we assign the `SKPhysicsBody` object to that node first.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点的`physicsBody`属性使用`SKPhysicsBody`类对象。在帧的生命周期中，`didSimulatePhysics`函数在动作评估之后被调用。这个函数的工作是计算物理属性，如重力、速度、摩擦、恢复力、碰撞或其他力。在完成这些计算后，节点的位置和方向在`update`函数中更新。如果我们打算对一个节点施加一些力，那么首先将`SKPhysicsBody`对象分配给该节点是必要的。
- en: 'Sprite Kit provides us with two kinds of physics bodies:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Kit为我们提供了两种物理体：
- en: '**Volume-based**: These are the kind of physics bodies that have mass and volume'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于体积**：这些是有质量和体积的物理体类型'
- en: '**Edge-based**: These are the kind of physics bodies that don''t have mass
    and volume'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于边缘**：这些是没有质量和体积的物理体类型'
- en: In volume-based bodies, we can control if it should be affected by gravity,
    friction, collision, and so on, by setting it as `static` or `dynamic`. This property
    is very useful as we can make a static platform or a moving object by just tweaking
    this property. These bodies are defined within specified boundaries, such as circle,
    rectangle, polygon, and so on. Irregular shapes are not allowed. For an irregular
    shaped body one can join small volume-based bodies to achieve desired pattern
    for a physics object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于体积的物理体中，我们可以通过将其设置为`static`或`dynamic`来控制它是否应该受到重力、摩擦、碰撞等的影响。这个属性非常有用，因为我们只需调整这个属性就可以创建一个静态平台或移动对象。这些物体定义在特定的边界内，如圆形、矩形、多边形等。不允许不规则形状。对于不规则形状的物体，可以通过连接小的基于体积的物体来实现所需的物理对象图案。
- en: On the other hand, edge-based bodies are used to make volume-less spaces in
    the game scene. That means they are not solid and allow other physics body inside
    their own boundaries. Edge-based physics bodies are always treated as if their
    `dynamic` property is `false` and could collide only with other volume-based physics
    bodies. To understand the concept of edge-based body, think of a scene having
    clouds; a cloud can never be solid, a volume-based physics object can enter into
    it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，边缘基于的物理体用于在游戏场景中创建无体积的空间。这意味着它们不是实心的，允许其他物理体在其边界内。边缘基于的物理体始终被视为其`dynamic`属性为`false`，并且只能与其他基于体积的物理体发生碰撞。为了理解边缘基于物理体的概念，可以想象一个有云的场景；云永远不会是实心的，基于体积的物理对象可以进入其中。
- en: '![SKPhysicsBody](img/4201_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![SKPhysicsBody](img/4201_05_01.jpg)'
- en: A graphical example of volume-based and edge-based physics bodies
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于体积和边缘物理体的图形示例
- en: These two kinds of physics bodies are made by calling appropriate initialization
    of `SKPhysicsBody`. We mostly use volume-based physics bodies in our scene.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种物理体是通过调用`SKPhysicsBody`的适当初始化方法来创建的。在我们的场景中，我们主要使用基于体积的物理体。
- en: As we define that, we need to instantiate the `SKPhysicsBody` class for making
    volume-based or edge-based physics bodies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所定义的，我们需要实例化`SKPhysicsBody`类来创建基于体积或边缘的物理体。
- en: The initialization of volume-based physics bodies
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于体积物理体的初始化
- en: 'Following are the initializers for volume-based physics bodies:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于体积物理体的初始化器：
- en: '`init(circleOfRadius r: CGFloat) -> SKPhysicsBody`: This initializer is used
    to make a circular physics body. It takes radius as a parameter and returns an
    `SKPhysicsBody` object. The center of gravity of this body lies in the center
    of the receiving node, that is, the, node on which this function is applied.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init(circleOfRadius r: CGFloat) -> SKPhysicsBody`：这个初始化器用于创建圆形物理体。它接受半径作为参数，并返回一个`SKPhysicsBody`对象。这个物体的重心位于接收节点的中心，即应用此函数的节点。'
- en: '`init(circleOfRadius r: CGFloat,center center: CGPoint) -> SKPhysicsBody`:
    This initializer is very similar to the previous one except in that it takes one
    more parameter, that is, the origin of the physics body. We can shift our gravity
    or circular physics body''s center with respect to the receiving coordinate system
    assigned by this initializer.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init(circleOfRadius r: CGFloat,center center: CGPoint) -> SKPhysicsBody`：这个初始化器与之前的非常相似，只是在它还接受一个额外的参数，即物理体的原点。我们可以使用这个初始化器分配的接收坐标系统相对于我们的重力或圆形物理体的中心进行偏移。'
- en: '`init!(rectangleOfSize s: CGSize) -> SKPhysicsBody`: This initializer is used
    to make rectangle shaped physics bodies. It takes a `rectangle` as a parameter
    and returns an `SKPhysicsBody` object, containing its center on the receiving
    node''s center.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init!(rectangleOfSize s: CGSize) -> SKPhysicsBody`: 这个初始化器用于创建矩形形状的物理体。它接受一个`rectangle`作为参数，并返回一个包含其中心在接收节点中心的`SKPhysicsBody`对象。'
- en: '`init!(rectangleOfSize s: CGSize,center center: CGPoint) -> SKPhysicsBody`:
    This initializer is very similar to the previous one except in that it takes one
    more parameter that is, origin of the physics body. We can shift gravity on a
    rectangular physics body to the center with respect to the receiving coordinate
    system assigned by this initializer.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init!(rectangleOfSize s: CGSize,center center: CGPoint) -> SKPhysicsBody`:
    这个初始化器与上一个非常相似，除了它多了一个参数，即物理体的原点。我们可以通过这个初始化器分配的接收坐标系，将重力在矩形物理体上移至中心。'
- en: '`init(bodies bodies: [AnyObject]) -> SKPhysicsBody`: This initializer is used
    to make a new physics body by using the array of existing physics bodies. For
    this we have to pass only volume-based physics body objects in the array. The
    resultant area of the physics body from this initializer, is the union of the
    other child physics body inside the array. As it uses the shapes of its children''s
    bodies, it means it can have spaces inside it, or even blank fields.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init(bodies bodies: [AnyObject]) -> SKPhysicsBody`: 这个初始化器用于通过使用现有物理体的数组来创建一个新的物理体。为此，我们只需在数组中传递基于体积的物理体对象。从这个初始化器创建的物理体的结果区域是数组中其他子物理体的并集。因为它使用其子体的形状，这意味着它内部可以有空间，甚至空白区域。'
- en: '`init!(polygonFromPath path: CGPath!) -> SKPhysicsBody`: This initializer is
    used to make a polygon shaped physics body. It takes a convex polygon path with
    counterclockwise winding as a parameter.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init!(polygonFromPath path: CGPath!) -> SKPhysicsBody`: 这个初始化器用于创建多边形形状的物理体。它接受一个顺时针方向的凸多边形路径作为参数。'
- en: '`init!(texture texture: SKTexture!,size size: CGSize) -> SKPhysicsBody`: This
    initializer is used to make a physics body using a texture. This is used when
    we need a physics body shape as per the texture shape. It is called per pixel
    physics and is very useful when the shape is neither rectangular nor circular.
    It was introduced in iOS 8\. In this initializer, a texture and a size are used
    as parameters. First, texture is scaled to that size and then, the shape of the
    newly created physics body is decided by all of the pixels having a non-zero alpha
    value.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init!(texture texture: SKTexture!,size size: CGSize) -> SKPhysicsBody`: 这个初始化器用于使用纹理创建物理体。当我们需要根据纹理形状创建物理体形状时，会用到它。这被称为逐像素物理，当形状既不是矩形也不是圆形时非常有用。它是在iOS
    8中引入的。在这个初始化器中，使用纹理和大小作为参数。首先，纹理被缩放到那个大小，然后，新创建的物理体的形状由所有具有非零alpha值的像素决定。'
- en: '`init!(texture texture: SKTexture!,alphaThreshold alphaThreshold: Float,size
    size: CGSize) -> SKPhysicsBody`: This initializer is very similar to the previous
    one and was also introduced in iOS 8, except that it takes one more argument,
    `alpha`, as parameter. We can define what should be the alpha value below which
    the pixels will be ignored, in order to create the new physics body. The rest
    of the process is the same as the previous one.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init!(texture texture: SKTexture!,alphaThreshold alphaThreshold: Float,size
    size: CGSize) -> SKPhysicsBody`: 这个初始化器与上一个非常相似，也是在iOS 8中引入的，但它多了一个参数，即`alpha`。我们可以定义像素的alpha值，当低于这个值时，像素将被忽略，以创建新的物理体。其余的过程与上一个相同。'
- en: After this, let's have a look at how to create an edge-based physics body.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，让我们看看如何创建基于边缘的物理体。
- en: The initialization of edge-based physics bodies
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于边缘的物理体的初始化
- en: 'Following is the list of initializers used to make an edge-based physics body:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于创建基于边缘的物理体的初始化器列表：
- en: '`init (edgeLoopFromRect rect: CGRect) -> SKPhysicsBody`: This initializer takes
    a rectangle as a parameter and returns a new rectangular edge-based physics body.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init (edgeLoopFromRect rect: CGRect) -> SKPhysicsBody`: 这个初始化器接受一个矩形作为参数，并返回一个新的基于矩形边缘的物理体。'
- en: '`init (edgeFromPoint p1: CGPoint, toPoint p2: CGPoint) -> SKPhysicsBody`: This
    initializer takes two points as parameters and returns an edge-based physics body
    between those two points.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init (edgeFromPoint p1: CGPoint, toPoint p2: CGPoint) -> SKPhysicsBody`: 这个初始化器接受两个点作为参数，并在这两个点之间返回一个基于边缘的物理体。'
- en: '`init (edgeLoopFromPath path: CGPath!) -> SKPhysicsBody`: This initializer
    takes a `path` as a parameter and returns an edge-based physics body based on
    that path. The path must not intersect itself. If the path is not closed, it creates
    a loop by joining the first and the last point of that path automatically.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init (edgeLoopFromPath path: CGPath!) -> SKPhysicsBody`: 此初始化器接受一个`path`作为参数，并基于该路径返回一个基于边的物理体。路径不得相交。如果路径未封闭，它将自动通过连接该路径的第一个和最后一个点来创建一个循环。'
- en: '`init (edgeChainFromPath path: CGPath!) -> SKPhysicsBody`: This initializer
    takes a `path` as a parameter and returns an edge chain-based physics body based
    on that path. The path must not intersect itself.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init (edgeChainFromPath path: CGPath!) -> SKPhysicsBody`: 此初始化器接受一个`path`作为参数，并基于该路径返回一个基于边链的物理体。路径不得相交。'
- en: These are the initialization processes for the physics body—both for volume-based
    and edge-based ones. We can customize a physics body's behavior by tweaking some
    of its properties.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基于体积和基于边的物理体的初始化过程。我们可以通过调整其一些属性来自定义物理体的行为。
- en: The behavior controller properties of a physics body
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理体的行为控制器属性
- en: 'Following is the list of properties from which we can control the behavior
    of a physics body:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以控制物理体行为的属性列表：
- en: '`affectedByGravity`: This is a Boolean value. It determines if a physics body
    will be affected by gravity in the scene. Edge-based physics bodies simply ignore
    this property as they are not affected by gravity. The default value is `true`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`受重力影响`: 这是一个布尔值。它确定物理体是否会被场景中的重力影响。基于边的物理体简单地忽略此属性，因为它们不受重力影响。默认值是`true`。'
- en: '`allowsRotation`: This is also a Boolean value. It determines if a physics
    body will be affected by angular forces and impulses applied to it in the scene.
    An edge-based physics body simply ignores this property. The default value is
    `true`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`允许旋转`: 这也是一个布尔值。它确定物理体是否会被场景中施加到它上的角力和冲量影响。基于边的物理体简单地忽略此属性。默认值是`true`。'
- en: '`dynamic`: This is a Boolean value too. It determines if a physics body will
    be moved by the physics simulation in the scene. Edge-based physics bodies simply
    ignore this property. The default value is `true`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`动态`: 这也是一个布尔值。它确定物理体是否会被场景中的物理模拟移动。基于边的物理体简单地忽略此属性。默认值是`true`。'
- en: These are the behavior controller properties for a volume-based physics body.
    Along with this, a physics body has some of its own physical properties too.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基于体积的物理体的行为控制器属性。此外，物理体还有一些自己的物理属性。
- en: The physical properties of a physics body
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理体的物理属性
- en: These are the properties possessed by a physics body. As you know, the velocity,
    force, gravity, collision, and so on, depend upon the mass, density, area, and
    so on, of a body.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是物理体拥有的属性。正如你所知，速度、力、重力、碰撞等取决于物体的质量、密度、面积等。
- en: Following is the list of physical properties of a physics body.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是物理体的物理属性列表。
- en: '`mass`: It is the mass of the body in kilograms.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`质量`: 这是物体的质量，单位为千克。'
- en: '`density`: It is the density of the body in kilograms per square meter. The
    density and mass properties are interrelated. One property is recalculated every
    time the other is changed. The default value is 1.0.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`密度`: 这是物体每平方米的密度。密度和质量属性是相互关联的。每当其中一个属性改变时，另一个属性就会重新计算。默认值是1.0。'
- en: '`area`: It is the area covered by the body. This is a read-only property and
    is used to define the mass of the physics body with the help of the `density`
    property.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`面积`: 这是物体覆盖的面积。这是一个只读属性，并用于在`密度`属性的帮助下定义物理体的质量。'
- en: '`friction`: It is used to determine how much friction force should be applied
    to the other physics body in contact with the current body. This property has
    a value between 0.0 and 1.0\. The default value is 0.2.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`摩擦力`: 它用于确定应施加到与当前物体接触的另一个物理物体上的摩擦力大小。此属性值介于0.0和1.0之间。默认值为0.2。'
- en: '`restitution`: It is used to determine the bounciness of the physics body.
    This property has a value between 0.0 and 1.0\. The default value is 0.2.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`恢复`: 它用于确定物理体的弹性。此属性值介于0.0和1.0之间。默认值是0.2。'
- en: '`linearDamping`: It is used to reduce the linear velocity of a physics body.
    This property has a value between 0.0 and 1.0\. The default value is 0.1.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`线性阻尼`: 它用于减少物理体的线性速度。此属性值介于0.0和1.0之间。默认值为0.1。'
- en: '`angularDamping`: It is used to reduce the angular velocity of a physics body.
    This property has a value between 0.0 and 1.0\. The default value is 0.1.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angularDamping`: 它用于减少物理物体的角速度。此属性值介于0.0和1.0之间。默认值为0.1。'
- en: These properties define the physical behavior of a physics body.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性定义了物理物体的物理行为。
- en: The `SKPhysicsBody` class provides some properties and functions for collision
    control.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKPhysicsBody`类提供了一些用于碰撞控制的属性和函数。'
- en: Collision control properties and functions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞控制属性和函数
- en: Physics bodies use some category for collision detection with other physics
    bodies. Collision is very important in almost every game. When objects collide,
    there is a change in the velocity and discretion of the object, which needs precise
    calculation of the change in the physical parameters. We have to specify the category
    of the physics bodies in our game. There is a limitation as we can only define
    32 different kinds of categories for the physics bodies in our game. We use these
    categories to define whether a physics body should collide with another physics
    body or not. This is very useful behavior and is used in a physics game in Sprite
    Kit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 物理物体使用某些类别与其他物理物体进行碰撞检测。碰撞在几乎每个游戏中都非常重要。当物体发生碰撞时，物体的速度和方向会发生变化，这需要对物理参数的变化进行精确计算。我们必须指定我们游戏中物理物体的类别。有一个限制，因为我们只能为我们游戏中的物理物体定义32种不同的类别。我们使用这些类别来定义物理物体是否应该与另一个物理物体发生碰撞。这是非常有用的行为，并且在Sprite
    Kit的物理游戏中使用。
- en: 'Following is the list of collision control properties:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是碰撞控制属性的列表：
- en: '`categoryBitMask`: This is a mask which defines the category of the physics
    body. We can have up to 32 different categories. With the help of a category bitmask,
    you can define which physics bodies should interact with each other. This property
    is used along with `contactTestBitMark`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`categoryBitMask`: 这是一个定义物理物体类别的掩码。我们可以有最多32个不同的类别。借助类别掩码，您可以定义哪些物理物体应该相互交互。此属性与`contactTestBitMark`一起使用。'
- en: '`collisionBitMask`: This property is used to define the categories of physics
    bodies which could collide. It is used to determine whether a collision occurs
    using an AND operation with the other physics body. If the result is a nonzero
    value, this body will be affected by the collision, otherwise not. This helps
    you skip collision calculations in case of a minute velocity change.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collisionBitMask`: 此属性用于定义可能发生碰撞的物理物体的类别。它用于通过与其他物理物体的AND操作来确定是否发生碰撞。如果结果是非零值，则此物体将受到碰撞的影响，否则不会。这有助于在速度变化很小的场合跳过碰撞计算。'
- en: '`usesPreciseCollisionDetection: Bool`: If `true`, this body will be affected
    by the collision, otherwise it will pass through the other body in a single frame.
    A `true` value on either of the bodies will lead to a collision, which means that
    more computation power will be used by Sprite Kit to detect collisions and perform
    precise calculations. For very small and fast moving objects, this property can
    be set to `true`, otherwise the default value is `false`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usesPreciseCollisionDetection: Bool`: 如果为`true`，则此物体将受到碰撞的影响，否则它将在一个帧内穿过另一个物体。任一物体的`true`值都会导致碰撞，这意味着Sprite
    Kit将使用更多的计算能力来检测碰撞和执行精确计算。对于非常小且快速移动的物体，此属性可以设置为`true`，否则默认值为`false`。'
- en: '`contactTestBitMask`: This property defines which category a `BitMask` physics
    body should notify the intersection with the receiving physics body through an
    AND gate operation. If the value is non-zero, the `SKPhysicsContact` object is
    created and passed to the physics world delegate.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contactTestBitMask`: 此属性定义了`BitMask`物理物体应该通过AND门操作通知与接收到的物理物体相交的类别。如果值为非零，则创建`SKPhysicsContact`对象并将其传递给物理世界代理。'
- en: '`allContactedBodies() -> [AnyObject]`: This is the function which is used to
    determine if one or more bodies is in contact with the receiving physics body.
    It simply returns an array of all physics body objects that are in contact with
    the receiving physics body, that is, the body on which this function is applied.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allContactedBodies() -> [AnyObject]`: 这是一个用于确定一个或多个物体是否与接收到的物理物体接触的函数。它简单地返回一个包含所有与接收到的物理物体接触的物理物体对象的数组，即应用此函数的物体。'
- en: These collision control properties and functions determine the behavior of two
    or more physics body collisions or contacts in a physics simulation. But sometimes
    we need to give velocity or force to a physics body for some specific behavior.
    The `SKPhysicsBody` class defines some functions which are used to apply force
    and impulse on physics bodies for this purpose.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些碰撞控制属性和功能决定了在物理模拟中两个或更多物理体碰撞或接触的行为。但有时我们需要为了某些特定的行为给物理体施加速度或力。`SKPhysicsBody`
    类定义了一些用于在此目的上对物理体施加力和冲量的函数。
- en: Forces and impulses
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 力和冲量
- en: To move a space ship or a car, we need to apply force in the direction of motion;
    to keep it moving one has to apply force continuously. Impulse is to change the
    momentum of an object, for example, to fire a bullet, we need not apply any force
    once it starts moving.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动一艘太空船或一辆汽车，我们需要在运动方向上施加力；要保持其运动，必须持续施加力。冲量是用来改变物体的动量，例如，发射子弹时，一旦它开始运动，我们就不需要再施加任何力。
- en: 'Following is the list of functions that are used to apply force and impulse
    on a physics body:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于在物理体上施加力和冲量的函数列表：
- en: '`func applyForce(_ force: CGVector)`: This function is used to apply a force
    on the receiving physics body. It takes `force` as a parameter and accelerates
    the receiving physics body without any angular acceleration.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func applyForce(_ force: CGVector)`: 此函数用于对接收到的物理体施加力。它接受 `force` 作为参数，并加速接收到的物理体，而不产生任何角加速度。'
- en: '`func applyTorque(_ torque: CGFloat)`: This function is used to apply an angular
    force on the receiving physics body. It takes `torque` as a parameter and applies
    angular acceleration to the receiving physics body. It does not apply any linear
    acceleration on the receiving physics body.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func applyTorque(_ torque: CGFloat)`: 此函数用于对接收到的物理体施加角力。它接受 `torque` 作为参数，并对接收到的物理体施加角加速度。它不会对接收到的物理体施加任何线加速度。'
- en: '`func applyForce(_ force: CGVector,atPoint point: CGPoint)`: This function
    is used to apply a force on the receiving physics body at a specific point. As
    it is applied on a specific point on the physics body, it could change both the
    angular and linear acceleration of the body.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func applyForce(_ force: CGVector, atPoint point: CGPoint)`: 此函数用于在特定点上对接收到的物理体施加力。由于它作用于物理体上的特定点，因此可能会改变物体的角加速度和线加速度。'
- en: '`func applyImpulse(_ impulse: CGVector)`: This function is used to apply an
    impulse to the center of gravity of the receiving physics body. It takes `impulse`
    as a parameter and affects linear velocity, without changing angular velocity.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func applyImpulse(_ impulse: CGVector)`: 此函数用于对接收到的物理体的重心施加冲量。它接受 `impulse`
    作为参数，并影响线速度，而不改变角速度。'
- en: '`func applyImpulse(_ impulse: CGVector,atPoint point: CGPoint)`: This function
    is used to apply an impulse on the receiving physics body at the specific point.
    As it is applied on a specific point on the physics body, it could change both
    angular and linear velocity of the receiving physics body.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func applyImpulse(_ impulse: CGVector, atPoint point: CGPoint)`: 此函数用于在特定点上对接收到的物理体施加冲量。由于它作用于物理体上的特定点，因此可能会改变接收物理体的角速度和线速度。'
- en: '`func applyAngularImpulse(_ impulse: CGFloat)`: This function is used to apply
    an angular impulse on the receiving physics body. It takes `impulse` as a parameter
    and applies angular velocity on the receiving physics body. It does not apply
    any linear velocity on the receiving physics body.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func applyAngularImpulse(_ impulse: CGFloat)`: 此函数用于对接收到的物理体施加角冲量。它接受 `impulse`
    作为参数，并对接收到的物理体施加角速度。它不会对接收到的物理体施加任何线速度。'
- en: Along with these functions, we also need to know the resultant velocity and
    angular velocity of the physics body. For this purpose, the `SKPhysicsBody` class
    has some properties.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些函数之外，我们还需要知道物理体的结果速度和角速度。为此，`SKPhysicsBody` 类有一些属性。
- en: The velocity of a physics body
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理体的速度
- en: 'Following is the list of functions which are used to apply velocity on a physics
    body:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于在物理体上施加速度的函数列表：
- en: '`velocity`: It is used to determine the linear velocity of the physics body.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`velocity`: 它用于确定物理体的线速度。'
- en: '`angularVelocity`: It is used to determine the angular velocity of the physics
    body.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angularVelocity`: 它用于确定物理体的角速度。'
- en: '`resting`: It determines if the physics object is at rest in the physics world.
    This means that it is not taking part in physics simulation, until awakened by
    a force or collision. This property helps reduce the calculation in physics simulation,
    and thus, improves the performance.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resting`：它确定物理对象是否在物理世界中处于静止状态。这意味着它不参与物理模拟，直到被力或碰撞唤醒。这个属性有助于减少物理模拟中的计算，从而提高性能。'
- en: '`SKPhysicsBody`: It provides us with some other important properties. Other
    property `joints`, this property holds an array of `SKPhysicsJoint` objects, which
    are connected to the receiving physics body.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKPhysicsBody`：它为我们提供了一些其他重要的属性。其他属性 `joints`，这个属性包含一个 `SKPhysicsJoint` 对象的数组，这些对象连接到接收到的物理体。'
- en: '`fieldBitMask`: This property is applied on the physics body. Once this body
    is inside of an `SKFieldNode` object, the `fieldBitMask` property will perform
    a logical AND operation with the `categoryBitMask` property of the field node.
    The field node''s effect will be applied to this body in case of a nonzero value.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldBitMask`：这个属性应用于物理体。一旦这个体进入一个 `SKFieldNode` 对象内部，`fieldBitMask` 属性将与字段节点的
    `categoryBitMask` 属性执行逻辑与操作。如果值为非零，字段节点的影响将应用于此体。'
- en: '`charge`: It is used to calculate the electromagnetic field force of an `SKFieldNode`
    object on the receiver''s physics body.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charge`：它用于计算 `SKFieldNode` 对象对接收器物理体的电磁场力。'
- en: '`pinned`: It determines whether the receiver will be fixed in position with
    respect to its parent or not. Its default value is `false`. If it is `true`, then
    the node can freely rotate around its position with respect to its parent, applying
    physics to our *Platformer* game.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pinned`：它确定接收器是否相对于其父级固定在位置。其默认值是 `false`。如果是 `true`，则节点可以自由地围绕其相对于父级的位置旋转，将物理应用到我们的
    *平台游戏*。'
- en: Now, we are going to continue with our *Platformer* game and implement various
    physics engine capabilities in it. Before we start to apply physics in our game,
    we need to first make sure that the menu scene that loads initially is `MenuScene`
    (as discussed in [Chapter 3](ch03.html "Chapter 3. Sprites"), *Sprites*) and not
    `NodeMenuScene`. We will be implementing the `NodeMenuScene` class when we discuss
    about shaders and particle emitters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续我们的 *平台游戏* 并在其中实现各种物理引擎功能。在我们开始将物理应用到我们的游戏之前，我们需要首先确保最初加载的菜单场景是 `MenuScene`（如第
    [3章](ch03.html "第3章。精灵") 所述，*精灵*) 而不是 `NodeMenuScene`。当我们讨论着色器和粒子发射器时，我们将实现 `NodeMenuScene`
    类。
- en: 'Please go over to the `GameViewController.swift` file and in the `GameViewController`
    class, comment out the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请转到 `GameViewController.swift` 文件，并在 `GameViewController` 类中注释掉以下内容：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead, write this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 取而代之，写下以下内容：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above code will make your game load the `MenuScene` class. Now, head over
    to the `GameScene.swift` file to add physics bodies in our game.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将使你的游戏加载 `MenuScene` 类。现在，前往 `GameScene.swift` 文件以在我们的游戏中添加物理体。
- en: Using GameScene.swift to add physics bodies
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `GameScene.swift` 添加物理体。
- en: Start by opening your `GameScene.swift` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开你的 `GameScene.swift` 文件。
- en: 'Edit the `GameScene` class declaration to add `SKPhysicsContactSelegate` as
    the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `GameScene` 类声明以添加 `SKPhysicsContactSelegate` 如下：
- en: '[PRE3]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then add the following code in it:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在其中添加以下代码：
- en: '[PRE4]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you have a look at the preceding code, you will see that we have added three
    new images: one is running the bar on top, which our player will run or appear
    to run, the other two are `block1` and `block2`. These two images are obstacles,
    with which our player will collide. Apart from this, we have also initialized
    some physical property values such as velocity, gravity, and so on. We also have
    defined an enum to control the collision type between `Blocks` and `Player`.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你查看前面的代码，你会看到我们添加了三张新图片：一张是顶部运行的条形，我们的玩家将跑步或看起来在跑步，其他两张是 `block1` 和 `block2`。这两张图片是障碍物，我们的玩家将与它们碰撞。除此之外，我们还初始化了一些物理属性值，如速度、重力等。我们还定义了一个枚举来控制
    `Blocks` 和 `Player` 之间的碰撞类型。
- en: 'Now, add this function to start the execution flow, and to define the contact
    delegate to detect touch/contact on the screen (touch will help us determine the
    jump intensity):'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下函数以启动执行流程，并定义接触代理以检测屏幕上的触摸/接触（触摸将帮助我们确定跳跃强度）：
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the `#1` code block is used for adding the background,
    running bar, player, and blocks into the scene with the methods. And also for
    setting up the physics properties, such as `categoryBitMask`, `ContactTestBitMask`,
    `CollisionBitMask`, and so on.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`#1`代码块用于使用方法将背景、跑步条、玩家和方块添加到场景中。并且还用于设置物理属性，如`categoryBitMask`、`ContactTestBitMask`、`CollisionBitMask`等。
- en: 'Now, add the following function to generate blocks randomly, taking a number
    between `50` and `200`; this is used to randomly display blocks on the screen:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下函数以随机生成方块，取一个介于`50`和`200`之间的数字；这是用于在屏幕上随机显示方块：
- en: '[PRE6]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, add the next function for using sprite without texture:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加下一个函数以使用无纹理的精灵：
- en: '[PRE7]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the next function to insert the background in the scene:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个函数以在场景中插入背景：
- en: '[PRE8]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following function to define the physics property for the player/character
    in our game:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到定义我们游戏中玩家/角色的物理属性：
- en: '[PRE9]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, set up the running bar; the bar on which the player will appear to run:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置跑步条；玩家将出现在上面的条上：
- en: '[PRE10]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Time to insert the following function to add the blocks in the game:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在插入以下函数以在游戏中添加方块：
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following function, which is called when the user touches the screen.
    It leads the character to jump:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数，当用户触摸屏幕时调用。它使角色跳跃：
- en: '[PRE12]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also add the next function, which is called when the screen touch is released.
    It will bring down the character after the jump:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还添加下一个函数，当屏幕触摸释放时调用。它将在跳跃后将角色降下：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the next method to define actions to perform scene-specific updates that
    need to occur before the scene''s actions are evaluated:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个方法以定义在场景动作评估之前需要执行的特定场景更新操作：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, add the following function to make the blocks run:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下函数以使方块移动：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also create one more `swift` file by the name of `BlockStatus.swift`, in Xcode.
    This file contains code to initialize and run the blocks:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在Xcode中创建一个名为`BlockStatus.swift`的`swift`文件。此文件包含初始化和运行方块代码：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now go ahead and run the game; make sure to experiment with various values to
    discover the behavior of your game. This will increase your understanding of physics
    in Sprite Kit.![Using GameScene.swift to add physics bodies](img/4201_05_02.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始运行游戏；确保尝试不同的值来发现你游戏的行为。这将增加你在Sprite Kit中对物理学的理解。![使用GameScene.swift添加物理体](img/4201_05_02.jpg)
- en: 'And following is the second image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二张图片：
- en: '![Using GameScene.swift to add physics bodies](img/4201_05_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![使用GameScene.swift添加物理体](img/4201_05_03.jpg)'
- en: 'The preceding two screenshots display the character as static and blocks as
    moving. We can also perform jumps by touching on the character on the screen:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个截图显示了角色为静态，方块为移动。我们还可以通过在屏幕上触摸角色来执行跳跃：
- en: '![Using GameScene.swift to add physics bodies](img/4201_05_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用GameScene.swift添加物理体](img/4201_05_04.jpg)'
- en: Did you notice that the player is not running, but instead, the bar under the
    player and the blocks colliding with it are moving. The character just appears
    to be running; in this case, we have just implemented the velocity method of jumping,
    instead of applying force in the y-direction.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到玩家没有在跑，而是玩家下面的条和与之碰撞的方块在移动。角色只是看起来像在跑；在这种情况下，我们只是实现了跳跃的速率方法，而不是在y方向上应用力。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the physics engine. We learned about `SKPhysicsBody`.
    Now we know very well about edge-based and volume-based physics bodies in Sprite
    Kit. In our game, blocks coming towards the character are volume-based bodies.
    We also learned about the various initialization methods for these kinds of physics
    bodies. We learned how to apply the physics engine of Sprite Kit in a game, so
    as to explore its features.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了物理引擎。我们学习了`SKPhysicsBody`。现在我们非常了解Sprite Kit中的基于边缘和基于体积的物理体。在我们的游戏中，朝向角色的方块是体积型体。我们还学习了这些类型物理体的各种初始化方法。我们学习了如何在游戏中应用Sprite
    Kit的物理引擎，以便探索其功能。
- en: In the next chapter, we will learn about animating sprites in Sprite Kit and
    adding various types of controls in our game. Also, we will discuss about collisions
    and SceneKit integration through Sprite Kit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习在Sprite Kit中动画精灵以及在我们的游戏中添加各种类型的控制。我们还将讨论通过Sprite Kit进行碰撞和SceneKit集成。
