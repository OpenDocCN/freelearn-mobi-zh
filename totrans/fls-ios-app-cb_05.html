<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Multi-touch and Gesture Support</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting the touch point input mode</li><li class="listitem" style="list-style-type: disc">Detecting multiple touch points</li><li class="listitem" style="list-style-type: disc">Dragging multiple display objects</li><li class="listitem" style="list-style-type: disc">Tracking movement</li><li class="listitem" style="list-style-type: disc">Setting the gesture input mode</li><li class="listitem" style="list-style-type: disc">Handling a swipe gesture</li><li class="listitem" style="list-style-type: disc">Panning an object</li><li class="listitem" style="list-style-type: disc">Rotating an object</li><li class="listitem" style="list-style-type: disc">Zooming an object</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Introduction</h1></div></div></div><p>The iPhone wasn't the first to use the technology, but its success kick-started the touch-screen revolution. Critical to that success was Apple's decision to include multi-touch support. Be it a single tap, swipe, or pinch; interaction with the iPhone's screen always feels intuitive and natural.</p><p>The Flash platform allows application developers to take full advantage of multi-touch when targeting iOS. In this chapter, we will explore how to work with multiple-touch points before covering how to detect and respond to gestures.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Setting the touch point input mode</h1></div></div></div><p>The success of the iPhone has changed how people use mobile devices, with users now expecting to interact directly with a device by physically touching its screen. While a mouse is limited to the selection of a single point, iOS devices can detect multiple touches and track the movement of each of them simultaneously.<a id="id348" class="indexterm"/>
</p><p>Flash provides full support for multi-touch but in order to take advantage of it you must first inform the platform of your intentions to receive and use touch-based events.<a id="id349" class="indexterm"/>
</p><p>Let us see how this is done.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec01"/>Getting ready</h2></div></div></div><p>An FLA has been provided as a starting point for this recipe.<a id="id350" class="indexterm"/>
</p><p>From the book's accompanying code bundle, open<code class="literal"> chapter5\recipe1\recipe.fla</code> into Flash Professional.</p><p>Sitting on the stage is a dynamic text field named<code class="literal"> output</code>. We will write some code to enable multi-touch input and write the success or failure of the request to the text field.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec02"/>How to do it...</h2></div></div></div><p>Perform the following steps:<a id="id351" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following two import statements:<div><pre class="programlisting">import flash.display.MovieClip;
<strong>import flash.ui.Multitouch;
import flash.ui.MultitouchInputMode;
</strong>
</pre></div></li><li class="listitem">Now within the constructor add some code to enable multi-touch support:<div><pre class="programlisting">public function Main() {
<strong>
if(Multitouch.supportsTouchEvents)
{
Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;
output.text = ("inputMode = " + Multitouch.inputMode);
}
else
{
output.text = "Multi-touch events not supported.";
}
</strong>
}
</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code>.</li><li class="listitem">Publish the FLA and deploy the IPA file to your iOS device.</li></ol></div><p>When you run the app, the following text should be output to the screen:<a id="id352" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><strong>inputMode = touchPoint
</strong></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec03"/>How it works...</h2></div></div></div><p>Flash provides various multi-touch input modes, which determine the type of events your application can receive. In order to receive touch events, you need to set the<code class="literal"> Multitouch.inputMode</code> property to<code class="literal"> MultitouchInputMode.TOUCH_POINT</code>. Here is the line of code from your document class that does this:<a id="id353" class="indexterm"/>
</p><div><pre class="programlisting">Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;
</pre></div><p>In addition to setting<code class="literal"> Multitouch.inputMode</code>, you can also query it to determine the currently selected input mode. For this recipe, the current input mode is written to the<code class="literal"> output</code> text field to confirm that it was successfully set:</p><div><pre class="programlisting">output.text = ("inputMode = " + Multitouch.inputMode);
</pre></div><p>Although Flash supports multi-touch across all iOS devices, the same is not true for all other operating systems and platforms. When writing cross-platform code, you may want to confirm support by checking the<code class="literal"> Multitouch.supportsTouchEvents</code> property. In our code example, this is done before setting the input mode.<a id="id354" class="indexterm"/>
</p><p>For more information regarding the multi-touch input mode, perform a search for<code class="literal"> flash.ui.Multitouch</code> and<code class="literal"> flash.ui.MultitouchInputMode</code> within Adobe Community Help.</p><p>It is also highly recommended that you spend time with Apple's iOS Human Interface Guidelines, where you will find best practices for driving the user experience through multi-touch. The documentation can be found on the iOS Dev Center at<a class="ulink" href="http://developer.apple.com/devcenter/ios"> http://developer.apple.com/devcenter/ios</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec04"/>There's more...</h2></div></div></div><p>Let us look at some additional detail.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Available touch events</h3></div></div></div><p>Setting the input mode for touch allows you to listen for touch-specific events being dispatched by objects of type<code class="literal"> InteractiveObject</code> or objects that inherit<code class="literal"> InteractiveObject</code>, such as<code class="literal"> Sprite, MovieClip</code>, and<code class="literal"> Stage</code>. On a multi-touch screen, each point of contact that can be made by a finger is known as a touch point.<a id="id355" class="indexterm"/>
</p><p>The following touch events are available:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Touch events</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_BEGIN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A touch point has been pressed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_END</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A touch point has been released.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_MOVE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A touch point is being moved. This occurs when a finger is being dragged across the screen.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_TAP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A quick finger tap.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_OVER</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A touch point has moved over an interactive object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_OUT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A touch point has been moved away from an interactive object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_ROLL_OVER</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A touch point has moved over an interactive object. Unlike<code class="literal"> TOUCH_OVER</code>, this event will not fire for any children belonging to the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TOUCH_ROLL_OUT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A touch point has been moved away from an interactive object. Unlike<code class="literal"> TOUCH_OUT</code>, this event will not fire for any children belonging to the object.</p>
</td></tr></tbody></table></div><p>We will see some of these events in action during the next few recipes.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Determining the number of supported touch points</h3></div></div></div><p>You can determine the number of touch points supported by your iOS device by examining the static<code class="literal"> Multitouch.maxTouchPoints</code> property.<a id="id356" class="indexterm"/>
</p><p>While you will find that five touch points are supported across the range of iOS devices, this property is of more practical use on cross-platform projects, where the number of touch points can vary wildly depending on the operating system and choice of input device. When targeting multiple platforms, optimize your content with this in mind.<a id="id357" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec03"/>Touch point hit targets</h3></div></div></div><p>For elements that can be tapped within your application, ensure that a hit area that is at least the size of a fingertip is used. This equates to approximately 44x44 pixels on a standard resolution screen and 88x88 pixels on a Retina display.<a id="id358" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec04"/>Mouse events</h3></div></div></div><p>The default input mode is<code class="literal"> MultitouchInputMode.NONE</code>, which specifies that all user interaction with a touch-enabled device is interpreted as a mouse event. However, unlike<code class="literal"> MultitouchInputMode.TOUCH_POINT</code>, only a single touch point can be processed at any one time.<a id="id359" class="indexterm"/>
</p><p>Note that when the input mode is set to<code class="literal"> MultitouchInputMode.TOUCH_POINT</code>, you can continue to listen for and respond to mouse events provided by<code class="literal"> flash.events.MouseEvents</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec05"/>Testing in ADL</h3></div></div></div><p>It is most likely that testing this recipe's code within ADL will result in the following message being output to the screen:<a id="id360" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><strong>Multi-touch events not supported.
</strong></li></ul></div><p>Not all desktop computers or operating systems support multi-touch. When using touch-based events within your code, it is advisable that you test directly on an iOS device.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec05"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a basic document class, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></li><li class="listitem" style="list-style-type: disc"><em>Handling user interaction, <a class="link" href="ch04.html" title="Chapter 4. Porting Flash Projects to iOS">Chapter 4</a></em></li><li class="listitem" style="list-style-type: disc"><em>Detecting multiple touch points</em></li><li class="listitem" style="list-style-type: disc"><em>Setting the gesture input mode</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Detecting multiple touch points</h1></div></div></div><p>The term multi-touch refers to the ability to simultaneously detect and track two or more distinct points of contact on a touch-screen. Touch events are similar to the mouse events provided by Flash, except you can listen for and respond to multiple touch events all at once.<a id="id361" class="indexterm"/>
</p><p>Let us revisit the Bubbles app from<a class="link" href="ch03.html" title="Chapter 3. Writing your First App"> Chapter 3</a> and add multi-touch interaction to it. We will add functionality to let the user trap multiple bubbles by holding a finger on top of each.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec06"/>Getting ready</h2></div></div></div><p>A version of the Bubbles FLA has been provided for you to work from.<a id="id362" class="indexterm"/>
</p><p>From Flash Professional, open<code class="literal"> chapter5\recipe2\recipe.fla</code> from the book's accompanying code bundle.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec07"/>How to do it...</h2></div></div></div><p>We will be making changes to both the FLA's document class and<code class="literal"> Bubble.as</code>.<a id="id363" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec06"/>Updating the Bubble class</h3></div></div></div><p>Let us start by adding some code to<code class="literal"> Bubble.as</code> that prevents any of the bubble instances from moving if being held:<a id="id364" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Open the<code class="literal"> Bubble.as</code> class.</li><li class="listitem">Add the following member variable:<div><pre class="programlisting">private var _held:Boolean = false;
</pre></div></li><li class="listitem">Now write a getter and a setter method for the<code class="literal"> _held</code> variable:<div><pre class="programlisting">public function set held(h:Boolean):void {
_held = h;
}
public function get held():Boolean {
return _held;
}
</pre></div></li><li class="listitem">Move to the<code class="literal"> update()</code> method and write a few lines of code at the start to prevent the bubble's update logic from running if it is being held:<a id="id365" class="indexterm"/><div><pre class="programlisting">public function update():void {
<strong>
if(_held)
{
return;
}
</strong>
</pre></div></li><li class="listitem">Finally, within the constructor, disable user input for any child display objects within the bubble—we are only interested in receiving events for the bubble's container:<div><pre class="programlisting">public function Bubble() {
<strong>mouseChildren = false;
</strong>
}
</pre></div></li><li class="listitem">Save<code class="literal"> Bubble.as.</code><a id="id366" class="indexterm"/></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec07"/>Responding to multiple touch events</h3></div></div></div><p>Now within the FLA's document class, let us listen for multi-touch events and trap any bubbles that are being touched:<a id="id367" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Open the<code class="literal"> Main.as</code> document class.</li><li class="listitem">Include the following three import statements:<div><pre class="programlisting">import flash.ui.Multitouch;
import flash.ui.MultitouchInputMode;
import flash.events.TouchEvent;
</pre></div></li><li class="listitem">Within the constructor, set the input mode, and listen for<code class="literal"> TouchEvent.TOUCH_BEGIN</code> and<code class="literal"> TouchEvent.TOUCH_END</code> being dispatched from the stage:<div><pre class="programlisting">public function Main() {
<strong>
Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;
stage.addEventListener(TouchEvent.TOUCH_BEGIN, touchBegin);
stage.addEventListener(TouchEvent.TOUCH_END, touchEnd);
</strong>
application = NativeApplication.nativeApplication;
</pre></div></li><li class="listitem">Write a handler for the<code class="literal"> TOUCH_BEGIN</code> event:<div><pre class="programlisting">private function touchBegin(e:TouchEvent):void {
var b:Bubble = e.target as Bubble;
if(b != null)
{
b.held = true;
}
}
</pre></div></li><li class="listitem">And add a handler for the<code class="literal"> TOUCH_END</code> event too:<div><pre class="programlisting">private function touchEnd(e:TouchEvent):void {
var b:Bubble = e.target as Bubble;
if(b != null)
{
b.held = false;
}
}
</pre></div></li><li class="listitem">Save<code class="literal"> Main.as</code>.</li><li class="listitem">Publish the FLA and deploy the IPA file to your device.</li></ol></div><p>Run the app and hold your fingers on multiple bubbles to stop them from floating upwards. Lifting your finger off a bubble will release it again.<a id="id368" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec08"/>How it works...</h2></div></div></div><p>This recipe took advantage of multi-touch to allow the detection of touch points across multiple objects simultaneously.<a id="id369" class="indexterm"/>
</p><p>Touch was enabled with the following line of code within the<code class="literal"> Main</code> class' constructor:</p><div><pre class="programlisting">Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;
</pre></div><p>Touch events can be dispatched by any<code class="literal"> InteractiveObject</code> or sub-class of<code class="literal"> InteractiveObject</code>, such as<code class="literal"> Sprite, MovieClip</code>, and<code class="literal"> Stage</code>.</p><p>Listeners for the following two events were added to the stage:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TouchEvent.TOUCH_BEGIN</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TouchEvent.TOUCH_END</code></li></ul></div><p>The<code class="literal"> TOUCH_BEGIN</code> event is fired when the user presses a finger onto any child interactive object of the stage. This is the case even if other areas of the screen's surface are already being touched. When the user lifts their finger from an interactive object, the<code class="literal"> TOUCH_END</code> event is dispatched.<a id="id370" class="indexterm"/>
</p><p>In this recipe, the stage's child objects consist of bubble instances and a single background movie clip. The event handlers simply check to see if the event was dispatched from a<code class="literal"> Bubble</code> instance, and if so the bubble's<code class="literal"> held</code> property is set. For the<code class="literal"> TOUCH_BEGIN</code> event, the bubble's<code class="literal"> held</code> property is set to<code class="literal"> true</code>, thus freezing it. When the<code class="literal"> TOUCH_END</code> event is received, the bubble's held property is set to<code class="literal"> false</code>, allowing it to start moving upwards again.<a id="id371" class="indexterm"/>
</p><p>You can obtain more information regarding the<code class="literal"> flash.events.TouchEvent</code> class from Adobe Community Help.<a id="id372" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec08"/>Handling roll out</h3></div></div></div><p>Sometimes the user's finger may slide away from the bubble rather than being cleanly lifted from it. When this happens in this recipe's example code, the held bubble doesn't receive the<code class="literal"> TOUCH_END</code> event and therefore doesn't start floating upwards again.<a id="id373" class="indexterm"/>
</p><p>You can rectify this by listening for<code class="literal"> TouchEvent.TOUCH_ROLL_OUT</code> being dispatched from each of the bubble instances. Simply add the following line within the<code class="literal"> Main</code> class' constructor:</p><div><pre class="programlisting">for(var i:uint = 0; i &lt; bubbles.length; i++)
{
bubbles[i].speed = speeds[i];
<strong>bubbles[i].addEventListener(TouchEvent.TOUCH_ROLL_OUT, touchEnd);
</strong>
}
</pre></div><p>Now when the user slides his or her finger away from a bubble, the<code class="literal"> touchEnd()</code> handler will get called and the bubble will start moving again.<a id="id374" class="indexterm"/>
</p><div><h3 class="title"><a id="note33"/>Note</h3><p>You can carry your code from this recipe into the next. If you have added an event listener for<code class="literal"> TouchEvent.TOUCH_ROLL_OUT</code>, then remove it again before continuing as it isn't required and will produce odd behavior if left in.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec09"/>There's more...</h2></div></div></div><p>Each event object that your handler receives contains a number of properties related to that touch event. You may find the following properties useful when detecting multiple touch points.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Primary touch point</h3></div></div></div><p>When touching a screen at multiple locations, the primary touch point is deemed to be the location that was first touched. When your event handler receives a<code class="literal"> TouchEvent</code> object, you can query its<code class="literal"> isPrimaryTouchPoint</code> property to determine this.<a id="id375" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Touch point ID</h3></div></div></div><p>A unique ID is assigned to every new touch point and is used across all events associated with that point of contact. You can determine the touch point that an event is associated with by examining its<code class="literal"> touchPointID</code> property.<a id="id376" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec11"/>Local touch coordinates</h3></div></div></div><p>You can use the<code class="literal"> localX</code> and<code class="literal"> localY</code> properties to determine the coordinates at which a touch event occurred relative to the interactive object. Bear in mind that these two properties won't provide pixel-perfect accuracy on touch-screen devices due to the nature of the technology and the surface area that is covered by a finger tip.<a id="id377" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec12"/>Global touch coordinates</h3></div></div></div><p>You can also obtain the position at which an event occurred in global stage coordinates. Simply inspect the value of the event's<code class="literal"> stageX</code> and<code class="literal"> stageY</code> properties.<a id="id378" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec10"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Linking classes to movie-clip symbols, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></li><li class="listitem" style="list-style-type: disc"><em>Using an update loop, <a class="link" href="ch03.html" title="Chapter 3. Writing your First App">Chapter 3</a></em></li><li class="listitem" style="list-style-type: disc"><em>Setting the touch point input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Dragging multiple display objects</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Dragging multiple display objects</h1></div></div></div><p>With touch-enabled screens, the act of dragging a display object with a finger is very intuitive. Adobe AIR provides API calls that allow this type of interaction without much effort. In addition, the multi-touch capabilities of iOS can be harnessed to allow multiple objects to be dragged at once.<a id="id379" class="indexterm"/>
</p><p>We will continue where we left off in the<em> Detecting multiple touch points</em> recipe and add the ability to drag the bubbles around the screen.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec11"/>Getting ready</h2></div></div></div><p>If you haven't already done so, complete the<em> Detecting multiple touch points</em> recipe before proceeding.<a id="id380" class="indexterm"/>
</p><p>You can continue to work with the code you wrote during that recipe. Alternatively, from the book's accompanying code bundle, open<code class="literal"> chapter5\recipe3\recipe.fla</code> into Flash Professional and work from there.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec12"/>How to do it...</h2></div></div></div><p>Open the FLA's document class and perform the following steps:<a id="id381" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Declare the following member variable:<div><pre class="programlisting">private var touching:Array;
</pre></div></li><li class="listitem">This array will be used to map touch points to <code class="literal"> Bubble</code> instances.</li><li class="listitem">Within the constructor, set the<code class="literal"> touching</code> member variable to an empty array:<div><pre class="programlisting">public function Main() {
touching = [];
Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;
stage.addEventListener(TouchEvent.TOUCH_BEGIN, touchBegin);
stage.addEventListener(TouchEvent.TOUCH_END, touchEnd);
</pre></div></li><li class="listitem">Move to the<code class="literal"> touchBegin()</code> event handler and make the following changes:<a id="id382" class="indexterm"/><div><pre class="programlisting">private function touchBegin(e:TouchEvent):void {
var b:Bubble = e.target as Bubble;
if(b != null &amp;&amp; !b.held)
{
b.held = true;
b.startTouchDrag(e.touchPointID);
touching[e.touchPointID] = b;
}
}
</pre></div></li><li class="listitem">Now alter the<code class="literal"> touchEnd()</code> handler too:<div><pre class="programlisting">private function touchEnd(e:TouchEvent):void {
var b:Bubble = touching[e.touchPointID];
if(b != null)
{
b.held = false;
b.stopTouchDrag(e.touchPointID);
delete touching[e.touchPointID];
touching[e.touchPointID] = null;
}
}
</pre></div></li><li class="listitem">Save<code class="literal"> Main.as</code>.</li><li class="listitem">Publish the FLA and deploy the IPA to your device.</li></ol></div><p>When you run the app, you will now be able to stop and drag the bubbles. You can even drag multiple bubbles simultaneously. Give it a try.<a id="id383" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec13"/>How it works...</h2></div></div></div><p>Much of the work in this recipe is performed by<code class="literal"> startTouchDrag()</code> and<code class="literal"> stopTouchDrag()</code>. Both methods are defined by<code class="literal"> flash.display.Sprite</code> and are also available to classes that inherit it, including our<code class="literal"> Bubble</code> class.<a id="id384" class="indexterm"/>
</p><p>The<code class="literal"> startTouchDrag()</code> method allows the user to drag a bubble across the screen. It does this by associating a touch point ID with a bubble, continuously updating the bubble's position to reflect that of the touch point.<a id="id385" class="indexterm"/>
</p><p>On the other hand, the<code class="literal"> stopTouchDrag()</code> method stops the bubble from being dragged by the specified touch point ID.<a id="id386" class="indexterm"/>
</p><p>Let us take a look at the<code class="literal"> touchBegin()</code> event handler where<code class="literal"> startTouchDrag()</code> is called. Two lines of code that are of particular interest have been highlighted:<a id="id387" class="indexterm"/>
</p><div><pre class="programlisting">private function touchBegin(e:TouchEvent):void {
<strong>var b:Bubble = e.target as Bubble;
</strong>
if(b != null &amp;&amp; !b.held)
{
b.held = true;
<strong>b.startTouchDrag(e.touchPointID);
</strong>
touching[e.touchPointID] = b;
}
}
</pre></div><p>First, the interactive object that was touched is obtained by querying the event's<code class="literal"> target</code> property and an attempt is made to cast it to a<code class="literal"> Bubble</code> object. If the object is a bubble, then its<code class="literal"> startTouchDrag()</code> method is called with the event's touch point ID being passed as an argument.<a id="id388" class="indexterm"/>
</p><p>Every point of contact made with the screen is assigned a unique ID that can be used by methods such as<code class="literal"> startTouchDrag()</code> and<code class="literal"> stopTouchDrag().</code> You can determine the touch point that an event is associated with by examining its<code class="literal"> touchPointID</code> property. We take advantage of these unique IDs within our code to associate a bubble with a touch point. You can see this mapping taking place near the end of the<code class="literal"> touchBegin()</code> event handler:<a id="id389" class="indexterm"/>
</p><div><pre class="programlisting">private function touchBegin(e:TouchEvent):void {
var b:Bubble = e.target as Bubble;
if(b != null &amp;&amp; !b.held)
{
b.held = true;
b.startTouchDrag(e.touchPointID);
<strong>touching[e.touchPointID] = b;
</strong>
}
}
</pre></div><p>The handler makes use of the<code class="literal"> touching</code> member variable to store a reference to the bubble that is being dragged by the user. The bubble instance is placed in the<code class="literal"> touching</code> array, with the event's touch point ID being used as the index position.</p><p>Let us now take a look at the<code class="literal"> touchEnd()</code> event handler, where we obtain from the<code class="literal"> touching</code> array, the bubble that has just been released by the user:<a id="id390" class="indexterm"/>
</p><div><pre class="programlisting">private function touchEnd(e:TouchEvent):void {
<strong>var b:Bubble = touching[e.touchPointID];
</strong>
if(b != null)
{
b.held = false;
<strong>b.stopTouchDrag(e.touchPointID);
</strong>
<strong>delete touching[e.touchPointID];
touching[e.touchPointID] = null;
</strong>
}
}
</pre></div><p>In the above method, the event's<code class="literal"> touchPointID</code> is obtained and used to retrieve the associated bubble from the<code class="literal"> touching</code> array. If a bubble instance was retrieved, then its<code class="literal"> stopTouchDrag()</code> method is called with the event's touch point ID being passed as an argument. This will stop the bubble being dragged by the user's finger.<a id="id391" class="indexterm"/>
</p><p>Finally, at the end of the method, the bubble reference is removed from the<code class="literal"> touching</code> array as it is no longer required:</p><div><pre class="programlisting">private function touchEnd(e:TouchEvent):void {
var b:Bubble = touching[e.touchPointID];
if(b != null)
{
b.held = false;
b.stopTouchDrag(e.touchPointID);
delete touching[e.touchPointID];
touching[e.touchPointID] = null;
}
}
</pre></div><p>That is all there is to it. With the use of the<code class="literal"> Sprite</code> class'<code class="literal"> startTouchDrag()</code> and<code class="literal"> stopTouchDrag()</code> methods and by tracking touch point IDs, we were able to manage the dragging of multiple interactive objects.<a id="id392" class="indexterm"/>
</p><p>You can obtain more information regarding the<code class="literal"> flash.display.Sprite</code> class from Adobe Community Help.<a id="id393" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec14"/>There's more...</h2></div></div></div><p>Following is some more information regarding<code class="literal"> startTouchDrag().</code>
<a id="id394" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec13"/>startTouchDrag() parameters</h3></div></div></div><p>The<code class="literal"> startTouchDrag()</code> method expects three arguments with only the first being mandatory:<a id="id395" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">touchPointID:</code> The ID of the touch point that will be used to drag the sprite.</li><li class="listitem" style="list-style-type: disc"><code class="literal">lockCenter:</code> Whether to lock the center of the sprite to the touch point <code class="literal">(true)
</code>, or lock to the point where contact was made with the sprite <code class="literal">(false)
</code>. Defaulted to<code class="literal"> false</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bounds:</code> A<code class="literal"> Rectangle</code> that defines a constraint region for the sprite that is being dragged. Defaulted to<code class="literal"> null</code> meaning there is to be no constraint region.</li></ul></div><p>This recipe's example code only used the first argument. Meaning the center of the bubble wasn't locked to the user's finger and the user was free to drag the bubble anywhere on the screen.</p><p>To force the bubble's center to lock to the user's finger, simply pass<code class="literal"> true</code> as the second argument:</p><div><pre class="programlisting">b.startTouchDrag(e.touchPointID, true);
</pre></div><p>The following example also constrains the bubble to a 200x200 pixel region at the top-left corner of the screen:</p><div><pre class="programlisting">b.startTouchDrag(
e.touchPointID, true, new Rectangle(0, 0, 200, 200));
</pre></div><p>Try applying each example to your code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec15"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Setting the touch point input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Tracking movement</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Tracking movement</h1></div></div></div><p>One important touch-based event that we haven't looked at yet in detail is<code class="literal"> TouchEvent.TOUCH_MOVE</code>. This event is fired whenever the user moves a finger across the screen and can be queried to determine the contact point's coordinates. Every time the user's finger changes position, a new<code class="literal"> TOUCH_MOVE</code> event is dispatched.</p><p>Although<code class="literal"> startTouchDrag()</code> and<code class="literal"> stopTouchDrag()</code> are recommended for dragging objects, you can instead update an object's position in response to<code class="literal"> TOUCH_MOVE</code> events.<a id="id396" class="indexterm"/>
</p><p>Let us make some changes to the code from the<em> Dragging multiple display objects</em> recipe to do this.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec16"/>Getting ready</h2></div></div></div><p>If you haven't already done so, complete the<em> Dragging multiple display objects</em> recipe before proceeding.</p><p>You can continue to work with your code from that recipe. Alternatively, from the book's accompanying code bundle, open<code class="literal"> chapter5\recipe4\recipe.fla</code> into Flash Professional and work from there.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec17"/>How to do it...</h2></div></div></div><p>Perform the following steps within the FLA's document class:<a id="id397" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Move to the constructor and add a listener for<code class="literal"> TouchEvent.TOUCH_MOVE:</code><div><pre class="programlisting">public function Main() {
touching = [];
Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;
stage.addEventListener(TouchEvent.TOUCH_BEGIN, touchBegin);
stage.addEventListener(TouchEvent.TOUCH_END, touchEnd);
<strong>stage.addEventListener(TouchEvent.TOUCH_MOVE, touchMove);
</strong>
</pre></div></li><li class="listitem">Remove the call to<code class="literal"> startTouchDrag()</code> from the<code class="literal"> touchBegin()</code> handler by deleting the highlighted line of code from the<code class="literal"> if</code> statement:<div><pre class="programlisting">private function touchBegin(e:TouchEvent):void {
var b:Bubble = e.target as Bubble;
if(b != null &amp;&amp; !b.held)
{
b.held = true;
<strong>b.startTouchDrag(e.touchPointID, true);
</strong>
touching[e.touchPointID] = b;
}
}
</pre></div></li><li class="listitem">Also remove the call to<code class="literal"> stopTouchDrag()</code> from the<code class="literal"> touchEnd()</code> handler by deleting the highlighted line of code from the<code class="literal"> if</code> statement:<div><pre class="programlisting">private function touchEnd(e:TouchEvent):void {
var b:Bubble = touching[e.touchPointID];
if(b != null)
{
b.held = false;
<strong>b.stopTouchDrag(e.touchPointID);
</strong>
delete touching[e.touchPointID];
touching[e.touchPointID] = null;
}
}
</pre></div></li><li class="listitem">Now write the<code class="literal"> touchMove()</code> event handler:<a id="id398" class="indexterm"/><div><pre class="programlisting">private function touchMove(e:TouchEvent):void {
var b:Bubble = touching[e.touchPointID] as Bubble;
if(b != null)
{
b.x = e.stageX;
b.y = e.stageY;
}
}
</pre></div></li><li class="listitem">Save<code class="literal"> Main.as</code>.</li><li class="listitem">Publish the FLA and deploy the IPA to your device.</li></ol></div><p>This example should behave in an identical way to the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec18"/>How it works...</h2></div></div></div><p>Although dragging was previously taken care of by<code class="literal"> startTouchDrag()</code> and<code class="literal"> stopTouchDrag()</code>, for this recipe we manually update the position of the bubbles by responding to<code class="literal"> TouchEvent.TOUCH_MOVE</code>.<a id="id399" class="indexterm"/>
</p><p>The bulk of the work is performed within the<code class="literal"> touchMove()</code> event handler, which is shown again as follows:<a id="id400" class="indexterm"/>
</p><div><pre class="programlisting">private function touchMove(e:TouchEvent):void {
var b:Bubble = touching[e.touchPointID] as Bubble;
if(b != null)
{
b.x = e.stageX;
b.y = e.stageY;
}
}
</pre></div><p>Using the event's touch point ID, a reference to the bubble associated with it (if any) is retrieved from the<code class="literal"> touching</code> array. The bubble's<code class="literal"> x</code> and<code class="literal"> y</code> properties are then updated to reflect the on-screen position of the user's finger, which is retrieved from the event's<code class="literal"> stageX</code> and<code class="literal"> stageY</code> properties.</p><p>Every time one of the user's fingers changes position on the device's screen, the<code class="literal"> TOUCH_MOVE</code> event is dispatched, and any bubble associated with that contact point is re-positioned to match the finger's position.<a id="id401" class="indexterm"/>
</p><p>While this recipe has concentrated on the use of<code class="literal"> TOUCH_MOVE</code> to perform dragging, the event can be applied to many other tasks. For example, it could be used to track finger movement for a paint application or to trace a path for a game character to follow.</p><p>If you are implementing dragging within your app, it is recommended that you use<code class="literal"> startTouchDrag()</code> and<code class="literal"> stopTouchDrag()</code> instead, which has performance benefits over listening for<code class="literal"> TOUCH_MOVE</code> events. However, now that you are comfortable working with the<code class="literal"> TOUCH_MOVE</code> event, you should be able to put it to various other uses.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec19"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Setting the touch point input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Dragging multiple display objects</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Setting the gesture input mode</h1></div></div></div><p>Along with handling simple multi-touch events, AIR for iOS provides support for gestures such as zoom, rotation, and swipe. A gesture is a single event that is made up from a sequence of simpler multi-touch events. Although you can capture multi-touch events and translate them into gestures yourself, the Flash platform also provides support for the most common ones, reducing your workload.<a id="id402" class="indexterm"/>
</p><p>In order to receive gesture events, you must select the appropriate input mode.</p><p>Let us see how this is done.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec20"/>Getting ready</h2></div></div></div><p>From Flash Professional, open<code class="literal"> chapter5\recipe5\recipe.fla</code> from the book's accompanying code bundle.<a id="id403" class="indexterm"/>
</p><p>Sitting on the stage is a dynamic text field named<code class="literal"> output</code>. We will write some code to enable gesture input and write the success or failure of the request to the text field.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec21"/>How to do it...</h2></div></div></div><p>Perform the following steps:<a id="id404" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following two import statements:<div><pre class="programlisting">import flash.display.MovieClip;
<strong>
import flash.ui.Multitouch;
import flash.ui.MultitouchInputMode;
</strong>
</pre></div></li><li class="listitem">Now within the constructor, add some code to enable gesture support:<div><pre class="programlisting">public function Main() {
<strong>
if(Multitouch.supportsGestureEvents)
{
Multitouch.inputMode = MultitouchInputMode.GESTURE;
output.text = ("inputMode = " + Multitouch.inputMode);
}
else
{
output.text = "Gesture events not supported.";
}
</strong>
}
</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code>.</li><li class="listitem">Publish the FLA and deploy the IPA file to your iOS device.</li></ol></div><p>When you run the app, the following text should be output on the screen:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><strong>inputMode = gesture
</strong></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec22"/>How it works...</h2></div></div></div><p>Flash provides various multi-touch input modes, which determine the type of events your application can receive. In order to receive gesture events, you need to set the<code class="literal"> Multitouch.inputMode</code> property to<code class="literal"> MultitouchInputMode.GESTURE</code>. The following is the line of code from your document class that does this:<a id="id405" class="indexterm"/>
</p><div><pre class="programlisting">Multitouch.inputMode = MultitouchInputMode.GESTURE;
</pre></div><p>In addition to setting<code class="literal"> Multitouch.inputMode</code>, you can also query it to determine the currently selected input mode. In this recipe's code example, the current input mode is written to the<code class="literal"> output</code> text field to confirm that it was successfully set:</p><div><pre class="programlisting">output.text = ("inputMode = " + Multitouch.inputMode);
</pre></div><p>Although Flash provides gesture support across all iOS devices, when writing cross-platform code you may want to confirm support by checking the<code class="literal"> Multitouch.supportsGestureEvents</code> property. In our code example, this is done before setting the input mode.<a id="id406" class="indexterm"/>
</p><p>It should be noted that when the input mode is set for handling gestures you will be unable to receive basic touch events from the<code class="literal"> TouchEvent</code> class. If you need to receive both touch and gesture events at the same time, then you will need to select the<code class="literal"> MultitouchInputMode.TOUCH_POINT</code> input mode and capture multiple touch events before synthesizing them into gesture events yourself.<a id="id407" class="indexterm"/>
</p><p>For more information regarding the gesture input mode, perform a search for<code class="literal"> flash.ui.Multitouch</code> and<code class="literal"> flash.ui.MultitouchInputMode</code> within Adobe Community Help.</p><p>Apple places a lot of importance on the correct use of gestures in order to provide consistency across applications. Apple's iOS Human Interface Guidelines contains a list of standard gestures and the actions users typically perform with them. When supporting gestures within your own applications, try not to deviate from the expected behavior.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec23"/>There's more...</h2></div></div></div><p>The following are some additional details regarding gestures.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec14"/>Available gesture events and types</h3></div></div></div><p>Setting the input mode for gestures allows you to listen for gesture-specific events being dispatched by objects of type<code class="literal"> InteractiveObject</code> or objects that inherit<code class="literal"> InteractiveObject</code>, such as<code class="literal"> Sprite, MovieClip</code>, and<code class="literal"> Stage</code>.</p><p>As with touch point input, gestures can also take advantage of multiple touch points.</p><p>The following gesture events are available:<a id="id408" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GestureEvent.GESTURE_TWO_FINGER_TAP:</code> Dispatched when two fingers are used to tap the screen.<a id="id409" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">TransformGestureEvent.GESTURE_PAN:</code> An attempt is made to move content that is typically too large to fit on screen. The pan gesture is fired when two fingers are being moved across on-screen content.<a id="id410" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">TransformGestureEvent.GESTURE_ROTATE:</code> Dispatched when two touch points are rotated around each other. This gesture is typically used to rotate on-screen content.<a id="id411" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">TransformGestureEvent.GESTURE_SWIPE:</code> A quick stroke of a finger across the screen. Swipe gestures are commonly used to scroll lists or quickly flick between pages of information.<a id="id412" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">TransformGestureEvent.GESTURE_ZOOM:</code> Two touch points are either being moved towards or away from one another. This gesture is commonly used to zoom on-screen content.<a id="id413" class="indexterm"/></li></ul></div><p>We will see some of these events in action throughout the remainder of this chapter.<a id="id414" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Determining the supported gestures</h3></div></div></div><p>You can obtain a list of gestures supported by your iOS device using the static<code class="literal"> Multitouch.supportedGestures</code> property. A vector array of strings will be returned, where each string represents a gesture event.<a id="id415" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec16"/>Mouse events</h3></div></div></div><p>The default input mode is<code class="literal"> MultitouchInputMode.NONE</code>, which specifies that all user interaction with a touch-enabled device is interpreted as a mouse event. However, unlike<code class="literal"> MultitouchInputMode.GESTURE</code> and<code class="literal"> MultitouchInputMode.TOUCH_POINT</code>, only a single touch point can be processed at any one time.<a id="id416" class="indexterm"/>
</p><p>Note that when the input mode is set to<code class="literal"> MultitouchInputMode.GESTURE</code>, you can continue to listen for and respond to mouse events provided by<code class="literal"> flash.events.MouseEvents</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec17"/>Testing in ADL</h3></div></div></div><p>It is most likely that testing this recipe's code within ADL will result in the following message being output on the screen:<a id="id417" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><strong>Gesture events not supported.</strong></li></ul></div><p>Not all desktop computers or operating systems support gesture-based events. When using gestures within your code, it is advisable that you test directly on an iOS device.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec24"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Handling user interaction,</em>Chapter 4</li><li class="listitem" style="list-style-type: disc"><em>Setting the touch point input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Handling a swipe gesture</em></li><li class="listitem" style="list-style-type: disc"><em>Panning an object</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Handling a swipe gesture</h1></div></div></div><p>The introduction of touch-screens has made the process of moving between pages of information more natural. The iPhone made simple touch gestures, such as swiping, popular. For example, many photo viewer applications allow the user to quickly flick their finger across the screen in order to view the next image in a sequence.<a id="id418" class="indexterm"/>
</p><p>The<code class="literal"> TransformGestureEvent.GESTURE_SWIPE</code> event is available, allowing both vertical and horizontal swiping gestures to be detected and acted upon.<a id="id419" class="indexterm"/>
</p><p>Let us see how this is done.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec25"/>Getting ready</h2></div></div></div><p>From Flash Professional, open<code class="literal"> chapter5\recipe6\recipe.fla</code> from the book's accompanying code bundle.<a id="id420" class="indexterm"/>
</p><p>Sitting on the stage is a container movie clip named<code class="literal"> content</code>, which is over twice the width of the stage. Inside the container are two distinct bubbles, with only a single bubble able to fit on screen at any one time. We will write code to let the user swipe horizontally between the two bubbles.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec26"/>How to do it...</h2></div></div></div><p>Perform the following steps to listen for and respond to a horizontal swipe gesture:</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Include the following import statements:<div><pre class="programlisting">import flash.display.MovieClip;
<strong>
import flash.events.TransformGestureEvent;
import flash.ui.Multitouch;
import flash.ui.MultitouchInputMode;
import fl.transitions.Tween;
import fl.motion.easing.Sine;
</strong>
</pre></div></li><li class="listitem">Add the following code within the class' constructor:<div><pre class="programlisting">public function Main() {
<strong>
Multitouch.inputMode = MultitouchInputMode.GESTURE;
stage.addEventListener(TransformGestureEvent.GESTURE_SWIPE, swipe);
}
</strong>
</pre></div></li><li class="listitem">Now add the swipe gesture's event handler:<a id="id421" class="indexterm"/><div><pre class="programlisting">private function swipe(e:TransformGestureEvent):void {
var t:Tween;
<strong>if(e.offsetX == -1)
</strong>
{
t = new Tween(content, "x", Sine.easeOut, content.x, -465, 0.25, true);
}
<strong>else if(e.offsetX == 1)
</strong>
{
t = new Tween(content, "x", Sine.easeOut, content.x, -35, 0.25, true);
}
}
</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code>.</li><li class="listitem">Publish the FLA and deploy the IPA to your device.</li></ol></div><p>Quickly swipe your finger from right to left to move to the second bubble, and left to right to move back to the first.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>How it works...</h2></div></div></div><p>Gesture events can be dispatched by any<code class="literal"> InteractiveObject</code> or sub-class of<code class="literal"> InteractiveObject</code>, such as<code class="literal"> Sprite, MovieClip</code>, and<code class="literal"> Stage.</code>
<a id="id422" class="indexterm"/>
</p><p>In this recipe, we took advantage of the gesture input mode to listen for and respond to<code class="literal"> TransformGestureEvent.GESTURE_SWIPE</code>.</p><p>Support for gesture-based input was enabled with the following line of code:</p><div><pre class="programlisting">Multitouch.inputMode = MultitouchInputMode.GESTURE;
</pre></div><p>A listener was then added for the<code class="literal"> GESTURE_SWIPE</code> event:<a id="id423" class="indexterm"/>
</p><div><pre class="programlisting">stage.addEventListener(TransformGestureEvent.GESTURE_SWIPE, swipe);
</pre></div><p>Notice the listener was actually added to the stage, allowing the user to swipe anywhere on screen and not just on the<code class="literal"> content</code> movie clip.</p><p>It is within the<code class="literal"> swipe()</code> handler where we respond to the user's swipe gesture and slide the<code class="literal"> content</code> movie clip either to its far-left or far-right.</p><p>To decide which direction to slide the movie clip, we inspect the<code class="literal"> TransformGestureEvent</code> object's<code class="literal"> offsetX</code> property. A value of<code class="literal"> 1</code> indicates that the user swiped to the right, whereas a value of<code class="literal"> -1</code> indicates the user swiped to the left. You can see the code for this highlighted as follows:<a id="id424" class="indexterm"/>
</p><div><pre class="programlisting">private function swipe(e:TransformGestureEvent):void {
var t:Tween;
if(e.offsetX == -1)
{
t = new Tween(content, "x",
Sine.easeOut, content.x, -465, 0.25, true);
}
else if(e.offsetX == 1)
{
t = new Tween(content, "x",
Sine.easeOut, content.x, -35, 0.25, true);
}
}
</pre></div><p>Finally the actual scrolling of the content is performed. The<code class="literal"> fl.transitions.Tween</code> class is used to slide the<code class="literal"> content</code> movie clip into position. To perform a gradual acceleration and deceleration during the sliding transition, the<code class="literal"> fl.motion.easing.Sine</code> class was used. Refer to Adobe Community Help for more information regarding these two classes.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>There's more...</h2></div></div></div><p>The following is one more property of<code class="literal"> TransformGestureEvent</code> that is relevant to swipe gestures.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec18"/>Swiping vertically</h3></div></div></div><p>Although it wasn't covered in this recipe's example code, you can just as easily detect a vertical swipe by querying the event's<code class="literal"> offsetY</code> property. A value of<code class="literal"> -1</code> will be returned for an upwards swipe, whereas<code class="literal"> 1</code> will be returned for a downwards swipe.<a id="id425" class="indexterm"/>
</p><p>Although both horizontal and vertical swiping motions are represented by separate properties, AIR for iOS does not support diagonal swiping gestures. A user can either swipe horizontally or vertically.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec29"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Setting the gesture input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Panning an object</em><a id="id426" class="indexterm"/></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec08"/>Panning an object</h1></div></div></div><p>Given the size constraints of screens on iOS devices, such as the iPhone and iPod touch, a user may need to pan or scroll to reveal content that is sitting out of view. The Flash platform provides the<code class="literal"> TransformGestureEvent.GESTURE_PAN</code> event that you can listen for in order to detect a pan gesture on any interactive object. The gesture is initiated by the user placing two fingers on an object then sliding them across the screen to move it.<a id="id427" class="indexterm"/>
</p><p>This recipe will show you how to take advantage of the pan gesture in your projects.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Getting ready</h2></div></div></div><p>From Flash Professional, open<code class="literal"> chapter5\recipe7\recipe.fla</code> from the book's accompanying code bundle.<a id="id428" class="indexterm"/>
</p><p>Sitting on the stage is a movie clip named<code class="literal"> bubble</code>, which is too large to fit fully on screen. We will write some ActionScript to let the user pan the movie clip in order to see parts that are hidden from view.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec31"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist"><li class="listitem">Create a document class and name it<code class="literal"> Main</code>.</li><li class="listitem">Add the following three import statements:<div><pre class="programlisting">import flash.display.MovieClip;
<strong>
import flash.events.TransformGestureEvent;
import flash.ui.Multitouch;
import flash.ui.MultitouchInputMode;
</strong>
</pre></div></li><li class="listitem">Within the constructor, set the input mode and listen for<code class="literal"> TransformGestureEvent.GESTURE_PAN:</code><div><pre class="programlisting">public function Main() {
<strong>
Multitouch.inputMode = MultitouchInputMode.GESTURE;
bubble.addEventListener(TransformGestureEvent.GESTURE_PAN, pan);
</strong>
}
</pre></div></li><li class="listitem">Write a handler for the<code class="literal"> GESTURE_PAN</code> event:<div><pre class="programlisting">private function pan(e:TransformGestureEvent):void {
<strong>bubble.x += e.offsetX;
bubble.y += e.offsetY;
</strong>
}
</pre></div></li><li class="listitem">Save the class file as<code class="literal"> Main.as</code>.</li><li class="listitem">Publish the FLA and deploy the IPA to your device.</li></ol></div><p>Touch the on-screen bubble with two fingers then slide them across the screen to pan the content.<a id="id429" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>How it works...</h2></div></div></div><p>In order to respond to a panning gesture, a listener for<code class="literal"> TransformGestureEvent.GESTURE_PAN</code> was added:<a id="id430" class="indexterm"/>
</p><div><pre class="programlisting">bubble.addEventListener(TransformGestureEvent.GESTURE_PAN,
pan);
</pre></div><p>The<code class="literal"> GESTURE_PAN</code> event is repeatedly dispatched as the user slides both fingers across the screen. The actual panning of the content takes place within the<code class="literal"> pan()</code> event handler. Here, we use the<code class="literal"> offsetX</code> and<code class="literal"> offsetY</code> properties of the<code class="literal"> TransformGestureEvent</code> object that was passed to the method:<a id="id431" class="indexterm"/>
</p><div><pre class="programlisting">private function pan(e:TransformGestureEvent):void {
bubble.x += e.offsetX;
bubble.y += e.offsetY;
}
</pre></div><p>Together, both properties provide the horizontal and vertical distance that the user's fingers have travelled since the last<code class="literal"> GESTURE_PAN</code> event. We simply use these offsets to reposition the<code class="literal"> bubble</code> movie clip.<a id="id432" class="indexterm"/>
</p><p>For more information, perform a search for<code class="literal"> flash.events.TransformGestureEvent</code> within Adobe Community Help.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>There's more...</h2></div></div></div><p>The following are a couple of final things regarding panning, including a property of the<code class="literal"> TransformGestureEvent</code> class that you may find of interest.<a id="id433" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Gesture phases</h3></div></div></div><p>Some gesture events are split into three distinct phases known as beginning, update, and end. If your application is required to respond to a gesture event's individual phase, then you can query the event's<code class="literal"> phase</code> property. Each phase is represented by a constant provided by the<code class="literal"> flash.events.GesturePhase</code> class.<a id="id434" class="indexterm"/>
</p><p>For example, when a user is panning on-screen content, the<code class="literal"> GESTURE_PAN</code> event will go through each of these phases:<a id="id435" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GesturePhase.BEGIN:</code> The user touches the screen with both fingers and starts to move them across the screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">GesturePhase.UPDATE:</code> The user is moving both fingers across the screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">GesturePhase.END:</code> The user lifts one or both fingers from the screen</li></ul></div><p>Let us look at a simple example where the<code class="literal"> bubble</code> movie clip from this recipe is expanded in size at the beginning of a gesture phase, then shrinks back to its original size at the end. During the update phase, the user will be able to pan the content as before:</p><div><pre class="programlisting">private function pan(e:TransformGestureEvent):void {
if(e.phase == GesturePhase.BEGIN)
{
bubble.scaleX += 0.2;
bubble.scaleY += 0.2;
}
else if(e.phase == GesturePhase.END)
{
bubble.scaleX -= 0.2;
bubble.scaleY -= 0.2;
}
else if(e.phase == GesturePhase.UPDATE)
{
bubble.x += e.offsetX;
bubble.y += e.offsetY;
}
}
</pre></div><p>Make the changes to your code and add an import statement for<code class="literal"> flash.events.GesturePhase</code>. Deploy the IPA to your device and try panning the on-screen content to get a feel of it when each of the gesture's phases occur.</p><div><h3 class="title"><a id="note34"/>Note</h3><p>You can carry your code from this recipe into the next. If you have made the changes above, then remove them before continuing as they aren't required.</p></div><p>Neither the swipe nor two-finger tap gesture have multiple phases. When working with either of these gestures, the<code class="literal"> phase</code> property will always return<code class="literal"> GesturePhase.ALL</code>.<a id="id436" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec20"/>Single finger panning</h3></div></div></div><p>The<code class="literal"> GESTURE_PAN</code> event only detects panning that is initiated and controlled using two fingers. Single finger panning, which is the expected behavior on iOS, can be achieved using the<code class="literal"> startTouchDrag()</code> and<code class="literal"> stopTouchDrag()</code> methods provided by<code class="literal"> flash.display.Sprite</code>. For details refer to the<em> Dragging multiple display objects</em> recipe earlier in this chapter.<a id="id437" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec34"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Setting the gesture input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Dragging multiple display objects</em></li><li class="listitem" style="list-style-type: disc"><em>Rotating an object</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec09"/>Rotating an object</h1></div></div></div><p>Rotation is another popular gesture used within iOS apps. It is performed by placing two fingers on your device's screen and rotating either one contact point around the other, or both around each other. To allow the rotation of content, you can listen for and respond to the<code class="literal"> TransformGestureEvent.GESTURE_ROTATE</code> event.<a id="id438" class="indexterm"/>
</p><p>We will continue from the<em> Panning an object</em> recipe and add the ability to rotate the on-screen content.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Getting ready</h2></div></div></div><p>If you haven't already done so, complete the<em> Panning an object</em> recipe before proceeding.</p><p>You can continue to work with the code you wrote during that recipe. Alternatively, open<code class="literal"> chapter5\recipe8\recipe.fla</code> from the book's accompanying code bundle and work from there. You will also find the FLA's document class in the same folder.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec36"/>How to do it...</h2></div></div></div><p>Perform the following steps within the FLA's document class:<a id="id439" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Within the constructor, listen for<code class="literal"> TransformGestureEvent.GESTURE_ROTATE:</code><div><pre class="programlisting">public function Main() {
Multitouch.inputMode = MultitouchInputMode.GESTURE;
bubble.addEventListener(TransformGestureEvent.GESTURE_PAN, pan);
<strong>bubble.addEventListener(TransformGestureEvent.GESTURE_ROTATE, rotate);
</strong>
}
</pre></div></li><li class="listitem">Add a handler that responds to the event:<div><pre class="programlisting">private function rotate(e:TransformGestureEvent):void {
bubble.rotation += e.rotation;
}
</pre></div></li><li class="listitem">Save your changes.<a id="id440" class="indexterm"/></li><li class="listitem">Publish the FLA and test it on your device.</li></ol></div><p>You should now be able to rotate the on-screen content as well as being able to pan it.</p><div><h3 class="title"><a id="note35"/>Note</h3><p>If you are testing on an older device, then you may find that the app performs poorly with the frame rate falling quite short of its target. This will be particularly true if you are developing with Flash Professional CS5. Don't worry; there are ways to dramatically improve the performance, which we will cover in<a class="link" href="ch06.html" title="Chapter 6. Graphics and Hardware Acceleration"> Chapter 6</a>,<em>Graphics and Hardware Acceleration.</em></p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec37"/>How it works...</h2></div></div></div><p>Only a few simple steps were required to add rotation support.<a id="id441" class="indexterm"/>
</p><p>First, a listener for the<code class="literal"> TransformGestureEvent.GESTURE_ROTATE</code> event was added to the<code class="literal"> bubble</code> movie clip:<a id="id442" class="indexterm"/>
</p><div><pre class="programlisting">bubble.addEventListener(TransformGestureEvent.GESTURE_ROTATE,
rotate);
</pre></div><p>Finally, the actual event handler queried the event's<code class="literal"> rotation</code> property in order to determine how much to rotate the movie clip:</p><div><pre class="programlisting">private function rotate(e:TransformGestureEvent):void {
<strong>bubble.rotation += e.rotation;
</strong>
}
</pre></div><p>The<code class="literal"> rotation</code> property specifies the change in rotation, measured in degrees, since the previous gesture event. This value was then added to the bubble's current angle of rotation in order to correctly update it.<a id="id443" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec38"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Setting the gesture input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Zooming an object</em></li><li class="listitem" style="list-style-type: disc"><em>Using Cache as Bitmap Matrix, <a class="link" href="ch06.html" title="Chapter 6. Graphics and Hardware Acceleration">Chapter 6</a></em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec10"/>Zooming an object</h1></div></div></div><p>The final gesture we will look at in this chapter is "zoom", which allows a user to scale content. It is typically performed by pinching the screen with two fingers. Drawing your fingers closer will zoom-out while pulling them apart will zoom-in. The Flash platform provides the<code class="literal"> TransformGestureEvent.GESTURE_ZOOM</code> event that you can listen for and respond to.<a id="id444" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Getting ready</h2></div></div></div><p>If you haven't already done so, complete the<em> Rotating an object</em> recipe before performing this one.</p><p>You can continue to work with the code you wrote during that recipe. Alternatively, work from the FLA and document class found in the book's accompanying code bundle at<code class="literal"> chapter5\recipe9\</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec40"/>How to do it...</h2></div></div></div><p>Make these changes to the FLA's document class:</p><div><ol class="orderedlist"><li class="listitem">Within the constructor, listen for the<code class="literal"> GESTURE_ZOOM</code> event:<a id="id445" class="indexterm"/><div><pre class="programlisting">public function Main() {
Multitouch.inputMode = MultitouchInputMode.GESTURE;
bubble.addEventListener(TransformGestureEvent.GESTURE_PAN, pan);
bubble.addEventListener(TransformGestureEvent.GESTURE_ROTATE, rotate);
<strong>bubble.addEventListener(TransformGestureEvent.GESTURE_ZOOM, zoom);
</strong>
}
</pre></div></li><li class="listitem">Now, add an event handler for the zoom gesture:<div><pre class="programlisting">private function zoom(e:TransformGestureEvent):void {
bubble.scaleX *= e.scaleX;
bubble.scaleY *= e.scaleY;
}
</pre></div></li><li class="listitem">Save the class file.</li><li class="listitem">Publish the FLA and deploy the IPA to your device.</li></ol></div><p>You should now be able to pan, rotate, and zoom the bubble using the gestures provided by the Flash platform.<a id="id446" class="indexterm"/>
</p><div><h3 class="title"><a id="note36"/>Note</h3><p>If you are testing on an older device, then you may find that the app performs poorly with the frame rate falling quite short of its target. This will be particularly true if you are developing with Flash Professional CS5. Don't worry; there are ways to dramatically improve the performance, which we will cover in<a class="link" href="ch06.html" title="Chapter 6. Graphics and Hardware Acceleration"> Chapter 6</a>,<em>Graphics and Hardware Acceleration.</em></p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec41"/>How it works...</h2></div></div></div><p>As with the other gestures covered in this chapter, implementing pinch zoom isn't difficult.<a id="id447" class="indexterm"/>
</p><p>An event listener for<code class="literal"> TransformGestureEvent.GESTURE_ZOOM</code> was added followed by the event's handler, which was responsible for actually zooming into the<code class="literal"> bubble</code> movie clip.</p><p>The following is the line of code that was used to register the listener:</p><div><pre class="programlisting">bubble.addEventListener(TransformGestureEvent.GESTURE_ZOOM, zoom);
</pre></div><p>And you can see the bubble's<code class="literal"> scaleX</code> and<code class="literal"> scaleY</code> properties being set within the<code class="literal"> zoom()</code> event handler as follows:</p><div><pre class="programlisting">private function zoom(e:TransformGestureEvent):void {
bubble.scaleX *= e.scaleX;
bubble.scaleY *= e.scaleY;
}
</pre></div><p>The<code class="literal"> TransformGestureEvent</code> object's<code class="literal"> scaleX</code> and<code class="literal"> scaleY</code> properties specify the change in horizontal and vertical scale since the previous gesture event. To apply these values to a display object, simply multiply the display object's<code class="literal"> scaleX</code> and<code class="literal"> scaleY</code> properties with the event object's<code class="literal"> scaleX</code> and<code class="literal"> scaleY</code> properties respectively. You can see this being done in the code earlier.<a id="id448" class="indexterm"/>
</p><p>It may not be immediately obvious, but the bubble's library symbol has its registration point set at its center. When scaling content, make sure the artwork within your container clip is centered otherwise the user may be presented with unexpected behavior when performing a zoom gesture.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Setting the gesture input mode</em></li><li class="listitem" style="list-style-type: disc"><em>Using Cache as Bitmap Matrix, <a class="link" href="ch06.html" title="Chapter 6. Graphics and Hardware Acceleration">Chapter 6</a></em></li></ul></div></div></div></body></html>