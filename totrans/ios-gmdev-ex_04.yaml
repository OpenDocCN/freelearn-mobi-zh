- en: Chapter 4. Nodes in Sprite Kit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Sprite Kit中的节点
- en: In the last chapter, we learnt about how to use sprites in a game in various
    ways. We discussed about the physical properties of sprites, textures of sprites,
    and various other properties, such as color property, lighting, shader, and so
    on. We also learned about working with texture objects and had an introduction
    to texture atlases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在游戏中以各种方式使用精灵。我们讨论了精灵的物理属性、精灵的纹理以及诸如颜色属性、光照、着色器等各种其他属性。我们还学习了与纹理对象一起工作，并对纹理图集进行了介绍。
- en: In the previous chapter, we implemented the `SKSprite` class which is a subclass
    of the `SKNode` class; that's why `SKSprite` is a node itself, inheriting `SKNode`
    properties. In this chapter, we will study about nodes, which play an important
    role in understanding the tree structure of a game. Further, we will discuss about
    types of nodes in the Sprite Kit and their uses in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了`SKSprite`类，它是`SKNode`类的子类；这就是为什么`SKSprite`本身就是一个节点，继承了`SKNode`属性。在本章中，我们将研究节点，它们在理解游戏树结构中起着重要作用。此外，我们将详细讨论Sprite
    Kit中的节点类型及其用途。
- en: All you need to know about nodes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要了解的所有关于节点的内容
- en: We have discussed many things about nodes so far. Almost everything you are
    making in a game with Sprite Kit is a node. Scenes that we are presenting to view
    are instances of the `SKScene` class, which is a subclass of the `SKEffectNode`
    class, which is itself a subclass of the `SKNode` class. Indirectly, `SKScene`
    is a subclass of the `SKNode` class.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了许多关于节点的内容。几乎你在使用Sprite Kit制作的游戏中所做的每一件事都是一个节点。我们展示给查看的场景是`SKScene`类的实例，它是`SKEffectNode`类的子类，而`SKEffectNode`类本身又是`SKNode`类的子类。间接地，`SKScene`是`SKNode`类的子类。
- en: As a game follows the node tree formation, a scene acts like a root node and
    the other nodes are used as its children. It should be remembered that although
    `SKNode` is a base class for the node you see in a scene, it itself does not draw
    anything. It only provides some basic features to its subclass nodes. All the
    visual content we see in a Sprite Kit made game, is drawn by using the appropriate
    `SKNode` subclasses.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏遵循节点树结构，场景就像一个根节点，其他节点则用作其子节点。应该记住，尽管`SKNode`是场景中看到的节点的基类，但它本身并不绘制任何内容。它只为它的子节点提供一些基本功能。我们在Sprite
    Kit制作的游戏中看到的所有视觉内容，都是通过使用适当的`SKNode`子类来绘制的。
- en: 'Following are some subclasses of `SKNode` classes, which are used for different
    behaviors in a Sprite Kit-based game:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`SKNode`类的子类，它们用于Sprite Kit游戏中的不同行为：
- en: '`SKSpriteNode`: This class is used to instantiate a texture sprite in the game;
    this is a familiar node class referred to frequently in [Chapter 3](ch03.html
    "Chapter 3. Sprites"), *Sprites*. `SKVideoNode`, this class is used to play video
    content in a scene.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKSpriteNode`：这个类用于在游戏中实例化纹理精灵；这是在[第3章](ch03.html "第3章。精灵") *精灵* 中经常提到的熟悉节点类。`SKVideoNode`，这个类用于在场景中播放视频内容。'
- en: '`SKLabelNode`: This class is used to draw labels in a game, with many customizing
    options, such as font type, font size, font color, and so on.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKLabelNode`：这个类用于在游戏中绘制标签，具有许多自定义选项，例如字体类型、字体大小、字体颜色等。'
- en: '`SKShapeNode`: This class is used to make a shape based on a path, at run time.
    For example, drawing a line or making a drawing game.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKShapeNode`：这个类用于在运行时基于路径创建形状。例如，绘制线条或制作绘图游戏。'
- en: '`SKEmitterNode`: This class is used for emitting particle effects in a scene,
    with many options, such as position, number of particles, color, and so on.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKEmitterNode`：这个类用于在场景中发射粒子效果，具有许多选项，例如位置、粒子数量、颜色等。'
- en: '`SKCropNode`: This class is basically used for cropping its child nodes, using
    a mask. Using this, you can selectively block areas of a layer.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKCropNode`：这个类基本上用于使用遮罩裁剪其子节点。使用它，你可以选择性地屏蔽图层的一部分。'
- en: '`SKEffectNode`: `SKEffectNode` is the parent of the `SKScene` class and the
    subclass of the `SKNode` class. It is used for applying an image filter to its
    children.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKEffectNode`：`SKEffectNode`是`SKScene`类的父类，也是`SKNode`类的子类。它用于对其子节点应用图像滤镜。'
- en: '`SKLightNode`: `SKLightNode` class is used to make light and shadow effects
    in scene.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKLightNode`：`SKLightNode`类用于在场景中创建光和阴影效果。'
- en: '`SKFieldNode`: This is a useful feature of Sprite Kit. You can define a portion
    of scene with some physical properties, for example, in space game, having a gravity
    effect on a black hole, which attracts the things which are nearby.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKFieldNode`：这是Sprite Kit的一个有用功能。你可以定义场景的一部分并赋予其一些物理属性，例如在太空游戏中，对黑洞施加引力效果，吸引附近的物体。'
- en: 'So, these are the basic subclasses of `SKNode` which are used frequently in
    Sprite Kit. `SKNode` provides some basic properties to its subclasses, which are
    used to view a node inside a scene, such as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些都是 Sprite Kit 中常用到的 `SKNode` 的基本子类。`SKNode` 为其子类提供了一些基本属性，用于在场景中查看节点，例如：
- en: '`position`: This sets up the position of a node in a scene'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`: 这设置了场景中节点的位置'
- en: '`xScale`: This scales in the width of a node'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xScale`: 这在节点的宽度上进行缩放'
- en: '`yScale`: This scales in the height of a node'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yScale`: 这在节点的高度上进行缩放'
- en: '`zRotation`: This facilitates the rotation of a node in a clockwise or anti-clockwise
    direction'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zRotation`: 这有助于节点按顺时针或逆时针方向旋转'
- en: '`frame`: `frame` is a rectangle containing the nodes content along with its
    x-scale, y-scale and z-rotation properties, ignoring the nodes children'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame`: `frame` 是一个包含节点内容的矩形，包括其 x 缩放、y 缩放和 z 旋转属性，忽略节点的子节点'
- en: We know that the `SKNode` class does not draw anything by itself. So, what is
    the use of it? Well, we can use `SKNode` instances to manage our other nodes in
    different layers separately, or we can use them to manage different nodes in the
    same layer. Let's take a look at how we can do this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `SKNode` 类本身不绘制任何内容。那么，它的用途是什么呢？嗯，我们可以使用 `SKNode` 实例来分别管理不同层的其他节点，或者我们可以使用它们来管理同一层中的不同节点。让我们看看我们如何做到这一点。
- en: Using the SKNode object in the game
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游戏中使用 SKNode 对象
- en: Now, we will discover what the various aspects of `SKNode` are used for. Say
    you have to make a body from different parts of sprites, such as a car. You can
    make it from sprites of wheels and body. The wheels and body of a car run in synchronization
    with each other, so that one controls their action together, rather than manage
    each part separately. This can be done by adding them as a child of the `SKNode`
    class object and updating this node to control the activity of the car.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将发现 `SKNode` 的各种方面用途。比如说，你需要从精灵的不同部分制作一个身体，比如一辆车。你可以从车轮和车身精灵制作它。车轮和车身的车在同步运行，所以一个可以控制它们的动作，而不是分别管理每个部分。这可以通过将它们添加为
    `SKNode` 类对象的子节点并更新此节点来控制汽车的活动来实现。
- en: 'The `SKNode` class object can be used for layering purposes in a game. Suppose
    we have three layers in our game: the foreground layer, which represents foreground
    sprites, the middle layer, which represents the middle sprites, and the background
    layer which represents background sprites.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKNode` 类对象可以用作游戏中分层的目的。假设我们在游戏中有三个层：前景层，代表前景精灵；中间层，代表中间精灵；背景层，代表背景精灵。'
- en: If we want a parallax effect in our game, we will have to update each sprite's
    position separately or we can make three `SKNode` objects, referring to each layer,
    and add the sprites to their respective nodes. Now we have to update only these
    three nodes' position and the sprites will update their position automatically.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在游戏中实现视差效果，我们必须分别更新每个精灵的位置，或者我们可以制作三个 `SKNode` 对象，分别对应每一层，并将精灵添加到相应的节点中。现在我们只需要更新这三个节点的位置，精灵将自动更新它们的位置。
- en: The `SKNode` class can be used to make some kind of check point in a game, which
    is hidden but performs or triggers some event when a player crosses them, such
    as a level end, bonus, or death trap.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKNode` 类可以用作游戏中的一种检查点，它是隐藏的，但在玩家穿过它们时执行或触发某些事件，例如关卡结束、奖励或死亡陷阱。'
- en: We can remove or add the whole sub tree inside a node and perform the necessary
    functions, such as rotating, scaling, positioning, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在节点内部移除或添加整个子树，并执行必要的功能，如旋转、缩放、定位等。
- en: Well, as we described that we can use the `SKNode` object as checkpoints in
    the game, it is important to recognize them in your scene. So, how we do that?
    Well the `SKNode` class provides a property for this. Let's find out more about
    it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如我们描述的那样，我们可以使用 `SKNode` 对象作为游戏中的检查点，因此在你的场景中识别它们是很重要的。那么，我们该如何做呢？嗯，`SKNode`
    类提供了一个属性来实现这一点。让我们更深入地了解它。
- en: Recognizing a node
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别一个节点
- en: 'The `SKNode` class provides a property with a name, to recognize the correct
    node. It takes string as a parameter. Either you can search a node by its name
    or you can use one of the two methods provided by `SKNode`, which are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKNode` 类提供了一个带有名称的属性，用于识别正确的节点。它接受字符串作为参数。你可以通过名称搜索节点，或者可以使用 `SKNode` 提供的两个方法之一，如下所示：'
- en: '`func childNodeWithName(name:String) -> SKNode`: This function takes the name
    string as a parameter, and if it finds a node with a specific name, it returns
    that node or else it returns nil. If there is more than one node sharing the same
    name, it will return the first node in the search.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func childNodeWithName(name:String) -> SKNode`: 这个函数接受一个字符串作为参数，如果找到一个具有特定名称的节点，则返回该节点，否则返回nil。如果有多个节点具有相同的名称，则返回搜索中的第一个节点。'
- en: '`func enumerateChildNodesWithName(name:String, usingBlock:((SKNode!,UnsafeMutablePointer<ObjCBool>)->Void)!)`:
    When you need all the nodes sharing the same name, use this function. This function
    takes the name and block as a parameter. In `usingBlock`, you need to provide
    two parameters. One matching node, and the other a pointer of type Boolean. In
    our game, if you remember, we used the `name` property inside `PlayButton` to
    recognize the node when a user taps on it. It''s a very useful property to search
    for the desired node.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func enumerateChildNodesWithName(name:String, usingBlock:((SKNode!,UnsafeMutablePointer<ObjCBool>)->Void)!)`:
    当你需要所有具有相同名称的节点时，请使用此函数。此函数接受名称和块作为参数。在`usingBlock`中，您需要提供两个参数。一个是匹配的节点，另一个是布尔类型的指针。在我们的游戏中，如果您还记得，我们使用`PlayButton`中的`name`属性来识别当用户点击时识别的节点。这是一个非常有用的属性，用于搜索所需的节点。'
- en: So, let's have a quick look at other properties or methods of the `SKNode` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们快速查看`SKNode`类的其他属性或方法。
- en: Initializing a node
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化一个节点
- en: There are two initializers to make an instance of `SKNode`. Both are available
    in iOS 8.0 or later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个初始化器可以创建`SKNode`的实例。这两个初始化器在iOS 8.0或更高版本中都是可用的。
- en: '`convenience init (fileNamed filename: String)`: This initializer is used for
    making a node by loading an archive file from main bundle. For this, you have
    to pass a file name with an `sks` extension in the main bundle.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convenience init (fileNamed filename: String)`: 这个初始化器用于通过从主包中加载存档文件来创建节点。为此，您必须在主包中传递一个具有`sks`扩展名的文件名。'
- en: '`init()`: It is used to make a simple node without any parameter. It is useful
    for layering purposes in a game.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init()`: 它用于创建一个不带任何参数的简单节点。这在游戏中的分层用途中非常有用。'
- en: As we already discussed the positioning of a node, let's discuss some functions
    and properties that are used to build a node tree.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论过的节点的定位，让我们讨论一些用于构建节点树的函数和属性。
- en: Building a node tree
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建节点树
- en: '`SKNode` provides some functions and properties to work with a node tree. Following
    are some of the functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKNode`提供了一些函数和属性来处理节点树。以下是一些函数：'
- en: '`addChild(node:SKNode)`: This is a very common function and is used mostly
    to make a node tree structure. We already used it to add nodes to scenes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addChild(node:SKNode)`: 这是一个非常常见的函数，主要用于创建节点树结构。我们之前已经用它向场景中添加节点。'
- en: '`insertChild(node:SKNode,atIndex index: Int)`: This is used when you have to
    insert a child in a specific position in the array.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insertChild(node:SKNode,atIndex index: Int)`: 这用于在数组中插入一个子节点到特定位置。'
- en: '`removeFromParent()`: This simply removes a node from its parent.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeFromParent()`: 这只是简单地从一个节点中移除。'
- en: '`removeAllChildren()`: This is used when you have to clear all the children
    in a node.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAllChildren()`: 这用于清除节点中的所有子节点。'
- en: '`removeChildrenInArray(nodes:[AnyObject]!)`: This takes an array of `SKNode`
    objects and removes it from the receiving node.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeChildrenInArray(nodes:[AnyObject]!)`: 它接受一个`SKNode`对象的数组，并将其从接收节点中移除。'
- en: '`inParentHierarchy(parent:SKNode) -> Bool`: It takes an `SKNode` object to
    check as a parent of the receiving node, and returns a Boolean value according
    to that condition.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inParentHierarchy(parent:SKNode) -> Bool`: 它接受一个`SKNode`对象作为接收节点的父节点进行检查，并返回一个布尔值来表示该条件。'
- en: 'There are some useful properties used in a node tree, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点树中，有一些有用的属性，如下所示：
- en: '`children`: This is a read only property. It contains the receiving node''s
    children in the array.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`children`: 这是一个只读属性。它包含接收节点在数组中的子节点。'
- en: '`parent`: This is also a read only property. It contain the reference of the
    parent of the receiving node, and if there is none, then it returns nil.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`: 这也是一个只读属性。它包含接收节点的父节点的引用，如果没有父节点，则返回nil。'
- en: '`scene`: This too is a read only property. If the node is embedded in the scene,
    it will contain the reference of the scene, otherwise nil.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scene`: 这也是一个只读属性。如果节点嵌入在场景中，它将包含场景的引用，否则为nil。'
- en: In a game, we need some specific task on a node, such as changing its position
    from one point to another, changing sprites in a sequence, and so on. These tasks
    are done using actions on node. Let's talk about them now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们需要对节点执行一些特定任务，例如将其位置从一个点移动到另一个点，按顺序更改精灵等。这些任务是通过节点上的动作完成的。现在让我们来谈谈它们。
- en: Actions on a node tree
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点树上的动作
- en: Actions are required for some specific tasks in a game. For this, the `SKNode`
    class provides some basic functions, which are as follows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的一些特定任务需要动作。为此，`SKNode`类提供了一些基本函数，如下所示。
- en: '`runAction(action:SKAction!)`: This function takes an `SKAction` class object
    as a parameter and performs the action on the receiving node.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAction(action:SKAction!)`: 此函数接受一个`SKAction`类对象作为参数，并在接收节点上执行该动作。'
- en: '`runAction(action:SKAction!,completion block: (() -> Void)!)`: This function
    takes an `SKAction` class object and a compilation block as object. When the action
    completes, it calls the block.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAction(action:SKAction!,completion block: (() -> Void)!)`: 此函数接受一个`SKAction`类对象和一个编译块作为对象。当动作完成时，它调用该块。'
- en: '`runAction(action:SKAction,withKey key:String!)`: This function takes an `SKAction`
    class object and a unique key, to identify this action and perform it on the receiving
    node.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAction(action:SKAction,withKey key:String!)`: 此函数接受一个`SKAction`类对象和一个唯一键，以识别此动作并在接收节点上执行。'
- en: '`actionForKey(key:String) -> SKAction?`: This takes a `String` key as a parameter
    and returns an associative `SKAction` object for that key identifier. This happens
    if it exists, otherwise it returns nil.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionForKey(key:String) -> SKAction?`: 它接受一个`String`键作为参数，并返回一个关联的`SKAction`对象，用于该键标识符。如果存在，则发生这种情况，否则返回nil。'
- en: '`hasActions() -> Bool`: Through this action, if the node has any executing
    action, it returns `true`, or else `false`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasActions() -> Bool`: 通过此操作，如果节点有任何正在执行的动作，则返回`true`，否则返回`false`。'
- en: '`removeAllActions()`: This function removes all actions from the receiving
    node.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAllActions()`: 此函数从接收节点中移除所有动作。'
- en: '`removeActionForKey(key:String)`: This takes `String` name as key and removes
    an action associated with that key, if it exists.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeActionForKey(key:String)`: 它接受`String`名称作为键，并移除与该键关联的动作（如果存在）。'
- en: 'Some useful properties to control these actions are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 控制这些动作的一些有用属性如下：
- en: '`speed`: This is used to speed up or speed down the action motion. The default
    value is `1.0` to run at normal speed; with increasing value, speed increases.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speed`: 这用于加快或减慢动作运动的速度。默认值为`1.0`以正常速度运行；随着值的增加，速度增加。'
- en: '`paused`: This Boolean value determines whether an action on the node should
    be paused or resumed.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paused`: 这个布尔值确定节点上的动作是否应该暂停或恢复。'
- en: Sometimes, we require changing a point coordinate system according to a node
    inside a scene. The `SKNode` class provides two functions to interchange a point's
    coordinate system with respect to a node in a scene. Let's talk about them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要根据场景中的节点更改一个点坐标系统。`SKNode`类提供了两个函数来交换一个点相对于场景中节点的坐标系统。让我们来谈谈它们。
- en: The coordinate system of a node
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点的坐标系
- en: 'We can convert a point with respect to the coordinate system of any node tree.
    The functions to do that, are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以转换任何节点树的坐标系中的点。执行此操作的功能如下：
- en: '`convertPoint(point:CGPoint, fromNode node : SKNode) -> CGPoint`: This takes
    a point in another node''s coordinate system and the other node as its parameter,
    and returns a converted point according to the receiving node''s coordinate system.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convertPoint(point:CGPoint, fromNode node : SKNode) -> CGPoint`: 它接受另一个节点坐标系统中的一个点以及另一个节点作为其参数，并返回根据接收节点坐标系统转换后的点。'
- en: '`convertPoint(point:CGPoint, toNode node:SKNode) ->CGPoint`: It takes a point
    in the receiving node''s coordinate system and the other nodes in the node tree
    as its parameters, and returns the same point converted according to the other
    node''s coordinate system.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convertPoint(point:CGPoint, toNode node:SKNode) ->CGPoint`: 它接受接收节点坐标系中的一个点以及节点树中的其他节点作为其参数，并返回根据其他节点坐标系转换后的相同点。'
- en: We can also determine if a point is inside a node's area or not.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以确定一个点是否在节点区域内或不在。
- en: '`containsPoint(p:CGPoint) -> Bool`: This returns the Boolean value according
    to the position of a point inside or outside of a receiving node''s bounding box.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsPoint(p:CGPoint) -> Bool`: 它根据点的位置返回布尔值，该点位于接收节点的边界框内部或外部。'
- en: '`nodeAtPoint(p:CGPoint) -> SKNode`: This returns the deepest descendant node
    that intersects the point. If that is not there, then it returns the receiver
    node.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodeAtPoint(p:CGPoint) -> SKNode`：此函数返回与点相交的最深子节点。如果没有这样的节点，则返回接收节点。'
- en: '`nodesAtPoint(p:CGPoint) -> [AnyObject]`: This returns an array of all the
    `SKNode` objects in the subtree that intersect the point. If no nodes intersect
    the point, an empty array is returned.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodesAtPoint(p:CGPoint) -> [AnyObject]`：此函数返回一个数组，包含所有在子树中与点相交的 `SKNode` 对象。如果没有节点与点相交，则返回一个空数组。'
- en: Apart from these, the `SKNode` class provides some other functions and properties
    too. Let's talk about them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些之外，`SKNode` 类还提供了一些其他函数和属性。让我们来谈谈它们。
- en: Other functions and properties
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他函数和属性
- en: 'Some other functions and properties of the `SKNode` class are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKNode` 类的其他一些函数和属性如下：'
- en: '`intersectsNode(node:SKNode) -> Bool`: As the name suggests, it returns a Boolean
    value according to the intersection of the receiving node and another node from
    the function parameter.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersectsNode(node:SKNode) -> Bool`：正如其名所示，它根据接收节点与函数参数中的另一个节点的交集返回一个布尔值。'
- en: '`physicsBody`: It is a property of the `SKNode` class. The default value is
    nil, which means that this node will not take part in any physical simulation
    in the scene. If it contains any physical body, then it will change its position
    and rotation in accordance with the physical simulation in the scene.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`physicsBody`：它是 `SKNode` 类的一个属性。默认值是 nil，这意味着此节点不会参与场景中的任何物理模拟。如果它包含任何物理体，则其位置和旋转将根据场景中的物理模拟进行更改。'
- en: '`userData : NSMutableDictionary?`: The `userData` property is used to store
    data for a node in a dictionary form. We can store position, rotation, and many
    custom data sets about the node inside it.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userData : NSMutableDictionary?`：`userData` 属性用于以字典形式存储节点的数据。我们可以在其中存储位置、旋转以及许多关于节点的自定义数据集。'
- en: '`constraints: [AnyObject]?`: It contains an array of constraints `SKConstraint`
    objects to the receiving node. Constraints are used to limit the position or rotation
    of a node inside a scene.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraints: [AnyObject]?`：它包含一个约束 `SKConstraint` 对象数组到接收节点。约束用于限制节点在场景内的位置或旋转。'
- en: '`reachConstraints: SKReachConstraints?`: This is basically used to make restricted
    values for the receiving node by making an `SKReachConstraints` object. For example,
    to make joints move in a human body.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reachConstraints: SKReachConstraints?`：这基本上用于通过创建一个 `SKReachConstraints` 对象来为接收节点设置限制值。例如，使关节在人体中移动。'
- en: 'Node blending modes: The `SKNode` class declares an `enum SKBlendMode` of the
    `int` type to blend the receiving node''s color by using source and destination
    pixel colors. The constant''s used for this are as follows:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点混合模式：`SKNode` 类声明了一个 `enum SKBlendMode` 的 `int` 类型，用于通过源像素颜色和目标像素颜色混合接收节点的颜色。用于此的常量如下：
- en: '`Alpha`: It is used to blend source and destination colors by multiplying the
    source alpha value'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alpha`：用于通过乘以源 alpha 值混合源颜色和目标颜色'
- en: '`Add`: It is used to add the source and destination colors'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add`：用于将源颜色和目标颜色相加'
- en: '`Subtract`: It is used to subtract the source color from the destination color'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subtract`：用于从目标颜色中减去源颜色'
- en: '`Multiply`: It is used to multiply the source color by the destination color'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Multiply`：用于将源颜色乘以目标颜色'
- en: '`MultiplyX2`: It is used to multiply the source color by the destination color,
    and after that, the resulting color is doubled'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiplyX2`：用于将源颜色乘以目标颜色，然后双倍结果颜色'
- en: '`Screen`: It is used to multiply the inverted source and the destination color
    respectively and it then inverts the final result color'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Screen`：用于分别乘以反转的源颜色和目标颜色，然后反转最终结果颜色'
- en: '`Replace`: It is used to replace the destination color by source color'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Replace`：用于用源颜色替换目标颜色'
- en: '`calculateAccumulatedFrame()->CGRect`: We know that a node does not draw anything
    by itself, but if a node has descendants that draw content, then we may be required
    to know the overall frame size of that node. This function calculates the frame
    that contains the content of the receiver node and all of its descendants.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateAccumulatedFrame()->CGRect`：我们知道节点本身不会绘制任何内容，但如果节点有绘制内容的子节点，那么我们可能需要知道该节点的整体框架大小。此函数计算包含接收节点及其所有子节点内容的框架。'
- en: 'Now, we are ready to see some basic `SKNode` subclasses in action. The classes
    we are going to discuss are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备看看一些基本的 `SKNode` 子类在实际中的应用。我们将讨论的类如下：
- en: '`SKLabelNode`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKLabelNode`'
- en: '`SKCropNode`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKCropNode`'
- en: '`SKShapeNode`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKShapeNode`'
- en: '`SKEmitterNode`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKEmitterNode`'
- en: '`SKLightNode`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKLightNode`'
- en: '`SKVideoNode`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKVideoNode`'
- en: To study these classes, we are going to create six different `SKScene` subclasses
    in our project, so that we can learn them separately.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究这些类，我们将在项目中创建六个不同的 `SKScene` 子类，这样我们就可以分别学习它们。
- en: Now, having learned in detail about nodes, we can proceed further to utilize
    the concept of nodes in a game.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经详细学习了节点，我们可以进一步利用节点在游戏中的概念。
- en: Creating subclasses for our Platformer game
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的平台游戏创建子类
- en: With the theoretical understanding of nodes, one wonders how this concept is
    helpful in developing a game. To understand the development of a game using the
    concept of Nodes, we now go ahead with writing and executing code for our *Platformer*
    game.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了节点的理论知识后，人们会想知道这个概念在开发游戏中有何帮助。为了理解使用节点概念开发游戏，我们现在继续编写和执行我们的 *平台游戏* 的代码。
- en: 'Create the subclasses of different nodes in Xcode, following the given steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定的步骤在 Xcode 中创建不同节点的子类：
- en: 'From the main menu, select **New File** | **Swift** | **Save As** | **NodeMenuScene.swift**:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从主菜单中选择 **新建文件** | **Swift** | **另存为** | **NodeMenuScene.swift**:'
- en: Make sure **Platformer** is ticked as the target. Now **Create** and **Open**
    and make the `NodeMenuScene` class by subclassing `SKScene`.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将 **Platformer** 标记为目标。现在 **创建** 并 **打开**，通过继承 `SKScene` 创建 `NodeMenuScene`
    类。
- en: Following the previous same steps as, make `CropScene`, `ShapeScene`, `ParticleScene`,
    `LightScene`, and `VideoNodeScene` files, respectively.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前的相同步骤，分别创建 `CropScene`、`ShapeScene`、`ParticleScene`、`LightScene` 和 `VideoNodeScene`
    文件。
- en: 'Open the `GameViewController.swift` file and replace the `viewDidLoad` function
    by typing out the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameViewController.swift` 文件，并用以下代码替换 `viewDidLoad` 函数：
- en: '[PRE0]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we just called our `NodeMenuScene` class from the `GameViewController`
    class. Now, it's time to add some code to the `NodeMenuScene` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只是从 `GameViewController` 类中调用了我们的 `NodeMenuScene` 类。现在，是时候向 `NodeMenuScene`
    类添加一些代码了。
- en: NodeMenuScene
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NodeMenuScene
- en: 'Open the `NodeMenuScene.swift` file and type in the code as shown next. Do
    not worry about the length of the code; as this code is for creating the node
    menu screen, most of the functions are similar to creating buttons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `NodeMenuScene.swift` 文件，并输入如下所示的代码。不要担心代码的长度；因为这段代码是为了创建节点菜单屏幕，大多数函数都与创建按钮类似：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will get the following screen from the previous code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从之前的代码中获得以下屏幕：
- en: '![NodeMenuScene](img/4201_04_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![NodeMenuScene](img/4201_04_01.jpg)'
- en: The screen is obtained when we execute the NodeMenuScene.swift file
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `NodeMenuScene.swift` 文件时，我们获得了屏幕。
- en: 'In the preceding code, after `import` statements, we defined some `String`
    variables. We are going to use these variables as `Label` names in the scene .We
    also added our font name as a string variable. Inside this class, we made two
    node references: one for background and the other for those labels which we are
    going to use in this scene. We are using these two nodes to make layers in our
    game. It is best to categorize the nodes in a scene, so that we can optimize the
    code. We make an `SKTransition` object reference of the flip horizontal effect.
    You can use other transition effects too.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在 `import` 语句之后，我们定义了一些 `String` 变量。我们将使用这些变量作为场景中的 `Label` 名称。我们还添加了我们的字体名称作为一个字符串变量。在这个类内部，我们创建了两个节点引用：一个用于背景，另一个用于我们将在这个场景中使用的那些标签。我们使用这两个节点来制作游戏中的层。最好将场景中的节点分类，这样我们可以优化代码。我们创建了一个
    `SKTransition` 对象引用，用于翻转水平效果。您也可以使用其他过渡效果。
- en: Inside the `didMoveToView()` function, we just get the node and add it to our
    scene and set their `z` position.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `didMoveToView()` 函数内部，我们只是获取节点并将其添加到我们的场景中，并设置它们的 `z` 位置。
- en: Now, if we look at the `getBackgroundNode()` function, we can see that we made
    a node by the `SKNode` class instance, a background by the `SKSpriteNode` class
    instance, and then added it to the node and returned it. If you see the syntax
    of this function, you will see `-> SKNode`. It means that this function returns
    an `SKNode` object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看 `getBackgroundNode()` 函数，我们可以看到我们通过 `SKNode` 类实例创建了一个节点，通过 `SKSpriteNode`
    类实例创建了一个背景，并将其添加到节点中并返回。如果您看到这个函数的语法，您会看到 `-> SKNode`。这意味着这个函数返回一个 `SKNode` 对象。
- en: The same goes in the function, `getLabelNode()`. It also returns a node containing
    all the `SKLabelNode` class objects. We have given a font and a name to these
    labels and set the position of them in the screen. The `SKLabelNode` class is
    used to make labels in Sprite Kit with many customizable options.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 `getLabelNode()` 中也是同样的情况。它也返回一个包含所有 `SKLabelNode` 类对象的节点。我们为这些标签指定了字体和名称，并在屏幕上设置了它们的位置。`SKLabelNode`
    类用于在 Sprite Kit 中创建具有许多可定制选项的标签。
- en: In the `touchBegan()` function, we get the information on which Label is touched,
    and we then call the appropriate scene with transitions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `touchBegan()` 函数中，我们获取被触摸的标签信息，然后调用带有过渡效果的适当场景。
- en: With this, we have created a scene with the transition effect. By tapping on
    each button, you can see the transition effect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经创建了一个带有过渡效果的场景。通过点击每个按钮，你可以看到过渡效果。
- en: CropScene
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CropScene
- en: 'In this scene, we are going to use the `SKCropNode` class object. This class
    is used to mask one node on another. We are going to use our play sprite as a
    mask and our background image as an image that is to be rendered according to
    the masking area. Open the `CropScene.swift` file and type in the code, as shown
    next:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们将使用 `SKCropNode` 类对象。这个类用于在另一个节点上遮罩一个节点。我们将使用我们的游戏精灵作为遮罩，并将背景图像作为根据遮罩区域渲染的图像。打开
    `CropScene.swift` 文件，并输入以下代码，如下所示：
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will get the following screen, with the preceding code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们将得到以下屏幕：
- en: '![CropScene](img/4201_04_02.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![CropScene](img/4201_04_02.jpg)'
- en: The preceding screen is obtained when we execute the Cropscene.swift file
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Cropscene.swift 文件时，我们得到前面的屏幕。
- en: In this code, we just added a label for the back press of the `SKLabelNode`
    class object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们仅为 `SKLabelNode` 类对象的后退按压添加了一个标签。
- en: In this class, we added play image to the mask node of the `SKCropNode` object
    and added a background to this crop node. If you click on the `SKCropNode` label
    in the `NodeMenuScene`, you will see that the play image is working as a mask
    over the background image.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将游戏图像添加到 `SKCropNode` 对象的遮罩节点中，并为这个裁剪节点添加了一个背景。如果你在 `NodeMenuScene`
    中点击 `SKCropNode` 标签，你会看到游戏图像作为遮罩覆盖在背景图像上。
- en: ShapeScene
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ShapeScene
- en: 'Now, open the `ShapeScene.swift` file and add the following code to create
    the `SKShapeNode` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `ShapeScene.swift` 文件，并添加以下代码以创建 `SKShapeNode` 类：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will get the following screen with the previous code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们将得到以下屏幕：
- en: '![ShapeScene](img/4201_04_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![ShapeScene](img/4201_04_03.jpg)'
- en: This screen is obtained when we execute the ShapeScene.swift file
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 ShapeScene.swift 文件时，我们得到此屏幕。
- en: The `SKShapeNode` class is basically used to make runtime graphics in scene.
    In this example, we have created a drawing of four lines and then filled it with
    a color by using the `fillColor` property.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKShapeNode` 类主要用于在场景中创建运行时图形。在这个例子中，我们创建了一个由四条线组成的图形，然后使用 `fillColor` 属性填充了颜色。'
- en: ParticleScene
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ParticleScene
- en: 'Now, open the `ParticleScene.swift` file and add the following code to create
    the `SKEmitterNode` class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `ParticleScene.swift` 文件，并添加以下代码以创建 `SKEmitterNode` 类：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get the following screen with the previous code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们得到以下屏幕：
- en: '![ParticleScene](img/4201_04_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![ParticleScene](img/4201_04_04.jpg)'
- en: This screen is obtained when we execute the ParticleScene.swift file
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 ParticleScene.swift 文件时，我们得到此屏幕。
- en: 'We used the `SKEmitterNode` class object for the particle effect. Sprite Kit
    gives you many predefined particle effects. You can customize them according to
    your requirements. To make a particle effect, follow these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `SKEmitterNode` 类对象来创建粒子效果。Sprite Kit 提供了许多预定义的粒子效果。你可以根据需求进行自定义。要创建粒子效果，请按照以下步骤操作：
- en: Right click on project explorer, **New File** | **Resource** | **SpriteKit Particle
    File**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目资源管理器，**新建文件** | **资源** | **SpriteKit 粒子文件**。
- en: Choose a particle template from the list and then click on **Next**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择一个粒子模板，然后点击 **下一步**。
- en: '**Save As**, name your particle system. We named it `MagicParticle`, in our
    project. Make sure that in the **Targets** option, the **Platformer** (project)
    is selected before you click on the **Create** button.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**另存为**，给你的粒子系统命名。在我们的项目中，我们将其命名为 `MagicParticle`。确保在点击 **创建** 按钮之前，在 **目标**
    选项中选择了 **Platformer**（项目）。'
- en: In the **Project Navigator**, on the left side of screen, you will see the `MagicParticle.sks`
    file. If you click on this file, you can see the particle effect in the editor
    window. Now, on the right side panel, many options are available for particle,
    color, shape, and so on. You can select any value as per your liking.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在**项目导航器**中，屏幕左侧，你会看到`MagicParticle.sks`文件。如果你点击这个文件，你可以在编辑器窗口中看到粒子效果。现在，在右侧面板中，有许多选项可供选择，如粒子、颜色、形状等。你可以根据自己的喜好选择任何值。
- en: LightScene
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LightScene
- en: 'Now, open the `LightScene.swift` file and add the following code to create
    the `SKLightNode` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`LightScene.swift`文件，添加以下代码以创建`SKLightNode`类：
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following screen, using the preceding code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们将获得以下屏幕：
- en: '![LightScene](img/4201_04_05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![LightScene](img/4201_04_05.jpg)'
- en: The preceding screen is obtained when we execute the LightScene.swift file
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上一屏是在执行`LightScene.swift`文件时获得的
- en: In this class, we used a light source and set bitmasks to images. If you run
    the project, you will see that the background color is being affected by the lighting
    source, and other play images are casting shadows in the opposite direction. If
    you click on scene, the lighting source will change its position and shadows will
    also change themselves according to the source.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们使用了一个光源并设置了位掩码到图像上。如果你运行项目，你会看到背景颜色受到光源的影响，其他播放图像在相反方向上投射阴影。如果你点击场景，光源将改变其位置，阴影也会根据光源改变自己。
- en: VideoNodeScene
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VideoNodeScene
- en: 'Now, open the `VideoNodeScene.swift` file and add the following code to create
    the `SKVideoNode` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`VideoNodeScene.swift`文件，添加以下代码以创建`SKVideoNode`类：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will get the following screen:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下屏幕：
- en: '![VideoNodeScene](img/4201_04_06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![VideoNodeScene](img/4201_04_06.jpg)'
- en: The preceding screen is obtained when we execute the LightScene.swift file
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`LightScene.swift`文件时，将获得以下屏幕
- en: To use audio and video in our scene, we have imported `AVFoundation` into our
    code. We have added a video file with the `.m4v` format in our project. We have
    used a file named `Movie.a4v` for this project. So, we are done with the coding
    part for this chapter. We learned six majorly used subclasses of `SKNode`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中使用音频和视频，我们在代码中导入了`AVFoundation`。我们在项目中添加了一个`.m4v`格式的视频文件。我们为这个项目使用了名为`Movie.a4v`的文件。因此，我们完成了这一章的编码部分。我们学习了`SKNode`类在Sprite
    Kit中常用的六个主要子类。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about nodes in detail. We discussed many properties
    and functions of the `SKNode` class of Sprite Kit, along with its usage. Also,
    we discussed about the building of a node tree, and actions on a node tree. Now
    we are familiar with the major subclasses of `SKNode`, namely `SKLabelNode`, `SKCropNode`,
    `SKShapeNode`, `SKEmitterNode`, `SKLightNode`, and `SKVideoNode`, along with their
    implementation in our game.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细学习了节点。我们讨论了Sprite Kit中`SKNode`类的许多属性和函数，以及它的用法。我们还讨论了节点树的构建和节点树上的动作。现在我们熟悉了`SKNode`的主要子类，即`SKLabelNode`、`SKCropNode`、`SKShapeNode`、`SKEmitterNode`、`SKLightNode`和`SKVideoNode`，以及它们在我们游戏中的实现。
- en: In the next chapter, we will learn the basics of adding physics simulation in
    a Sprite Kit game. We will also learn about adding physics to the different nodes
    in our game.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习在Sprite Kit游戏中添加物理模拟的基础知识。我们还将学习如何将物理添加到我们游戏中的不同节点。
