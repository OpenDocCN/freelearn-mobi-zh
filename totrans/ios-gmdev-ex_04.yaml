- en: Chapter 4. Nodes in Sprite Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learnt about how to use sprites in a game in various
    ways. We discussed about the physical properties of sprites, textures of sprites,
    and various other properties, such as color property, lighting, shader, and so
    on. We also learned about working with texture objects and had an introduction
    to texture atlases.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented the `SKSprite` class which is a subclass
    of the `SKNode` class; that's why `SKSprite` is a node itself, inheriting `SKNode`
    properties. In this chapter, we will study about nodes, which play an important
    role in understanding the tree structure of a game. Further, we will discuss about
    types of nodes in the Sprite Kit and their uses in detail.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to know about nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed many things about nodes so far. Almost everything you are
    making in a game with Sprite Kit is a node. Scenes that we are presenting to view
    are instances of the `SKScene` class, which is a subclass of the `SKEffectNode`
    class, which is itself a subclass of the `SKNode` class. Indirectly, `SKScene`
    is a subclass of the `SKNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: As a game follows the node tree formation, a scene acts like a root node and
    the other nodes are used as its children. It should be remembered that although
    `SKNode` is a base class for the node you see in a scene, it itself does not draw
    anything. It only provides some basic features to its subclass nodes. All the
    visual content we see in a Sprite Kit made game, is drawn by using the appropriate
    `SKNode` subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are some subclasses of `SKNode` classes, which are used for different
    behaviors in a Sprite Kit-based game:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SKSpriteNode`: This class is used to instantiate a texture sprite in the game;
    this is a familiar node class referred to frequently in [Chapter 3](ch03.html
    "Chapter 3. Sprites"), *Sprites*. `SKVideoNode`, this class is used to play video
    content in a scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKLabelNode`: This class is used to draw labels in a game, with many customizing
    options, such as font type, font size, font color, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKShapeNode`: This class is used to make a shape based on a path, at run time.
    For example, drawing a line or making a drawing game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKEmitterNode`: This class is used for emitting particle effects in a scene,
    with many options, such as position, number of particles, color, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKCropNode`: This class is basically used for cropping its child nodes, using
    a mask. Using this, you can selectively block areas of a layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKEffectNode`: `SKEffectNode` is the parent of the `SKScene` class and the
    subclass of the `SKNode` class. It is used for applying an image filter to its
    children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKLightNode`: `SKLightNode` class is used to make light and shadow effects
    in scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKFieldNode`: This is a useful feature of Sprite Kit. You can define a portion
    of scene with some physical properties, for example, in space game, having a gravity
    effect on a black hole, which attracts the things which are nearby.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, these are the basic subclasses of `SKNode` which are used frequently in
    Sprite Kit. `SKNode` provides some basic properties to its subclasses, which are
    used to view a node inside a scene, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`position`: This sets up the position of a node in a scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xScale`: This scales in the width of a node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yScale`: This scales in the height of a node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zRotation`: This facilitates the rotation of a node in a clockwise or anti-clockwise
    direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame`: `frame` is a rectangle containing the nodes content along with its
    x-scale, y-scale and z-rotation properties, ignoring the nodes children'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know that the `SKNode` class does not draw anything by itself. So, what is
    the use of it? Well, we can use `SKNode` instances to manage our other nodes in
    different layers separately, or we can use them to manage different nodes in the
    same layer. Let's take a look at how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SKNode object in the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will discover what the various aspects of `SKNode` are used for. Say
    you have to make a body from different parts of sprites, such as a car. You can
    make it from sprites of wheels and body. The wheels and body of a car run in synchronization
    with each other, so that one controls their action together, rather than manage
    each part separately. This can be done by adding them as a child of the `SKNode`
    class object and updating this node to control the activity of the car.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SKNode` class object can be used for layering purposes in a game. Suppose
    we have three layers in our game: the foreground layer, which represents foreground
    sprites, the middle layer, which represents the middle sprites, and the background
    layer which represents background sprites.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want a parallax effect in our game, we will have to update each sprite's
    position separately or we can make three `SKNode` objects, referring to each layer,
    and add the sprites to their respective nodes. Now we have to update only these
    three nodes' position and the sprites will update their position automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The `SKNode` class can be used to make some kind of check point in a game, which
    is hidden but performs or triggers some event when a player crosses them, such
    as a level end, bonus, or death trap.
  prefs: []
  type: TYPE_NORMAL
- en: We can remove or add the whole sub tree inside a node and perform the necessary
    functions, such as rotating, scaling, positioning, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Well, as we described that we can use the `SKNode` object as checkpoints in
    the game, it is important to recognize them in your scene. So, how we do that?
    Well the `SKNode` class provides a property for this. Let's find out more about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SKNode` class provides a property with a name, to recognize the correct
    node. It takes string as a parameter. Either you can search a node by its name
    or you can use one of the two methods provided by `SKNode`, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func childNodeWithName(name:String) -> SKNode`: This function takes the name
    string as a parameter, and if it finds a node with a specific name, it returns
    that node or else it returns nil. If there is more than one node sharing the same
    name, it will return the first node in the search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func enumerateChildNodesWithName(name:String, usingBlock:((SKNode!,UnsafeMutablePointer<ObjCBool>)->Void)!)`:
    When you need all the nodes sharing the same name, use this function. This function
    takes the name and block as a parameter. In `usingBlock`, you need to provide
    two parameters. One matching node, and the other a pointer of type Boolean. In
    our game, if you remember, we used the `name` property inside `PlayButton` to
    recognize the node when a user taps on it. It''s a very useful property to search
    for the desired node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's have a quick look at other properties or methods of the `SKNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two initializers to make an instance of `SKNode`. Both are available
    in iOS 8.0 or later.
  prefs: []
  type: TYPE_NORMAL
- en: '`convenience init (fileNamed filename: String)`: This initializer is used for
    making a node by loading an archive file from main bundle. For this, you have
    to pass a file name with an `sks` extension in the main bundle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init()`: It is used to make a simple node without any parameter. It is useful
    for layering purposes in a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we already discussed the positioning of a node, let's discuss some functions
    and properties that are used to build a node tree.
  prefs: []
  type: TYPE_NORMAL
- en: Building a node tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SKNode` provides some functions and properties to work with a node tree. Following
    are some of the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addChild(node:SKNode)`: This is a very common function and is used mostly
    to make a node tree structure. We already used it to add nodes to scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertChild(node:SKNode,atIndex index: Int)`: This is used when you have to
    insert a child in a specific position in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeFromParent()`: This simply removes a node from its parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAllChildren()`: This is used when you have to clear all the children
    in a node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeChildrenInArray(nodes:[AnyObject]!)`: This takes an array of `SKNode`
    objects and removes it from the receiving node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inParentHierarchy(parent:SKNode) -> Bool`: It takes an `SKNode` object to
    check as a parent of the receiving node, and returns a Boolean value according
    to that condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some useful properties used in a node tree, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`children`: This is a read only property. It contains the receiving node''s
    children in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent`: This is also a read only property. It contain the reference of the
    parent of the receiving node, and if there is none, then it returns nil.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scene`: This too is a read only property. If the node is embedded in the scene,
    it will contain the reference of the scene, otherwise nil.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a game, we need some specific task on a node, such as changing its position
    from one point to another, changing sprites in a sequence, and so on. These tasks
    are done using actions on node. Let's talk about them now.
  prefs: []
  type: TYPE_NORMAL
- en: Actions on a node tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions are required for some specific tasks in a game. For this, the `SKNode`
    class provides some basic functions, which are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`runAction(action:SKAction!)`: This function takes an `SKAction` class object
    as a parameter and performs the action on the receiving node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAction(action:SKAction!,completion block: (() -> Void)!)`: This function
    takes an `SKAction` class object and a compilation block as object. When the action
    completes, it calls the block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAction(action:SKAction,withKey key:String!)`: This function takes an `SKAction`
    class object and a unique key, to identify this action and perform it on the receiving
    node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionForKey(key:String) -> SKAction?`: This takes a `String` key as a parameter
    and returns an associative `SKAction` object for that key identifier. This happens
    if it exists, otherwise it returns nil.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasActions() -> Bool`: Through this action, if the node has any executing
    action, it returns `true`, or else `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAllActions()`: This function removes all actions from the receiving
    node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeActionForKey(key:String)`: This takes `String` name as key and removes
    an action associated with that key, if it exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some useful properties to control these actions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`speed`: This is used to speed up or speed down the action motion. The default
    value is `1.0` to run at normal speed; with increasing value, speed increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paused`: This Boolean value determines whether an action on the node should
    be paused or resumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we require changing a point coordinate system according to a node
    inside a scene. The `SKNode` class provides two functions to interchange a point's
    coordinate system with respect to a node in a scene. Let's talk about them.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate system of a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can convert a point with respect to the coordinate system of any node tree.
    The functions to do that, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`convertPoint(point:CGPoint, fromNode node : SKNode) -> CGPoint`: This takes
    a point in another node''s coordinate system and the other node as its parameter,
    and returns a converted point according to the receiving node''s coordinate system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convertPoint(point:CGPoint, toNode node:SKNode) ->CGPoint`: It takes a point
    in the receiving node''s coordinate system and the other nodes in the node tree
    as its parameters, and returns the same point converted according to the other
    node''s coordinate system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also determine if a point is inside a node's area or not.
  prefs: []
  type: TYPE_NORMAL
- en: '`containsPoint(p:CGPoint) -> Bool`: This returns the Boolean value according
    to the position of a point inside or outside of a receiving node''s bounding box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodeAtPoint(p:CGPoint) -> SKNode`: This returns the deepest descendant node
    that intersects the point. If that is not there, then it returns the receiver
    node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodesAtPoint(p:CGPoint) -> [AnyObject]`: This returns an array of all the
    `SKNode` objects in the subtree that intersect the point. If no nodes intersect
    the point, an empty array is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these, the `SKNode` class provides some other functions and properties
    too. Let's talk about them.
  prefs: []
  type: TYPE_NORMAL
- en: Other functions and properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some other functions and properties of the `SKNode` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`intersectsNode(node:SKNode) -> Bool`: As the name suggests, it returns a Boolean
    value according to the intersection of the receiving node and another node from
    the function parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physicsBody`: It is a property of the `SKNode` class. The default value is
    nil, which means that this node will not take part in any physical simulation
    in the scene. If it contains any physical body, then it will change its position
    and rotation in accordance with the physical simulation in the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userData : NSMutableDictionary?`: The `userData` property is used to store
    data for a node in a dictionary form. We can store position, rotation, and many
    custom data sets about the node inside it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constraints: [AnyObject]?`: It contains an array of constraints `SKConstraint`
    objects to the receiving node. Constraints are used to limit the position or rotation
    of a node inside a scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reachConstraints: SKReachConstraints?`: This is basically used to make restricted
    values for the receiving node by making an `SKReachConstraints` object. For example,
    to make joints move in a human body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node blending modes: The `SKNode` class declares an `enum SKBlendMode` of the
    `int` type to blend the receiving node''s color by using source and destination
    pixel colors. The constant''s used for this are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alpha`: It is used to blend source and destination colors by multiplying the
    source alpha value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add`: It is used to add the source and destination colors'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subtract`: It is used to subtract the source color from the destination color'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Multiply`: It is used to multiply the source color by the destination color'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiplyX2`: It is used to multiply the source color by the destination color,
    and after that, the resulting color is doubled'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Screen`: It is used to multiply the inverted source and the destination color
    respectively and it then inverts the final result color'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Replace`: It is used to replace the destination color by source color'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateAccumulatedFrame()->CGRect`: We know that a node does not draw anything
    by itself, but if a node has descendants that draw content, then we may be required
    to know the overall frame size of that node. This function calculates the frame
    that contains the content of the receiver node and all of its descendants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we are ready to see some basic `SKNode` subclasses in action. The classes
    we are going to discuss are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SKLabelNode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKCropNode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKShapeNode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKEmitterNode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKLightNode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKVideoNode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To study these classes, we are going to create six different `SKScene` subclasses
    in our project, so that we can learn them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Now, having learned in detail about nodes, we can proceed further to utilize
    the concept of nodes in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating subclasses for our Platformer game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the theoretical understanding of nodes, one wonders how this concept is
    helpful in developing a game. To understand the development of a game using the
    concept of Nodes, we now go ahead with writing and executing code for our *Platformer*
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the subclasses of different nodes in Xcode, following the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the main menu, select **New File** | **Swift** | **Save As** | **NodeMenuScene.swift**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure **Platformer** is ticked as the target. Now **Create** and **Open**
    and make the `NodeMenuScene` class by subclassing `SKScene`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Following the previous same steps as, make `CropScene`, `ShapeScene`, `ParticleScene`,
    `LightScene`, and `VideoNodeScene` files, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `GameViewController.swift` file and replace the `viewDidLoad` function
    by typing out the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we just called our `NodeMenuScene` class from the `GameViewController`
    class. Now, it's time to add some code to the `NodeMenuScene` class.
  prefs: []
  type: TYPE_NORMAL
- en: NodeMenuScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `NodeMenuScene.swift` file and type in the code as shown next. Do
    not worry about the length of the code; as this code is for creating the node
    menu screen, most of the functions are similar to creating buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following screen from the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NodeMenuScene](img/4201_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The screen is obtained when we execute the NodeMenuScene.swift file
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, after `import` statements, we defined some `String`
    variables. We are going to use these variables as `Label` names in the scene .We
    also added our font name as a string variable. Inside this class, we made two
    node references: one for background and the other for those labels which we are
    going to use in this scene. We are using these two nodes to make layers in our
    game. It is best to categorize the nodes in a scene, so that we can optimize the
    code. We make an `SKTransition` object reference of the flip horizontal effect.
    You can use other transition effects too.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `didMoveToView()` function, we just get the node and add it to our
    scene and set their `z` position.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we look at the `getBackgroundNode()` function, we can see that we made
    a node by the `SKNode` class instance, a background by the `SKSpriteNode` class
    instance, and then added it to the node and returned it. If you see the syntax
    of this function, you will see `-> SKNode`. It means that this function returns
    an `SKNode` object.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes in the function, `getLabelNode()`. It also returns a node containing
    all the `SKLabelNode` class objects. We have given a font and a name to these
    labels and set the position of them in the screen. The `SKLabelNode` class is
    used to make labels in Sprite Kit with many customizable options.
  prefs: []
  type: TYPE_NORMAL
- en: In the `touchBegan()` function, we get the information on which Label is touched,
    and we then call the appropriate scene with transitions.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have created a scene with the transition effect. By tapping on
    each button, you can see the transition effect.
  prefs: []
  type: TYPE_NORMAL
- en: CropScene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this scene, we are going to use the `SKCropNode` class object. This class
    is used to mask one node on another. We are going to use our play sprite as a
    mask and our background image as an image that is to be rendered according to
    the masking area. Open the `CropScene.swift` file and type in the code, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following screen, with the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CropScene](img/4201_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screen is obtained when we execute the Cropscene.swift file
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we just added a label for the back press of the `SKLabelNode`
    class object.
  prefs: []
  type: TYPE_NORMAL
- en: In this class, we added play image to the mask node of the `SKCropNode` object
    and added a background to this crop node. If you click on the `SKCropNode` label
    in the `NodeMenuScene`, you will see that the play image is working as a mask
    over the background image.
  prefs: []
  type: TYPE_NORMAL
- en: ShapeScene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, open the `ShapeScene.swift` file and add the following code to create
    the `SKShapeNode` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following screen with the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ShapeScene](img/4201_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screen is obtained when we execute the ShapeScene.swift file
  prefs: []
  type: TYPE_NORMAL
- en: The `SKShapeNode` class is basically used to make runtime graphics in scene.
    In this example, we have created a drawing of four lines and then filled it with
    a color by using the `fillColor` property.
  prefs: []
  type: TYPE_NORMAL
- en: ParticleScene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, open the `ParticleScene.swift` file and add the following code to create
    the `SKEmitterNode` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following screen with the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ParticleScene](img/4201_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screen is obtained when we execute the ParticleScene.swift file
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `SKEmitterNode` class object for the particle effect. Sprite Kit
    gives you many predefined particle effects. You can customize them according to
    your requirements. To make a particle effect, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right click on project explorer, **New File** | **Resource** | **SpriteKit Particle
    File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a particle template from the list and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Save As**, name your particle system. We named it `MagicParticle`, in our
    project. Make sure that in the **Targets** option, the **Platformer** (project)
    is selected before you click on the **Create** button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project Navigator**, on the left side of screen, you will see the `MagicParticle.sks`
    file. If you click on this file, you can see the particle effect in the editor
    window. Now, on the right side panel, many options are available for particle,
    color, shape, and so on. You can select any value as per your liking.
  prefs: []
  type: TYPE_NORMAL
- en: LightScene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, open the `LightScene.swift` file and add the following code to create
    the `SKLightNode` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following screen, using the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LightScene](img/4201_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screen is obtained when we execute the LightScene.swift file
  prefs: []
  type: TYPE_NORMAL
- en: In this class, we used a light source and set bitmasks to images. If you run
    the project, you will see that the background color is being affected by the lighting
    source, and other play images are casting shadows in the opposite direction. If
    you click on scene, the lighting source will change its position and shadows will
    also change themselves according to the source.
  prefs: []
  type: TYPE_NORMAL
- en: VideoNodeScene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, open the `VideoNodeScene.swift` file and add the following code to create
    the `SKVideoNode` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![VideoNodeScene](img/4201_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screen is obtained when we execute the LightScene.swift file
  prefs: []
  type: TYPE_NORMAL
- en: To use audio and video in our scene, we have imported `AVFoundation` into our
    code. We have added a video file with the `.m4v` format in our project. We have
    used a file named `Movie.a4v` for this project. So, we are done with the coding
    part for this chapter. We learned six majorly used subclasses of `SKNode`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about nodes in detail. We discussed many properties
    and functions of the `SKNode` class of Sprite Kit, along with its usage. Also,
    we discussed about the building of a node tree, and actions on a node tree. Now
    we are familiar with the major subclasses of `SKNode`, namely `SKLabelNode`, `SKCropNode`,
    `SKShapeNode`, `SKEmitterNode`, `SKLightNode`, and `SKVideoNode`, along with their
    implementation in our game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn the basics of adding physics simulation in
    a Sprite Kit game. We will also learn about adding physics to the different nodes
    in our game.
  prefs: []
  type: TYPE_NORMAL
