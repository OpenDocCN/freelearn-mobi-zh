- en: Chapter 6. Working with Gradle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 使用 Gradle
- en: This chapter covers some more plugins such as **War** and **Scala**, which will
    be helpful in building web applications and Scala applications. Additionally,
    we will discuss diverse topics such as **Property Management**, **Multi-Project
    build**, and **logging** aspects. In the *Multi-project build* section, we will
    discuss how Gradle supports multi-project build through the root project's build
    file. It also provides the flexibility of treating each module as a separate project,
    plus all the modules together like a single project. In the final section of this
    chapter, we will learn the automated testing aspects with Gradle. You will learn
    to execute unit tests with different configurations. In this section, we will
    learn about testing concepts with the examples of two commonly used testing frameworks,
    JUnit and TestNG.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了更多插件，如 **War** 和 **Scala**，这些插件在构建 Web 应用程序和 Scala 应用程序时将非常有用。此外，我们还将讨论诸如
    **属性管理**、**多项目构建**和 **日志** 等多个主题。在 **多项目构建** 部分，我们将讨论 Gradle 如何通过根项目的构建文件支持多项目构建。它还提供了将每个模块视为独立项目的同时，将所有模块作为一个单一项目来处理的灵活性。在本章的最后部分，我们将学习使用
    Gradle 的自动化测试方面。你将学习如何使用不同的配置执行单元测试。在本节中，我们将通过两个常用测试框架 JUnit 和 TestNG 的示例来了解测试概念。
- en: The War plugin
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: War 插件
- en: 'The War plugin is used to build web projects, and like any other plugin, it
    can be added to the build file by adding the following line:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: War 插件用于构建 Web 项目，并且像任何其他插件一样，可以通过在构建文件中添加以下行来添加：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`War` plugin extends the Java plugin and helps to create the `war` archives.
    The `war` plugin automatically applies the Java plugin to the build file. During
    the build process, the plugin creates a `war` file instead of a `jar` file. The
    war plugin disables the `jar` task of the Java plugin and adds a default `war`
    archive task. By default, the content of the `war` file will be compiled classes
    from `src/main/java`; content from `src/main/webapp` and all the runtime dependencies.
    The content can be customized using the `war` closure as well.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`War` 插件扩展了 Java 插件，并有助于创建 `war` 归档。`war` 插件会自动将 Java 插件应用于构建文件。在构建过程中，插件创建一个
    `war` 文件而不是 `jar` 文件。War 插件禁用了 Java 插件的 `jar` 任务，并添加了一个默认的 `war` 归档任务。默认情况下，`war`
    文件的内容将是来自 `src/main/java` 的编译类；来自 `src/main/webapp` 的内容以及所有运行时依赖项。内容可以通过使用 `war`
    闭包进行自定义。'
- en: 'In our example, we have created a simple `servlet` file to display the current
    date and time, a `web.xml` file and a `build.gradle` file. The project structure
    is displayed in the following screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个简单的 `servlet` 文件来显示当前日期和时间，一个 `web.xml` 文件和一个 `build.gradle`
    文件。项目结构在以下屏幕截图中进行展示：
- en: '![The War plugin](img/B02000_06_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![War 插件](img/B02000_06_01.jpg)'
- en: Figure 6.1
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1
- en: 'The `SimpleWebApp/build.gradle` file has the following content:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleWebApp/build.gradle` 文件的内容如下：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `war` plugin adds the `providedCompile` and `providedRuntime` dependency
    configurations on top of the Java plugin. The `providedCompile` and `providedRuntime`
    configurations have the same scope as `compile` and `runtime` respectively, but
    the only difference is that the libraries defined in these configurations will
    not be a part of the `war` archive. In our example, we have defined `servlet-api`
    as the `providedCompile` time dependency. So, this library is not included in
    the `WEB-INF/lib/` folder of the `war` file. This is because this library is provided
    by the servlet container such as Tomcat. So, when we deploy the application in
    a container, it is added by the container. You can confirm this by expanding the
    `war` file as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`war` 插件在 Java 插件之上添加了 `providedCompile` 和 `providedRuntime` 依赖配置。`providedCompile`
    和 `providedRuntime` 配置的范围分别与 `compile` 和 `runtime` 相同，但唯一的不同是这些配置中定义的库将不会成为 `war`
    归档的一部分。在我们的示例中，我们已将 `servlet-api` 定义为 `providedCompile` 时间的依赖项。因此，这个库不包括在 `war`
    文件的 `WEB-INF/lib/` 文件夹中。这是因为这个库由如 Tomcat 这样的 Servlet 容器提供。因此，当我们在一个容器中部署应用程序时，它将由容器添加。你可以通过以下方式展开
    `war` 文件来确认这一点：'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, we might need to customize the project''s structure as well. For
    example, the `webapp` folder could be under the root project folder, not in the
    `src` folder. The `webapp` folder can also contain new folders such as `conf`
    and `resource` to store the properties files, Java scripts, images, and other
    assets. We might want to rename the `webapp` folder to `WebContent`. The proposed
    directory structure might look like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能还需要自定义项目的结构。例如，`webapp` 文件夹可能位于根项目文件夹下，而不是在 `src` 文件夹中。`webapp` 文件夹还可以包含新的文件夹，如
    `conf` 和 `resource`，用于存储属性文件、Java 脚本、图像和其他资产。我们可能希望将 `webapp` 文件夹重命名为 `WebContent`。建议的目录结构可能如下所示：
- en: '![The War plugin](img/B02000_06_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![The War plugin](img/B02000_06_02.jpg)'
- en: Figure 6.2
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2
- en: We might also be interested in creating a `war` file with a custom name and
    version. Additionally, we might not want to copy any empty folder such as `images`
    or `js` to the `war` file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还希望创建一个具有自定义名称和版本的 `war` 文件。此外，我们可能不想将任何空文件夹，如 `images` 或 `js`，复制到 `war`
    文件中。
- en: To implement these new changes, add the additional properties to the `build.gradle`
    file as described here. The `webAppDirName` property sets the new `webapp` folder
    location to the `WebContent` folder. The `war` closure defines properties such
    as version and name, and sets the `includeEmptyDirs` option as `false`. By default,
    `includeEmptyDirs` is set to `true`. This means any empty folder in the `webapp`
    directory will be copied to the `war` file. By setting it to `false`, the empty
    folders such as `images` and `js` will not be copied to the `war` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些新更改，请按照此处所述，将附加属性添加到 `build.gradle` 文件中。`webAppDirName` 属性将新的 `webapp`
    文件夹位置设置为 `WebContent` 文件夹。`war` 闭包定义了版本和名称等属性，并将 `includeEmptyDirs` 选项设置为 `false`。默认情况下，`includeEmptyDirs`
    被设置为 `true`。这意味着 `webapp` 目录中的任何空文件夹都将被复制到 `war` 文件中。通过将其设置为 `false`，空文件夹如 `images`
    和 `js` 将不会被复制到 `war` 文件中。
- en: 'The following would be the contents of `CustomWebApp/build.gradle`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是 `CustomWebApp/build.gradle` 的内容：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the build is successful, the `war` file will be created as `simpleapp-1.0.war`.
    Execute the `jar -tvf build/libs/simpleapp-1.0.war` command and verify the content
    of the `war` file. You will find the `conf` folder is added to the `war` file,
    whereas `images` and `js` folders are not included.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功后，将创建名为 `simpleapp-1.0.war` 的 `war` 文件。执行 `jar -tvf build/libs/simpleapp-1.0.war`
    命令并验证 `war` 文件的内容。你会发现 `conf` 文件夹被添加到了 `war` 文件中，而 `images` 和 `js` 文件夹则没有被包含。
- en: 'You might also find the Jetty plugin interesting for web application deployment,
    which enables you to deploy the web application in an embedded container. This
    plugin automatically applies the War plugin to the project. The Jetty plugin defines
    three tasks; `jettyRun`, `jettyRunWar`, and `jettyStop`. Task `jettyRun` runs
    the web application in an embedded Jetty web container, whereas the `jettyRunWar`
    task helps to build the `war` file and then run it in the embedded web container.
    Task `jettyStop` stops the container instance. Covering more on war configuration
    is beyond the scope of the book, so for more information please refer to the Gradle
    API documentation. Here is the link: [https://docs.gradle.org/current/userguide/war_plugin.html](https://docs.gradle.org/current/userguide/war_plugin.html).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会对用于网络应用程序部署的 Jetty 插件感兴趣，该插件允许你在嵌入式容器中部署网络应用程序。此插件会自动将 War 插件应用到项目中。Jetty
    插件定义了三个任务：`jettyRun`、`jettyRunWar` 和 `jettyStop`。任务 `jettyRun` 在嵌入式 Jetty 网络容器中运行网络应用程序，而
    `jettyRunWar` 任务帮助构建 `war` 文件，并在嵌入式网络容器中运行它。任务 `jettyStop` 停止容器实例。关于 War 配置的更多内容超出了本书的范围，因此，更多信息请参考
    Gradle API 文档。以下是链接：[https://docs.gradle.org/current/userguide/war_plugin.html](https://docs.gradle.org/current/userguide/war_plugin.html)。
- en: The Scala plugin
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 插件
- en: 'The **Scala** plugin helps you to build the Scala application. Like any other
    plugin, the Scala plugin can be applied to the build file by adding the following
    line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scala** 插件可以帮助你构建 Scala 应用程序。像任何其他插件一样，Scala 插件可以通过添加以下行应用到构建文件中：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Scala plugin also extends the Java plugin and adds a few more tasks such
    as `compileScala`, `compileTestScala`, and `scaladoc` to work with Scala files.
    The task names are pretty much all named after their Java equivalent, simply replacing
    the `java` part with `scala`. The Scala project's directory structure is also
    similar to a Java project structure where production code is typically written
    under `src/main/scala` directory and test code is kept under the `src/test/scala`
    directory. Figure 6.3 shows the directory structure of a Scala project. You can
    also observe from the directory structure that a Scala project can contain a mix
    of Java and Scala source files. The `HelloScala.scala` file has the following
    content. The output is `Hello, Scala...` on the console. This is a very basic
    code and we will not be able to discuss much detail on the Scala programming language.
    We request readers to refer to the Scala language documentation available at [http://www.scala-lang.org/](http://www.scala-lang.org/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 插件也扩展了 Java 插件并添加了一些更多任务，如 `compileScala`、`compileTestScala` 和 `scaladoc`，以处理
    Scala 文件。任务名称几乎都是根据它们的 Java 等价物命名的，只需将 `java` 部分替换为 `scala`。Scala 项目的目录结构也与 Java
    项目的结构类似，其中生产代码通常写在 `src/main/scala` 目录下，测试代码保存在 `src/test/scala` 目录下。图 6.3 展示了
    Scala 项目的目录结构。您还可以从目录结构中观察到，Scala 项目可以包含 Java 和 Scala 源文件的混合。`HelloScala.scala`
    文件的内容如下。控制台输出为 `Hello, Scala...`。这是一个非常基础的代码，我们无法对 Scala 编程语言进行太多详细讨论。我们请求读者参考可在
    [http://www.scala-lang.org/](http://www.scala-lang.org/) 找到的 Scala 语言文档。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To support the compilation of Scala source code, Scala libraries should be
    added in the dependency configuration:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 Scala 源代码的编译，应在依赖配置中添加 Scala 库：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![The Scala plugin](img/B02000_06_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Scala 插件](img/B02000_06_03.jpg)'
- en: Figure 6.3
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3
- en: As mentioned, the Scala plugin extends the Java plugin and adds a few new tasks.
    For example, the `compileScala` task depends on the `compileJava` task and the
    `compileTestScala` task depends on the `compileTestJava` task. This can be understood
    easily, by executing `classes` and `testClasses` tasks and looking at the output.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala 插件扩展了 Java 插件并添加了一些新任务。例如，`compileScala` 任务依赖于 `compileJava` 任务，而
    `compileTestScala` 任务依赖于 `compileTestJava` 任务。这可以通过执行 `classes` 和 `testClasses`
    任务并查看输出轻松理解。
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Scala projects are also packaged as `jar` files. The `jar` task or `assemble`
    task creates a `jar` file in the `build/libs` directory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 项目也被打包成 `jar` 文件。`jar` 任务或 `assemble` 任务在 `build/libs` 目录下创建一个 `jar` 文件。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Scala plugin does not add any extra convention to the Java plugin. Therefore,
    the conventions defined in the Java plugin, such as lib directory and report directory
    can be reused in the Scala plugin. The Scala plugin only adds few `sourceSet`
    properties such as `allScala`, `scala.srcDirs`, and `scala` to work with source
    set. The following task example displays different properties available to the
    Scala plugin. This example is similar to the convention example task that we created
    in [Chapter 4](ch04.html "Chapter 4. Plugin Management"), *Plugin Management*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 插件不会向 Java 插件添加任何额外的约定。因此，Java 插件中定义的约定，如 lib 目录和 report 目录，可以在 Scala
    插件中重用。Scala 插件仅添加了一些 `sourceSet` 属性，如 `allScala`、`scala.srcDirs` 和 `scala`，以处理源集。以下任务示例显示了
    Scala 插件可用的不同属性。此示例类似于我们在第 4 章[第 4 章。插件管理](ch04.html "第 4 章。插件管理")中创建的约定示例任务。
- en: 'The following is a code snippet from `ScalaApplication/build.gradle`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `ScalaApplication/build.gradle` 文件中的代码片段：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the task `displayScalaPluginConvention` is shown in the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 任务 `displayScalaPluginConvention` 的输出如下所示：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, we will conclude this section by discussing how to execute Scala application
    from Gradle; we can create a simple task in the build file as follows.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过讨论如何从 Gradle 执行 Scala 应用程序来结束本节；我们可以在构建文件中创建一个简单的任务，如下所示。
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `HelloScala` source file has a main method which prints `Hello, Scala...`
    in the console. The `runMain` task executes the main method and displays the output
    in the console:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloScala` 源文件有一个主方法，它在控制台打印 `Hello, Scala...`。`runMain` 任务执行主方法并在控制台显示输出：'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Logging
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'Until now we have used `println` everywhere in the build script to display
    the messages to the user. If you are coming from a Java background you know a
    `println` statement is not the right way to give information to the user. You
    need logging. Logging helps the user to classify the categories of messages to
    show at different levels. These different levels help users to print a correct
    message based on the situation. For example, when a user wants complete detailed
    tracking of your software, they can use debug level. Similarly, whenever a user
    wants very limited useful information while executing a task, they can use quiet
    or info level. Gradle provides the following different types of logging:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在构建脚本中到处使用 `println` 来向用户显示消息。如果您来自 Java 背景，您知道 `println` 语句不是向用户提供信息的正确方式。您需要日志记录。日志记录帮助用户对显示在不同级别的消息进行分类。这些不同的级别帮助用户根据情况打印正确的消息。例如，当用户想要对您的软件进行完整的详细跟踪时，他们可以使用调试级别。同样，每当用户在执行任务时想要非常有限的有用信息时，他们可以使用安静或信息级别。Gradle
    提供以下不同类型的日志记录：
- en: '| Log Level | Description |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 日志级别 | 描述 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ERROR | This is used to show error messages |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| ERROR | 这用于显示错误信息 |'
- en: '| QUIET | This is used to show limited useful information |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| QUIET | 这用于显示有限的有用信息 |'
- en: '| WARNING | This is used to show warning messages |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| WARNING | 这用于显示警告信息 |'
- en: '| LIFECYCLE | This is used to show the progress (default level) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| LIFECYCLE | 这用于显示进度（默认级别）|'
- en: '| INFO | This is used to show information messages |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| INFO | 这用于显示信息消息 |'
- en: '| DEBUG | This is used to show debug messages (all logs) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| DEBUG | 这用于显示调试信息（所有日志）|'
- en: 'By default, the Gradle log level is LIFECYCLE. The following is the code snippet
    from `LogExample/build.gradle`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gradle 的日志级别是 LIFECYCLE。以下是从 `LogExample/build.gradle` 的代码片段：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, execute the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下命令：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, Gradle has printed all the logger statements upto the lifecycle level
    (including lifecycle), which is Gradle's default log level. You can also control
    the log level from the command line.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Gradle 打印了所有生命周期级别的日志语句（包括生命周期），这是 Gradle 的默认日志级别。您也可以从命令行控制日志级别。
- en: '| `-q` | This will show logs up to the quiet level. It will include error and
    quiet messages |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `-q` | 这将显示直到安静级别的日志。它将包括错误和安静信息 |'
- en: '| `-i` | This will show logs up to the info level. It will include error, quiet,
    warning, lifecycle and info messages. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `-i` | 这将显示直到信息级别的日志。它将包括错误、安静、警告、生命周期和信息消息。|'
- en: '| `-s` | This prints out the stacktrace for all exceptions. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `-s` | 这将打印出所有异常的堆栈跟踪。|'
- en: '| `-d` | This prints out all logs and debug information. This is most expressive
    log level, which will also print all the minor details. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 这将打印出所有日志和调试信息。这是最表达性的日志级别，它还将打印所有细节。|'
- en: 'Now, execute `gradle showLogging -q`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行 `gradle showLogging -q`：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Apart from the regular lifecycle, Gradle provides an additional option to provide
    stack trace in case of any exception. Stack trace is different from debug. In
    case of any failure, it allows tracking of all the nested functions, which are
    called in sequence up to the point where the stack trace is generated.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的生命周期之外，Gradle 还提供了一个额外的选项，在发生任何异常时提供堆栈跟踪。堆栈跟踪与调试不同。在发生任何失败的情况下，它允许跟踪所有嵌套函数，这些函数按顺序调用，直到生成堆栈跟踪的点。
- en: 'To verify, add the `assert` statement in the preceding task and execute the
    following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证，在先前的任务中添加 `assert` 语句并执行以下操作：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With `stracktrace`, Gradle also provides two options:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `stracktrace`，Gradle 还提供了两个选项：
- en: '`-s` or `--stracktrace`: This will print truncated stracktrace'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s` 或 `--stracktrace`：这将打印截断的堆栈跟踪'
- en: '`-S` or `--full-stracktrace`: This will print full stracktrace'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-S` 或 `--full-stracktrace`：这将打印完整的堆栈跟踪'
- en: File management
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件管理
- en: One of the key features of any build tool is I/O operations and how easily you
    can perform the I/O operations such as reading files, writing files, and directory-related
    operations. Developers with Ant or Maven backgrounds know how painful and complex
    it was to handle the files and directory operations in old build tools; sometimes
    you had to write custom tasks and plugins to perform these kinds of operations
    due to XML limitations in Ant and Maven. Since Gradle uses Groovy, it will make
    your life much easier while dealing with files and directory-related operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何构建工具的关键特性之一是 I/O 操作以及你执行这些 I/O 操作（如读取文件、写入文件和目录相关操作）的容易程度。具有 Ant 或 Maven 背景的开发者知道在旧构建工具中处理文件和目录操作是多么痛苦和复杂；有时你不得不编写自定义任务和插件来执行这些类型的操作，因为
    Ant 和 Maven 中的 XML 限制。由于 Gradle 使用 Groovy，它将使你在处理文件和目录相关操作时生活变得更加容易。
- en: Reading files
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'Gradle provides simple ways to read the file. You just need to use the File
    API (application programing interface) and it provides everything to deal with
    the file. The following is the code snippet from `FileExample/build.gradle`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 提供了简单的方式来读取文件。你只需要使用文件 API（应用程序编程接口），它提供了处理文件所需的一切。以下是从 `FileExample/build.gradle`
    的代码片段：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To read the file, we have used `file(<file Name>)`. This is the default Gradle
    way to reference files because Gradle adds some path behavior `($PROJECT_PATH/<filename>)`
    due to absolute and relative referencing of files. Here, the first `println` statement
    will print the name of the file which is `readme.txt`. To read a file, Groovy
    provides the `eachLine` method to the `File` API, which reads all the lines of
    the file one by one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，我们使用了 `file(<文件名>)`。这是 Gradle 引用文件的默认方式，因为 Gradle 由于文件的绝对和相对引用而添加了一些路径行为
    `($PROJECT_PATH/<filename>)`。在这里，第一个 `println` 语句将打印文件名，即 `readme.txt`。为了读取文件，Groovy
    为 `File` API 提供了 `eachLine` 方法，该方法逐行读取文件的所有行。
- en: 'To access the directory, you can use the following file API:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问目录，你可以使用以下文件 API：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Writing files
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'To write to the files, you can use either the `append` method to add contents
    to the end of the file or overwrite the file using the `setText` or `write` methods:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入文件，你可以使用 `append` 方法将内容添加到文件末尾，或者使用 `setText` 或 `write` 方法覆盖文件：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating files/directories
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文件/目录
- en: 'You can create a new file by just writing some text to it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向其中写入一些文本来创建一个新文件：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By writing some data to the file, Groovy will automatically create the file
    if it does not exist.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向文件中写入一些数据，Groovy 将自动创建文件（如果不存在的话）。
- en: 'To write content to file you can also use the leftshift operator (`<<`), it
    will append data at the end of the file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要向文件写入内容，你也可以使用左移运算符 (`<<`)，它将在文件末尾追加数据：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you want to create an empty file, you can create a new file using the `createNewFile()`
    method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个空文件，你可以使用 `createNewFile()` 方法创建一个新文件。
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A new directory can be created using the `mkdir` command. Gradle also allows
    you to create nested directories in a single command using `mkdirs`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `mkdir` 命令创建一个新的目录。Gradle 还允许你使用 `mkdirs` 命令在一个命令中创建嵌套目录：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, we are creating two directories, one using `mkdir()`
    and the other using `createTempDir()`. The difference is when we create a directory
    using `createTempDir()`, that directory gets automatically deleted once your build
    script execution is completed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了两个目录，一个使用 `mkdir()`，另一个使用 `createTempDir()`。区别在于当我们使用 `createTempDir()`
    创建目录时，该目录会在构建脚本执行完成后自动删除。
- en: File operations
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件操作
- en: 'We will see examples of some of the frequently used methods while dealing with
    files, which will help you in build automation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一些在处理文件时经常使用的示例，这将有助于你在构建自动化中。
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Most of the preceding methods are self-explanatory. Try to execute the preceding
    task and observe the output. If you try to execute the `fileOperations` task twice,
    you will get the exception `readme.txt (No such file or directory)` since you
    have renamed the file to `writeme.txt`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前面的方法都是不言自明的。尝试执行前面的任务并观察输出。如果你尝试执行 `fileOperations` 任务两次，你会得到异常 `readme.txt
    (No such file or directory)`，因为你已经将文件重命名为 `writeme.txt`。
- en: Filter files
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤文件
- en: 'Certain file methods allow users to pass a regular expression as an argument.
    Regular expressions can be used to filter out only the required data, rather than
    fetch all the data. The following is an example of the `eachFileMatch()` method,
    which will list only the Groovy files in a directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 某些文件方法允许用户传递一个正则表达式作为参数。正则表达式可以用来过滤出所需的数据，而不是获取所有数据。以下是一个`eachFileMatch()`方法的示例，它将仅列出目录中的Groovy文件：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Delete files and directories
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除文件和目录
- en: 'Gradle provides the `delete()` and `deleteDir()` APIs to delete files and directories
    respectively:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle提供了`delete()`和`deleteDir()` API来分别删除文件和目录：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding task will create a directory `dir2` and a file `abc.txt`. Then
    it will print the absolute paths and finally delete them. You can verify whether
    it is deleted properly by calling the `exists()` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的任务将创建一个目录`dir2`和一个文件`abc.txt`。然后它将打印绝对路径，最后删除它们。您可以通过调用`exists()`函数来验证是否已正确删除。
- en: FileTree
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件树
- en: 'Until now, we have dealt with single file operations. Gradle provides plenty
    of user-friendly APIs to deal with file collections. One such API is **FileTree**.
    A FileTree represents a hierarchy of files or directories. It extends the `FileCollection`
    interface. Several objects in Gradle such as `sourceSets`, implement the `FileTree`
    interface. You can initialize FileTree with the `fileTree()` method. The following
    are the different ways you can initialize the `fileTree` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已处理了单个文件操作。Gradle提供了许多用户友好的API来处理文件集合。其中一个这样的API是**FileTree**。FileTree表示文件或目录的层次结构。它扩展了`FileCollection`接口。Gradle中的多个对象，如`sourceSets`，实现了`FileTree`接口。您可以使用`fileTree()`方法初始化FileTree。以下是可以初始化`fileTree`方法的不同方式：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Execute the `gradle fileTreeSample` command and observe the output. The first
    iteration will print all the files in `dir1`. The second iteration will only include
    Groovy files (with extension `.groovy`). The third iteration will exclude Groovy
    files (with extension `.groovy`) and print other files with absolute path.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`gradle fileTreeSample`命令并观察输出。第一次迭代将打印`dir1`中的所有文件。第二次迭代将仅包括Groovy文件（扩展名为`.groovy`）。第三次迭代将排除Groovy文件（扩展名为`.groovy`）并打印其他带有绝对路径的文件。
- en: 'You can also use FileTree to read contents from the archive files such as ZIP,
    JAR, or TAR files:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用文件树来读取诸如ZIP、JAR或TAR等存档文件的内容：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code snippet will list all the files contained in a `jar` file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将列出`jar`文件中包含的所有文件。
- en: Property management
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性管理
- en: 'We cannot make a software available on different operating systems, or different
    environments without configuring it dynamically. One approach to configure software
    is by using the properties file or environment properties. The following are the
    different ways Gradle provides to configure properties to `build.gradle`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在不进行动态配置的情况下在不同的操作系统或不同的环境中提供软件。配置软件的一种方法是通过使用属性文件或环境属性。以下列出了Gradle提供配置属性到`build.gradle`的不同方式：
- en: '`ext` closure'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext`闭包'
- en: '`gradle.properties`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gradle.properties`'
- en: Command line
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行
- en: Custom properties file
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性文件
- en: ext closure
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ext闭包
- en: We saw many examples in [Chapter 3](ch03.html "Chapter 3. Managing Task"), *Managing
    Task*, of adding custom properties to a project using the `ext` closure. Thus,
    we will not discuss the topic in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。管理任务")“管理任务”中看到了许多示例，使用`ext`闭包向项目中添加自定义属性。因此，我们不会在本章中讨论此主题。
- en: gradle.properties
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gradle.properties
- en: 'Gradle provides a default mechanism of reading the properties file using `gradle.properties`.
    You can add the `gradle.properties` file in any of the following locations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle提供了一个默认机制，使用`gradle.properties`来读取属性文件。您可以将`gradle.properties`文件添加到以下任何位置：
- en: '`<USER_HOME>/.gradle`: `gradle.properties` defined under this directory would
    be accessible to all the projects. You can use this file to define global properties
    and you can access these properties using `$project.<propertyname>`. If you have
    defined `GRADLE_USER_HOME` to some other directory, then Gradle will skip the
    `<USER_HOME>/.gradle` directory and will read `gradle.properties` from the `GRADLE_USER_HOME`
    directory. By default `<USER_HOME>/.gradle` would be considered to read the `gradle.properties`
    file. If properties are defined in `<USER_HOME>/.gradle/gradle.properties`, but
    are not set by the user, it leads to an exception. If this is not desired, such
    properties should be checked using the `hasProperty` method of `project`, and
    if not set, it should be initialized with a default value. This property file
    may also be used for storing passwords.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<USER_HOME>/.gradle`：在此目录下定义的 `gradle.properties` 可供所有项目访问。您可以使用此文件定义全局属性，并且可以使用
    `$project.<propertyname>` 访问这些属性。如果您已将 `GRADLE_USER_HOME` 定义为其他目录，则 Gradle 将跳过
    `<USER_HOME>/.gradle` 目录，并从 `GRADLE_USER_HOME` 目录读取 `gradle.properties`。默认情况下，`<USER_HOME>/.gradle`
    将被视为读取 `gradle.properties` 文件。如果 `<USER_HOME>/.gradle/gradle.properties` 中定义了属性，但用户未设置，则会导致异常。如果不希望出现这种情况，应使用
    `project` 的 `hasProperty` 方法检查这些属性，如果没有设置，则应使用默认值初始化。此属性文件也可用于存储密码。'
- en: '`<ProjectDir>`: `gradle.propertie`s defined under this directory would be accessible
    to the current project. You cannot access these properties from any other project.
    So, all the project-specific properties can be defined in the project''s `gradle.properties`
    file.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ProjectDir>`：在此目录下定义的 `gradle.properties` 可供当前项目访问。您无法从任何其他项目访问这些属性。因此，所有项目特定的属性都可以在项目的
    `gradle.properties` 文件中定义。'
- en: Along with project-level properties, you can also define system-level properties
    in the `gradle.properties` file. To define system-level properties, you can append
    properties with `systemProp`. So `systemProp.sProp1=sVal1` will set `sProp1` as
    a system-level property with the value `sVal1`.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了项目级别的属性外，您还可以在 `gradle.properties` 文件中定义系统级别的属性。要定义系统级别的属性，您可以使用 `systemProp`
    将属性追加。因此，`systemProp.sProp1=sVal1` 将 `sProp1` 设置为具有值 `sVal1` 的系统级别属性。
- en: We will see an example in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到一个示例。
- en: The command line
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行
- en: 'You can define runtime properties on the command line also using the `-P` and
    `-D` options. Using `-P`, you can define project-specific properties. Using `-D`,
    you can define system-level properties. To access system-level properties, you
    can use `System.properties[''<propertyname>''].`Note that, command line properties
    override `gradle.properties`. When you configure properties in multiple places,
    the following order applies and the last one gets the highest priority:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `-P` 和 `-D` 选项在命令行上定义运行时属性。使用 `-P`，您可以定义项目特定的属性。使用 `-D`，您可以定义系统级别的属性。要访问系统级别的属性，您可以使用
    `System.properties['<propertyname>']`。请注意，命令行属性会覆盖 `gradle.properties`。当您在多个位置配置属性时，以下顺序适用，最后一个具有最高优先级：
- en: '`gradle.properties` in project `build` dir.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 `build` 目录中的 `gradle.properties`
- en: '`gradle.properties` in Gradle user home.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle 用户主目录中的 `gradle.properties`
- en: System properties set on the command line.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行设置的系统属性。
- en: The Custom properties file
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义属性文件
- en: 'You might want to use the custom filename for your properties file, for example,
    `login.properties` or `profile.properties`. To use the custom properties, simply
    read the file using `FileInputStream` and convert it to the properties object:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望为属性文件使用自定义文件名，例如，`login.properties` 或 `profile.properties`。要使用自定义属性，只需使用
    `FileInputStream` 读取文件并将其转换为属性对象：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code will read the `login.properties` file, and the first `println`
    statement will print all the properties while the second `println` statement will
    display the value of the `loginKey1` property.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将读取 `login.properties` 文件，第一个 `println` 语句将打印所有属性，而第二个 `println` 语句将显示 `loginKey1`
    属性的值。
- en: 'Let''s take a look at a comprehensive example. We will create one `gradle.properties`
    file in the `<USER_HOME>/.gradle` directory and another `gradle.properties` file
    in the project directory:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个综合示例。我们将在 `<USER_HOME>/.gradle` 目录中创建一个 `gradle.properties` 文件，并在项目目录中创建另一个
    `gradle.properties` 文件：
- en: '`<USER_HOME>/.gradle/gradle.properties`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`<USER_HOME>/.gradle/gradle.properties`'
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Chapter6/PropertyExample/Proj1/gradle.properties`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter6/PropertyExample/Proj1/gradle.properties`'
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is our build script, `Chapter6/PropertyExample/Proj1/build.gradle`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的构建脚本，`Chapter6/PropertyExample/Proj1/build.gradle`：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, execute the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下命令：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, you can see that the first two lines contain the properties defined in
    the project's `gradle.properties` file. The third line shows the property, which
    the user initialize with the `-P` option. The fourth and fifth lines show the
    properties defined in `<USER_HOME>/.gradle/gradle.properties`. The sixth line
    shows the system properties defined in the project's `gradle.properties` file,
    and finally, the example shows the system property passed in the command line
    using the `-D` option.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到前两行包含在项目的 `gradle.properties` 文件中定义的属性。第三行显示了用户使用 `-P` 选项初始化的属性。第四和第五行显示了在
    `<USER_HOME>/.gradle/gradle.properties` 中定义的属性。第六行显示了在项目的 `gradle.properties`
    文件中定义的系统属性，最后，示例显示了使用 `-D` 选项在命令行中传递的系统属性。
- en: Multi-project build
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项目构建
- en: We have explored many features of Gradle such as tasks, plugins, and dependency
    management. We have seen many examples of the build script involving in-built
    tasks, custom tasks, and dependencies between the tasks. Yet, we have not covered
    one of the main features of Gradle, which is **Multi-Project Build**. Until now
    we have seen build files for a single project. A single project build file represents
    only one project or one module. It is a very common scenario in any software world
    that it starts with a single module initially and as the software matures and
    grows over time, it turns into a big project. Then we need to divide it again
    into different submodules, but overall, we build the project using one file only.
    Gradle provides the capability of treating different modules as a different project,
    which can be grouped under a root project. It also gives the flexibility of building
    a submodule independently without building the complete project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了 Gradle 的许多特性，例如任务、插件和依赖管理。我们看到了许多涉及内置任务、自定义任务和任务之间依赖关系的构建脚本示例。然而，我们还没有涵盖
    Gradle 的一个主要特性，即**多项目构建**。直到现在，我们只看到了单个项目的构建文件。单个项目构建文件仅代表一个项目或一个模块。在任何软件世界中，最初通常从一个模块开始，随着软件随着时间的推移成熟和增长，它变成一个大项目。然后我们需要再次将其划分为不同的子模块，但总体来说，我们只使用一个文件来构建项目。Gradle
    提供了将不同的模块视为不同项目的能力，这些项目可以归入根项目之下。它还提供了独立构建子模块而不构建完整项目的灵活性。
- en: Multi-project is not a new concept. The only additional capability Gradle provides
    is to build the modules separately as an individual subproject, and whenever required,
    you can build the entire module using the root project. The subproject has all
    the properties and features, which a project object has in Gradle. You can define
    modular dependencies to other projects. Gradle allows you to define subproject
    tasks' dependencies to other subprojects. You can build only one subproject (and
    its dependencies) to optimize the build performance time and so on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 多项目构建不是一个新概念。Gradle 提供的唯一附加功能是分别将模块作为单独的子项目构建，并且每当需要时，可以使用根项目构建整个模块。子项目具有 Gradle
    中项目对象的所有属性和功能。你可以定义模块之间的模块依赖关系。Gradle 允许你定义子项目任务对其他子项目的依赖关系。你可以仅构建一个子项目（及其依赖关系）以优化构建性能时间等。
- en: The Multi-project structure
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项目结构
- en: 'Consider a simple user management Java application, which authenticates and
    authorizes the user, allows the user to manage his profile, and perform transactions.
    Let''s say we divided this into three different subprojects or modules: login
    module, profile module, and transaction module.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的用户管理 Java 应用程序，该应用程序验证和授权用户，允许用户管理其个人资料，并执行交易。假设我们将这个应用程序划分为三个不同的子项目或模块：登录模块、个人资料模块和交易模块。
- en: One more question might arise, when we have already defined three subprojects
    why do we need the root project `UserManagement`, as it does not contain any source
    code? One of the purposes of the root project is to coordinate among the subprojects,
    define dependencies between the projects, if any, define common behaviors to avoid
    duplicate build configurations in each project, and more.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还会出现另一个问题，当我们已经定义了三个子项目时，为什么还需要根项目 `UserManagement`，因为它不包含任何源代码？根项目的一个目的就是在子项目之间进行协调，定义项目之间的依赖关系（如果有的话），定义公共行为以避免在每个项目中重复构建配置，等等。
- en: The purpose of these three modules is to work on them independently, build them
    separately, and if required, publish its artifacts without any dependency.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模块的目的是独立工作于它们，分别构建它们，如果需要，可以无任何依赖关系地发布其工件。
- en: 'The directory structure will look like the following diagram:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构将类似于以下图表：
- en: '![The Multi-project structure](img/B02000_06_04.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![多项目结构](img/B02000_06_04.jpg)'
- en: Figure 6.4
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4
- en: 'Here, we have created three subprojects: **login**, **profile**, and **transaction**,
    each module with its own `src/main/java` hierarchy. We have grouped the subprojects
    under the root project **UserManagement**. Additionally, the root project contains
    one **build.gradle** file and a **settings.gradle** file.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了三个子项目：**login**、**profile**和**transaction**，每个模块都有自己的`src/main/java`层次结构。我们将子项目分组在根项目**UserManagement**下。此外，根项目包含一个**build.gradle**文件和一个**settings.gradle**文件。
- en: 'The **settings.gradle** file is one of the key files in multi-project build.
    This file needs to be present in the root project''s directory. It lists all the
    subprojects. The content of the **settings.gradle** file is shown in the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.gradle**文件是多项目构建中的关键文件之一。此文件需要存在于根项目的目录中。它列出了所有子项目。以下代码显示了**settings.gradle**文件的内容：'
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we have included all the subprojects, which are part of the root project.
    On executing the following command, we get all the project details as output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已包含所有属于根项目的子项目。执行以下命令后，我们将获得所有项目详情作为输出：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output displays the root project `UserManagement`, and all the subprojects
    which are under the root project. Now, try to delete the `settings.gradle` file
    or remove the include statements in the `settings.gradle` file and run this command
    again. This time, it will display only root project details. The `settings.gradle`
    is an important file, which makes the root project aware of all the subprojects
    it should include. It is also possible to declare multiple levels of subprojects
    using `'subproject:subsubproject','subproject:subsubproject:subsubsubproject'`,
    and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了根项目`UserManagement`以及所有位于根项目下的子项目。现在，尝试删除`settings.gradle`文件或在`settings.gradle`文件中删除包含语句，然后再次运行此命令。这次，它将仅显示根项目详情。`settings.gradle`是一个重要的文件，它使根项目了解它应该包含的所有子项目。也可以使用`'subproject:subsubproject','subproject:subsubproject:subsubsubproject'`等来声明多级子项目。
- en: 'We talked about three phases of the Gradle build life cycle: initialization,
    configuration, and execution. Using the `settings.gradle` file during the initialization
    phase, Gradle adds all the subproject instances to the build process. You can
    also add projects by using the `include(String[])` method to this object.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了Gradle构建生命周期的三个阶段：初始化、配置和执行。在初始化阶段使用`settings.gradle`文件，Gradle会将所有子项目实例添加到构建过程中。您也可以通过使用`include(String[])`方法向此对象添加项目。
- en: The settings.gradle file also has access to the `gradle.properties` file defined
    in the settings directory of the build or `<USER_HOME>/.gradle` directory and
    properties provided on the command line using the `–P` option. The `settings.gradle`
    file can also execute Gradle tasks, and include plugins and other operations,
    which can be done in any `.gradle` file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings.gradle`文件还可以访问在构建的设置目录中定义的`gradle.properties`文件或`<USER_HOME>/.gradle`目录中的属性，以及使用`-P`选项在命令行上提供的属性。`settings.gradle`文件还可以执行Gradle任务，包括插件和其他操作，这些操作可以在任何`.gradle`文件中完成。'
- en: The Multi-project execution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项目执行
- en: To determine if the current build process is part of a multi-project build,
    it searches for the `settings.gradle` file first in the current directory and
    then in its parent hierarchy. If it finds `settings.gradle` in the same directory,
    it considers itself as a parent project and then checks for subprojects. In another
    case, if it finds the `settings.gradle` file in its parent hierarchy, it checks
    whether or not the current subdirectory is a subproject of the root project that
    is found. If the current project is part of the root project, then it is executed
    as a part of the multi-project build, otherwise, as a single project build.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定当前构建过程是否是多项目构建的一部分，它首先在当前目录中搜索`settings.gradle`文件，然后在其父级层次结构中搜索。如果在同一目录中找到`settings.gradle`，它将自己视为父项目，然后检查子项目。在另一种情况下，如果在其父级层次结构中找到`settings.gradle`文件，它会检查当前子目录是否是找到的根项目的子项目。如果当前项目是根项目的一部分，那么它作为多项目构建的一部分执行，否则作为单一项目构建。
- en: 'The following is the sample `build.gradle` under the `UserManagement` directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`UserManagement`目录下的示例`build.gradle`：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, try to execute the following command from the `UserManagement` directory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试从`UserManagement`目录执行以下命令：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, go to the `login` directory and execute the same command; you will find
    a similar output. The difference is, in the subproject, the help task would be
    replaced by: `login:help`, because Gradle automatically detects the subproject
    you are in.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `login` 目录并执行相同的命令；你会找到类似的输出。区别在于，在子项目中，帮助任务会被替换为：`login:help`，因为 Gradle
    会自动检测你所在的子项目。
- en: In the first scenario, Gradle found the settings.gradle file in the same directory
    and found three subprojects. Gradle initialized three subprojects and during configuration
    phase it executed the configuration statements. We did not mention any tasks,
    so no task is executed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，Gradle 在同一目录中找到了 settings.gradle 文件，并找到了三个子项目。Gradle 初始化了三个子项目，并在配置阶段执行了配置语句。我们没有提到任何任务，所以没有执行任何任务。
- en: In the second scenario, when we executed the Gradle command from the login module,
    Gradle again started searching for the `settings.gradle` file and found this file
    in the parent directory, and also found the current project to be a part of the
    multi-project build, and thus, executed the build script as a multi-project build.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，当我们从登录模块执行 Gradle 命令时，Gradle 再次开始搜索 `settings.gradle` 文件，并在父目录中找到了这个文件，并且也发现当前项目是多项目构建的一部分，因此作为多项目构建执行了构建脚本。
- en: 'One thing you might have noticed here is that we did not define any `build.gradle`
    for any of the subprojects. We added all the subprojects to the root project''s
    build file. This is one of the ways you can define the multi-project build. The
    alternative is to create individual build.gradle files in each of the subprojects.
    Just remove the project closures from the main build file and copy it to its respective
    project build file. The new project structure is shown in figure 6.4:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这里我们没有为任何子项目定义任何 `build.gradle` 文件。我们将所有子项目添加到了根项目的构建文件中。这是定义多项目构建的一种方法。另一种方法是，在每个子项目中创建单独的
    build.gradle 文件。只需从主构建文件中移除项目闭包，并将其复制到相应的项目构建文件中。新的项目结构如图 6.4 所示：
- en: '![The Multi-project execution](img/B02000_06_05.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![多项目执行](img/B02000_06_05.jpg)'
- en: Figure 6.5
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5
- en: Task execution
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务执行
- en: 'Before executing a task in the multi-project build, Gradle will search for
    the task in the root project and in all the subprojects. If the task are found
    in multiple projects, it will execute all the tasks consecutively. Execute the
    following command from the `UserManagement` directory:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行多项目构建中的任务之前，Gradle 将在根项目和所有子项目中搜索该任务。如果任务在多个项目中找到，它将依次执行所有任务。从 `UserManagement`
    目录执行以下命令：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, copy `loginTask` to the transaction project and try to execute the same
    command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `loginTask` 复制到交易项目，并尝试执行相同的命令：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, you can see the Gradle-executed `loginTask` in both the `login` and `transactions`
    projects. To execute a project-specific task, prefix the task name with the project
    name and use colon (`:`) as a separator—`gradle project:task`. To execute `loginTask`
    for the `login` module, use the `$ gradle login:loginTask` command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Gradle 在 `login` 和 `transactions` 项目中执行的 `loginTask`。要执行特定项目的任务，请在任务名称前加上项目名称，并使用冒号（`:`）作为分隔符——`gradle
    project:task`。要为 `login` 模块执行 `loginTask`，使用 `$ gradle login:loginTask` 命令。
- en: The multi-project build helps to avoid redundant configurations and allows optimizing
    and organizing the build file structure appropriately.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 多项目构建有助于避免冗余配置，并允许适当地优化和组织构建文件结构。
- en: 'In the preceding example, we have three subprojects and all have a dependency
    on the Java plugin. These subprojects might depend on some common libraries as
    well. Instead of defining dependencies in each of the subproject build files,
    we can define a common configuration into the root project. By doing so, the entire
    subproject will inherit this common configuration. This can be done by using two
    closures: `allprojects` and `subprojects`. The configuration defined under `allprojects`
    will be shared by all the subprojects, including the root project, whereas configuration
    under `subprojects` will be shared by all the subprojects excluding the root project.
    Add the following `subprojects{}` and `allprojects{}` closures, which are used
    to build a file and remove the `apply plugin: ''java''` statement from each subproject:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，我们有三个子项目，它们都依赖于Java插件。这些子项目可能还依赖于一些公共库。我们可以在根项目中定义一个公共配置，而不是在每个子项目的构建文件中定义依赖关系。这样做，整个子项目将继承这个公共配置。这可以通过使用两个闭包：`allprojects`和`subprojects`来实现。在`allprojects`下定义的配置将由所有子项目共享，包括根项目，而在`subprojects`下定义的配置将由所有子项目共享，但不包括根项目。添加以下`subprojects{}`和`allprojects{}`闭包，这些闭包用于构建文件并从每个子项目中移除`apply
    plugin: ''java''`语句：'
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we have added the Java plugin, `repositories` closure, and common dependencies
    to the `subprojects` closure. So, it will be shared by all the subprojects. We
    have added a version in `allprojects`, which would be shared by all the subprojects,
    including the root subproject.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将Java插件、`repositories`闭包和公共依赖项添加到`subprojects`闭包中。因此，它将由所有子项目共享。我们在`allprojects`中添加了一个版本，这将由所有子项目共享，包括根子项目。
- en: 'Now, try to execute the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试执行以下命令：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It has executed clean tasks in all the subprojects but not for the root project.
    Even if you try to execute `UserManagement:clean` task explicitly, it will throw
    an exception. If you add `apply plugin: ''java''` to the `allprojects` closure,
    it will add clean task to root project along with the subprojects.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '它已执行了所有子项目的clean任务，但未执行根项目的任务。即使你尝试显式执行`UserManagement:clean`任务，它也会抛出异常。如果你在`allprojects`闭包中添加`apply
    plugin: ''java''`，它将把clean任务添加到根项目和子项目中。'
- en: The Flat hierarchy
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平级层次结构
- en: Apart from the parent/child hierarchy, you can also create the subprojects at
    the same level, which can be included using the `includeFlat '<projectname>'`
    syntax.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了父/子层次结构之外，你还可以在同一级别创建子项目，可以使用`includeFlat '<projectname>'`语法来包含它们。
- en: Let's add one more subproject department at the same level with the `UserManagement`
    module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在与`UserManagement`模块同一级别的位置添加一个额外的子项目部门。
- en: 'The `department` module can be added as a subproject to the `UserManagement`
    project by adding the following code in the `settings.gradle` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`settings.gradle`文件中添加以下代码，将`department`模块作为子项目添加到`UserManagement`项目中：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Interproject dependency
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项间依赖
- en: 'When you execute some common tasks such as `clean` and `compile` (after adding
    the Java plugin) on a multi-project build, the default execution order is based
    on their alphabetical order:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在多项目构建上执行一些常见任务，如`clean`和`compile`（在添加Java插件后），默认的执行顺序是基于它们的字母顺序：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first root project is getting evaluated and then all the subprojects as
    per their alphabetical order. To override the default behavior, Gradle provides
    you with a different level of dependency management.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先评估第一个根项目，然后按照字母顺序评估所有子项目。为了覆盖默认行为，Gradle为你提供了不同级别的依赖管理。
- en: Configuration-level dependency
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置级别的依赖
- en: The configuration-level dependency evaluates or configures a project after the
    execution of the project on which it depends upon. For example, you want to set
    some properties in the profile project and you want to use those properties in
    the login project. You can achieve this using `evaluationDependsOn`. To enable
    this feature, you should have separate `build.gradle` files for each subproject.
    Let's create independent `build.gradle` for each subprojects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 配置级别的依赖在依赖于它的项目执行之后评估或配置项目。例如，你想要在配置项目中设置一些属性，并想要在登录项目中使用这些属性。你可以通过使用`evaluationDependsOn`来实现这一点。为了启用此功能，你应该为每个子项目有单独的`build.gradle`文件。让我们为每个子项目创建独立的`build.gradle`文件。
- en: You can create each subproject and `build.gradle` in the following pattern.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下模式创建每个子项目和`build.gradle`。
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The root project `build.gradle` will look like the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根项目`build.gradle`将如下所示：
- en: '`UserManagement_confDep/build.gradle`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserManagement_confDep/build.gradle`'
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, execute the following Gradle command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下Gradle命令：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have executed the Gradle command without any task. It has executed up to
    the configuration phase and you can see the preceding configuration order in alphabetical
    order (after root project configuration).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有执行任何任务就执行了Gradle命令。它执行到了配置阶段，你可以看到之前的配置顺序按字母顺序排列（在根项目配置之后）。
- en: 'Now, add the following statement in your login project `build.gradle` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的登录项目`build.gradle`文件中添加以下语句：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, execute the Gradle command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行Gradle命令：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, you can see that the profile configuration is evaluated before the login
    configuration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到配置配置在登录配置之前被评估。
- en: Task-level dependency
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务级别依赖
- en: 'There might be a situation when a task of a project may depend on another project
    task. Gradle allows you to maintain task-level dependencies across subprojects.
    Here is an example where `loginTask` depends on `profileTask`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一种情况，一个项目的任务可能依赖于另一个项目的任务。Gradle允许你在子项目之间维护任务级别的依赖关系。以下是一个示例，其中`loginTask`依赖于`profileTask`：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now the output shows the dependency between the tasks:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出显示了任务之间的依赖关系：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you declare an execution dependency between different projects with `dependsOn`,
    the default behavior of this method is to also create a configuration dependency
    between the two projects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`dependsOn`在不同项目之间声明执行依赖，此方法的默认行为是在两个项目之间创建配置依赖。
- en: Library dependency
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库依赖
- en: 'If one of the subprojects needs a class file or JAR file of another subproject
    to compile, this can be introduced as a compile time dependency. If the login
    project needs a profile jar in its classpath, you can introduce dependencies at
    compile level:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个子项目需要另一个子项目的类文件或JAR文件来编译，这可以作为一个编译时依赖引入。如果登录项目需要在它的类路径中包含配置JAR，你可以在编译级别引入依赖：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the output, we can realize that all the dependent modules were compiled
    before the login compile tasks were executed.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以意识到所有依赖模块都在执行登录编译任务之前被编译。
- en: Partial builds
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分构建
- en: 'During development, you might need to build the projects again and again. Sometimes
    you do not make any changes to your dependent subproject, but Gradle by default
    always builds the dependencies first and then builds the dependent subprojects.
    This process might affect overall build performance. To overcome this problem,
    Gradle provides a solution called partial builds. Partial builds enable you to
    build only the required project, not its dependency projects. In the preceding
    example, we have the compile dependency of the login module on the profile project.
    To compile the login project without the dependent profile project, command-line
    option `-a` can be applied:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你可能需要反复构建项目。有时你并没有对你的依赖子项目进行任何更改，但Gradle默认总是先构建依赖项，然后再构建依赖的子项目。这个过程可能会影响整体构建性能。为了解决这个问题，Gradle提供了一个名为部分构建的解决方案。部分构建允许你只构建所需的项目，而不是其依赖项目。在上面的示例中，我们有登录模块对配置项目的编译依赖。要编译不依赖配置子项目的登录项目，可以使用命令行选项`-a`：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: buildDependents
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: buildDependents
- en: In an enterprise project, we have project dependencies. When you want to build
    a project and at the same time you want to build the other dependent projects,
    the Java plugin provides the `buildDependents` option.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业项目中，我们有项目依赖。当你想构建一个项目，同时你又想构建其他依赖项目时，Java插件提供了`buildDependents`选项。
- en: 'In the previous example, the login project has compile time dependency on the
    profile project. We will try to build a profile with the `buildDependents` option:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，登录项目对配置项目有编译时依赖。我们将尝试使用`buildDependents`选项构建配置：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since the login module depends on the profile module, executing the profile
    project also builds the login project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于登录模块依赖于配置模块，执行配置项目也会构建登录项目。
- en: buildNeeded
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: buildNeeded
- en: 'When you build the project, it only compiles the code and prepares the JAR
    file. If you have compile-time dependencies on the other project, it only compiles
    the other project and prepares the JAR file. To check the functionality of the
    complete component, you might want to execute the test cases as well. To execute
    the test case of the subproject as well as the dependent project, use `buildNeeded`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建项目时，它只编译代码并准备JAR文件。如果你对其他项目有编译时依赖，它只编译其他项目并准备JAR文件。为了检查完整组件的功能，你可能还想执行测试用例。要执行子项目和依赖项目的测试用例，使用`buildNeeded`：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, `buildNeeded` not only executes the login test cases, it also executes
    the profile test cases.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`buildNeeded`不仅执行登录测试用例，还执行配置文件测试用例。
- en: Testing with Gradle
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gradle进行测试
- en: No piece of software is production ready unless it passes through a proper quality
    check. It helps to deliver software with minimum defects and saves lots of maintenance
    effort. However, manual test execution requires lots of time to execute tests
    and therefore the software release cycle is delayed. Release time and productivity
    can be improved if tests are automated.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 除非软件通过了适当的质量检查，否则没有任何软件是生产就绪的。这有助于以最低的缺陷交付软件，并节省大量的维护工作。然而，手动测试执行需要大量时间来执行测试，因此软件发布周期被延迟。如果测试自动化，可以改善发布时间和生产力。
- en: Gradle provides an automated way to execute test code, especially for unit tests.
    In the following section, we'll explore how to integrate JUnit and TestNG with
    Gradle.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle提供了一种自动执行测试代码的方法，特别是对于单元测试。在下一节中，我们将探讨如何将JUnit和TestNG与Gradle集成。
- en: JUnit
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JUnit
- en: 'Gradle''s Java plugin provides a predefined structure to keep test code and
    test resources for configuration and execution. As with the source code structure,
    the default test code location is `src/test/java/<test_package>`. If you follow
    this convention, you just need to execute the `test` task to run the unit test
    cases as shown in the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的Java插件提供了一个预定义的结构来保持测试代码和测试资源以进行配置和执行。与源代码结构一样，默认的测试代码位置是`src/test/java/<test_package>`。如果你遵循此约定，你只需执行`test`任务即可运行单元测试用例，如下面的命令所示：
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This test task will perform all the required operations such as the compilation
    of the source code, compilation of the test code, process resources, and finally,
    execution of the test cases and creation of reports.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试任务将执行所有必要的操作，例如编译源代码、编译测试代码、处理资源，最后执行测试用例并创建报告。
- en: 'JUnit provides a user-friendly format to understand the result. You will find
    the following hierarchy after executing the test task:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit提供了一个用户友好的格式来理解结果。在执行测试任务后，你会找到以下层次结构：
- en: '![JUnit](img/B02000_06_06.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![JUnit](img/B02000_06_06.jpg)'
- en: Figure 6.6
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6
- en: 'The `reports` folder contains a `tests` subdirectory, which has a test summary
    result in HTML format named `index.html`. If you open the `index.html` file, you
    will find the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`reports`文件夹包含一个名为`index.html`的HTML格式的`tests`子目录，其中包含测试摘要结果。如果你打开`index.html`文件，你会看到以下输出：'
- en: '![JUnit](img/B02000_06_07.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![JUnit](img/B02000_06_07.jpg)'
- en: Figure 6.7
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7
- en: It provides a complete analysis of test case scenarios such as number of test
    cases executed, test cases failed, ignored, and so on. From the report, you can
    drill down further to the individual test case level by following the hyperlinks
    on the report page. The report will show a detailed explanation of the error/exception
    that occurred, if any, and the execution time in a tabular format.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了对测试用例场景的完整分析，例如执行测试用例的数量、失败的测试用例、忽略的测试用例等。从报告中，你可以通过跟随报告页面上的超链接进一步深入到单个测试用例级别。如果发生错误/异常，报告将显示详细的解释，并以表格格式显示执行时间。
- en: 'Until now, we have only discussed the execution of the test cases using Gradle.
    To compile and execute test cases, we need a test framework library. Like any
    other configuration, you need to mention the JUnit JAR as a dependency for your
    project. Typically, the dependency is added as a `testCompile` configuration:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了使用Gradle执行测试用例。为了编译和执行测试用例，我们需要一个测试框架库。像任何其他配置一样，你需要将JUnit JAR作为项目的依赖项提及。通常，依赖项作为`testCompile`配置添加：
- en: '[PRE61]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This configuration will download the `junit-4.12.jar` from the Maven repository
    and the JAR file will be added to the classpath during the compilation and execution
    phase.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将从Maven仓库下载`junit-4.12.jar`，JAR文件将在编译和执行阶段添加到类路径中。
- en: Test configuration
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试配置
- en: There are different configuration parameters that can be set for test configuration,
    which help to optimize the resources and customize the behavior based on project
    requirements.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为测试配置设置不同的配置参数，这有助于优化资源并根据项目需求自定义行为。
- en: 'Sometimes, the test directory structure does not follow the default convention,
    that is, `src/test/java`. In a similar way to the source code directory configuration,
    you can configure the new test code location as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，测试目录结构不遵循默认约定，即`src/test/java`。与源代码目录配置类似，你可以按照以下方式配置新的测试代码位置：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: maxParallelForks
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: maxParallelForks
- en: 'Gradle executes the test cases in a separate JVM. By default, Gradle executes
    all the tests in a single process. You can specify the number of parallel processes
    by configuring the `maxParallelForks` property in the `test` closure. Its default
    value is one:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle在单独的JVM中执行测试用例。默认情况下，Gradle在单个进程中执行所有测试。您可以通过在`test`闭包中配置`maxParallelForks`属性来指定并行进程的数量。其默认值是`1`：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To understand how it works exactly, we can modify our previous example. Just
    create multiple copies of the test class in `src/test/java`. In our example, in
    the `TestUsingJunitParallel` project, we have created a total of five copies of
    the same `LoginTest` class as `LoginTest1`, `LoginTest2`, and so on. Now, execute
    the Gradle command with the `--info` option:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解其确切的工作方式，我们可以修改我们之前的例子。只需在`src/test/java`中创建测试类的多个副本。在我们的例子中，在`TestUsingJunitParallel`项目中，我们创建了总共五个与`LoginTest`相同的副本，例如`LoginTest1`、`LoginTest2`等。现在，使用`--info`选项执行Gradle命令：
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The command-line output shows that three processes were created by Gradle and
    all the test cases were executed in those processes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行输出显示Gradle创建了三个进程，并且所有测试用例都在这些进程中执行。
- en: The forkEvery option
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`forkEvery`选项'
- en: This option allows setting the number of test classes per process. The default
    value is `0`, that is, unlimited. If you set this option to a nonzero value, then
    a process will be created when this limit is reached.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许设置每个进程的测试类数。默认值是`0`，即无限。如果您将此选项设置为非零值，则当达到此限制时将创建进程。
- en: 'In the previous example, we have five test classes and we have set the parallel
    process count to three. Now, we will set the `forkEvery` option to `1`, so every
    process will execute only one test class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们有五个测试类，并将并行处理计数设置为三个。现在，我们将`forkEvery`选项设置为`1`，因此每个进程将只执行一个测试类：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: From the output, we can observe that Gradle first created three processes, which
    executed three test classes. Then, other two processes, for example, `'Gradle
    Test Executor 4'` and `'Gradle Test Executor 5'`, were created to execute another
    two test files.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以观察到Gradle首先创建了三个进程，执行了三个测试类。然后，创建了另外两个进程，例如`'Gradle Test Executor 4'`和`'Gradle
    Test Executor 5'`，用于执行另外两个测试文件。
- en: ignoreFailures
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 忽略失败
- en: 'Whenever any of the test cases fails, the build is marked as `FAILED`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪个测试用例失败，构建都会标记为`FAILED`：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you want the build to succeed irrespective of the test case outcome, you
    can add `ignoreFailures=true` in the build script `test` closure, as shown in
    the previous example. Its default value is `false`. On executing the test task
    again, the build will be successful as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望构建无论测试用例结果如何都成功，您可以在构建脚本`test`闭包中添加`ignoreFailures=true`，如前例所示。其默认值是`false`。再次执行测试任务时，构建将成功如下：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: filter
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤
- en: Gradle allows you a selective execution of test cases by filtering them based
    on different patterns. Suppose we have two test packages with four test cases.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle允许您通过基于不同的模式过滤测试用例来选择性地执行测试用例。假设我们有两个测试包，包含四个测试用例。
- en: '`/src/test/java/ch6/login/LoginTest.java` contains 2 test packages as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/test/java/ch6/login/LoginTest.java`包含以下两个测试包：'
- en: '`testUserLogin1()`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testUserLogin1()`'
- en: '`testUserLogin2()`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testUserLogin2()`'
- en: '`/src/test/java/ch6/profile/ProfileTest.java` contains 2 test packages as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/test/java/ch6/profile/ProfileTest.java`包含以下两个测试包：'
- en: '`testUserProfile1()`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testUserProfile1()`'
- en: '`testUserProfile2()`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testUserProfile2()`'
- en: 'The following code snippet shows how to apply a filter based on different patterns:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何根据不同的模式应用过滤器：
- en: '[PRE69]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The first filter will identify only two test cases from the `ch6.login` package.
    The second filter selects all four test cases, as test class names are matching
    the `*Test` pattern. The third statement finally filters only two test cases:
    `testUserLogin1()` and `testUserProfile1()`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个过滤器将只从`ch6.login`包中识别出两个测试用例。第二个过滤器选择所有四个测试用例，因为测试类名与`*Test`模式匹配。第三个语句最终只过滤出两个测试用例：`testUserLogin1()`和`testUserProfile1()`。
- en: 'Just comment the first two patterns and execute the test with filter pattern
    `*1`. Although we have a total of four test cases, you will find that Gradle executes
    one test case from each package. You can also include or exclude packages by using
    `include` or `exclude` with the package structure mentioned in the preceding example.
    If you only want to execute a single test class, you can also execute it by appending
    test classes to the command-line option `--tests`. Command `gradle tests --tests
    ch6.login.LoginTest` will execute only the test case mentioned in the `LoginTest`
    class:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 只注释前两个模式，并使用过滤器模式`*1`执行测试。尽管我们总共有四个测试用例，但你将发现Gradle会从每个包中执行一个测试用例。你也可以使用前面示例中提到的包结构，通过使用`include`或`exclude`来包含或排除包。如果你只想执行单个测试类，你也可以通过将测试类追加到命令行选项`--tests`来执行它：命令`gradle
    tests --tests ch6.login.LoginTest`将只执行`LoginTest`类中提到的测试用例：
- en: '![filter](img/B02000_06_08.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![filter](img/B02000_06_08.jpg)'
- en: Figure 6.8
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8
- en: TestNG
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TestNG
- en: 'Gradle also provides integration with the TestNG framework. To write test cases
    in TestNG, you need to add the dependency in the `build.gradle` file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle还提供了与TestNG框架的集成。要在TestNG中编写测试用例，你需要在`build.gradle`文件中添加依赖项：
- en: '[PRE70]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In our example, we have created a TestNG test class with three test cases.
    Now, by executing the test task, we get the report file created under `build/reports/tests`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个包含三个测试用例的TestNG测试类。现在，通过执行测试任务，我们得到在`build/reports/tests`下创建的报告文件：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, open the `index.html` file and you will see the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`index.html`文件，你会看到以下输出：
- en: '![TestNG](img/B02000_06_09.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![TestNG](img/B02000_06_09.jpg)'
- en: Figure 6.9
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9
- en: The look and feel of the report is similar to the JUnit that we saw earlier.
    Actually, JUnit and TestNG on their own generate completely different report formats,
    but Gradle reconciles them into a standard look and feel.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的外观和感觉与之前看到的JUnit相似。实际上，JUnit和TestNG本身生成完全不同的报告格式，但Gradle将它们协调成标准的外观和感觉。
- en: As explained in the *JUnit* section, you can also define other properties in
    the `test` closure such as `ignoreFailures`, `maxParallelForks`, and so on.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如*JUnit*部分所述，你还可以在`test`闭包中定义其他属性，例如`ignoreFailures`、`maxParallelForks`等。
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Execution based on group
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于组的执行
- en: 'In the preceding `test` closure, we have used the `useTestNG` option to enable
    `TestNG` support. You can also set other options such as groups and listeners
    in this closure. For example, the following setting only executes test cases with
    the group name `Smoke` and it creates an additional emailable `TestNG` report
    in the `reports/tests` folder:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`test`闭包中，我们使用了`useTestNG`选项来启用`TestNG`支持。你还可以在此闭包中设置其他选项，如组和监听器。例如，以下设置仅执行具有组名`Smoke`的测试用例，并在`reports/tests`文件夹中创建一个额外的可发送电子邮件的`TestNG`报告：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In `useTestNG`, you can group test cases based on the group attribute to the
    `@Test` annotation:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useTestNG`中，你可以根据`@Test`注解的group属性对测试用例进行分组：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In our example, we have grouped the test cases as `Smoke` and `Integration`.
    On executing the `test` task, only the `verifyArraySize` and `verifyArrayNotNull`
    test cases will be executed:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将测试用例分组为`Smoke`和`Integration`。在执行`test`任务时，只有`verifyArraySize`和`verifyArrayNotNull`测试用例将被执行：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Execution based on the TestNG suite file
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于TestNG套件文件的执行
- en: TestNG suite files provide better control to execute tests. In a test suite
    file, you can define all the test classes and methods that will be included to
    execute the test case, any filter based on group name, listener information, and
    so on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: TestNG套件文件提供了更好的控制来执行测试。在测试套件文件中，你可以定义所有将被包含以执行测试用例的测试类和方法，基于组名的任何过滤器，监听器信息等。
- en: 'We have created a `testng.xml` file in the `src/test/resource` folder. The
    file has three key pieces of information; the `listener` configuration to create
    an emailable report format, included the test group as `Smoke` and added the `ArrayTest`
    file as a test class. Using the test suite file, you can also configure other
    properties such as thread pool size, whether test classes or test methods will
    run in parallel, and many more:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`src/test/resource`文件夹中创建了一个`testng.xml`文件。该文件包含三个关键信息；创建可发送电子邮件的报告格式的`listener`配置，包含测试组为`Smoke`，并将`ArrayTest`文件作为测试类添加。使用测试套件文件，你还可以配置其他属性，例如线程池大小、测试类或测试方法是否并行运行，等等：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This suite file can be included in the `test` closure as follows. Then, on
    executing the test task, reports will be created in the `reports/tests` folder:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此套件文件可以按如下方式包含在`test`闭包中。然后，在执行测试任务时，报告将在`reports/tests`文件夹中创建：
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored different topics of Gradle such as I/O operations,
    logging, Multi-Project build and testing using Gradle. We also learned how easy
    it is to generate assets for web applications and Scala projects with Gradle.
    In the *Testing with Gradle* section, we learned some basics to execute tests
    with JUnit and TestNG.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Gradle 的不同主题，例如使用 Gradle 进行 I/O 操作、日志记录、多项目构建和测试。我们还学习了如何使用 Gradle
    轻松地为 Web 应用程序和 Scala 项目生成资源。在 *使用 Gradle 进行测试* 部分，我们学习了执行 JUnit 和 TestNG 测试的一些基础知识。
- en: In the next chapter, we will learn the code quality aspects of a Java project.
    We will analyze a few Gradle plugins such as Checkstyle and Sonar. Apart from
    learning these plugins, we will discuss another topic called Continuous Integration.
    These two topics will be combined and presented by exploration of two different
    continuous integration servers, namely Jenkins and TeamCity.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 Java 项目的代码质量方面。我们将分析几个 Gradle 插件，例如 Checkstyle 和 Sonar。除了学习这些插件之外，我们还将讨论另一个名为持续集成的主题。这两个主题将通过探索两个不同的持续集成服务器，即
    Jenkins 和 TeamCity，来结合并展示。
