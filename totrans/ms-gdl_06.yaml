- en: Chapter 6. Working with Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers some more plugins such as **War** and **Scala**, which will
    be helpful in building web applications and Scala applications. Additionally,
    we will discuss diverse topics such as **Property Management**, **Multi-Project
    build**, and **logging** aspects. In the *Multi-project build* section, we will
    discuss how Gradle supports multi-project build through the root project's build
    file. It also provides the flexibility of treating each module as a separate project,
    plus all the modules together like a single project. In the final section of this
    chapter, we will learn the automated testing aspects with Gradle. You will learn
    to execute unit tests with different configurations. In this section, we will
    learn about testing concepts with the examples of two commonly used testing frameworks,
    JUnit and TestNG.
  prefs: []
  type: TYPE_NORMAL
- en: The War plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The War plugin is used to build web projects, and like any other plugin, it
    can be added to the build file by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`War` plugin extends the Java plugin and helps to create the `war` archives.
    The `war` plugin automatically applies the Java plugin to the build file. During
    the build process, the plugin creates a `war` file instead of a `jar` file. The
    war plugin disables the `jar` task of the Java plugin and adds a default `war`
    archive task. By default, the content of the `war` file will be compiled classes
    from `src/main/java`; content from `src/main/webapp` and all the runtime dependencies.
    The content can be customized using the `war` closure as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have created a simple `servlet` file to display the current
    date and time, a `web.xml` file and a `build.gradle` file. The project structure
    is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The War plugin](img/B02000_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SimpleWebApp/build.gradle` file has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `war` plugin adds the `providedCompile` and `providedRuntime` dependency
    configurations on top of the Java plugin. The `providedCompile` and `providedRuntime`
    configurations have the same scope as `compile` and `runtime` respectively, but
    the only difference is that the libraries defined in these configurations will
    not be a part of the `war` archive. In our example, we have defined `servlet-api`
    as the `providedCompile` time dependency. So, this library is not included in
    the `WEB-INF/lib/` folder of the `war` file. This is because this library is provided
    by the servlet container such as Tomcat. So, when we deploy the application in
    a container, it is added by the container. You can confirm this by expanding the
    `war` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we might need to customize the project''s structure as well. For
    example, the `webapp` folder could be under the root project folder, not in the
    `src` folder. The `webapp` folder can also contain new folders such as `conf`
    and `resource` to store the properties files, Java scripts, images, and other
    assets. We might want to rename the `webapp` folder to `WebContent`. The proposed
    directory structure might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The War plugin](img/B02000_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2
  prefs: []
  type: TYPE_NORMAL
- en: We might also be interested in creating a `war` file with a custom name and
    version. Additionally, we might not want to copy any empty folder such as `images`
    or `js` to the `war` file.
  prefs: []
  type: TYPE_NORMAL
- en: To implement these new changes, add the additional properties to the `build.gradle`
    file as described here. The `webAppDirName` property sets the new `webapp` folder
    location to the `WebContent` folder. The `war` closure defines properties such
    as version and name, and sets the `includeEmptyDirs` option as `false`. By default,
    `includeEmptyDirs` is set to `true`. This means any empty folder in the `webapp`
    directory will be copied to the `war` file. By setting it to `false`, the empty
    folders such as `images` and `js` will not be copied to the `war` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following would be the contents of `CustomWebApp/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After the build is successful, the `war` file will be created as `simpleapp-1.0.war`.
    Execute the `jar -tvf build/libs/simpleapp-1.0.war` command and verify the content
    of the `war` file. You will find the `conf` folder is added to the `war` file,
    whereas `images` and `js` folders are not included.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also find the Jetty plugin interesting for web application deployment,
    which enables you to deploy the web application in an embedded container. This
    plugin automatically applies the War plugin to the project. The Jetty plugin defines
    three tasks; `jettyRun`, `jettyRunWar`, and `jettyStop`. Task `jettyRun` runs
    the web application in an embedded Jetty web container, whereas the `jettyRunWar`
    task helps to build the `war` file and then run it in the embedded web container.
    Task `jettyStop` stops the container instance. Covering more on war configuration
    is beyond the scope of the book, so for more information please refer to the Gradle
    API documentation. Here is the link: [https://docs.gradle.org/current/userguide/war_plugin.html](https://docs.gradle.org/current/userguide/war_plugin.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The Scala plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Scala** plugin helps you to build the Scala application. Like any other
    plugin, the Scala plugin can be applied to the build file by adding the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Scala plugin also extends the Java plugin and adds a few more tasks such
    as `compileScala`, `compileTestScala`, and `scaladoc` to work with Scala files.
    The task names are pretty much all named after their Java equivalent, simply replacing
    the `java` part with `scala`. The Scala project's directory structure is also
    similar to a Java project structure where production code is typically written
    under `src/main/scala` directory and test code is kept under the `src/test/scala`
    directory. Figure 6.3 shows the directory structure of a Scala project. You can
    also observe from the directory structure that a Scala project can contain a mix
    of Java and Scala source files. The `HelloScala.scala` file has the following
    content. The output is `Hello, Scala...` on the console. This is a very basic
    code and we will not be able to discuss much detail on the Scala programming language.
    We request readers to refer to the Scala language documentation available at [http://www.scala-lang.org/](http://www.scala-lang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To support the compilation of Scala source code, Scala libraries should be
    added in the dependency configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![The Scala plugin](img/B02000_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the Scala plugin extends the Java plugin and adds a few new tasks.
    For example, the `compileScala` task depends on the `compileJava` task and the
    `compileTestScala` task depends on the `compileTestJava` task. This can be understood
    easily, by executing `classes` and `testClasses` tasks and looking at the output.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Scala projects are also packaged as `jar` files. The `jar` task or `assemble`
    task creates a `jar` file in the `build/libs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Scala plugin does not add any extra convention to the Java plugin. Therefore,
    the conventions defined in the Java plugin, such as lib directory and report directory
    can be reused in the Scala plugin. The Scala plugin only adds few `sourceSet`
    properties such as `allScala`, `scala.srcDirs`, and `scala` to work with source
    set. The following task example displays different properties available to the
    Scala plugin. This example is similar to the convention example task that we created
    in [Chapter 4](ch04.html "Chapter 4. Plugin Management"), *Plugin Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code snippet from `ScalaApplication/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the task `displayScalaPluginConvention` is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will conclude this section by discussing how to execute Scala application
    from Gradle; we can create a simple task in the build file as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HelloScala` source file has a main method which prints `Hello, Scala...`
    in the console. The `runMain` task executes the main method and displays the output
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now we have used `println` everywhere in the build script to display
    the messages to the user. If you are coming from a Java background you know a
    `println` statement is not the right way to give information to the user. You
    need logging. Logging helps the user to classify the categories of messages to
    show at different levels. These different levels help users to print a correct
    message based on the situation. For example, when a user wants complete detailed
    tracking of your software, they can use debug level. Similarly, whenever a user
    wants very limited useful information while executing a task, they can use quiet
    or info level. Gradle provides the following different types of logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Log Level | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ERROR | This is used to show error messages |'
  prefs: []
  type: TYPE_TB
- en: '| QUIET | This is used to show limited useful information |'
  prefs: []
  type: TYPE_TB
- en: '| WARNING | This is used to show warning messages |'
  prefs: []
  type: TYPE_TB
- en: '| LIFECYCLE | This is used to show the progress (default level) |'
  prefs: []
  type: TYPE_TB
- en: '| INFO | This is used to show information messages |'
  prefs: []
  type: TYPE_TB
- en: '| DEBUG | This is used to show debug messages (all logs) |'
  prefs: []
  type: TYPE_TB
- en: 'By default, the Gradle log level is LIFECYCLE. The following is the code snippet
    from `LogExample/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, Gradle has printed all the logger statements upto the lifecycle level
    (including lifecycle), which is Gradle's default log level. You can also control
    the log level from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '| `-q` | This will show logs up to the quiet level. It will include error and
    quiet messages |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | This will show logs up to the info level. It will include error, quiet,
    warning, lifecycle and info messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | This prints out the stacktrace for all exceptions. |'
  prefs: []
  type: TYPE_TB
- en: '| `-d` | This prints out all logs and debug information. This is most expressive
    log level, which will also print all the minor details. |'
  prefs: []
  type: TYPE_TB
- en: 'Now, execute `gradle showLogging -q`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the regular lifecycle, Gradle provides an additional option to provide
    stack trace in case of any exception. Stack trace is different from debug. In
    case of any failure, it allows tracking of all the nested functions, which are
    called in sequence up to the point where the stack trace is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify, add the `assert` statement in the preceding task and execute the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With `stracktrace`, Gradle also provides two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-s` or `--stracktrace`: This will print truncated stracktrace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-S` or `--full-stracktrace`: This will print full stracktrace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features of any build tool is I/O operations and how easily you
    can perform the I/O operations such as reading files, writing files, and directory-related
    operations. Developers with Ant or Maven backgrounds know how painful and complex
    it was to handle the files and directory operations in old build tools; sometimes
    you had to write custom tasks and plugins to perform these kinds of operations
    due to XML limitations in Ant and Maven. Since Gradle uses Groovy, it will make
    your life much easier while dealing with files and directory-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle provides simple ways to read the file. You just need to use the File
    API (application programing interface) and it provides everything to deal with
    the file. The following is the code snippet from `FileExample/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To read the file, we have used `file(<file Name>)`. This is the default Gradle
    way to reference files because Gradle adds some path behavior `($PROJECT_PATH/<filename>)`
    due to absolute and relative referencing of files. Here, the first `println` statement
    will print the name of the file which is `readme.txt`. To read a file, Groovy
    provides the `eachLine` method to the `File` API, which reads all the lines of
    the file one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the directory, you can use the following file API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Writing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write to the files, you can use either the `append` method to add contents
    to the end of the file or overwrite the file using the `setText` or `write` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating files/directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a new file by just writing some text to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By writing some data to the file, Groovy will automatically create the file
    if it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write content to file you can also use the leftshift operator (`<<`), it
    will append data at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you want to create an empty file, you can create a new file using the `createNewFile()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A new directory can be created using the `mkdir` command. Gradle also allows
    you to create nested directories in a single command using `mkdirs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are creating two directories, one using `mkdir()`
    and the other using `createTempDir()`. The difference is when we create a directory
    using `createTempDir()`, that directory gets automatically deleted once your build
    script execution is completed.
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see examples of some of the frequently used methods while dealing with
    files, which will help you in build automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Most of the preceding methods are self-explanatory. Try to execute the preceding
    task and observe the output. If you try to execute the `fileOperations` task twice,
    you will get the exception `readme.txt (No such file or directory)` since you
    have renamed the file to `writeme.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Filter files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certain file methods allow users to pass a regular expression as an argument.
    Regular expressions can be used to filter out only the required data, rather than
    fetch all the data. The following is an example of the `eachFileMatch()` method,
    which will list only the Groovy files in a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Delete files and directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle provides the `delete()` and `deleteDir()` APIs to delete files and directories
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding task will create a directory `dir2` and a file `abc.txt`. Then
    it will print the absolute paths and finally delete them. You can verify whether
    it is deleted properly by calling the `exists()` function.
  prefs: []
  type: TYPE_NORMAL
- en: FileTree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we have dealt with single file operations. Gradle provides plenty
    of user-friendly APIs to deal with file collections. One such API is **FileTree**.
    A FileTree represents a hierarchy of files or directories. It extends the `FileCollection`
    interface. Several objects in Gradle such as `sourceSets`, implement the `FileTree`
    interface. You can initialize FileTree with the `fileTree()` method. The following
    are the different ways you can initialize the `fileTree` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Execute the `gradle fileTreeSample` command and observe the output. The first
    iteration will print all the files in `dir1`. The second iteration will only include
    Groovy files (with extension `.groovy`). The third iteration will exclude Groovy
    files (with extension `.groovy`) and print other files with absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use FileTree to read contents from the archive files such as ZIP,
    JAR, or TAR files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet will list all the files contained in a `jar` file.
  prefs: []
  type: TYPE_NORMAL
- en: Property management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cannot make a software available on different operating systems, or different
    environments without configuring it dynamically. One approach to configure software
    is by using the properties file or environment properties. The following are the
    different ways Gradle provides to configure properties to `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ext` closure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gradle.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom properties file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ext closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw many examples in [Chapter 3](ch03.html "Chapter 3. Managing Task"), *Managing
    Task*, of adding custom properties to a project using the `ext` closure. Thus,
    we will not discuss the topic in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: gradle.properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle provides a default mechanism of reading the properties file using `gradle.properties`.
    You can add the `gradle.properties` file in any of the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<USER_HOME>/.gradle`: `gradle.properties` defined under this directory would
    be accessible to all the projects. You can use this file to define global properties
    and you can access these properties using `$project.<propertyname>`. If you have
    defined `GRADLE_USER_HOME` to some other directory, then Gradle will skip the
    `<USER_HOME>/.gradle` directory and will read `gradle.properties` from the `GRADLE_USER_HOME`
    directory. By default `<USER_HOME>/.gradle` would be considered to read the `gradle.properties`
    file. If properties are defined in `<USER_HOME>/.gradle/gradle.properties`, but
    are not set by the user, it leads to an exception. If this is not desired, such
    properties should be checked using the `hasProperty` method of `project`, and
    if not set, it should be initialized with a default value. This property file
    may also be used for storing passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ProjectDir>`: `gradle.propertie`s defined under this directory would be accessible
    to the current project. You cannot access these properties from any other project.
    So, all the project-specific properties can be defined in the project''s `gradle.properties`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with project-level properties, you can also define system-level properties
    in the `gradle.properties` file. To define system-level properties, you can append
    properties with `systemProp`. So `systemProp.sProp1=sVal1` will set `sProp1` as
    a system-level property with the value `sVal1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will see an example in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define runtime properties on the command line also using the `-P` and
    `-D` options. Using `-P`, you can define project-specific properties. Using `-D`,
    you can define system-level properties. To access system-level properties, you
    can use `System.properties[''<propertyname>''].`Note that, command line properties
    override `gradle.properties`. When you configure properties in multiple places,
    the following order applies and the last one gets the highest priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gradle.properties` in project `build` dir.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gradle.properties` in Gradle user home.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System properties set on the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Custom properties file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might want to use the custom filename for your properties file, for example,
    `login.properties` or `profile.properties`. To use the custom properties, simply
    read the file using `FileInputStream` and convert it to the properties object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will read the `login.properties` file, and the first `println`
    statement will print all the properties while the second `println` statement will
    display the value of the `loginKey1` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a comprehensive example. We will create one `gradle.properties`
    file in the `<USER_HOME>/.gradle` directory and another `gradle.properties` file
    in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<USER_HOME>/.gradle/gradle.properties`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`Chapter6/PropertyExample/Proj1/gradle.properties`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our build script, `Chapter6/PropertyExample/Proj1/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that the first two lines contain the properties defined in
    the project's `gradle.properties` file. The third line shows the property, which
    the user initialize with the `-P` option. The fourth and fifth lines show the
    properties defined in `<USER_HOME>/.gradle/gradle.properties`. The sixth line
    shows the system properties defined in the project's `gradle.properties` file,
    and finally, the example shows the system property passed in the command line
    using the `-D` option.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-project build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored many features of Gradle such as tasks, plugins, and dependency
    management. We have seen many examples of the build script involving in-built
    tasks, custom tasks, and dependencies between the tasks. Yet, we have not covered
    one of the main features of Gradle, which is **Multi-Project Build**. Until now
    we have seen build files for a single project. A single project build file represents
    only one project or one module. It is a very common scenario in any software world
    that it starts with a single module initially and as the software matures and
    grows over time, it turns into a big project. Then we need to divide it again
    into different submodules, but overall, we build the project using one file only.
    Gradle provides the capability of treating different modules as a different project,
    which can be grouped under a root project. It also gives the flexibility of building
    a submodule independently without building the complete project.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-project is not a new concept. The only additional capability Gradle provides
    is to build the modules separately as an individual subproject, and whenever required,
    you can build the entire module using the root project. The subproject has all
    the properties and features, which a project object has in Gradle. You can define
    modular dependencies to other projects. Gradle allows you to define subproject
    tasks' dependencies to other subprojects. You can build only one subproject (and
    its dependencies) to optimize the build performance time and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Multi-project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a simple user management Java application, which authenticates and
    authorizes the user, allows the user to manage his profile, and perform transactions.
    Let''s say we divided this into three different subprojects or modules: login
    module, profile module, and transaction module.'
  prefs: []
  type: TYPE_NORMAL
- en: One more question might arise, when we have already defined three subprojects
    why do we need the root project `UserManagement`, as it does not contain any source
    code? One of the purposes of the root project is to coordinate among the subprojects,
    define dependencies between the projects, if any, define common behaviors to avoid
    duplicate build configurations in each project, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of these three modules is to work on them independently, build them
    separately, and if required, publish its artifacts without any dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory structure will look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Multi-project structure](img/B02000_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have created three subprojects: **login**, **profile**, and **transaction**,
    each module with its own `src/main/java` hierarchy. We have grouped the subprojects
    under the root project **UserManagement**. Additionally, the root project contains
    one **build.gradle** file and a **settings.gradle** file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **settings.gradle** file is one of the key files in multi-project build.
    This file needs to be present in the root project''s directory. It lists all the
    subprojects. The content of the **settings.gradle** file is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have included all the subprojects, which are part of the root project.
    On executing the following command, we get all the project details as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The output displays the root project `UserManagement`, and all the subprojects
    which are under the root project. Now, try to delete the `settings.gradle` file
    or remove the include statements in the `settings.gradle` file and run this command
    again. This time, it will display only root project details. The `settings.gradle`
    is an important file, which makes the root project aware of all the subprojects
    it should include. It is also possible to declare multiple levels of subprojects
    using `'subproject:subsubproject','subproject:subsubproject:subsubsubproject'`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We talked about three phases of the Gradle build life cycle: initialization,
    configuration, and execution. Using the `settings.gradle` file during the initialization
    phase, Gradle adds all the subproject instances to the build process. You can
    also add projects by using the `include(String[])` method to this object.'
  prefs: []
  type: TYPE_NORMAL
- en: The settings.gradle file also has access to the `gradle.properties` file defined
    in the settings directory of the build or `<USER_HOME>/.gradle` directory and
    properties provided on the command line using the `–P` option. The `settings.gradle`
    file can also execute Gradle tasks, and include plugins and other operations,
    which can be done in any `.gradle` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Multi-project execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To determine if the current build process is part of a multi-project build,
    it searches for the `settings.gradle` file first in the current directory and
    then in its parent hierarchy. If it finds `settings.gradle` in the same directory,
    it considers itself as a parent project and then checks for subprojects. In another
    case, if it finds the `settings.gradle` file in its parent hierarchy, it checks
    whether or not the current subdirectory is a subproject of the root project that
    is found. If the current project is part of the root project, then it is executed
    as a part of the multi-project build, otherwise, as a single project build.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample `build.gradle` under the `UserManagement` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try to execute the following command from the `UserManagement` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the `login` directory and execute the same command; you will find
    a similar output. The difference is, in the subproject, the help task would be
    replaced by: `login:help`, because Gradle automatically detects the subproject
    you are in.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first scenario, Gradle found the settings.gradle file in the same directory
    and found three subprojects. Gradle initialized three subprojects and during configuration
    phase it executed the configuration statements. We did not mention any tasks,
    so no task is executed.
  prefs: []
  type: TYPE_NORMAL
- en: In the second scenario, when we executed the Gradle command from the login module,
    Gradle again started searching for the `settings.gradle` file and found this file
    in the parent directory, and also found the current project to be a part of the
    multi-project build, and thus, executed the build script as a multi-project build.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing you might have noticed here is that we did not define any `build.gradle`
    for any of the subprojects. We added all the subprojects to the root project''s
    build file. This is one of the ways you can define the multi-project build. The
    alternative is to create individual build.gradle files in each of the subprojects.
    Just remove the project closures from the main build file and copy it to its respective
    project build file. The new project structure is shown in figure 6.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Multi-project execution](img/B02000_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5
  prefs: []
  type: TYPE_NORMAL
- en: Task execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before executing a task in the multi-project build, Gradle will search for
    the task in the root project and in all the subprojects. If the task are found
    in multiple projects, it will execute all the tasks consecutively. Execute the
    following command from the `UserManagement` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, copy `loginTask` to the transaction project and try to execute the same
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the Gradle-executed `loginTask` in both the `login` and `transactions`
    projects. To execute a project-specific task, prefix the task name with the project
    name and use colon (`:`) as a separator—`gradle project:task`. To execute `loginTask`
    for the `login` module, use the `$ gradle login:loginTask` command.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-project build helps to avoid redundant configurations and allows optimizing
    and organizing the build file structure appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we have three subprojects and all have a dependency
    on the Java plugin. These subprojects might depend on some common libraries as
    well. Instead of defining dependencies in each of the subproject build files,
    we can define a common configuration into the root project. By doing so, the entire
    subproject will inherit this common configuration. This can be done by using two
    closures: `allprojects` and `subprojects`. The configuration defined under `allprojects`
    will be shared by all the subprojects, including the root project, whereas configuration
    under `subprojects` will be shared by all the subprojects excluding the root project.
    Add the following `subprojects{}` and `allprojects{}` closures, which are used
    to build a file and remove the `apply plugin: ''java''` statement from each subproject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added the Java plugin, `repositories` closure, and common dependencies
    to the `subprojects` closure. So, it will be shared by all the subprojects. We
    have added a version in `allprojects`, which would be shared by all the subprojects,
    including the root subproject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It has executed clean tasks in all the subprojects but not for the root project.
    Even if you try to execute `UserManagement:clean` task explicitly, it will throw
    an exception. If you add `apply plugin: ''java''` to the `allprojects` closure,
    it will add clean task to root project along with the subprojects.'
  prefs: []
  type: TYPE_NORMAL
- en: The Flat hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the parent/child hierarchy, you can also create the subprojects at
    the same level, which can be included using the `includeFlat '<projectname>'`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add one more subproject department at the same level with the `UserManagement`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `department` module can be added as a subproject to the `UserManagement`
    project by adding the following code in the `settings.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Interproject dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you execute some common tasks such as `clean` and `compile` (after adding
    the Java plugin) on a multi-project build, the default execution order is based
    on their alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first root project is getting evaluated and then all the subprojects as
    per their alphabetical order. To override the default behavior, Gradle provides
    you with a different level of dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration-level dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The configuration-level dependency evaluates or configures a project after the
    execution of the project on which it depends upon. For example, you want to set
    some properties in the profile project and you want to use those properties in
    the login project. You can achieve this using `evaluationDependsOn`. To enable
    this feature, you should have separate `build.gradle` files for each subproject.
    Let's create independent `build.gradle` for each subprojects.
  prefs: []
  type: TYPE_NORMAL
- en: You can create each subproject and `build.gradle` in the following pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The root project `build.gradle` will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserManagement_confDep/build.gradle`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the following Gradle command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We have executed the Gradle command without any task. It has executed up to
    the configuration phase and you can see the preceding configuration order in alphabetical
    order (after root project configuration).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following statement in your login project `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, execute the Gradle command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can see that the profile configuration is evaluated before the login
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Task-level dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There might be a situation when a task of a project may depend on another project
    task. Gradle allows you to maintain task-level dependencies across subprojects.
    Here is an example where `loginTask` depends on `profileTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output shows the dependency between the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you declare an execution dependency between different projects with `dependsOn`,
    the default behavior of this method is to also create a configuration dependency
    between the two projects.
  prefs: []
  type: TYPE_NORMAL
- en: Library dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If one of the subprojects needs a class file or JAR file of another subproject
    to compile, this can be introduced as a compile time dependency. If the login
    project needs a profile jar in its classpath, you can introduce dependencies at
    compile level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can realize that all the dependent modules were compiled
    before the login compile tasks were executed.
  prefs: []
  type: TYPE_NORMAL
- en: Partial builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During development, you might need to build the projects again and again. Sometimes
    you do not make any changes to your dependent subproject, but Gradle by default
    always builds the dependencies first and then builds the dependent subprojects.
    This process might affect overall build performance. To overcome this problem,
    Gradle provides a solution called partial builds. Partial builds enable you to
    build only the required project, not its dependency projects. In the preceding
    example, we have the compile dependency of the login module on the profile project.
    To compile the login project without the dependent profile project, command-line
    option `-a` can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: buildDependents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an enterprise project, we have project dependencies. When you want to build
    a project and at the same time you want to build the other dependent projects,
    the Java plugin provides the `buildDependents` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the login project has compile time dependency on the
    profile project. We will try to build a profile with the `buildDependents` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since the login module depends on the profile module, executing the profile
    project also builds the login project.
  prefs: []
  type: TYPE_NORMAL
- en: buildNeeded
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you build the project, it only compiles the code and prepares the JAR
    file. If you have compile-time dependencies on the other project, it only compiles
    the other project and prepares the JAR file. To check the functionality of the
    complete component, you might want to execute the test cases as well. To execute
    the test case of the subproject as well as the dependent project, use `buildNeeded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, `buildNeeded` not only executes the login test cases, it also executes
    the profile test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No piece of software is production ready unless it passes through a proper quality
    check. It helps to deliver software with minimum defects and saves lots of maintenance
    effort. However, manual test execution requires lots of time to execute tests
    and therefore the software release cycle is delayed. Release time and productivity
    can be improved if tests are automated.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle provides an automated way to execute test code, especially for unit tests.
    In the following section, we'll explore how to integrate JUnit and TestNG with
    Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle''s Java plugin provides a predefined structure to keep test code and
    test resources for configuration and execution. As with the source code structure,
    the default test code location is `src/test/java/<test_package>`. If you follow
    this convention, you just need to execute the `test` task to run the unit test
    cases as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This test task will perform all the required operations such as the compilation
    of the source code, compilation of the test code, process resources, and finally,
    execution of the test cases and creation of reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit provides a user-friendly format to understand the result. You will find
    the following hierarchy after executing the test task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JUnit](img/B02000_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reports` folder contains a `tests` subdirectory, which has a test summary
    result in HTML format named `index.html`. If you open the `index.html` file, you
    will find the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JUnit](img/B02000_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7
  prefs: []
  type: TYPE_NORMAL
- en: It provides a complete analysis of test case scenarios such as number of test
    cases executed, test cases failed, ignored, and so on. From the report, you can
    drill down further to the individual test case level by following the hyperlinks
    on the report page. The report will show a detailed explanation of the error/exception
    that occurred, if any, and the execution time in a tabular format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have only discussed the execution of the test cases using Gradle.
    To compile and execute test cases, we need a test framework library. Like any
    other configuration, you need to mention the JUnit JAR as a dependency for your
    project. Typically, the dependency is added as a `testCompile` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will download the `junit-4.12.jar` from the Maven repository
    and the JAR file will be added to the classpath during the compilation and execution
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Test configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are different configuration parameters that can be set for test configuration,
    which help to optimize the resources and customize the behavior based on project
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the test directory structure does not follow the default convention,
    that is, `src/test/java`. In a similar way to the source code directory configuration,
    you can configure the new test code location as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: maxParallelForks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gradle executes the test cases in a separate JVM. By default, Gradle executes
    all the tests in a single process. You can specify the number of parallel processes
    by configuring the `maxParallelForks` property in the `test` closure. Its default
    value is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how it works exactly, we can modify our previous example. Just
    create multiple copies of the test class in `src/test/java`. In our example, in
    the `TestUsingJunitParallel` project, we have created a total of five copies of
    the same `LoginTest` class as `LoginTest1`, `LoginTest2`, and so on. Now, execute
    the Gradle command with the `--info` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The command-line output shows that three processes were created by Gradle and
    all the test cases were executed in those processes.
  prefs: []
  type: TYPE_NORMAL
- en: The forkEvery option
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This option allows setting the number of test classes per process. The default
    value is `0`, that is, unlimited. If you set this option to a nonzero value, then
    a process will be created when this limit is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we have five test classes and we have set the parallel
    process count to three. Now, we will set the `forkEvery` option to `1`, so every
    process will execute only one test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can observe that Gradle first created three processes, which
    executed three test classes. Then, other two processes, for example, `'Gradle
    Test Executor 4'` and `'Gradle Test Executor 5'`, were created to execute another
    two test files.
  prefs: []
  type: TYPE_NORMAL
- en: ignoreFailures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever any of the test cases fails, the build is marked as `FAILED`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the build to succeed irrespective of the test case outcome, you
    can add `ignoreFailures=true` in the build script `test` closure, as shown in
    the previous example. Its default value is `false`. On executing the test task
    again, the build will be successful as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: filter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gradle allows you a selective execution of test cases by filtering them based
    on different patterns. Suppose we have two test packages with four test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/test/java/ch6/login/LoginTest.java` contains 2 test packages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testUserLogin1()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testUserLogin2()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/src/test/java/ch6/profile/ProfileTest.java` contains 2 test packages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testUserProfile1()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testUserProfile2()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to apply a filter based on different patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The first filter will identify only two test cases from the `ch6.login` package.
    The second filter selects all four test cases, as test class names are matching
    the `*Test` pattern. The third statement finally filters only two test cases:
    `testUserLogin1()` and `testUserProfile1()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just comment the first two patterns and execute the test with filter pattern
    `*1`. Although we have a total of four test cases, you will find that Gradle executes
    one test case from each package. You can also include or exclude packages by using
    `include` or `exclude` with the package structure mentioned in the preceding example.
    If you only want to execute a single test class, you can also execute it by appending
    test classes to the command-line option `--tests`. Command `gradle tests --tests
    ch6.login.LoginTest` will execute only the test case mentioned in the `LoginTest`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![filter](img/B02000_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8
  prefs: []
  type: TYPE_NORMAL
- en: TestNG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle also provides integration with the TestNG framework. To write test cases
    in TestNG, you need to add the dependency in the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we have created a TestNG test class with three test cases.
    Now, by executing the test task, we get the report file created under `build/reports/tests`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `index.html` file and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TestNG](img/B02000_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9
  prefs: []
  type: TYPE_NORMAL
- en: The look and feel of the report is similar to the JUnit that we saw earlier.
    Actually, JUnit and TestNG on their own generate completely different report formats,
    but Gradle reconciles them into a standard look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the *JUnit* section, you can also define other properties in
    the `test` closure such as `ignoreFailures`, `maxParallelForks`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Execution based on group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the preceding `test` closure, we have used the `useTestNG` option to enable
    `TestNG` support. You can also set other options such as groups and listeners
    in this closure. For example, the following setting only executes test cases with
    the group name `Smoke` and it creates an additional emailable `TestNG` report
    in the `reports/tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In `useTestNG`, you can group test cases based on the group attribute to the
    `@Test` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we have grouped the test cases as `Smoke` and `Integration`.
    On executing the `test` task, only the `verifyArraySize` and `verifyArrayNotNull`
    test cases will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Execution based on the TestNG suite file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TestNG suite files provide better control to execute tests. In a test suite
    file, you can define all the test classes and methods that will be included to
    execute the test case, any filter based on group name, listener information, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a `testng.xml` file in the `src/test/resource` folder. The
    file has three key pieces of information; the `listener` configuration to create
    an emailable report format, included the test group as `Smoke` and added the `ArrayTest`
    file as a test class. Using the test suite file, you can also configure other
    properties such as thread pool size, whether test classes or test methods will
    run in parallel, and many more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This suite file can be included in the `test` closure as follows. Then, on
    executing the test task, reports will be created in the `reports/tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored different topics of Gradle such as I/O operations,
    logging, Multi-Project build and testing using Gradle. We also learned how easy
    it is to generate assets for web applications and Scala projects with Gradle.
    In the *Testing with Gradle* section, we learned some basics to execute tests
    with JUnit and TestNG.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn the code quality aspects of a Java project.
    We will analyze a few Gradle plugins such as Checkstyle and Sonar. Apart from
    learning these plugins, we will discuss another topic called Continuous Integration.
    These two topics will be combined and presented by exploration of two different
    continuous integration servers, namely Jenkins and TeamCity.
  prefs: []
  type: TYPE_NORMAL
