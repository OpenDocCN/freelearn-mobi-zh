["```swift\n//Interface\n@interface Ch8_Tiled : GameArea2D {\nCCTMXTiledMap *tileMap;\n}\n@end\n//Implementation\n@implementation Ch8_Tiled\n-(CCLayer*) runRecipe {\n//Load TMX tilemap file\ntileMap = [CCTMXTiledMap tiledMapWithTMXFile:@\"tilemap.tmx\"];\n//Set game area size based on tilemap size\n[self setGameAreaSize];\n//Superclass initialization and message\n[super runRecipe];\n[self showMessage:@\"Use the DPad to move the actor around.\"];\n//Add tile map\n[gameNode addChild:tileMap z:0];\n/* Re-order layers according to their Y value. This creates isometric depth. */\n//Our layers\nCCTMXLayer *collidableLayer = [tileMap layerNamed:@\"Collidable\"];\nCCTMXLayer *ground = [tileMap layerNamed:@\"Ground\"];\nCCTMXLayer *wall = [tileMap layerNamed:@\"Wall\"];\n//Gather all the layers into a container\nfloat mw = tileMap.mapSize.width; float mh = tileMap.mapSize.height;\nfloat tw = tileMap.tileSize.width; float th = tileMap.tileSize.height;\nNSMutableDictionary *layersToReorder = [[[NSMutableDictionary alloc] init] autorelease];\nfor( CCTMXLayer* child in [tileMap children] ) {\n//Skip tiles marked \"Collidable\", \"Ground\" and \"Wall\"\nif(child == ground){ continue; }\nelse if(child == wall){ continue; }\nelse if(child == collidableLayer){ continue; }\n//Gather all the layers\nfor(float x=0; x<mw; x+=1){\nfor(float y=mh-1; y>=0; y-=1){\nCCSprite *childTile = [child tileAt:ccp(x,y)];\nCCSprite *collideTile = [collidableLayer tileAt:ccp(x,y)];\nif(childTile && collideTile){\n[layersToReorder setObject:[NSNumber numberWithFloat:y] forKey:[child layerName]];\nx=mw; y=-1;\n}\n}\n}\n}\n//Re-order gathered layers\nfor(id key in layersToReorder){\nNSString *str = (NSString*)key;\n[tileMap reorderChild:[tileMap layerNamed:str] z:[[layersToReorder objectForKey:key] floatValue]];\n}\n//Set the ground to z=0\n[tileMap reorderChild:ground z:0];\n//Add Box2D boxes to represent all layers marked \"Collidable\"\nfor(float x=0; x<mw; x+=1){\nfor(float y=0; y<mh; y+=1){\nif([collidableLayer tileAt:ccp(x,y)]){\n[self addBoxAtPoint:ccp(x*tw, mh*th - y*th) size:ccp(tw/2,th/2)];\n}\n}\n}\n//Remove the \"Collidable\" layer art as it's only an indicator for the level editor\n[tileMap removeChild:collidableLayer cleanup:YES];\nreturn self;\n}\n-(void) step: (ccTime) dt {\n[super step:dt];\n/* CODE OMITTED */\n//Re-order the actor\nfloat mh = tileMap.mapSize.height;\nfloat th = tileMap.tileSize.height;\nCGPoint p = [actor.sprite position];\nfloat z = -(p.y/th) + mh;\n[tileMap reorderChild:actor.sprite z:z ];\n}\n-(void) setGameAreaSize {\n//Set gameAreaSize based on tileMap size\ngameAreaSize = ccp((tileMap.mapSize.width * tileMap.tileSize.width)/PTM_RATIO,(tileMap.mapSize.height * tileMap.tileSize.height)/PTM_RATIO); //Box2d units\n}\n-(void) addActor {\n//Get spawn point from tile object named \"SpawnPoint\"\nif(!spawnPoint){\nCCTMXObjectGroup *objects = [tileMap objectGroupNamed:@\"Objects\"];\nNSAssert(objects != nil, @\"'Objects' object group not found\");\nNSMutableDictionary *sp = [objects objectNamed:@\"SpawnPoint\"];\nNSAssert(sp != nil, @\"SpawnPoint object not found\");\nint x = [[sp valueForKey:@\"x\"] intValue];\nint y = [[sp valueForKey:@\"y\"] intValue];\nspawnPoint = [Vector3D x:x y:y z:0];\n}\n//Add actor\n/* CODE OMITTED */\n[tileMap addChild:actor.sprite z:[[tileMap layerNamed:@\"0\"] vertexZ]];\n}\n@end\n\n```", "```swift\n        CCTMXTiledMap *tileMap = [CCTMXTiledMap tiledMapWithTMXFile:@\"tilemap.tmx\"];\n        [gameNode addChild:tileMap z:0];\n\n        ```", "```swift\n        CCTMXLayer *collidableLayer = [tileMap layerNamed:@\"Collidable\"];\n\n        ```", "```swift\n        for( CCTMXLayer* child in [tileMap children] ) {\n        //Do Something\n        }\n\n        ```", "```swift\n        float x = 0; float y = 0;\n        CCSprite *tileSprite = [collidableLayer tileAt:ccp(x,y)];\n\n        ```", "```swift\n    for(float x=0; x<mw; x+=1){\n    for(float y=0; y<mh; y+=1){\n    if([collidableLayer tileAt:ccp(x,y)]){\n    [self addBoxAtPoint:ccp(x*tw, mh*th - y*th) size:ccp(tw/2,th/2)];\n    }\n    }\n    }\n\n    ```", "```swift\n    CCTMXObjectGroup *objects = [tileMap objectGroupNamed:@\"Objects\"];\n\n    ```", "```swift\n    NSMutableDictionary *sp = [objects objectNamed:@\"SpawnPoint\"];\n    int x = [[sp valueForKey:@\"x\"] intValue];\n    int y = [[sp valueForKey:@\"y\"] intValue];\n    spawnPoint = [Vector3D x:x y:y z:0];\n\n    ```", "```swift\n#import \"ActualPath.h\"\n#import \"CJSONDeserializer.h\"\n//Interface\n@interface Ch8_JSONWorldBuilder : GameArea2D\n{\nNSDictionary *mapData;\nCGPoint canvasSize;\nNSMutableArray *lineVerticesA;\nNSMutableArray *lineVerticesB;\nNSMutableArray *points;\n}\n@end\n//Implementation\n@implementation Ch8_JSONWorldBuilder\n-(CCLayer*) runRecipe {\n//Load our map file\n[self loadMap:@\"world.json\"];\nreturn self;\n}\n/* Called after the map has been loaded into a container but before assets have been loaded */\n-(void) finishInit {\n//Superclass initialization and message\n[super runRecipe];\n/* CODE OMITTED */\n//Init line/point containers\nlineVerticesA = [[NSMutableArray alloc] init];\nlineVerticesB = [[NSMutableArray alloc] init];\npoints = [[NSMutableArray alloc] init];\n}\n/* Our load map method */\n-(void) loadMap:(NSString*)mapStr {\n/* CODE OMITTED */\n//Add all sprite frames for listed plist files\nNSArray *plistFiles = [mapData objectForKey:@\"plistFiles\"];\nfor (id plistFile in plistFiles) {\n[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:plistFile];\n}\n//List of PNG files is also available\nNSArray *pngFiles = [mapData objectForKey:@\"pngFiles\"];\n//Pre process data\n[self preProcessMapData];\n//Process map nodes\nNSDictionary *mapNodes = [mapData objectForKey:@\"mapNodes\"];\nfor (id mapNodeKey in mapNodes) {\nNSDictionary *mapNode = [mapNodes objectForKey:mapNodeKey];\nNSString *nodeType = [mapNode objectForKey:@\"type\"];\n//Process node types\nif([nodeType isEqualToString:@\"sprite\"]){\n[self processSprite:mapNode];\n}else if([nodeType isEqualToString:@\"tiledSprite\"]){\n[self processTiledSprite:mapNode];\n}else if([nodeType isEqualToString:@\"line\"]){\n[self processLine:mapNode];\n}else if([nodeType isEqualToString:@\"point\"]){\n[self processPoint:mapNode];\n}\n}\n}\n-(void) preProcessMapData {\n//Set canvasSize and gameAreaSize from map file\ncanvasSize = ccp( [[mapData objectForKey:@\"canvasWidth\"] floatValue], [[mapData objectForKey:@\"canvasHeight\"] floatValue] );\ngameAreaSize = ccp( canvasSize.x/PTM_RATIO, canvasSize.y/PTM_RATIO );\n//Finish map initialization\n[self finishInit];\n}\n/* Process a sprite node. This represents a single sprite onscreen */\n-(void) processSprite:(NSDictionary*)mapNode {\n//Get node information\nNSString *texture = [mapNode objectForKey:@\"selectedSpriteY\"];\nfloat originX = [[mapNode objectForKey:@\"originX\"] floatValue];\n/* CODE OMITTED */\n//Get metadata\nNSDictionary *metaPairs = [mapNode objectForKey:@\"meta\"];\nfor (id metaKey in metaPairs) {\nNSString* metaValue = [metaPairs objectForKey:metaKey];\n//Check for key \"tag\"\nif([metaKey isEqualToString:@\"tag\"]){\ntag = ((int)[metaValue dataUsingEncoding:NSUTF8StringEncoding]);\n}\n}\n/* CODE OMITTED */\n//Finally, add the sprite\n[gameNode addChild:sprite z:zIndex-24995 tag:tag];\n}\n/* Process a tiled sprite. */\n-(void) processTiledSprite:(NSDictionary*)mapNode {\n//Get node information\nNSString *texture = [mapNode objectForKey:@\"selectedSpriteY\"];\nNSMutableDictionary *frames = [[[NSMutableDictionary alloc] init] autorelease];\nfloat originX = [[mapNode objectForKey:@\"originX\"] floatValue];\n/* CODE OMITTED */\n//Get metadata\nNSDictionary *metaPairs = [mapNode objectForKey:@\"meta\"];\nfor (id metaKey in metaPairs) {\nNSString* metaValue = [metaPairs objectForKey:metaKey];\n//Check for key \"tag\" or key \"frame\" (for animation)\nif([metaKey isEqualToString:@\"tag\"]){\ntag = ((int)[metaValue dataUsingEncoding:NSUTF8StringEncoding]);\n}else if ([metaKey rangeOfString:@\"frame\"].location != NSNotFound){\n[frames setObject:metaValue forKey:metaKey];\n}\n}\n//Get any masks to be applied to this tiled sprite\nNSArray *masks = [mapNode objectForKey:@\"masks\"];\n//OpenGL texture parameters\nccTexParams params = {GL_NEAREST,GL_NEAREST_MIPMAP_NEAREST,GL_REPEAT,GL_REPEAT};\n//If a mask exists, apply it\nif([masks count] > 0){\n/* CODE OMITTED */\n//Create TexturedPolygon object\nTexturedPolygon *tp = [TexturedPolygon createWithFile:texture withVertices:vertices withTriangles:triangles];\n[tp.texture setTexParameters:&params];\n//Set position\nfloat x = originX - (canvasSize.x/2);\nfloat y = canvasSize.y - originY - (canvasSize.y/2);\ntp.position = ccp( x, y-height );\n/* CODE OMITTED */\n//Finally, add the node\n[gameNode addChild:tp z:zIndex-24995];\n}else if([frames count] > 0){\n/* If we have a non-masked tiled animated sprite */\n/* CODE OMITTED */\n}else{\n//Use a regular Sprite\nCCSprite *sprite = [CCSprite spriteWithFile:texture rect:CGRectMake(0,0,width,height)];\n[sprite.texture setTexParameters:&params];\n//Set position\nfloat x = originX - (canvasSize.x/2);\nfloat y = canvasSize.y - originY - (canvasSize.y/2);\nsprite.position = ccp( x+width/2, y-height/2 );\n//Add the node\n[gameNode addChild:sprite z:zIndex-24999];\n}\n}\n/* Process a line */\n-(void) processLine:(NSDictionary*)mapNode{\n//Get line information\nNSArray *drawnLines = [mapNode objectForKey:@\"drawnLines\"];\n/* CODE OMITTED */\n//Add information to our line containers\n[lineVerticesA addObject:[NSValue valueWithCGPoint:ccp(fromX, canvasSize.y-fromY)]];\n[lineVerticesB addObject:[NSValue valueWithCGPoint:ccp(toX, canvasSize.y-toY)]];\n}\n/* Process a point */\n-(void) processPoint:(NSDictionary*)mapNode{\n//Get point information\nfloat originX = [[mapNode objectForKey:@\"originX\"] floatValue];\nfloat originY = [[mapNode objectForKey:@\"originY\"] floatValue];\noriginY = canvasSize.y - originY;\n//If metadata is appropriate, add point to container\n/* CODE OMITTED */\n}\n-(void) cleanRecipe {\n[lineVerticesA release];\n[lineVerticesB release];\n[points release];\n[super cleanRecipe];\n}\n@end\n\n```", "```swift\n    -(void) processSprite:(NSDictionary*)mapNode;\n    -(void) processTiledSprite:(NSDictionary*)mapNode;\n    -(void) processLine:(NSDictionary*)mapNode;\n    -(void) processPoint:(NSDictionary*)mapNode;\n\n    ```", "```swift\n#import \"CCBReader.h\"\n//Implementation\n@implementation Ch8_CocosBuilder\n-(CCLayer*) runRecipe {\n//Add button to push CocosBuilder scene\n[CCMenuItemFont setFontSize:32];\nCCMenuItemFont *pushItem = [CCMenuItemFont itemFromString:@\"Push CocosBuilder Scene\" target:self selector:@selector(pushScene)];\nCCMenu *pushMenu = [CCMenu menuWithItems:pushItem, nil];\npushMenu.position = ccp(240,160);\n[self addChild:pushMenu];\nreturn self;\n}\n/* Push scene callback */\n-(void) pushScene {\nCCScene* scene = [CCBReader sceneWithNodeGraphFromFile:@\"scene.ccb\" owner:self];\n[[CCDirector sharedDirector] pushScene:scene];\n}\n/* Callback called from CocosBuilder scene */\n-(void) back {\n[[CCDirector sharedDirector] popScene];\n}\n@end\n\n```", "```swift\n    CCScene* scene = [CCBReader sceneWithNodeGraphFromFile:@\"scene.ccb\" owner:self];\n    [[CCDirector sharedDirector] pushScene:scene];\n\n    ```", "```swift\n#include \"HelloWorldScene.h\"\n#include \"SimpleAudioEngine.h\"\nusing namespace cocos2d;\nusing namespace CocosDenshion;\nCCScene* HelloWorld::scene()\n{\n//'scene' is an autorelease object\nCCScene *scene = CCScene::node();\n//'layer' is an autorelease object\nHelloWorld *layer = HelloWorld::node();\n//Add layer as a child to scene\nscene->addChild(layer);\nreturn scene;\n}\n// on \"init\" you need to initialize your instance\nbool HelloWorld::init()\n{\n//Super initialization\nif ( !CCLayer::init() )\n{\nreturn false;\n}\n//Add a menu item with \"X\" image, which is clicked to quit the program. You may modify it.\n//Add a \"close\" icon to exit the progress. it's an autorelease object\nCCMenuItemImage *pCloseItem = CCMenuItemImage::itemFromNormalImage(\"CloseNormal.png\", \"CloseSelected.png\", this, menu_selector(HelloWorld::menuCloseCallback) );\npCloseItem->setPosition( ccp(CCDirector::sharedDirector()->getWinSize().width - 20, 20) );\n//Create menu, it's an autorelease object\nCCMenu* pMenu = CCMenu::menuWithItems(pCloseItem, NULL);\npMenu->setPosition( CCPointZero );\nthis->addChild(pMenu, 1);\n//Add a label shows \"Hello World\"\n// create and initialize a label\nCCLabelTTF* pLabel = CCLabelTTF::labelWithString(\"Hello World\", \"Thonburi\", 34);\n//Ask director the window size\nCCSize size = CCDirector::sharedDirector()->getWinSize();\n//Position the label on the center of the screen\npLabel->setPosition( ccp(size.width / 2, size.height - 20) );\n//Add the label as a child to this layer\nthis->addChild(pLabel, 1);\n//Add \"HelloWorld\" splash screen\"\nCCSprite* pSprite = CCSprite::spriteWithFile(\"HelloWorld.png\");\n//Position the sprite on the center of the screen\npSprite->setPosition( ccp(size.width/2, size.height/2) );\n//Add the sprite as a child to this layer\nthis->addChild(pSprite, 0);\nreturn true;\n}\nvoid HelloWorld::menuCloseCallback(CCObject* pSender)\n{\nCCDirector::sharedDirector()->end();\n#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)\nexit(0);\n#endif\n}\n\n```", "```swift\n    sudo sh install-templates-xcode.sh\n\n    ```", "```swift\n#import \"Ch8_Cocos3dWorld.h\"\n#import \"CC3PODResourceNode.h\"\n#import \"CC3ActionInterval.h\"\n#import \"CC3MeshNode.h\"\n#import \"CC3Camera.h\"\n#import \"CC3Light.h\"\n@implementation Ch8_Cocos3dWorld\n-(void) dealloc {\n[super dealloc];\n}\n-(void) initializeWorld {\n//Create the camera, place it back a bit, and add it to the world\nCC3Camera* cam = [CC3Camera nodeWithName: @\"Camera\"];\ncam.location = cc3v( 0.0, 0.0, 6.0 );\n[self addChild: cam];\n//Create a light, place it back and to the left at a specific position (not just directional lighting), and add it to the world\nCC3Light* lamp = [CC3Light nodeWithName: @\"Lamp\"];\nlamp.location = cc3v( -2.0, 0.0, 0.0 );\nlamp.isDirectionalOnly = NO;\n[cam addChild: lamp];\n//This is the simplest way to load a POD resource file and add the nodes to the CC3World, if no customized resource subclass is needed.\n[self addContentFromPODResourceFile: @\"hello-world.pod\"];\n//Create OpenGL ES buffers for the vertex arrays to keep things fast and efficient, and to save memory, release the vertex data in main memory because it is now redundant.\n[self createGLBuffers];\n[self releaseRedundantData];\n//That's it! The model world is now constructed and is good to go.\n//But to add some dynamism, we'll animate the 'hello, world' message using a couple of cocos2d actions...\n//Fetch the 'hello, world' 3D text object that was loaded from the POD file and start it rotating\nCC3MeshNode* helloTxt = (CC3MeshNode*)[self getNodeNamed: @\"Hello\"];\nCCActionInterval* partialRot = [CC3RotateBy actionWithDuration: 1.0 rotateBy: cc3v(0.0, 30.0, 0.0)];\n[helloTxt runAction: [CCRepeatForever actionWithAction: partialRot]];\n//To make things a bit more appealing, set up a repeating up/down cycle to change the color of the text from the original red to blue, and back again.\nGLfloat tintTime = 8.0f;\nccColor3B startColor = helloTxt.color;\nccColor3B endColor = { 50, 0, 200 };\nCCActionInterval* tintDown = [CCTintTo actionWithDuration: tintTime red: endColor.r green: endColor.g blue: endColor.b];\nCCActionInterval* tintUp = [CCTintTo actionWithDuration: tintTime red: startColor.r green: startColor.g blue: startColor.b];\nCCActionInterval* tintCycle = [CCSequence actionOne: tintDown two: tintUp];\n[helloTxt runAction: [CCRepeatForever actionWithAction: tintCycle]];\n}\n/* This template method is invoked periodically whenever the 3D nodes are to be updated. */\n-(void) updateBeforeTransform: (CC3NodeUpdatingVisitor*) visitor {}\n/* This template method is invoked periodically whenever the 3D nodes are to be updated. */\n-(void) updateAfterTransform: (CC3NodeUpdatingVisitor*) visitor {}\n@end\n\n```", "```swift\n    sudo sh install-cocos3d.sh\n\n    ```"]