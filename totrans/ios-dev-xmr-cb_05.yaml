- en: Chapter 5. Displaying Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data in a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching through the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data in a grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed some of the available options for data
    management in an iOS app. In this chapter, we will discuss the various ways of
    displaying data to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will focus on how to use the following controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UIPickerView**: This control provides functionality that is similar to a
    list box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UITableView**: This is a very customizable view for displaying data. It is
    one of the most used controls in iOS apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UISearchBar** **and** **UISearchDisplayController**: This is a combination
    of controls that provides an easy-to-use interface for searching through data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UIWebView**: This brings web-browser functionality to apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UICollectionView**: This displays data in a customizable grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, we will learn how to provide indexing in tables to make large volumes
    of data easily accessible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Providing lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UIPickerView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIPickerView` class provides us with a control whose functionality is similar
    to that of a list box. It is specifically designed for human fingers that touch
    the screen. Its main difference from a common list box is that each column can
    have its own number of rows. To get started, create a new iPhone **Single View
    Application** project and name it `PickerViewApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PickerViewAppViewController.xib` file in Interface Builder. Add `UILabel`
    and `UIPickerView` on the main view and save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, create a nested class in the `PickerViewAppViewController`
    class that inherits from UIPickerViewModel using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following constructor and fields in the nested class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will now need to override four methods from the `UIPickerViewModel` class,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, set the model object we created to the picker view''s `Model` property
    inside the controller''s `ViewDidLoad` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Drag through the items in the picker
    view and watch the label's content change according to your selection. The following
    screenshot shows how it should look:![How to do it...](img/8924OT_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIPickerViewModel` class does not exist in Objective-C. Xamarin.iOS provides
    this class as a wrapper around the `UIPickerViewDataSource` and `UIPickerViewDelegate`
    native protocols, and contains both of these classes' methods for us to override.
    This is extremely helpful since we only have to implement and assign one class
    instead of two for our picker view. Both of these protocols are available as `C#`
    classes in Xamarin.iOS at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the constructor, we initialize the lists that will hold the data to
    be displayed in the picker. The following four methods we need to override are
    responsible for displaying the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int GetComponentCount (UIPickerView picker)`: This returns the number of columns
    we want the picker view to display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int GetRowsInComponent (UIPickerView picker, int component)`: This returns
    the number of rows each component will display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string GetTitle (UIPickerView picker, int row, int component)`: This is the
    text of each row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Selected (UIPickerView picker, int row, int component)`: This is the
    action to be taken when the user selects an item from any component/row combination
    in the picker view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the lists we have assigned in the constructor to display the data. For
    example, the `GetTitle` method is implemented as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can programmatically select the initial selection of the picker view by calling
    the `Select (int, int, bool)` method. The first two parameters reflect the row
    and component index, respectively, while the `bool` parameter toggles the selection
    animation. The only thing to remember with this method is to call it after we
    have assigned the picker's `Model` property. An exception will occur otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: More UIPickerView customization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from the options presented earlier, we also have the option of setting
    the width of each component. To do this, we override the `GetComponentWidth (UIPickerView,
    int)` method, which returns a float that represents the width for each component.
  prefs: []
  type: TYPE_NORMAL
- en: We can also set custom views as items in the picker view, instead of plain text.
    This can be done by overriding the `GetView(UIPickerView, int, int, UIView)` method
    and returning the view we want to be displayed on each position in the `UIPickerView`
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a control named `UIDatePicker` that is similar to `UIPickerView` and
    is specifically customized to display and select the date and time values. Note
    that although its user interface is the same as the picker view, it does not inherit
    the `UIPickerView` class. It just uses an instance of it as a subview.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data in a table* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data in a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UITableView` class to display
    data. This class, along with the `UITableViewCell` object, provides an interface
    for displaying data on the screen in multiple rows, but on a single column.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, create a new project in Xamarin Studio and name it `TableViewApp`.
    In this recipe, we will not use the XIB files. We will create our user interface
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class to the project and name it `TableController`. Derive the class
    from `UITableViewController` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following nested class inside the `TableController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the controller''s `ViewDidLoad` method and add the following line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `FinishedLaunching` method to display the table
    controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. The result should be similar
    to the one shown in the following screenshot:![How to do it...](img/8924OT_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nested class we created acts as the data source of `UITableView`. The class
    created in the following code inherits from the Xamarin.iOS `UITableViewSource`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like `UIPickerView`, in the example discussed in the previous recipe, the `UITableViewSource`
    class does not exist in Objective-C. It is merely a wrapper object offered by
    Xamarin.iOS around the `UITableViewDelegate` and `UITableViewSource` protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its constructor, we initialize two variables (as shown in the following
    code): `string`, which will act as the cells'' identifier, and a generic `Dictionary`
    variable for our data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the `TableSource` class work, we need to override two methods. The
    first method, named `RowsInSection`, returns the number of rows that the table
    shall display. In the following code, we return the number of items in our data
    source object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second method, `GetCell`, returns the `UITableViewCell` object that will
    be displayed in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UITableViewCell` class represents a single row and manages its content
    in `UITableView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more efficient, the table view creates its cell objects when they are
    needed. For this reason, we need to get `UITableViewCell` (that was used earlier)
    from the table through its `DequeueReusableCell` method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If no cells exist for the particular cell identifier, the method returns `null`.
    Hence, we create the cell that will be used, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we assign the text that the particular cell will display and return using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `UITableViewCell` class contains two labels that can be used
    to display text. The main label can be accessed through the `TextLabel` property
    and the secondary label through the `DetailTextLabel` property. Note that when
    using a cell with the `Default` style, the `DetailTextLabel` property cannot be
    used and will return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To provide functionality when the user selects a particular row, we need to
    override the `RowSelected` property in the class that acts as a `UITableViewSource`.
    By default, when the user taps on a row, the cell is highlighted with a light
    gray color to indicate the selection. To deselect the row, we use the `UITableView.DeselectRow(NSIndexPath,
    bool)` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The UITableView styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`UITableView` can be created with two different styles. The default style is
    `Plain`. The other style that can be used is the `Grouped` style. This style is
    being used in many iOS native apps such as the *Settings* app.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, `UITableView` supports the display of data divided into different sections.
    We must explicitly return the number of rows each section will have in the `RowsInSection`
    override if we want to use different sections.
  prefs: []
  type: TYPE_NORMAL
- en: The UITableViewCell styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A table cell can have four different cell styles, which are represented by
    the `UITableViewCellStyle` enumeration. Its values are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default**: This is the default cell style. Only the `TextLabel` property
    can be used to display text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtitle**: This is a style that provides `DetailTextLabel` as a subtitle
    to `TextLabel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value1**: This is a style that displays both `TextLabel` and `DetailTextLabel`
    text in the same size, with a different color, and aligned to the sides of the
    cell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value2**: This is a style that displays the `TextLabel` text smaller than
    the `DetailTextLabel` text. This style is used in the native *Contacts* app, in
    the contact details screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Providing lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing rows* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Navigating through different view controllers* recipe in [Chapter 3](ch03.html
    "Chapter 3. User Interface – View Controllers"), *User Interface – View Controllers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a table view that uses our own custom subclass
    of `UITableViewCell` to display data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Xamarin Studio in the same manner in which the project
    in the earlier recipe was created. Name it `CustomRowsApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class to the project and name it `CustomCell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new **Empty iPhone Interface Definition** to the project and name it `CustomCell`.
    Don't worry about the name conflicting with the class we created earlier, as this
    is an XIB file. Open the file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UITableViewCell` on the canvas. The following screenshot shows a selected
    `UITableViewCell` in the object browser in Xcode:![How to do it...](img/8924OT_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Class** field of the table cell to `CustomCell` in the **Identity**
    inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Identifier** field of the cell to `CustomCell` in the **Attributes**
    inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIImageView` and a `UILabel` on the cell and connect them to their outlets.
    Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `TableController.cs` file we created in the previous recipe, *Displaying
    data in a table*, to the project. Change its namespace from `TableViewApp` to
    `CustomRowsApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `TableSource` class'' `GetCell` method to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method of `TableController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, make sure that `TableController` is presented in the `FinishedLaunching`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like creating a custom view, we are able to create our own custom cells
    to present data with a `UITableView`. The main difference lies in the fact that
    the table view reuses the instances of its cells so that it is more efficient
    when we want to display multiple rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our table view "aware" of our custom cell, we call the `RegisterNibForCellReuse`
    method using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, when we call the `DequeueReusable` cell method in `GetCell`, the
    system will automatically create a cell instance for us or get one that was created
    earlier. Hence, there is no need for us to check if the cell is null or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you notice something common in the two method calls discussed earlier?
    They both need an identifier string for the cell. The `CustomCell.CELLID` constant
    has the same value we entered in the **Identifier** field of the cell in Xcode:
    `CustomCell`. In this case, it is the same as the class name of our cell, as it
    keeps things tidy if we were to have different custom cells to present. However,
    basically, the identifier for a cell can be whatever we want it to be.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create as many custom cells as we need. As discussed earlier, we need
    to make sure that we set a unique identifier for each of the cell classes we are
    going to use. Also, if the custom cells we create have different heights, we need
    to make sure we override the `GetHeightForRow` method in our `UITableViewSource`
    implementation using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For greater efficiency, it's good to have the heights of the rows calculated
    beforehand and not calculate them inside `GetHeightForRow`.
  prefs: []
  type: TYPE_NORMAL
- en: Useful properties of the UITableViewCell class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from adding text in the default labels, the `UITableViewCell` contains
    some other properties whose values we can set to add more default items in a cell.
    These properties are are follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageView`: This accepts a `UIImageView` parameter. We can use it to display
    an image in a cell, on its left-hand side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AccessoryView`: This accepts any instance of `UIView`. Its position defaults
    to the right of the cell, in the place of the cell''s accessory, which is located
    on the right-hand side of the cell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Accessory`: This accepts values of the `UITableViewCellAccessory` type. It
    provides predefined views for the cell''s accessory, such as `DetailDisclosureButton`
    or `Checkmark`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UINib class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `UINib` class is responsible for loading NIB files at runtime. We instantiate
    a `UINib` instance through its `FromName` static method, passing the name of the
    NIB file we want to load without its extension, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Adding content programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add views to a table cell programmatically. However, we should not add
    them to the cell directly, but to its `ContentView`, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data in a table* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Editing a table* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a custom view* recipe in [Chapter 2](ch02.html "Chapter 2. User
    Interface – Views"), *User Interface – Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to insert and delete rows at runtime from
    a `UITableView`, providing the user with the appropriate user interface interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `CustomRowsApp` project we created in the previous recipe, *Customizing
    rows*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `tableData` field from the `TableSource` class and replace it with
    the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the list in the constructor using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TableSource` class, override the `CommitEditingStyle` method and implement
    it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TableController` class, add a `UIBarButtonItem` using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the plus button to add new rows
    to the table and swipe on an item from right to left to delete items. The following
    screenshot shows the table after having added one item and swiped on another one:![How
    to do it...](img/8924OT_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To swipe an item on the simulator, click-and-drag the cursor sideways.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CommitEditingStyleForRow` method is called whenever an editing action
    is about to take place. In our implementation, we check if the editing action
    is about deleting an item, and if it is, we remove the row. To do this, we first
    remove the corresponding item from our data source and then call the `DeleteRows`
    method of the table view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when we want to add a row to the table, we first add the item we
    want to our data source and then call the `InsertRows` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UITableView` also supports an editing mode. We can activate/deactivate
    the editing mode of a table view by calling the `SetEditing` method, passing `true`
    or `false`, respectively, an example of which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter determines whether we want the table view to transition
    to/from the editing mode with an animation.
  prefs: []
  type: TYPE_NORMAL
- en: When a table view is in the editing mode, each row has a red minus sign on its
    left-hand side. If the user taps the sign, the **Delete** button will appear on
    the right-hand side of the row, just as it appears when they swipe the row.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling editing modes for individual rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also enable a specific editing mode or even disable it for individual
    rows. To do this, we need to override the `EditingStyleForRow` method in our `UITableViewSource`
    subclass, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data in a table* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to provide an index in a table, allowing the
    user to quickly browse through the rows of `UITableView`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Xamarin Studio and name it `TableIndexApp`. Add a `UITableViewController`,
    as shown in the previous tasks in this chapter, and implement the `TableSource`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table source class, override and implement the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table source created in this recipe contains many different sections. For
    simplicity, each section contains one row. The `NumberOfSections` method returns
    the total number of sections that the table will display.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a title for each section, we must override the `TitleForHeader` method,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation returns the first letter of each string in the data source.
    To provide the index, we override the `SectionIndexTitles` method, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, it returns the first letter of each item in the data source. The result
    of this project will be similar to one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the user touches the screen anywhere on the index, the table view will
    scroll to that specific section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexing should be applied to tables with a **Plain** style. Applying an index
    on tables with a **Grouped** style set is not advisable, because the index will
    not be easily distinguished.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of a native iOS app with an index on a table can be found in
    the native *Contacts* app.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data in a table* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching through the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to provide search functionality for the content
    in a table view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Xamarin Studio and name it `SearchTableApp`. Add `UIViewController`
    and name it `SearchController`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SearchController.xib` file in Interface Builder. Add **Search Bar
    and Search Display Controller** in `UITableView`. The following screenshot shows
    the `UISearchDisplayController` object selected in the object browser:![How to
    do it...](img/8924OT_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that after this action, some outlets are created and connected automatically.
    We need most of them, so we leave them as they are.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add `UITableView` and connect it to an outlet. Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in Xamarin Studio, create a `UITableViewSource` subclass that will act
    as the data source for the table view. Refer to the *Displaying data in a table*
    recipe in this chapter for information on how to do this. This time, make sure
    that the `List<string>` variable, which will hold the data, is a member of the
    `SearchController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add another `List<string>` variable in the `SearchController` class using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a subclass that will act as a delegate object for the search display
    controller, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `ViewDidLoad` method and assign the source and
    delegate objects in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap the search bar and start typing
    into it. It will automatically search the table and show the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can find the complete code in the `SearchTableApp` project. The result
    will be the common iOS search bar above the table, similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/8924OT_05_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UISearchDisplayController` class provides a convenient way of searching
    through data. It contains `UISearchBar` which accepts input from the user, and
    `UITableView` which is used to display the results. After we add a search controller
    in a view controller, we can access it through that controller''s `SearchDisplayController`
    property. To trigger the results table, we must implement `UISearchDisplayDelegate`
    and override its `ShouldReloadForSearchString` (which returns a Boolean value)
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ShouldReloadForSearchString` method override, we search our data
    source, saving the filtered results in a new data source according to its `forSearchString`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We then sort the results alphabetically and return `true` so that the search
    controller''s table will reload its data, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The search controller''s table view also needs a source object. In this example,
    we set it to the same object we created for our table, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are using instances of the same object, we need to modify some things
    in it to display data according to which table calls it. So, for example, the
    `RowsInSection` method looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we return the number of rows according to which table calls the
    method. Similarly, we need to set each cell''s text label inside the `GetCell`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user taps on the search bar, the keyboard appears, making the search
    controller active. To deactivate it, we can hook on the search bar''s `SearchButtonClicked`
    event. This event will get triggered when the user taps on the keyboard''s **Search**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `SetActive` method is what we can use to enable or disable the search controller.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data in a table* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Table indexing* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple web browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss displaying online content with the `UIWebView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** project in Xamarin Studio and name
    it `WebBrowserApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `WebBrowserAppViewController.xib` file in Interface Builder and add
    a `UIWebView` object on the main view. Create and connect an outlet for it with
    the name `webView`. Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the `ViewDidAppear` method in the `WebBrowserAppViewController` class,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Watch the website load on the screen!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIWebView` class is iOS SDK''s web browser control. To load web content,
    we just have to call its `LoadRequest` method, which accepts a parameter of the
    `NSUrlRequest` type. The `NSUrlRequest` object contains the URL we want it to
    load, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIWebView` class contains some very useful events, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoadStarted`: This is triggered when the control has started loading content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadFinished`: This is triggered when the content finished loading successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadError`: This is triggered when the loading of the content failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important feature of the `UIWebView` is the automatic scaling of content.
    It can be activated by setting its `ScalePageToFit` property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: UIWebView supported files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from web pages, the `UIWebView` control can be used to display local
    content with the following types of files:'
  prefs: []
  type: TYPE_NORMAL
- en: Excel (`.xls`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keynote (`.key.zip`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers (`.numbers.zip`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages (`.pages.zip`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDF (`.pdf`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerpoint (`.ppt`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word (`.doc`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich Text Format (`.rtf`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich Text Format Directory (`.rtfd.zip`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keynote (`.key`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers (`.numbers`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages (`.pages`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data in a grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss using the `UICollectionView` object to display
    data in a grid-like layout. The `UICollectionView` class was introduced in iOS
    6, and is a very useful control that was missed by iOS developers. Prior to `UICollectionView`,
    the only way to display data in a grid was to create a custom control, which was
    not a very easy task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in Xamarin Studio and name it `CollectionViewApp`. We will
    also need something to display, so add an image to the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CollectionViewAppViewController.xib` file in Interface Builder and
    add a `UICollectionView` on its main view. The following screenshot shows the
    object in the object browser:![How to do it...](img/8924OT_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, add the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following nested class in the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. The result should be similar to the
    one shown in the following screenshot:![How to do it...](img/8924OT_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UICollectionView` class is used in a manner that is similar to `UITableView`.
    The main difference is that instead of showing the data in a single column, it
    does so in a grid arrangement. The `UICollectionViewSource` class is overridden
    to provide the data source of the collection view, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like table views in `UITableViewSource`, we need to provide the number
    of items in the grid and the object for single items, in this case, `UICollectionViewCell`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that unlike `UITableViewCell`, the `UICollectionViewCell` class doesn''t
    offer much for us to use. So, we have to override it to create our own cell for
    the collection, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are using a custom cell, we have to let the collection view know about
    it through the `RegisterClassForCell` method, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from showing individual items with the `UICollectionViewCell` class, the
    `UICollectionView` supports the display of supplementary views of the `UICollectionReusableView`
    type. These views basically represent either the header or the footer of the sections
    in the collection view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide supplementary views, we need to create our own subclass using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to override the following method in the collection source (this
    method will return the supplementary view that we want):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `elementKind` parameter is the `NSString` representation of the `UICollectionElementKindSection`
    enumeration, which contains two values: `Footer` and `Header`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to call the `RegisterClassForSupplementaryView` method to
    register our custom class with the collection view, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: More information on UICollectionView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A good tutorial on `UICollectionView` can be found at Xamarin''s website: [http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/](http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data in a table* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing rows* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to customize the display of the collection
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will work on the `CollectionViewApp` project we created in
    the *Displaying data in a grid* recipe. Open the project in Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ViewDidLoad` method of the controller, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. The result should be similar to the
    one shown in the following screenshot:![How to do it...](img/8924OT_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The collection view's layout can be customized through the `UICollectionViewLayout`
    class. `UICollectionViewFlowLayout` is a subclass of this class and offers a simple
    layout that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting specific properties, we define how the cells will be arranged by
    the collection view. The following list describes the properties we are setting
    in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MinimumLineSpacing`: This is the smallest distance between rows in the grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinimumInteritemSpacing`: This is the smallest distance between individual
    items in the grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SectionInset`: This is the area around each section in the collection view
    that should be left blank'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemSize`: This is the size of each item in the collection view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows what each property corresponds to in the collection
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_05_11_diagram.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting the `ItemSize` parameter of the collection layout object will adjust
    the size of all the items in the collection view. We can set the size for every
    cell individually by providing the following method in the `CollectionSource`
    subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the preceding method to our own `CollectionSource` subclass would give
    the result shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/8924OT_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying data in a grid* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
