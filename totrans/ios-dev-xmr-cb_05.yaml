- en: Chapter 5. Displaying Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。显示数据
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Providing lists
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供列表
- en: Displaying data in a table
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以表格形式显示数据
- en: Customizing rows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义行
- en: Editing a table
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑表格
- en: Table indexing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格索引
- en: Searching through the data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索数据
- en: Creating a simple web browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的网页浏览器
- en: Displaying data in a grid
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以网格形式显示数据
- en: Customizing the grid
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义网格
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we discussed some of the available options for data
    management in an iOS app. In this chapter, we will discuss the various ways of
    displaying data to the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了在 iOS 应用中数据管理的可用选项。在本章中，我们将讨论向用户显示数据的各种方式。
- en: 'Specifically, we will focus on how to use the following controls:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将关注如何使用以下控件：
- en: '**UIPickerView**: This control provides functionality that is similar to a
    list box.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIPickerView**：此控件提供与列表框类似的功能。'
- en: '**UITableView**: This is a very customizable view for displaying data. It is
    one of the most used controls in iOS apps.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UITableView**：这是一个用于显示数据的非常可定制的视图。它是 iOS 应用中最常用的控件之一。'
- en: '**UISearchBar** **and** **UISearchDisplayController**: This is a combination
    of controls that provides an easy-to-use interface for searching through data.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UISearchBar** 和 **UISearchDisplayController**：这是一个提供易于使用界面进行数据搜索的控件组合。'
- en: '**UIWebView**: This brings web-browser functionality to apps.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIWebView**：这为应用带来了网页浏览器的功能。'
- en: '**UICollectionView**: This displays data in a customizable grid.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UICollectionView**：这以可定制的网格显示数据。'
- en: Furthermore, we will learn how to provide indexing in tables to make large volumes
    of data easily accessible to the user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将学习如何在表格中提供索引，以便用户可以轻松访问大量数据。
- en: Providing lists
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供列表
- en: In this recipe, we will learn how to use the `UIPickerView` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 `UIPickerView` 类。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UIPickerView` class provides us with a control whose functionality is similar
    to that of a list box. It is specifically designed for human fingers that touch
    the screen. Its main difference from a common list box is that each column can
    have its own number of rows. To get started, create a new iPhone **Single View
    Application** project and name it `PickerViewApp`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPickerView` 类为我们提供了一个与列表框功能类似的控件。它专门为触摸屏幕的人手设计。它与普通列表框的主要区别在于，每一列都可以有自己的行数。要开始，创建一个新的
    iPhone **单视图应用程序**项目，并将其命名为 `PickerViewApp`。'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `PickerViewAppViewController.xib` file in Interface Builder. Add `UILabel`
    and `UIPickerView` on the main view and save the document.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `PickerViewAppViewController.xib` 文件。在主视图中添加 `UILabel`
    和 `UIPickerView` 并保存文档。
- en: 'Back in Xamarin Studio, create a nested class in the `PickerViewAppViewController`
    class that inherits from UIPickerViewModel using the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 Xamarin Studio，在 `PickerViewAppViewController` 类中创建一个嵌套类，该类继承自 `UIPickerViewModel`，并使用以下代码：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following constructor and fields in the nested class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在嵌套类中添加以下构造函数和字段：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will now need to override four methods from the `UIPickerViewModel` class,
    as shown in the following code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在需要重写 `UIPickerViewModel` 类中的四个方法，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, set the model object we created to the picker view''s `Model` property
    inside the controller''s `ViewDidLoad` method, as shown in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在控制器中的 `ViewDidLoad` 方法内将我们创建的模型对象设置为选择视图的 `Model` 属性，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compile and run the app on the simulator. Drag through the items in the picker
    view and watch the label's content change according to your selection. The following
    screenshot shows how it should look:![How to do it...](img/8924OT_05_01.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。拖动选择视图中的项目，并观察标签内容根据您的选择而更改。以下截图显示了它应该看起来像什么：![如何做...](img/8924OT_05_01.jpg)
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIPickerViewModel` class does not exist in Objective-C. Xamarin.iOS provides
    this class as a wrapper around the `UIPickerViewDataSource` and `UIPickerViewDelegate`
    native protocols, and contains both of these classes' methods for us to override.
    This is extremely helpful since we only have to implement and assign one class
    instead of two for our picker view. Both of these protocols are available as `C#`
    classes in Xamarin.iOS at the same time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPickerViewModel` 类在 Objective-C 中不存在。Xamarin.iOS 提供了这个类，作为 `UIPickerViewDataSource`
    和 `UIPickerViewDelegate` 原生协议的包装器，并包含这两个类的方法以供我们重写。这非常有帮助，因为我们只需要实现和分配一个类而不是两个类来为我们的选择视图。这两个协议在
    Xamarin.iOS 中同时作为 `C#` 类可用。'
- en: 'Inside the constructor, we initialize the lists that will hold the data to
    be displayed in the picker. The following four methods we need to override are
    responsible for displaying the data:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数内部，我们初始化将用于在选择器中显示数据的列表。以下四个需要重写的方法负责显示数据：
- en: '`int GetComponentCount (UIPickerView picker)`: This returns the number of columns
    we want the picker view to display'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int GetComponentCount (UIPickerView picker)`: 这个方法返回我们希望选择器视图显示的列数'
- en: '`int GetRowsInComponent (UIPickerView picker, int component)`: This returns
    the number of rows each component will display'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int GetRowsInComponent (UIPickerView picker, int component)`: 这个方法返回每个组件将显示的行数'
- en: '`string GetTitle (UIPickerView picker, int row, int component)`: This is the
    text of each row'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string GetTitle (UIPickerView picker, int row, int component)`: 这是每行的文本'
- en: '`void Selected (UIPickerView picker, int row, int component)`: This is the
    action to be taken when the user selects an item from any component/row combination
    in the picker view'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Selected (UIPickerView picker, int row, int component)`: 当用户在选择器视图的任何组件/行组合中选择一个项时，将执行此操作'
- en: 'We use the lists we have assigned in the constructor to display the data. For
    example, the `GetTitle` method is implemented as shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在构造函数中分配的列表来显示数据。例如，`GetTitle` 方法实现如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can programmatically select the initial selection of the picker view by calling
    the `Select (int, int, bool)` method. The first two parameters reflect the row
    and component index, respectively, while the `bool` parameter toggles the selection
    animation. The only thing to remember with this method is to call it after we
    have assigned the picker's `Model` property. An exception will occur otherwise.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `Select (int, int, bool)` 方法来程序化选择选择器的初始选择。前两个参数分别反映行和组件索引，而 `bool`
    参数切换选择动画。使用此方法时需要注意的唯一一点是，在分配选择器的 `Model` 属性之后调用它。否则将发生异常。
- en: More UIPickerView customization
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多 UIPickerView 定制
- en: Apart from the options presented earlier, we also have the option of setting
    the width of each component. To do this, we override the `GetComponentWidth (UIPickerView,
    int)` method, which returns a float that represents the width for each component.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提供的选项外，我们还可以设置每个组件的宽度。为此，我们重写 `GetComponentWidth (UIPickerView, int)` 方法，该方法返回一个表示每个组件宽度的浮点数。
- en: We can also set custom views as items in the picker view, instead of plain text.
    This can be done by overriding the `GetView(UIPickerView, int, int, UIView)` method
    and returning the view we want to be displayed on each position in the `UIPickerView`
    control.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将自定义视图作为选择器视图中的项，而不是纯文本。这可以通过重写 `GetView(UIPickerView, int, int, UIView)`
    方法并返回我们希望在 `UIPickerView` 控制器的每个位置显示的视图来实现。
- en: Date and time selection
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和时间选择
- en: There is a control named `UIDatePicker` that is similar to `UIPickerView` and
    is specifically customized to display and select the date and time values. Note
    that although its user interface is the same as the picker view, it does not inherit
    the `UIPickerView` class. It just uses an instance of it as a subview.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `UIDatePicker` 的控件，它与 `UIPickerView` 类似，专门定制用于显示和选择日期和时间值。请注意，尽管其用户界面与选择器视图相同，但它并不继承
    `UIPickerView` 类。它只是使用它的一个实例作为子视图。
- en: See also
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying data in a table* recipe
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据* 食谱'
- en: Displaying data in a table
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表格中显示数据
- en: In this recipe, we will learn how to use the `UITableView` class to display
    data. This class, along with the `UITableViewCell` object, provides an interface
    for displaying data on the screen in multiple rows, but on a single column.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 `UITableView` 类来显示数据。这个类，连同 `UITableViewCell` 对象一起，提供了一个在屏幕上以多行但单列形式显示数据的接口。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, create a new project in Xamarin Studio and name it `TableViewApp`.
    In this recipe, we will not use the XIB files. We will create our user interface
    in code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，在 Xamarin Studio 中创建一个新的项目，并将其命名为 `TableViewApp`。在本食谱中，我们不会使用 XIB 文件。我们将通过代码创建用户界面。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add a new class to the project and name it `TableController`. Derive the class
    from `UITableViewController` using the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的类，并将其命名为 `TableController`。使用以下代码从 `UITableViewController` 派生该类：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the following nested class inside the `TableController` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TableController` 类内部创建以下嵌套类：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the controller''s `ViewDidLoad` method and add the following line
    of code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写控制器的方法 `ViewDidLoad` 并添加以下代码行：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code in the `FinishedLaunching` method to display the table
    controller:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FinishedLaunching`方法中添加以下代码以显示表格控制器：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compile and run the application on the simulator. The result should be similar
    to the one shown in the following screenshot:![How to do it...](img/8924OT_05_02.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。结果应该类似于以下截图所示：![如何操作...](img/8924OT_05_02.jpg)
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The nested class we created acts as the data source of `UITableView`. The class
    created in the following code inherits from the Xamarin.iOS `UITableViewSource`
    class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的嵌套类作为`UITableView`的数据源。在以下代码中创建的类继承自Xamarin.iOS的`UITableViewSource`类：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like `UIPickerView`, in the example discussed in the previous recipe, the `UITableViewSource`
    class does not exist in Objective-C. It is merely a wrapper object offered by
    Xamarin.iOS around the `UITableViewDelegate` and `UITableViewSource` protocols.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与`UIPickerView`一样，在前面讨论的示例中，`UITableViewSource`类在Objective-C中不存在。它仅仅是Xamarin.iOS围绕`UITableViewDelegate`和`UITableViewSource`协议提供的包装对象。
- en: 'In its constructor, we initialize two variables (as shown in the following
    code): `string`, which will act as the cells'' identifier, and a generic `Dictionary`
    variable for our data source:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在其构造函数中，我们初始化了两个变量（如下面的代码所示）：`string`，它将作为单元格的标识符，以及一个通用的`Dictionary`变量作为我们的数据源：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To make the `TableSource` class work, we need to override two methods. The
    first method, named `RowsInSection`, returns the number of rows that the table
    shall display. In the following code, we return the number of items in our data
    source object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`TableSource`类工作，我们需要重写两个方法。第一个方法名为`RowsInSection`，它返回表格应显示的行数。在以下代码中，我们返回数据源对象中的项目数：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second method, `GetCell`, returns the `UITableViewCell` object that will
    be displayed in the table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法`GetCell`返回将在表中显示的`UITableViewCell`对象。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `UITableViewCell` class represents a single row and manages its content
    in `UITableView`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableViewCell`类代表一行，并在`UITableView`中管理其内容。'
- en: 'To be more efficient, the table view creates its cell objects when they are
    needed. For this reason, we need to get `UITableViewCell` (that was used earlier)
    from the table through its `DequeueReusableCell` method, as shown in the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效，表格视图在需要时创建其单元格对象。因此，我们需要通过其`DequeueReusableCell`方法从表格中获取`UITableViewCell`（之前使用过），如下面的代码所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If no cells exist for the particular cell identifier, the method returns `null`.
    Hence, we create the cell that will be used, using the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为特定的单元格标识符存在单元格，该方法将返回`null`。因此，我们使用以下代码创建将要使用的单元格：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we assign the text that the particular cell will display and return using
    the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分配特定单元格将显示的文本并使用以下代码返回：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By default, the `UITableViewCell` class contains two labels that can be used
    to display text. The main label can be accessed through the `TextLabel` property
    and the secondary label through the `DetailTextLabel` property. Note that when
    using a cell with the `Default` style, the `DetailTextLabel` property cannot be
    used and will return `null`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`UITableViewCell`类包含两个标签，可以用来显示文本。主标签可以通过`TextLabel`属性访问，次要标签可以通过`DetailTextLabel`属性访问。请注意，当使用具有`Default`样式的单元格时，`DetailTextLabel`属性不能使用，并将返回`null`。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'To provide functionality when the user selects a particular row, we need to
    override the `RowSelected` property in the class that acts as a `UITableViewSource`.
    By default, when the user taps on a row, the cell is highlighted with a light
    gray color to indicate the selection. To deselect the row, we use the `UITableView.DeselectRow(NSIndexPath,
    bool)` method, as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户选择特定行时提供功能，我们需要在充当`UITableViewSource`的类中重写`RowSelected`属性。默认情况下，当用户点击一行时，单元格将以浅灰色突出显示，以指示选择。要取消选择行，我们使用`UITableView.DeselectRow(NSIndexPath,
    bool)`方法，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The UITableView styles
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UITableView样式
- en: '`UITableView` can be created with two different styles. The default style is
    `Plain`. The other style that can be used is the `Grouped` style. This style is
    being used in many iOS native apps such as the *Settings* app.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView`可以使用两种不同的样式创建。默认样式是`Plain`。另一种可以使用的样式是`Grouped`样式。这种样式在许多iOS原生应用程序中正在使用，例如*设置*应用程序。'
- en: Also, `UITableView` supports the display of data divided into different sections.
    We must explicitly return the number of rows each section will have in the `RowsInSection`
    override if we want to use different sections.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`UITableView` 支持显示分为不同部分的数据。如果我们想使用不同的部分，我们必须在 `RowsInSection` 覆盖中显式返回每个部分将有的行数。
- en: The UITableViewCell styles
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UITableViewCell 样式
- en: 'A table cell can have four different cell styles, which are represented by
    the `UITableViewCellStyle` enumeration. Its values are listed as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表格单元格可以有四种不同的单元格样式，这些样式由 `UITableViewCellStyle` 枚举表示。其值如下所示：
- en: '**Default**: This is the default cell style. Only the `TextLabel` property
    can be used to display text.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：这是默认单元格样式。只能使用 `TextLabel` 属性来显示文本。'
- en: '**Subtitle**: This is a style that provides `DetailTextLabel` as a subtitle
    to `TextLabel`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副标题**：这是一种提供 `DetailTextLabel` 作为 `TextLabel` 副标题的样式。'
- en: '**Value1**: This is a style that displays both `TextLabel` and `DetailTextLabel`
    text in the same size, with a different color, and aligned to the sides of the
    cell.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值1**：这是一种显示 `TextLabel` 和 `DetailTextLabel` 文本大小相同、颜色不同，并居中对齐单元格两侧的样式。'
- en: '**Value2**: This is a style that displays the `TextLabel` text smaller than
    the `DetailTextLabel` text. This style is used in the native *Contacts* app, in
    the contact details screen.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值2**：这是一种显示 `TextLabel` 文本比 `DetailTextLabel` 文本小的样式。这种样式用于原生 *联系人* 应用中的联系人详情屏幕。'
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Providing lists* recipe
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供列表* 菜谱'
- en: The *Customizing rows* recipe
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义行* 菜谱'
- en: The *Navigating through different view controllers* recipe in [Chapter 3](ch03.html
    "Chapter 3. User Interface – View Controllers"), *User Interface – View Controllers*
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。用户界面 – 视图控制器")，*用户界面 – 视图控制器* 中的 *在不同视图控制器间导航* 菜谱'
- en: Customizing rows
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义行
- en: In this recipe, we will create a table view that uses our own custom subclass
    of `UITableViewCell` to display data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个使用我们自己的自定义 `UITableViewCell` 子类来显示数据的表格视图。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Xamarin Studio in the same manner in which the project
    in the earlier recipe was created. Name it `CustomRowsApp`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以与先前菜谱中创建项目相同的方式在 Xamarin Studio 中创建一个新的项目。将其命名为 `CustomRowsApp`。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a new class to the project and name it `CustomCell`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的类，并将其命名为 `CustomCell`。
- en: 'Implement the class with the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现该类：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add a new **Empty iPhone Interface Definition** to the project and name it `CustomCell`.
    Don't worry about the name conflicting with the class we created earlier, as this
    is an XIB file. Open the file in Interface Builder.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的 **Empty iPhone Interface Definition**，并将其命名为 `CustomCell`。不用担心名称与之前创建的类冲突，因为这个是一个
    XIB 文件。在 Interface Builder 中打开该文件。
- en: Add `UITableViewCell` on the canvas. The following screenshot shows a selected
    `UITableViewCell` in the object browser in Xcode:![How to do it...](img/8924OT_05_03.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加 `UITableViewCell`。以下截图显示了 Xcode 对象浏览器中选中的 `UITableViewCell`：![如何操作...](img/8924OT_05_03.jpg)
- en: Set the **Class** field of the table cell to `CustomCell` in the **Identity**
    inspector.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Identity** 检查器中将表格单元格的 **Class** 字段设置为 `CustomCell`。
- en: Set the **Identifier** field of the cell to `CustomCell` in the **Attributes**
    inspector.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Attributes** 检查器中将单元格的 **Identifier** 字段设置为 `CustomCell`。
- en: Add a `UIImageView` and a `UILabel` on the cell and connect them to their outlets.
    Save the document.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单元格上添加一个 `UIImageView` 和一个 `UILabel`，并将它们连接到它们的出口。保存文档。
- en: Add the `TableController.cs` file we created in the previous recipe, *Displaying
    data in a table*, to the project. Change its namespace from `TableViewApp` to
    `CustomRowsApp`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在先前的菜谱中创建的 `TableController.cs` 文件添加到项目中。将其命名空间从 `TableViewApp` 更改为 `CustomRowsApp`。
- en: 'Change the `TableSource` class'' `GetCell` method to the following code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TableSource` 类的 `GetCell` 方法更改为以下代码：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following code in the `ViewDidLoad` method of `TableController`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TableController` 的 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, make sure that `TableController` is presented in the `FinishedLaunching`
    method, as shown in the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保在 `FinishedLaunching` 方法中呈现 `TableController`，如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just like creating a custom view, we are able to create our own custom cells
    to present data with a `UITableView`. The main difference lies in the fact that
    the table view reuses the instances of its cells so that it is more efficient
    when we want to display multiple rows.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像创建自定义视图一样，我们能够使用`UITableView`创建我们自己的自定义单元格来显示数据。主要区别在于，表格重用其单元格的实例，这样当我们想要显示多行时，它会更有效率。
- en: 'To make our table view "aware" of our custom cell, we call the `RegisterNibForCellReuse`
    method using the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的表格视图“意识到”我们的自定义单元格，我们使用以下代码调用`RegisterNibForCellReuse`方法：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This way, when we call the `DequeueReusable` cell method in `GetCell`, the
    system will automatically create a cell instance for us or get one that was created
    earlier. Hence, there is no need for us to check if the cell is null or not:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们调用`GetCell`中的`DequeueReusable`单元格方法时，系统将自动为我们创建一个单元格实例或获取之前创建的一个。因此，我们不需要检查单元格是否为null：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Did you notice something common in the two method calls discussed earlier?
    They both need an identifier string for the cell. The `CustomCell.CELLID` constant
    has the same value we entered in the **Identifier** field of the cell in Xcode:
    `CustomCell`. In this case, it is the same as the class name of our cell, as it
    keeps things tidy if we were to have different custom cells to present. However,
    basically, the identifier for a cell can be whatever we want it to be.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到前面讨论的两个方法调用中的共同点了吗？它们都需要一个单元格的标识符字符串。`CustomCell.CELLID`常量具有我们在Xcode中单元格的**标识符**字段中输入的相同值：`CustomCell`。在这种情况下，它与我们的单元格类名相同，如果我们有多个自定义单元格要显示，这将使事情保持整洁。然而，基本上，单元格的标识符可以是任何我们想要的。
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can create as many custom cells as we need. As discussed earlier, we need
    to make sure that we set a unique identifier for each of the cell classes we are
    going to use. Also, if the custom cells we create have different heights, we need
    to make sure we override the `GetHeightForRow` method in our `UITableViewSource`
    implementation using the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建我们需要的任何数量的自定义单元格。如前所述，我们需要确保为我们将要使用的每个单元格类设置一个唯一的标识符。此外，如果我们创建的自定义单元格具有不同的高度，我们需要确保我们在`UITableViewSource`实现中使用以下代码覆盖`GetHeightForRow`方法：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For greater efficiency, it's good to have the heights of the rows calculated
    beforehand and not calculate them inside `GetHeightForRow`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，最好事先计算出行高，而不是在`GetHeightForRow`方法中计算它们。
- en: Useful properties of the UITableViewCell class
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UITableViewCell类的有用属性
- en: 'Apart from adding text in the default labels, the `UITableViewCell` contains
    some other properties whose values we can set to add more default items in a cell.
    These properties are are follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在默认标签中添加文本外，`UITableViewCell`还包含一些其他属性，我们可以设置它们的值以在单元格中添加更多默认项。这些属性如下：
- en: '`ImageView`: This accepts a `UIImageView` parameter. We can use it to display
    an image in a cell, on its left-hand side.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageView`：接受一个`UIImageView`参数。我们可以用它来在单元格的左侧显示图像。'
- en: '`AccessoryView`: This accepts any instance of `UIView`. Its position defaults
    to the right of the cell, in the place of the cell''s accessory, which is located
    on the right-hand side of the cell.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccessoryView`：接受任何`UIView`实例。其默认位置在单元格的右侧，位于单元格的accessory位置，该位置位于单元格的右侧。'
- en: '`Accessory`: This accepts values of the `UITableViewCellAccessory` type. It
    provides predefined views for the cell''s accessory, such as `DetailDisclosureButton`
    or `Checkmark`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accessory`：接受`UITableViewCellAccessory`类型的值。它为单元格的accessory提供预定义的视图，例如`DetailDisclosureButton`或`Checkmark`。'
- en: UINib class
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UINib类
- en: 'The `UINib` class is responsible for loading NIB files at runtime. We instantiate
    a `UINib` instance through its `FromName` static method, passing the name of the
    NIB file we want to load without its extension, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINib`类负责在运行时加载NIB文件。我们通过其`FromName`静态方法实例化一个`UINib`实例，传递我们想要加载的NIB文件名（不带扩展名），如下面的代码所示：'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Adding content programmatically
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以编程方式添加内容
- en: 'We can add views to a table cell programmatically. However, we should not add
    them to the cell directly, but to its `ContentView`, using the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以编程方式向单元格添加视图。然而，我们不应直接将其添加到单元格中，而应将其添加到其`ContentView`中，使用以下代码：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying data in a table* recipe
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*配方'
- en: The *Editing a table* recipe
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑表格*配方'
- en: The *Creating a custom view* recipe in [Chapter 2](ch02.html "Chapter 2. User
    Interface – Views"), *User Interface – Views*
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第2章中，*用户界面 – 视图*的*创建自定义视图*配方
- en: Editing a table
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑表格
- en: In this recipe, we will discuss how to insert and delete rows at runtime from
    a `UITableView`, providing the user with the appropriate user interface interaction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何在运行时从 `UITableView` 中插入和删除行，为用户提供适当的用户界面交互。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open the `CustomRowsApp` project we created in the previous recipe, *Customizing
    rows*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们在上一食谱中创建的 `CustomRowsApp` 项目，*自定义行*。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Remove the `tableData` field from the `TableSource` class and replace it with
    the following property:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `TableSource` 类中删除 `tableData` 字段，并用以下属性替换它：
- en: '[PRE25]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Initialize the list in the constructor using the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中使用以下代码初始化列表：
- en: '[PRE26]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `TableSource` class, override the `CommitEditingStyle` method and implement
    it with the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TableSource` 类中，重写 `CommitEditingStyle` 方法并使用以下代码实现它：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `TableController` class, add a `UIBarButtonItem` using the following
    code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TableController` 类中，使用以下代码添加一个 `UIBarButtonItem`：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Compile and run the app on the simulator. Tap the plus button to add new rows
    to the table and swipe on an item from right to left to delete items. The following
    screenshot shows the table after having added one item and swiped on another one:![How
    to do it...](img/8924OT_05_04.jpg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击加号按钮向表格添加新行，从右向左滑动一个项以删除项。以下截图显示了添加了一个项并滑动另一个项后的表格：![如何做...](img/8924OT_05_04.jpg)
- en: Note
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To swipe an item on the simulator, click-and-drag the cursor sideways.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在模拟器上滑动一个项，请点击并拖动光标向侧面。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `CommitEditingStyleForRow` method is called whenever an editing action
    is about to take place. In our implementation, we check if the editing action
    is about deleting an item, and if it is, we remove the row. To do this, we first
    remove the corresponding item from our data source and then call the `DeleteRows`
    method of the table view:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当即将进行编辑操作时，会调用 `CommitEditingStyleForRow` 方法。在我们的实现中，我们检查编辑操作是否是删除项，如果是，我们就删除该行。为此，我们首先从我们的数据源中删除相应的项，然后调用表格视图的
    `DeleteRows` 方法：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, when we want to add a row to the table, we first add the item we
    want to our data source and then call the `InsertRows` method, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们想要向表格中添加一行时，我们首先将我们想要的项添加到我们的数据源中，然后调用以下 `InsertRows` 方法：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's more...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `UITableView` also supports an editing mode. We can activate/deactivate
    the editing mode of a table view by calling the `SetEditing` method, passing `true`
    or `false`, respectively, an example of which is shown in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 也支持编辑模式。我们可以通过调用 `SetEditing` 方法来激活/停用表格视图的编辑模式，分别传递 `true` 或
    `false`，以下代码是一个示例：'
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second parameter determines whether we want the table view to transition
    to/from the editing mode with an animation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数确定我们是否希望表格视图通过动画过渡到/从编辑模式。
- en: When a table view is in the editing mode, each row has a red minus sign on its
    left-hand side. If the user taps the sign, the **Delete** button will appear on
    the right-hand side of the row, just as it appears when they swipe the row.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当表格视图处于编辑模式时，每一行的左侧都有一个红色减号。如果用户点击该符号，行右侧将出现 **删除** 按钮，就像他们滑动行时出现的那样。
- en: Enabling editing modes for individual rows
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为单个行启用编辑模式
- en: 'We can also enable a specific editing mode or even disable it for individual
    rows. To do this, we need to override the `EditingStyleForRow` method in our `UITableViewSource`
    subclass, as shown in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为单个行启用特定的编辑模式，甚至禁用它。为此，我们需要在我们的 `UITableViewSource` 子类中重写 `EditingStyleForRow`
    方法，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: See also
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Displaying data in a table* recipe
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据* 食谱'
- en: Table indexing
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格索引
- en: In this recipe, we will learn how to provide an index in a table, allowing the
    user to quickly browse through the rows of `UITableView`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在表格中提供一个索引，使用户能够快速浏览 `UITableView` 的行。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Xamarin Studio and name it `TableIndexApp`. Add a `UITableViewController`,
    as shown in the previous tasks in this chapter, and implement the `TableSource`
    class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的项目，并将其命名为 `TableIndexApp`。添加一个 `UITableViewController`，如本章前面的任务所示，并实现
    `TableSource` 类。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following step:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the table source class, override and implement the following methods:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表格源类中，重写并实现以下方法：
- en: '[PRE33]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The table source created in this recipe contains many different sections. For
    simplicity, each section contains one row. The `NumberOfSections` method returns
    the total number of sections that the table will display.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中创建的表格源包含许多不同的部分。为了简化，每个部分包含一行。`NumberOfSections` 方法返回表格将显示的总部分数。
- en: 'To set a title for each section, we must override the `TitleForHeader` method,
    as shown in the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个部分设置标题，我们必须重写 `TitleForHeader` 方法，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This implementation returns the first letter of each string in the data source.
    To provide the index, we override the `SectionIndexTitles` method, as shown in
    the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现返回数据源中每个字符串的第一个字母。为了提供索引，我们重写 `SectionIndexTitles` 方法，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, it returns the first letter of each item in the data source. The result
    of this project will be similar to one shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它返回数据源中每个项目的第一个字母。本项目的结果将类似于以下屏幕截图所示：
- en: '![How it works...](img/8924OT_05_05.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8924OT_05_05.jpg)'
- en: When the user touches the screen anywhere on the index, the table view will
    scroll to that specific section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在索引的任何地方触摸屏幕时，表格视图将滚动到该特定部分。
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Indexing should be applied to tables with a **Plain** style. Applying an index
    on tables with a **Grouped** style set is not advisable, because the index will
    not be easily distinguished.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应将索引应用于具有 **普通** 样式的表格。不建议在设置了 **分组** 样式的表格上应用索引，因为索引将不易区分。
- en: A good example of a native iOS app with an index on a table can be found in
    the native *Contacts* app.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在表格上有索引的本地 iOS 应用程序的例子可以在本地的 *Contacts* 应用中找到。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying data in a table* recipe
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据* 的食谱'
- en: Searching through the data
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索数据
- en: In this recipe, we will learn how to provide search functionality for the content
    in a table view.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何为表格视图中的内容提供搜索功能。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Xamarin Studio and name it `SearchTableApp`. Add `UIViewController`
    and name it `SearchController`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的项目，并将其命名为 `SearchTableApp`。添加 `UIViewController` 并命名为
    `SearchController`。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `SearchController.xib` file in Interface Builder. Add **Search Bar
    and Search Display Controller** in `UITableView`. The following screenshot shows
    the `UISearchDisplayController` object selected in the object browser:![How to
    do it...](img/8924OT_05_06.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `SearchController.xib` 文件。在 `UITableView` 中添加 **搜索栏和搜索显示控制器**。以下屏幕截图显示了在对象浏览器中选中的
    `UISearchDisplayController` 对象：![如何做...](img/8924OT_05_06.jpg)
- en: Note
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that after this action, some outlets are created and connected automatically.
    We need most of them, so we leave them as they are.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在此操作之后，将自动创建并连接一些出口。我们需要大多数它们，所以我们保留它们原样。
- en: Add `UITableView` and connect it to an outlet. Save the document.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UITableView` 并将其连接到一个出口。保存文档。
- en: Back in Xamarin Studio, create a `UITableViewSource` subclass that will act
    as the data source for the table view. Refer to the *Displaying data in a table*
    recipe in this chapter for information on how to do this. This time, make sure
    that the `List<string>` variable, which will hold the data, is a member of the
    `SearchController` class.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 Xamarin Studio，创建一个 `UITableViewSource` 子类，它将作为表格视图的数据源。参考本章中的 *在表格中显示数据*
    食谱以获取如何执行此操作的信息。这次，确保将用于存储数据的 `List<string>` 变量是 `SearchController` 类的成员。
- en: 'Add another `List<string>` variable in the `SearchController` class using the
    following code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SearchController` 类中使用以下代码添加另一个 `List<string>` 变量：
- en: '[PRE36]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement a subclass that will act as a delegate object for the search display
    controller, as shown in the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个子类，它将作为搜索显示控制器的委托对象，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following code in the `ViewDidLoad` method and assign the source and
    delegate objects in it:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中添加以下代码，并在其中分配源和委托对象：
- en: '[PRE38]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compile and run the app on the simulator. Tap the search bar and start typing
    into it. It will automatically search the table and show the results.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击搜索栏并开始输入。它将自动搜索表格并显示结果。
- en: 'You can find the complete code in the `SearchTableApp` project. The result
    will be the common iOS search bar above the table, similar to the following screenshot:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 `SearchTableApp` 项目中找到完整的代码。结果将是类似于以下屏幕截图所示的表格上方的常见 iOS 搜索栏：
- en: '![How to do it...](img/8924OT_05_07.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/8924OT_05_07.jpg)'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The `UISearchDisplayController` class provides a convenient way of searching
    through data. It contains `UISearchBar` which accepts input from the user, and
    `UITableView` which is used to display the results. After we add a search controller
    in a view controller, we can access it through that controller''s `SearchDisplayController`
    property. To trigger the results table, we must implement `UISearchDisplayDelegate`
    and override its `ShouldReloadForSearchString` (which returns a Boolean value)
    using the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`UISearchDisplayController`类提供了一个方便的方式来搜索数据。它包含`UISearchBar`，它接受用户的输入，以及`UITableView`，它用于显示结果。在我们向视图控制器添加搜索控制器后，我们可以通过该控制器的`SearchDisplayController`属性访问它。要触发结果表格，我们必须实现`UISearchDisplayDelegate`并覆盖其`ShouldReloadForSearchString`（返回一个布尔值）方法，如下所示：'
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the `ShouldReloadForSearchString` method override, we search our data
    source, saving the filtered results in a new data source according to its `forSearchString`
    parameter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShouldReloadForSearchString`方法覆盖中，我们搜索我们的数据源，根据其`forSearchString`参数将过滤后的结果保存到新的数据源中：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We then sort the results alphabetically and return `true` so that the search
    controller''s table will reload its data, as shown in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按字母顺序排序结果并返回`true`，以便搜索控制器的表格重新加载数据，如下所示：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The search controller''s table view also needs a source object. In this example,
    we set it to the same object we created for our table, as shown in the following
    code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索控制器的表格视图也需要一个源对象。在这个例子中，我们将其设置为为我们的表格创建的相同对象，如下所示：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As we are using instances of the same object, we need to modify some things
    in it to display data according to which table calls it. So, for example, the
    `RowsInSection` method looks like the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是相同对象的实例，我们需要对其中的某些内容进行修改，以便根据哪个表格调用它来显示数据。例如，`RowsInSection`方法如下所示：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this way, we return the number of rows according to which table calls the
    method. Similarly, we need to set each cell''s text label inside the `GetCell`
    method, as shown in the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们根据哪个表格调用该方法来返回行数。同样，我们还需要在`GetCell`方法中设置每个单元格的文本标签，如下所示：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'When the user taps on the search bar, the keyboard appears, making the search
    controller active. To deactivate it, we can hook on the search bar''s `SearchButtonClicked`
    event. This event will get triggered when the user taps on the keyboard''s **Search**
    button:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击搜索栏时，键盘出现，使搜索控制器变得活跃。要使其不活跃，我们可以挂钩到搜索栏的`SearchButtonClicked`事件。当用户点击键盘上的**搜索**按钮时，此事件将被触发：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `SetActive` method is what we can use to enable or disable the search controller.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetActive`方法是我们用来启用或禁用搜索控制器的方法。'
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying data in a table* recipe
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*的食谱'
- en: The *Table indexing* recipe
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表格索引*的食谱'
- en: Creating a simple web browser
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单的网页浏览器
- en: In this recipe, we will discuss displaying online content with the `UIWebView`
    class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将讨论使用`UIWebView`类显示在线内容。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** project in Xamarin Studio and name
    it `WebBrowserApp`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用**项目，并将其命名为`WebBrowserApp`。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `WebBrowserAppViewController.xib` file in Interface Builder and add
    a `UIWebView` object on the main view. Create and connect an outlet for it with
    the name `webView`. Save the document.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`WebBrowserAppViewController.xib`文件，并在主视图中添加一个`UIWebView`对象。为其创建并连接一个名为`webView`的出口。保存文档。
- en: 'Override the `ViewDidAppear` method in the `WebBrowserAppViewController` class,
    as shown in the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下代码所示，在`WebBrowserAppViewController`类中覆盖`ViewDidAppear`方法：
- en: '[PRE46]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Compile and run the app on the simulator. Watch the website load on the screen!
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。观察屏幕上网站加载的情况！
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIWebView` class is iOS SDK''s web browser control. To load web content,
    we just have to call its `LoadRequest` method, which accepts a parameter of the
    `NSUrlRequest` type. The `NSUrlRequest` object contains the URL we want it to
    load, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView`类是iOS SDK的网页浏览器控件。要加载网页内容，我们只需调用其`LoadRequest`方法，该方法接受一个`NSUrlRequest`类型的参数。`NSUrlRequest`对象包含我们想要加载的URL，如下所示：'
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The `UIWebView` class contains some very useful events, which are as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView`类包含一些非常有用的事件，如下所示：'
- en: '`LoadStarted`: This is triggered when the control has started loading content'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadStarted`：当控件开始加载内容时触发'
- en: '`LoadFinished`: This is triggered when the content finished loading successfully'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadFinished`：当内容成功加载完成后触发'
- en: '`LoadError`: This is triggered when the loading of the content failed'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadError`：当内容加载失败时触发'
- en: Scaling the content
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放内容
- en: Another important feature of the `UIWebView` is the automatic scaling of content.
    It can be activated by setting its `ScalePageToFit` property to `true`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView` 的另一个重要功能是内容的自动缩放。可以通过将其 `ScalePageToFit` 属性设置为 `true` 来激活它。'
- en: UIWebView supported files
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIWebView 支持的文件
- en: 'Apart from web pages, the `UIWebView` control can be used to display local
    content with the following types of files:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网页之外，`UIWebView` 控件还可以使用以下类型的文件来显示本地内容：
- en: Excel (`.xls`)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子表格（`.xls`）
- en: Keynote (`.key.zip`)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示文稿（`.key.zip`）
- en: Numbers (`.numbers.zip`)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字（`.numbers.zip`）
- en: Pages (`.pages.zip`)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面（`.pages.zip`）
- en: PDF (`.pdf`)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF（`.pdf`）
- en: Powerpoint (`.ppt`)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幻灯片（`.ppt`）
- en: Word (`.doc`)
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档（`.doc`）
- en: Rich Text Format (`.rtf`)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 富文本格式（`.rtf`）
- en: Rich Text Format Directory (`.rtfd.zip`)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 富文本格式目录（`.rtfd.zip`）
- en: Keynote (`.key`)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示文稿（`.key`）
- en: Numbers (`.numbers`)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字（`.numbers`）
- en: Pages (`.pages`)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面（`.pages`）
- en: Displaying data in a grid
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以网格形式显示数据
- en: In this recipe, we will discuss using the `UICollectionView` object to display
    data in a grid-like layout. The `UICollectionView` class was introduced in iOS
    6, and is a very useful control that was missed by iOS developers. Prior to `UICollectionView`,
    the only way to display data in a grid was to create a custom control, which was
    not a very easy task.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论使用 `UICollectionView` 对象以网格布局显示数据。`UICollectionView` 类是在 iOS 6 中引入的，这是一个被
    iOS 开发人员忽视的非常有用的控件。在 `UICollectionView` 之前，显示网格数据的唯一方法是通过创建自定义控件，这并不是一个很容易的任务。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Xamarin Studio and name it `CollectionViewApp`. We will
    also need something to display, so add an image to the project.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的项目，并将其命名为 `CollectionViewApp`。我们还需要一些内容来显示，所以将一张图片添加到项目中。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `CollectionViewAppViewController.xib` file in Interface Builder and
    add a `UICollectionView` on its main view. The following screenshot shows the
    object in the object browser:![How to do it...](img/8924OT_05_08.jpg)
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `CollectionViewAppViewController.xib` 文件，并在其主视图中添加一个
    `UICollectionView`。以下截图显示了对象浏览器中的对象：![如何操作...](img/8924OT_05_08.jpg)
- en: 'Back in Xamarin Studio, add the following class:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 Xamarin Studio，添加以下类：
- en: '[PRE48]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the following nested class in the controller:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中添加以下嵌套类：
- en: '[PRE49]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the following code in the controller:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中添加以下代码：
- en: '[PRE50]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Compile and run the app on the simulator. The result should be similar to the
    one shown in the following screenshot:![How to do it...](img/8924OT_05_09.jpg)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。结果应类似于以下截图所示：![如何操作...](img/8924OT_05_09.jpg)
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UICollectionView` class is used in a manner that is similar to `UITableView`.
    The main difference is that instead of showing the data in a single column, it
    does so in a grid arrangement. The `UICollectionViewSource` class is overridden
    to provide the data source of the collection view, as shown in the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`UICollectionView` 类的使用方式与 `UITableView` 类似。主要区别在于它不是在单列中显示数据，而是在网格排列中显示。`UICollectionViewSource`
    类被重写以提供集合视图的数据源，如下面的代码所示：'
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Just like table views in `UITableViewSource`, we need to provide the number
    of items in the grid and the object for single items, in this case, `UICollectionViewCell`,
    as shown in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 `UITableViewSource` 中的表格视图一样，我们需要提供网格中的项目数量以及单个项目的对象，在这种情况下是 `UICollectionViewCell`，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that unlike `UITableViewCell`, the `UICollectionViewCell` class doesn''t
    offer much for us to use. So, we have to override it to create our own cell for
    the collection, as shown in the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `UITableViewCell` 不同，`UICollectionViewCell` 类为我们提供的功能不多。因此，我们必须重写它来为集合创建自己的单元格，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As we are using a custom cell, we have to let the collection view know about
    it through the `RegisterClassForCell` method, using the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是自定义单元格，我们必须通过 `RegisterClassForCell` 方法让集合视图知道它，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from showing individual items with the `UICollectionViewCell` class, the
    `UICollectionView` supports the display of supplementary views of the `UICollectionReusableView`
    type. These views basically represent either the header or the footer of the sections
    in the collection view.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`UICollectionViewCell`类显示单个项目外，`UICollectionView`还支持显示`UICollectionReusableView`类型的辅助视图。这些视图基本上代表集合视图中各部分的头部或尾部。
- en: 'To provide supplementary views, we need to create our own subclass using the
    following code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供辅助视图，我们需要创建自己的子类，使用以下代码：
- en: '[PRE55]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We then need to override the following method in the collection source (this
    method will return the supplementary view that we want):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要在集合源中重写以下方法（此方法将返回我们想要的辅助视图）：
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `elementKind` parameter is the `NSString` representation of the `UICollectionElementKindSection`
    enumeration, which contains two values: `Footer` and `Header`.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`elementKind`参数是`UICollectionElementKindSection`枚举的`NSString`表示，它包含两个值：`Footer`和`Header`。'
- en: 'Finally, we need to call the `RegisterClassForSupplementaryView` method to
    register our custom class with the collection view, using the following code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调用`RegisterClassForSupplementaryView`方法来将我们的自定义类注册到集合视图中，使用以下代码：
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: More information on UICollectionView
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于UICollectionView的信息
- en: 'A good tutorial on `UICollectionView` can be found at Xamarin''s website: [http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/](http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin网站上可以找到一个关于`UICollectionView`的优秀教程：[http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/](http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/)。
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关阅读
- en: The *Displaying data in a table* recipe
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*的食谱'
- en: The *Customizing rows* recipe
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义行*的食谱'
- en: Customizing the grid
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义网格
- en: In this recipe, we will learn how to customize the display of the collection
    view.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何自定义集合视图的显示。
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will work on the `CollectionViewApp` project we created in
    the *Displaying data in a grid* recipe. Open the project in Xamarin Studio.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将处理我们在*在网格中显示数据*食谱中创建的`CollectionViewApp`项目。在Xamarin Studio中打开项目。
- en: How to do it...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the `ViewDidLoad` method of the controller, add the following code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的`ViewDidLoad`方法中，添加以下代码：
- en: '[PRE58]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Compile and run the app on the simulator. The result should be similar to the
    one shown in the following screenshot:![How to do it...](img/8924OT_05_10.jpg)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。结果应该与以下截图所示类似：![如何操作...](img/8924OT_05_10.jpg)
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The collection view's layout can be customized through the `UICollectionViewLayout`
    class. `UICollectionViewFlowLayout` is a subclass of this class and offers a simple
    layout that we can use.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`UICollectionViewLayout`类自定义集合视图的布局。`UICollectionViewFlowLayout`是这个类的子类，提供了一个简单的布局，我们可以使用它。
- en: 'By setting specific properties, we define how the cells will be arranged by
    the collection view. The following list describes the properties we are setting
    in this project:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置特定的属性，我们定义了集合视图将如何排列单元格。以下列表描述了我们在项目中设置的属性：
- en: '`MinimumLineSpacing`: This is the smallest distance between rows in the grid'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinimumLineSpacing`：这是网格中行之间的最小距离'
- en: '`MinimumInteritemSpacing`: This is the smallest distance between individual
    items in the grid'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinimumInteritemSpacing`：这是网格中单个项目之间的最小距离'
- en: '`SectionInset`: This is the area around each section in the collection view
    that should be left blank'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SectionInset`：这是集合视图中每个部分周围应该留空的区域'
- en: '`ItemSize`: This is the size of each item in the collection view'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemSize`：这是集合视图中每个项目的尺寸'
- en: 'The following image shows what each property corresponds to in the collection
    view:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了每个属性在集合视图中的对应关系：
- en: '![How it works...](img/8924OT_05_11_diagram.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8924OT_05_11_diagram.jpg)'
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Setting the `ItemSize` parameter of the collection layout object will adjust
    the size of all the items in the collection view. We can set the size for every
    cell individually by providing the following method in the `CollectionSource`
    subclass:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 设置集合布局对象的`ItemSize`参数将调整集合视图中所有项目的尺寸。我们可以在`CollectionSource`子类中提供以下方法来为每个单元格单独设置尺寸：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Adding the preceding method to our own `CollectionSource` subclass would give
    the result shown in the following screenshot:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的方法添加到我们自己的`CollectionSource`子类中，将得到以下截图所示的结果：
- en: '![There''s more...](img/8924OT_05_12.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/8924OT_05_12.jpg)'
- en: See also
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying data in a grid* recipe
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在网格中显示数据* 的配方'
