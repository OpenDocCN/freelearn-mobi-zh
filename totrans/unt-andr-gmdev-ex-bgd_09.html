<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Optimization"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Optimization</h1></div></div></div><p>
<span class="emphasis"><em>In the previous chapter, we learned about special effects for our games. We added background music to our Space Fighter game. We also created engine trails for our ship. Combining both audio effects and particle systems, we created some explosions and gun blasts. Together, this rounds out the game experience and gives us a very complete-looking game.</em></span>
</p><p>
<span class="emphasis"><em>In this chapter, we explore our options for optimization. We start by looking at the application footprint, and how to reduce it. We move on to look at the game's performance. We look at the tools that Unity provides and create another one ourselves. With the use of occlusion culling, we can improve the game's performance even further. Finally, we will explore some key areas that can cause lag and how to minimize their effects.</em></span>
</p><p>In this chapter, we will be covering the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Minimizing the application footprint</li><li class="listitem" style="list-style-type: disc">Tracking performance</li><li class="listitem" style="list-style-type: disc">Minimizing lag</li><li class="listitem" style="list-style-type: disc">Occlusion</li></ul></div><p>We will be working on both our Space Fighter and Tank Battle games, for this chapter. Start by opening the Space Fighter project.</p><div class="section" title="Minimizing the application footprint"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec125"/>Minimizing the application footprint</h1></div></div></div><p>One of the keys to a successful game is the size of the game itself. Many users will quickly uninstall any application that appears<a id="id650" class="indexterm"/> to be unnecessarily large. Also, all of the mobile app stores have limits to how your game will be supplied to users based on the size of the application itself. Becoming familiar with the options <a id="id651" class="indexterm"/>you have for minimizing the size of your game is the key to control how your game will be distributed.</p><p>The first thing to note when working to minimize the footprint is how Unity handles assets as it builds the game. Only assets that are used somewhere in one of the scenes for the build are actually included in the game. If it is not in the scene itself or referenced by an asset that is in the scene, it will not be included. This means you could have test versions of assets, or incomplete<a id="id652" class="indexterm"/> versions; as long as they are not referenced, they will not affect the final build size of your game.</p><p>Unity also allows you to keep your assets in the format you need for working on them. When the final build is made, all assets are converted to an appropriate version for their type. This means you can keep models in the format native to your modeling program. Or keep your images as Photoshop files, or any other format you work in, and they will be converted to <code class="literal">JPG</code> or <code class="literal">PNG</code> appropriately when the game is built.</p><div class="section" title="Editor log"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec141"/>Editor log</h2></div></div></div><p>When you are finally ready<a id="id653" class="indexterm"/> to work with the footprint of your game, it is possible to find out exactly what is causing your game to be larger than desired. In the top-right corner of the <span class="strong"><strong>Console</strong></span> window is a drop-down menu button. Inside this menu is <span class="strong"><strong>Open Editor Log</strong></span><a id="id654" class="indexterm"/>.</p><div class="mediaobject"><img src="graphics/2014OT_09_07.jpg" alt="Editor log"/></div><p>The editor log is the location where Unity outputs information while it is running. This includes information about the current version, license checks, and any asset importing. The log will also contain detailed information about the file size and assets included in the game, after it has been built.</p><div class="mediaobject"><img src="graphics/2014OT_09_08.jpg" alt="Editor log"/></div><p>We can see a breakdown of the aspects of the final build. Every asset category has a size and percentage of the<a id="id655" class="indexterm"/> total build size. We are also supplied with a list of every asset that is actually included in the game, organized by their file size before being added to the build. This information becomes very useful when looking for assets that can stand to be made smaller.</p></div><div class="section" title="Asset compression"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec142"/>Asset compression</h2></div></div></div><p>Inside the <span class="strong"><strong>Import Settings</strong></span> for models, textures, and audio there are options that affect the size and quality<a id="id656" class="indexterm"/> of imported assets. In general, the affected change is a reduction in quality. However, especially when working on mobile devices, asset quality can be reduced well below the levels required for a computer before the difference<a id="id657" class="indexterm"/> is noticeable on the device. Once you understand the options available for each type of asset, you will be able to make optimal decisions regarding the quality of your game. When working with any of these options, look for a setting that minimizes the size before introducing undesired artifacts.</p><div class="section" title="Models"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec01"/>Models</h3></div></div></div><p>No matter what program or method you use to create your models, ultimately they are always a list of vertex positions and triangles, with a few references to textures. Most of the file size of a model comes from the list of vertex positions. To make sure the models in your game are of the highest quality, <a id="id658" class="indexterm"/>start in the modeling program of your choice. Delete any and all extra vertexes and faces. Not only will this result in a smaller file when building your final game, it will also reduce the import time when working in the editor.</p><p>The <span class="strong"><strong>Import Settings</strong></span> for models consists of three pages, resulting in more options to adjust the quality. Each page tab corresponds to the relevant part of the model, allowing us to fine-tune each one of them.</p></div><div class="section" title="Model tab"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec02"/>Model tab</h3></div></div></div><p>On the <span class="strong"><strong>Model</strong></span> tab, we are able to affect how the mesh is imported. When it comes to optimizing our use of the<a id="id659" class="indexterm"/> models, there are many options here that are key to success. Once your game is looking and playing<a id="id660" class="indexterm"/> the way you want it to, we should have a good look at the settings shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2014OT_09_03.jpg" alt="Model tab"/></div><p>The settings available under the <span class="strong"><strong>Model</strong></span> tab are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mesh Compression</strong></span>: This option<a id="id661" class="indexterm"/> lets us select how much compression should be applied to the model. The effect amounts to combining vertexes to reduce the overall amount of detail that has to be stored for the mesh. This setting is likely to introduce undesired oddities in the mesh. So, always pick the highest setting that does not introduce any artifacts.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Read/Write Enabled</strong></span>: This option is only<a id="id662" class="indexterm"/> useful when you want to manipulate the mesh while the game is running, through the script. If you never touch the mesh with any of your scripts, uncheck this box. While not affecting the final build size, this will affect how much memory is required to run your game.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Optimize Mesh</strong></span>: This option causes Unity to reorder the triangles list that describes the model. This is always a good<a id="id663" class="indexterm"/> one to leave checked. The only reason you might want to uncheck it is if you are manipulating the game or mesh based on the specific order of the triangles.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Generate Colliders</strong></span>: This option is almost always a candidate to leave off. This option will add Mesh Collider <a id="id664" class="indexterm"/>components to every mesh in your model. These are relatively expensive to calculate when working with physics in your game. If possible, you should always use a group of the significantly simpler Box Colliders and Sphere Colliders.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Generate Lightmap UVs</strong></span>: This option<a id="id665" class="indexterm"/> should only be used when working with objects that need static shadows. If the object does not, it will introduce excess vertex information and bloat the asset.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Normals</strong></span>: This option is used by materials <a id="id666" class="indexterm"/>for determining which direction a vertex faces and how lighting should affect it. If the mesh never uses a material needing <span class="strong"><strong>Normals</strong></span> information, be sure to set this to <span class="strong"><strong>None</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tangents</strong></span>: This option is used by materials<a id="id667" class="indexterm"/> for faking detail with bump maps and similar special effects. Just as with the <span class="strong"><strong>Normals</strong></span> setting, if you don't need them, don't import them. If <span class="strong"><strong>Normals</strong></span> is set to <span class="strong"><strong>None</strong></span>, this setting will automatically be grayed out and no longer imported.</li></ul></div></div><div class="section" title="Rig tab"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec03"/>Rig tab</h3></div></div></div><p>The following is a screenshot <a id="id668" class="indexterm"/>that displays the <span class="strong"><strong>Rig</strong></span> tab:</p><div class="mediaobject"><img src="graphics/2014OT_09_09.jpg" alt="Rig tab"/></div><p>There are really<a id="id669" class="indexterm"/> only two things to keep in mind when working to optimize your animation rig. The first is, if the asset does not animate, then don't import it. By setting <span class="strong"><strong>Animation Type</strong></span> to <span class="strong"><strong>None</strong></span>, Unity will not try to import the rig or any useless animations. The second thing to keep in mind is to remove any unnecessary bones. Once imported to Unity, delete any and all objects from the rig that do not actually have an effect on the animation <a id="id670" class="indexterm"/>or character. Unity converts any inverse<a id="id671" class="indexterm"/> kinematics that you might use for animating into forward kinematics, so the guides used for it can be deleted once in Unity.</p></div><div class="section" title="Animations tab"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec04"/>Animations tab</h3></div></div></div><p>As with with the <span class="strong"><strong>Rig</strong></span> tab, if the model <a id="id672" class="indexterm"/>does not animate, do not import animations. Unchecking the <span class="strong"><strong>Import Animation</strong></span> box, when first importing the asset, will avoid any extra components being added to your GameObjects in Unity. <a id="id673" class="indexterm"/>Also, if any extra animations get added to your final build accidentally, they can quickly make your application over-sized.</p><div class="mediaobject"><img src="graphics/2014OT_09_06.jpg" alt="Animations tab"/></div><p>The settings available under the <span class="strong"><strong>Animations</strong></span> tab are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Anim. Compression</strong></span><a id="id674" class="indexterm"/>: This option adjusts how Unity handles excess keyframes in your animations. For most situations, the default option works well.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Off</strong></span>: This option should only be used if you need a high-precision animation. This is the largest and most costly setting to choose.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Keyframe Reduction</strong></span>: This option will reduce the number of keyframes used by the animation based on the Error settings that follow. Essentially, if a keyframe does not have a noticeable effect upon the animation, it is ignored.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Keyframe Reduction and Compression</strong></span>: This option does the same as the previous option but additionally compresses the file size of the animations. At<a id="id675" class="indexterm"/> runtime, though, the animation will still require the same amount of processor resources to calculate as the previous option.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rotation Error</strong></span>: This <a id="id676" class="indexterm"/>option is the number of degrees different between keyframes that will be ignored when performing keyframe<a id="id677" class="indexterm"/> reduction.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Position Error</strong></span>: This option<a id="id678" class="indexterm"/> is the movement distance that will be ignored between keyframes when performing the keyframe reduction.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scale Error</strong></span>: This option is the amount <a id="id679" class="indexterm"/>of size adjustment in the animation that will be ignored between keyframes when performing the keyframe<span class="strong"><strong> </strong></span>reduction.</li></ul></div></div><div class="section" title="Textures"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec05"/>Textures</h3></div></div></div><p>When working with textures in computer graphics, it is always better to work in <span class="strong"><strong>Powers of 2</strong></span><a id="id680" class="indexterm"/>. A Power of 2 is any value where it and its subsequent halves can be evenly divided by two until one is reached. This is important because they<a id="id681" class="indexterm"/> are faster for the computer to calculate and process. By default, Unity will convert any textures that do not meet this requirement by scaling them to the nearest Power of 2.</p><div class="mediaobject"><img src="graphics/2014OT_09_04.jpg" alt="Textures"/></div><p>The various <span class="strong"><strong>Texture</strong></span> settings available in Unity are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Texture Type</strong></span>: This option affects<a id="id682" class="indexterm"/> what type of texture this image will be treated as. It is always best to select the type most appropriate for the <a id="id683" class="indexterm"/>intended use of the image.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Texture</strong></span>: This option is the most common and default setting. This should be used for your normal model textures.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Normal Map</strong></span>: This option is used for special effects such as bump maps. Materials using this type of texture will also need the normal and tangent information from the model import settings.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GUI</strong></span>: This option should be used if the image is going to appear in the GUI and not on any models.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Reflection</strong></span>: These textures are used for creating cube maps that imitate the reflective properties of real objects.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cookie</strong></span>: These textures are used on lights, changing how the light is emitted from the light object.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Advanced</strong></span>: This option gives full control over all of the settings concerned with importing images. You will only need this setting if you have special purposes for your textures.<p>When the <span class="strong"><strong>Texture Type</strong></span> option is set to <span class="strong"><strong>Advanced</strong></span>, the <span class="strong"><strong>Read / Write Enabled</strong></span> box becomes available. This should only be left checked if you plan on manipulating the texture from your scripts while the game is running. If unchecked, Unity does not maintain a copy of the data in the CPU, freeing memory for other parts of the game.</p></li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Generate Mip Maps</strong></span>: This option is another <span class="strong"><strong>Advanced</strong></span> setting that lets you control the creation of smaller <a id="id684" class="indexterm"/>versions of the texture. These are then used when the texture is small on the screen, reducing the amount of processing needed to draw the texture and the object using it on the screen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Filter Mode</strong></span>: This option<a id="id685" class="indexterm"/> is available for all of the texture types. It affects how the image will look when you are very close to it. <span class="strong"><strong>Point</strong></span> will make the image look blocky, while <span class="strong"><strong>Bilinear</strong></span> and <span class="strong"><strong>Trilinear</strong></span> will blur the pixels. In general, <span class="strong"><strong>Point</strong></span> is the fastest; <span class="strong"><strong>Trilinear</strong></span> is the slowest but gives the best looking effect.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Max Size</strong></span>: This option adjusts how <a id="id686" class="indexterm"/>large the image can be when it is used in the game. This allows you to work with images that are very large but import them to Unity in an appropriately small size. In general, values greater than <span class="strong"><strong>1024</strong></span> are poor choices; not just because of the increased memory requirement, but also because the video cards on most mobile devices cannot handle textures that are any larger. Choosing the smallest size possible will have a great effect on the footprint size<a id="id687" class="indexterm"/> of the textures in your final build.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Format</strong></span>: This option adjusts<a id="id688" class="indexterm"/> how the image should be imported and how much detail each pixel can hold. <span class="strong"><strong>Compressed</strong></span> is the smallest, while <span class="strong"><strong>Truecolor</strong></span> provides the most detail.</li></ul></div></div><div class="section" title="Audio"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec06"/>Audio</h3></div></div></div><p>Giving a game quality<a id="id689" class="indexterm"/> sound always adds a lot to the final size of the game. It is one of those assets that a game cannot do without, but can be hard to include at a suitable level. When working on them in your audio program, keep them as short as possible to minimize their size. The audio import settings all have an effect on either their footprint in the build size, or the memory required to run the game.</p><div class="mediaobject"><img src="graphics/2014OT_09_05.jpg" alt="Audio"/></div><p>The various <span class="strong"><strong>Audio</strong></span> settings available in Unity are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Audio Format</strong></span>: This setting changes how the file will be stored in your game. <span class="strong"><strong>Native</strong></span> offers higher quality while <span class="strong"><strong>Compressed</strong></span> results in a smaller file size. As a special feature of mobile platforms, compressed audio can be retrieved relatively faster<a id="id690" class="indexterm"/> than on other platforms because of some special hardware in the mobile devices.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>3D Sound</strong></span>: This setting dictates<a id="id691" class="indexterm"/> whether or not the file will be affected by its position in the game relative to the <span class="strong"><strong>Audio Listener</strong></span>. If this is unchecked, some calculations can be avoided, reducing the processing required in each frame of your game.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Force to mono</strong></span>: This setting converts stereo audio into mono. While most devices are technically capable of playing stereo sounds, they do not always have the multiple speakers required <a id="id692" class="indexterm"/>for it to make a difference. Checking this box can significantly reduce the file size of the audio, by removing that extra audio channel.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Load type</strong></span>: This setting affects how much of the system's memory is used, while the game is running, to handle loading audio files. <span class="strong"><strong>Decompress on load</strong></span> uses the most memory, and is best for small, short sounds. <span class="strong"><strong>Compressed in memory</strong></span> only decompresses<a id="id693" class="indexterm"/> the file while it is playing, using a medium amount of memory, and is best for medium-sized files. <span class="strong"><strong>Stream from disc</strong></span> means that only the part of the file currently being played is stored in the runtime memory. This is like streaming video or music from the Internet. This option is best for large files but should only be used by a few at one time.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Compression (kbps)</strong></span>: This setting adjusts the amount of detail in the audio file. A smaller value will <a id="id694" class="indexterm"/>reduce the file size, but also reduce quality. A larger value will result in a larger file size and greater quality. If the amount of compression already applied by your audio is smaller than the value here, the setting will have no effect on the sound. In general, it is best to pick the smallest size while maintaining the desired level of quality.</li></ul></div></div></div><div class="section" title="Player settings"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec143"/>Player settings</h2></div></div></div><p>Open your game's <span class="strong"><strong>Player Settings</strong></span> by going to Unity's toolbar and navigating to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Player</strong></span>. In the <span class="strong"><strong>Per-Platform Settings</strong></span>, for Android, we have another few options under <span class="strong"><strong>Other Settings</strong></span> that will affect the <a id="id695" class="indexterm"/>final size and speed of our game.</p><div class="section" title="Rendering"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec07"/>Rendering</h3></div></div></div><p>The following is the screenshot that displays the <a id="id696" class="indexterm"/>
<span class="strong"><strong>Rendering</strong></span> settings:</p><div class="mediaobject"><img src="graphics/2014OT_09_10.jpg" alt="Rendering"/></div><p>The various <span class="strong"><strong>Rendering</strong></span> settings<a id="id697" class="indexterm"/> available in Unity are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When we worked with making lightmaps, we had<a id="id698" class="indexterm"/> to set some objects as static. This told Unity that the objects will never be moving and allows them to be lightmapped. It also allows Unity Pro users to utilize <span class="strong"><strong>Static Batching</strong></span> that allows Unity to significantly speed up rendering times by grouping identical objects. For each group it then renders one object in multiple places, rather than each object individually. Potentially, this setting can add some extra girth to your final build size, because Unity will need to save extra information about your static objects to make it work.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dynamic Batching</strong></span> works the same as <span class="strong"><strong>Static Batching</strong></span>, with two major differences. First, it is available to both Unity Pro and Basic users. Second, it groups objects that are not marked as static.</li></ul></div></div><div class="section" title="Optimization"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec08"/>Optimization</h3></div></div></div><p>The <span class="strong"><strong>Optimization</strong></span> settings are<a id="id699" class="indexterm"/> shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2014OT_09_11.jpg" alt="Optimization"/></div><p>The various <span class="strong"><strong>Optimization</strong></span> settings available in Unity are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Api Compatibility Level</strong></span>: This setting <a id="id700" class="indexterm"/>determines which set of the .Net functions to include in the final build. <span class="strong"><strong>.Net 2.0</strong></span> will include all of the available functions, making the largest footprint. <span class="strong"><strong>.Net 2.0 Subset</strong></span> is a smaller portion of the functions, including only those that your programming is most likely to use. Unless you need some special functionality, <span class="strong"><strong>.Net 2.0 Subset</strong></span> should always be the option you choose.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Stripping Level</strong></span>: This setting is a Unity Pro only feature. It allows you to reduce the size of your final build by removing all of the excess code before compiling it. System functions are grouped into what are called libraries for easy reference. <span class="strong"><strong>Strip Assemblies</strong></span> removes the unused libraries from the final build. <a id="id701" class="indexterm"/>The <span class="strong"><strong>Use micro mscorlib</strong></span> option performs the same function as the previous option, but utilizes a minimized form of the libraries. While significantly smaller, this library possesses fewer functions for your code to use. However, unless your game is complex, it should not make a difference.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Optimize Mesh Data</strong></span>: This setting will remove extra information from all of your meshes that are not being<a id="id702" class="indexterm"/> used by any materials applied to them. This includes the <span class="strong"><strong>Normals</strong></span>, <span class="strong"><strong>Tangents</strong></span>, and a few other bits of information. Unless you have a very special case, this is a good box to always check.</li></ul></div></div></div></div></div>
<div class="section" title="Tracking performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec126"/>Tracking performance</h1></div></div></div><p>Unity provides us with many tools that allow us to determine how well our game is running. The <a id="id703" class="indexterm"/>first we will be covering is readily available for both Unity Pro and Basic users. However, the information is rather limited, though still useful. The second is only available to Unity Pro users. It provides significantly more detail and information on performance. Finally, we will create our own tool, allowing us to view the performance of our scripts in detail.</p><div class="section" title="Editor statistics"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec144"/>Editor statistics</h2></div></div></div><p>In the top-right of the <span class="strong"><strong>Game</strong></span> window, there is a button labeled <span class="strong"><strong>Stats</strong></span>. Clicking on this button will open a window, giving<a id="id704" class="indexterm"/> us information about how the game is running. There is little bit of information about how fast the game is running. Most of the information in this window concerns how well the game is being rendered, largely amounting to how many objects are currently on the screen, how many are animating, and how much memory they take up.</p><div class="mediaobject"><img src="graphics/2014OT_09_02.jpg" alt="Editor statistics"/></div><p>The various statistics in Unity Editor are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At the top-right of the Unity Editor <span class="strong"><strong>Statistics</strong></span> window is the current <span class="strong"><strong>FPS</strong></span> (<span class="strong"><strong>Frames Per Second</strong></span><a id="id705" class="indexterm"/>) and the time in milliseconds that the last frame took to render. These values are unaffected by the rendering of the rest of the Unity Editor, though there is a slight performance hit by running the game in the Editor. In general, if you can keep your game running at more than 60 FPS, your game will run pretty well on your target platform.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Main Thread</strong></span> statistic<a id="id706" class="indexterm"/> provides us with the time in milliseconds that it took to run through the code for the frame and <a id="id707" class="indexterm"/>render everything to the screen. This is the total amount of time it takes to process a single frame of your game.</li><li class="listitem" style="list-style-type: disc">To the right of <span class="strong"><strong>Main Thread</strong></span>, we <a id="id708" class="indexterm"/>have <span class="strong"><strong>Renderer</strong></span>. This statistic is the number of milliseconds the rendering of the frame alone took. This time is already included in the <span class="strong"><strong>Main Thread</strong></span> statistic.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Draw Calls</strong></span> statistic<a id="id709" class="indexterm"/> is the number of unique objects that had to be drawn on screen. This is roughly equal to the number of objects that are currently visible to the camera. So, things behind the camera are not drawn and do not add to this value.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Saved by batching</strong></span> statistic<a id="id710" class="indexterm"/> is closely related to the number of <span class="strong"><strong>Draw Calls</strong></span>. We will learn more about batching later. But, suffice it to say for now, batching is a special grouping process that reduces the number of <span class="strong"><strong>Draw Calls</strong></span>, making the game render faster.</li><li class="listitem" style="list-style-type: disc">Ultimately, every model in 3D graphics is made from a series of triangles. <span class="strong"><strong>Tris</strong></span> is the total number of triangles seen and being rendered by the camera.</li><li class="listitem" style="list-style-type: disc">Most of the information<a id="id711" class="indexterm"/> in a model file is concerned with the position of each vertex. <span class="strong"><strong>Verts</strong></span><a id="id712" class="indexterm"/> is the total number of vertexes seen and rendered by the camera. The lower the number of vertexes for each model, the faster it will be rendered to the screen.</li><li class="listitem" style="list-style-type: disc">The first number for the<a id="id713" class="indexterm"/> <span class="strong"><strong>Used Textures</strong></span> statistic is the total number of unique textures that are being used in this frame. The second is the total amount of memory they take up. By reducing texture quality or by combining textures, this statistic can be reduced, allowing the game to run faster.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Render Textures</strong></span> statistic is<a id="id714" class="indexterm"/> a special type of texture used for special effects such as security cameras and real-time reflections. This statistic displays the total number visible and the amount of memory needed for them.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>switches</strong></span> statistic<a id="id715" class="indexterm"/> essentially amounts to how much work the <span class="strong"><strong>Render Textures</strong></span> statistic is doing. Fewer <span class="strong"><strong>Render Textures</strong></span> and simpler materials will reduce this number and the resulting cost to rendering time.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Screen</strong></span> is the current width and height, in pixels, of the <span class="strong"><strong>Game</strong></span> window. It also displays the amount<a id="id716" class="indexterm"/> of memory needed for rendering at that size. A smaller size results in less detail for your game, but also makes the game easier to render.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>VRAM usage</strong></span> statistic<a id="id717" class="indexterm"/> gives the approximate minimum and maximum video memory currently being used. It also provides the current total amount of video memory available in parentheses. With this statistic and knowing the amount of video memory available in your target device, you can determine whether graphics of your game are simple enough to run on that device.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>VBO Total</strong></span> statistic is the total number of unique meshes currently being rendered by your game. Every<a id="id718" class="indexterm"/> distinct model you might use will add to this statistic.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Shadow Casters</strong></span> statistic is used when making use of real-time shadows. Real-time shadows <a id="id719" class="indexterm"/>are expensive. If possible, they should not be used on mobile devices. But, if you have to have them, minimize the number of objects that cast those shadows. Limit it to moving objects that are large enough for the user to see the shadow. Small, static objects especially do not need to cast shadows.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Visible Skinned Meshes</strong></span> statistic<a id="id720" class="indexterm"/> is the total number of rigged objects currently in the view of the camera. <span class="strong"><strong>Skinned Meshes</strong></span> are most often going to be your characters and just about anything else that animates.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Animations</strong></span> statistic<a id="id721" class="indexterm"/> provides the current total<a id="id722" class="indexterm"/> number of animations playing in the scene.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Network</strong></span> group of statistics only becomes visible when connected to other players in a multiplayer game. The information generally amounts to how many people the game is connected to and how fast those connections are.</li></ul></div></div><div class="section" title="The Profiler"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec145"/>The Profiler</h2></div></div></div><p>The <span class="strong"><strong>Profiler</strong></span> window<a id="id723" class="indexterm"/>, found in <a id="id724" class="indexterm"/>Unity's toolbar under <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Profiler</strong></span>, is a great tool for analyzing how your game is running. It gives us a colorful breakdown of each part of our system and how much work it is doing. The only really unfortunate part of this tool is that it is only available for Unity Pro users.</p><div class="mediaobject"><img src="graphics/2014OT_09_12.jpg" alt="The Profiler"/></div><p>By first opening the <span class="strong"><strong>Profiler</strong></span> window, we can then play our game in the window and watch the tool give us a fairly detailed breakdown of what is going on. We can click on any point and see detailed information about that frame in the bottom of the window. The information provided is specific to the lane that you clicked on, <span class="strong"><strong>CPU Usage</strong></span>, <span class="strong"><strong>Rendering</strong></span>, <span class="strong"><strong>Memory</strong></span>, and so on.</p><p>The <span class="strong"><strong>CPU Usage</strong></span> information is particularly useful when trying to find parts of our game that are taking too long to process. Spikes in processing cost stand out pretty easily. By clicking on a spike, we <a id="id725" class="indexterm"/>can see the breakdown of what each part of the game played in making that frame expensive. For most of these parts we can dig down to the exact object or function that is causing the issue. However, we can only get down to the function level. Just because we know where an issue in the code <a id="id726" class="indexterm"/>generally is, the Profiler will not tell us exactly which part of that function is causing the issue.</p><p>In order to actually work, the Profiler needs to hook into every part of your game. This introduces a little extra cost in the speed of your game. Therefore, when analyzing the information provided, it is best to consider the relative costs rather than hold each cost as an exact value.</p></div><div class="section" title="Tracking script performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec146"/>Tracking script performance</h2></div></div></div><p>All of these tools that Unity provides are great, but not always the right solution. The Unity Basic user does not have access to the Profiler. Also, both the Profiler and the Editor Statistics are<a id="id727" class="indexterm"/> fairly generalized. We can get a little more detail with the Profiler, but not always enough. In this next part, we will be creating a special script capable of tracking the performance of specific parts of any script. It should definitely become a regular piece of your developer kit.</p></div></div>
<div class="section" title="Time for action &#x2013; tracking scripts"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec127"/>Time for action – tracking scripts</h1></div></div></div><p>We will be creating this script in the Space Fighter game:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we will need a special class that will keep track of our performance statistics. Create a new script and name it <code class="literal">TrackerStat</code>.</li><li class="listitem">To begin this script, we first need to change the class definition line. We do not want or need to extend the <code class="literal">MonoBehaviour</code> class. So, find the following line of code:<div class="informalexample"><pre class="programlisting">public class TrackerStat : MonoBehaviour {</pre></div><p>And, change it to the following:</p><div class="informalexample"><pre class="programlisting">public class TrackerStat {</pre></div></li><li class="listitem">This script starts with four variables. The first will be used as an ID, allowing us to track multiple scripts at once by supplying different key values. The second will keep track of the average amount of time that the tracked bits of code are taking. The third is just the total number of times the tracked code has been called. The fourth is the longest time the code has taken to execute.<div class="informalexample"><pre class="programlisting">public string key = "";
public float averageTime = 0;
public int totalCalls = 0;
public float longestCall = 0;</pre></div></li><li class="listitem">Next, we have two more variables. These will do the work of actually tracking how long the script takes to execute. The first is the time when the tracking starts. The second is a flag marking that tracking has started.<div class="informalexample"><pre class="programlisting">public float openTime = 0;
public bool isOpen = false;</pre></div></li><li class="listitem">The first function<a id="id728" class="indexterm"/> for this script is <code class="literal">Open</code>. This function is called when we want to start tracking a bit of code. It first checks to see if the code is already being tracked. It uses <code class="literal">Debug.LogWarning</code> to send a warning to the <span class="strong"><strong>Console</strong></span> window, if it is. Next, it sets the flag marking that code is being tracked. Finally, the function tracks the time it was called by using <code class="literal">Time.realtimeSinceStartup</code>, which is the actual number of seconds since the game started.<div class="informalexample"><pre class="programlisting">public void Open() {
  if(isOpen) {
    Debug.LogWarning("Tracking is already open. Key: " + key);
  }

  isOpen = true;
  openTime = Time.realtimeSinceStartup;
}</pre></div></li><li class="listitem">The next function, <code class="literal">Close</code>, acts as the opposite of the previous one. It is called when we have reached the end of the code we want to track. The time when the tracking should stop is passed to it. This is done to minimize the amount of excess code being executed. As with the previous function, it checks to see if tracking is being done, sending out another warning and exiting early if it is not. Next, the <code class="literal">isOpen</code> flag is cleared by setting it to <code class="literal">false</code>. Finally, the amount of time since tracking was opened is calculated and the <code class="literal">AddValue</code> function<a id="id729" class="indexterm"/> is called.<div class="informalexample"><pre class="programlisting">public void Close(float closeTime) {
  if(!isOpen) {
    Debug.LogWarning("Tracking is already closed. Key: " + key);
    return;
  }
  isOpen = false;
  AddValue(closeTime - openTime);
}</pre></div></li><li class="listitem">This last function for this script is <code class="literal">AddValue</code>. This function is passed <code class="literal">callLength</code>, the length of time that the tracked bit of code took. It then uses some math to add the value to <code class="literal">averageTime</code>. Next, the function compares the current <code class="literal">longestCall</code> with the new value and selects the longest. Finally, the function increments <code class="literal">totalCalls</code>.<div class="informalexample"><pre class="programlisting">public void AddValue(float callLength) {
  float totalTime = averageTime * totalCalls;
  averageTime = (totalTime + callLength) / (totalCalls + 1);

  longestCall = longestCall &lt; callLength ? callLength : longestCall;

  totalCalls++;
}</pre></div></li><li class="listitem">Next, we need to<a id="id730" class="indexterm"/> create another new script and name it <code class="literal">ScriptTracker</code>. This script will allow us to do actual performance tracking.</li><li class="listitem">This script starts off with a single variable. This variable maintains all of the stats that are currently being tracked. Note the use of <code class="literal">static</code> here; it allows us to easily update the list from anywhere in the game.<div class="informalexample"><pre class="programlisting">private static TrackerStat[] stats = new TrackerStat[0];</pre></div></li><li class="listitem">The first function for this script, <code class="literal">Open</code>, allows us to start tracking the code execution. It uses the <code class="literal">static</code> flag, so the function can be called easily by any script. A <code class="literal">key</code> value is passed to the function, allowing us to group track calls. The function starts by creating a variable to hold the <code class="literal">index</code> of the stat to start tracking. Next, it loops through the current set of <code class="literal">stats</code> to find a matching <code class="literal">key</code> value. If one is found, the <code class="literal">index</code> variable is updated with the value and the loop is exited.<div class="informalexample"><pre class="programlisting">public static void Open(string key) {
  int index = -1;

  for(int i=0;i&lt;stats.Length;i++) {
    if(stats[i].key == key) {
      index = i;
      break;
    }
  }</pre></div></li><li class="listitem">The <code class="literal">Open</code> function<a id="id731" class="indexterm"/> continues by checking if a stat was found. The <code class="literal">index</code> variable will only be less than zero if we make it through the whole loop of current <code class="literal">stats</code> and are unable to find a matching <code class="literal">key</code>. If one is not found, we call <code class="literal">AddNewStat</code>, which will be created shortly, to create the new stat for tracking. The <code class="literal">index</code> is then set to that of the new stat. Finally, the stat is triggered to start tracking by using the stat's <code class="literal">Open</code> function.<div class="informalexample"><pre class="programlisting">  if(index &lt; 0) {
    AddNewStat(key);
    index = stats.Length – 1;
  }

  stats[index].Open();
}</pre></div></li><li class="listitem">The <code class="literal">AddNewStat</code> function<a id="id732" class="indexterm"/> is passed the <code class="literal">key</code> of the stat that is to be created. It starts by storing the list of <code class="literal">stats</code> in a temporary variable and increasing the size of the <code class="literal">stats</code> list by one. Each value is then transferred from the <code class="literal">temp</code> list to the larger <code class="literal">stats</code> list. Finally, a new stat is created, it is assigned to the last slot in the <code class="literal">stats</code> list, and the <code class="literal">key</code> is set.<div class="informalexample"><pre class="programlisting">private static void AddNewStat(string key) {
  TrackerStat[] temp = stats;
  stats = new TrackerStat[temp.Length + 1];
  
  for(int i=0;i&lt;temp.Length;i++) {
    stats[i] = temp[i];
  }

  stats[stats.Length – 1] = new TrackerStat();
  stats[stats.Length – 1].key = key;
}</pre></div></li><li class="listitem">Next, we have the <code class="literal">Close</code> function<a id="id733" class="indexterm"/>. This function is passed the <code class="literal">key</code> value of the stat to be closed. It starts by finding the time that the function was called, minimizing the<a id="id734" class="indexterm"/> amount of excess code being tracked. It continues by looping through the list of <code class="literal">stats</code> to find a matching <code class="literal">key</code>. If one is found, the stat's <code class="literal">Close</code> function is called and the function is exited. If a match is not found, <code class="literal">Debug.LogError</code> is called to send an error message to the <span class="strong"><strong>Console</strong></span> window.<div class="informalexample"><pre class="programlisting">public static void Close(string key) {
  float closeTime = Time.realtimeSinceStartup;

  for(int i=0;i&lt;stats.Length;i++) {
    if(stats[i].key == key) {
      stats[i].Close(closeTime);
      return;
    }
  }

  Debug.LogError("Tracking stat not found. Key: " + key);
}</pre></div></li><li class="listitem">The last static function for this script is <code class="literal">Clear</code>. It only empties the stats list, making it ready for fresh tracking.<div class="informalexample"><pre class="programlisting">public static void Clear() {
  stats = new TrackerStat[0];
}</pre></div></li><li class="listitem">The last step for the script is the <code class="literal">OnGUI</code> function. This function will let us see our statistics while the game is playing. In it we make heavy use of the <code class="literal">GUILayout</code> class and its functions. <code class="literal">GUILayout</code> automatically arranges the various GUI elements, allowing us to spend less time arranging and more time analyzing. We first use <code class="literal">BeginVertical</code> to start a vertical list of elements. <code class="literal">BeginHorizontal</code> is used to start a horizontal list of elements. The <code class="literal">Label</code> function is<a id="id735" class="indexterm"/> then used to create titles for each row of our statistics. We are using the <code class="literal">GUILayout.Width</code> function to give each label a specific width, making the layout look much nicer. Next, <code class="literal">EndHorizontal</code> is called to close the horizontal list. Every call to <code class="literal">BeginHorizontal</code> must be paired with an <code class="literal">EndHorizontal</code> else Unity will make many complaints.<div class="informalexample"><pre class="programlisting">public void OnGUI() {
  GUILayout.BeginVertical();

  GUILayout.BeginHorizontal();
  GUILayout.Label("Key", GUILayout.Width(150));
  GUILayout.Label("Average", GUILayout.Width(100));
  GUILayout.Label("Total", GUILayout.Width(50));
  GUILayout.Label("Longest", GUILayout.Width(100));
  GUILayout.EndHorizontal();</pre></div></li><li class="listitem">Next, we loop through our list of stats. For each, we create a horizontal list and use <code class="literal">Label</code> to draw each stat on the screen. The <code class="literal">ToString</code> function<a id="id736" class="indexterm"/> is used to convert the numbers to strings, needed by the labels.<div class="informalexample"><pre class="programlisting">  for(int i=0;i&lt;stats.Length;i++) {
    GUILayout.BeginHorizontal();

    GUILayout.Label(stats[i].key.ToString(), GUILayout.Width(150));
    GUILayout.Label(stats[i].averageTime.ToString(), GUILayout.Width(100));
    GUILayout.Label(stats[i].totalCalls.ToString(), GUILayout.Width(50));
    GUILayout.Label(stats[i].longestCall.ToString(), GUILayout.Width(100));

    GUILayout.EndHorizontal();
  }</pre></div></li><li class="listitem">The <code class="literal">OnGUI</code> function<a id="id737" class="indexterm"/> finishes by creating a button, that calls upon the <code class="literal">Clear</code> function when clicked. And finally, the <code class="literal">EndVertical</code> function<a id="id738" class="indexterm"/> is called to end the vertical list of elements. Every call to <code class="literal">BeginVertical</code> must be paired with a call to <code class="literal">EndVertical</code>, just as the horizontal lists.<div class="informalexample"><pre class="programlisting">  if(GUILayout.Button("Clear"))
    Clear();

  GUILayout.EndVertical();
}</pre></div></li><li class="listitem">To test these <a id="id739" class="indexterm"/>scripts, open up your <code class="literal">PlayerShip</code> script. To the beginning of the <code class="literal">Rotate</code> function, add the following line to start tracking how long it takes to run.<div class="informalexample"><pre class="programlisting">ScriptTracker.Open("PlayerShip_Rotate");</pre></div></li><li class="listitem">Towards the end of the <a id="id740" class="indexterm"/><code class="literal">Rotate</code> function, we need to call the <code class="literal">Close</code> function with the same key.<div class="informalexample"><pre class="programlisting">ScriptTracker.Close("PlayerShip_Rotate");</pre></div></li><li class="listitem">Finally, create an empty game object and add your <code class="literal">ScriptTracker</code> script to it. Start the game and take a look at the results.<div class="mediaobject"><img src="graphics/2014OT_09_01.jpg" alt="Time for action – tracking scripts"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec147"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We created a tool for testing specific parts of code. By wrapping any bit of code in calls to the functions and sending a unique ID, we can determine how long it takes to execute the code. By averaging out the calls to the script, and wrapping different parts of code, we can determine exactly which parts of a script are taking the longest to complete. We can also find out if the parts of code have been called too many times. Both cases are ideal points to start looking at for minimizing processing and lag.</p><p>Be sure to remove any references to this tool before you deploy your game. If left in the final levels, it can add an unnecessary amount of load on the CPU. This adverse effect on the game could make the game unplayable. Always remember to clear out any uses of tools that are exclusively for Editor debugging.</p></div></div>
<div class="section" title="Minimizing lag"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec128"/>Minimizing lag</h1></div></div></div><p>Lag is one of those nebulous ideas used to describe an application performing slower than expected. As developers, <a id="id741" class="indexterm"/>we constantly fight against providing the highest quality experience we can, while maintaining the speeds and responsiveness that <a id="id742" class="indexterm"/>users expect. It essentially amounts to whether or not the processor on the user's device can handle the cost of providing the game experience. A few, simple objects in your game will result in fast processing. Several complex objects will cost the most processing.</p></div>
<div class="section" title="Occlusion"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec129"/>Occlusion</h1></div></div></div><p>Occlusion is great for games with a lot of objects. In its basic form, anything off to the sides or behind the camera is not seen <a id="id743" class="indexterm"/>and therefore not drawn. In Unity Pro, we are able to set up occlusion culling. This will calculate what can actually be seen by the camera, not drawing anything that is blocked from view. There is a balance that has to be achieved when using these tools. The cost of calculating what can not be seen needs to be less than the cost of just drawing those objects anyway. As a rule of thumb, if you have many smaller objects that are regularly blocked from view by larger objects, occlusion culling is the right choice.</p></div>
<div class="section" title="Time for action &#x2013; occluding tanks"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec130"/>Time for action – occluding tanks</h1></div></div></div><p>We will add occlusion culling to the Tank Battle game, because it is the only one with anything large enough to block objects from view:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">So, open up the<a id="id744" class="indexterm"/> Tank Battle game now. If you completed the challenges and added the extra debris and obstacles, this section will be particularly effective for you.</li><li class="listitem">Open the Occlusion window by going to Unity's toolbar and navigate to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Occlusion Culling</strong></span>. This window is your primary point of access for modifying the various settings associated with occlusion in your game.</li><li class="listitem">Switch to the <span class="strong"><strong>Bake</strong></span> page and we can take a look at the options associated with occlusion culling.<div class="mediaobject"><img src="graphics/2014OT_09_13.jpg" alt="Time for action – occluding tanks"/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Technique</strong></span>: This<a id="id745" class="indexterm"/> setting will determine what method to use when setting up occlusion culling.<p>
<span class="strong"><strong>PVS Only</strong></span>: This setting will only calculate the static objects of your scene to have occlusion culling applied. This option is the least intensive for the processor but is only good if there are very few moving objects in the scene.</p><p>
<span class="strong"><strong>PVS and dynamic objects</strong></span>: This setting will precompute what objects can be seen by the camera. For dynamic objects, the system will create portals. They are used to cull objects that are on opposite sides of the portals from the camera.</p><p>
<span class="strong"><strong>Automatic Portal Generation</strong></span>: This setting will cull both static and dynamic objects based on portals. While giving the most accuracy, this option also has the highest cost for the processor.</p><p>
<span class="strong"><strong>View Cell Size</strong></span>: This setting sets how detailed the occlusion calculations are. Smaller values will result in better culling but will cause the file size to increase to store the extra information.</p><p>
<span class="strong"><strong>Near Clip Plane</strong></span> and <span class="strong"><strong>Far Clip Plane</strong></span>: These settings are used by the system to estimate what a camera can see at any point in space. They should be set to the smallest <span class="strong"><strong>Near Clip Plane</strong></span> and largest <span class="strong"><strong>Far Clip Plane</strong></span> of all the cameras in your game.</p><p>
<span class="strong"><strong>Memory Limit</strong></span>: This setting is used when either of the <span class="strong"><strong>PVS Techniques</strong></span> have been chosen. It helps guide how much detail can be put into the calculation.</p></li></ul></div></li><li class="listitem">Select <span class="strong"><strong>PVS and dynamic objects</strong></span> for <span class="strong"><strong>Technique</strong></span> and <code class="literal">5</code> for <span class="strong"><strong>View Cell Size</strong></span>.</li><li class="listitem">In order to make the occlusion system work with dynamic objects, we need to set up a number of occlusion areas. To create them, create an empty <span class="strong"><strong>GameObject</strong></span> and<a id="id746" class="indexterm"/> add an <span class="strong"><strong>Occlusion Area</strong></span> component, found in Unity's toolbar under <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Rendering</strong></span> | <span class="strong"><strong>Occlusion Area</strong></span>.</li><li class="listitem">They need to cover the area where any dynamic objects will be located. Create and position enough areas to cover the streets of our game. Their size can be edited just as when working with <span class="strong"><strong>Box Collider</strong></span> components. Be sure to make them tall enough to cover all of your targets.<div class="mediaobject"><img src="graphics/2014OT_09_15.jpg" alt="Time for action – occluding tanks"/></div></li><li class="listitem">Hit <span class="strong"><strong>Bake</strong></span> at the bottom of the <span class="strong"><strong>Occlusion</strong></span> window. A progress bar will appear at the bottom-right of the Unity Editor, telling you how much longer the calculations <a id="id747" class="indexterm"/>will take. This process usually takes a good amount of time, especially as your game becomes more and more complex.</li><li class="listitem">When the baking process has completed, the <span class="strong"><strong>Occlusion</strong></span> window should have switched to the <span class="strong"><strong>Visualization</strong></span> tab<a id="id748" class="indexterm"/> and the camera should be selected in your <span class="strong"><strong>Scene</strong></span> window. If not, select them now. In the <span class="strong"><strong>Scene</strong></span> view, Unity will give us a preview of how occlusion culling is working. Only those objects that can be seen will be visible while the rest are turned off.<div class="mediaobject"><img src="graphics/2014OT_09_14.jpg" alt="Time for action – occluding tanks"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec148"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We went through <a id="id749" class="indexterm"/>the basic process for setting up occlusion culling. We took a look at the <span class="strong"><strong>Occlusion</strong></span> window and learned about the settings available there. Occlusion culling is great for reducing the number of draw calls in a scene. However, that reduction needs to be balanced against the cost of storing and retrieving the occlusion calculations. This balance is achieved by selecting a proper <span class="strong"><strong>Technique</strong></span> and an appropriate <span class="strong"><strong>View Cell Size</strong></span>. Play around with the different values now, finding a cell size that gives the appropriate amount of detail without supplying too much information.</p></div><div class="section" title="Points to remember"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec149"/>Points to remember</h2></div></div></div><p>The following is a list of tips for dealing <a id="id750" class="indexterm"/>with and avoiding lag in your games. Not all of them will apply to every game you make, but they are good to keep in mind for every project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Avoid the transparent shaders, if possible, when creating your materials. They are a little more expensive to render. And, you can save yourself a world of headaches dealing with depth sorting, if you avoid them.</li><li class="listitem" style="list-style-type: disc">Use one material per object. The greater the number of draw calls in your game, the longer each frame will take to render. Every mesh is drawn once per material on it, even if the material doesn't appear to do anything. By keeping to one material per object, especially on mobile platforms, you minimize the number of draw calls and maximize your rendering speed.</li><li class="listitem" style="list-style-type: disc">Combine textures when possible. Not every texture you make will utilize the whole of the image. Whenever<a id="id751" class="indexterm"/> possible, combine the textures of objects that are in the same scene. This maximizes your efficient use of the images, while reducing the final build size and amount of memory needed to utilize those textures.</li><li class="listitem" style="list-style-type: disc">Group objects in your <span class="strong"><strong>Hierarchy</strong></span> using empty GameObjects. Though not specific to minimizing lag, it will make your project easier to work with. Especially with large and complex levels, you will be able to spend less time searching through the objects in your scene and more time making a great game.</li><li class="listitem" style="list-style-type: disc">The <a id="id752" class="indexterm"/><span class="strong"><strong>Console</strong></span> window is your friend. Before worrying about your game not working, first take a look at the <span class="strong"><strong>Console</strong></span> window or the bar at the bottom in Unity. Both will display any complaints that Unity might have about the way your game is currently set up. The messages here are great for pointing you in the right direction to fixing any problems. If you are ever unsure what the messages are trying to tell you, perform a Google search for the message and you should be able to easily find a solution from one of the many other Unity users. If your code ever appears to not be working and Unity isn't complaining about it, use the <a id="id753" class="indexterm"/><code class="literal">Debug.Log</code> function to print messages to the <span class="strong"><strong>Console</strong></span>. This will let you find places that your code might be exiting unexpectedly, or values that are not what they should be.</li><li class="listitem" style="list-style-type: disc">Device testing is important. Working in the Editor is great, but there is nothing quite like testing on the target device. You can get a much better feel for how your game is performing when it is on the device. The Editor always introduces a small amount of additional processing overhead. Also, the computer you are working on will always be more powerful than the mobile devices you might intend on deploying to.</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec131"/>Summary</h1></div></div></div><p>In this chapter, we learned about our options for optimization in Unity. We first took a look at the various settings, for the assets used in our games, used to keep their file size down while maintaining quality. Next, we learned about some settings that affect the overall game. After that, we explored options for tracking the performance of the game. We first looked at some tools provided by Unity for tracking that performance. Then, we created a tool of our own for tracking script performance in detail. We then took a look at some options for minimizing lag in our games, including utilizing occlusion culling. Now that we know about all of these tools and options, go through the games we created and optimize them. Make them the best they can be.</p><p>In this book we learned a whole lot. We started with learning about Unity, Android, and how to make them work together. Our journey continued with an exploration of Unity's GUI system and the creation of a Tic-tac-toe game. We then learned about the basic assets needed for any game, while starting the creation of a Tank Battle game. Our Tank Battle game then expanded with the addition of a few special camera effects and some lighting. We concluded the creation of the Tank Battle game by introducing some enemies and making them chase the player. The creation of our Space Fighter game taught us about the touch and tilt controls that we can utilize in our game. A short break from that game saw the creation of an Angry Birds clone while learning about physics and the possibilities of a 2D game in Unity. We then returned to the Space Fighter game to add some polish with the addition of sound and particle effects. Finally, our journey concluded by learning about optimizing our games. Thank you for reading this book. Enjoy your experiences with Unity and creating the awesome games you have always dreamed about.</p></div></body></html>