- en: Control Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Assigning result to an expression using the `if` keyword
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if` 关键字将结果分配给表达式
- en: Using range with the `when` expression
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `when` 表达式与范围
- en: Using `when` with custom objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `when` 与自定义对象
- en: Using `try`–`catch` as an expression
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `try`–`catch` 作为表达式使用
- en: How to write a swap function in Kotlin using the `also` function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `also` 函数在 Kotlin 中编写交换函数
- en: How to throw a custom exception in Kotlin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中抛出自定义异常
- en: How to make a multiconditional loop in Kotlin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中创建多条件循环
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Control flows are the basic building block of every programming language. What's
    different in Kotlin is that you can use a few of those control flows as an expression,
    such as `try`-`catch`, `if`-`else`, `when`, and so on. In this chapter, we will
    go through some of the control flows offered by Kotlin and learn to use them.
    Furthermore, we will also see how they provide much more power than Java control
    flows. So let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流是每种编程语言的基本构建块。在 Kotlin 中有什么不同之处在于，您可以使用其中的一些控制流作为表达式，例如 `try`–`catch`、`if`–`else`、`when`
    等。在本章中，我们将了解 Kotlin 提供的一些控制流，并学习如何使用它们。此外，我们还将了解它们如何比 Java 控制流提供更多的功能。所以，让我们开始吧！
- en: Assigning result to an expression using the if keyword
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `if` 关键字将结果分配给表达式
- en: In Kotlin `if` is special because it returns values. That is why we can use
    an `if` statement to assign values to a result. This removes the need for a ternary
    operator in Kotlin. Let's see how we can use `if` statements to assign value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`if` 是特殊的，因为它返回值。这就是为什么我们可以使用 `if` 语句来分配值。这消除了 Kotlin 中三元运算符的需要。让我们看看我们如何使用
    `if` 语句来分配值。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the command line for compiling
    and running my Kotlin code for this recipe.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此目的，为此您需要安装 Kotlin 编译器和 JDK。在这个菜谱中，我使用命令行来编译和运行我的
    Kotlin 代码。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a file and name it `ifWithKotlin.kt`. You can name it anything; it need
    not be the same as the class name because it is in Java. Now, to get started,
    you should always declare the main method because the Java virtual machine starts
    execution by invoking the `main` method of the specified class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件，并将其命名为 `ifWithKotlin.kt`。您可以将其命名为任何名称；它不必与类名相同，因为它是在 Java 中。现在，为了开始，您应该始终声明
    `main` 方法，因为 Java 虚拟机通过调用指定类的 `main` 方法来启动执行。
- en: 'The `main` method is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法如下：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s try a basic `if` statement in a traditional way to understand how it
    works:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个基本的 `if` 语句，以了解它是如何工作的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code block, we assign a value to `x` in the `if` and `else` block and
    then print it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们在 `if` 和 `else` 块中为 `x` 分配一个值，然后打印它。
- en: 'Now, let''s try the same thing the Kotlin way:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们以 Kotlin 的方式尝试同样的事情：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code block, we assigned a value returned by the `if`-`else` block to
    `x`. Note how we've used an `if` statement as a part of the expression on the
    right-hand side of the expression.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们将 `if`–`else` 块返回的值分配给 `x`。注意我们如何将 `if` 语句用作表达式右侧的表达式的一部分。
- en: 'Let''s see what else can we do. In the following example, we will try to return
    something from the expression using the `if` statement:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们还能做什么。在以下示例中，我们将尝试使用 `if` 语句从表达式中返回一些内容：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note how we used the whole block of `if`–`else`. In this case, the `if` block
    returns the last statement of the block.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用了整个 `if`–`else` 块。在这种情况下，`if` 块返回块中的最后一个语句。
- en: 'Finally, let''s try a more complicated example using a nested `if`–`else`.
    This will help us understand how values are returned in a nested `if`–`else` structure:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试一个更复杂的例子，使用嵌套的`if`–`else`。这将帮助我们理解在嵌套的`if`–`else`结构中值的返回方式：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, if we nest an `if`–`else` block and if the last statement of that `if`–`else`
    block is another `if`–`else` statement, the value returned by the nested `if`–`else`
    is returned by the enclosing one. As you can see, `96` is returned by the `else`
    block inside the `if(10<20)` block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们嵌套一个`if`–`else`块，并且该`if`–`else`块的最后一个语句又是另一个`if`–`else`语句，那么嵌套的`if`–`else`返回的值将由外层的`if`–`else`返回。正如你所看到的，`96`是由`if(10<20)`块内部的`else`块返回的。
- en: 'What happens if the `if`–`else` block is not the last statement, like in this
    example:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`if`–`else`块不是最后一个语句，会发生什么，就像这个例子一样：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Clearly, the value returned by the nested `if`–`else` is not being used, and
    the Kotlin compiler also warns us of this. The reason behind this is because the
    `if`–`else` block is not the last statement of the parent `if`–`else` block, which
    is why the returned value is not being used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，嵌套的`if-else`返回的值没有被使用，Kotlin编译器也警告了我们这一点。原因在于`if-else`块不是父`if-else`块的最后一个语句，这就是为什么返回的值没有被使用的原因。
- en: '![](img/e30f8a59-cc59-43fa-91a6-f70f33605f3b.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e30f8a59-cc59-43fa-91a6-f70f33605f3b.png)'
- en: Try playing around with the values and logic to see what else you can do with
    `if`-`else`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整值和逻辑，看看您还能用`if-else`做些什么。
- en: The key thing to always remember is that the last statement of the `if`-`else` block
    is returned, which is why it can be used to assign values to any variable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要记住的关键点是`if-else`块的最后一个语句会被返回，这就是为什么它可以用来给任何变量赋值的原因。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have used string templates in print statements. Note how we are able to
    access a variable using the `$` symbol before the name of a variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在打印语句中使用了字符串模板。注意我们是如何在变量名前使用`$`符号来访问变量的：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also put a piece of code in strings that are evaluated and whose results
    are concatenated into the string. In this case, `$` is followed by `{}`, inside
    which we put our code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在要评估并其结果连接到字符串的字符串中放入一段代码。在这种情况下，`$`后面跟着`{}`，我们在其中放入我们的代码：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using range with the when expression
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`when`表达式与范围
- en: In Kotlin, `when` is like a super-powered switch control statement. However,
    that's not all it can do. There's a lot of amazing logic that you can build with
    the `when` statement, one example of which is using a range with the `when` statement.
    We will take a look at that in this recipe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，`when`就像一个超级强大的`switch`控制语句。然而，这还不是它的全部。您可以用`when`语句构建很多令人惊叹的逻辑，其中一个例子就是使用范围与`when`语句。我们将在本菜谱中查看这一点。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the command line to compile
    and run my Kotlin code for this recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。您也可以使用命令行来完成此目的，为此您需要安装Kotlin编译器和JDK。我在这个菜谱中使用命令行来编译和运行我的Kotlin代码。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s create a file, name it `whenWithRanges.kt`, and follow these
    steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个文件，命名为`whenWithRanges.kt`，并按照以下步骤操作：
- en: 'Let''s try a basic `when` statement to understand how it works:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个基本的`when`语句来了解它是如何工作的：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So basically, this code block works like a `switch` case statement, and it can
    also be implemented using an `if` statement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，这个代码块的工作方式就像一个`switch`语句，它也可以使用`if`语句来实现。
- en: 'Now, let''s see if `x` lies between `1` to `10` or outside it:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看`x`是否位于`1`到`10`之间或之外：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s see what else we can do. In the following example, we will work with
    different types of conditions that can be used inside a `when` statement:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们还能做什么。在下面的例子中，我们将处理可以在`when`语句内部使用的不同类型的条件：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, let''s try a more complicated example of using data classes. In this
    example, we will see how to use `when` with objects:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试一个更复杂的使用数据类的例子。在这个例子中，我们将看到如何使用对象与`when`结合：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s how it looks after compiling and running the program:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译和运行程序后的样子：
- en: '![](img/9bd2ee53-162e-4ccb-9820-076c503674c1.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bd2ee53-162e-4ccb-9820-076c503674c1.png)'
- en: Try playing around with the values and logic to see what else you can do with
    such a small block of code in Kotlin using `when`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整值和逻辑，看看您还能用Kotlin中这样一小段代码的`when`做些什么。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the preceding examples, the first example is the most basic `when` statement;
    we are directly comparing *x*’s value to `12` and `4`, and if no conditions match,
    we are simply executing the `else` statement. It is like an `if else if else`
    statement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一个例子是最基本的`when`语句；我们直接比较*x*的值与`12`和`4`，如果没有条件匹配，我们只是简单地执行`else`语句。这就像一个`if
    else if else`语句。
- en: 'In the second example, we check whether `x` lies between `1` to `10` in the
    first statement inside the `when` block, and in the second statement, we check
    whether `x` does not lie between `1` to `10`. That''s how we work with ranges
    in `when`. Basically, in `when`, we can check whether `x` lies in a range or exists
    in a collection using the `in` keyword. The syntax is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们在 `when` 块的第一个语句中检查 `x` 是否位于 `1` 到 `10` 之间，在第二个语句中，我们检查 `x` 是否不位于
    `1` 到 `10` 之间。这就是我们在 `when` 中处理范围的方式。基本上，在 `when` 中，我们可以使用 `in` 关键字检查 `x` 是否位于一个范围内或存在于一个集合中。语法如下：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the third example, we use a function to check whether `x` equals the value
    of the expression `magicNum(x)`. So we can also use expressions and functions
    in place of constants and ranges to compare `x`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，我们使用一个函数来检查 `x` 是否等于表达式 `magicNum(x)` 的值。因此，我们也可以使用表达式和函数来代替常量和范围来比较
    `x`。
- en: In the fourth example, we explore the power of the `when` statement using a
    data class instead of a primitive data type in `when`. Note how we are able to
    access all properties of `x` inside `when` and also play with them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个例子中，我们使用数据类而不是原始数据类型来探索 `when` 语句的强大功能。注意我们如何在 `when` 内部访问 `x` 的所有属性，并且还可以与之交互。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'We have already seen how we can use string templates with expressions in print
    statements. Remember how we were able to access a variable using the `$` symbol
    before the name of a variable:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在打印语句中使用带有表达式的字符串模板。记得我们是如何能够使用变量名前的 `$` 符号来访问变量的，对吧：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also put a piece of code in a string, which is then evaluated and whose
    results are concatenated into the string. In this case, `$` is followed by `{}`,
    inside which we put our code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一段代码放入一个字符串中，然后该字符串将被评估，其结果将连接到字符串中。在这种情况下，`$` 后面跟着 `{}`，我们在其中放入我们的代码：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using when with custom objects
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `when` 与自定义对象
- en: In Kotlin, `when` is already so powerful but did you know you can also use custom
    objects in `when`? Amazing, right? Let's go about implementing it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`when` 已经非常强大了，但你是否知道你还可以在 `when` 中使用自定义对象？太棒了，对吧？让我们来实施它。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the command line to compile
    and run my Kotlin code for this recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此目的，为此您需要安装 Kotlin 编译器和 JDK。我正在使用命令行来编译和运行我的
    Kotlin 代码来完成这个菜谱。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a file and name it `whenWithObject.kt`, and then, let''s try `when`
    with a custom object. In this example, we will create an object with some properties
    and try to match it in a `when` statement:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件，并将其命名为 `whenWithObject.kt`，然后，让我们尝试使用自定义对象来使用 `when`。在这个例子中，我们将创建一个具有一些属性的对象，并尝试在
    `when` 语句中匹配它：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s the output of the preceding code block:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码块的结果：
- en: '![](img/5c8046e6-07d1-47fa-a149-5e9fcf36b34f.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c8046e6-07d1-47fa-a149-5e9fcf36b34f.png)'
- en: 'If you try to compare a different object type in `when`, it throws an error
    `error: incompatible types` because we are trying to compare objects of different
    types.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您尝试在 `when` 中比较不同的对象类型，它将抛出一个错误 `error: incompatible types`，因为我们正在尝试比较不同类型的对象。'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Kotlin, `when` basically works with equality in the background, so we can
    compare objects as long as their types are the same.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`when` 在后台基本上是通过相等性来工作的，因此只要它们的类型相同，我们就可以比较对象。
- en: Using try–catch as an expression
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 try–catch 作为表达式
- en: Exceptions in Kotlin are both similar and different compared to those in Java.
    In Kotlin, `Throwable` is the superclass of all the exceptions, and every exception
    has a stack trace, message, and an optional cause.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 相比，Kotlin 中的异常既有相似之处也有不同之处。在 Kotlin 中，`Throwable` 是所有异常的超类，每个异常都有一个堆栈跟踪、消息和一个可选的原因。
- en: 'The structure of `try`–`catch` is also similar to that used in Java. In Kotlin,
    here''s how a `try`–`catch` statement looks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`–`catch` 的结构也与 Java 中使用的结构相似。在 Kotlin 中，这是一个 `try`–`catch` 语句的外观：'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At least one `catch` block is mandatory and the `finally` block is optional,
    and so it can be omitted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 至少需要一个 `catch` 块，而 `finally` 块是可选的，因此可以省略。
- en: In Kotlin, `try`–`catch` is special as it enables it to be used as an expression.
    In this article, we will see how we can use `try`–`catch` as an expression.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`try`–`catch` 是特殊的，因为它允许它作为一个表达式使用。在这篇文章中，我们将看到我们如何使用 `try`–`catch`
    作为表达式。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装一个首选的开发环境，用于编译和运行Kotlin。你也可以使用命令行来完成这个任务，你需要安装Kotlin编译器和JDK。我使用IntelliJ
    IDE来编译和运行我的Kotlin代码来完成这个菜谱。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write a simple program that takes in a number as an input and assigns
    its value to a variable. If the entered value is not a number, we catch the `NumberFormatException`
    exception and assign `-1` to that variable:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序，它接受一个数字作为输入并将其值赋给一个变量。如果输入的值不是一个数字，我们捕获`NumberFormatException`异常并将`-1`赋给该变量：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is the output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s try something crazy and deliberately try to throw the exception:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些疯狂的事情，故意尝试抛出异常：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The usage of `try`–`catch` will help you a lot in edge cases as they can be
    used as an expression.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`try`–`catch`在边缘情况下会非常有帮助，因为它们可以用作表达式。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The reason we can use `try`–`catch` as an expression is that both `try` and
    `throw` are expressions in Kotlin and hence can be assigned to a variable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`try`–`catch`作为表达式的原因是，在Kotlin中`try`和`throw`都是表达式，因此可以被赋值给变量。
- en: When you use `try`–`catch` as an expression, the last line of the `try` or `catch`
    block is returned. That's why, in the first example, we got `23` as the returned
    value and we got `-1` in the second example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`try`–`catch`作为表达式时，`try`或`catch`块的最后一行会被返回。这就是为什么在第一个例子中我们得到了返回值`23`，而在第二个例子中我们得到了`-1`。
- en: 'Here, one thing to note is that the same thing doesn''t apply to the `finally`
    block—that is, writing the `finally` block will not affect the result:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，需要注意的是，同样的情况并不适用于`finally`块——也就是说，编写`finally`块不会影响结果：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, writing the `finally` block doesn't change anything.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编写`finally`块并不会改变任何东西。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In Kotlin, all the exceptions are unchecked, which means that we don't need
    to apply `try`–`catch` at all. This is quite different than Java, where if a method
    throws an exception, we need to surround it with `try`–`catch`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，所有的异常都是未检查的，这意味着我们根本不需要使用`try`–`catch`。这与Java非常不同，在Java中，如果一个方法抛出异常，我们需要用`try`–`catch`包围它。
- en: 'Here''s an example of an IO operation in Kotlin:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个Kotlin中的IO操作的示例：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we don't need to wrap things with `try`–`catch` if we don't
    want to. In Java, we couldn't proceed without handling this exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果我们不想使用`try`–`catch`，我们不需要这样做。在Java中，如果我们不处理这个异常，我们无法继续进行。
- en: How to write a swap function in Kotlin using the also function
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在Kotlin中使用`also`函数编写交换函数
- en: 'Swapping two numbers is one of the most common things you do in programming.
    Most of the approaches are quite similar in nature: Either you do it using a third
    variable or using pointers.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 交换两个数字是你在编程中做的最常见的事情之一。大多数方法在本质上都很相似：要么你使用一个第三方变量，要么使用指针。
- en: In Java, we don't have pointers, so mostly we rely on a third variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们没有指针，所以我们主要依赖于第三方变量。
- en: 'You can obviously use something as mentioned here, which is just the Kotlin
    version of Java code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以使用这里提到的方法，这只是Java代码的Kotlin版本：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, in Kotlin, there is a very quick and intuitive way of doing it. Let's
    see how!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Kotlin中，有一个非常快速且直观的方式来完成它。让我们看看如何做！
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装一个首选的开发环境，用于编译和运行Kotlin。你也可以使用命令行来完成这个任务，你需要安装Kotlin编译器和JDK。我使用IntelliJ
    IDE来编译和运行我的Kotlin代码来完成这个菜谱。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In Kotlin, we have a special function, `also`, that we can use to swap two
    numbers. Here''s the code to go with it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们有一个特殊的功能，`also`，我们可以用它来交换两个数字。以下是相应的代码：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We were able to achieve the same thing without using any third variable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在不使用任何第三方变量的情况下实现相同的功能。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To understand the preceding example, we need to understand the `also` function
    in Kotlin. The `also` function takes the receiver, performs some operation, and
    returns the receiver. In simple words, it passes an object and returns the same
    object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解前面的示例，我们需要了解 Kotlin 中的 `also` 函数。`also` 函数接受接收者，执行一些操作，并返回接收者。简单来说，它传递一个对象并返回相同的对象。
- en: Applying the `also` function on an object is like saying "do this as well" to
    that object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象上应用 `also` 函数就像对那个对象说“也这样做”一样。
- en: 'So, we called the `also` function on `b`, did an operation (assigning the value
    of `a` to `b`), and then returned the same receiver that we got as an argument:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 `b` 上调用了 `also` 函数，执行了一个操作（将 `a` 的值赋给 `b`），然后返回了作为参数得到的相同接收者：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `apply` function is quite similar to the `also` function, but they have
    a subtle difference. To understand that, let''s look at their implementation first:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 函数与 `also` 函数非常相似，但它们之间有一个细微的差别。为了理解这一点，让我们首先看看它们的实现：'
- en: 'The `also` function:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`also` 函数：'
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `apply` function:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply` 函数：'
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In `also`, the block is defined as `(T) -> Unit`, but it is defined as `T.()
    -> Unit` in `apply()`, which means there is an implicit `this` inside the `apply`
    block. However, to reference it in `also`, we need `it`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `also` 中，块被定义为 `(T) -> Unit`，但在 `apply()` 中被定义为 `T.() -> Unit`，这意味着在 `apply`
    块内部有一个隐式的 `this`。然而，要在 `also` 中引用它，我们需要 `it`。
- en: 'So a code using `also` will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，使用 `also` 的代码将看起来像这样：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same will look like this using `apply`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `apply` 的代码将看起来像这样：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The age of the resulting object will be the same in both the cases, that is,
    `13`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，结果对象的时代将相同，即 `13`。
- en: How to throw a custom exception in Kotlin
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中抛出自定义异常
- en: Sometimes, there are cases where you want to create your own exception. If you
    are creating your own exception, it's known as a **custom exception** or **user-defined
    exception**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能想创建自己的异常。如果您创建自己的异常，它被称为**自定义异常**或**用户定义异常**。
- en: These are used to customize the exception according to a specific need, and
    using this, you can have your own exception and a message. In this recipe, we
    will see how to create and throw a custom exception in Kotlin.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于根据特定需求定制异常，使用这些，您可以拥有自己的异常和消息。在这个菜谱中，我们将看到如何在 Kotlin 中创建和抛出自定义异常。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此目的，为此您需要安装 Kotlin 编译器和 JDK。我使用
    IntelliJ IDE 来编译和运行我的 Kotlin 代码，以完成这个菜谱。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: All the exceptions have `Exception` as their superclass, so we need to extend
    that class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的异常都有 `Exception` 作为它们的超类，因此我们需要扩展那个类。
- en: 'Here''s what our custom exception looks like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的自定义异常的样子：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since the `Exception` superclass has a constructor that can take in a message,
    we've passed it with the help of the constructor of `CustomException`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Exception` 超类有一个可以接受消息的构造函数，我们通过 `CustomException` 的构造函数的帮助传递了它。
- en: 'Now, if you have to `throw` an `Exception`, you will need to simply do the
    following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您必须 `throw` 一个 `Exception`，您只需做以下操作：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output will be something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：
- en: '![](img/62b86b27-1b50-4d23-8212-f9042fa9dae1.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62b86b27-1b50-4d23-8212-f9042fa9dae1.png)'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a look at the implementation of the `Exception` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Exception` 类的实现：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we have a second constructor that takes a `String` as a parameter.
    In our `CustomException` class, we have supplied it by passing its message to
    the superclass's constructor. Also, you can create a custom exception with an
    empty constructor because `Exception` also has an empty constructor.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个接受 `String` 参数的第二个构造函数。在我们的 `CustomException` 类中，我们通过将其消息传递给超类构造函数来提供它。此外，您还可以使用空构造函数创建自定义异常，因为
    `Exception` 也有空构造函数。
- en: How to make a multiconditional loop in Kotlin
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中创建多条件循环
- en: 'Conditional loops are common to any programming language you pick. If you apply
    multiple conditions on a loop, it is called a **multiconditional loop**. A simple
    example of a multiconditional loop in Java is illustrated here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 条件循环是任何编程语言都有的常见特性。如果你在循环中应用多个条件，那么它被称为**多条件循环**。这里以 Java 为例，展示了多条件循环的一个简单示例：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code on execution will print out `5`, `6`, and `7`. Let's see
    how we can use a multiconditional loop in Kotlin. We will be looking at a functional
    approach to the same thing in Kotlin.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行之前，前面的代码将打印出`5`、`6`和`7`。让我们看看如何在Kotlin中使用多条件循环。我们将探讨Kotlin中相同问题的函数式方法。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。您也可以使用命令行来完成此目的，为此您需要安装Kotlin编译器和JDK。我使用IntelliJ
    IDE来编译和运行我的Kotlin代码，以完成此菜谱。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The preceding multiconditional loop can be written in Kotlin like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述多条件循环可以用Kotlin这样写：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It's nice, clean, and definitely not an eyesore.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它很整洁，干净，绝对不是一种视觉上的负担。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We used `takeWhile`, which returns a sequence containing first elements satisfying
    the given predicate (in this case, `i<data[i]`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`takeWhile`，它返回一个包含满足给定谓词的第一个元素的序列（在这种情况下，`i<data[i]`）。
- en: Though `takeWhile` returns the first elements that satisfy the given predicate,
    you might be tempted to think that it will first evaluate the complete range and
    then pass to `forEach`. That would have been the case if we hadn't used `.asSequence()`.
    We converted the range to a `Sequence<T>`, and because of this, it was lazily
    evaluated. In short, it won't process the whole set of items with `.takeWhile
    { ... }` and will only check them one by one when `.forEach { ... }` is up to
    process the next item.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`takeWhile`返回满足给定谓词的第一个元素，但您可能会想它将首先评估整个范围，然后传递给`forEach`。如果不是我们使用了`.asSequence()`，这种情况就会发生。我们将范围转换为`Sequence<T>`，因此它是惰性评估的。简而言之，它不会使用`.takeWhile
    { ... }`处理整个集合，而是在`.forEach { ... }`准备处理下一个项目时逐个检查它们。
- en: Let's try to understand this with the help of an example. First, we will work
    with an eager evaluation over `Iterable<T>`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来尝试理解这一点。首先，我们将对`Iterable<T>`进行贪婪评估。
- en: 'This is the eager version, which evaluates the first function before moving
    on to the next one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是贪婪版本，它会在移动到下一个函数之前先评估第一个函数：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, the range was first processed with `takeWhile` (which returned
    0, 1, 2) and was then sent for processing to `forEach`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，范围首先通过`takeWhile`（返回0, 1, 2）进行处理，然后发送到`forEach`进行处理。
- en: 'Now, let''s see the lazy version:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看惰性版本：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here''s the output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see in the preceding example, `takeWhile` is evaluated only when
    `forEach` is used to processes an item. This is the nature of `Sequence<T>`, which
    performs lazily where possible.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的示例中所见，`takeWhile`仅在`forEach`用于处理项目时才会被评估。这是`Sequence<T>`的本质，它在可能的情况下执行惰性操作。
