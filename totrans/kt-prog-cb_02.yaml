- en: Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning result to an expression using the `if` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using range with the `when` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `when` with custom objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `try`–`catch` as an expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a swap function in Kotlin using the `also` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to throw a custom exception in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make a multiconditional loop in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control flows are the basic building block of every programming language. What's
    different in Kotlin is that you can use a few of those control flows as an expression,
    such as `try`-`catch`, `if`-`else`, `when`, and so on. In this chapter, we will
    go through some of the control flows offered by Kotlin and learn to use them.
    Furthermore, we will also see how they provide much more power than Java control
    flows. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Assigning result to an expression using the if keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin `if` is special because it returns values. That is why we can use
    an `if` statement to assign values to a result. This removes the need for a ternary
    operator in Kotlin. Let's see how we can use `if` statements to assign value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the command line for compiling
    and running my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a file and name it `ifWithKotlin.kt`. You can name it anything; it need
    not be the same as the class name because it is in Java. Now, to get started,
    you should always declare the main method because the Java virtual machine starts
    execution by invoking the `main` method of the specified class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try a basic `if` statement in a traditional way to understand how it
    works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we assign a value to `x` in the `if` and `else` block and
    then print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try the same thing the Kotlin way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we assigned a value returned by the `if`-`else` block to
    `x`. Note how we've used an `if` statement as a part of the expression on the
    right-hand side of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what else can we do. In the following example, we will try to return
    something from the expression using the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note how we used the whole block of `if`–`else`. In this case, the `if` block
    returns the last statement of the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s try a more complicated example using a nested `if`–`else`.
    This will help us understand how values are returned in a nested `if`–`else` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, if we nest an `if`–`else` block and if the last statement of that `if`–`else`
    block is another `if`–`else` statement, the value returned by the nested `if`–`else`
    is returned by the enclosing one. As you can see, `96` is returned by the `else`
    block inside the `if(10<20)` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if the `if`–`else` block is not the last statement, like in this
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the value returned by the nested `if`–`else` is not being used, and
    the Kotlin compiler also warns us of this. The reason behind this is because the
    `if`–`else` block is not the last statement of the parent `if`–`else` block, which
    is why the returned value is not being used.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e30f8a59-cc59-43fa-91a6-f70f33605f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Try playing around with the values and logic to see what else you can do with
    `if`-`else`.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing to always remember is that the last statement of the `if`-`else` block
    is returned, which is why it can be used to assign values to any variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used string templates in print statements. Note how we are able to
    access a variable using the `$` symbol before the name of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also put a piece of code in strings that are evaluated and whose results
    are concatenated into the string. In this case, `$` is followed by `{}`, inside
    which we put our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using range with the when expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, `when` is like a super-powered switch control statement. However,
    that's not all it can do. There's a lot of amazing logic that you can build with
    the `when` statement, one example of which is using a range with the `when` statement.
    We will take a look at that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the command line to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a file, name it `whenWithRanges.kt`, and follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a basic `when` statement to understand how it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So basically, this code block works like a `switch` case statement, and it can
    also be implemented using an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see if `x` lies between `1` to `10` or outside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what else we can do. In the following example, we will work with
    different types of conditions that can be used inside a `when` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s try a more complicated example of using data classes. In this
    example, we will see how to use `when` with objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it looks after compiling and running the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bd2ee53-162e-4ccb-9820-076c503674c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Try playing around with the values and logic to see what else you can do with
    such a small block of code in Kotlin using `when`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, the first example is the most basic `when` statement;
    we are directly comparing *x*’s value to `12` and `4`, and if no conditions match,
    we are simply executing the `else` statement. It is like an `if else if else`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example, we check whether `x` lies between `1` to `10` in the
    first statement inside the `when` block, and in the second statement, we check
    whether `x` does not lie between `1` to `10`. That''s how we work with ranges
    in `when`. Basically, in `when`, we can check whether `x` lies in a range or exists
    in a collection using the `in` keyword. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the third example, we use a function to check whether `x` equals the value
    of the expression `magicNum(x)`. So we can also use expressions and functions
    in place of constants and ranges to compare `x`.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth example, we explore the power of the `when` statement using a
    data class instead of a primitive data type in `when`. Note how we are able to
    access all properties of `x` inside `when` and also play with them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen how we can use string templates with expressions in print
    statements. Remember how we were able to access a variable using the `$` symbol
    before the name of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also put a piece of code in a string, which is then evaluated and whose
    results are concatenated into the string. In this case, `$` is followed by `{}`,
    inside which we put our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using when with custom objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, `when` is already so powerful but did you know you can also use custom
    objects in `when`? Amazing, right? Let's go about implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using the command line to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file and name it `whenWithObject.kt`, and then, let''s try `when`
    with a custom object. In this example, we will create an object with some properties
    and try to match it in a `when` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c8046e6-07d1-47fa-a149-5e9fcf36b34f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you try to compare a different object type in `when`, it throws an error
    `error: incompatible types` because we are trying to compare objects of different
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, `when` basically works with equality in the background, so we can
    compare objects as long as their types are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using try–catch as an expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions in Kotlin are both similar and different compared to those in Java.
    In Kotlin, `Throwable` is the superclass of all the exceptions, and every exception
    has a stack trace, message, and an optional cause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of `try`–`catch` is also similar to that used in Java. In Kotlin,
    here''s how a `try`–`catch` statement looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At least one `catch` block is mandatory and the `finally` block is optional,
    and so it can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, `try`–`catch` is special as it enables it to be used as an expression.
    In this article, we will see how we can use `try`–`catch` as an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple program that takes in a number as an input and assigns
    its value to a variable. If the entered value is not a number, we catch the `NumberFormatException`
    exception and assign `-1` to that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try something crazy and deliberately try to throw the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The usage of `try`–`catch` will help you a lot in edge cases as they can be
    used as an expression.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason we can use `try`–`catch` as an expression is that both `try` and
    `throw` are expressions in Kotlin and hence can be assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `try`–`catch` as an expression, the last line of the `try` or `catch`
    block is returned. That's why, in the first example, we got `23` as the returned
    value and we got `-1` in the second example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, one thing to note is that the same thing doesn''t apply to the `finally`
    block—that is, writing the `finally` block will not affect the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, writing the `finally` block doesn't change anything.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, all the exceptions are unchecked, which means that we don't need
    to apply `try`–`catch` at all. This is quite different than Java, where if a method
    throws an exception, we need to surround it with `try`–`catch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of an IO operation in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we don't need to wrap things with `try`–`catch` if we don't
    want to. In Java, we couldn't proceed without handling this exception.
  prefs: []
  type: TYPE_NORMAL
- en: How to write a swap function in Kotlin using the also function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swapping two numbers is one of the most common things you do in programming.
    Most of the approaches are quite similar in nature: Either you do it using a third
    variable or using pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we don't have pointers, so mostly we rely on a third variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obviously use something as mentioned here, which is just the Kotlin
    version of Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, in Kotlin, there is a very quick and intuitive way of doing it. Let's
    see how!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, we have a special function, `also`, that we can use to swap two
    numbers. Here''s the code to go with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We were able to achieve the same thing without using any third variable.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the preceding example, we need to understand the `also` function
    in Kotlin. The `also` function takes the receiver, performs some operation, and
    returns the receiver. In simple words, it passes an object and returns the same
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the `also` function on an object is like saying "do this as well" to
    that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we called the `also` function on `b`, did an operation (assigning the value
    of `a` to `b`), and then returned the same receiver that we got as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `apply` function is quite similar to the `also` function, but they have
    a subtle difference. To understand that, let''s look at their implementation first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `also` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In `also`, the block is defined as `(T) -> Unit`, but it is defined as `T.()
    -> Unit` in `apply()`, which means there is an implicit `this` inside the `apply`
    block. However, to reference it in `also`, we need `it`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So a code using `also` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The same will look like this using `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The age of the resulting object will be the same in both the cases, that is,
    `13`.
  prefs: []
  type: TYPE_NORMAL
- en: How to throw a custom exception in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, there are cases where you want to create your own exception. If you
    are creating your own exception, it's known as a **custom exception** or **user-defined
    exception**.
  prefs: []
  type: TYPE_NORMAL
- en: These are used to customize the exception according to a specific need, and
    using this, you can have your own exception and a message. In this recipe, we
    will see how to create and throw a custom exception in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the exceptions have `Exception` as their superclass, so we need to extend
    that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our custom exception looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Exception` superclass has a constructor that can take in a message,
    we've passed it with the help of the constructor of `CustomException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you have to `throw` an `Exception`, you will need to simply do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62b86b27-1b50-4d23-8212-f9042fa9dae1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of the `Exception` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a second constructor that takes a `String` as a parameter.
    In our `CustomException` class, we have supplied it by passing its message to
    the superclass's constructor. Also, you can create a custom exception with an
    empty constructor because `Exception` also has an empty constructor.
  prefs: []
  type: TYPE_NORMAL
- en: How to make a multiconditional loop in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional loops are common to any programming language you pick. If you apply
    multiple conditions on a loop, it is called a **multiconditional loop**. A simple
    example of a multiconditional loop in Java is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code on execution will print out `5`, `6`, and `7`. Let's see
    how we can use a multiconditional loop in Kotlin. We will be looking at a functional
    approach to the same thing in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding multiconditional loop can be written in Kotlin like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It's nice, clean, and definitely not an eyesore.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used `takeWhile`, which returns a sequence containing first elements satisfying
    the given predicate (in this case, `i<data[i]`).
  prefs: []
  type: TYPE_NORMAL
- en: Though `takeWhile` returns the first elements that satisfy the given predicate,
    you might be tempted to think that it will first evaluate the complete range and
    then pass to `forEach`. That would have been the case if we hadn't used `.asSequence()`.
    We converted the range to a `Sequence<T>`, and because of this, it was lazily
    evaluated. In short, it won't process the whole set of items with `.takeWhile
    { ... }` and will only check them one by one when `.forEach { ... }` is up to
    process the next item.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand this with the help of an example. First, we will work
    with an eager evaluation over `Iterable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the eager version, which evaluates the first function before moving
    on to the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the range was first processed with `takeWhile` (which returned
    0, 1, 2) and was then sent for processing to `forEach`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the lazy version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, `takeWhile` is evaluated only when
    `forEach` is used to processes an item. This is the nature of `Sequence<T>`, which
    performs lazily where possible.
  prefs: []
  type: TYPE_NORMAL
