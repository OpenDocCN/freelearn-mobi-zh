- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drilling into App Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed an important topic – design patterns. We said
    that design patterns are repeatable solutions that solve common problems. We can
    also say that design patterns are the building blocks of our code. Before looking
    at design patterns in this book, we went over Swift, then built upon it with the
    design patterns. Now we are at the top level – the app architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '**App architecture** is a critical topic in interviews, not just in the architecture
    design interview. Architecture discussions can happen *earlier*, even in the first
    stage. For example, the interviewer can ask about our previous projects and how
    we built them. Understanding the basic terminology and having the skills to use
    them in our interview is essential.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But don’t worry because in this chapter, we will go over the most fundamental
    principles of mobile architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go over the **Separation of Concerns** (**SoC**) principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover some *great tips* for separation in our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll learn how to *break our app into layers* and how data flows between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll talk about the *design interview*, how to approach it, and how to communicate
    with the interviewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve almost reached the end of the book, and as you’ll have learned by now,
    I like to start with the basics, as it helps me to explain complex topics much
    better. The basics of app architecture is the SoC principle.
  prefs: []
  type: TYPE_NORMAL
- en: All about the Separation of Concerns principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have mentioned the **SoC principle** in the book several times. In fact, I
    mentioned this principle many times in my previous books and articles as well.
    In a way, the SoC principle sits at the heart of many design patterns and architectural
    decisions, and for a pretty good reason. Before we dive into understanding why,
    let’s try to understand what SoC means.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Separation of Concerns principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin with defining what SoC is. SoC refers to organizing code to separate
    different functionalities into different objects and owners. It means that a class
    or a module must have one and only one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In our code example, we can see that the `processUserData` function has three
    different responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Validate* the user data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Save* the user data to a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Send* a welcome email to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the problem starts earlier – the name `processUserData` indicates
    that the function has an unclear responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the function into three different functions – `validateUserData`,
    `saveUserDataToFile`, and `sendWelcomeEmail` – would be an excellent solution
    to fix the problem of unclearness.
  prefs: []
  type: TYPE_NORMAL
- en: The SoC principle applies to functions and variables – a variable should have
    its own responsibility, just like functions and classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `name` to store both first and last names instead of
    creating two dedicated variables – `firstName` and `lastName`. These bad practices
    often happen when trying to save time, but they are error-prone and can lead to
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the SoC principle is a relevant factor in all levels of development,
    from variables, functions, and classes up to modules.
  prefs: []
  type: TYPE_NORMAL
- en: But…why is it so important? Let’s see.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the importance of SoC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know what the SoC principle is, it is time to understand why it
    is important when designing and writing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few reasons why we want to have a single responsibility for every
    part of our app and every variable. Let’s name some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Making our code more explicit*: When each part focuses on a single task, it
    is easier for us (and others) to understand what’s happening. Clarity is also
    critical with debugging and code investigation – here’s a quote from Brian Kernighan:
    “*Debugging is twice as hard as writing the code in the first place. Therefore
    if you write the code as cleverly as possible, you are, by definition, not smart
    enough to debug it*.” The only way to reduce the gap between writing and debugging
    is clarity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Maintaining the code becomes easier*: We all know writing code is easier than
    maintaining it. One of the reasons is that every code modification we perform
    can create a new bug. Moreover, modifications often change the code structure
    to something we hadn’t planned when writing it. We are reducing both risks when
    isolating tasks to specific functions or classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Increase our code reusability*: This is another important benefit of the SoC
    principle. When a view, a controller, or a module has a specific task and responsibility,
    it makes it easier to reuse. Let’s take, for instance, a library that handles
    text manipulation. Adding more features and capabilities to that library may increase
    its dependencies and side effects. It also makes it bigger and more error-prone
    since it now handles more responsibilities irrelevant to what we need and may
    collide with another library we want to link. Separating part of the library from
    another is smarter and allows us to work with different libraries like LEGO pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Improve our code testability*: One of the critical aspects of testing is ensuring
    that the outcomes are predictable. When a method is responsible for multiple tasks,
    it might reduce its predictability over time. Think of a function that returns
    a computed value and updates user defaults. Testing the function’s returned value
    can have side effects we don’t want in our test use case. It is better to separate
    that calculation into another function and test it separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These benefits are the foundation of any design pattern or architectural decision
    we make when working on our projects. Moreover, SoC is an essential principle
    to follow when approaching an architectural task in an interview. It is the basis
    for any professional discussion we may have during our interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s dive a bit deeper and look at some practical tips for the SoC principle.
  prefs: []
  type: TYPE_NORMAL
- en: Going practical with the Separation of Concerns principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter aims to prepare us for the architectural interview, which may contain
    whiteboard tasks and professional discussions. We understand the SoC principle’s
    importance, but how do we transform it into practical tools?
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that we reviewed these tools in previous chapters. Let’s list
    them now and add some more.
  prefs: []
  type: TYPE_NORMAL
- en: Having a clear understanding of using UI design patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I do not doubt that the topic of MVVM or MVC will be central in your interviews.
    What’s important here is to really understand the different components and their
    responsibility. If we decide to use MVVM for our screen, we must ensure that we
    do it because we need to manage a complex state and not because “this is how things
    are done today.” We must ensure we use the right tool for the right job and that
    each component performs its role.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help understand this, look at *Figure 12**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The most popular UI design patterns in iOS](img/Figure_12.01_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – The most popular UI design patterns in iOS
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 12**.1*, we can see that our selection of design patterns is broader
    than just MVC and MVVM. Furthermore, there are no rules here, just best practices.
    Choosing the correct design pattern while considering the different responsibilities
    and separations is essential to implementing the SoC principle.
  prefs: []
  type: TYPE_NORMAL
- en: For example, VIPER can be incredible for screens that work with many services
    and data entities, and MVP is suitable for a UI that focuses on formatting and
    presentation tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: VIPER and MVP?
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go over VIPER and MVP because they are less common design patterns in
    iOS development than MVC and MVVM. I recommended reading about these patterns
    and learning the pros and cons, so you have broader knowledge for your interview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some great reads on VIPER and MVP:'
  prefs: []
  type: TYPE_NORMAL
- en: '- VIPER: [https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern](https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern)'
  prefs: []
  type: TYPE_NORMAL
- en: '- MVP: [https://www.javatpoint.com/ios-model-view-presenter](https://www.javatpoint.com/ios-model-view-presenter)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Clean Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later, in the *Designing app architecture* section, we will discuss app architecture,
    but for now, we are just laying the groundwork, and **Clean Architecture** serves
    as a great foundation. So, what is Clean Architecture?
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture is an architectural approach emphasizing the SoC principle
    when developing a full-blown app. It involves dividing our project into layers
    – the data layer, presentation layer, business logic layer, and network layer
    – and pushes for clean SoC between the different layers and components. If we
    take that even further, we’re discussing creating various libraries for other
    parts of the project and trying to make our app feel like a giant puzzle. Notice
    that breaking our app into modules has a price – maintaining different modules
    can be difficult and requires planning and sometimes complex interface decisions.
    We must always consider the trade-off between a stable structure and a complicated
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Writing small functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a tip most of us have heard several times before. They say a function
    length should be “less than a screen,” but if we want to go extreme, we can say
    that functions should be *as small as possible*. Breaking a long function into
    two/three functions is a good idea to make our code cleaner, less error-prone,
    and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While this function works, it has multiple responsibilities – it iterates the
    list of items and calculates their prices. To improve the SoC, we can separate
    this code into another function that calculates a single item’s price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a dedicated function to calculate a specific item price, and we
    use it in the original `calculateTotalPrice()` function. Small modification? Well,
    regarding code design, that’s a dramatic change – we can test the calculation
    separately and reuse it in other places in our code. Also, the code is more readable,
    and the `calculateItemPrice()` function name also saves us from explaining what
    `price*Double(quantity)` does and even avoids unneeded comments.
  prefs: []
  type: TYPE_NORMAL
- en: It’s interesting to see that even though the original function was small and
    worked well, we can still break it and improve our code in several aspects. That’s
    why the phrase “as small as possible” is much more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Using descriptive names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Descriptive names are always a good idea, but how does naming help us have good,
    clean, and separated code?
  prefs: []
  type: TYPE_NORMAL
- en: Naming has a secret power – it forces us to think about the responsibility of
    our function and describe precisely what it does. The attention we give it can
    help us make the right design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example – look at the next function interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It’s clear that `getProducts()` is supposed to fetch and return products. But
    what exactly does it do? Does it load the products from local data storage or
    use a network request?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s improve the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, things have become more apparent. We understand exactly what the function
    does. But the issue is unclear – our question about the function’s job helped
    us think deeply about its responsibility. Maybe originally, we came up with the
    following name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s a great indication we need to break the function since describing its
    responsibility becomes long and cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more examples of good naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Coming to the interview process with naming conventions in mind is a good idea.
    And you know what? You’ll have written hundreds (if not more) functions in your
    life. You just need to think back and reflect on them. Maybe we’ll learn something
    using our code.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a disclaimer!
  prefs: []
  type: TYPE_NORMAL
- en: I know some tips here are not about “architecture.” But these principles and
    recommendations are relevant at any level.
  prefs: []
  type: TYPE_NORMAL
- en: SoC lays the groundwork for designing a scalable, modular, and maintainable
    app architecture. We can move on to designing app architecture now that we understand
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Designing app architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common mistakes candidates make when asked about app architecture
    is replying, “MVVM, of course!”
  prefs: []
  type: TYPE_NORMAL
- en: So, I want to remind you – MVVM is a design pattern, not an architecture, and
    I want to emphasize the difference.
  prefs: []
  type: TYPE_NORMAL
- en: A design pattern is a reusable solution to a common problem. Dependency Injection,
    Singletons, and MVVM are examples of design patterns. On the other hand, architecture
    is the general structure of our project that represents our app idea.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent real-world example is a building. In this case, the architecture
    describes the number of floors, where the parking lot and the entry door are,
    or what type of roof we have. Design patterns describe *how each apartment is
    built* – the number of rooms in each apartment, the kitchen’s location, and the
    electrical wiring.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that each apartment and floor could be designed differently – meaning
    we can use different design patterns for various problems and needs.
  prefs: []
  type: TYPE_NORMAL
- en: Valuable insights can be gained by drawing parallels with the building industry,
    as there are many similarities between constructing an application and building
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of apartments, we have application screens; instead of a roof and lobby,
    we have application layers.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s talk about application layers for a second.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the architecture into application layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The different layers of an app can be a good starting point for describing an
    app architecture. But what are layers?
  prefs: []
  type: TYPE_NORMAL
- en: 'Layers are different components or sets of components that have different concerns
    and app responsibilities. Most apps work with three primary layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer**: Responsible for presenting information using a UI.
    We can find here the different screens and UI components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business logic layer**: Responsible for the app logic, rules, and calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data layer**: Responsible for storing and retrieving data from local databases
    or other sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layers or tiers?
  prefs: []
  type: TYPE_NORMAL
- en: One common mistake people make when discussing layers is calling them “tiers.”
    The term “tiers” refer to the physical component of an application, while “layers”
    refers to the software component. For example, a tier can be a different computer
    or server responsible for a specific concern. In the case of an iOS app architecture,
    the term “tiers” is irrelevant unless we include the backend side.
  prefs: []
  type: TYPE_NORMAL
- en: For a quick reminder, we’ll review design patterns – MVVM is an example of implementing
    a screen as part of the presentation layer. A Singleton is a design pattern that
    can help us to implement a Core Data handler as part of the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a typical application architecture (*Figure 12**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – A typical iOS app architecture](img/Figure_12.02_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – A typical iOS app architecture
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be intimidated by the diagram in *Figure 12**.2* – remember, *we already
    know* that things need to be reorganized in our heads.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the architecture in *Figure 12**.2* is separated into the three
    different layers we discussed earlier in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the *presentation* layer has various technologies and design
    patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *business logic* layer, we have another design pattern – Façade, which
    is a design pattern that provides a simplified interface to a complex and large
    code block. This is our entry point to the app logic. We can also see the different
    entities we work with in the business layer, the logic of the workflow, and the
    general app logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *data layer*, we can see different service agents (connectors) that can
    help us connect to various services. We can also see analytics and helper services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underneath the diagram, we have external services, such as the database, network,
    and configuration. These services are data sources for the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture diagram illustrates another aspect: how the data flows between
    the different layers, which we will see next.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about data flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We understand that if the presentation layer needs to show information to the
    user, we need it to fetch the information from the business layer all the way
    to the data layer and the database. There are cases where we can have an app with
    more layers, such as notification, security, and persistence layers. In that case,
    the data flow gets a little more complex.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting question that may arise is whether it’s feasible for a layer
    to bypass another layer while retrieving data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to answer that briefly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing a layered system, there are two terms that we need to learn
    – closed and open layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closed layer**: A closed layer means the given layer cannot be bypassed to
    one of the layers below it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open layer**: An open layer means the given layer can be passed to any layer
    below it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is considered a best practice for a system to be fully closed or open, but
    in most cases, systems have a mixture of open and closed layers.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are the benefits of having a closed or open layer?
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at *Figure 12**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Open and closed layers](img/Figure_12.03_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Open and closed layers
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 12**.3*, we can see a system architecture with different layers and
    their dependencies. Layer B is closed, meaning layer A can’t access layers D and
    E. On the other hand, layer C is open, meaning that layer A can access layers
    F and G.
  prefs: []
  type: TYPE_NORMAL
- en: The gray-filled layers are those layer A has access to, but it also means that
    these are dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: What the open layer does is increase coupling by exposing the top layers to
    more layers. On the other hand, closed layers are harder to maintain and require
    designing an excellent and flexible interface ahead of time. We already know that
    reducing the number of dependencies creates a loose and flexible system, but it
    doesn’t mean we need to create an overly complex design. This is an excellent
    example of a trade-off between simplicity and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: What’s more important is to understand these terms when designing architecture
    and making decisions. Building a layered system without thinking at all is probably
    the worst thing we can do.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture concepts combined with design patterns are the ground for designing
    good architecture for our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a real-world example and review its design together.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an offline-first system architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **offline-first** system architecture is a typical design many interviewers
    like to discuss. The reason is that this use case involves working with different
    data sources and design patterns to achieve what seems to be an important advantage
    of having a mobile-native app instead of a web app.
  prefs: []
  type: TYPE_NORMAL
- en: The way an offline-first system works is by having two data sources – a *persistent
    store* and *network* communication. On top of that, we have a *sync service* that
    is responsible for updating the persistent store with data from the network. The
    business logic layer that connects the UI to the data layer works directly with
    the persistent store, regardless of the network status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a diagram of such a system (*Figure 12**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Offline-first system architecture](img/Figure_12.04_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Offline-first system architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at *Figure 12**.4*, we can see that **Articles Handler** on the business
    layer works directly with Core Data *without being aware* of the network layer.
    The sync service is the only component that links the Core Data store and the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: We provide a superb user experience to our users by adding offline loading.
    Besides that, we have an excellent implementation of the SoC principle with a
    decoupled system that makes its components totally disconnected.
  prefs: []
  type: TYPE_NORMAL
- en: A typical implementation option candidates love to answer with in interviews
    is doing all the sync work in one class in the business logic or even as part
    of the view model. Sure, that option can work great, but this is a very narrow
    point of view when designing a system that can scale and be maintained over time.
    Having a dedicated service that can handle sync logic and maintain it separately
    is perfectly fine.
  prefs: []
  type: TYPE_NORMAL
- en: It is always important to remind ourselves of the responsibility of every component
    in our system and how it communicates with other components. That can lead us
    to a better and clearer design.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture design interview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture design interview is a crucial step toward our proposal, and
    it requires skills that are much softer and communication oriented.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Swift, Combine, and Core Data questions, the architecture design interview
    requires us to step forward and come up with a more holistic point of view – product
    requirements, backend, scale, analytics, and user experience are all factors we
    need to consider when trying to design a complete system.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture interview, perhaps even more than the other steps in the hiring
    process, is based on communication and meeting expectations. Therefore, we’ll
    start with understanding the interviewer’s point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Entering the head of our interviewer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what does our interviewer want from us? What are their expectations?
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to understand here is that the interviewer doesn’t
    care whether your answer is the most optimized solution, or even whether it’s
    right or wrong. The architecture design interview is definitely in another field,
    and the interviewer is looking for something else – they want to see how we *think*,
    approach problems, *manage trade-offs*, and find a path to a decent solution based
    on the product requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take, for example, the following interview question:'
  prefs: []
  type: TYPE_NORMAL
- en: “Design the Messages app that comes with iOS.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the top app feature would be the messaging screen (“chat”). Here
    is a list of issues we need to tackle when we approach that problem:'
  prefs: []
  type: TYPE_NORMAL
- en: What would the UI components we will use be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the data model? What will the properties of each message be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What endpoints do we need? Are we going to implement pagination? If not, how
    do we handle an endless number of messages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we support offline use? How are we going to do that?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we support attachments? How is it going to work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if we want to have a group chat?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are we going to support real-time updates?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the questions that arise when approaching this task,
    and none are straightforward. It’s our job to find the answers.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we start?
  prefs: []
  type: TYPE_NORMAL
- en: Approaching the mission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve interviewed hundreds of candidates in my life, and many of them struggled
    to understand how to approach an architecture interview.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not that they didn’t know how to design an app or explain their ideas
    – they didn’t know two things:'
  prefs: []
  type: TYPE_NORMAL
- en: What the starting point for the task was
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What their boundaries were
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two topics are critical to understand for the interview to warm up and
    get on track to a great solution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the starting point – understanding the problem and the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem and the scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do when approaching a design question is to stop,
    breathe, and try to understand what the interviewer expects from us. Most candidates
    fail at this point because they know they have limited time to answer a question,
    so they rush up to scribble boxes on the whiteboard.
  prefs: []
  type: TYPE_NORMAL
- en: But the design interview represents a real-life task. The interviewer expects
    us to understand the problem before describing what we do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to our problem – designing a messages app similar to the one that
    comes with iOS. Several questions we can ask the interviewer are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we have a UI wireframe or must we produce it ourselves?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many screens do we have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the design need to contain the backend services as well?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it cross-platform (including Android or web) or iOS only?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have a given database scheme, or do we need to plan it ourselves?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few examples, but they can help us understand what we must
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand the problem and what to do, we can retrieve the product requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the product requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike with conventional development tasks, we don’t have a **Product Requirements
    Document** (**PRD**) or a kickoff meeting with our product manager in the architecture
    design interview. Instead, we must understand the product requirements and ask
    our interviewers for more information. In fact – this is what the interviewer
    is looking for!
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the interview is like a dark maze where we navigate with a flashlight
    and unveil more areas, rooms, and paths. Sometimes even the interviewer doesn’t
    know where we will take the interview!
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the messages app task, there are some questions we can think
    of when starting to design the app. Take the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we support offline reading and writing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have an integration with the device contacts?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to support notifications and real-time chat?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the user edit or delete messages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to support landscape mode?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These questions weren’t posed out of curiosity. They impact the design and technical
    decisions we’ll need to make. For example, offline support is crucial to understand
    our data source’s behavior and sync mechanism. Integration with the device contacts
    influences our data model. Real-time chat defines our network methods, and edit
    and delete features affect how we sync information back to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: It is perfectly fine not to ask all the questions at first – sometimes we just
    need to start designing to understand what we need to ask, but having a good start
    is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we start the design? With wireframes? Or entities? That’s a good
    question, so let’s see.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The design part is dynamic. No one expects us to have the final answers when
    we start to draw, and we should expect things to change during the interview according
    to new findings and conclusions. Presenting things clearly and in detail can help
    us communicate better with the interviewer and express our thoughts better.
  prefs: []
  type: TYPE_NORMAL
- en: Going to the whiteboard – wireframes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not product designers, and no one expects us to be. But knowing how to
    present our ideas on a whiteboard is crucial for that process. We already discussed
    that in *Chapter 1* when we discussed technical preparations, and now, we understand
    exactly why.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we start? Some developers like to start with basic UML that describes
    the different entities or classes. But in my opinion, it is better to start with
    wireframing the different screens when it comes to app architecture. Let’s start
    with the messages screen (*Figure 12**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The messages screen](img/Figure_12.05_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – The messages screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at *Figure 12**.5*, we can understand why starting from the UI is better.
    Ignoring the font size and the layout (I’m not a good designer, I know), it looks
    like there are many things we can learn from this wireframe. Let’s list them:'
  prefs: []
  type: TYPE_NORMAL
- en: We’re starting to understand the *different entities*. For example, we see a
    full name and an avatar – that describes the **Contact** entity. We can also see
    that the list shows the contact’s last message, which contains text property,
    so we have another entity here – **Message**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We see that the list is being sorted by time. That’s maybe the place to dig
    a little bit deeper – do we want to sort it according to the most updated message
    for each contact, or do we want to have an **updatedTime** property of the **Contact**
    entity? This is a classic *trade-off between performance and simplicity*; we should
    discuss it with our interviewer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How about the *UI*? We know we are supposed to have some sort of **UITableView**
    here. But do we want to load all the messages into the table view, or do we want
    to support pagination? What design pattern are we going to use here, MVC or MVVM?
    We should decide on the app’s scale, the first-time experience, and common user
    usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we continue, I want you to notice something – there are no clear answers,
    just considerations and trade-offs. I asked questions but haven’t given you any
    answers because the questions we ask ourselves and the interviewer are part of
    the process. That’s the place to show that we understand there are gray areas
    where we need to make the decisions.
  prefs: []
  type: TYPE_NORMAL
- en: So, are we just using the whiteboard to draw a UI? Not necessarily – let’s continue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding entities and backend services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s [*Chapter 12*](B18653_12.xhtml#_idTextAnchor360), and we know that an app
    is more than just the UI. But is one screen enough to start designing the other
    parts? Definitely, yes!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add entities (*Figure 12**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Initial entities for the message’s app](img/Figure_12.06_B18653.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Initial entities for the message’s app
  prefs: []
  type: TYPE_NORMAL
- en: Writing the entities on the whiteboard sounds like a technical task, but similar
    to wireframing, it can help us find more exciting things about our app.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we mentioned a URL for a contact avatar – this means we need to
    create some kind of image downloader service and a caching mechanism based on
    that URL. As a result, the *image downloader* can be added to our drawing on the
    whiteboard.
  prefs: []
  type: TYPE_NORMAL
- en: Look what we’ve achieved based on a single entity’s property!
  prefs: []
  type: TYPE_NORMAL
- en: But the actual value of drawing the entities is when we start thinking about
    their relationships. We have `Contact` and `Message`. But what describes a conversation
    with a contact? Maybe we need to create another entity named `MessagesThread`.
    And if we have a `MessagesThread` entity, what would its properties be?
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, things become a little bit more complex, because thinking about
    the connections brings up more questions – for example, do we support group messaging?
    The answer sets the relation type between `MessageThread` and `Contact`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing the entities next to our wireframes creates a back-and-forth process
    that helps us shape our design and make it more complete. Each decision leads
    to more questions, leading to more design decisions. It also sets the path to
    our next task: designing the interaction with our backend.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding network calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the basic UI wireframes and entities, planning how we will
    work with our backend service should be easier. Remember that the UI and entities
    are still part of our app learning stage – now we understand better what we need
    to do. The different endpoints define the user experience and the design patterns
    we will use, and that’s where we can really work on our app architecture, as we
    learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what endpoints we need for the main screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET/threads**: To retrieve the list of all the threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST/thread**: To create a new messages thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, when working with a list of information, it is common to include
    these two endpoints as a part of our design. But there are more things to consider
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: How are the threads sorted? Do we get them sorted from the server, or do we
    sort them by a specific property?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have a pagination mechanism? Or do we fetch all threads and use an incremental
    update sync?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need the **POST** request at this stage? Or can we do that only after
    the first message we send?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The endpoints also help us to define the app architecture. They answer important
    questions about the UI layer and its design patterns (MVC/MVVM). But they also
    help us understand our data layer and the different services we will need. The
    following are examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Core Data handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image downloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sync service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network service and real-time management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we continue adding more endpoints to the rest of the screens, we will learn
    more about our app and get more answers.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an app architecture is a discovery process. Nothing is clear at the
    beginning, and communicating the process to find the answers is essential. That’s
    why our next topic is extremely important – our communication with the interviewer.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the interviewer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in this section, many candidates believe their primary
    goal in the architecture design interview is to provide the most optimal solution
    to the problem they just received. But the truth is that the goal is for the interviewer
    to see how we think and offer a decent solution to problems that might come up.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, effective communication with the interviewer is crucial to be successful
    in this kind of interview. Some of our most critical soft skills are being tested
    here!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over some tips to help us focus on what matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listen to the interviewer*: That’s obvious, right? Of course we are going
    to listen to the interviewer! But I mean, *really* listen to them. First, because
    the task requirements and the scope are very important to be precise on what we
    do. Moreover, there are valuable tips our interviewer will give us that can help
    us with our goal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clarify doubts*: If you are uncertain about your decision, you must communicate
    this to the interviewer. Interviewers need to see that candidates see things in
    shades of gray and not just black and white, but it is also a way to get clues
    or discuss things with the interviewer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Be confident*: I know it sounds like it contradicts the previous point, but
    it doesn’t. It’s true that when we have doubts, we need to communicate them, but
    when we are confident about something, we must show it. Self-confidence is an
    essential factor in these interviews.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Think out loud*: We know what we want to achieve with our design, and we even
    drew it on the whiteboard. But what is clear to us is not always apparent to the
    other person in the room. Thinking out loud can help us explain what we’re doing
    more clearly and help the interviewer understand the fantastic architecture we’ve
    just designed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use the correct terminology*: In this book, I have been strict about the different
    terms used – method versus function, design pattern versus architecture, and more.
    Using the correct terminology in these interviews is essential, not just to appear
    professional; it also makes our explanations much more evident to our interviewer.
    Not all interviewers are strict about it – but that doesn’t mean we shouldn’t
    be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Be open to feedback*: The interviewer may provide feedback or suggestions
    during the interview. Sometimes it is a clue for the direction we can take, or
    sometimes it’s because we went out of scope. What happens many times, in this
    case, is that candidates lose their self-confidence and close themselves off,
    finding it difficult to accept that feedback. We should put our egos aside when
    we enter the design interview (actually, we should put our egos aside all the
    time) and use the interviewer’s feedback to improve our answers. Feedback during
    the interview doesn’t mean we failed – it means that we have a chance to provide
    a better solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It seems like we are being tested on how we communicate and express ourselves,
    but that’s the reality! The interviewer wants to see what it is like working with
    us, discussing design issues, and having architecture debates. That’s where our
    personality stands out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture design interview is the highlight of the hiring process. It
    incorporates extensive knowledge of design patterns, architectures, iOS user experience,
    and critical soft skills such as planning, communication, and presentation.
  prefs: []
  type: TYPE_NORMAL
- en: However, at this point, we should be in a position where we know how to crack
    the interview with several primary steps.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned about the SoC and how it applies to iOS architecture,
    including function size and naming. We’ve learned about application layers and
    data flows and even discussed an excellent example of an architecture for offline
    working. And finally, we discussed the architecture design interview – how to
    approach it and communicate with the interviewer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next (and final!) chapter, we will discuss the most practical step in
    the interview: the live coding interview and the home assessment. All hiring processes
    now include this step, and it’s our job to be ready for the unknown.'
  prefs: []
  type: TYPE_NORMAL
