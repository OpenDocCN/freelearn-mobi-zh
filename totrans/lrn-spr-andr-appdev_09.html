<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating an Application</h1>
                
            
            
                
<p>So far, we have prepared you to become a professional Spring-based developer. You have learned what Spring is, as well as the functions of its architecture, components, security features, database, and so on. We have also shown you how to develop an Android app and handle HTTP requests and use the database. </p>
<p>As you know, we developed all the example projects in Kotlin, and nowadays, this language is very famous among developers for its conciseness and interoperability. In this chapter, we will implement all the features of the previous chapters to develop a project that will have a server and a client side. </p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Project idea</li>
<li>Creating the design</li>
<li>Server side:
<ul>
<li>Developing a database model</li>
<li>Creating a project and Maven dependency</li>
<li>Creating entities, repositories, and a controller</li>
<li>Implementing security</li>
<li>Modified application.properties</li>
</ul>
</li>
<li>Client side:
<ul>
<li>Creating models</li>
<li>Creating HTTP requests</li>
<li>Creating API services</li>
<li>Modifying activities</li>
<li>Fetching REST APIs</li>
<li>Creating an adapter and XML layouts</li>
<li>Checking the output</li>
</ul>
</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>You will need almost all the dependencies, such as security, MySQL, JPA, Hibernate, and JDBC, from the previous chapters.</p>
<p>The source code with an example for this chapter is available on GitHub at the following link: <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter09">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter09.</a></p>
<p>You will find two projects—<kbd>social_network</kbd> is the server side, which has been developed with the help of the Spring Framework, and <kbd>ClientSide</kbd> is the client side, which has been developed for the Android platform.<strong> </strong></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project idea</h1>
                
            
            
                
<p>The project idea is the most important part. You need to generate this idea very carefully and have to identify the facts behind your project. You need to keep in mind how this project could be effective on the market, how the users will accept your project, why they will use it, why they should choose your app instead of others, what features will make it different from other existing similar projects, and so on. After generating an idea, you need to create a draft in your mind of how will it look. Then you need to put it down on paper, design the workflow of the project, and then develop the project's code. Lastly, you need to test the project for its smoothness, check that it's bug/error free, and prepare it for the market.</p>
<p>In this chapter, we will create a small project that is like a social network. We will name it <kbd>Packt Network</kbd>. This project will have two parts. One is a server and one is a client, and both sides will be written in Kotlin. First of all, we create a Spring project where we will build our server and REST API. The data will be stored in a MySQL database, and we will handle the database using JDBC, JPA, and Hibernate. This data will be protected by the basic authentication of Spring Security. </p>
<p>In our second project, we will create an Android application and handle the created REST APIs of the server. We will use Retrofit to handle the REST APIs and the network. Then we will create a registration and login page to create and login as a user, using a username and password. After this, the user can post a status and see a list of all the other user's statuses. A comment can be also posted in a status. </p>
<p>Now we will start to design and develop our server-side project using Spring.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Server side</h1>
                
            
            
                
<p>On the server side, we are using the Spring Framework. We will handle all the data with a MySQL database and protect the resources with basic authentication. </p>
<p>First of all, we will design the project's backend logic. Then we will plan for the REST API. We will create a data model using MySQL Workbench. Then we will create the project using <a href="http://start.spring.io">http://start.spring.io</a>. Then we will create the database entity using JPA and Hibernate, and we will check that the REST API is working. To check this, we will use an HTTP client software tool named Insomnia. Then we will implement basic authentication with Spring Security to protect our resources. Lastly, we will give you a task to complete, on upgrading the project, and becoming a contributor to this project on GitHub.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the design</h1>
                
            
            
                
<p>As we mentioned before, this project will be like a social media platform; the users can post their statuses and others can see them in the timeline and can like it, add comments, and so on. For this project, there won't be a UI for the server side. We will create a backend server. To create this server, we will have to create a REST API that can be used by the client application. To do this, we need to create a database based on our REST API.</p>
<p>First of all, we split our database table names, the HTTP function requests, and the URL path.</p>
<p>There will be four tables:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9ba5c0ba-4f49-43b7-a2e7-9703757538d9.png" style="width:18.33em;height:10.67em;"/></p>
<p>Let's have a look at each of them:</p>
<ul>
<li>One is for the users. All their information will be stored in a table named <kbd>Profile</kbd>.</li>
<li>There will be another table named <kbd>Post</kbd>, where all the posted statuses of all the users will be stored.</li>
</ul>
<ul>
<li>Another table named <kbd>Comment</kbd> will store all the comments of all the posted statuses.</li>
<li>Another table named <kbd>LikeObj</kbd> will store all the likes of all the posted statuses, but we won't provide this feature for the comments.</li>
</ul>
<p>Now we will create the URL path of the REST API using an HTTP function request, and all the output will be designed for JSON. We are using JSON because it is very easy to handle and understand for all developers. </p>
<p>Regarding the <kbd>Profile</kbd> table, here are the URL paths of the HTTP requests:</p>
<ul>
<li><kbd>POST http://localhost:8080/user/new</kbd>: This request will create a user profile with all the information the user has posted on their profile</li>
<li><kbd>GET http://localhost:8080/user/{id}</kbd>: This request will get the details of the given <kbd>id</kbd> holder</li>
<li><kbd>PUT http://localhost:8080/user/{id}</kbd>: This request will update the user details of the given <kbd>id</kbd> holder</li>
<li><kbd>DELETE http://localhost:8080/user/{id}</kbd>: This request will delete the user details of the given <kbd>id</kbd> holder, including all the posts, comments, and likes from this user</li>
</ul>
<p>Regarding the <kbd>Post</kbd> table, here are the URL paths of the HTTP requests:</p>
<ul>
<li class="mce-root"><kbd>POST http://localhost:8080/post/{id}/new</kbd>: This request will create a post from the <kbd>id</kbd> holder</li>
<li class="mce-root"><kbd>GET http://localhost:8080/posts</kbd>: This request will get all the post's details</li>
<li class="mce-root"><kbd>GET http://localhost:8080/post/{id}</kbd>: This request will get the post details of the given <kbd>id</kbd> holder</li>
<li class="mce-root"><kbd>DELETE http://localhost:8080/post/{id}</kbd>: This request will delete the post details of the given <kbd>id</kbd> holder, including all the comments</li>
</ul>
<p class="mce-root">Regarding the <kbd>Comment</kbd> table, here are the URL paths of the HTTP requests:</p>
<ul>
<li class="mce-root"><kbd>POST HTTP://localhost:8080/comment/{post_id}</kbd>: This request will create a comment on the <kbd>post_id</kbd> holder</li>
<li class="mce-root"><kbd>DELETE HTTP://localhost:8080/comment/{post_id}</kbd>: This request will delete the comment of the given <kbd>post_id</kbd> holder</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Regarding the <kbd>LikeObj</kbd> table, here are the URL paths of the HTTP requests:</p>
<ul>
<li class="mce-root"><kbd>POST http://localhost:8080/like/new</kbd>: This request will like a post of the <kbd>post_id</kbd> holder</li>
<li class="mce-root"><kbd>DELETE ttp://localhost:8080/like/new</kbd>: This request will unlike a post of the <kbd>post_id</kbd> holder</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing a database model</h1>
                
            
            
                
<p>We will use JPA, and one of the most noticeable points is that creating a database is not recommended, because as we know, JPA will automatically create database tables with fields using the entity class of the project. But still, we need to create a demo database and draw an EER diagram. You can create your EER on paper or you can create one digitally using MySQL Workbench. Here, we will use MySQL Workbench, which has a free version. This is one of the best tools for developing a database or creating a model for a database:</p>
<ol>
<li>You need to download this software from<a href="https://dev.mysql.com/downloads/workbench/"> https://dev.mysql.com/downloads/workbench/</a>, if you don't have it. Then install and run it. As we mentioned before, we have some default values:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">Host -- localhost // our hosting URL<br/>Port -- 3306 // our hosting port<br/>Username -- root // username of the MySQL<br/>Password -- 12345678 // password of the MySQL</pre>
<ol start="2">
<li class="CDPAlignLeft CDPAlign">Open this application and select the Models option, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b487cdb6-845c-4217-896c-38e57fbaca3d.png" style="width:31.08em;height:16.00em;"/></p>
<ol start="3">
<li class="CDPAlignLeft CDPAlign">Click the plus (+) sign to create a new model for our application. In the new window, you will find all the necessary features to create a model. Save this model as <kbd>my_app</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8fb2a6c7-66fc-4fb5-8c81-c3697b4f0017.png"/></p>
<ol start="4">
<li class="CDPAlignLeft CDPAlign">Create a table called <kbd>Profile</kbd>. The columns will be <kbd>id (primary key)</kbd>, <kbd>username</kbd>, <kbd>password</kbd>, <kbd>email</kbd>, <kbd>first_name</kbd>, <kbd>last_name</kbd>, <kbd>acc_created_time</kbd>, <kbd>contact_number</kbd>, <kbd>dob</kbd>, <kbd>city</kbd>, and <kbd>country</kbd>.</li>
<li>A table called <kbd>Post</kbd>. The columns will be <kbd>id (primary key)</kbd> and <kbd>text</kbd>.</li>
<li>Create another table called <kbd>Comment</kbd>. The columns will be <kbd>id (primary key)</kbd> and <kbd>text</kbd>.</li>
<li>Lastly, create a table called <kbd>Like</kbd>. The column will be <kbd>id (primary key)</kbd>.</li>
</ol>
<p>But there are some relationships between the tables:</p>
<ul>
<li>Between <kbd>Profile</kbd> and <kbd>Post</kbd>: There is a many-to-one relation for <kbd>Post</kbd> because a user can post multiple statuses, and each post has only one user.</li>
<li>Between  <kbd>Profile</kbd> and <kbd>Comment</kbd>: There is a many-to-one relation for <kbd>Comment</kbd> because a user can post multiple comments, and each comment has only one user.</li>
<li>Between  <kbd>Profile</kbd> and <kbd>Like</kbd>: There is a many-to-one relation for <kbd>Like</kbd> because a user can like multiple  posts, and each like has only one user.</li>
<li class="mce-root">Between  <kbd>Post</kbd> and <kbd>Comment</kbd>: There is a one-to-many relation for <kbd>Post</kbd> because a post may have multiple comments, but a comment is for only one specific post.</li>
<li>Between  <kbd>Post</kbd> and <kbd>Like</kbd><strong>:</strong> There is a one-to-many relation for <kbd>Post</kbd> because a post may have multiple likes, but each like is for only one specific post:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/aea017e3-8e32-477b-8c67-9e8f71ba0b06.png"/></p>
<p>So after all the relations, we can see the table names of the database, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/61a24944-37fc-4692-ae5d-8fa9aea80ad9.png" style="width:30.17em;height:18.08em;"/></p>
<p>Finally, you can create the EER diagram by clicking on the EER Diagram icon, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/973c7439-afc1-4d49-bc49-02593293139e.png" style="width:28.25em;height:16.75em;"/></p>
<p>This is the EER diagram model of our project. You may find two extra tables, named <kbd>post_likes</kbd> and <kbd>post_comments</kbd>. It generates these using JPA and Hibernate. We will discuss this later.</p>
<p>So, our database modeling is done. Now you can export it as SQL and create the database for the project. But we recommend you not to do this because we need to do some modification. </p>
<p>Now create the project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a project</h1>
                
            
            
                
<p>To create a project, go to  <a href="https://start.spring.io">https://start.spring.io</a> and create a Kotlin-based project. Here are the dependencies of the project:</p>
<ul>
<li class="mce-root">Web</li>
<li class="mce-root">JDBC</li>
<li class="mce-root">MySQL</li>
<li class="mce-root">DevTools</li>
<li>JPA</li>
<li>H2</li>
</ul>
<p>You can find these in the <kbd>pom.xml</kbd> file. There you can update, add, or remove the dependencies.</p>
<p>To enable JPA auditing, you need to annotate <kbd>@EnableJpaAuditing</kbd> annotation on the <kbd>SocialNetworkApplication.kt</kbd> class. It will enable the use of JPA functionalities.</p>
<p>Here is the code for this class:</p>
<pre>@SpringBootApplication<br/><strong>@EnableJpaAuditing<br/></strong>class SocialNetworkApplication<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   runApplication&lt;SocialNetworkApplication&gt;(*args)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating entities</h1>
                
            
            
                
<p>First of all, we need to create four as the table details of the database. The four entities are <kbd>Profile</kbd>, <kbd>Post</kbd>, <kbd>Comment</kbd>, and <kbd>LikeObj</kbd>. In the following sections, you'll learn how to create the entity classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Profile entity</h1>
                
            
            
                
<p>Create a <kbd>Profile</kbd> entity named <kbd>Profile.kt</kbd> with the <kbd>@Entity</kbd> annotation to convert this class into an entity class. Here is the code of this model class (the entire code can be found at the provided GitHub Link):</p>
<pre>@Entity<br/>class Profile : Serializable {<br/><br/>    constructor(id: Long) {<br/>        this.id = id<br/>    }<br/><br/>    constructor(name: String) {<br/>        this.username = name<br/>    }<br/>    -----<br/>    -----<br/> @JsonProperty("contactNumber")<br/> var contactNumber: String? = null<br/><br/> @JsonProperty("dob")<br/> var dOB: Date? = null<br/><br/> @JsonProperty("city")<br/> var city: String? = null<br/><br/> @JsonProperty("country")<br/> var country: String? = null<br/>}</pre>
<p>In this class, we have <kbd>11</kbd> elements, which contain all the user's details. We have four constructors to use this model according to our tasks. Here are the constructors:</p>
<pre>constructor<strong>(id: Long)</strong> {<br/>  ----<br/>  ----<br/>}<br/><br/>constructor<strong>(name: String)</strong> {<br/>  ----<br/>  ----<br/>}<br/><br/>constructor<strong>(id: Long, name: String, password: String)</strong> {<br/>  ----<br/>  ----<br/>}<br/><br/>constructor<strong>(username: String, password: String, email: String, accCreatedTime: Instant,<br/> firstName: String?, lastName: String?, contactNumber: String?, dOB: Date?,<br/> city: String?, country: String?)</strong> {<br/>  ----<br/>  ----<br/>}</pre>
<p class="mce-root">Now let's discuss the annotations that are used in this class:</p>
<pre><strong>@Id</strong><br/><strong>@GeneratedValue</strong><br/>var id: Long? = 0</pre>
<p>According to the previous code, we used <kbd>@Id</kbd> annotation on the <kbd>id</kbd>, which means that <kbd>id</kbd> is the primary key of the <kbd>Profile</kbd> entity. The <kbd>@GeneratedValue</kbd> annotation means it increments the value of <kbd>id</kbd>.</p>
<p>Here is a snippet of the code for the <kbd>password</kbd> object:</p>
<pre><strong>@JsonIgnore<br/>@JsonProperty("password")</strong><br/>var password: String = ""</pre>
<p>According to this code, <kbd>@JsonIgnore</kbd> uses variables or functions. If you use it, then the requested JSON won't show this variable. Here, we used it on the <kbd>password</kbd>, and that means no-one can fetch the password.</p>
<p><kbd>@JsonProperty</kbd> defines that during the serialization and deserialization of JSON, it changes the visibility of the logical property of its element.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Post entity</h1>
                
            
            
                
<p>Create a <kbd>Post</kbd> entity named <kbd>Post.kt</kbd> with the <kbd>@Entity</kbd> annotation to convert this class into an entity class. Here is the code of this model class:</p>
<pre>@Entity<br/>class Post(text: String, postedBy: Profile) : Serializable {<br/><br/>    @Id<br/>    @GeneratedValue<br/>    var id: Long? = 0<br/><br/>    var text: String? = text<br/><br/>    @ManyToOne(fetch = FetchType.LAZY)<br/>    @JoinColumn(name = "profile_id")<br/>    @JsonIgnoreProperties("username","password", "email","accCreatedTime","firstName","lastName",<br/>            "contactNumber","dob","city","country")<br/>    var postedBy: Profile? = postedBy<br/><br/>    @JsonIgnore<br/>    @JsonProperty("postCreatedTime")<br/>    var postCreatedTime: Instant? = Instant.now()<br/><br/>    @OneToMany(cascade = [CascadeType.ALL], fetch = FetchType.LAZY, orphanRemoval=true)<br/>    val comments = mutableListOf&lt;Comment&gt;()<br/><br/><br/>    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true)<br/>    var likes: List&lt;LikeObj&gt;? = mutableListOf&lt;Comment&gt;()<br/>}</pre>
<p>Here we have two elements and one constructor. Here is the constructor:</p>
<pre>@Entity<br/>class Post<strong>(text: String, postedBy: Profile)</strong> : Serializable {<br/>   -----<br/>   -----<br/>}</pre>
<p>It's time now to discuss some new annotations that have been used in this class:</p>
<pre><strong>@ManyToOne(fetch = FetchType.LAZY)</strong><br/><strong>@JoinColumn(name = "profile_id")</strong><br/><strong>@JsonIgnoreProperties("username","password", "email","accCreatedTime","firstName","lastName",<br/>            "contactNumber","dob","city","country")</strong><br/>    var postedBy: Profile? = postedBy</pre>
<p><kbd>@ManyToOne</kbd> on the <kbd>Profile</kbd> variable means that this will indicate which user posted that specific status. </p>
<p><kbd>@JoinColumn</kbd> means its access element <kbd>Profile</kbd> is connected with the foreign key using <kbd>profile_id</kbd>.</p>
<p><kbd>@JsonIgnoreProperties(......)</kbd> ignores the JSON properties during deserialization. In this project, when you get the post's JSON, in the <kbd>profile</kbd> attribute you will only find the <kbd>id</kbd>. Here is a simple example of a JSON:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/0d9033c7-88c3-423a-95a8-b38ed8836268.png"/> </p>
<p>You can see <kbd>"id":0</kbd>, which is the <kbd>id</kbd> of the post.</p>
<p>Now create a mutable list of the <kbd>Comment</kbd> and annotate it with <kbd>@OneToMany</kbd>, as follows:</p>
<pre> @OneToMany(cascade = [CascadeType.ALL], fetch = FetchType.LAZY, orphanRemoval=true)<br/>    val comments = mutableListOf&lt;Comment&gt;()</pre>
<p><kbd>@OneToMany(....)</kbd> means a post can be many comments and likes. </p>
<p><kbd>cascade = [CascadeType.ALL]</kbd> attribute is a feature of Hibernate. It means you can apply all primary cascade types.</p>
<p><kbd>fetch = FetchType.LAZY</kbd> means it fetches the data lazily during the first access.</p>
<p><kbd>orphanRemoval=true</kbd> means if the post has been deleted, then all the comments and likes on this post will be deleted automatically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Comment entity</h1>
                
            
            
                
<p>Create a <kbd>Comment</kbd> entity named <kbd>Comment.kt</kbd> with the <kbd>@Entity</kbd> annotation to convert this class into an entity class. Here is the code of this model class:</p>
<pre>@Entity<br/>class Comment<strong>(text: String, postedBy: Profile)</strong> : Serializable {<br/><br/>    @Id<br/>    @GeneratedValue<br/>    var id: Long? = 0<br/><br/>    var text: String? = text<br/><br/>    @JsonIgnore<br/>    @JsonProperty("accCreatedTime")<br/>    var accCreatedTime: Instant? = Instant.now()<br/><br/>    @ManyToOne<br/>    @JoinColumn(name = "profile_id")<br/>        @JsonIgnoreProperties("username","password","email","accCreatedTime","firstName","lastName"       , "contactNumber","dob","city","country")<br/>    var postedBy: Profile? = postedBy<br/>}</pre>
<p>Here we have three elements and one constructor. Here is the constructor:</p>
<pre>@Entity<br/>class Comment<strong>(text: String, postedBy: Profile)</strong> : Serializable {<br/>   -----<br/>   -----<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating like entity</h1>
                
            
            
                
<p>Create a like entity named <kbd>LikeObj.kt</kbd> with the <kbd>@Entity</kbd> annotation to convert this class into an entity class. Here is the code of this model class:</p>
<pre>@Entity<br/>class LikeObj(mProfile: Profile) : Serializable {<br/><br/>    @Id<br/>    @GeneratedValue<br/>    var id: Long? = 0<br/><br/>    @ManyToOne<br/>    @JoinColumn(name = "profile_id")<br/>    @JsonIgnoreProperties("username","password","email","accCreatedTime","firstName","lastName",<br/>            "contactNumber","dob","city","country")<br/>    var profile: Profile? = mProfile<br/>}</pre>
<p>Here we have one element and one constructor. Here is the constructor:</p>
<pre>@Entity<br/>class LikeObj<strong>(profile: Profile)</strong> : Serializable {<br/>   -----<br/>   -----<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating repositories</h1>
                
            
            
                
<p>Create a repository for a profile named <kbd>ProfileRepository.kt</kbd> and implement the <kbd>JpaRepository</kbd> repository that has all the necessary CRUD request methods to fetch the database. Here is the code for this class:</p>
<pre>@Repository<br/>interface ProfileRepository : JpaRepository&lt;Profile, Long&gt;</pre>
<p>Now create a repository for a post named <kbd>PostRepository.kt</kbd> and implement the <kbd>JpaRepository</kbd> repository that has all the necessary CRUD request methods to fetch the database. Here is the code for this class:</p>
<pre>@Repository<br/>interface PostRepository : JpaRepository&lt;Post, Long&gt;</pre>
<p>Then create a repository for a comment named <kbd>CommentRepository.kt</kbd> and implement the <kbd>JpaRepository&lt;&gt;</kbd> repository that has all the necessary CRUD request methods to fetch the database. Here is the code for this class:</p>
<pre>@Repository<br/>interface CommentRepository : JpaRepository&lt;Comment, Long&gt;</pre>
<p>Lastly, create a repository for the like model named <kbd>LikeRepository.kt</kbd> and implement the <kbd>JpaRepository&lt;&gt;</kbd> repository that has all the necessary CRUD request methods to fetch the database. Here is the code for this class:</p>
<pre>@Repository<br/>interface LikeRepository : JpaRepository&lt;LikeObj, Long&gt;</pre>
<p class="mce-root">To delete all the data regarding the deleted post, we need to create a repository for the profile named <kbd>DeletePCLRepository.kt</kbd> and implement an interface named <kbd>DeletePCLByIDInterface.kt</kbd> with one function, which will delete all the data regarding the deleted user. Here is the code for the interface:</p>
<pre>interface DeletePCLByIDInterface {<br/>    fun deleteAllUsersInfoByUserID(userID: Long): Any<br/>}</pre>
<p>Here is the code for the <kbd>DeletePCLRepository.kt</kbd> class:</p>
<pre>@Repository<br/>class DeletePCLRepository : DeletePCLByIDInterface {<br/><br/>    @Autowired<br/>    private lateinit var jdbcTemplate: JdbcTemplate<br/><br/>    override fun deleteAllUsersInfoByUserID(userID: Long): Any {<br/><br/>        val deletePosts = "DELETE FROM post, comment WHERE profile_id = ?;"<br/>        val deleteComments = "DELETE FROM comment WHERE profile_id = ?"<br/>        val deleteLikes = "DELETE FROM like_obj WHERE profile_id = ?"<br/><br/>        jdbcTemplate.update(deletePosts, userID)<br/>        jdbcTemplate.update(deleteComments, userID)<br/>        jdbcTemplate.update(deleteLikes, userID)<br/><br/>        return "DONE"<br/>    }<br/>}</pre>
<p class="mce-root">To check a registered user, create a repository named <kbd>UserExistRepository.kt</kbd> and implement an interface named <kbd>UserExistInterface.kt</kbd> with two functions.</p>
<p>Here is the code for the interface:</p>
<pre>interface UserExistInterface{<br/>    fun isUserExist(name: String): Boolean<br/>}</pre>
<p>In this interface, <kbd>isUserExist(username: String)</kbd> will search the <kbd>Profile</kbd> table of the database and return a <kbd>Boolean</kbd> based on the existing of the user. </p>
<p>Here is the code for the <kbd>UserExistRepository.kt</kbd> class:</p>
<pre>@Repository<br/>class UserExistRepository: UserExistInterface {<br/>    @Autowired<br/>    private lateinit var jdbcTemplate: JdbcTemplate<br/><br/>    override fun isUserExist(name: String): Boolean {<br/>        val sql = "SELECT count(*) FROM PROFILE WHERE username = ?"<br/>        val count = jdbcTemplate.queryForObject(sql, Int::class.java, name)<br/>        return count != 0<br/>    }<br/>}</pre>
<p>In this class, we add the <kbd>@Autowired</kbd> annotation to autowire the <kbd>JdbcTemplate</kbd> to utilize the JDBC database. We <kbd>override</kbd> the <kbd>issue exist(name: String)</kbd> function.</p>
<p><kbd>"SELECT count(*) FROM PROFILE WHERE username = ?"</kbd> is an SQL query that is used to search the existing users from the <kbd>Profile</kbd> table of the database. If there is a user, then it will return <kbd>true</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a controller</h1>
                
            
            
                
<p>Now, create a controller class named <kbd>AppController.kt</kbd> and annotate it with <kbd>@RestController</kbd> to convert it into a controller class:</p>
<pre><strong>@RestController<br/></strong>class AppController {<br/>    -----<br/>    -----<br/>}</pre>
<p>Now autowire the repositories, as shown in the following code:</p>
<pre>@Autowired<br/>private lateinit var profileRepository: ProfileRepository<br/><br/>@Autowired<br/>private lateinit var userExist: UserExistRepository<br/><br/>@Autowired<br/>private lateinit var postRepository: PostRepository<br/><br/>@Autowired<br/>private lateinit var commentRepository: CommentRepository<br/><br/>@Autowired<br/>private lateinit var likeRepository: LikeRepository<br/><br/>@Autowired<br/>private lateinit var deletePCLRepository : DeletePCLRepository</pre>
<p>Then create HTTP function requests. We won't discuss this here because we have already described the use of the HTTP requests in <a href="ee961da7-427b-4435-b7aa-6c5c541c89a6.xhtml" target="_blank">Chapter 4</a>, <em>Spring Modules for Android</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a profile's HTTP requests</h1>
                
            
            
                
<p>Now create HTTP function requests for the profiles. </p>
<p>Here is the function for creating a profile's <kbd>POST</kbd> request:</p>
<pre>// New Profile registration<br/><strong>@PostMapping("/profile/new")</strong><br/>fun registerUser(@RequestBody profile: Profile): Any {<br/>    if (!userExist.isUserExist(profile.username)) {<br/>        profile.password = passwordEncoder.encode(profile.password)<br/>        profileRepository.save(profile)<br/>        return profile<br/>    }<br/>    return "{\"duplicate\": \"${profile.username} is taken. Try another\"}"<br/>}</pre>
<p>Here is the function for creating a profile's <kbd>GET</kbd> request:</p>
<pre>// Get Profile by ID<br/><strong>@GetMapping("/profile/{id}")</strong><br/>fun getUserById(@PathVariable("id") id: Long): Any {<br/>    return profileRepository.findById(id)<br/>}</pre>
<p>Here is the function for creating a profile's <kbd>PUT</kbd> request:</p>
<pre>//     Update Profile by ID<br/><strong>@PutMapping("/profile/{id}")</strong><br/>fun updateUserById(@PathVariable("id") id: Long, @RequestBody mUser: Profile): Any {<br/>    val profile = profileRepository.getOne(id)<br/>    if (mUser.firstName != null) profile.firstName = mUser.firstName<br/>    if (mUser.lastName != null) profile.lastName = mUser.lastName<br/>    if (mUser.contactNumber != null) profile.contactNumber = mUser.contactNumber<br/>    if (mUser.city != null) profile.city = mUser.city<br/>    if (mUser.country != null) profile.country = mUser.country<br/>    return profileRepository.save(profile)<br/>}</pre>
<p>Here is the function for creating a profile's <kbd>DELETE</kbd> request:</p>
<pre>// Delete Profile by ID<br/><strong>@DeleteMapping("/profile/{userId}")</strong><br/>fun deleteUserById(@PathVariable("userId") userId: Long): Any {<br/>    deletePCLRepository.deleteAllUsersInfoByUserID(userId)<br/>    return profileRepository.deleteById(userId)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a post's HTTP requests</h1>
                
            
            
                
<p>Now create the HTTP request functions for the <kbd>Post</kbd>. </p>
<p>Here is the function for creating a post's <kbd>POST</kbd> request:</p>
<pre>// Post status by Profile ID<br/><strong>@PostMapping("/post/{profile_id}/new")</strong><br/>fun submitPost(@PathVariable("profile_id") profile_id: Long, @RequestParam text: String): Any {<br/>        val mPost = Post(text, Profile(profile_id))<br/>        postRepository.save(mPost)<br/><br/>        return mPost<br/>    }</pre>
<p>Here is the function for the creating a post's <kbd>GET</kbd> request to fetch all the posts:</p>
<pre>// Get all posted status<br/><strong>@GetMapping("/posts")</strong><br/>fun getPostList(): Any {<br/>    return postRepository.findAll()<br/>}</pre>
<p>Here is the function for creating a post's <kbd>GET</kbd> request to fetch one post:</p>
<pre>// Get all posted status by Profile ID<br/><strong>@GetMapping("/post/{id}")</strong><br/>fun getPostById(@PathVariable("id") id: Long): Any {<br/>    return postRepository.findById(id)<br/>}</pre>
<p>Here is the function for the creating a post's <kbd>PUT</kbd> request to update one post:</p>
<pre>// Update all posted status by Profile ID<br/><strong>    @PutMapping("/post/{profile_id}")</strong><br/>    fun updatePostById(@PathVariable("profile_id") id: Long, @RequestParam text: String): Any {<br/>        val modifiedPost = postRepository.getOne(id)<br/>        modifiedPost.text = text<br/>        return postRepository.save(modifiedPost)<br/>    }</pre>
<p>Here is the function for creating a post's  <kbd>DELETE</kbd> request:</p>
<pre>// Delete a posted status by Profile ID<br/><strong>@DeleteMapping("/post/{id}")</strong><br/>fun deletePostByUserId(@PathVariable("id") id: Long): Any {<br/>    return postRepository.deleteById(id)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a comment's HTTP requests</h1>
                
            
            
                
<p>Now create the HTTP request functions for the <kbd>Comment</kbd>. </p>
<p>Here is the function for creating a comment's <kbd>POST</kbd> request:</p>
<pre>// Post comment in a post by Profile ID and Post ID<br/>    @PostMapping("/comment/{post_id}")<br/>    fun postCommentByPostId(@PathVariable("post_id") postId: Long, @RequestParam id: Long, @RequestParam commentText: String): Any {<br/>        val optionalPost: Optional&lt;Post&gt; = postRepository.findById(postId)<br/>        return if (optionalPost.isPresent) {<br/>            val myComment = Comment(commentText, Profile(id))<br/>            val post = optionalPost.get()<br/>            post.comments.add(myComment)<br/>            postRepository.save(post)<br/>            return post<br/>        } else {<br/>            "There is no post.."<br/>        }<br/>    }</pre>
<p>First, we need to initialize an <kbd>optionalPost</kbd> object by finding the existing post. Then, if the post exists, we create a <kbd>Comment</kbd> model named <kbd>myComment</kbd>, then add the mutable list of <kbd>Comment</kbd>, and then save the post using <kbd>postRepository</kbd>.</p>
<p>Here is the function for creating a comment's <kbd>GET</kbd> request:</p>
<pre>// get comment List of a post<br/><strong>@GetMapping("/comment/{id}")</strong><br/>fun getCommentListByPostId(@PathVariable("id") id: Long): Any {<br/>    return commentRepository.findById(id)<br/>}</pre>
<p>Here is the function for creating a comment's <kbd>PUT</kbd> request:</p>
<pre>// get comment List of a post<br/><strong>@GetMapping("/comment/{id}")</strong><br/>fun getCommentListByPostId(@PathVariable("id") id: Long, @RequestParam text: String): Any {<br/>    val modifiedComment = commentRepository.getOne(id)<br/>    modifiedComment.text = text<br/>    return commentRepository.save(modifiedComment)<br/>}</pre>
<p>Here is the function for creating a comment's <kbd>DELETE</kbd> request:</p>
<pre>// delete comment List of a status<br/><strong>@DeleteMapping("/comment/{id}")</strong><br/>fun deleteCommentByPostId(@PathVariable("id") id: Long): Any {<br/>    return commentRepository.findById(id)<br/>}</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing security</h1>
                
            
            
                
<p>We are implementing basic authentication security. It will be similar to what we covered in <em><a href="d27e39f7-8dea-4796-9025-cfb8bc345283.xhtml">Chapter 5</a>, Securing Applications with Spring Security</em>. But there we used <strong><kbd>inMemoryAuthentication()</kbd></strong>, and here we will fetch the username and password from the database and implement them for the project using <kbd>UserDetailsService</kbd>:</p>
<ol>
<li>Create a service class named <kbd>CustomUserDetailsService.kt</kbd>.</li>
<li>Implement the <kbd>UserDetailsService</kbd> and annotated by <kbd>@Service</kbd> to make it a service class. Here is the code for this service class:</li>
</ol>
<pre style="padding-left: 60px">@Service<br/>class CustomUserDetailsService: UserDetailsService {<br/><br/> @Autowired<br/> private lateinit var userByNameRepository: UserByNameRepository<br/><br/> @Throws(UsernameNotFoundException::class)<br/> override fun loadUserByUsername(username: String): User {<br/> val profile = userByNameRepository.getUserByName(username)<br/><br/> return org.springframework.security.core.userdetails.User(username, profile.password,<br/> AuthorityUtils.createAuthorityList("USER"))<br/> }<br/>}</pre>
<ol start="3">
<li>Here, we autowire the <kbd>UserByNameRepository.kt</kbd> repository and override <kbd>loadUserByUsername(username: String)</kbd>. We will fetch the <kbd>username</kbd> and <kbd>password</kbd> from the repository and match them with the <kbd>username</kbd> and <kbd>password</kbd> given by the client. Here is the code for <kbd>UserByNameRepository.kt</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Repository<br/>class UserByNameRepository: UserByNameInterface {<br/> @Autowired<br/> private lateinit var jdbcTemplate: JdbcTemplate<br/><br/> override fun getUserByName(username: String): Profile {<br/> val sql = "SELECT * FROM PROFILE WHERE username = ?"<br/> val profile = jdbcTemplate.queryForObject(sql, UserRowMapper(), username)<br/><br/> return profile!!<br/> }<br/><br/> override fun getUserByNamePassword(username: String, password: String): Boolean {<br/> val sql = "SELECT * FROM PROFILE WHERE username = ?, password = ?"<br/> val profile = jdbcTemplate.queryForObject(sql, UserRowMapper(), username, password)<br/> return profile != null<br/> }<br/>}<br/><br/>interface UserByNameInterface {<br/> fun getUserByName(username: String): Profile<br/> fun getUserByNamePassword(username: String, password: String): Boolean<br/>}</pre>
<ol start="4">
<li> Now create the code for the <kbd>RowMapper</kbd> class of the user named <kbd>UserRowMapper.kt</kbd> to fetch the user details. Here is a piece of code from this class:</li>
</ol>
<pre style="padding-left: 60px">class UserRowMapper : RowMapper&lt;Profile&gt; {<br/><br/>    @Throws(SQLException::class)<br/>    override fun mapRow(row: ResultSet, rowNumber: Int): Profile? {<br/>        val profile = Profile(row.getLong("id"),<br/>                row.getString("username"),<br/>                row.getString("password"))<br/>        return profile<br/>    }<br/>}</pre>
<ol start="5">
<li>Let's create a <kbd>WebSecurityConfigurerAdapter</kbd> class named <kbd>SecurityConfigurer.kt</kbd> and annotate it with <kbd>@Configuration</kbd> and <kbd>@EnableWebSecurity</kbd> to make a configuration file and enable web security. Here is the code for the <kbd>SecurityConfigurer.kt</kbd> class:</li>
</ol>
<pre style="padding-left: 30px">@Configuration<br/>@EnableWebSecurity<br/>class SecurityConfigurer : WebSecurityConfigurerAdapter() {<br/><br/> @Autowired<br/> private lateinit var authEntryPoint: AuthenticationEntryPoint<br/><br/> @Autowired<br/> private lateinit var customUserDetailsService: CustomUserDetailsService<br/><br/> @Throws(Exception::class)<br/> override fun configure(http: HttpSecurity) {<br/> http.csrf().disable().authorizeRequests()<br/> .antMatchers("/profile/new").permitAll()<br/> .anyRequest()<br/> .authenticated()<br/> .and()<br/> .formLogin()<br/> .and()<br/> .httpBasic()<br/> .authenticationEntryPoint(authEntryPoint)<br/> }<br/><br/> @Autowired<br/> @Throws(Exception::class)<br/> fun configureGlobal(auth: AuthenticationManagerBuilder) {<br/> auth<br/> .userDetailsService(customUserDetailsService)<br/> .passwordEncoder(getPasswordEncoder())<br/> }<br/><br/> @Bean<br/> fun getPasswordEncoder(): PasswordEncoder {<br/> return object : PasswordEncoder {<br/> override fun encode(charSequence: CharSequence): String {<br/> return charSequence.toString()<br/> }<br/><br/> override fun matches(charSequence: CharSequence, s: String): Boolean {<br/> return true<br/> }<br/> }<br/> }<br/>}</pre>
<p>In the previous code, we've done the following:</p>
<ul>
<li>To use this registration URL path, <kbd>"/profile/new"</kbd>, any user can access. It doesn't need a <kbd>username</kbd> and <kbd>password</kbd>.</li>
<li>We use <kbd>PasswordEncoder</kbd> to encode the password.</li>
<li>We autowired <kbd>configureGlobal(auth: AuthenticationManagerBuilder)</kbd> and passed <kbd>CustomUserDetailsService</kbd> via <kbd>auth.userDetailsService(customUserDetailsService)</kbd> to check and match the username.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Modified application.properties</h1>
                
            
            
                
<p>The <kbd>application.properties</kbd> file is used to connect the database with the application and define how the database will behave. Here is the code for <kbd>application.properties</kbd>:</p>
<pre># ===============================<br/># DATABASE<br/># ===============================<br/><br/>spring.datasource.url=jdbc:mysql://localhost:3306/my_app_schema?useSSL=false&amp;allowPublicKeyRetrieval=true<br/>spring.datasource.username=root<br/>spring.datasource.password=12345678<br/><br/># ===============================<br/># JPA / HIBERNATE<br/># ===============================<br/>spring.jpa.show-sql=true<br/><br/># Hibernate ddl auto (create, create-drop, validate, update)<br/>spring.jpa.hibernate.ddl-auto = update<br/><br/>## Hibernate Properties<br/># The SQL dialect makes Hibernate generate better SQL for the chosen database<br/>spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect</pre>
<p>Here we have used the database named <kbd>my_app</kbd>, and the schema is <kbd>my_app_schema</kbd>. We disable <kbd>useSSL</kbd> with <kbd>useSSL=false</kbd>, and to retrieve the public key we use <kbd>allowPublicKeyRetrieval=true</kbd>.</p>
<p>Here, we use <kbd>spring.jpa.hibernate.ddl-auto = update</kbd>, which means after restarting your server the data won't be lost.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Client side</h1>
                
            
            
                
<p>After creating our backend, we need to create a client-based application to utilize the server. In this part, we will create an Android application as a client-based frontend application. To create the application, we need to make a design before starting coding. We will create an Android application and handle HTTP requests with the use of Retrofit.</p>
<p>First of all, we will design the workflow of the application. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the design</h1>
                
            
            
                
<p>To design our application, we have to keep in mind what the project is about and how the backend was designed. As we know, this is a mini-social-network-type app. So we have to create some model objects that are exactly the same as the server's model objects. In the application's workflow, we will have some layouts that will represent our applications.</p>
<p>The workflow is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e37b34b5-f16e-4419-b2ee-df7d626d109b.png" style="width:29.83em;height:33.17em;"/></p>
<p>Here are the brief of the workflow according to this diagram:</p>
<ul>
<li><strong>Login page</strong>: If you have a registered account, you can input the username and password to enter the application's main page. Or, if you are new, you need to go to the registration page and register an account.</li>
<li><strong>Registration page</strong>: This is for registering an account.</li>
<li><strong>Home activity</strong>: This is the main part of your application. </li>
</ul>
<ul>
<li><strong>Profile</strong>: You can see your details here.</li>
<li><strong>Status details</strong>: You can see the details of any post that you click on.</li>
</ul>
<p>So far, this project is based on these layouts. Now we need to create an Android application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a project</h1>
                
            
            
                
<p>To create a new project, go to Android Studio and click New Project. This time, select Android for Mobile<strong>,</strong> then select Basic Activity, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9b2c13e5-7bfe-445a-9368-10bc7dd5034b.png" style="width:47.92em;height:31.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing dependencies </h1>
                
            
            
                
<p>After building the project, add these dependencies in the <kbd>dependencies{}</kbd> block of <kbd>build.gradle (Module:app)</kbd>. These are for Material Design, Retrofit, and RxJava:</p>
<pre>// Design<br/>implementation 'com.android.support:design:28.0.0'<br/>implementation 'com.android.support:recyclerview-v7:28.0.0'<br/>implementation 'com.android.support:cardview-v7:28.0.0'<br/><br/>// Retrofit<br/>implementation "com.squareup.retrofit2:retrofit:$retrofit_version"<br/>implementation "com.squareup.retrofit2:converter-gson:$retrofit_version"<br/>implementation "com.squareup.retrofit2:adapter-rxjava2:$retrofit_version"<br/>implementation "com.squareup.retrofit2:retrofit-converters:$retrofit_version"<br/>implementation "com.squareup.retrofit2:retrofit-adapters:$retrofit_version"<br/>implementation "com.squareup.okhttp3:logging-interceptor:$okhttp3_version"<br/>implementation "com.google.code.gson:gson:$gson_version"<br/><br/>// Rx<br/>implementation 'io.reactivex.rxjava2:rxandroid:2.0.2'<br/>implementation 'io.reactivex.rxjava2:rxjava:2.2.0'</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating HomeActivity</h1>
                
            
            
                
<p>After creating the project, you will find <kbd>MainActivity</kbd>, but here we have renamed it as <kbd>HomeActivity.kt</kbd>, and the layout name is <kbd>activity_home</kbd>.</p>
<p>Now go to the activity, and here is the default code for this class:</p>
<pre>class HomeActivity : AppCompatActivity() {<br/><br/> override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main2)<br/>        setSupportActionBar(toolbar)<br/><br/>        fab.setOnClickListener { view -&gt;<br/>            Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)<br/>                .setAction("Action", null).show()<br/>        }<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the layout</h1>
                
            
            
                
<p>First, create a layout named <kbd>home_content.xml</kbd>, add <kbd>FrameLayout</kbd>, and add an <kbd>id</kbd> name. Here is the code for this XML file (you can see the full version on GitHub):</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.design.widget.CoordinatorLayout<br/>        xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:app="http://schemas.android.com/apk/res-auto"<br/>        xmlns:tools="http://schemas.android.com/tools"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        tools:context=".ui.MainActivity"&gt;<br/>    &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>                                                 xmlns:app="http://schemas.android.com/apk/res-auto"<br/>                                                 xmlns:tools="http://schemas.android.com/tools"<br/>                                                 android:layout_width="match_parent"<br/>                                                 android:layout_height="match_parent"<br/>                                                 tools:context=".ui.MainActivity"&gt;<br/><br/>      ----<br/>----<br/><br/>        &lt;android.support.v7.widget.RecyclerView<br/>                android:id="@+id/displayList"<br/>                android:layout_width="0dp"<br/>                android:layout_height="0dp"<br/>                app:layout_constraintEnd_toEndOf="parent"<br/>                app:layout_constraintStart_toStartOf="parent"<br/>                tools:listitem="@layout/post_item"<br/>                app:layout_constraintBottom_toBottomOf="parent"<br/>                app:layout_constraintHorizontal_bias="0.0" android:layout_marginTop="8dp"<br/>                app:layout_constraintTop_toBottomOf="@+id/appBarLayout"/&gt;<br/><br/>    &lt;/android.support.constraint.ConstraintLayout&gt;<br/><br/><br/>    &lt;android.support.design.widget.FloatingActionButton<br/>            android:id="@+id/fabMain"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            android:layout_gravity="bottom|end"<br/>            android:layout_margin="@dimen/fab_margin"<br/>            app:srcCompat="@android:drawable/ic_dialog_email"/&gt;<br/>&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating models</h1>
                
            
            
                
<p>To create the models, we need to keep the same model items as the backend. But we will also include the <kbd>Gson</kbd> annotation, <kbd>@SerializedName</kbd>. The value of the <kbd>@SerializedName</kbd> annotation is used when serializing and deserializing objects. Here, <kbd>@SerializedName("username")</kbd> is stating that this is the name of the <kbd>Username</kbd> in the JSON. Though we implement the Gson, you can call these model classes as the response of the API. That means when this application requests the server and fetches the content, then this content will be returned with the help of these model classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating profile model</h1>
                
            
            
                
<p>Create a <kbd>Profile</kbd> data class named <kbd>Profile.kt</kbd>, and here is the sample code:</p>
<pre>data class Profile(<br/>    @SerializedName("id") var userID: String,<br/>    @SerializedName("username") var username: String,<br/>    @SerializedName("password") var password: String,<br/>    @SerializedName("email") var email: String,<br/>    @SerializedName("accCreatedTime") var accCreatedTime: String,<br/>    @SerializedName("firstName") var firstName: String,<br/>    @SerializedName("lastName") var lastName: String,<br/>    @SerializedName("contactNumber") var contactNumber: String,<br/>    @SerializedName("country") var country: String<br/>    )</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating post model</h1>
                
            
            
                
<p>Create a <kbd>Post</kbd> data class named <kbd>Post.kt</kbd>, and here is the sample code:</p>
<pre>data class Post(<br/>    @SerializedName("id") var postId: Long?,<br/>    @SerializedName("text") var text: String?,<br/>    @SerializedName("postedBy") var profile: Profile?,<br/>    @SerializedName("accCreatedTime") var accCreatedTime: String?,<br/>    @SerializedName("comments") var comment: ArrayList&lt;Comment&gt;?,<br/>    @SerializedName("likes") var likes: ArrayList&lt;Like&gt;?<br/>)</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a comment model</h1>
                
            
            
                
<p>Create a comment data class named <kbd>Comment.kt</kbd>, and here is the sample code:</p>
<pre>data class Comment (<br/>    @SerializedName("id") var comment: Long?,<br/>    @SerializedName("text") var text: String?,<br/>    @SerializedName("postedBy") var profile: Profile?,<br/>    @SerializedName("accCreatedTime") var accCreatedTime: String?<br/>    )</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating services</h1>
                
            
            
                
<p>This is the most important section. This will send the <kbd>GET</kbd> request to the server to fetch the data from the server. First of all, we will create the services of the model classes. We will create the HTTP request functions using the Retrofit annotation, which are explained in the section called <em>HTTP Request Functions</em> in <a href="ee961da7-427b-4435-b7aa-6c5c541c89a6.xhtml" target="_blank">Chapter 4</a>, <em>Spring Modules for Android</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the profile service</h1>
                
            
            
                
<p>According to our server, we have four <kbd>HTTP</kbd> requests for the profile. So we will create three <kbd>HTTP</kbd> requests using the Retrofit annotations. Now create an interface named <kbd>ProfileService.kt</kbd>, and here is the code:</p>
<p> </p>
<pre>interface ProfileService {<br/><br/>    // New Profile registration<br/>    @Headers("Content-Type: application/json")<br/>    @POST("/profile/new")<br/>    fun registerProfile(@Body profile: Profile): Observable&lt;Profile&gt;<br/><br/>    @Headers("Content-Type: application/json")<br/>    @GET("/profile/login")<br/>    fun loginProfile(@Query("username") username: String, @Query("password") password: String): Observable&lt;Profile&gt;<br/><br/>    // Get All Profiles<br/>    @Headers("Content-Type: application/json")<br/>    @GET("/profiles")<br/>    fun getUserList(): Observable&lt;List&lt;Profile&gt;&gt;<br/><br/>   // Get Profile by ID<br/>    @GET("/profile/{userId}")<br/>    fun getUserById(@Path("userId") userId: Long): Observable&lt;Profile&gt;<br/>}</pre>
<p>Based on the preceding code, here are the brief details of the functions:</p>
<ul>
<li><kbd>registerProfile(@Body profile: Profile)</kbd> registers a new profile. You need to pass a project object.</li>
<li><kbd>getUserList() </kbd> gets all the profiles.</li>
<li><kbd>getUserById(@Query("userId") userId: Long)</kbd> gets a profile. You need to pass a user ID.</li>
</ul>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the post service</h1>
                
            
            
                
<p>According to our server, we have three <kbd>HTTP</kbd> requests for the profile. So we will create three <kbd>HTTP</kbd> requests using the Retrofit annotations. Now create an interface named <kbd>ProfileService.kt</kbd>, and here is the code:</p>
<pre>interface PostService {<br/>    @Headers("Content-Type: application/json")<br/>    @POST("/post/{profile_id}/new")<br/>    fun submitNewPost(@Path("profile_id") id: Long, @Query("text") text: String): Observable&lt;List&lt;Post&gt;&gt;<br/><br/><br/>    // Get all posted status<br/>    @Headers("Content-Type: application/json")<br/>    @GET("/posts")<br/>    fun getPostList(): Single&lt;List&lt;Post&gt;&gt;<br/><br/><br/>    // Get all posted status by Profile ID<br/>    @Headers("Content-Type: application/json")<br/>    @GET("/post/{id}")<br/>    fun getPostById(@Path("id") id: Long): Observable&lt;Post&gt;<br/><br/>}</pre>
<p>Based on the preceding code, here is a brief description of the functions:</p>
<ul>
<li><kbd>submitNewPost(@Query("id") id: Long, @Field("text") text: String)</kbd> submits a new post, and to submit the new post, you need to pass the user ID and the text.</li>
<li class="mce-root"><kbd>getPostList()</kbd> gets all the posts.</li>
<li class="mce-root"><kbd>getPostById(@Query("id") id: Long)</kbd> gets a post. You need to pass a post ID.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the comment service</h1>
                
            
            
                
<p>To handle the comment REST APIs, we will create two <kbd>HTTP</kbd> requests. So we will create two <kbd>POST</kbd> and <kbd>DELETE</kbd> requests using the Retrofit annotations. Now create an interface named <kbd>PostService.kt</kbd>, and here is the code:</p>
<pre>interface CommentService {<br/>    // Post comment in a post by Profile ID and Post ID<br/>    @POST("/comment/{user_id}/{post_id}")<br/>    fun postCommentByPostId(@Path("post_id") postId: Long, @Path("user_id") userId: Long,<br/>                            @Query("commentText") commentText: String): Observable&lt;Post&gt;<br/><br/><br/>    // Delete comment in a post by Profile ID and Post ID<br/>    @DELETE("/comment/{user_id}/{post_id}")<br/>    fun deleteCommentByPostId(@Path("post_id") postId: Long, @Path("user_id") userId: Long,<br/>                              @Query("commentText") commentText: String): Observable&lt;Post&gt;<br/>}<br/><br/></pre>
<p><kbd>postCommentByPostId(@Path("post_id") postId: Long, @Path("user_id") userId: Long,</kbd><br/>
<kbd>@Query("commentText") commentText: String)</kbd>  is a <kbd>POST</kbd> request function, and it submits a new comment. You need to pass the <kbd>user_id</kbd>, <kbd>post_id</kbd>, and the text.</p>
<p><kbd>deleteCommentByPostId(@Path("post_id") postId: Long, @Path("user_id") userId: Long,</kbd><br/>
<kbd>@Query("commentText") commentText: String)</kbd> is a <kbd>DELETE</kbd> request function, and it deletes the comment. You need to pass the <kbd>user_id</kbd> and <kbd>post_id</kbd>.</p>
<p>So far, all the requests have been created, and now we need to create an API service that will hit the server and fetch the JSON. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an API service</h1>
                
            
            
                
<p>We explained this procedure in <a href="ee961da7-427b-4435-b7aa-6c5c541c89a6.xhtml" target="_blank">Chapter 4,</a> <em>Spring Modules for Android</em>. So we will just show you the code and explain the new features. Create an object named <kbd>APIService.kt</kbd> and add <kbd>gsonConverter()</kbd> and <kbd>getOkhttpClient(username, password)</kbd>:</p>
<pre>object APIService{<br/>   fun getRetrofitBuilder(username:String, password:String): Retrofit {<br/>       return Retrofit.Builder()<br/>           .client(getOkhttpClient(username, password))<br/>           .baseUrl(Constants.API_BASE_PATH)<br/>           .addCallAdapterFactory(RxJava2CallAdapterFactory.create())<br/>           .addConverterFactory(gsonConverter())<br/>           .build()<br/>    }<br/><br/>    fun gsonConverter(): GsonConverterFactory {<br/>        return GsonConverterFactory<br/>            .create(<br/>                GsonBuilder()<br/>                    .setLenient()<br/>                    .disableHtmlEscaping()<br/>                    .create()<br/>            )<br/>    }<br/><br/>    fun getOkhttpClient(profileName: String, password: String): OkHttpClient {<br/>        return OkHttpClient.Builder()<br/>            .addInterceptor(BasicAuthInterceptor(profileName, password))<br/>            .connectTimeout(30, TimeUnit.SECONDS)<br/>            .readTimeout(60, TimeUnit.SECONDS)<br/>            .build()<br/>    }<br/>}</pre>
<p>If you're confused about <kbd>addInterceptor(BasicAuthInterceptor(profileName, password))</kbd>, then please go to <a href="d27e39f7-8dea-4796-9025-cfb8bc345283.xhtml"><em>Chapter</em> 5</a>, <em>Securing Applications with Spring Security</em>, and check out the section called <em>Authenticating with OkHttp interceptors</em>. </p>
<p>Now we need to initialize the <kbd>RetrofitBuilder</kbd> functions of the services. We have four service interfaces, and now we will create four <kbd>RetrofitBuilder</kbd> functions for them. Add this code in the <kbd>APIService.kt</kbd> file:</p>
<pre>// get profile request builder<br/>fun profileAPICall(username:String, password:String) = getRetrofitBuilder(username, password)<br/>    .create(ProfileService::class.java)<br/><br/>// get post request builder<br/>fun postAPICall(username:String, password:String) = getRetrofitBuilder(username, password)<br/>    .create(PostService::class.java)<br/><br/>// get comment request builder<br/>fun commentAPICall(username:String, password:String) = getRetrofitBuilder(username, password)<br/>    .create(CommentService::class.java)</pre>
<p>Now we will work for the frontend, which means the activities and layouts. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a login activity</h1>
                
            
            
                
<p>This is the first activity of the app. When users enter the app it will be the first thing they see. For the user, they need to go to the register activity to register a new profile. After the registration, they will get access to the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the layout</h1>
                
            
            
                
<p>Create an empty activity named <kbd>LoginActivity.kt</kbd>, and a layout named <kbd>activity_login.xml</kbd>. Here is the code in the <kbd>xml</kbd> (you will find the full version of this layout on GitHub):</p>
<pre>------<br/>------<br/>&lt;android.support.v7.widget.CardView<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:layout_alignParentEnd="true"<br/>        android:layout_alignParentStart="true"<br/>        android:layout_centerHorizontal="true"<br/>        android:background="@color/reg_body"<br/>        app:layout_constraintTop_toTopOf="parent" app:layout_constraintStart_toStartOf="parent"<br/>        android:layout_marginBottom="64dp" app:layout_constraintBottom_toBottomOf="parent"<br/>        android:layout_marginStart="32dp" app:layout_constraintEnd_toEndOf="parent" android:layout_marginEnd="32dp"<br/>        android:id="@+id/cardView"&gt;<br/><br/><br/>    &lt;android.support.constraint.ConstraintLayout<br/>            android:layout_width="match_parent"<br/>            android:layout_height="match_parent"<br/>            app:layout_constraintEnd_toEndOf="parent"<br/>            app:layout_constraintBottom_toBottomOf="parent"<br/>            app:layout_constraintStart_toStartOf="parent"<br/>            app:layout_constraintTop_toTopOf="parent"<br/>            app:layout_constraintHorizontal_bias="0.0"<br/>            app:layout_constraintVertical_bias="1.0" android:layout_marginEnd="24dp"<br/>            android:layout_marginTop="32dp"<br/>            android:layout_marginStart="24dp" android:layout_marginBottom="32dp"&gt;<br/>        &lt;TextView<br/>                android:id="@+id/LogIn"<br/>                android:layout_width="wrap_content"<br/>                android:layout_height="wrap_content"<br/>                android:layout_alignParentTop="true"<br/>                android:layout_centerHorizontal="true"<br/>                android:text="@string/title_login"<br/>                android:textSize="30sp"<br/>                android:textStyle="bold"<br/>                android:typeface="monospace" app:layout_constraintEnd_toEndOf="parent"<br/>                android:layout_marginEnd="8dp" app:layout_constraintStart_toStartOf="parent"<br/>                app:layout_constraintTop_toTopOf="parent" android:layout_marginStart="8dp"<br/>                android:layout_marginTop="8dp"/&gt;<br/>------<br/>------<br/> &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content"<br/>                    android:text="@string/title_login"<br/>                    android:id="@+id/reg_submit"<br/><br/>                    app:layout_constraintTop_toBottomOf="@+id/password_title_reg"<br/>                    app:layout_constraintStart_toStartOf="parent" app:layout_constraintEnd_toEndOf="parent"<br/>                    android:layout_marginEnd="32dp" android:layout_marginStart="32dp"<br/>                    android:layout_marginTop="64dp"/&gt;<br/>------<br/>------ </pre>
<p>Here we have user input for <kbd>Username</kbd> and <kbd>Password</kbd>. In this layout, we have also one button to log in and one <kbd>TextView</kbd> to go to the <kbd>RegistrationActivity</kbd>.</p>
<p>Here is the image preview of this layout:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/95aa2770-ea38-426d-bb91-00ff75a02e04.png" style="width:23.75em;height:42.58em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying activity</h1>
                
            
            
                
<p>Go to the <kbd>LogInActivity.kt</kbd> file, where we will input the login information. The user needs to provide a <kbd>username</kbd> and a <kbd>password</kbd>. Then this information will be searched in the <kbd>Profile</kbd> table of the server database. If there are the same <kbd>username</kbd> and <kbd>password</kbd> in this <kbd>Profile</kbd> table, you will be able to enter the <kbd>MainActivity</kbd>, or you will get an error message. If you are a new user, you can click New Member? to register a new profile.</p>
<p>First, we will check <kbd>SharedPreferences</kbd> to see if we have the saved <kbd>username</kbd> and <kbd>password</kbd>. It will show in the username and password fields, or it will remain blank so you can input the values. Here is the function of this logic:</p>
<pre>override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.activity_login)<br/><br/>   setUsernamePassword()<br/> }<br/><br/>private fun setUsernamePassword() {<br/> if (PrefUtils.getUsername(this) != null<br/> || PrefUtils.getPassword(this) != null) {<br/> username_input_login.setText(PrefUtils.getUsername(this))<br/> password_input_login.setText(PrefUtils.getPassword(this))<br/> }<br/>}</pre>
<p>Now set the <kbd>OnClickListener()</kbd> listener function in the <kbd>TextView</kbd> named <kbd>need_reg</kbd>, which will take us to the <kbd>RegistrationActivity</kbd>. Here is the code for this function:</p>
<pre>need_reg.setOnClickListener {<br/>    val intent = Intent(this, RegistrationActivity::class.java)<br/>    startActivity(intent)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Login request</h1>
                
            
            
                
<p>Now we will create a function named <kbd>logInUser()</kbd>, which will send a <kbd>POST</kbd> request to the server and match the <kbd>username</kbd> and <kbd>password</kbd>. In return of failed, it gets an error and shows the error message, or it will take to to the <kbd>MainActivity</kbd>.  Here is the function:</p>
<pre>private fun logInUser(){<br/><br/>    APIClient.profileAPICall(username_input_login.text.toString(), password_input_login.text.toString())<br/>        .loginProfile(username_input_login.text.toString(),password_input_login.text.toString() )<br/>        .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .subscribe({<br/>                newUser -&gt;<br/>            if(newUser.error != null){<br/>                Toast.makeText(applicationContext,newUser.error!!, Toast.LENGTH_SHORT).show()<br/>            }else {<br/>                PrefUtils.storeUsernameID(this, newUser.userID!!)<br/>                PrefUtils.storeUsername(this, newUser.username!!)<br/>                PrefUtils.storePassword(this, newUser.password!!)<br/>                username_input_login.setText(PrefUtils.getUsername(this))<br/>                password_input_login.setText(PrefUtils.getPassword(this))<br/>                val intent = Intent(this, MainActivity::class.java)<br/>                startActivity(intent)<br/>            }<br/>        },{<br/>                error -&gt;<br/>            Toast.makeText(applicationContext,R.string.err_login_msg, Toast.LENGTH_SHORT).show()<br/>            Log.wtf("******", error.message.toString())<br/>        })<br/>}</pre>
<p>Here, we store the <kbd>username</kbd>, <kbd>password</kbd>, and <kbd>userID</kbd> if we get the correct response.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the registration activity</h1>
                
            
            
                
<p>Create an activity for registration named <kbd>RegistrationActivity.kt</kbd>, where we will register a new account. Before modifying the code, we need to modify the layout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying layout</h1>
                
            
            
                
<p>Create a layout for <kbd>RegistrationActivity.kt</kbd> named <kbd>activity_registration.xml</kbd>. Here I have added a UI, so please look at the full version of this file on GitHub. Here is a piece of code from this file:</p>
<pre> &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content"<br/>                        android:text="@string/title_reg"<br/>                        android:id="@+id/reg_submit" android:layout_marginTop="32dp"<br/>                        app:layout_constraintTop_toBottomOf="@+id/country_title_reg"<br/>                        app:layout_constraintStart_toStartOf="parent" android:layout_marginStart="32dp"<br/>                        app:layout_constraintEnd_toEndOf="parent" android:layout_marginEnd="32dp"/&gt;<br/><br/>          -----<br/>          -----<br/><br/>            &lt;/android.support.constraint.ConstraintLayout&gt;<br/>        &lt;/ScrollView&gt;<br/>    &lt;/android.support.v7.widget.CardView&gt;<br/><br/>&lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>Here is the image preview of this layout:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/52a502f9-35b9-40c3-96c3-25fa55930784.png" style="width:19.75em;height:35.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the activity</h1>
                
            
            
                
<p>Here is the code for <kbd>RegistrationActivity</kbd>:</p>
<pre>class RegistrationActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_registration)<br/><br/>    }<br/>}</pre>
<p>Now add some logic to validate the <kbd>username</kbd>, <kbd>password</kbd>, and <kbd>email id</kbd>. Here is the code:</p>
<pre><br/>private <strong>fun </strong><strong>validateName(): Boolean</strong> {<br/>    if (username_input_reg.text.toString().trim().isEmpty()) {<br/>        username_title_reg.error = getString(R.string.err_msg_name)<br/>        requestFocus(username_input_reg)<br/>        return false<br/>    } else {<br/>        username_title_reg.isErrorEnabled = false<br/>    }<br/><br/>    return true<br/>}<br/><br/>private <strong>fun </strong><strong>validateEmail(): Boolean</strong> {<br/>    if (email_input_reg.text.toString().trim().isEmpty() || !isValidEmail(email_input_reg.text.toString().trim())) {<br/>        email_title_reg.error = getString(R.string.err_msg_email)<br/>        requestFocus(email_input_reg)<br/>        return false<br/>    } else {<br/>        email_title_reg.isErrorEnabled = false<br/>    }<br/><br/>    return true<br/>}<br/><br/>private fun <strong>validatePassword(): Boolean</strong> {<br/>    if (password_input_reg.text.toString().trim().isEmpty()<br/>    || con_password_input_reg.text.toString().trim().isEmpty()) {<br/><br/>        if (password_input_reg.text.toString().trim()<br/>            == con_password_input_reg.text.toString().trim()){<br/>            password_title_reg.error = getString(R.string.err_match_password)<br/>            requestFocus(password_title_reg)<br/>        }<br/><br/>        password_title_reg.error = getString(R.string.err_msg_password)<br/>        requestFocus(password_title_reg)<br/>        return false<br/>    } else {<br/>        password_title_reg.isErrorEnabled = false<br/>    }<br/><br/>    return true<br/>}</pre>
<p>Add a <kbd>TextWatcher</kbd> inner class, which will send an alert if there is any invalid input:</p>
<pre>private inner class MyTextWatcher (private val view: View) : TextWatcher {<br/><br/>    override fun beforeTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}<br/><br/>    override fun onTextChanged(charSequence: CharSequence, i: Int, i1: Int, i2: Int) {}<br/><br/>    override fun afterTextChanged(editable: Editable) {<br/>        when (view.id) {<br/>            R.id.username_input_reg -&gt; validateName()<br/>            R.id.email_input_reg -&gt; validateEmail()<br/>            R.id.input_password -&gt; validatePassword()<br/>        }<br/>    }<br/>}</pre>
<p>When the <kbd>username</kbd>, <kbd>password</kbd>, or the <kbd>email id</kbd> is invalid, it will show an alert.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Registering a new profile </h1>
                
            
            
                
<p>Now we will create a function called <kbd>registerUser()</kbd>, which will help you to send requests to the server and fetch the output from the server. We will show you how to use RxJava in <a href="1b0061a5-8853-487a-9f44-cb18940046a2.xhtml" target="_blank">Chapter 8</a>, <em>Reactive Programming</em>, and Retrofit in <a href="ee961da7-427b-4435-b7aa-6c5c541c89a6.xhtml" target="_blank">Chapter 4</a>, <em>Spring Modules for Android</em>. Here is the code for <kbd>registerUser()</kbd>:</p>
<pre>private fun registerUser(){<br/>    val newProfile = Profile(null,<br/>        username_input_reg.text.toString(),<br/>        password_input_reg.text.toString(),<br/>        email_input_reg.text.toString(),<br/>        null,<br/>        first_name_input_reg.text.toString(),<br/>        last_name_input_reg.text.toString(),<br/>        contact_input_reg.text.toString(),<br/>        country_input_reg.text.toString())<br/>        <br/>        APIClient.profileAPICall("","")<br/>        .registerProfile(newProfile)<br/>        .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .<strong>subscribe</strong>({<br/>                newUser -&gt;<br/>           if(newUser.duplicate != null){<br/>                    Toast.makeText(applicationContext,newUser.duplicate!!, Toast.LENGTH_SHORT).show()<br/>                }else {<br/>                    PrefUtils.storeUsernameID(this, 1)<br/>                    PrefUtils.storeUsername(this, username)<br/>                    PrefUtils.storePassword(this, password)<br/>                    val intent = Intent(this, LoginActivity::class.java)<br/>                    startActivity(intent)<br/>                }<br/><br/>        },{<br/>                error -&gt;<br/>                            Toast.makeText(applicationContext,error.message.toString(), Toast.LENGTH_SHORT).show()<br/><br/><br/>        })<br/>}</pre>
<p>Here, we will take the contents from <kbd>EditText</kbd> and create a <kbd>Profile</kbd> object. Then we take an observer that will fetch the profile list as JSON type and handle the updated list in the <kbd>subscribe()</kbd> function. If the result is complete, it will return in the first parameter, and then we will save the <kbd>username</kbd>, <kbd>password</kbd>, and <kbd>userID</kbd> locally using <kbd>SharedPreferences</kbd> and return to <kbd>LoginActivity</kbd>. If it throws an error, it will go to the second parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the main activity</h1>
                
            
            
                
<p>This is our home page. Here, you can see all the posts. We need to modify our layout and the activity class.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the layout</h1>
                
            
            
                
<p>The layout of <kbd>MainActivity</kbd> is in the <kbd>activity_main.xml</kbd> file. Here, we have added <kbd>RecyclerView</kbd> to show the list, one <kbd>FabButton</kbd> to submit the post, and a <kbd>TextView</kbd> to show if there is no post available. Here is a piece of the code:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.design.widget.CoordinatorLayout<br/>        xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:app="http://schemas.android.com/apk/res-auto"<br/>        xmlns:tools="http://schemas.android.com/tools"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        tools:context=".ui.MainActivity"&gt;<br/>-----<br/>-----<br/><br/>&lt;android.support.v7.widget.RecyclerView<br/> android:id="@+id/displayList"<br/> android:layout_width="0dp"<br/> android:layout_height="0dp"<br/> app:layout_constraintEnd_toEndOf="parent"<br/> app:layout_constraintStart_toStartOf="parent"<br/> tools:listitem="@layout/post_item"<br/> app:layout_constraintBottom_toBottomOf="parent"<br/> app:layout_constraintHorizontal_bias="0.0" android:layout_marginTop="8dp"<br/> app:layout_constraintTop_toBottomOf="@+id/appBarLayout"/&gt;<br/> &lt;/android.support.constraint.ConstraintLayout&gt;<br/>     &lt;android.support.design.widget.FloatingActionButton<br/>     android:id="@+id/fabMain"<br/>     android:layout_width="wrap_content"<br/>     android:layout_height="wrap_content"<br/>     android:layout_gravity="bottom|end"<br/>     android:layout_margin="@dimen/fab_margin"<br/>     app:srcCompat="@android:drawable/ic_dialog_email"/&gt;<br/>&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the activity</h1>
                
            
            
                
<p>Go to <kbd>MainAcitivty.kt</kbd>. Here, we have <kbd>RecycleView</kbd> and the post adapter. We will add a global <kbd>List&lt;Post&gt;</kbd> and set the <kbd>recycleView</kbd> in the <kbd>onCreate()</kbd> function like this:</p>
<pre>private var postList: List&lt;Post&gt; = listOf()<br/><br/>override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.activity_main)<br/>        displayList.layoutManager = LinearLayoutManager(this)<br/>        displayList.setHasFixedSize(true)<br/>        postRecycleViewAdapter = PostRecycleViewAdapter(this, postList)<br/>        displayList.adapter = postRecycleViewAdapter<br/>}</pre>
<p>Here, we have initialized the <kbd>PostRecycleViewAdapter</kbd> named <kbd>postRecycleViewAdapter</kbd> and set the adapter into the list named <kbd>displayList</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching a post</h1>
                
            
            
                
<p>We will fetch all the posts using the <kbd>getAllPosts()</kbd> function. This function will send a request to the server to get all the post list. In return, we will get the updated list named <kbd>newPostList</kbd> and pass using <kbd>setItems(newPostList)</kbd> to <kbd>PostRecycleViewAdapter</kbd> and notify with <kbd>notifyDataSetChanged()</kbd>. For the error handling, we have used toast. Here is the code of the <kbd>getAllPosts()</kbd> function:</p>
<pre>private fun getAllPosts() {<br/>        APIClient.postAPICall(PrefUtils.getUsername(this)!!, PrefUtils.getPassword(this)!!)<br/>        .getPostList()<br/>            .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .subscribe({<br/>            newPostList -&gt;<br/>            <strong>postRecycleViewAdapter.setItems(newPostList)</strong><br/><strong>            postRecycleViewAdapter.notifyDataSetChanged()</strong><br/>        },{<br/>                error -&gt;<br/>       Toast.makeText(applicationContext, error.message.toString(), Toast.LENGTH_SHORT).show()<br/>        })<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Submitting a post</h1>
                
            
            
                
<p>When you press the fab button we will see an alert box where you can input your status using <kbd>submitPost()</kbd>. In return, we get the post list named <kbd>newPostList</kbd> and pass the list to the <kbd>setItems(newPostList)</kbd> of the <kbd>PostRecycleViewAdapter</kbd> to replace with the older post list with the new one. Lastly, notify with <kbd>notifyDataSetChanged()</kbd>, and the <kbd>RecycleView</kbd> list will be updated.</p>
<p>Here is the code for the <kbd>submitPost()</kbd> function:</p>
<pre>private fun submitPost(id: Long, text: String){<br/>    APIClient.postAPICall(PrefUtils.getUsername(this)!!, PrefUtils.getPassword(this)!!)<br/>        .submitNewPost(id, text)<br/>        .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .subscribe({<br/>                newPostList -&gt;<br/>            postRecycleViewAdapter.setItems(newPostList)<br/>            postRecycleViewAdapter.notifyDataSetChanged()<br/>        },{<br/>                error -&gt;<br/>      Toast.makeText(applicationContext, error.message.toString(), Toast.LENGTH_SHORT).show()<br/>        })<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the menu</h1>
                
            
            
                
<p>To show the profile details and update a post, we will add two icons on the <kbd>Toolbar</kbd>. To do this, we need to create a toolbar file. Create a menu file in <kbd>res &gt; menu</kbd> named <kbd>menu_main.xml</kbd>. There we will add two items, one for profile and one for updating a post.</p>
<p>Here is the code for <kbd>menu_main.xml</kbd>:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt;<br/>    &lt;item<br/>            android:id="@+id/profileMenu"<br/>            android:icon="@drawable/ic_face_white_24dp"<br/><strong>            app:showAsAction="always"<br/></strong>            android:title="@string/title_profile"&gt;<br/>    &lt;/item&gt;<br/>    &lt;item<br/>            android:id="@+id/postUpdate"<br/>            android:icon="@drawable/ic_autorenew_white_24dp"<br/><strong>            app:showAsAction="always"<br/></strong>            android:title="@string/title_update"&gt;<br/>    &lt;/item&gt;<br/>&lt;/menu&gt;</pre>
<p>We have used <kbd>app:showAsAction="always"</kbd>, and it means the items will always show on the toolbar.</p>
<p>Now implement it in <kbd>MainAcitivy.kt</kbd>. To do this, we need to override two functions, and these are <kbd>onCreateOptionsMenu()</kbd> and <kbd>onOptionsItemSelected()</kbd>. </p>
<p>We will bind the <kbd>menu_main</kbd> menu XML file using <kbd>menuInflater.inflate()</kbd> in <kbd>onCreateOptionsMenu()</kbd>, and we will write down the logic for every menu item in the <kbd>onOptionsItemSelected()</kbd>:</p>
<pre>    override fun onCreateOptionsMenu(menu: Menu): Boolean {<br/>        menuInflater.inflate(R.menu.menu_main, menu)<br/>        return true<br/>    }<br/><br/>    override fun onOptionsItemSelected(item: MenuItem?): Boolean {<br/>        when (item!!.itemId) {<br/>            R.id.profileMenu -&gt; {<br/>                val intent = Intent(this, ProfileActivity::class.java)<br/>                startActivity(intent)<br/>            }<br/>            R.id.postUpdate -&gt; {<br/>                getAllPosts()<br/>            }<br/>        }<br/>        return true<br/>    }</pre>
<p><kbd>R.id.profileMenu</kbd> will take you to the <kbd>ProfileActivity</kbd> class.</p>
<p><kbd>R.id.postUpdate</kbd> will update the post using <kbd>getAllPosts()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the post adapter</h1>
                
            
            
                
<p>Now we need to modify our post adapter class. It will help us to show the post in a nice structure. Our post adapter name is <kbd>PostRecycleViewAdapter</kbd>, and the layout name is <kbd>post_item</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying post adapter layouts</h1>
                
            
            
                
<p>To utilize the post adapter, we need to create an <kbd>xml</kbd> file named <kbd>post_item.xml</kbd>, and here we will implement the UI. Here is a piece of the code (the entire code can be found on GitHub):</p>
<pre>----<br/>----<br/>        &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content"<br/>                  tools:text="@tools:sample/date/ddmmyy"<br/>                  android:id="@+id/postedDate"<br/>                  android:textAppearance="?android:textAppearanceSmall"<br/>                  app:layout_constraintTop_toBottomOf="@+id/profileName"<br/>                  app:layout_constraintStart_toStartOf="@+id/profileName"<br/>                  android:layout_marginTop="4dp"<br/>                  app:layout_constraintBottom_toBottomOf="parent" android:layout_marginBottom="4dp"/&gt;<br/>    &lt;/android.support.constraint.ConstraintLayout&gt;<br/><br/>    &lt;TextView android:layout_width="0dp" android:layout_height="wrap_content"<br/>              tools:text="@tools:sample/lorem"<br/>              android:id="@+id/postText"<br/>              android:padding="4dp"<br/>              android:textAppearance="?android:textAppearanceSmall"<br/>              app:layout_constraintStart_toStartOf="parent"<br/>              app:layout_constraintEnd_toEndOf="parent" android:layout_marginTop="4dp"<br/>              app:layout_constraintTop_toBottomOf="@+id/constraintLayout"/&gt;<br/>----<br/>----</pre>
<p>We have four <kbd>TextView</kbd> for user full name, username, posted time, and the post text. </p>
<p>Here is a sample image from the preview option of the layout:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fb178a79-ec83-42f3-a5aa-51abdd7d08cf.png" style="width:24.58em;height:10.75em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the adapter for posts</h1>
                
            
            
                
<p>Let's create a custom <kbd>RecycleView</kbd> adapter named <kbd>PostRecycleViewAdapter.kt</kbd> to display the post list. We have shown you how to create custom adapters in <a href="ee961da7-427b-4435-b7aa-6c5c541c89a6.xhtml">Chapter 4</a>, <em>Spring Modules for Android</em>, so we won't repeat it. Here is the <kbd>PostRecycleViewAdapter</kbd> class:</p>
<pre>class PostRecycleViewAdapter(private var context: Context,<br/>                       private val postList: List&lt;Post&gt;):<br/>RecyclerView.Adapter&lt;PostRecycleViewAdapter.ViewHolder&gt;() {<br/>-----<br/>-----<br/>}</pre>
<p>Now create the <kbd>ViewHolder</kbd> class and initialize all the content of the <kbd>post_item</kbd> layout in <kbd>PostRecycleViewAdapter.kt</kbd>, as shown in the following code:</p>
<pre>class ViewHolder(view: View): RecyclerView.ViewHolder(view){<br/>    val postRoot = view.findViewById(R.id.postRoot) as ConstraintLayout<br/><br/>    val profileFullName = view.findViewById(R.id.profileFullNamePost) as TextView<br/>    val username = view.findViewById(R.id.usernamePost) as TextView<br/>    val postedDate = view.findViewById(R.id.postedDate) as TextView<br/>    val postText = view.findViewById(R.id.postText) as TextView<br/>}</pre>
<p>Now override <kbd>onCreateViewHolder()</kbd> and return the <kbd>ViewHolder</kbd> class:</p>
<pre>override fun onCreateViewHolder(viewGroup: ViewGroup, p1: Int): ViewHolder {<br/>    val layoutInflater = LayoutInflater.from(context).inflate(R.layout.post_item, viewGroup, false)<br/>    return ViewHolder(layoutInflater)<br/>}</pre>
<p>Now, we need to set the value in every raw of the list based on its position. To do this, override the <kbd>onBindViewHolder()</kbd> function and add this code:</p>
<pre>override fun onBindViewHolder(viewHolder: ViewHolder, position: Int) {<br/><br/>    val userDetails = postList[position]<br/><br/>    viewHolder.profileFullName.text = "${userDetails.profile!!.firstName} ${userDetails.profile!!.lastName} "<br/>    viewHolder.username.text = userDetails.profile!!.username<br/>    viewHolder.postedDate.text = userDetails.postCreatedTime<br/>    viewHolder.postText.text = userDetails.text<br/><br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the profile layout</h1>
                
            
            
                
<p>This layout will help to get the profile details from the users. Open <kbd>activity_profile.xml</kbd> and modify it as follows (please check GitHub for the full layout code):</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/><br/>    &lt;!--full name--&gt;<br/><br/>    &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content"<br/>              android:id="@+id/profileFullNameTitlePro"<br/>              android:textStyle="bold"<br/>              android:text="@string/title_full_names"<br/>              android:textAppearance="?android:textAppearanceSmall"<br/>              android:layout_marginStart="8dp"<br/>              app:layout_constraintStart_toStartOf="parent" android:layout_marginTop="32dp"<br/>              app:layout_constraintTop_toBottomOf="@+id/usernamePro" android:layout_marginEnd="8dp"<br/>              app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.0"/&gt;<br/><br/>    &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content"<br/>              tools:text="@tools:sample/full_names"<br/>              android:id="@+id/profileFullNamePro"<br/>              android:textAppearance="?android:textAppearanceSmall"<br/>              app:layout_constraintTop_toTopOf="@+id/profileFullNameTitlePro"<br/>              app:layout_constraintBottom_toBottomOf="@+id/profileFullNameTitlePro"<br/>              app:layout_constraintEnd_toEndOf="parent"<br/>              android:layout_marginEnd="160dp"<br/>              app:layout_constraintVertical_bias="1.0"/&gt;<br/>    <br/>------<br/>------<br/>&lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>Here we have one <kbd>TextView</kbd> for the username, a <kbd>TextView</kbd> for each profile item label name, and four for the profile contents of <kbd>Full Name</kbd>, <kbd>Email</kbd>, <kbd>Contact Number</kbd>, and <kbd>Country</kbd>.</p>
<p>Here is the preview of the <strong>Profile</strong> details:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/102bb590-8d0d-4201-87e6-bc0854b5aab0.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying a profile activity</h1>
                
            
            
                
<p>Create a new activity called <kbd>ProfileActivity.kt</kbd>, and here is the code:</p>
<pre>class ProfileActivity : AppCompatActivity() {<br/><br/>        private var username: String = ""<br/>    private var password: String = ""<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_profile)<br/>        setTitleName() <br/><br/>        username = PrefUtils.getUsername(this)!!<br/>        password = PrefUtils.getPassword(this)!!<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching the profile details</h1>
                
            
            
                
<p>To fetch the profile details, we need to create a function named <kbd>getUser()</kbd> in which we will call <kbd>getUserById()</kbd> from the <kbd>Profile</kbd> services. In return, it will provide the user details, or if there is an error, it will show the error message. Here is the code of the <kbd>getUserById()</kbd> function:</p>
<pre>private fun getUser(){<br/>        APIClient.profileAPICall(username,password)<br/>            .getUserById(PrefUtils.getUsernameID(this)!!)<br/>            .subscribeOn(Schedulers.io())<br/>            .observeOn(AndroidSchedulers.mainThread())<br/>            .subscribe({<br/>                    myUser -&gt;<br/><br/>                usernamePro.text = myUser.username<br/>                profileFullNamePro.text = "${myUser.firstName} ${myUser.lastName}"<br/>                emailPro.text = myUser.email<br/>                contactNumberPro.text = myUser.contactNumber<br/>                countryPro.text = myUser.country<br/>            },{<br/>                    error -&gt;<br/>                UtilMethods.hideLoading()<br/>                Log.wtf("******", error.message.toString())<br/>            })<br/>    }</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Post details activity</h1>
                
            
            
                
<p>Now we will need our last activity, <kbd>PostDetailsActivity.kt</kbd>, and the layout is in <kbd>activity_post_details.xml</kbd>. In this activity, you will see a specific post and its comments. You can also post a comment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the post details layout</h1>
                
            
            
                
<p>This view will show specific post details. Here is a piece of code from <kbd>activity_post_details.xml</kbd>:</p>
<pre>-----<br/>----<br/>&lt;android.support.v7.widget.RecyclerView<br/>        android:id="@+id/displayList_com"<br/>        android:layout_width="0dp"<br/>        android:layout_height="0dp"<br/>        tools:listitem="@layout/post_item"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintEnd_toEndOf="parent" app:layout_constraintTop_toBottomOf="@+id/postRoot_pd"<br/>        android:layout_marginBottom="8dp" app:layout_constraintBottom_toBottomOf="parent"<br/>        android:layout_marginStart="16dp" android:layout_marginEnd="16dp" android:layout_marginTop="8dp"/&gt;<br/><br/>&lt;android.support.constraint.ConstraintLayout<br/>        android:layout_width="match_parent"<br/>        android:id="@+id/postRoot_pd"<br/>        android:layout_height="wrap_content"<br/>        android:layout_marginTop="8dp"<br/>        app:layout_constraintTop_toBottomOf="@+id/appBarLayout_pd" app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent" android:layout_marginEnd="8dp"<br/>        android:layout_marginStart="8dp"&gt;<br/>-----<br/>----</pre>
<p>Here we have a post's details and its list of comments. </p>
<p>The preview of this layout is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5aaa0cab-5202-4ad3-abd0-ae6a0d3b97a9.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the post details activity</h1>
                
            
            
                
<p>This is an activity where will handle a specific post. This post will be fetched by a <kbd>postId</kbd>, and we will get this through the intent that is sent from <kbd>PostRecycleViewAdapter</kbd>. To get the intent view, we need to use <kbd>intent.extras</kbd>. We use <kbd>Long</kbd> with the <em>key name</em> of  <kbd>"postId"</kbd>, as shown in the following code:</p>
<pre>private var postId:Long = -1<br/><br/>if(intent.extras!=null){<br/>    postId = intent.extras.getLong("postId")<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching post details</h1>
                
            
            
                
<p>Now create a function called <kbd>getPostById(id: Long)</kbd>, and we will pass the given <kbd>postId</kbd> from <kbd>MainActivity</kbd>. We will handle all the value in the specific <kbd>TextView</kbd>, such as <kbd>MainActivity</kbd>:</p>
<pre>@SuppressLint("CheckResult")<br/>private fun getPostById(id: Long){<br/>    UtilMethods.showLoading(this)<br/>    APIClient.postAPICall(PrefUtils.getUsername(this)!!, PrefUtils.getPassword(this)!!)<br/>        .getPostById(id)<br/>        .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .subscribe({<br/>                post -&gt;<br/>            postText_pd.text = post.text<br/>            profileFullNamePost_pd.text = "${post.profile!!.firstName} ${post.profile!!.lastName}"<br/>            usernamePost_pd.text = post.profile!!.username<br/>            postedDate_pd.text = SimpleDateFormat(Constants.TIME_FORMAT).format(post.postCreatedTime!!)<br/><br/>            commentList = post.comment!!<br/><br/>            Log.wtf("******", commentList.toString())<br/>            commentRecycleViewAdapter.setItems(commentList)<br/>            commentRecycleViewAdapter.notifyDataSetChanged()<br/><br/>            UtilMethods.hideLoading()<br/>        },{<br/>                error -&gt;<br/>            UtilMethods.hideLoading()<br/>            Log.wtf("******", error.message.toString())<br/>            Toast.makeText(applicationContext, error.message.toString(), Toast.LENGTH_SHORT).show()<br/>        })<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Submitting comment</h1>
                
            
            
                
<p>To submit a comment, click <kbd>fabButton</kbd> and enter a comment. The system of comment submission is similar to the post submission system. We create a function named <kbd>submitComment(id: Long, text: String)</kbd> and use it to submit the comment. Here is the <kbd>submitComment()</kbd> function: </p>
<pre>@SuppressLint("CheckResult")<br/>private fun submitComment(id: Long, text: String){<br/>    UtilMethods.showLoading(this)<br/>    APIClient.commentAPICall(PrefUtils.getUsername(this)!!, PrefUtils.getPassword(this)!!)<br/>        .postCommentByPostId(id, PrefUtils.getUsernameID(this)!!,text)<br/>        .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .subscribe({<br/>                newPostList -&gt;<br/>            commentList = newPostList.comment!!<br/><br/>            Log.wtf("******", commentList.toString())<br/>            commentRecycleViewAdapter.setItems(commentList)<br/>            commentRecycleViewAdapter.notifyDataSetChanged()<br/>            UtilMethods.hideLoading()<br/>        },{<br/>                error -&gt;<br/>            UtilMethods.hideLoading()<br/>            Log.wtf("******", error.message.toString())<br/>            Toast.makeText(applicationContext, error.message.toString(), Toast.LENGTH_SHORT).show()<br/>        })<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the comment adapter</h1>
                
            
            
                
<p>This adapter is the same as the Post adapter. Check the Modifying Post Adapter, Modifying Post Adapter Layouts to modify this comment adapter. The name of this adapter is <kbd>CommentRecycleViewAdapter.kt</kbd> and the layout is <kbd>comment_item.xml</kbd>.</p>
<p>Our project is complete! Now it's time to check the output of the server and the client.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking the output</h1>
                
            
            
                
<p>To check our output, first, run the server from the <kbd>Social_Network</kbd> Spring project. Then you can run two different emulators or Android devices as client users.</p>
<p>Now open the Android app. Click the New Member? button to create a new account. Fill in all the required details and click the Registration button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6a1b2168-c00e-4f59-87de-0aa54bd5d8a1.png"/></p>
<p>If the username is already taken, then it will alert you like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fd12e35a-0a4a-401d-964e-dfa6c03742a8.png" style="width:29.92em;height:52.25em;"/></p>
<p class="mce-root"/>
<p>Now if you press the Profile button, the second left on the toolbar, you will see the Profile details. If you press the Update button, the top-left icon of the toolbar, your post will update, as you can see in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c216e8a0-fbeb-48c7-8da4-b996eb8898b9.png" style="width:44.25em;height:26.00em;"/></p>
<p>Click on any post and you will see the specific post, and you can add a comment using the Fab button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c7516fca-33cd-4ee3-84a7-c04ce4f6a4e5.png" style="width:46.92em;height:20.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We are at end of this long journey. Now your client application is ready to use. Here you can post a status, see the posted status, check the details of the post, and put comments on that post. We have shown you how to use the server and handle the resources from the server in an Android application. You can find some minor functions and layouts on GitHub that may be helpful with this application. We recommend you create another application with your own imagination and deploy it. That will be more effective, and you can learn more about what you want to learn. There are lots of alternative ways to handle HTTP requests, and so you can learn more. If you want to learn more, have a look at the <em>Further reading</em> section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>After a long journey, we have finished this chapter. Here we have seen how to create a server side and a client side complete application using all the modules of the previous chapters, such as Spring Security and database. You can modify this project in your own style. You can implement new architecture and implement new frameworks. In this chapter, first, we learned about the design of a project. Then we created the database model for our project. After creating the database model, we created our server-side project and implemented the dependencies. Then we created the models based on the database model. Then we created the repositories and the controller. In the controller, we created the HTTP request functions. Then we implemented the security. We used basic authentication from Spring Security. Then we modified application.properties to connect to the MySQL database. After finishing the server side, we started to create the Android application. We created the workflow of the application. Then we created the models of the users, posts, and comments. Then we created the API services and requests. After the backend, we developed the layouts and activities. In the activities, we called the HTTP request using Retrofit and RxJava. Then we modified the UI classes and layouts of the application. Lastly, we tested the output of the project.</p>
<p>In <a href="9ce60363-adfb-4e1c-89f4-ec573a89657d.xhtml">Chapter 10</a>, <em>Testing an Application</em>, you will learn how to use the JUnit framework to unit test the Spring project and the UI testing using the Espresso in the Android application.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the EER diagram?</li>
<li>What are CRUD operations?</li>
<li>What type of tools can be used as the HTTP client?</li>
<li>Currently, what are the minimum, maximum, and targeted API versions for Android?</li>
<li>What are the common names of the Android architecture?</li>
<li>What are the names of emulators to develop Android applications?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li>
<p><em>Building Applications with Spring 5 and Kotlin </em>(<a href="https://www.packtpub.com/application-development/building-applications-spring-5-and-kotlin">https://www.packtpub.com/application-development/building-applications-spring-5-and-kotlin</a>) by Miloš Vasić</p>
</li>
<li>
<p><em>Spring MVC – Beginner's Guide - Second Edition</em> (<a href="https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition">https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition</a>) by Amuthan Ganeshan</p>
</li>
<li>
<p><em>Android Development with Kotlin</em> (<a href="https://www.packtpub.com/application-development/android-development-kotlin">https://www.packtpub.com/application-development/android-development-kotlin</a>) by Marcin Moskala, Igor Wojda</p>
</li>
<li>
<p><em>Kotlin for Android Developers [Video]</em> (<a href="https://www.packtpub.com/application-development/kotlin-android-developers-video">https://www.packtpub.com/application-development/kotlin-android-developers-video</a>) by Yusuf Saber</p>
</li>
</ul>


            

            
        
    </body></html>