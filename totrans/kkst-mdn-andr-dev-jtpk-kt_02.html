<html><head></head><body>
		<div><h1 id="_idParaDest-13"><em class="italic"><a id="_idTextAnchor012"/>Chapter 1</em>: Creating a Modern UI with Jetpack Compose</h1>
			<p>Jetpack libraries enable you to build and design high-quality, robust Android apps that have a reliable architecture and work consistently across different versions and devices. At the same time, the Jetpack suite allows you to eliminate boilerplate code and ultimately focus on what matters – building the necessary features.</p>
			<p>In this chapter, we<a id="_idIndexMarker000"/> will tackle one of the most popular Jetpack libraries for building <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>), called <strong class="bold">Compose</strong>. Simply put, Jetpack Compose is a powerful modern toolkit that allows you to build a native UI in Android directly with Kotlin functions and APIs.</p>
			<p>Compose accelerates and greatly simplifies UI development as it harnesses the power of declarative programming, combined with the ease of use of the Kotlin programming language. The new toolkit solely relies on Kotlin APIs when allowing you to construct UIs through declarative functions.</p>
			<p>By the end of this chapter, you will know how building UIs on Android can be done with less code, powerful tools, intuitive APIs, and without the need for additional languages such as XML.</p>
			<p>In the first section, <em class="italic">Understanding the core concepts of Compose</em>, we will explore the fundamental concepts behind Compose and understand how they are beneficial in helping us write better and cleaner UIs. We will see how UIs can be described with composable functions while also understanding how the new declarative way of building UIs on Android works. We will also explore how composition is favored over inheritance and how the data flow works in Compose. Finally, we will cover what recomposition is and see how essential it is to our declarative UI.</p>
			<p>In the second section, <em class="italic">Exploring the building blocks of Compose UIs</em>, we will study the most important composable functions that Compose provides out of the box. Afterward, we will see how we can preview our Compose UI and how activities render it.</p>
			<p>We will then put our knowledge to good use by creating our first Compose project about restaurants in the <em class="italic">Building a Compose-based screen</em> section. In the last section, entitled <em class="italic">Exploring lists with Compose</em>, we will learn how to correctly show more content in Compose with the help of lists.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the core concepts of Compose</li>
				<li>Exploring the building blocks of Compose UIs</li>
				<li>Building a Compose-based screen</li>
				<li>Exploring lists with Compose<p class="callout-heading">Note</p><p class="callout">As Compose is a dedicated native UI framework, we will only briefly cover the core concepts, common components, and usages of the toolkit without going into advanced topics.</p></li>
			</ul>
			<h1 id="_idParaDest-14"><a id="_idTextAnchor013"/>Technical requirements</h1>
			<p>When building Compose-based Android projects, you usually require your day-to-day tools for Android development. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>The Kotlin 1.6.10 or newer plugin must be installed in Android Studio.</li>
				<li>Jetpack Compose 1.1.1 or greater. You should follow this chapter and use the projects with this version. You can explore newer versions if you wish, though API differences might arise.</li>
			</ul>
			<p>You can find the GitHub repository containing the source code for this book here: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_01">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/</a>.</p>
			<p>To access the code presented in this chapter, navigate to the <code>Chapter_01</code> directory. The code snippets presented in the first two sections can be found in the <code>ExamplesActivity.kt</code> file, which is located in the root directory. The project coding solution for the Restaurants app, which we will develop in the last few sections of this chapter, can be found in the <code>chapter_1_restaurants_app</code> Android project directory.</p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Understanding the core concepts of Compose</h1>
			<p>Jetpack Compose dramatically changes the way we write UIs on Android. UIs are now developed with Kotlin, which enables a <a id="_idIndexMarker001"/>new declarative paradigm<a id="_idIndexMarker002"/> of writing layouts with widgets called <strong class="bold">composables</strong>.</p>
			<p>In this section, we will understand what composable functions are and how they are used to write UIs. We will learn how the programming paradigm has shifted and how composition is now enforced, thereby increasing flexibility in the way we define UIs. We will also discuss the flow of data within UIs and what recomposition is while trying to understand the benefits that are brought by these new concepts.</p>
			<p>To summarize, we will be covering the following topics:</p>
			<ul>
				<li>Describing UIs with composable functions</li>
				<li>The paradigm shift in creating UIs on Android</li>
				<li>Favoring composition over inheritance</li>
				<li>Unidirectional flow of data</li>
				<li>Recomposition</li>
			</ul>
			<p>So, let's get started.</p>
			<h2 id="_idParaDest-16"><a id="_idTextAnchor015"/>Describing UIs with composable functions</h2>
			<p>Compose<a id="_idIndexMarker003"/> allows you to build UIs by defining and calling <code>@Composable</code> annotation that represent widgets on the screen.</p>
			<p>Compose works with the help of a Kotlin compiler plugin in the type checking and code generation phase of Kotlin. The Compose compiler plugin makes sure that you can create composables.</p>
			<p>For example, a composable that displays a piece of text may look like this:</p>
			<pre>@Composable
fun FriendlyMessage(name: String) {
   Text(text = "Greetings $name!")
}</pre>
			<p>In the preceding code block, we've defined the <code>FriendlyMessage</code> composable function by annotating it with the <code>@Composable</code> annotation. Looking at the function definition and body, we can easily deduce that it displays a greeting message.</p>
			<p>It's important to note that any function annotated with <code>@Composable</code> can be rendered on the <a id="_idIndexMarker004"/>screen as it will produce a piece of UI hierarchy that displays content. In their true sense, composable functions emit UI widgets based on their definition. </p>
			<p>In our case, the previous function should display a greeting message by concatenating the <code>String</code> value it receives as a parameter with a predefined message. As the function relies on its input parameters to show different messages on every usage, it's correct to say that composable functions are functions of data (presented as <strong class="bold">F(data)</strong> in the following diagram) that are converted into pieces of UI or widgets:</p>
			<div><div><img src="img/B17788_01_01.jpg" alt="Figure 1.1 – In Compose, UI is a function of data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – In Compose, UI is a function of data</p>
			<p>Later, in the <em class="italic">Unidirectional flow of data</em> subsection, we will understand why having functions to describe UI widgets is beneficial to our projects as it leads to a less bug-prone UI layer.</p>
			<p>Getting back to our<a id="_idIndexMarker005"/> example, you might be wondering what the <code>Text</code> functional call represents. As with every other framework, Compose provides composable functions such as <code>Text</code> out of the box that we can use.</p>
			<p>As its name suggests, the <code>Text</code> composable allows you to display some text on the screen. We will cover other composable functions provided by Compose in the <em class="italic">Exploring the building blocks of Compose UIs</em> section.</p>
			<p>Until then, let's have another look at the previous code example and highlight the most important rules when it comes to defining a composable function:</p>
			<ul>
				<li>It should be a regular function marked with the <code>@Composable</code> annotation. </li>
				<li>Its UI output is defined by the data that's received through its input parameters. Composable functions should return <code>Unit</code> as they emit UI elements and do not return data as regular functions do. Most of the time, we omit defining the <code>Unit</code> return type or even returning <code>Unit</code> – as Kotlin marks it as redundant – just like in the previous example.</li>
				<li>It can contain other composable functions or regular Kotlin code. In the previous example, the <code>FriendlyMessage</code> composable function makes use of another composable, called <code>Text</code>, but it could also call regular Kotlin code (we will tackle that in the upcoming sections).</li>
				<li>It should be named as a noun or a noun preceded by a suggestive adjective (but never a verb). This way, composable functions envision widgets and not actions. Additionally, its name should respect the PascalCase naming convention, meaning that the first letter of each compound word in a variable is capitalized.</li>
				<li>It's recommended that the function is public and not defined within a class but directly within a Kotlin file. This way, Compose promotes the reuse of composable functions. </li>
			</ul>
			<p>Now that we<a id="_idIndexMarker006"/> understand what a composable function is and how one is defined, let's move on and explore the paradigm shift that Compose brings to Android UI development.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>The paradigm shift in creating UIs on Android</h2>
			<p>Compose brings a<a id="_idIndexMarker007"/> new approach to Android UI development and that is providing a declarative way of describing your UI. Before trying to understand how the declarative approach works, we will learn how the traditional View System relies on a different paradigm – the imperative one.</p>
			<h3>The imperative paradigm</h3>
			<p>When describing your UI <a id="_idIndexMarker008"/>with XML, you represent the view<a id="_idIndexMarker009"/> hierarchy as a tree of widgets that are commonly known as views. Views, in the context of the traditional View System, are all the components that inherit from the <code>android.view.View</code> class, from <code>TextView</code>, <code>Button</code>, or <code>ImageView</code> to <code>LinearLayout</code>, <code>RelativeLayout</code>, and so on.</p>
			<p>Yet what's essential for the View System is the <em class="italic">imperative paradigm</em> that it relies on. Because your application must know how to react to user interactions and change the state of the UI accordingly, you can mutate the state of your views by referencing them through <code>findViewById</code> calls and then update their values through calls such as <code>setText()</code>, <code>setBackgroundResource()</code>, and so on.</p>
			<p>Since views maintain their internal state and expose setters and getters, you must imperatively set new states for each component, as the following diagram suggests:</p>
			<div><div><img src="img/B17788_01_02.jpg" alt="Figure 1.2 – The Android View System features in the imperative paradigm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – The Android View System features in the imperative paradigm</p>
			<p>Manually manipulating views' states increases the chance of bugs and errors in your UI. Because you end up treating multiple possible states and because chunks of data are displayed in several such <a id="_idIndexMarker010"/>states, it's relatively easy to mess up the outcome of your UI. Illegal states or conflicts between states can also arise relatively easily when your UI grows in complexity.</p>
			<p>Moreover, since the layouts are defined in an additional component – that is, an XML file – the coupling between <code>Activity</code>, <code>Fragment</code>, or <code>ViewModel</code> and the XML-based UI increases. This means that changing something on the UI in the XML file will often lead to changes in <code>Activity</code>, <code>Fragment</code>, or <code>ViewModel</code> classes, which is where state handling happens. Not only that but cohesion is reduced because of language differences: one component is in Java/Kotlin, while the other one is in XML. This means that for the UI to function, it needs not only an <code>Activity</code> or <code>Fragment</code> but also XML.</p>
			<h3>The declarative paradigm</h3>
			<p>To address some <a id="_idIndexMarker011"/>of the issues within the standard View System, Compose relies on a modern declarative UI model, which drastically simplifies the process of building, updating, and maintaining UIs on Android.</p>
			<p>If, in the traditional View System, the imperative paradigm described <em class="italic">how</em> the UI should change, in Compose, the declarative paradigm describes <em class="italic">what</em> the UI should render at a certain point in time.</p>
			<p>Compose does that by defining the screen as a tree of composables. As in the following examples, each composable passes<a id="_idIndexMarker012"/> data to its nested composables, just like the <code>FriendlyMessage</code> composable passed a name to the <code>Text</code> composable in our code example from the previous section:</p>
			<div><div><img src="img/B17788_01_03.jpg" alt="Figure 1.3 – Visualizing a tree of composable widgets and how data is passed downwards&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Visualizing a tree of composable widgets and how data is passed downwards</p>
			<p>When the input arguments change, Compose regenerates the entire widget tree from scratch. It applies the necessary changes and eliminates the need and the associated complexity of manually updating each widget.</p>
			<p>This means that in Compose, composables are relatively stateless and because of that, they don't expose getter and setter methods. This allows the caller to react to interactions and handle the process of creating new states separately. It does that by calling the same composables but with different argument values. As we discussed in the <em class="italic">Describing UIs with composable functions</em> section, the UI in Compose is a function of data. From this, we can conclude that if new data is passed to composables, new UI states can be produced.</p>
			<p>Lastly, compared to the View System, Compose only relies on Kotlin APIs, which means that UIs can now be defined with a single technology, in a single component, thereby increasing cohesion and reducing coupling.</p>
			<p>Now, let's look at another shift in design brought by Compose and discuss how composition yields more flexible ways of defining UIs than inheritance does. </p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Favoring composition over inheritance</h2>
			<p>In the Android View<a id="_idIndexMarker013"/> System, every view inherits functionality from the parent <code>View</code> class. As the system relies solely on inheritance, the task of creating custom views can only be done through defining elaborate hierarchies.</p>
			<p>Let's take the <code>Button</code> view as an example. It inherits functionality from <code>TextView</code>, which, in turn, inherits from <code>View</code>:</p>
			<div><div><img src="img/B17788_01_04.jpg" alt="Figure 1.4 – The class inheritance hierarchy for the Button view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – The class inheritance hierarchy for the Button view</p>
			<p>This strategy is great for reusing functionality, but inheritance becomes difficult to scale and has little flexibility when trying to have multiple variations of one view. </p>
			<p>Say you want the <code>Button</code> view to render an image instead of text. In the View System, you would have to create an entirely new inheritance hierarchy, as shown in the following hierarchy diagram:</p>
			<div><div><img src="img/B17788_01_05.jpg" alt="Figure 1.5 – The class inheritance hierarchy for the ImageButton view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – The class inheritance hierarchy for the ImageButton view</p>
			<p>But what if you need a button that accommodates both a <code>TextView</code> and an <code>ImageView</code>? This task would be extremely challenging, so it's easy to conclude that having separate inheritance hierarchies for each custom view is neither flexible nor scalable. </p>
			<p>These examples are real, and they show the limitations of the View System. As we've previously seen, one of the biggest reasons for the lack of flexibility is the inheritance model of the View System.</p>
			<p>To address this issue, <em class="italic">Compose favors composition over inheritance</em>. As shown in the following <a id="_idIndexMarker014"/>diagram, this means that Compose builds more complex UIs by using smaller pieces and not by inheriting functionality from one single parent:</p>
			<div><div><img src="img/B17788_01_06.jpg" alt="Figure 1.6 – Inheritance versus composition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Inheritance versus composition</p>
			<p>Let's try to briefly explain our previous comparison between inheritance and composition:</p>
			<ul>
				<li>With inheritance, you are limited to inheriting your parent, just like <code>Button</code> inherits only from <code>TextView</code>.</li>
				<li>With composition, you can compose multiple other components, just like the <code>Button</code> composable contains both an <code>Image</code> composable and a <code>Text</code> composable, thereby giving you much more flexibility in building UIs.</li>
			</ul>
			<p>Let's try to build a composable that features a button with an image and text. This was a huge challenge with inheritance, but Compose simplifies this by allowing you to compose an <code>Image</code> composable and a <code>Text</code> composable inside a <code>Button</code> composable: </p>
			<pre>@Composable
fun SuggestiveButton() {
    Button(onClick = { }) {
        Row() {
            Image(painter = 
                     painterResource(R.drawable.drawable),
                  contentDescription = "")
            Text(text = "Press me")
        }
    }
}</pre>
			<p>Now, our <code>SuggestiveButton</code> composable contains both <code>Image</code> and <code>Text</code> composables. The beauty of this is that it could contain anything else. A <code>Button</code> composable can accept other <a id="_idIndexMarker015"/>composables that it renders as part of its button's body. Don't worry about this aspect or about that weird composable called <code>Row</code> for now. The <em class="italic">Exploring the building blocks of Compose UIs</em> section will cover both of these aspects in more detail. </p>
			<p>What's important to remember from this example is that Compose gives us the flexibility of building a custom UI with ease. Next, let's cover how data and events flow in Compose.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Unidirectional flow of data</h2>
			<p>Knowing that each <a id="_idIndexMarker016"/>composable passes data down to its children composables, we can deduct that the internal state is no longer needed. This also translates into a unidirectional flow of data because composables only expect data as input and never care about their state:</p>
			<div><div><img src="img/B17788_01_07.jpg" alt="Figure 1.7 – Visualizing the unidirectional flow of data and events&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Visualizing the unidirectional flow of data and events</p>
			<p>Similarly, with data, each composable passes down callback functions to its children composables. Yet this time, the callback functions are caused by user interactions, and they create an upstream of callbacks that goes from each nested composable to its parent and so on. This means that not only the data is unidirectional but also events, just in opposite ways.</p>
			<p>From this, it's clear that data and events travel only in one direction, and that's a good thing because only one source of truth – ideally, <code>ViewModel</code> – is in charge of handling them, resulting in<a id="_idIndexMarker017"/> fewer bugs and easier maintenance as the UI scales.</p>
			<p>Let's consider a case with another composable provided by Jetpack Compose called <code>Button</code>. As its name suggests, it emits a button widget on the screen, and it exposes a callback function called <code>onClick</code> that notifies us whenever the user clicks the button.</p>
			<p>In the following example, our <code>MailButton</code> composable receives data as an email identifier, <code>mailId</code>, and an event callback as a <code>mailPressedCallback</code> function:</p>
			<pre>@Composable
fun MailButton(
    mailId: Int,
    mailPressedCallback: (Int) -&gt; Unit
) {
    Button(onClick = { mailPressedCallback(mailId) }) {
        Text(text = "Expand mail $mailId")
    }
}</pre>
			<p>While it consumes the data it receives via <code>mailId</code>, it also sets the  <code>mailPressedCallback</code> function to be called every time its button is clicked, thereby sending the event back up to its parent. This <a id="_idIndexMarker018"/>way, data flows downwards and the callback flows upwards.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is ideal to construct your Compose UI in such a way that data provided by the <code>ViewModel</code> flows from parent composables to children composables and events flow from each composable back up to the <code>ViewModel</code>. If you're not familiar with the <code>ViewModel</code> component, don't worry as will cover it in the upcoming <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Recomposition</h2>
			<p>We have already covered how <a id="_idIndexMarker019"/>composable functions are defined by their input data and stated that whenever the data changes, composables are rebuilt as they render a new UI state corresponding to the newly received data.</p>
			<p>The process of calling your composable functions again when inputs change is called <strong class="bold">recomposition</strong>. When<a id="_idIndexMarker020"/> inputs change, Compose automatically triggers the recomposition process for us and rebuilds the UI widget tree, redrawing the widgets emitted by the composables so that they display the newly received data. </p>
			<p>Yet recomposing the entire UI hierarchy is computationally expensive, which is why Compose only calls the functions that have new input while skipping the ones whose input hasn't changed. Optimizing<a id="_idIndexMarker021"/> the process of rebuilding the composable tree is a complex job and is usually referred to as <em class="italic">intelligent recomposition</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the traditional View System, we would manually call the setters and getters of views, but with Compose, it's enough to provide new arguments to our composables. This will allow Compose to initiate the recomposition process for parts of the UI so that the updated values are displayed.</p>
			<p>Before jumping into an actual example of recomposition, let's have a quick look at the lifecycle of a composable function. Its lifecycle is defined by the composition lifecycle, as shown here:</p>
			<div><div><img src="img/B17788_01_08.jpg" alt="Figure 1.8 – The composition lifecycle of a composable function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – The composition lifecycle of a composable function</p>
			<p>This means that a composable first enters composition, and before leaving this process, it can recompose as many times as needed – that is, before it disappears from the screen, it can be recomposed and rebuilt many times, each time possibly displaying a different value.</p>
			<p>Recomposition is often<a id="_idIndexMarker022"/> triggered by changes within <code>State</code> objects, so let's look at an example to explore how seamlessly this happens with little intervention from our side. Say you have a <code>TimerText</code> composable that expects a certain number of elapsed <code>seconds</code> that it displays in a <code>Text</code> composable. The timer starts from 0 and updates every 1 second (or 1,000 ms), displaying the number of seconds that have elapsed:</p>
			<pre>var seconds by mutableStateOf(0)
val stopWatchTimer = timer(period = 1000) { seconds++ }
   ...
@Composable
fun TimerText(seconds: Int) {
   Text(text = "Elapsed: $seconds")
}</pre>
			<p>In the <em class="italic">Defining and handling state with Compose</em> section of <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>, we will define the state in Compose in more detail, but until then, let's think of <code>seconds</code> as a simple state object (instantiated with <code>mutableStateOf()</code>) that has an initial value of <code>0</code> and that its value changes over time, triggering a recomposition each time.</p>
			<p>Every time <code>stopWatchTimer</code> increases the value of the <code>seconds</code> state object, Compose triggers a recomposition that rebuilds the widget tree and redraws the composables with new arguments.</p>
			<p>In our case, <code>TimerText</code> will be recomposed or rebuilt because it receives different arguments – the first time, it will receive <code>0</code>, then <code>1</code>, <code>2</code>, and so on. This, in turn, triggers the <code>Text</code> composable to also recompose and that's why Compose redraws it on the screen to display the <a id="_idIndexMarker023"/>updated message.</p>
			<p>Recomposition is a complex topic. As we will not be able to go into too much depth on it now, it's important to also cover more advanced concepts, as described in the documentation: <a href="https://developer.android.com/jetpack/compose/mental-model#any-order">https://developer.android.com/jetpack/compose/mental-model#any-order</a>.</p>
			<p>Now that we've covered what recomposition is and the core concepts behind Compose, it's time to have a better look at the composables that are used to build a Compose UI.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Exploring the building blocks of Compose UIs</h1>
			<p>We've only had a <a id="_idIndexMarker024"/>brief look at the <code>Text</code> and <code>Button</code> composables so far. That's why, in this section, we will not only understand how activities can render <a id="_idIndexMarker025"/>composables instead of XML and how we can preview them, but we will also have a better look at the most important and commonly used composable functions: from the ones we've seen, such as <code>Text</code> and <code>Button</code>, to new ones such as <code>TextField</code>, <code>Image</code>, <code>Row</code>, <code>Column</code>, and <code>Box</code>.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>Setting content and previewing composables</li>
				<li>Exploring core composables</li>
				<li>Customizing composables with modifiers</li>
				<li>Layouts in Compose</li>
			</ul>
			<p>Let's jump in and understand how to render composable functions on the screen.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Setting content and previewing composables</h2>
			<p>We had a quick <a id="_idIndexMarker026"/>look at some composable<a id="_idIndexMarker027"/> functions, but we didn't quite touch on the aspect of making the application display Compose UIs. </p>
			<p>Setting the composable content can easily be achieved and is encouraged to be done in your <code>Activity</code> class by simply replacing the traditional <code>setContentView(R.layout.XML)</code> call with <code>setContent()</code> and passing a composable function to it:</p>
			<pre>import androidx.activity.compose.setContent
class MainActivity : ComponentActivity() {
   override fun onCreate(savedInstanceState: Bundle?) {
       super.onCreate(savedInstanceState)
       <strong class="bold">setContent {</strong>
           Text("Hello world")
       <strong class="bold">}</strong>
   }
}</pre>
			<p>Because Compose no longer needs the <code>AppCompat</code> API for backward compatibility, we made our <code>MainActivity</code> inherit the base <code>ComponentActivity</code> class.</p>
			<p>In the previous example, we called the <code>setContent</code> method in the <code>onCreate</code> callback of <code>MainActivity</code> and passed a <code>Text</code> composable function to it. If we run the app, we will see the <code>"Hello world"</code> message.</p>
			<p>The <code>setContent</code> method is an extension function for <code>ComponentActivity</code> that composes the given composable into the given activity. It only accepts a <code>@Composable</code> function as a trailing lambda. The input composable function will become the root view of the activity and act as a container for your Compose hierarchy.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can add composable functions into fragments or activities that have an XML UI already defined with the help of the <code>ComposeView</code> class, but we will not go into too much detail as far as interoperability goes.</p>
			<p>As XML provided us <a id="_idIndexMarker028"/>with a preview tool, a good question would be whether Compose also has one. Compose brings an <a id="_idIndexMarker029"/>even more powerful preview tool that allows us to skip running the application on the emulator or real devices every time we want to see how our UI evolves. </p>
			<p>Previewing your composable is easy; just add the <code>@Preview</code> annotation to it:</p>
			<pre>@Preview(showBackground = true)
@Composable
fun FriendlyMessage() {
   Text<a id="_idTextAnchor022"/>(text = "Greetings!")
}</pre>
			<p>The IDE will automatically pick up that you want to preview this composable and show it on the right-hand side of the screen. Make sure that you <em class="italic">rebuild</em> your project and have the <strong class="bold">Split</strong> option enabled: </p>
			<div><div><img src="img/B17788_01_09.jpg" alt="Figure 1.9 – Previewing composable functions in Android Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Previewing composable functions in Android Studio</p>
			<p>Optionally, you can specify for the <a id="_idIndexMarker030"/>preview to show a background for better visibility by passing the <code>showBackground</code> parameter with a<a id="_idIndexMarker031"/> value of <code>true</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure that the composable function you are trying to preview has no input parameters. If it has, supply the default values for them so that the preview tools can work.</p>
			<p>Yet this preview tool is much more powerful than this as it supports <strong class="bold">Interactive mode</strong>, which allows you to interact with the UI, and <strong class="bold">Live Edit of literals</strong>, which, if enabled, causes the preview to reload every time you change widths, heights, or others, just like a real UI would. You can see these two options in the following screenshot:</p>
			<div><div><img src="img/B17788_01_10.jpg" alt="Figure 1.10 – Using the Preview feature in Compose&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Using the Preview feature in Compose</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To enable <strong class="bold">Interactive mode</strong> on Android Studio Arctic Fox, go to <strong class="bold">File</strong> | <strong class="bold">Settings</strong> | <strong class="bold">Experimental</strong> (Windows) or <strong class="bold">Android Studio</strong> | <strong class="bold">Preferences</strong> | <strong class="bold">Experimental</strong> (macOS).</p>
			<p>Additionally, you<a id="_idIndexMarker032"/> can have multiple previews<a id="_idIndexMarker033"/> simultaneously if you annotate each function with the <code>@Preview</code> annotation. You can add names for each preview through the <code>name</code> parameter and even tell the preview tool which device it should display it on through the <code>device</code> argument:</p>
			<pre>@Preview(
    name = "Greeting preview",
    showSystemUi = true,
    device = Devices.PIXEL_2_XL
)
@Composable
fun FriendlyMessagePreview() { Text(text = "Greetings!") }
@Preview(
        showSystemUi = true,
        device = Devic<a id="_idTextAnchor023"/>es.NEXUS_5)
@Composable
fun FriendlyMessagePreview2() { Text(text = "Goodbye!") }</pre>
			<p>Make sure that you also set <code>showSystemUi</code> to <code>true</code> to see the entire device. </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>@Preview</code> functions should have different names to avoid preview conflicts.</p>
			<p>Now that we <a id="_idIndexMarker034"/>have learned how to set and preview<a id="_idIndexMarker035"/> Compose UI, it's time to explore new composables.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>Exploring core composables</h2>
			<p>We've already had a quick <a id="_idIndexMarker036"/>look at some of the most basic composable functions: <code>Text</code>, <code>Button</code>, and <code>Image</code>. In this subsection, we will spend a bit more time exploring not only those composables but also new ones such as <code>TextField</code>.</p>
			<h3>Text</h3>
			<p><code>Text</code> is the Compose version of our old and beloved <code>TextView</code>. <code>Text</code> is provided by Compose and achieves the<a id="_idIndexMarker037"/> most basic and yet important functionality in any application: the ability to display a piece of text. We've already used this composable in several examples:</p>
			<pre>Text(text = "Greetings $name!")</pre>
			<p>You might be wondering how we can customize it. Let's check out the source code or the documentation for <code>Text</code> to find the most basic and commonly used arguments for it:</p>
			<ul>
				<li><code>text</code> is the only required argument. It expects a <code>String</code> and sets the output text.</li>
				<li><code>color</code> specifies the color of the output text and expects a <code>Color</code> object.</li>
				<li><code>fontSize</code> of type <code>TextUnit</code>, <code>fontStyle</code> of type <code>FontStyle</code>, <code>fontFamily</code> of type <code>FontFamily</code>, an<a id="_idTextAnchor025"/>d <code>fontWeight</code> of type <code>FontWeight</code> all allow you to customize the look a<a id="_idTextAnchor026"/>nd appearance of your text.</li>
				<li><code>textAlign</code> specifies the horizontal alignment of the text. It expects a <code>TextAlign</code> object.</li>
				<li><code>maxLines</code> expects an <code>Int</code> value that sets the maximum number of lines in the output text.</li>
				<li><code>style</code> expects a <code>TextStyle</code> object and allows you to define and reuse styles through themes.</li>
			</ul>
			<p>Instead of going through all the arguments<a id="_idIndexMarker038"/> for <code>Text</code>, let's check out an example where we can customize the look of our <code>Text</code> composable function:</p>
			<pre>@Composable
fun MyAppText() {
   Text(
       text = stringResource(id = R.string.app_name),
       fontStyle = FontStyle.Italic,
       textAlign = TextAlign.Center,
       color = Color.Magenta,
       fontSize = 24.sp,
       fontWe<a id="_idTextAnchor027"/><a id="_idTextAnchor028"/>ight = FontWeight.ExtraBold)
}</pre>
			<p>Instead of passing some hardcoded text, we passed a string resource with the help of the built-in <code>stringResource</code> function and obtained the following result:</p>
			<div><div><img src="img/B17788_01_11.jpg" alt="Figure 1.11 – Exploring a customized Text composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Exploring a customized Text composable</p>
			<p>Now that we've learned how to display text with the <code>Text</code> composable, let's move on to buttons.</p>
			<h3>Button</h3>
			<p>Displaying<a id="_idIndexMarker039"/> text is essential in any application, yet having clickable buttons allows it to be interactive. We've used the <code>Button</code> composable (previously known in the View System as <code>Button</code> too) before and its main characteristic was the <code>onClick</code> callback function, which notified us when the user pressed the button.</p>
			<p>While <code>Button</code> features plenty of customizing arguments, let's check out the most used parameters:</p>
			<ul>
				<li><code>onClick</code> is a mandatory parameter and it expects a function that will be called whenever the user presses the button.</li>
				<li><code>colors</code> expects a <code>ButtonColors</code> object that defines the content/background colors.</li>
				<li><code>shape</code> expects a custom/Material theme <code>Shape</code> object that sets the shape of the button.</li>
				<li><code>content</code> is a mandatory parameter that expects a composable function that displays the content inside this <code>Button</code>. We can add any composables here, including <code>Text</code>, <code>Image</code>, and more.</li>
			</ul>
			<p>Let's try to build a <code>Button</code> function that makes use of these core arguments:</p>
			<pre>@Composable
fun ClickableButton() {
   Button(
       onClick = { /* callback */ },
       colors = ButtonDefaults.buttonColors(
           backgroundColor = Color.Blue,
           contentColor = Color.Red),
       shape = MaterialTheme.shapes.medi<a id="_idTextAnchor029"/>um
   ) { Text("Press me") }
}</pre>
			<p>We've also passed a <a id="_idIndexMarker040"/>predefined <code>MaterialTheme</code> shape. Let's preview the resulting composable:</p>
			<div><div><img src="img/B17788_01_12.jpg" alt="Figure 1.12 – Exploring a customized Button composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Exploring a customized Button composable</p>
			<p>With that, we've seen how easy it is to create a custom button with the <code>Button</code> composable. Next up, let's try to play around with another composable function – <code>TextField</code>.</p>
			<h3>TextField</h3>
			<p>Adding buttons is the first <a id="_idIndexMarker041"/>step toward having an interactive UI, but the most important element in this area is the <code>TextField</code> composable, previously known in the View System as <code>EditText</code>. Just like <code>EditText</code> did, the <code>TextField</code> composable allows the user to enter and modify text.</p>
			<p>While <code>TextField</code> has many arguments, the most important ones that it features are as follows:</p>
			<ul>
				<li><code>value</code> is a mandatory <code>String</code> argument as it's the displayed text. This value should change as we type inside it by holding it in a <code>State</code> object; more on that soon.</li>
				<li><code>onValueChange</code> is a mandatory function that triggers every time the user inputs new characters or deletes existing ones. </li>
				<li><code>label</code> expects a composable function that allows us to add a descriptive label.</li>
			</ul>
			<p>Let's have a look at a simple usage of a <code>TextField</code> that also handles its own state:</p>
			<pre>@Composable
fun NameInput() {
   val textState = remember { mutableStateOf("") }
   TextField(
        value = textState.value,
        onValueChange = { newValue -&gt;
            textState.value = newValue
        },
        label = { Text("Your name") })
}</pre>
			<p>It achieves this by defining a <code>MutableState</code> that holds the text displayed by <code>TextField</code>. This means that <code>textState</code> doesn't change across recompositions, so every time the UI updates because of other composables, <code>textState</code> should be retained. Moreover, we've wrapped the <code>MutableState</code> object in a <code>remember</code> block, which tells Compose that across recompositions, it should not revert the value to its initial value; that is, <code>""</code>.</p>
			<p>To get or set the value of a <code>State</code> or <code>MutableState</code> object, our <code>NameInput</code> composable uses the <code>value</code> accessor. Because <code>TextField</code> accesses a <code>MutableState </code>object through the <code>value</code> accessor, Compose knows to retrigger a <em class="italic">recomposition</em> every time the <code>textState</code> value changes – in our case, in the <code>onValueChange</code> callback. By doing so, we ensure that as we input text in our <code>TextField</code>, the UI also updates with the new characters that have been added or removed from the keyboard.</p>
			<p>Don't worry if these <a id="_idIndexMarker042"/>concepts about state in Compose don't make too much sense right now – we will cover how state is defined in Compose in more detail in <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>.</p>
			<p class="callout-heading">Note:</p>
			<p class="callout">Unlike <code>EditText</code>, <code>TextField</code> has no internal state. That's why we've created and handled it; otherwise, as we would type in, the UI would not update accordingly.</p>
			<p>The resulting <code>NameInput</code> composable updates the UI correctly and looks like this:</p>
			<div><div><img src="img/B17788_01_13.jpg" alt="Figure 1.13 – Exploring a TextField composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Exploring a TextField composable</p>
			<p>Now that we've learned how to add input fields within a Compose-based app, it's time to explore one of the<a id="_idIndexMarker043"/> most common elements in any UI.</p>
			<h3>Image</h3>
			<p>Displaying graphical information in <a id="_idIndexMarker044"/>our application is essential and Compose provides us with a handy composable called <code>Image</code>, which is the composable version of the <code>ImageView</code> from the View System.</p>
			<p>While <code>Image</code> features plenty of customizing arguments, let's check out the most used parameters:</p>
			<ul>
				<li><code>painter</code> expects a <code>Painter</code> object. This argument is mandatory as it sets the image resource. Alternatively, you can use the overloaded version of <code>Image</code> to directly pass an <code>ImageBitmap</code> object to its <code>bitmap</code> parameter.</li>
				<li><code>contentDescription</code> is a mandatory <code>String</code> that's used by accessibility services.</li>
				<li><code>contentScale</code> expects a <code>ContentScale</code> object that specifies the scaling of the picture.</li>
			</ul>
			<p>Let's add an <code>Image</code> composable that displays the application icon using <code>painterResource</code>:</p>
			<pre>@Composable
fun BeautifulImage() {
    Image(
        painter =
           painterResource(R.drawable.ic_launcher_foreground),
        contentDescription = "My app icon",
        contentScale = ContentScale.Fit
    )
}</pre>
			<p>Finally, let's preview the <code>BeautifulImage</code> function and then move on to the next section:</p>
			<div><div><img src="img/B17788_01_14.jpg" alt="Figure 1.14 – Exploring the Image composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – Exploring the Image composable</p>
			<p>We've also tried displaying<a id="_idIndexMarker045"/> images with Compose, yet you may still be wondering, how can we customize all these composable functions?</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>Customizing composables with modifiers</h2>
			<p>All the composables we've covered so far feature an argument that we haven't covere<a id="_idTextAnchor031"/>d yet: <code>modifier</code>. This expects a <code>Modifier</code> object. In simple terms, <em class="italic">modifiers tell a composable how to display, arrange, or behave within its parent composable.</em> By passing a modifier, we<a id="_idIndexMarker046"/> can specify many<a id="_idIndexMarker047"/> configurations for a composable: from size, padding, or shape to background color or border. </p>
			<p>Let's start with an example by using a <code>Box</code> composable and specifying a <code>size</code> modifier for it:</p>
			<pre>@Composable
fun ColoredBox() {
   Box(<a id="_idTextAnchor032"/>modifier = <strong class="bold">Modifier.size(120.dp)</strong>)
}</pre>
			<p>We will cover the <code>Box</code> composable later but until then, you can think of it like a container that we will use to draw several shapes on the screen. What's important here is that we passed the <code>Modifier.size()</code> modifier, which sets the size of the box. It accepts a <code>dp</code> value that represents both the width and the height of the composable. You can also pass the width and height as parameters within the <code>size()</code> modifier or separately with the help of the <code>height()</code> and <code>width()</code> modifiers.</p>
			<p>Specifying only one modifier for composables is usually not enough. That's why <em class="italic">modifiers can be chained</em>. Let's chain multiple modifiers by adding several other configurations to our <code>Box</code>:</p>
			<pre>@Composable
fun ColoredBox() {
   Box(modifier = Modifier
           .size(120.dp)
           .background(Color.Green)
           .padding(16.dp)
           .clip(RoundedCornerShape(size = 20.dp))
           .background(Color.Red))
}</pre>
			<p>As we mentioned <a id="_idIndexMarker048"/>previously, chaining modifiers is simple: start with an empty <code>Modifier</code> object and then chain new modifiers one after the<a id="_idIndexMarker049"/> other. We've chained several new modifiers, starting with <code>background</code>, then <code>padding</code>, <code>clip</code>, and finally another <code>background</code>. The modifiers, when combined, produce an output consisting of a green rectangle that contains a nested rounded corner rectangle that's red:</p>
			<div><div><img src="img/B17788_01_15.jpg" alt="Figure 1.15 – Exploring chained modifiers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15 – Exploring chained modifiers</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The order of the modifiers in the chain matters because modifiers are applied from the outer layer to the inner layer. Each modifier modifies the composable and then prepares it for the upcoming modifier in the chain. Different modifier orders yield different results.</p>
			<p>In the previous example, because<a id="_idIndexMarker050"/> modifiers are applied from the outermost layer to the innermost layer, the entire rectangular box is green because green is the first color modifier that's applied. Going inner, we applied a padding of 16 <code>dp</code>. Afterward, still going inner, the <code>RoundedCornerShape</code> modifier is applied. Finally, in the innermost layer, we applied another color modifier – this time, of the color red – and we got our final result.</p>
			<p>Now that we've played around with the most common composables, it's time to start building actual layouts that make <a id="_idIndexMarker051"/>use of multiple composable functions.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor033"/>Layouts in Compose</h2>
			<p>Often, building <a id="_idIndexMarker052"/>even a simple screen cannot be achieved by following the previous examples since most of them feature only one composable. For<a id="_idIndexMarker053"/> simple use cases, composable functions contain only one composable child.</p>
			<p>To build more complex pieces of UI, layout components in Compose give you the option to add as many children composables as you need.</p>
			<p>In this section, we will cover those composable functions that allow you to place children composables in a linear or overlayed fashion, such as the following:</p>
			<ul>
				<li><code>Row</code> for arranging children composables in a horizontal fashion</li>
				<li><code>Column</code> for arranging children composables vertically</li>
				<li><code>Box</code> for arranging children composables on top of each other</li>
			</ul>
			<p>Following these definitions, let's envision the layout composables with the following diagram:</p>
			<div><div><img src="img/B17788_01_16.jpg" alt="Figure 1.16 – Exploring Column, Row, and Box&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16 – Exploring Column, Row, and Box</p>
			<p>It's clear now<a id="_idIndexMarker054"/> that arranging children composables in different ways <a id="_idIndexMarker055"/>can easily be achieved with <code>Column</code>, <code>Row</code>, and <code>Box</code>, so it's time to look at them in more detail.</p>
			<h3>Row</h3>
			<p>Displaying multiple widgets on the screen is achieved by using a <code>Row</code> composable that arranges its <a id="_idIndexMarker056"/>children composables horizontally, just like the old <code>LinearLayout</code> with horizontal orientation did:</p>
			<pre>@Composable
fun HorizontalNumbersList() {
   Row(
       horizontalArrangement = Arrangement.Start,
       verticalAlignment = Alignment.CenterVertically,
       modifier = Modifier.fillMaxWidth()
   ) {
       Text("1", fontSize = 36.sp)
       Text("2", fontSize = 36.sp)
       Text("3", fontSize = 36.sp)<a id="_idTextAnchor034"/>
       Text("4", fontSize = 36.sp)
   }
}</pre>
			<p>We've set <code>Row</code> to only take the available width and added several <code>Text</code> functions<a id="_idTextAnchor035"/> as children composables. We specified a <code>horizontalArrangement</code> of <code>Start</code> so that they start from the left of the<a id="_idIndexMarker057"/> parent but also made sure that they are centered vertically by passing a <code>CenterVertically</code> alignment for the <code>verticalAlignment</code> argument. The result is straightforward:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B17788_01_17.jpg" alt="Figure 1.17 – Exploring the Row composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17 – Exploring the Row composable</p>
			<p>Largely, the essential arguments for a <code>Row</code> composable are related to how children are arranged or aligned:</p>
			<ul>
				<li><code>horizontalArrangement</code> defines how the children are positioned horizontally both relative to each other and within the parent <code>Row</code>. Apart from <code>Arragement.Start</code>, you can also pass <code>Center</code> or <code>End</code> or <code>SpaceBetween</code>, <code>SpaceEvenly</code>, or <code>SpaceAround</code>.</li>
				<li><code>verticalAlignment</code> sets how the children are positioned vertically within the parent <code>Row</code>. Apart from <code>Alignment.CenterVertically</code>, you can pass <code>Top</code> or <code>Bottom</code>.</li>
			</ul>
			<p>Now that we've arranged the children composables horizontally, let's try to arrange them vertically.</p>
			<h3>Column</h3>
			<p>Displaying a vertical list on the screen <a id="_idIndexMarker058"/>can be achieved by using a <code>Column</code> composable that arranges its children composables vertically, just like the old <code>LinearLayout</code> with vertical orientation did:</p>
			<pre>@Composable
fun NamesVerticalList() {
   Column(verticalArrangement = Arrangement.SpaceEvenly,
       horizontalAlignment = Alignment.CenterHorizontally,
       modifier = Modifier.fillMaxSize()
   ) {
       Text("John", fontSize = 36.sp)
       Text("Amanda", fontSize = 36.sp)
       Text("Mike", fontSize = 36.sp)
       Text("Alma", fontSize = 36.sp)
   }
}</pre>
			<p>We've set <code>Column</code> to take<a id="_idIndexMarker059"/> all the available space and added several <code>Text</code> functions as children composables. This time, we specified a <code>verticalArrangement</code> of <code>SpaceEvenly</code> so that children are spread out equally within the parent, but we also made sure they are centered horizontally by passing a <code>CenterHorizontally</code> alignment as <code>horizontalAlignment</code>:</p>
			<div><div><img src="img/B17788_01_18.jpg" alt="Figure 1.18 – Exploring the Column composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18 – Exploring the Column composable</p>
			<p>Similar to <code>Row</code>, the <a id="_idIndexMarker060"/>essential arguments for a <code>Column</code> are also related to how children are arranged or aligned. This time, though, the arrangement is vertical instead of horizontal, and the alignment is horizontal instead of vertical:</p>
			<ul>
				<li><code>verticalArrangement</code> defines how the children are vertically positioned within the parent <code>Column</code>. The values are the same as the row's <code>horizontalArrangement</code>.</li>
				<li><code>horizontalAlignment</code> defines how the children are aligned within the parent <code>Column</code>. Apart from <code>Alignment.CenterHorizontally</code>, you can pass <code>Start</code> or <code>End</code>.<p class="callout-heading">Note</p><p class="callout">If you're feeling brave, this is a great time for you to explore different alignments and arrangements and see how the UI changes. Make sure that you preview your composable functions with the <code>@Preview</code> annotation.</p></li>
			</ul>
			<h3>Box</h3>
			<p>So far, we've learned how to arrange children horizontally and vertically, but what if we want to place them <a id="_idIndexMarker061"/>on top of each other? The <code>Box</code> composable comes to our rescue as it allows us to stack children composables. <code>Box</code> also allows us to position the children relatively to it.</p>
			<p>Let's try to <a id="_idIndexMarker062"/>build our own <code>Box</code>. We will stack two composables inside <code>Box</code>: </p>
			<ul>
				<li>One green circle, which will be created with the help of <code>Surface</code>. The <code>Surface</code> composable allows you to easily define a material surface with a certain shape, background, or elevation.</li>
				<li>One plus sign (<code>+</code>) added as text inside the <code>Text</code> composable, which is aligned in the center of its parent <code>Box</code>.</li>
			</ul>
			<p>This is what the code will look like:</p>
			<pre>@Composable
fun MyFloatingActionButton() {
   Box {
       Surface(
           modifier = Modifier.size(32.dp),
           color = Color.Green,
           shape = CircleShape,
           content = { })
       Text(text = "+",
            modif<a id="_idTextAnchor036"/>ier = Modifier.align(Alignment.Center))
   }
}</pre>
			<p>The <code>Surface</code> composable is defined with a mandatory <code>content</code> parameter that accepts another composable as its inner content. We don't want to add a composable inside of it. Instead, we want to stack a <code>Text</code> composable on top of it, so we passed an empty function<a id="_idIndexMarker063"/> to the <code>content</code> parameter.</p>
			<p>The result is similar to the FAB we are all used to:</p>
			<div><div><img src="img/B17788_01_19.jpg" alt="Figure 1.19 – Exploring the Box composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.19 – Exploring the Box composable</p>
			<p>To take advantage of <code>Box</code>, you must keep the following in mind:</p>
			<ul>
				<li>The order in which composables are added within <code>Box</code> defines the order in which they are painted and stacked on top of each other. If you switch the order of <code>Surface</code> and <code>Text</code>, the <code>+</code> icon will be painted beneath the green circle making it invisible.</li>
				<li>You can align the children composables relative to the <code>Box</code> parent by passing different values for each of the child's alignment modifiers. That's why, apart from <code>Alignment.Center</code>, you can also position children composables with <code>CenterStart</code>, <code>CenterEnd</code>, <code>TopStart</code>, <code>TopCenter</code>, <code>TopEnd</code>, <code>BottomStart</code>, <code>BottomEnd</code>, or <code>BottomCenter</code>.</li>
			</ul>
			<p>Now that we covered the basics, it's time to roll up our sleeves and create our first Compose project!</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor037"/>Building a Compose-based screen</h1>
			<p>Let's say we want to<a id="_idIndexMarker064"/> build an application that showcases some restaurants. We will build the UI with Compose and go through the steps of creating a new Compose project. We will then build a list item for such a restaurant and finally display a dummy list of such items.</p>
			<p>To summarize, in this section, we will build our first Compose-based application: a restaurant explorer app! To achieve that, we must display some restaurants, which we will do by covering the following topics:</p>
			<ul>
				<li>Creating your first Compose project</li>
				<li>Building a restaurant element layout</li>
				<li>Displaying a list of restaurants with Compose</li>
			</ul>
			<p>Now that we have a clear path, let's get started.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor038"/>Creating your first Compose project</h2>
			<p>To build a restaurant app, we<a id="_idIndexMarker065"/> have to create a new Compose-based project:</p>
			<ol>
				<li>Open Android Studio and select the <strong class="bold">New Project</strong> option:</li>
			</ol>
			<div><div><img src="img/B17788_01_20.jpg" alt="Figure 1.20 – Starting a new project with Android Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20 – Starting a new project with Android Studio</p>
			<p>If you already have Android Studio open, go to <strong class="bold">File</strong>, then <strong class="bold">New</strong>, and finally <strong class="bold">New Project</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure that you have Android Studio version Arctic Fox 2020.3.1 or newer. If you're using a newer version though, some files might have differences in the generated code.</p>
			<ol>
				<li value="2">In the <strong class="bold">Phone and tablet</strong> template section, select <strong class="bold">Empty Compose Activity</strong> and then choose <strong class="bold">Next</strong>:</li>
			</ol>
			<div><div><img src="img/B17788_01_21.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.21 – Starting a new project with Android Studio</p>
			<ol>
				<li value="3">Next, enter some details about <a id="_idIndexMarker066"/>your application. In the <code>Restaurants app</code>. Leave <strong class="bold">Kotlin</strong> as-is for <strong class="bold">Language</strong> and set <strong class="bold">Minimum SDK</strong> to <strong class="bold">API 21</strong>. Then, click <strong class="bold">Finish</strong>.<p class="callout-heading">Important note</p><p class="callout">The upcoming step is an essential configuration step. It makes sure that the project Android Studio has configured for you the same versions of dependencies (from Compose, to Kotlin and other dependencies) that we use throughout the book. By doing so, you will be able to follow the code snippets and inspect the code source without any API differences.</p></li>
				<li>Inside the newly<a id="_idIndexMarker067"/> generated project, before inspecting the code, make sure that the generated project uses the versions of dependencies that are used throughout the book.</li>
			</ol>
			<p>To do so, first go to the project-level <code>build.gradle</code> file and inside the <code>dependencies</code> block, make sure that the Kotlin version is set to <code>1.6.10</code>:</p>
			<pre>buildscript {
    […]
    dependencies {
        classpath "com.android.tools.build:gradle:7.0.2"
        classpath "org.jetbrains.kotlin:kotlin-gradle- 
            plugin:<strong class="bold">1.6.10</strong>"
      […]
    }
}</pre>
			<p>Alternatively, if you're using a newer version of Android Studio, you might find the Kotlin version used in this project inside the <code>plugins</code> block, like so:</p>
			<pre>plugins {
    […]
    id 'org.jetbrains.kotlin.android' version <strong class="bold">'1.6.10'</strong> 
        apply false
}</pre>
			<p>If you <a id="_idIndexMarker068"/>haven't already, you might need to install the 1.6.10 plugin version of Kotlin in Android Studio. To do that, click on the <code>1.6.10</code>.</p>
			<p>Still in the project-level <code>build.gradle</code> file, because Compose is tied to the Kotlin version used in our project, make sure that the Compose version is set to <code>1.1.1</code> inside the <code>ext { }</code> block:</p>
			<pre>buildscript {
    ext {
<strong class="bold">        compose_version = '1.1.1'</strong>
    }
    repositories {…}
    dependencies {…}
}</pre>
			<p>Then, move into the app-level <code>build.gradle</code> file. First check that the <code>composeOptions { }</code> block looks like this:</p>
			<pre>plugins { ... }
android {
    [...]
    buildFeatures { compose true }
    <strong class="bold">composeOptions {</strong>
<strong class="bold">        kotlinCompilerExtensionVersion compose_version</strong>
<strong class="bold">    }</strong>
    packagingOptions { ... }
}</pre>
			<p>In some versions of <a id="_idIndexMarker069"/>Android Studio, the <code>composeOptions { }</code> block would add an outdated <code>kotlinCompilerVersion '1.x.xx'</code> line that should be removed.</p>
			<p>Finally, make sure that the <code>dependencies</code> block of the app-level <code>build.gradle</code> file<a id="_idIndexMarker070"/> includes the following versions for its dependencies:</p>
			<pre>dependencies {
    implementation 'androidx.core:core-ktx:<strong class="bold">1.7.0</strong>'
    implementation 'androidx.appcompat:appcompat:<strong class="bold">1.4.1'</strong>
    implementation 'com.google.android.material:
        material:<strong class="bold">1.5.0'</strong>
    implementation "androidx.compose.ui:ui:
        $compose_version"
    implementation "androidx.compose.material:
        material:$compose_version"
    implementation "androidx.compose.ui:ui-tooling-
        preview:$compose_version"
    implementation 'androidx.lifecycle:lifecycle-
        runtime-ktx:<strong class="bold">2.4.1'</strong>
    implementation 'androidx.activity:activity-
        compose:<strong class="bold">1.4.0'</strong>
    testImplementation 'junit:junit:<strong class="bold">4.+</strong>'
    androidTestImplementation
        'androidx.test.ext:junit:<strong class="bold">1.1.3'</strong>
    androidTestImplementation 
        'androidx.test.espresso:espresso-core:<strong class="bold">3.4.0'</strong>
    androidTestImplementation "androidx.compose.ui:ui-
        test-junit4:$compose_version"
    debugImplementation "androidx.compose.ui:ui-
        tooling:$compose_version"
}</pre>
			<p>If you had to make any changes, synchronize your project with its Gradle files by clicking on the <strong class="bold">Sync your project with Gradle files</strong> button in Android Studio or by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<p>Now we're set. Let's return to the source code generated by Android Studio.</p>
			<p>And here we are – our first<a id="_idIndexMarker071"/> Compose project has been set up! Let's check out the source code by navigating to the <code>MainActivity.kt</code> file. We can conclude that it consists of three main parts:</p>
			<ul>
				<li>The <code>MainActivity</code> class</li>
				<li>The <code>Greeting</code> composable function</li>
				<li>The <code>DefaultPreview</code> composable function</li>
			</ul>
			<p>The <code>MainActivity</code> class is where content is passed to the <code>setContent</code> method in the <code>onCreate</code> callback. As we know by now, we need to call <code>setContent</code> to set up a Compose UI and pass composable functions as our UI:</p>
			<pre>setContent {
   RestaurantsAppTheme {
       Surface(color = MaterialTheme.colors.background) {
           Greeting("Android")
       }
   }
}</pre>
			<p>The IDE template has already implemented a <code>Greeting</code> composable that is wrapped into a <code>Surface</code> that uses the theme's background color. But what is that <code>RestaurantsAppTheme</code> function that was passed as the parent composable to the <code>setContent</code> method?</p>
			<p>If you press <em class="italic">Ctrl</em> + <em class="italic">B</em> or <em class="italic">Command</em> + <em class="italic">B</em> on the function name, you will be taken to the <code>Theme.kt</code> file, which is where <a id="_idIndexMarker072"/>our theme is generated. <code>RestaurantsAppTheme</code> is a composable function that was auto-generated by the IDE as it holds the app's name:</p>
			<pre>@Composable
fun RestaurantsAppTheme(
   darkTheme: Boolean = isSystemInDarkTheme(),
   content: @Composable() -&gt; Unit
) {
   ...
   MaterialTheme(
       colors = colors,
       typography = Typography,
       shapes = Shapes,
       content = content)
}</pre>
			<p>The app's theme is a wrapper over <code>MaterialTheme</code> and if we pass it to the <code>setContent</code> call, it allows us to reuse custom styles and color schemes defined within the app's theme. For it to take effect and reuse custom styles, we must pass our composables functions to the <code>content</code> parameter of our theme composable – in our case, in <code>MainActivity</code>, the <code>Greeting</code> composable wrapped in the <code>Surface</code> composable is passed to the <code>RestaurantsAppTheme</code> composable.</p>
			<p>Let's go back inside the <code>MainActivity.kt</code> file to have a look at the other parts generated by Android studio. We can see that the <code>Greeting</code> composable displays text through <code>Text</code>, similar to our composable functions from the previous examples.</p>
			<p>To preview the <code>Greeting</code> composable, the IDE also generated a preview composable for us called <code>DefaultPreview</code>, which allows us to preview the content that <code>MainActivity</code> displays; that is, <code>Greeting</code>. It also makes use of the theme composable to get the consistently themed UI.</p>
			<p>Now that we've achieved a<a id="_idIndexMarker073"/> big milestone in that we've created a Compose-based application, it's time to start working on our Restaurants App!</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor039"/>Building a restaurant element layout</h2>
			<p>It's time to get our hands dirty and<a id="_idIndexMarker074"/> start building the layout for a restaurant within the app:</p>
			<ol>
				<li value="1">Create a new file by left-clicking the application package and selecting <code>RestaurantsScreen</code> for the name and select the type as <strong class="bold">File</strong>. </li>
				<li>Inside this file, let's create a <code>RestaurantsScreen</code> composable function for our first Compose screen:<pre>@Com<a id="_idTextAnchor040"/>posable
fun RestaurantsScreen() {
   RestaurantItem()
}</pre></li>
				<li>Next, inside the <code>RestaurantsScreen.kt</code> file, let's define the <code>RestaurantItem</code> composable, which features a <code>Card</code> composable with elevation and padding:<pre>@Composable
fun RestaurantItem() {
    Card(elevation = 4.dp,
         modifier = Modifier.padding(8.dp)
    ) {
        Row(verticalAlignment =
                Alignment.CenterVertically,
            modifier = Modifier.padding(8.dp)) {
            RestaurantIcon(
                Icons.Filled.Place,
                Modifier.weight(0.15f))
            RestaurantDetails(Modifier.weight(0.85f))
        }
    }
}</pre></li>
			</ol>
			<p>Make sure that every import you include is part of the <code>androidx.compose.*</code> package. If you're unsure what imports to include, check out the source code for the <code>RestaurantsScreen.kt</code> file at the following URL:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt</a></p>
			<p>Getting back to the <a id="_idIndexMarker075"/>previous code snippet, we could say that the <code>Card</code> composable is similar to <code>Cardview</code> from the old View System as it allows us to beautify the UI piece that represents a restaurant with border or elevation.</p>
			<p>In our case, <code>Card</code> contains a <code>Row</code> composable whose children composables are centered vertically and are surrounded by some padding. We used <code>Row</code> since we will show some details about the restaurant in a horizontal fashion: an icon and some text details.</p>
			<p>We passed the <code>RestaurantIcon</code> and <code>RestaurantDetails</code> composables as children of the <code>Row</code> composable but these functions are not defined so we have compilation errors. For now, don't worry about the weight modifiers. Let's define the <code>RestaurantIcon</code> composable first!</p>
			<ol>
				<li value="4">Still inside the <code>RestaurantsScreen.kt</code> file, create another composable function entitled <code>RestaurantIcon</code> with the following code:<pre>@Composable
private fun RestaurantIcon(icon: ImageVector, modifier: Modifier) {
   Image(imageVector = icon,
         contentDescription = "Restaur<a id="_idTextAnchor041"/>ant icon",
         modifier = modifier.padding(8.dp))
}</pre></li>
			</ol>
			<p>The <code>RestaurantIcon</code> composable sets an <code>ImageVector</code> icon to an <code>Image</code> composable – in our case, a predefined Material Theme icon called <code>Icons.Filled.Place</code>. It also sets a <code>contentDescription</code> value and adds padding on top of the modifier it receives.</p>
			<p>However, the<a id="_idIndexMarker076"/> most interesting part is the fact that <code>RestaurantIcon</code> receives a <code>Modifier</code> as an argument from its parent <code>Row</code>. The argument it receives is <code>Modifier.weight(0.15f)</code>, which means that our <code>Row</code> assigns weights to each of its horizontally positioned children. The value – in this case, <code>0.15f</code> – means that this child <code>RestaurantIcon</code> will take 15% of the horizontal space from its parent <code>Row</code>.</p>
			<ol>
				<li value="5">Now, still inside the <code>RestaurantsScreen.kt</code> file, create a <code>RestaurantDetails</code> function that displays the restaurant's details:<pre>@Composable
private fun RestaurantDetails(modifier: Modifier) {
   Column(modifier = modifier) {
       Text(text = "Alfredo's dishes",
            style = MaterialTheme.typography.h6)
       CompositionLocalProvider(
           LocalContentAlpha provides 
               ContentAlpha.medium) {
           Text(text = "At Alfredo's … seafood dishes.",
                style = MaterialThe<a id="_idTextAnchor042"/>me.typography.body2)
       }
   }
}</pre></li>
			</ol>
			<p>Similarly, <code>RestaurantDetails</code> receives a <code>Modifier.weight(0.85f)</code> modifier as an <a id="_idIndexMarker077"/>argument from <code>Row</code>, which will make it occupy the remaining 85% of the horizontal space.</p>
			<p>The <code>RestaurantDetails</code> composable is a simple <code>Column</code> that arranges two <code>Text</code> composables vertically, with one being the title of the restaurant, and the other being its description. </p>
			<p>But what's up with <code>CompositionLocalProvider</code>? To display the description that's faded out in contrast to the title, we applied a <code>LocalContentAlpha</code> of <code>ContentAlpha.medium</code>. This way, the child <code>Text</code> with the restaurant description will be faded or grayed out.</p>
			<p><code>CompositionLocalProvider</code> allows us to pass data down to the composable hierarchy. In this case, we want the child <code>Text</code> to be grayed out, so we passed a <code>LocalContentAlpha</code> object with a <code>ContentAlpha.medium</code> value using the infix <code>provides</code> method.</p>
			<ol>
				<li value="6">For a moment, go to <code>MainActivity.kt</code> and remove the <code>DefaultPreview</code> composable function as we will define our own a <code>@Preview</code> composable up next.</li>
				<li>Go back<a id="_idIndexMarker078"/> inside the <code>RestaurantsScreen.kt</code> file, define a <code>@Preview</code> composable:<pre>@Preview(showBackground = true)
@Composable
fun DefaultPreview() {<a id="_idTextAnchor043"/>
   RestaurantsAppTheme {
       RestaurantsScreen()
   }
}</pre></li>
			</ol>
			<p>If you have chosen a different name for your app, you might need to update the previous snippet with the theme composable defined in the <code>Theme.kt</code> file.</p>
			<ol>
				<li value="8">Rebuild the project and let's inspect the <code>RestaurantsScreen()</code> composable by previewing the <a id="_idIndexMarker079"/>newly created <code>DefaultPreview</code> composable, which should display a restaurant item:</li>
			</ol>
			<div><div><img src="img/B17788_01_22.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.22 – Previewing a restaurant item </p>
			<ol>
				<li value="9">Finally, go back to <code>MainActivity.kt</code> and remove the <code>Greeting</code> composable. Also, remove the <code>Surface</code> and <code>Greeting</code> function calls in the <code>setContent</code> method and replace them with <code>RestaurantScreen</code>:<pre>setContent {<a id="_idTextAnchor044"/><a id="_idTextAnchor045"/>
   RestaurantsAppTheme {
       <strong class="bold">RestaurantsScreen()</strong>
   }
}</pre></li>
			</ol>
			<p>By passing <code>RestaurantScreen</code> to our <code>MainActivity</code>'s <code>setContent</code> method, we ensure that the application will render the desired UI when built and run.</p>
			<ol>
				<li value="10">Optionally, you<a id="_idIndexMarker080"/> can now <strong class="bold">Run</strong> the app to see the restaurant directly on your device or emulator.</li>
			</ol>
			<p>Now that we have built a layout for a restaurant, it's time to learn how to display more of them! </p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor046"/>Displaying a list of restaurants with Compose</h2>
			<p>So far, we've displayed <a id="_idIndexMarker081"/>a restaurant item, so it's time to display an entire list of them:</p>
			<ol>
				<li value="1">First, create a new class in the root package, next to <code>MainActivity.kt</code>, called <code>Restaurant.kt</code>. Here, we will add a <code>data class</code> called <code>Restaur<a id="_idTextAnchor047"/><a id="_idTextAnchor048"/>ant</code> and add the fields that we expect a restaurant to have:<pre>data class Restaurant(val id: Int,
                      val title: String,
                      val description: String)</pre></li>
				<li>In the same <code>Restaurant.kt</code> file, create a dummy list of <code>Restaurant</code> <a id="_idTextAnchor049"/>items, preferably at least 10 to fill up the entire screen:<pre>data class Restaurant(val id: Int,
                      val title: String,
                      val description: String)
val dummyRestaurants = listOf(
    Restaurant(0, "Alfredo foods", "At Alfredo's …"),
    [...],
    Restaurant(13, "Mike and Ben's food pub", "")
)</pre></li>
			</ol>
			<p>You can find the pre-populated<a id="_idIndexMarker082"/> list in this book's GitHub repository, inside the <code>Restaurant.kt</code> file:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt</a>.</p>
			<ol>
				<li value="3">Go back inside the <code>RestaurantsScreen.kt</code> file and update your <code>RestaurantItem</code> so that it receives a <code>Restaurant</code> object as an argument, while also passing the restaurant's <code>title</code> and <code>description</code> to<a id="_idTextAnchor050"/> the <code>RestaurantDetails</code> composable as parameters:<pre>@Composable
fun RestaurantItem(<strong class="bold">item: Restaurant</strong>) {
    Card(...) {
        Row(...) {
            RestaurantIcon(...)
            RestaurantDetails(
              <strong class="bold">  item.title,</strong>
<strong class="bold">                item.description,</strong>
                Modifier.weight(0.85f)
            )
        }
    }
}</pre></li>
				<li>We have passed the restaurant's <code>title</code> and <code>description</code> to the <code>RestaurantDetails</code> composable as parameters. Propagate these changes in the <code>RestaurantDetails</code> composable and pass the <code>title</code> into the first <code>Text</code> composable and <a id="_idTextAnchor051"/>the <code>description</code> into the second <code>Text</code> <a id="_idTextAnchor052"/>composable:<pre>@Composable
fun RestaurantDetails(<strong class="bold">title: String</strong>, <strong class="bold">description: String,</strong> modifier: Modifier){
   Column(modifier = modifier) {
       Text(text = <strong class="bold">title</strong>, ...)
       CompositionLocalProvider( … ) {
           Text(text = <strong class="bold">description</strong>, ...)
       }
   }
}</pre></li>
				<li>Go back to the <code>RestaurantsScreen</code> composable and update it to display a vertical list of <code>Restaurant</code> objects. We <a id="_idIndexMarker083"/>already know that we can use a <code>Column</code> to achieve this. Then, iterate over each restaurant in <code>dummyRestaurants</code> and bind <a id="_idTextAnchor053"/>it to a <code>RestaurantItem</code>:<pre>@Composable
fun RestaurantsScreen() {
<strong class="bold">   Column {</strong>
<strong class="bold">       dummyRestaurants.forEach { rest<a id="_idTextAnchor054"/>aurant -&gt;</strong>
<strong class="bold">           RestaurantItem(restaurant)</strong>
<strong class="bold">       }</strong>
<strong class="bold">   }</strong>
}</pre></li>
			</ol>
			<p>This will create a beautiful vertical list that we can preview through our <code>DefaultPreview</code> composable.</p>
			<ol>
				<li value="6">Rebuild the project to<a id="_idIndexMarker084"/> see the updated preview generated by the <code>DefaultPreview</code> composable:</li>
			</ol>
			<div><div><img src="img/B17788_01_23.jpg" alt="Figure 1.23 – Previewing RestaurantsScreen with the Column composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.23 – Previewing RestaurantsScreen with the Column composable</p>
			<p>Alternatively, you can <strong class="bold">Run</strong> the app to see the restaurants directly on your device or emulator.</p>
			<p>We've finally created our first list with Compose! It looks very nice and beautiful, yet it has one huge issue – it doesn't scroll! We'll address this together in the next section.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor055"/>Exploring lists with Compose</h1>
			<p>In the previous section, we <a id="_idIndexMarker085"/>built a Compose-based screen that features a list of restaurants. However, if you run the application or preview the screen in interactive mode, you will notice that the list doesn't scroll. This is a huge inconvenience that we will address in this section by adding scroll capabilities to our <code>Column</code> composable.</p>
			<p>Next, we will specify why <code>Column</code> is suited for static content, whereas if the list is large and its size is dynamic or dictated by the server's response, we should use <em class="italic">lazy composables</em>. We will explore a variety of lazy composables and understand why they are better suited for large lists.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>Adding scrolling to the <code>Column</code> composable</li>
				<li>Introducing lazy composables</li>
				<li>Using <code>LazyColumn</code> to display restaurants</li>
			</ul>
			<p>Let's start by adding scrolling capabilities to our <code>RestaurantsScreen</code> composable.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor056"/>Adding scrolling to the Column composable</h2>
			<p>Our list of restaurants<a id="_idIndexMarker086"/> is long, and it can't scroll. This is a bad user experience,<a id="_idTextAnchor057"/> so let's fix it.</p>
			<p>Let's make the <code>Column</code> scrollable by passing a <code>Modifier.verticalScroll</code> modifier that <a id="_idTextAnchor058"/>receives a <code>ScrollState</code>:</p>
			<pre>@Composable
fun RestaurantsScreen() {
   Column<strong class="bold">(Modifier.verticalScroll(rememberScrollState()))</strong> {
       ...
   }
}</pre>
			<p>We want the scrolling position to be retained across recompositions. That's why, by passing <code>rememberScrollState</code> to the <code>verticalScroll</code> modifier, we ensure that every time the UI recomposes, the scroll state is remembered and retained. The <code>rememberScrollState</code> persistence mechanism is similar to the <code>remember { }</code> block, which we used previously to retain the <code>TextField</code>'s state across recompositions.</p>
			<p>Now, you can <strong class="bold">Run</strong> the app or<a id="_idIndexMarker087"/> preview it in <strong class="bold">Interactive mode</strong> and check out the scrolling effect.</p>
			<p>However, we have one final issue with our <code>Column</code> that is related to how <code>Column</code> lays and composes its elements. Let's dive into that now and try to find a better alternative.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor059"/>Introducing lazy composables</h2>
			<p>Let's take a short <a id="_idIndexMarker088"/>break from our restaurant app and try to think of a better way of handling large lists. Using <code>Row</code> or <code>Column</code> for displaying long lists of items, or maybe a list of unknown size, can prove detrimental to your UI and impact your app's performance. This happens because <code>Row</code> and <code>Column</code> render or lay all their children out, whether they are visible or not. They are good for displaying static content, yet passing a large list can cause <a id="_idTextAnchor060"/>your UI to become laggy or even unusable.</p>
			<p>Two lazy composables called <code>LazyColumn</code> and <code>LazyRow</code> come to your rescue since they only compose or output those items that are currently visible on the screen, hence the term <em class="italic">lazy</em>. So, as you can see, they are somehow similar to the old <code>RecyclerView</code>. </p>
			<p>As the only difference between <code>Row</code> and <code>Column</code> was the way children were laid out on the screen – horizontally or vertically – the same thing applies with <code>LazyRow</code> and <code>LazyColumn</code>. These lazy composables lay their children out horizontally or vertically and provide scrolling capabilities out of the box. As they only render the visible items, lazy composables are a much better fit for large lists.</p>
			<p>Yet, lazy composables are different than the regular composables that we've used so far. That's mainly <a id="_idIndexMarker089"/>because instead of accepting <code>@Composable</code> content, they expose a <code>LazyListScope</code> block:</p>
			<pre>@Composable
fun LazyColumn(
   ...
   content: LazyListScope.() -&gt; Unit
) { … }</pre>
			<p>The <code>LazyListScope</code> DSL allows us to describe the <em class="italic">item</em> contents that we want to be displayed as part of the list. The most <a id="_idIndexMarker090"/>commonly used ones are <code>item()</code> and <code>items()</code>. Such example usage of <code>LazyColumn</code> that makes use of DSL is as follows:</p>
			<pre>LazyColumn {
   <strong class="bold">item()</strong> {
       Text(text = "Custom header item")
   }
   <strong class="bold">items(myLongList)</strong> { myItem -&gt;
       MyComposable(myIt<a id="_idTextAnchor062"/>em)
   }
   <strong class="bold">item(2)</strong> {
       Text(text = "Custom footer item")
   }
}</pre>
			<p><code>item()</code> adds a single composable element to the list, while <code>items()</code> can receive not only a standalone list of content such as <code>myLongList</code> but also an <code>Int</code>, which will add the same item multiple times.</p>
			<p>The code that we featured previously should render a vertical list that contains the following:</p>
			<ul>
				<li>A header <code>Text</code> composable</li>
				<li>A list of <code>MyComposable</code> composables that are the same size as <code>myLongList</code></li>
				<li>Two <code>Text</code> footer composables</li>
			</ul>
			<p>Returning from the DSL world, a noteworthy argument for the lazy composables is <code>contentPadding</code>, which allows you to define horizontal/vertical padding surrounding your list. This argument expects a <code>PaddingValues</code> object – we will use it soon; don't worry!</p>
			<p>Now, we will soon<a id="_idIndexMarker091"/> receive the restaurants from a remote server, which means we don't know the size of the list, so it's time to implement such a lazy composable in our Restaurants application as well.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor063"/>Using LazyColumn to display restaurants</h2>
			<p>We are currently using <code>Column</code> to<a id="_idIndexMarker092"/> display our <code>dummyRestaurants</code> list. We know why that's not the best practice, so to optimize our UI for dynamic content, we will replace it with <code>LazyColumn</code> so that we can continue displaying the restaurants vertically.</p>
			<p>Go back to the <code>RestaurantsScreen.kt</code> file and, inside of the <code>RestaurantScreen</code> composable, replace the <code>Column</code> composable with <code>LazyColumn</code>:</p>
			<pre>@Composable
fun RestaurantsScreen() {
<strong class="bold">   LazyColumn(</strong>
<strong class="bold">       contentPadding = PaddingValues(</strong>
<strong class="bold">           vertical = 8.dp,</strong>
<strong class="bold">           horizontal = 8.dp)) {</strong>
<strong class="bold">       items(dummyRestaurants<a id="_idTextAnchor064"/><a id="_idTextAnchor065"/><a id="_idTextAnchor066"/>) { restaurant -&gt;</strong>
<strong class="bold">           RestaurantItem(restaurant)</strong>
<strong class="bold">       }</strong>
<strong class="bold">   }</strong>
}</pre>
			<p>We've used its DSL and specified the <code>items</code> properties that should populate our <code>LazyColumn</code> by passing the <code>dummyRestaurants</code> list. We obtained access to each item as a restaurant of type <code>Restaurant</code> and rendered it through a <code>RestaurantItem</code> composable.</p>
			<p>We also added additional padding through the <code>contentPadding</code> argument to our <code>LazyColumn</code> by passing a <code>PaddingValues</code> object where we configured the vertical and horizontal padding.</p>
			<p>You can now <code>LazyColumn</code> than with <code>Column</code>.</p>
			<p>We've done it! We've built our first Compose-based app from scratch while exploring tons of composable functions. We've added a list that scrolls beautifully, and we can now be proud of the result!</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor067"/>Summary</h1>
			<p>In this chapter, we learned how to build modern UIs on Android directly in Kotlin by using the Jetpack Compose toolkit. You learned how, in Compose, everything is a composable function and how this new declarative way of defining UIs improves and makes the way we build UIs much easier and less prone to bugs. </p>
			<p>We learned that Compose accelerates and greatly simplifies UI development with the help of concise Kotlin APIs and without the need for XML or other additional languages. We then covered the basic concepts behind Compose and the core components that allow you to build UIs.</p>
			<p>Finally, we saw how easy it is to build UI with Compose by creating a Compose-based screen that displays a list of restaurants. </p>
			<p>In <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>, we will use the fundamentals we've learned in this chapter to revisit the concept of state in Compose and learn how it is represented, as well as how we can correctly manage it with the help of another Jetpack component: <code>ViewModel</code>.</p>
			<p>First, we will understand what <code>ViewModel</code> is and why such a component is needed. Then, by continuing working on the Restaurants application that we started in this chapter, we will learn how to define and lift the UI's state in our own <code>ViewModel</code> class.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor068"/>Further reading</h1>
			<p>Exploring a library with the magnitude of Compose is nearly impossible in a single chapter. That's why you should also explore other topics that are of great importance when building your UI with Compose:</p>
			<ul>
				<li>We've briefly mentioned how Compose works with the help of a Kotlin compiler plugin. To better how this compiler plugin helps us define composable functions, check out this great article written by the official Android developer team: <a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd">https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd</a>.</li>
			</ul>
			<p>This article also covers the internals of Compose, so if you are curious about the execution model of Compose or what the compiler plugin does behind the scenes, make sure to check it out.</p>
			<ul>
				<li>Building UIs with Compose is simple, yet Compose is a very powerful framework that enables you to write highly reusable UIs. To take advantage of that, every Composable should receive a <code>Modifier</code> object that defines how it is arranged inside its caller parent. See what this means by checking out this great article, and then try to practice a bit: <a href="https://chris.banes.dev/always-provide-a-modifier/">https://chris.banes.dev/always-provide-a-modifier/</a>.</li>
				<li>Your layout should be adaptive and flexible for devices with different screen sizes or forms. You can learn more about this and try experimenting a bit by looking at the official documentation: <a href="https://developer.android.com/jetpack/compose/layouts/adaptive">https://developer.android.com/jetpack/compose/layouts/adaptive</a>.</li>
			</ul>
		</div>
	</body></html>