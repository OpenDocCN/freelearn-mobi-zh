<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-13"><em class="italic"><a id="_idTextAnchor012"/>Chapter 1</em>: Creating a Modern UI with Jetpack Compose</h1>
			<p>Jetpack libraries enable you to build and design high-quality, robust Android apps that have a reliable architecture and work consistently across different versions and devices. At the same time, the Jetpack suite allows you to eliminate boilerplate code and ultimately focus on what matters – building the necessary features.</p>
			<p>In this chapter, we<a id="_idIndexMarker000"/> will tackle one of the most popular Jetpack libraries for building <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>), called <strong class="bold">Compose</strong>. Simply put, Jetpack Compose is a powerful modern toolkit that allows you to build a native UI in Android directly with Kotlin functions and APIs.</p>
			<p>Compose accelerates and greatly simplifies UI development as it harnesses the power of declarative programming, combined with the ease of use of the Kotlin programming language. The new toolkit solely relies on Kotlin APIs when allowing you to construct UIs through declarative functions.</p>
			<p>By the end of this chapter, you will know how building UIs on Android can be done with less code, powerful tools, intuitive APIs, and without the need for additional languages such as XML.</p>
			<p>In the first section, <em class="italic">Understanding the core concepts of Compose</em>, we will explore the fundamental concepts behind Compose and understand how they are beneficial in helping us write better and cleaner UIs. We will see how UIs can be described with composable functions while also understanding how the new declarative way of building UIs on Android works. We will also explore how composition is favored over inheritance and how the data flow works in Compose. Finally, we will cover what recomposition is and see how essential it is to our declarative UI.</p>
			<p>In the second section, <em class="italic">Exploring the building blocks of Compose UIs</em>, we will study the most important composable functions that Compose provides out of the box. Afterward, we will see how we can preview our Compose UI and how activities render it.</p>
			<p>We will then put our knowledge to good use by creating our first Compose project about restaurants in the <em class="italic">Building a Compose-based screen</em> section. In the last section, entitled <em class="italic">Exploring lists with Compose</em>, we will learn how to correctly show more content in Compose with the help of lists.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the core concepts of Compose</li>
				<li>Exploring the building blocks of Compose UIs</li>
				<li>Building a Compose-based screen</li>
				<li>Exploring lists with Compose<p class="callout-heading">Note</p><p class="callout">As Compose is a dedicated native UI framework, we will only briefly cover the core concepts, common components, and usages of the toolkit without going into advanced topics.</p></li>
			</ul>
			<h1 id="_idParaDest-14"><a id="_idTextAnchor013"/>Technical requirements</h1>
			<p>When building Compose-based Android projects, you usually require your day-to-day tools for Android development. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>The Kotlin 1.6.10 or newer plugin must be installed in Android Studio.</li>
				<li>Jetpack Compose 1.1.1 or greater. You should follow this chapter and use the projects with this version. You can explore newer versions if you wish, though API differences might arise.</li>
			</ul>
			<p>You can find the GitHub repository containing the source code for this book here:<span class="hidden"> </span><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_01">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/</a>.</p>
			<p>To access the code presented in this chapter, navigate to the <strong class="source-inline">Chapter_01</strong> directory. The code snippets presented in the first two sections can be found in the <strong class="source-inline">ExamplesActivity.kt</strong> file, which is located in the root directory. The project coding solution for the Restaurants app, which we will develop in the last few sections of this chapter, can be found in the <strong class="source-inline">chapter_1_restaurants_app</strong> Android project directory.</p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Understanding the core concepts of Compose</h1>
			<p>Jetpack Compose dramatically changes the way we write UIs on Android. UIs are now developed with Kotlin, which enables a <a id="_idIndexMarker001"/>new declarative paradigm<a id="_idIndexMarker002"/> of writing layouts with widgets called <strong class="bold">composables</strong>.</p>
			<p>In this section, we will understand what composable functions are and how they are used to write UIs. We will learn how the programming paradigm has shifted and how composition is now enforced, thereby increasing flexibility in the way we define UIs. We will also discuss the flow of data within UIs and what recomposition is while trying to understand the benefits that are brought by these new concepts.</p>
			<p>To summarize, we will be covering the following topics:</p>
			<ul>
				<li>Describing UIs with composable functions</li>
				<li>The paradigm shift in creating UIs on Android</li>
				<li>Favoring composition over inheritance</li>
				<li>Unidirectional flow of data</li>
				<li>Recomposition</li>
			</ul>
			<p>So, let's get started.</p>
			<h2 id="_idParaDest-16"><a id="_idTextAnchor015"/>Describing UIs with composable functions</h2>
			<p>Compose<a id="_idIndexMarker003"/> allows you to build UIs by defining and calling <strong class="bold">composable</strong> functions. Composable functions are regular functions annotated with the <strong class="source-inline">@Composable</strong> annotation that represent widgets on the screen.</p>
			<p>Compose works with the help of a Kotlin compiler plugin in the type checking and code generation phase of Kotlin. The Compose compiler plugin makes sure that you can create composables.</p>
			<p>For example, a composable that displays a piece of text may look like this:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun FriendlyMessage(name: String) {</p>
			<p class="source-code">   Text(text = "Greetings $name!")</p>
			<p class="source-code">}</p>
			<p>In the preceding code block, we've defined the <strong class="source-inline">FriendlyMessage</strong> composable function by annotating it with the <strong class="source-inline">@Composable</strong> annotation. Looking at the function definition and body, we can easily deduce that it displays a greeting message.</p>
			<p>It's important to note that any function annotated with <strong class="source-inline">@Composable</strong> can be rendered on the <a id="_idIndexMarker004"/>screen as it will produce a piece of UI hierarchy that displays content. In their true sense, composable functions emit UI widgets based on their definition. </p>
			<p>In our case, the previous function should display a greeting message by concatenating the <strong class="source-inline">String</strong> value it receives as a parameter with a predefined message. As the function relies on its input parameters to show different messages on every usage, it's correct to say that composable functions are functions of data (presented as <strong class="bold">F(data)</strong> in the following diagram) that are converted into pieces of UI or widgets:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B17788_01_01.jpg" alt="Figure 1.1 – In Compose, UI is a function of data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – In Compose, UI is a function of data</p>
			<p>Later, in the <em class="italic">Unidirectional flow of data</em> subsection, we will understand why having functions to describe UI widgets is beneficial to our projects as it leads to a less bug-prone UI layer.</p>
			<p>Getting back to our<a id="_idIndexMarker005"/> example, you might be wondering what the <strong class="source-inline">Text</strong> functional call represents. As with every other framework, Compose provides composable functions such as <strong class="source-inline">Text</strong> out of the box that we can use.</p>
			<p>As its name suggests, the <strong class="source-inline">Text</strong> composable allows you to display some text on the screen. We will cover other composable functions provided by Compose in the <em class="italic">Exploring the building blocks of Compose UIs</em> section.</p>
			<p>Until then, let's have another look at the previous code example and highlight the most important rules when it comes to defining a composable function:</p>
			<ul>
				<li>It should be a regular function marked with the <strong class="source-inline">@Composable</strong> annotation. </li>
				<li>Its UI output is defined by the data that's received through its input parameters. Composable functions should return <strong class="source-inline">Unit</strong> as they emit UI elements and do not return data as regular functions do. Most of the time, we omit defining the <strong class="source-inline">Unit</strong> return type or even returning <strong class="source-inline">Unit</strong> – as Kotlin marks it as redundant – just like in the previous example.</li>
				<li>It can contain other composable functions or regular Kotlin code. In the previous example, the <strong class="source-inline">FriendlyMessage</strong> composable function makes use of another composable, called <strong class="source-inline">Text</strong>, but it could also call regular Kotlin code (we will tackle that in the upcoming sections).</li>
				<li>It should be named as a noun or a noun preceded by a suggestive adjective (but never a verb). This way, composable functions envision widgets and not actions. Additionally, its name should respect the PascalCase naming convention, meaning that the first letter of each compound word in a variable is capitalized.</li>
				<li>It's recommended that the function is public and not defined within a class but directly within a Kotlin file. This way, Compose promotes the reuse of composable functions. </li>
			</ul>
			<p>Now that we<a id="_idIndexMarker006"/> understand what a composable function is and how one is defined, let's move on and explore the paradigm shift that Compose brings to Android UI development.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>The paradigm shift in creating UIs on Android</h2>
			<p>Compose brings a<a id="_idIndexMarker007"/> new approach to Android UI development and that is providing a declarative way of describing your UI. Before trying to understand how the declarative approach works, we will learn how the traditional View System relies on a different paradigm – the imperative one.</p>
			<h3>The imperative paradigm</h3>
			<p>When describing your UI <a id="_idIndexMarker008"/>with XML, you represent the view<a id="_idIndexMarker009"/> hierarchy as a tree of widgets that are commonly known as views. Views, in the context of the traditional View System, are all the components that inherit from the <strong class="source-inline">android.view.View</strong> class, from <strong class="source-inline">TextView</strong>, <strong class="source-inline">Button</strong>, or <strong class="source-inline">ImageView</strong> to <strong class="source-inline">LinearLayout</strong>, <strong class="source-inline">RelativeLayout</strong>, and so on.</p>
			<p>Yet what's essential for the View System is the <em class="italic">imperative paradigm</em> that it relies on. Because your application must know how to react to user interactions and change the state of the UI accordingly, you can mutate the state of your views by referencing them through <strong class="source-inline">findViewById</strong> calls and then update their values through calls such as <strong class="source-inline">setText()</strong>, <strong class="source-inline">setBackgroundResource()</strong>, and so on.</p>
			<p>Since views maintain their internal state and expose setters and getters, you must imperatively set new states for each component, as the following diagram suggests:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17788_01_02.jpg" alt="Figure 1.2 – The Android View System features in the imperative paradigm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – The Android View System features in the imperative paradigm</p>
			<p>Manually manipulating views' states increases the chance of bugs and errors in your UI. Because you end up treating multiple possible states and because chunks of data are displayed in several such <a id="_idIndexMarker010"/>states, it's relatively easy to mess up the outcome of your UI. Illegal states or conflicts between states can also arise relatively easily when your UI grows in complexity.</p>
			<p>Moreover, since the layouts are defined in an additional component – that is, an XML file – the coupling between <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, or <strong class="source-inline">ViewModel</strong> and the XML-based UI increases. This means that changing something on the UI in the XML file will often lead to changes in <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, or <strong class="source-inline">ViewModel</strong> classes, which is where state handling happens. Not only that but cohesion is reduced because of language differences: one component is in Java/Kotlin, while the other one is in XML. This means that for the UI to function, it needs not only an <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> but also XML.</p>
			<h3>The declarative paradigm</h3>
			<p>To address some <a id="_idIndexMarker011"/>of the issues within the standard View System, Compose relies on a modern declarative UI model, which drastically simplifies the process of building, updating, and maintaining UIs on Android.</p>
			<p>If, in the traditional View System, the imperative paradigm described <em class="italic">how</em> the UI should change, in Compose, the declarative paradigm describes <em class="italic">what</em> the UI should render at a certain point in time.</p>
			<p>Compose does that by defining the screen as a tree of composables. As in the following examples, each composable passes<a id="_idIndexMarker012"/> data to its nested composables, just like the <strong class="source-inline">FriendlyMessage</strong> composable passed a name to the <strong class="source-inline">Text</strong> composable in our code example from the previous section:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B17788_01_03.jpg" alt="Figure 1.3 – Visualizing a tree of composable widgets and how data is passed downwards&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Visualizing a tree of composable widgets and how data is passed downwards</p>
			<p>When the input arguments change, Compose regenerates the entire widget tree from scratch. It applies the necessary changes and eliminates the need and the associated complexity of manually updating each widget.</p>
			<p>This means that in Compose, composables are relatively stateless and because of that, they don't expose getter and setter methods. This allows the caller to react to interactions and handle the process of creating new states separately. It does that by calling the same composables but with different argument values. As we discussed in the <em class="italic">Describing UIs with composable functions</em> section, the UI in Compose is a function of data. From this, we can conclude that if new data is passed to composables, new UI states can be produced.</p>
			<p>Lastly, compared to the View System, Compose only relies on Kotlin APIs, which means that UIs can now be defined with a single technology, in a single component, thereby increasing cohesion and reducing coupling.</p>
			<p>Now, let's look at another shift in design brought by Compose and discuss how composition yields more flexible ways of defining UIs than inheritance does. </p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Favoring composition over inheritance</h2>
			<p>In the Android View<a id="_idIndexMarker013"/> System, every view inherits functionality from the parent <strong class="source-inline">View</strong> class. As the system relies solely on inheritance, the task of creating custom views can only be done through defining elaborate hierarchies.</p>
			<p>Let's take the <strong class="source-inline">Button</strong> view as an example. It inherits functionality from <strong class="source-inline">TextView</strong>, which, in turn, inherits from <strong class="source-inline">View</strong>:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B17788_01_04.jpg" alt="Figure 1.4 – The class inheritance hierarchy for the Button view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – The class inheritance hierarchy for the Button view</p>
			<p>This strategy is great for reusing functionality, but inheritance becomes difficult to scale and has little flexibility when trying to have multiple variations of one view. </p>
			<p>Say you want the <strong class="source-inline">Button</strong> view to render an image instead of text. In the View System, you would have to create an entirely new inheritance hierarchy, as shown in the following hierarchy diagram:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B17788_01_05.jpg" alt="Figure 1.5 – The class inheritance hierarchy for the ImageButton view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – The class inheritance hierarchy for the ImageButton view</p>
			<p>But what if you need a button that accommodates both a <strong class="source-inline">TextView</strong> and an <strong class="source-inline">ImageView</strong>? This task would be extremely challenging, so it's easy to conclude that having separate inheritance hierarchies for each custom view is neither flexible nor scalable. </p>
			<p>These examples are real, and they show the limitations of the View System. As we've previously seen, one of the biggest reasons for the lack of flexibility is the inheritance model of the View System.</p>
			<p>To address this issue, <em class="italic">Compose favors composition over inheritance</em>. As shown in the following <a id="_idIndexMarker014"/>diagram, this means that Compose builds more complex UIs by using smaller pieces and not by inheriting functionality from one single parent:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B17788_01_06.jpg" alt="Figure 1.6 – Inheritance versus composition&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Inheritance versus composition</p>
			<p>Let's try to briefly explain our previous comparison between inheritance and composition:</p>
			<ul>
				<li>With inheritance, you are limited to inheriting your parent, just like <strong class="source-inline">Button</strong> inherits only from <strong class="source-inline">TextView</strong>.</li>
				<li>With composition, you can compose multiple other components, just like the <strong class="source-inline">Button</strong> composable contains both an <strong class="source-inline">Image</strong> composable and a <strong class="source-inline">Text</strong> composable, thereby giving you much more flexibility in building UIs.</li>
			</ul>
			<p>Let's try to build a composable that features a button with an image and text. This was a huge challenge with inheritance, but Compose simplifies this by allowing you to compose an <strong class="source-inline">Image</strong> composable and a <strong class="source-inline">Text</strong> composable inside a <strong class="source-inline">Button</strong> composable: </p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun SuggestiveButton() {</p>
			<p class="source-code">    Button(onClick = { }) {</p>
			<p class="source-code">        Row() {</p>
			<p class="source-code">            Image(painter = </p>
			<p class="source-code">                     painterResource(R.drawable.drawable),</p>
			<p class="source-code">                  contentDescription = "")</p>
			<p class="source-code">            Text(text = "Press me")</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, our <strong class="source-inline">SuggestiveButton</strong> composable contains both <strong class="source-inline">Image</strong> and <strong class="source-inline">Text</strong> composables. The beauty of this is that it could contain anything else. A <strong class="source-inline">Button</strong> composable can accept other <a id="_idIndexMarker015"/>composables that it renders as part of its button's body. Don't worry about this aspect or about that weird composable called <strong class="source-inline">Row</strong> for now. The <em class="italic">Exploring the building blocks of Compose UIs</em> section will cover both of these aspects in more detail. </p>
			<p>What's important to remember from this example is that Compose gives us the flexibility of building a custom UI with ease. Next, let's cover how data and events flow in Compose.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Unidirectional flow of data</h2>
			<p>Knowing that each <a id="_idIndexMarker016"/>composable passes data down to its children composables, we can deduct that the internal state is no longer needed. This also translates into a unidirectional flow of data because composables only expect data as input and never care about their state:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B17788_01_07.jpg" alt="Figure 1.7 – Visualizing the unidirectional flow of data and events&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Visualizing the unidirectional flow of data and events</p>
			<p>Similarly, with data, each composable passes down callback functions to its children composables. Yet this time, the callback functions are caused by user interactions, and they create an upstream of callbacks that goes from each nested composable to its parent and so on. This means that not only the data is unidirectional but also events, just in opposite ways.</p>
			<p>From this, it's clear that data and events travel only in one direction, and that's a good thing because only one source of truth – ideally, <strong class="source-inline">ViewModel</strong> – is in charge of handling them, resulting in<a id="_idIndexMarker017"/> fewer bugs and easier maintenance as the UI scales.</p>
			<p>Let's consider a case with another composable provided by Jetpack Compose called <strong class="source-inline">Button</strong>. As its name suggests, it emits a button widget on the screen, and it exposes a callback function called <strong class="source-inline">onClick</strong> that notifies us whenever the user clicks the button.</p>
			<p>In the following example, our <strong class="source-inline">MailButton</strong> composable receives data as an email identifier, <strong class="source-inline">mailId</strong>, and an event callback as a <strong class="source-inline">mailPressedCallback</strong> function:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MailButton(</p>
			<p class="source-code">    mailId: Int,</p>
			<p class="source-code">    mailPressedCallback: (Int) -&gt; Unit</p>
			<p class="source-code">) {</p>
			<p class="source-code">    Button(onClick = { mailPressedCallback(mailId) }) {</p>
			<p class="source-code">        Text(text = "Expand mail $mailId")</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>While it consumes the data it receives via <strong class="source-inline">mailId</strong>, it also sets the  <strong class="source-inline">mailPressedCallback</strong> function to be called every time its button is clicked, thereby sending the event back up to its parent. This <a id="_idIndexMarker018"/>way, data flows downwards and the callback flows upwards.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is ideal to construct your Compose UI in such a way that data provided by the <strong class="source-inline">ViewModel</strong> flows from parent composables to children composables and events flow from each composable back up to the <strong class="source-inline">ViewModel</strong>. If you're not familiar with the <strong class="source-inline">ViewModel</strong> component, don't worry as will cover it in the upcoming <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Recomposition</h2>
			<p>We have already covered how <a id="_idIndexMarker019"/>composable functions are defined by their input data and stated that whenever the data changes, composables are rebuilt as they render a new UI state corresponding to the newly received data.</p>
			<p>The process of calling your composable functions again when inputs change is called <strong class="bold">recomposition</strong>. When<a id="_idIndexMarker020"/> inputs change, Compose automatically triggers the recomposition process for us and rebuilds the UI widget tree, redrawing the widgets emitted by the composables so that they display the newly received data. </p>
			<p>Yet recomposing the entire UI hierarchy is computationally expensive, which is why Compose only calls the functions that have new input while skipping the ones whose input hasn't changed. Optimizing<a id="_idIndexMarker021"/> the process of rebuilding the composable tree is a complex job and is usually referred to as <em class="italic">intelligent recomposition</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the traditional View System, we would manually call the setters and getters of views, but with Compose, it's enough to provide new arguments to our composables. This will allow Compose to initiate the recomposition process for parts of the UI so that the updated values are displayed.</p>
			<p>Before jumping into an actual example of recomposition, let's have a quick look at the lifecycle of a composable function. Its lifecycle is defined by the composition lifecycle, as shown here:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B17788_01_08.jpg" alt="Figure 1.8 – The composition lifecycle of a composable function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – The composition lifecycle of a composable function</p>
			<p>This means that a composable first enters composition, and before leaving this process, it can recompose as many times as needed – that is, before it disappears from the screen, it can be recomposed and rebuilt many times, each time possibly displaying a different value.</p>
			<p>Recomposition is often<a id="_idIndexMarker022"/> triggered by changes within <strong class="source-inline">State</strong> objects, so let's look at an example to explore how seamlessly this happens with little intervention from our side. Say you have a <strong class="source-inline">TimerText</strong> composable that expects a certain number of elapsed <strong class="source-inline">seconds</strong> that it displays in a <strong class="source-inline">Text</strong> composable. The timer starts from 0 and updates every 1 second (or 1,000 ms), displaying the number of seconds that have elapsed:</p>
			<p class="source-code">var seconds by mutableStateOf(0)</p>
			<p class="source-code">val stopWatchTimer = timer(period = 1000) { seconds++ }</p>
			<p class="source-code">   ...</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun TimerText(seconds: Int) {</p>
			<p class="source-code">   Text(text = "Elapsed: $seconds")</p>
			<p class="source-code">}</p>
			<p>In the <em class="italic">Defining and handling state with Compose</em> section of <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>, we will define the state in Compose in more detail, but until then, let's think of <strong class="source-inline">seconds</strong> as a simple state object (instantiated with <strong class="source-inline">mutableStateOf()</strong>) that has an initial value of <strong class="source-inline">0</strong> and that its value changes over time, triggering a recomposition each time.</p>
			<p>Every time <strong class="source-inline">stopWatchTimer</strong> increases the value of the <strong class="source-inline">seconds</strong> state object, Compose triggers a recomposition that rebuilds the widget tree and redraws the composables with new arguments.</p>
			<p>In our case, <strong class="source-inline">TimerText</strong> will be recomposed or rebuilt because it receives different arguments – the first time, it will receive <strong class="source-inline">0</strong>, then <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and so on. This, in turn, triggers the <strong class="source-inline">Text</strong> composable to also recompose and that's why Compose redraws it on the screen to display the <a id="_idIndexMarker023"/>updated message.</p>
			<p>Recomposition is a complex topic. As we will not be able to go into too much depth on it now, it's important to also cover more advanced concepts, as described in the documentation: <a href="https://developer.android.com/jetpack/compose/mental-model#any-order">https://developer.android.com/jetpack/compose/mental-model#any-order</a>.</p>
			<p>Now that we've covered what recomposition is and the core concepts behind Compose, it's time to have a better look at the composables that are used to build a Compose UI.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Exploring the building blocks of Compose UIs</h1>
			<p>We've only had a <a id="_idIndexMarker024"/>brief look at the <strong class="source-inline">Text</strong> and <strong class="source-inline">Button</strong> composables so far. That's why, in this section, we will not only understand how activities can render <a id="_idIndexMarker025"/>composables instead of XML and how we can preview them, but we will also have a better look at the most important and commonly used composable functions: from the ones we've seen, such as <strong class="source-inline">Text</strong> and <strong class="source-inline">Button</strong>, to new ones such as <strong class="source-inline">TextField</strong>, <strong class="source-inline">Image</strong>, <strong class="source-inline">Row</strong>, <strong class="source-inline">Column</strong>, and <strong class="source-inline">Box</strong>.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>Setting content and previewing composables</li>
				<li>Exploring core composables</li>
				<li>Customizing composables with modifiers</li>
				<li>Layouts in Compose</li>
			</ul>
			<p>Let's jump in and understand how to render composable functions on the screen.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Setting content and previewing composables</h2>
			<p>We had a quick <a id="_idIndexMarker026"/>look at some composable<a id="_idIndexMarker027"/> functions, but we didn't quite touch on the aspect of making the application display Compose UIs. </p>
			<p>Setting the composable content can easily be achieved and is encouraged to be done in your <strong class="source-inline">Activity</strong> class by simply replacing the traditional <strong class="source-inline">setContentView(R.layout.XML)</strong> call with <strong class="source-inline">setContent()</strong> and passing a composable function to it:</p>
			<p class="source-code">import androidx.activity.compose.setContent</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">   override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">       super.onCreate(savedInstanceState)</p>
			<p class="source-code">       <strong class="bold">setContent {</strong></p>
			<p class="source-code">           Text("Hello world")</p>
			<p class="source-code">       <strong class="bold">}</strong></p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>Because Compose no longer needs the <strong class="source-inline">AppCompat</strong> API for backward compatibility, we made our <strong class="source-inline">MainActivity</strong> inherit the base <strong class="source-inline">ComponentActivity</strong> class.</p>
			<p>In the previous example, we called the <strong class="source-inline">setContent</strong> method in the <strong class="source-inline">onCreate</strong> callback of <strong class="source-inline">MainActivity</strong> and passed a <strong class="source-inline">Text</strong> composable function to it. If we run the app, we will see the <strong class="source-inline">"Hello world"</strong> message.</p>
			<p>The <strong class="source-inline">setContent</strong> method is an extension function for <strong class="source-inline">ComponentActivity</strong> that composes the given composable into the given activity. It only accepts a <strong class="source-inline">@Composable</strong> function as a trailing lambda. The input composable function will become the root view of the activity and act as a container for your Compose hierarchy.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can add composable functions into fragments or activities that have an XML UI already defined with the help of the <strong class="source-inline">ComposeView</strong> class, but we will not go into too much detail as far as interoperability goes.</p>
			<p>As XML provided us <a id="_idIndexMarker028"/>with a preview tool, a good question would be whether Compose also has one. Compose brings an <a id="_idIndexMarker029"/>even more powerful preview tool that allows us to skip running the application on the emulator or real devices every time we want to see how our UI evolves. </p>
			<p>Previewing your composable is easy; just add the <strong class="source-inline">@Preview</strong> annotation to it:</p>
			<p class="source-code">@Preview(showBackground = true)</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun FriendlyMessage() {</p>
			<p class="source-code">   Text<a id="_idTextAnchor022"/>(text = "Greetings!")</p>
			<p class="source-code">}</p>
			<p>The IDE will automatically pick up that you want to preview this composable and show it on the right-hand side of the screen. Make sure that you <em class="italic">rebuild</em> your project and have the <strong class="bold">Split</strong> option enabled: </p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B17788_01_09.jpg" alt="Figure 1.9 – Previewing composable functions in Android Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Previewing composable functions in Android Studio</p>
			<p>Optionally, you can specify for the <a id="_idIndexMarker030"/>preview to show a background for better visibility by passing the <strong class="source-inline">showBackground</strong> parameter with a<a id="_idIndexMarker031"/> value of <strong class="source-inline">true</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure that the composable function you are trying to preview has no input parameters. If it has, supply the default values for them so that the preview tools can work.</p>
			<p>Yet this preview tool is much more powerful than this as it supports <strong class="bold">Interactive mode</strong>, which allows you to interact with the UI, and <strong class="bold">Live Edit of literals</strong>, which, if enabled, causes the preview to reload every time you change widths, heights, or others, just like a real UI would. You can see these two options in the following screenshot:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B17788_01_10.jpg" alt="Figure 1.10 – Using the Preview feature in Compose&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Using the Preview feature in Compose</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To enable <strong class="bold">Interactive mode</strong> on Android Studio Arctic Fox, go to <strong class="bold">File</strong> | <strong class="bold">Settings</strong> | <strong class="bold">Experimental</strong> (Windows) or <strong class="bold">Android Studio</strong> | <strong class="bold">Preferences</strong> | <strong class="bold">Experimental</strong> (macOS).</p>
			<p>Additionally, you<a id="_idIndexMarker032"/> can have multiple previews<a id="_idIndexMarker033"/> simultaneously if you annotate each function with the <strong class="source-inline">@Preview</strong> annotation. You can add names for each preview through the <strong class="source-inline">name</strong> parameter and even tell the preview tool which device it should display it on through the <strong class="source-inline">device</strong> argument:</p>
			<p class="source-code">@Preview(</p>
			<p class="source-code">    name = "Greeting preview",</p>
			<p class="source-code">    showSystemUi = true,</p>
			<p class="source-code">    device = Devices.PIXEL_2_XL</p>
			<p class="source-code">)</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun FriendlyMessagePreview() { Text(text = "Greetings!") }</p>
			<p class="source-code">@Preview(</p>
			<p class="source-code">        showSystemUi = true,</p>
			<p class="source-code">        device = Devic<a id="_idTextAnchor023"/>es.NEXUS_5)</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun FriendlyMessagePreview2() { Text(text = "Goodbye!") }</p>
			<p>Make sure that you also set <strong class="source-inline">showSystemUi</strong> to <strong class="source-inline">true</strong> to see the entire device. </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">@Preview</strong> functions should have different names to avoid preview conflicts.</p>
			<p>Now that we <a id="_idIndexMarker034"/>have learned how to set and preview<a id="_idIndexMarker035"/> Compose UI, it's time to explore new composables.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>Exploring core composables</h2>
			<p>We've already had a quick <a id="_idIndexMarker036"/>look at some of the most basic composable functions: <strong class="source-inline">Text</strong>, <strong class="source-inline">Button</strong>, and <strong class="source-inline">Image</strong>. In this subsection, we will spend a bit more time exploring not only those composables but also new ones such as <strong class="source-inline">TextField</strong>.</p>
			<h3>Text</h3>
			<p><strong class="source-inline">Text</strong> is the Compose version of our old and beloved <strong class="source-inline">TextView</strong>. <strong class="source-inline">Text</strong> is provided by Compose and achieves the<a id="_idIndexMarker037"/> most basic and yet important functionality in any application: the ability to display a piece of text. We've already used this composable in several examples:</p>
			<p class="source-code">Text(text = "Greetings $name!")</p>
			<p>You might be wondering how we can customize it. Let's check out the source code or the documentation for <strong class="source-inline">Text</strong> to find the most basic and commonly used arguments for it:</p>
			<ul>
				<li><strong class="source-inline">text</strong> is the only required argument. It expects a <strong class="source-inline">String</strong> and sets the output text.</li>
				<li><strong class="source-inline">color</strong> specifies the color of the output text and expects a <strong class="source-inline">Color</strong> object.</li>
				<li><strong class="source-inline">fontSize</strong> of type <strong class="source-inline">TextUnit</strong>, <strong class="source-inline">fontStyle</strong> of type <strong class="source-inline">FontStyle</strong>, <strong class="source-inline">fontFamily</strong> of type <strong class="source-inline">FontFamily</strong>, an<a id="_idTextAnchor025"/>d <strong class="source-inline">fontWeight</strong> of type <strong class="source-inline">FontWeight</strong> all allow you to customize the look a<a id="_idTextAnchor026"/>nd appearance of your text.</li>
				<li><strong class="source-inline">textAlign</strong> specifies the horizontal alignment of the text. It expects a <strong class="source-inline">TextAlign</strong> object.</li>
				<li><strong class="source-inline">maxLines</strong> expects an <strong class="source-inline">Int</strong> value that sets the maximum number of lines in the output text.</li>
				<li><strong class="source-inline">style</strong> expects a <strong class="source-inline">TextStyle</strong> object and allows you to define and reuse styles through themes.</li>
			</ul>
			<p>Instead of going through all the arguments<a id="_idIndexMarker038"/> for <strong class="source-inline">Text</strong>, let's check out an example where we can customize the look of our <strong class="source-inline">Text</strong> composable function:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MyAppText() {</p>
			<p class="source-code">   Text(</p>
			<p class="source-code">       text = stringResource(id = R.string.app_name),</p>
			<p class="source-code">       fontStyle = FontStyle.Italic,</p>
			<p class="source-code">       textAlign = TextAlign.Center,</p>
			<p class="source-code">       color = Color.Magenta,</p>
			<p class="source-code">       fontSize = 24.sp,</p>
			<p class="source-code">       fontWe<a id="_idTextAnchor027"/><a id="_idTextAnchor028"/>ight = FontWeight.ExtraBold)</p>
			<p class="source-code">}</p>
			<p>Instead of passing some hardcoded text, we passed a string resource with the help of the built-in <strong class="source-inline">stringResource</strong> function and obtained the following result:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B17788_01_11.jpg" alt="Figure 1.11 – Exploring a customized Text composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Exploring a customized Text composable</p>
			<p>Now that we've learned how to display text with the <strong class="source-inline">Text</strong> composable, let's move on to buttons.</p>
			<h3>Button</h3>
			<p>Displaying<a id="_idIndexMarker039"/> text is essential in any application, yet having clickable buttons allows it to be interactive. We've used the <strong class="source-inline">Button</strong> composable (previously known in the View System as <strong class="source-inline">Button</strong> too) before and its main characteristic was the <strong class="source-inline">onClick</strong> callback function, which notified us when the user pressed the button.</p>
			<p>While <strong class="source-inline">Button</strong> features plenty of customizing arguments, let's check out the most used parameters:</p>
			<ul>
				<li><strong class="source-inline">onClick</strong> is a mandatory parameter and it expects a function that will be called whenever the user presses the button.</li>
				<li><strong class="source-inline">colors</strong> expects a <strong class="source-inline">ButtonColors</strong> object that defines the content/background colors.</li>
				<li><strong class="source-inline">shape</strong> expects a custom/Material theme <strong class="source-inline">Shape</strong> object that sets the shape of the button.</li>
				<li><strong class="source-inline">content</strong> is a mandatory parameter that expects a composable function that displays the content inside this <strong class="source-inline">Button</strong>. We can add any composables here, including <strong class="source-inline">Text</strong>, <strong class="source-inline">Image</strong>, and more.</li>
			</ul>
			<p>Let's try to build a <strong class="source-inline">Button</strong> function that makes use of these core arguments:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ClickableButton() {</p>
			<p class="source-code">   Button(</p>
			<p class="source-code">       onClick = { /* callback */ },</p>
			<p class="source-code">       colors = ButtonDefaults.buttonColors(</p>
			<p class="source-code">           backgroundColor = Color.Blue,</p>
			<p class="source-code">           contentColor = Color.Red),</p>
			<p class="source-code">       shape = MaterialTheme.shapes.medi<a id="_idTextAnchor029"/>um</p>
			<p class="source-code">   ) { Text("Press me") }</p>
			<p class="source-code">}</p>
			<p>We've also passed a <a id="_idIndexMarker040"/>predefined <strong class="source-inline">MaterialTheme</strong> shape. Let's preview the resulting composable:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B17788_01_12.jpg" alt="Figure 1.12 – Exploring a customized Button composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Exploring a customized Button composable</p>
			<p>With that, we've seen how easy it is to create a custom button with the <strong class="source-inline">Button</strong> composable. Next up, let's try to play around with another composable function – <strong class="source-inline">TextField</strong>.</p>
			<h3>TextField</h3>
			<p>Adding buttons is the first <a id="_idIndexMarker041"/>step toward having an interactive UI, but the most important element in this area is the <strong class="source-inline">TextField</strong> composable, previously known in the View System as <strong class="source-inline">EditText</strong>. Just like <strong class="source-inline">EditText</strong> did, the <strong class="source-inline">TextField</strong> composable allows the user to enter and modify text.</p>
			<p>While <strong class="source-inline">TextField</strong> has many arguments, the most important ones that it features are as follows:</p>
			<ul>
				<li><strong class="source-inline">value</strong> is a mandatory <strong class="source-inline">String</strong> argument as it's the displayed text. This value should change as we type inside it by holding it in a <strong class="source-inline">State</strong> object; more on that soon.</li>
				<li><strong class="source-inline">onValueChange</strong> is a mandatory function that triggers every time the user inputs new characters or deletes existing ones. </li>
				<li><strong class="source-inline">label</strong> expects a composable function that allows us to add a descriptive label.</li>
			</ul>
			<p>Let's have a look at a simple usage of a <strong class="source-inline">TextField</strong> that also handles its own state:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun NameInput() {</p>
			<p class="source-code">   val textState = remember { mutableStateOf("") }</p>
			<p class="source-code">   TextField(</p>
			<p class="source-code">        value = textState.value,</p>
			<p class="source-code">        onValueChange = { newValue -&gt;</p>
			<p class="source-code">            textState.value = newValue</p>
			<p class="source-code">        },</p>
			<p class="source-code">        label = { Text("Your name") })</p>
			<p class="source-code">}</p>
			<p>It achieves this by defining a <strong class="source-inline">MutableState</strong> that holds the text displayed by <strong class="source-inline">TextField</strong>. This means that <strong class="source-inline">textState</strong> doesn't change across recompositions, so every time the UI updates because of other composables, <strong class="source-inline">textState</strong> should be retained. Moreover, we've wrapped the <strong class="source-inline">MutableState</strong> object in a <strong class="source-inline">remember</strong> block, which tells Compose that across recompositions, it should not revert the value to its initial value; that is, <strong class="source-inline">""</strong>.</p>
			<p>To get or set the value of a <strong class="source-inline">State</strong> or <strong class="source-inline">MutableState</strong> object, our <strong class="source-inline">NameInput</strong> composable uses the <strong class="source-inline">value</strong> accessor. Because <strong class="source-inline">TextField</strong> accesses a <strong class="source-inline">MutableState </strong>object through the <strong class="source-inline">value</strong> accessor, Compose knows to retrigger a <em class="italic">recomposition</em> every time the <strong class="source-inline">textState</strong> value changes – in our case, in the <strong class="source-inline">onValueChange</strong> callback. By doing so, we ensure that as we input text in our <strong class="source-inline">TextField</strong>, the UI also updates with the new characters that have been added or removed from the keyboard.</p>
			<p>Don't worry if these <a id="_idIndexMarker042"/>concepts about state in Compose don't make too much sense right now – we will cover how state is defined in Compose in more detail in <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>.</p>
			<p class="callout-heading">Note:</p>
			<p class="callout">Unlike <strong class="source-inline">EditText</strong>, <strong class="source-inline">TextField</strong> has no internal state. That's why we've created and handled it; otherwise, as we would type in, the UI would not update accordingly.</p>
			<p>The resulting <strong class="source-inline">NameInput</strong> composable updates the UI correctly and looks like this:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B17788_01_13.jpg" alt="Figure 1.13 – Exploring a TextField composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Exploring a TextField composable</p>
			<p>Now that we've learned how to add input fields within a Compose-based app, it's time to explore one of the<a id="_idIndexMarker043"/> most common elements in any UI.</p>
			<h3>Image</h3>
			<p>Displaying graphical information in <a id="_idIndexMarker044"/>our application is essential and Compose provides us with a handy composable called <strong class="source-inline">Image</strong>, which is the composable version of the <strong class="source-inline">ImageView</strong> from the View System.</p>
			<p>While <strong class="source-inline">Image</strong> features plenty of customizing arguments, let's check out the most used parameters:</p>
			<ul>
				<li><strong class="source-inline">painter</strong> expects a <strong class="source-inline">Painter</strong> object. This argument is mandatory as it sets the image resource. Alternatively, you can use the overloaded version of <strong class="source-inline">Image</strong> to directly pass an <strong class="source-inline">ImageBitmap</strong> object to its <strong class="source-inline">bitmap</strong> parameter.</li>
				<li><strong class="source-inline">contentDescription</strong> is a mandatory <strong class="source-inline">String</strong> that's used by accessibility services.</li>
				<li><strong class="source-inline">contentScale</strong> expects a <strong class="source-inline">ContentScale</strong> object that specifies the scaling of the picture.</li>
			</ul>
			<p>Let's add an <strong class="source-inline">Image</strong> composable that displays the application icon using <strong class="source-inline">painterResource</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun BeautifulImage() {</p>
			<p class="source-code">    Image(</p>
			<p class="source-code">        painter =</p>
			<p class="source-code">           painterResource(R.drawable.ic_launcher_foreground),</p>
			<p class="source-code">        contentDescription = "My app icon",</p>
			<p class="source-code">        contentScale = ContentScale.Fit</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>Finally, let's preview the <strong class="source-inline">BeautifulImage</strong> function and then move on to the next section:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B17788_01_14.jpg" alt="Figure 1.14 – Exploring the Image composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – Exploring the Image composable</p>
			<p>We've also tried displaying<a id="_idIndexMarker045"/> images with Compose, yet you may still be wondering, how can we customize all these composable functions?</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>Customizing composables with modifiers</h2>
			<p>All the composables we've covered so far feature an argument that we haven't covere<a id="_idTextAnchor031"/>d yet: <strong class="source-inline">modifier</strong>. This expects a <strong class="source-inline">Modifier</strong> object. In simple terms, <em class="italic">modifiers tell a composable how to display, arrange, or behave within its parent composable.</em> By passing a modifier, we<a id="_idIndexMarker046"/> can specify many<a id="_idIndexMarker047"/> configurations for a composable: from size, padding, or shape to background color or border. </p>
			<p>Let's start with an example by using a <strong class="source-inline">Box</strong> composable and specifying a <strong class="source-inline">size</strong> modifier for it:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ColoredBox() {</p>
			<p class="source-code">   Box(<a id="_idTextAnchor032"/>modifier = <strong class="bold">Modifier.size(120.dp)</strong>)</p>
			<p class="source-code">}</p>
			<p>We will cover the <strong class="source-inline">Box</strong> composable later but until then, you can think of it like a container that we will use to draw several shapes on the screen. What's important here is that we passed the <strong class="source-inline">Modifier.size()</strong> modifier, which sets the size of the box. It accepts a <strong class="source-inline">dp</strong> value that represents both the width and the height of the composable. You can also pass the width and height as parameters within the <strong class="source-inline">size()</strong> modifier or separately with the help of the <strong class="source-inline">height()</strong> and <strong class="source-inline">width()</strong> modifiers.</p>
			<p>Specifying only one modifier for composables is usually not enough. That's why <em class="italic">modifiers can be chained</em>. Let's chain multiple modifiers by adding several other configurations to our <strong class="source-inline">Box</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ColoredBox() {</p>
			<p class="source-code">   Box(modifier = Modifier</p>
			<p class="source-code">           .size(120.dp)</p>
			<p class="source-code">           .background(Color.Green)</p>
			<p class="source-code">           .padding(16.dp)</p>
			<p class="source-code">           .clip(RoundedCornerShape(size = 20.dp))</p>
			<p class="source-code">           .background(Color.Red))</p>
			<p class="source-code">}</p>
			<p>As we mentioned <a id="_idIndexMarker048"/>previously, chaining modifiers is simple: start with an empty <strong class="source-inline">Modifier</strong> object and then chain new modifiers one after the<a id="_idIndexMarker049"/> other. We've chained several new modifiers, starting with <strong class="source-inline">background</strong>, then <strong class="source-inline">padding</strong>, <strong class="source-inline">clip</strong>, and finally another <strong class="source-inline">background</strong>. The modifiers, when combined, produce an output consisting of a green rectangle that contains a nested rounded corner rectangle that's red:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B17788_01_15.jpg" alt="Figure 1.15 – Exploring chained modifiers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15 – Exploring chained modifiers</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The order of the modifiers in the chain matters because modifiers are applied from the outer layer to the inner layer. Each modifier modifies the composable and then prepares it for the upcoming modifier in the chain. Different modifier orders yield different results.</p>
			<p>In the previous example, because<a id="_idIndexMarker050"/> modifiers are applied from the outermost layer to the innermost layer, the entire rectangular box is green because green is the first color modifier that's applied. Going inner, we applied a padding of 16 <strong class="source-inline">dp</strong>. Afterward, still going inner, the <strong class="source-inline">RoundedCornerShape</strong> modifier is applied. Finally, in the innermost layer, we applied another color modifier – this time, of the color red – and we got our final result.</p>
			<p>Now that we've played around with the most common composables, it's time to start building actual layouts that make <a id="_idIndexMarker051"/>use of multiple composable functions.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor033"/>Layouts in Compose</h2>
			<p>Often, building <a id="_idIndexMarker052"/>even a simple screen cannot be achieved by following the previous examples since most of them feature only one composable. For<a id="_idIndexMarker053"/> simple use cases, composable functions contain only one composable child.</p>
			<p>To build more complex pieces of UI, layout components in Compose give you the option to add as many children composables as you need.</p>
			<p>In this section, we will cover those composable functions that allow you to place children composables in a linear or overlayed fashion, such as the following:</p>
			<ul>
				<li><strong class="source-inline">Row</strong> for arranging children composables in a horizontal fashion</li>
				<li><strong class="source-inline">Column</strong> for arranging children composables vertically</li>
				<li><strong class="source-inline">Box</strong> for arranging children composables on top of each other</li>
			</ul>
			<p>Following these definitions, let's envision the layout composables with the following diagram:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B17788_01_16.jpg" alt="Figure 1.16 – Exploring Column, Row, and Box&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16 – Exploring Column, Row, and Box</p>
			<p>It's clear now<a id="_idIndexMarker054"/> that arranging children composables in different ways <a id="_idIndexMarker055"/>can easily be achieved with <strong class="source-inline">Column</strong>, <strong class="source-inline">Row</strong>, and <strong class="source-inline">Box</strong>, so it's time to look at them in more detail.</p>
			<h3>Row</h3>
			<p>Displaying multiple widgets on the screen is achieved by using a <strong class="source-inline">Row</strong> composable that arranges its <a id="_idIndexMarker056"/>children composables horizontally, just like the old <strong class="source-inline">LinearLayout</strong> with horizontal orientation did:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun HorizontalNumbersList() {</p>
			<p class="source-code">   Row(</p>
			<p class="source-code">       horizontalArrangement = Arrangement.Start,</p>
			<p class="source-code">       verticalAlignment = Alignment.CenterVertically,</p>
			<p class="source-code">       modifier = Modifier.fillMaxWidth()</p>
			<p class="source-code">   ) {</p>
			<p class="source-code">       Text("1", fontSize = 36.sp)</p>
			<p class="source-code">       Text("2", fontSize = 36.sp)</p>
			<p class="source-code">       Text("3", fontSize = 36.sp)<a id="_idTextAnchor034"/></p>
			<p class="source-code">       Text("4", fontSize = 36.sp)</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>We've set <strong class="source-inline">Row</strong> to only take the available width and added several <strong class="source-inline">Text</strong> functions<a id="_idTextAnchor035"/> as children composables. We specified a <strong class="source-inline">horizontalArrangement</strong> of <strong class="source-inline">Start</strong> so that they start from the left of the<a id="_idIndexMarker057"/> parent but also made sure that they are centered vertically by passing a <strong class="source-inline">CenterVertically</strong> alignment for the <strong class="source-inline">verticalAlignment</strong> argument. The result is straightforward:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B17788_01_17.jpg" alt="Figure 1.17 – Exploring the Row composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17 – Exploring the Row composable</p>
			<p>Largely, the essential arguments for a <strong class="source-inline">Row</strong> composable are related to how children are arranged or aligned:</p>
			<ul>
				<li><strong class="source-inline">horizontalArrangement</strong> defines how the children are positioned horizontally both relative to each other and within the parent <strong class="source-inline">Row</strong>. Apart from <strong class="source-inline">Arragement.Start</strong>, you can also pass <strong class="source-inline">Center</strong> or <strong class="source-inline">End</strong> or <strong class="source-inline">SpaceBetween</strong>, <strong class="source-inline">SpaceEvenly</strong>, or <strong class="source-inline">SpaceAround</strong>.</li>
				<li><strong class="source-inline">verticalAlignment</strong> sets how the children are positioned vertically within the parent <strong class="source-inline">Row</strong>. Apart from <strong class="source-inline">Alignment.CenterVertically</strong>, you can pass <strong class="source-inline">Top</strong> or <strong class="source-inline">Bottom</strong>.</li>
			</ul>
			<p>Now that we've arranged the children composables horizontally, let's try to arrange them vertically.</p>
			<h3>Column</h3>
			<p>Displaying a vertical list on the screen <a id="_idIndexMarker058"/>can be achieved by using a <strong class="source-inline">Column</strong> composable that arranges its children composables vertically, just like the old <strong class="source-inline">LinearLayout</strong> with vertical orientation did:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun NamesVerticalList() {</p>
			<p class="source-code">   Column(verticalArrangement = Arrangement.SpaceEvenly,</p>
			<p class="source-code">       horizontalAlignment = Alignment.CenterHorizontally,</p>
			<p class="source-code">       modifier = Modifier.fillMaxSize()</p>
			<p class="source-code">   ) {</p>
			<p class="source-code">       Text("John", fontSize = 36.sp)</p>
			<p class="source-code">       Text("Amanda", fontSize = 36.sp)</p>
			<p class="source-code">       Text("Mike", fontSize = 36.sp)</p>
			<p class="source-code">       Text("Alma", fontSize = 36.sp)</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>We've set <strong class="source-inline">Column</strong> to take<a id="_idIndexMarker059"/> all the available space and added several <strong class="source-inline">Text</strong> functions as children composables. This time, we specified a <strong class="source-inline">verticalArrangement</strong> of <strong class="source-inline">SpaceEvenly</strong> so that children are spread out equally within the parent, but we also made sure they are centered horizontally by passing a <strong class="source-inline">CenterHorizontally</strong> alignment as <strong class="source-inline">horizontalAlignment</strong>:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B17788_01_18.jpg" alt="Figure 1.18 – Exploring the Column composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18 – Exploring the Column composable</p>
			<p>Similar to <strong class="source-inline">Row</strong>, the <a id="_idIndexMarker060"/>essential arguments for a <strong class="source-inline">Column</strong> are also related to how children are arranged or aligned. This time, though, the arrangement is vertical instead of horizontal, and the alignment is horizontal instead of vertical:</p>
			<ul>
				<li><strong class="source-inline">verticalArrangement</strong> defines how the children are vertically positioned within the parent <strong class="source-inline">Column</strong>. The values are the same as the row's <strong class="source-inline">horizontalArrangement</strong>.</li>
				<li><strong class="source-inline">horizontalAlignment</strong> defines how the children are aligned within the parent <strong class="source-inline">Column</strong>. Apart from <strong class="source-inline">Alignment.CenterHorizontally</strong>, you can pass <strong class="source-inline">Start</strong> or <strong class="source-inline">End</strong>.<p class="callout-heading">Note</p><p class="callout">If you're feeling brave, this is a great time for you to explore different alignments and arrangements and see how the UI changes. Make sure that you preview your composable functions with the <strong class="source-inline">@Preview</strong> annotation.</p></li>
			</ul>
			<h3>Box</h3>
			<p>So far, we've learned how to arrange children horizontally and vertically, but what if we want to place them <a id="_idIndexMarker061"/>on top of each other? The <strong class="source-inline">Box</strong> composable comes to our rescue as it allows us to stack children composables. <strong class="source-inline">Box</strong> also allows us to position the children relatively to it.</p>
			<p>Let's try to <a id="_idIndexMarker062"/>build our own <strong class="bold">Floating Action Button</strong> (<strong class="bold">FAB</strong>) with the help of <strong class="source-inline">Box</strong>. We will stack two composables inside <strong class="source-inline">Box</strong>: </p>
			<ul>
				<li>One green circle, which will be created with the help of <strong class="source-inline">Surface</strong>. The <strong class="source-inline">Surface</strong> composable allows you to easily define a material surface with a certain shape, background, or elevation.</li>
				<li>One plus sign (<strong class="source-inline">+</strong>) added as text inside the <strong class="source-inline">Text</strong> composable, which is aligned in the center of its parent <strong class="source-inline">Box</strong>.</li>
			</ul>
			<p>This is what the code will look like:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MyFloatingActionButton() {</p>
			<p class="source-code">   Box {</p>
			<p class="source-code">       Surface(</p>
			<p class="source-code">           modifier = Modifier.size(32.dp),</p>
			<p class="source-code">           color = Color.Green,</p>
			<p class="source-code">           shape = CircleShape,</p>
			<p class="source-code">           content = { })</p>
			<p class="source-code">       Text(text = "+",</p>
			<p class="source-code">            modif<a id="_idTextAnchor036"/>ier = Modifier.align(Alignment.Center))</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Surface</strong> composable is defined with a mandatory <strong class="source-inline">content</strong> parameter that accepts another composable as its inner content. We don't want to add a composable inside of it. Instead, we want to stack a <strong class="source-inline">Text</strong> composable on top of it, so we passed an empty function<a id="_idIndexMarker063"/> to the <strong class="source-inline">content</strong> parameter.</p>
			<p>The result is similar to the FAB we are all used to:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B17788_01_19.jpg" alt="Figure 1.19 – Exploring the Box composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.19 – Exploring the Box composable</p>
			<p>To take advantage of <strong class="source-inline">Box</strong>, you must keep the following in mind:</p>
			<ul>
				<li>The order in which composables are added within <strong class="source-inline">Box</strong> defines the order in which they are painted and stacked on top of each other. If you switch the order of <strong class="source-inline">Surface</strong> and <strong class="source-inline">Text</strong>, the <strong class="source-inline">+</strong> icon will be painted beneath the green circle making it invisible.</li>
				<li>You can align the children composables relative to the <strong class="source-inline">Box</strong> parent by passing different values for each of the child's alignment modifiers. That's why, apart from <strong class="source-inline">Alignment.Center</strong>, you can also position children composables with <strong class="source-inline">CenterStart</strong>, <strong class="source-inline">CenterEnd</strong>, <strong class="source-inline">TopStart</strong>, <strong class="source-inline">TopCenter</strong>, <strong class="source-inline">TopEnd</strong>, <strong class="source-inline">BottomStart</strong>, <strong class="source-inline">BottomEnd</strong>, or <strong class="source-inline">BottomCenter</strong>.</li>
			</ul>
			<p>Now that we covered the basics, it's time to roll up our sleeves and create our first Compose project!</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor037"/>Building a Compose-based screen</h1>
			<p>Let's say we want to<a id="_idIndexMarker064"/> build an application that showcases some restaurants. We will build the UI with Compose and go through the steps of creating a new Compose project. We will then build a list item for such a restaurant and finally display a dummy list of such items.</p>
			<p>To summarize, in this section, we will build our first Compose-based application: a restaurant explorer app! To achieve that, we must display some restaurants, which we will do by covering the following topics:</p>
			<ul>
				<li>Creating your first Compose project</li>
				<li>Building a restaurant element layout</li>
				<li>Displaying a list of restaurants with Compose</li>
			</ul>
			<p>Now that we have a clear path, let's get started.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor038"/>Creating your first Compose project</h2>
			<p>To build a restaurant app, we<a id="_idIndexMarker065"/> have to create a new Compose-based project:</p>
			<ol>
				<li>Open Android Studio and select the <strong class="bold">New Project</strong> option:</li>
			</ol>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B17788_01_20.jpg" alt="Figure 1.20 – Starting a new project with Android Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20 – Starting a new project with Android Studio</p>
			<p>If you already have Android Studio open, go to <strong class="bold">File</strong>, then <strong class="bold">New</strong>, and finally <strong class="bold">New Project</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure that you have Android Studio version Arctic Fox 2020.3.1 or newer. If you're using a newer version though, some files might have differences in the generated code.</p>
			<ol>
				<li value="2">In the <strong class="bold">Phone and tablet</strong> template section, select <strong class="bold">Empty Compose Activity</strong> and then choose <strong class="bold">Next</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B17788_01_21.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.21 – Starting a new project with Android Studio</p>
			<ol>
				<li value="3">Next, enter some details about <a id="_idIndexMarker066"/>your application. In the <strong class="bold">Name</strong> field, enter <strong class="source-inline">Restaurants app</strong>. Leave <strong class="bold">Kotlin</strong> as-is for <strong class="bold">Language</strong> and set <strong class="bold">Minimum SDK</strong> to <strong class="bold">API 21</strong>. Then, click <strong class="bold">Finish</strong>.<p class="callout-heading">Important note</p><p class="callout">The upcoming step is an essential configuration step. It makes sure that the project Android Studio has configured for you the same versions of dependencies (from Compose, to Kotlin and other dependencies) that we use throughout the book. By doing so, you will be able to follow the code snippets and inspect the code source without any API differences.</p></li>
				<li>Inside the newly<a id="_idIndexMarker067"/> generated project, before inspecting the code, make sure that the generated project uses the versions of dependencies that are used throughout the book.</li>
			</ol>
			<p>To do so, first go to the project-level <strong class="source-inline">build.gradle</strong> file and inside the <strong class="source-inline">dependencies</strong> block, make sure that the Kotlin version is set to <strong class="source-inline">1.6.10</strong>:</p>
			<p class="source-code">buildscript {</p>
			<p class="source-code">    […]</p>
			<p class="source-code">    dependencies {</p>
			<p class="source-code">        classpath "com.android.tools.build:gradle:7.0.2"</p>
			<p class="source-code">        classpath "org.jetbrains.kotlin:kotlin-gradle- </p>
			<p class="source-code">            plugin:<strong class="bold">1.6.10</strong>"</p>
			<p class="source-code">      […]</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Alternatively, if you're using a newer version of Android Studio, you might find the Kotlin version used in this project inside the <strong class="source-inline">plugins</strong> block, like so:</p>
			<p class="source-code">plugins {</p>
			<p class="source-code">    […]</p>
			<p class="source-code">    id 'org.jetbrains.kotlin.android' version <strong class="bold">'1.6.10'</strong> </p>
			<p class="source-code">        apply false</p>
			<p class="source-code">}</p>
			<p>If you <a id="_idIndexMarker068"/>haven't already, you might need to install the 1.6.10 plugin version of Kotlin in Android Studio. To do that, click on the <strong class="bold">Tools</strong> option of Android Studio on the <strong class="bold">Kotlin</strong> and on the <strong class="bold">Configure Kotlin Plugin Updates</strong> options. In the newly opened window, you can update your Kotlin version to <strong class="source-inline">1.6.10</strong>.</p>
			<p>Still in the project-level <strong class="source-inline">build.gradle</strong> file, because Compose is tied to the Kotlin version used in our project, make sure that the Compose version is set to <strong class="source-inline">1.1.1</strong> inside the <strong class="source-inline">ext { }</strong> block:</p>
			<p class="source-code">buildscript {</p>
			<p class="source-code">    ext {</p>
			<p class="source-code"><strong class="bold">        compose_version = '1.1.1'</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    repositories {…}</p>
			<p class="source-code">    dependencies {…}</p>
			<p class="source-code">}</p>
			<p>Then, move into the app-level <strong class="source-inline">build.gradle</strong> file. First check that the <strong class="source-inline">composeOptions { }</strong> block looks like this:</p>
			<p class="source-code">plugins { ... }</p>
			<p class="source-code">android {</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    buildFeatures { compose true }</p>
			<p class="source-code">    <strong class="bold">composeOptions {</strong></p>
			<p class="source-code"><strong class="bold">        kotlinCompilerExtensionVersion compose_version</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    packagingOptions { ... }</p>
			<p class="source-code">}</p>
			<p>In some versions of <a id="_idIndexMarker069"/>Android Studio, the <strong class="source-inline">composeOptions { }</strong> block would add an outdated <strong class="source-inline">kotlinCompilerVersion '1.x.xx'</strong> line that should be removed.</p>
			<p>Finally, make sure that the <strong class="source-inline">dependencies</strong> block of the app-level <strong class="source-inline">build.gradle</strong> file<a id="_idIndexMarker070"/> includes the following versions for its dependencies:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    implementation 'androidx.core:core-ktx:<strong class="bold">1.7.0</strong>'</p>
			<p class="source-code">    implementation 'androidx.appcompat:appcompat:<strong class="bold">1.4.1'</strong></p>
			<p class="source-code">    implementation 'com.google.android.material:</p>
			<p class="source-code">        material:<strong class="bold">1.5.0'</strong></p>
			<p class="source-code">    implementation "androidx.compose.ui:ui:</p>
			<p class="source-code">        $compose_version"</p>
			<p class="source-code">    implementation "androidx.compose.material:</p>
			<p class="source-code">        material:$compose_version"</p>
			<p class="source-code">    implementation "androidx.compose.ui:ui-tooling-</p>
			<p class="source-code">        preview:$compose_version"</p>
			<p class="source-code">    implementation 'androidx.lifecycle:lifecycle-</p>
			<p class="source-code">        runtime-ktx:<strong class="bold">2.4.1'</strong></p>
			<p class="source-code">    implementation 'androidx.activity:activity-</p>
			<p class="source-code">        compose:<strong class="bold">1.4.0'</strong></p>
			<p class="source-code">    testImplementation 'junit:junit:<strong class="bold">4.+</strong>'</p>
			<p class="source-code">    androidTestImplementation</p>
			<p class="source-code">        'androidx.test.ext:junit:<strong class="bold">1.1.3'</strong></p>
			<p class="source-code">    androidTestImplementation </p>
			<p class="source-code">        'androidx.test.espresso:espresso-core:<strong class="bold">3.4.0'</strong></p>
			<p class="source-code">    androidTestImplementation "androidx.compose.ui:ui-</p>
			<p class="source-code">        test-junit4:$compose_version"</p>
			<p class="source-code">    debugImplementation "androidx.compose.ui:ui-</p>
			<p class="source-code">        tooling:$compose_version"</p>
			<p class="source-code">}</p>
			<p>If you had to make any changes, synchronize your project with its Gradle files by clicking on the <strong class="bold">Sync your project with Gradle files</strong> button in Android Studio or by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<p>Now we're set. Let's return to the source code generated by Android Studio.</p>
			<p>And here we are – our first<a id="_idIndexMarker071"/> Compose project has been set up! Let's check out the source code by navigating to the <strong class="source-inline">MainActivity.kt</strong> file. We can conclude that it consists of three main parts:</p>
			<ul>
				<li>The <strong class="source-inline">MainActivity</strong> class</li>
				<li>The <strong class="source-inline">Greeting</strong> composable function</li>
				<li>The <strong class="source-inline">DefaultPreview</strong> composable function</li>
			</ul>
			<p>The <strong class="source-inline">MainActivity</strong> class is where content is passed to the <strong class="source-inline">setContent</strong> method in the <strong class="source-inline">onCreate</strong> callback. As we know by now, we need to call <strong class="source-inline">setContent</strong> to set up a Compose UI and pass composable functions as our UI:</p>
			<p class="source-code">setContent {</p>
			<p class="source-code">   RestaurantsAppTheme {</p>
			<p class="source-code">       Surface(color = MaterialTheme.colors.background) {</p>
			<p class="source-code">           Greeting("Android")</p>
			<p class="source-code">       }</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>The IDE template has already implemented a <strong class="source-inline">Greeting</strong> composable that is wrapped into a <strong class="source-inline">Surface</strong> that uses the theme's background color. But what is that <strong class="source-inline">RestaurantsAppTheme</strong> function that was passed as the parent composable to the <strong class="source-inline">setContent</strong> method?</p>
			<p>If you press <em class="italic">Ctrl</em> + <em class="italic">B</em> or <em class="italic">Command</em> + <em class="italic">B</em> on the function name, you will be taken to the <strong class="source-inline">Theme.kt</strong> file, which is where <a id="_idIndexMarker072"/>our theme is generated. <strong class="source-inline">RestaurantsAppTheme</strong> is a composable function that was auto-generated by the IDE as it holds the app's name:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsAppTheme(</p>
			<p class="source-code">   darkTheme: Boolean = isSystemInDarkTheme(),</p>
			<p class="source-code">   content: @Composable() -&gt; Unit</p>
			<p class="source-code">) {</p>
			<p class="source-code">   ...</p>
			<p class="source-code">   MaterialTheme(</p>
			<p class="source-code">       colors = colors,</p>
			<p class="source-code">       typography = Typography,</p>
			<p class="source-code">       shapes = Shapes,</p>
			<p class="source-code">       content = content)</p>
			<p class="source-code">}</p>
			<p>The app's theme is a wrapper over <strong class="source-inline">MaterialTheme</strong> and if we pass it to the <strong class="source-inline">setContent</strong> call, it allows us to reuse custom styles and color schemes defined within the app's theme. For it to take effect and reuse custom styles, we must pass our composables functions to the <strong class="source-inline">content</strong> parameter of our theme composable – in our case, in <strong class="source-inline">MainActivity</strong>, the <strong class="source-inline">Greeting</strong> composable wrapped in the <strong class="source-inline">Surface</strong> composable is passed to the <strong class="source-inline">RestaurantsAppTheme</strong> composable.</p>
			<p>Let's go back inside the <strong class="source-inline">MainActivity.kt</strong> file to have a look at the other parts generated by Android studio. We can see that the <strong class="source-inline">Greeting</strong> composable displays text through <strong class="source-inline">Text</strong>, similar to our composable functions from the previous examples.</p>
			<p>To preview the <strong class="source-inline">Greeting</strong> composable, the IDE also generated a preview composable for us called <strong class="source-inline">DefaultPreview</strong>, which allows us to preview the content that <strong class="source-inline">MainActivity</strong> displays; that is, <strong class="source-inline">Greeting</strong>. It also makes use of the theme composable to get the consistently themed UI.</p>
			<p>Now that we've achieved a<a id="_idIndexMarker073"/> big milestone in that we've created a Compose-based application, it's time to start working on our Restaurants App!</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor039"/>Building a restaurant element layout</h2>
			<p>It's time to get our hands dirty and<a id="_idIndexMarker074"/> start building the layout for a restaurant within the app:</p>
			<ol>
				<li value="1">Create a new file by left-clicking the application package and selecting <strong class="bold">New</strong> and then <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsScreen</strong> for the name and select the type as <strong class="bold">File</strong>. </li>
				<li>Inside this file, let's create a <strong class="source-inline">RestaurantsScreen</strong> composable function for our first Compose screen:<p class="source-code">@Com<a id="_idTextAnchor040"/>posable</p><p class="source-code">fun RestaurantsScreen() {</p><p class="source-code">   RestaurantItem()</p><p class="source-code">}</p></li>
				<li>Next, inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, let's define the <strong class="source-inline">RestaurantItem</strong> composable, which features a <strong class="source-inline">Card</strong> composable with elevation and padding:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantItem() {</p><p class="source-code">    Card(elevation = 4.dp,</p><p class="source-code">         modifier = Modifier.padding(8.dp)</p><p class="source-code">    ) {</p><p class="source-code">        Row(verticalAlignment =</p><p class="source-code">                Alignment.CenterVertically,</p><p class="source-code">            modifier = Modifier.padding(8.dp)) {</p><p class="source-code">            RestaurantIcon(</p><p class="source-code">                Icons.Filled.Place,</p><p class="source-code">                Modifier.weight(0.15f))</p><p class="source-code">            RestaurantDetails(Modifier.weight(0.85f))</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Make sure that every import you include is part of the <strong class="source-inline">androidx.compose.*</strong> package. If you're unsure what imports to include, check out the source code for the <strong class="source-inline">RestaurantsScreen.kt</strong> file at the following URL:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/RestaurantsScreen.kt</a></p>
			<p>Getting back to the <a id="_idIndexMarker075"/>previous code snippet, we could say that the <strong class="source-inline">Card</strong> composable is similar to <strong class="source-inline">Cardview</strong> from the old View System as it allows us to beautify the UI piece that represents a restaurant with border or elevation.</p>
			<p>In our case, <strong class="source-inline">Card</strong> contains a <strong class="source-inline">Row</strong> composable whose children composables are centered vertically and are surrounded by some padding. We used <strong class="source-inline">Row</strong> since we will show some details about the restaurant in a horizontal fashion: an icon and some text details.</p>
			<p>We passed the <strong class="source-inline">RestaurantIcon</strong> and <strong class="source-inline">RestaurantDetails</strong> composables as children of the <strong class="source-inline">Row</strong> composable but these functions are not defined so we have compilation errors. For now, don't worry about the weight modifiers. Let's define the <strong class="source-inline">RestaurantIcon</strong> composable first!</p>
			<ol>
				<li value="4">Still inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, create another composable function entitled <strong class="source-inline">RestaurantIcon</strong> with the following code:<p class="source-code">@Composable</p><p class="source-code">private fun RestaurantIcon(icon: ImageVector, modifier: Modifier) {</p><p class="source-code">   Image(imageVector = icon,</p><p class="source-code">         contentDescription = "Restaur<a id="_idTextAnchor041"/>ant icon",</p><p class="source-code">         modifier = modifier.padding(8.dp))</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">RestaurantIcon</strong> composable sets an <strong class="source-inline">ImageVector</strong> icon to an <strong class="source-inline">Image</strong> composable – in our case, a predefined Material Theme icon called <strong class="source-inline">Icons.Filled.Place</strong>. It also sets a <strong class="source-inline">contentDescription</strong> value and adds padding on top of the modifier it receives.</p>
			<p>However, the<a id="_idIndexMarker076"/> most interesting part is the fact that <strong class="source-inline">RestaurantIcon</strong> receives a <strong class="source-inline">Modifier</strong> as an argument from its parent <strong class="source-inline">Row</strong>. The argument it receives is <strong class="source-inline">Modifier.weight(0.15f)</strong>, which means that our <strong class="source-inline">Row</strong> assigns weights to each of its horizontally positioned children. The value – in this case, <strong class="source-inline">0.15f</strong> – means that this child <strong class="source-inline">RestaurantIcon</strong> will take 15% of the horizontal space from its parent <strong class="source-inline">Row</strong>.</p>
			<ol>
				<li value="5">Now, still inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, create a <strong class="source-inline">RestaurantDetails</strong> function that displays the restaurant's details:<p class="source-code">@Composable</p><p class="source-code">private fun RestaurantDetails(modifier: Modifier) {</p><p class="source-code">   Column(modifier = modifier) {</p><p class="source-code">       Text(text = "Alfredo's dishes",</p><p class="source-code">            style = MaterialTheme.typography.h6)</p><p class="source-code">       CompositionLocalProvider(</p><p class="source-code">           LocalContentAlpha provides </p><p class="source-code">               ContentAlpha.medium) {</p><p class="source-code">           Text(text = "At Alfredo's … seafood dishes.",</p><p class="source-code">                style = MaterialThe<a id="_idTextAnchor042"/>me.typography.body2)</p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>Similarly, <strong class="source-inline">RestaurantDetails</strong> receives a <strong class="source-inline">Modifier.weight(0.85f)</strong> modifier as an <a id="_idIndexMarker077"/>argument from <strong class="source-inline">Row</strong>, which will make it occupy the remaining 85% of the horizontal space.</p>
			<p>The <strong class="source-inline">RestaurantDetails</strong> composable is a simple <strong class="source-inline">Column</strong> that arranges two <strong class="source-inline">Text</strong> composables vertically, with one being the title of the restaurant, and the other being its description. </p>
			<p>But what's up with <strong class="source-inline">CompositionLocalProvider</strong>? To display the description that's faded out in contrast to the title, we applied a <strong class="source-inline">LocalContentAlpha</strong> of <strong class="source-inline">ContentAlpha.medium</strong>. This way, the child <strong class="source-inline">Text</strong> with the restaurant description will be faded or grayed out.</p>
			<p><strong class="source-inline">CompositionLocalProvider</strong> allows us to pass data down to the composable hierarchy. In this case, we want the child <strong class="source-inline">Text</strong> to be grayed out, so we passed a <strong class="source-inline">LocalContentAlpha</strong> object with a <strong class="source-inline">ContentAlpha.medium</strong> value using the infix <strong class="source-inline">provides</strong> method.</p>
			<ol>
				<li value="6">For a moment, go to <strong class="source-inline">MainActivity.kt</strong> and remove the <strong class="source-inline">DefaultPreview</strong> composable function as we will define our own a <strong class="source-inline">@Preview</strong> composable up next.</li>
				<li>Go back<a id="_idIndexMarker078"/> inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file, define a <strong class="source-inline">@Preview</strong> composable:<p class="source-code">@Preview(showBackground = true)</p><p class="source-code">@Composable</p><p class="source-code">fun DefaultPreview() {<a id="_idTextAnchor043"/></p><p class="source-code">   RestaurantsAppTheme {</p><p class="source-code">       RestaurantsScreen()</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>If you have chosen a different name for your app, you might need to update the previous snippet with the theme composable defined in the <strong class="source-inline">Theme.kt</strong> file.</p>
			<ol>
				<li value="8">Rebuild the project and let's inspect the <strong class="source-inline">RestaurantsScreen()</strong> composable by previewing the <a id="_idIndexMarker079"/>newly created <strong class="source-inline">DefaultPreview</strong> composable, which should display a restaurant item:</li>
			</ol>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B17788_01_22.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.22 – Previewing a restaurant item </p>
			<ol>
				<li value="9">Finally, go back to <strong class="source-inline">MainActivity.kt</strong> and remove the <strong class="source-inline">Greeting</strong> composable. Also, remove the <strong class="source-inline">Surface</strong> and <strong class="source-inline">Greeting</strong> function calls in the <strong class="source-inline">setContent</strong> method and replace them with <strong class="source-inline">RestaurantScreen</strong>:<p class="source-code">setContent {<a id="_idTextAnchor044"/><a id="_idTextAnchor045"/></p><p class="source-code">   RestaurantsAppTheme {</p><p class="source-code">       <strong class="bold">RestaurantsScreen()</strong></p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>By passing <strong class="source-inline">RestaurantScreen</strong> to our <strong class="source-inline">MainActivity</strong>'s <strong class="source-inline">setContent</strong> method, we ensure that the application will render the desired UI when built and run.</p>
			<ol>
				<li value="10">Optionally, you<a id="_idIndexMarker080"/> can now <strong class="bold">Run</strong> the app to see the restaurant directly on your device or emulator.</li>
			</ol>
			<p>Now that we have built a layout for a restaurant, it's time to learn how to display more of them! </p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor046"/>Displaying a list of restaurants with Compose</h2>
			<p>So far, we've displayed <a id="_idIndexMarker081"/>a restaurant item, so it's time to display an entire list of them:</p>
			<ol>
				<li value="1">First, create a new class in the root package, next to <strong class="source-inline">MainActivity.kt</strong>, called <strong class="source-inline">Restaurant.kt</strong>. Here, we will add a <strong class="source-inline">data class</strong> called <strong class="source-inline">Restaur<a id="_idTextAnchor047"/><a id="_idTextAnchor048"/>ant</strong> and add the fields that we expect a restaurant to have:<p class="source-code">data class Restaurant(val id: Int,</p><p class="source-code">                      val title: String,</p><p class="source-code">                      val description: String)</p></li>
				<li>In the same <strong class="source-inline">Restaurant.kt</strong> file, create a dummy list of <strong class="source-inline">Restaurant</strong> <a id="_idTextAnchor049"/>items, preferably at least 10 to fill up the entire screen:<p class="source-code">data class Restaurant(val id: Int,</p><p class="source-code">                      val title: String,</p><p class="source-code">                      val description: String)</p><p class="source-code">val dummyRestaurants = listOf(</p><p class="source-code">    Restaurant(0, "Alfredo foods", "At Alfredo's …"),</p><p class="source-code">    [...],</p><p class="source-code">    Restaurant(13, "Mike and Ben's food pub", "")</p><p class="source-code">)</p></li>
			</ol>
			<p>You can find the pre-populated<a id="_idIndexMarker082"/> list in this book's GitHub repository, inside the <strong class="source-inline">Restaurant.kt</strong> file:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/blob/main/Chapter_01/chapter_1_restaurants_app/app/src/main/java/com/codingtroops/restaurantsapp/Restaurant.kt</a>.</p>
			<ol>
				<li value="3">Go back inside the <strong class="source-inline">RestaurantsScreen.kt</strong> file and update your <strong class="source-inline">RestaurantItem</strong> so that it receives a <strong class="source-inline">Restaurant</strong> object as an argument, while also passing the restaurant's <strong class="source-inline">title</strong> and <strong class="source-inline">description</strong> to<a id="_idTextAnchor050"/> the <strong class="source-inline">RestaurantDetails</strong> composable as parameters:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantItem(<strong class="bold">item: Restaurant</strong>) {</p><p class="source-code">    Card(...) {</p><p class="source-code">        Row(...) {</p><p class="source-code">            RestaurantIcon(...)</p><p class="source-code">            RestaurantDetails(</p><p class="source-code">              <strong class="bold">  item.title,</strong></p><p class="source-code"><strong class="bold">                item.description,</strong></p><p class="source-code">                Modifier.weight(0.85f)</p><p class="source-code">            )</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We have passed the restaurant's <strong class="source-inline">title</strong> and <strong class="source-inline">description</strong> to the <strong class="source-inline">RestaurantDetails</strong> composable as parameters. Propagate these changes in the <strong class="source-inline">RestaurantDetails</strong> composable and pass the <strong class="source-inline">title</strong> into the first <strong class="source-inline">Text</strong> composable and <a id="_idTextAnchor051"/>the <strong class="source-inline">description</strong> into the second <strong class="source-inline">Text</strong> <a id="_idTextAnchor052"/>composable:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantDetails(<strong class="bold">title: String</strong>, <strong class="bold">description: String,</strong> modifier: Modifier){</p><p class="source-code">   Column(modifier = modifier) {</p><p class="source-code">       Text(text = <strong class="bold">title</strong>, ...)</p><p class="source-code">       CompositionLocalProvider( … ) {</p><p class="source-code">           Text(text = <strong class="bold">description</strong>, ...)</p><p class="source-code">       }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
				<li>Go back to the <strong class="source-inline">RestaurantsScreen</strong> composable and update it to display a vertical list of <strong class="source-inline">Restaurant</strong> objects. We <a id="_idIndexMarker083"/>already know that we can use a <strong class="source-inline">Column</strong> to achieve this. Then, iterate over each restaurant in <strong class="source-inline">dummyRestaurants</strong> and bind <a id="_idTextAnchor053"/>it to a <strong class="source-inline">RestaurantItem</strong>:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen() {</p><p class="source-code"><strong class="bold">   Column {</strong></p><p class="source-code"><strong class="bold">       dummyRestaurants.forEach { rest<a id="_idTextAnchor054"/>aurant -&gt;</strong></p><p class="source-code"><strong class="bold">           RestaurantItem(restaurant)</strong></p><p class="source-code"><strong class="bold">       }</strong></p><p class="source-code"><strong class="bold">   }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>This will create a beautiful vertical list that we can preview through our <strong class="source-inline">DefaultPreview</strong> composable.</p>
			<ol>
				<li value="6">Rebuild the project to<a id="_idIndexMarker084"/> see the updated preview generated by the <strong class="source-inline">DefaultPreview</strong> composable:</li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B17788_01_23.jpg" alt="Figure 1.23 – Previewing RestaurantsScreen with the Column composable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.23 – Previewing RestaurantsScreen with the Column composable</p>
			<p>Alternatively, you can <strong class="bold">Run</strong> the app to see the restaurants directly on your device or emulator.</p>
			<p>We've finally created our first list with Compose! It looks very nice and beautiful, yet it has one huge issue – it doesn't scroll! We'll address this together in the next section.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor055"/>Exploring lists with Compose</h1>
			<p>In the previous section, we <a id="_idIndexMarker085"/>built a Compose-based screen that features a list of restaurants. However, if you run the application or preview the screen in interactive mode, you will notice that the list doesn't scroll. This is a huge inconvenience that we will address in this section by adding scroll capabilities to our <strong class="source-inline">Column</strong> composable.</p>
			<p>Next, we will specify why <strong class="source-inline">Column</strong> is suited for static content, whereas if the list is large and its size is dynamic or dictated by the server's response, we should use <em class="italic">lazy composables</em>. We will explore a variety of lazy composables and understand why they are better suited for large lists.</p>
			<p>To summarize, this section will cover the following topics:</p>
			<ul>
				<li>Adding scrolling to the <strong class="source-inline">Column</strong> composable</li>
				<li>Introducing lazy composables</li>
				<li>Using <strong class="source-inline">LazyColumn</strong> to display restaurants</li>
			</ul>
			<p>Let's start by adding scrolling capabilities to our <strong class="source-inline">RestaurantsScreen</strong> composable.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor056"/>Adding scrolling to the Column composable</h2>
			<p>Our list of restaurants<a id="_idIndexMarker086"/> is long, and it can't scroll. This is a bad user experience,<a id="_idTextAnchor057"/> so let's fix it.</p>
			<p>Let's make the <strong class="source-inline">Column</strong> scrollable by passing a <strong class="source-inline">Modifier.verticalScroll</strong> modifier that <a id="_idTextAnchor058"/>receives a <strong class="source-inline">ScrollState</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen() {</p>
			<p class="source-code">   Column<strong class="bold">(Modifier.verticalScroll(rememberScrollState()))</strong> {</p>
			<p class="source-code">       ...</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>We want the scrolling position to be retained across recompositions. That's why, by passing <strong class="source-inline">rememberScrollState</strong> to the <strong class="source-inline">verticalScroll</strong> modifier, we ensure that every time the UI recomposes, the scroll state is remembered and retained. The <strong class="source-inline">rememberScrollState</strong> persistence mechanism is similar to the <strong class="source-inline">remember { }</strong> block, which we used previously to retain the <strong class="source-inline">TextField</strong>'s state across recompositions.</p>
			<p>Now, you can <strong class="bold">Run</strong> the app or<a id="_idIndexMarker087"/> preview it in <strong class="bold">Interactive mode</strong> and check out the scrolling effect.</p>
			<p>However, we have one final issue with our <strong class="source-inline">Column</strong> that is related to how <strong class="source-inline">Column</strong> lays and composes its elements. Let's dive into that now and try to find a better alternative.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor059"/>Introducing lazy composables</h2>
			<p>Let's take a short <a id="_idIndexMarker088"/>break from our restaurant app and try to think of a better way of handling large lists. Using <strong class="source-inline">Row</strong> or <strong class="source-inline">Column</strong> for displaying long lists of items, or maybe a list of unknown size, can prove detrimental to your UI and impact your app's performance. This happens because <strong class="source-inline">Row</strong> and <strong class="source-inline">Column</strong> render or lay all their children out, whether they are visible or not. They are good for displaying static content, yet passing a large list can cause <a id="_idTextAnchor060"/>your UI to become laggy or even unusable.</p>
			<p>Two lazy composables called <strong class="source-inline">LazyColumn</strong> and <strong class="source-inline">LazyRow</strong> come to your rescue since they only compose or output those items that are currently visible on the screen, hence the term <em class="italic">lazy</em>. So, as you can see, they are somehow similar to the old <strong class="source-inline">RecyclerView</strong>. </p>
			<p>As the only difference between <strong class="source-inline">Row</strong> and <strong class="source-inline">Column</strong> was the way children were laid out on the screen – horizontally or vertically – the same thing applies with <strong class="source-inline">LazyRow</strong> and <strong class="source-inline">LazyColumn</strong>. These lazy composables lay their children out horizontally or vertically and provide scrolling capabilities out of the box. As they only render the visible items, lazy composables are a much better fit for large lists.</p>
			<p>Yet, lazy composables are different than the regular composables that we've used so far. That's mainly <a id="_idIndexMarker089"/>because instead of accepting <strong class="source-inline">@Composable</strong> content, they expose a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) defi<a id="_idTextAnchor061"/>ned by a <strong class="source-inline">LazyListScope</strong> block:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun LazyColumn(</p>
			<p class="source-code">   ...</p>
			<p class="source-code">   content: LazyListScope.() -&gt; Unit</p>
			<p class="source-code">) { … }</p>
			<p>The <strong class="source-inline">LazyListScope</strong> DSL allows us to describe the <em class="italic">item</em> contents that we want to be displayed as part of the list. The most <a id="_idIndexMarker090"/>commonly used ones are <strong class="source-inline">item()</strong> and <strong class="source-inline">items()</strong>. Such example usage of <strong class="source-inline">LazyColumn</strong> that makes use of DSL is as follows:</p>
			<p class="source-code">LazyColumn {</p>
			<p class="source-code">   <strong class="bold">item()</strong> {</p>
			<p class="source-code">       Text(text = "Custom header item")</p>
			<p class="source-code">   }</p>
			<p class="source-code">   <strong class="bold">items(myLongList)</strong> { myItem -&gt;</p>
			<p class="source-code">       MyComposable(myIt<a id="_idTextAnchor062"/>em)</p>
			<p class="source-code">   }</p>
			<p class="source-code">   <strong class="bold">item(2)</strong> {</p>
			<p class="source-code">       Text(text = "Custom footer item")</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">item()</strong> adds a single composable element to the list, while <strong class="source-inline">items()</strong> can receive not only a standalone list of content such as <strong class="source-inline">myLongList</strong> but also an <strong class="source-inline">Int</strong>, which will add the same item multiple times.</p>
			<p>The code that we featured previously should render a vertical list that contains the following:</p>
			<ul>
				<li>A header <strong class="source-inline">Text</strong> composable</li>
				<li>A list of <strong class="source-inline">MyComposable</strong> composables that are the same size as <strong class="source-inline">myLongList</strong></li>
				<li>Two <strong class="source-inline">Text</strong> footer composables</li>
			</ul>
			<p>Returning from the DSL world, a noteworthy argument for the lazy composables is <strong class="source-inline">contentPadding</strong>, which allows you to define horizontal/vertical padding surrounding your list. This argument expects a <strong class="source-inline">PaddingValues</strong> object – we will use it soon; don't worry!</p>
			<p>Now, we will soon<a id="_idIndexMarker091"/> receive the restaurants from a remote server, which means we don't know the size of the list, so it's time to implement such a lazy composable in our Restaurants application as well.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor063"/>Using LazyColumn to display restaurants</h2>
			<p>We are currently using <strong class="source-inline">Column</strong> to<a id="_idIndexMarker092"/> display our <strong class="source-inline">dummyRestaurants</strong> list. We know why that's not the best practice, so to optimize our UI for dynamic content, we will replace it with <strong class="source-inline">LazyColumn</strong> so that we can continue displaying the restaurants vertically.</p>
			<p>Go back to the <strong class="source-inline">RestaurantsScreen.kt</strong> file and, inside of the <strong class="source-inline">RestaurantScreen</strong> composable, replace the <strong class="source-inline">Column</strong> composable with <strong class="source-inline">LazyColumn</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen() {</p>
			<p class="source-code"><strong class="bold">   LazyColumn(</strong></p>
			<p class="source-code"><strong class="bold">       contentPadding = PaddingValues(</strong></p>
			<p class="source-code"><strong class="bold">           vertical = 8.dp,</strong></p>
			<p class="source-code"><strong class="bold">           horizontal = 8.dp)) {</strong></p>
			<p class="source-code"><strong class="bold">       items(dummyRestaurants<a id="_idTextAnchor064"/><a id="_idTextAnchor065"/><a id="_idTextAnchor066"/>) { restaurant -&gt;</strong></p>
			<p class="source-code"><strong class="bold">           RestaurantItem(restaurant)</strong></p>
			<p class="source-code"><strong class="bold">       }</strong></p>
			<p class="source-code"><strong class="bold">   }</strong></p>
			<p class="source-code">}</p>
			<p>We've used its DSL and specified the <strong class="source-inline">items</strong> properties that should populate our <strong class="source-inline">LazyColumn</strong> by passing the <strong class="source-inline">dummyRestaurants</strong> list. We obtained access to each item as a restaurant of type <strong class="source-inline">Restaurant</strong> and rendered it through a <strong class="source-inline">RestaurantItem</strong> composable.</p>
			<p>We also added additional padding through the <strong class="source-inline">contentPadding</strong> argument to our <strong class="source-inline">LazyColumn</strong> by passing a <strong class="source-inline">PaddingValues</strong> object where we configured the vertical and horizontal padding.</p>
			<p>You can now <strong class="bold">Run</strong> the app and<a id="_idIndexMarker093"/> check out the scrolling effect. In our case, the output is the same, yet if we were to test the app with a very long list of restaurants, we would have a much smoother scroll effect and a better UI experience with <strong class="source-inline">LazyColumn</strong> than with <strong class="source-inline">Column</strong>.</p>
			<p>We've done it! We've built our first Compose-based app from scratch while exploring tons of composable functions. We've added a list that scrolls beautifully, and we can now be proud of the result!</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor067"/>Summary</h1>
			<p>In this chapter, we learned how to build modern UIs on Android directly in Kotlin by using the Jetpack Compose toolkit. You learned how, in Compose, everything is a composable function and how this new declarative way of defining UIs improves and makes the way we build UIs much easier and less prone to bugs. </p>
			<p>We learned that Compose accelerates and greatly simplifies UI development with the help of concise Kotlin APIs and without the need for XML or other additional languages. We then covered the basic concepts behind Compose and the core components that allow you to build UIs.</p>
			<p>Finally, we saw how easy it is to build UI with Compose by creating a Compose-based screen that displays a list of restaurants. </p>
			<p>In <a href="B17788_02_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 2</em></a>, <em class="italic">Handling UI State with Jetpack ViewModel</em>, we will use the fundamentals we've learned in this chapter to revisit the concept of state in Compose and learn how it is represented, as well as how we can correctly manage it with the help of another Jetpack component: <strong class="source-inline">ViewModel</strong>.</p>
			<p>First, we will understand what <strong class="source-inline">ViewModel</strong> is and why such a component is needed. Then, by continuing working on the Restaurants application that we started in this chapter, we will learn how to define and lift the UI's state in our own <strong class="source-inline">ViewModel</strong> class.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor068"/>Further reading</h1>
			<p>Exploring a library with the magnitude of Compose is nearly impossible in a single chapter. That's why you should also explore other topics that are of great importance when building your UI with Compose:</p>
			<ul>
				<li>We've briefly mentioned how Compose works with the help of a Kotlin compiler plugin. To better how this compiler plugin helps us define composable functions, check out this great article written by the official Android developer team: <a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd">https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd</a>.</li>
			</ul>
			<p>This article also covers the internals of Compose, so if you are curious about the execution model of Compose or what the compiler plugin does behind the scenes, make sure to check it out.</p>
			<ul>
				<li>Building UIs with Compose is simple, yet Compose is a very powerful framework that enables you to write highly reusable UIs. To take advantage of that, every Composable should receive a <strong class="source-inline">Modifier</strong> object that defines how it is arranged inside its caller parent. See what this means by checking out this great article, and then try to practice a bit: <a href="https://chris.banes.dev/always-provide-a-modifier/">https://chris.banes.dev/always-provide-a-modifier/</a>.</li>
				<li>Your layout should be adaptive and flexible for devices with different screen sizes or forms. You can learn more about this and try experimenting a bit by looking at the official documentation: <a href="https://developer.android.com/jetpack/compose/layouts/adaptive">https://developer.android.com/jetpack/compose/layouts/adaptive</a>.</li>
			</ul>
		</div>
	</body></html>