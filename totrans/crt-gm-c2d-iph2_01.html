<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Thanks for the Memory Game</h1></div></div></div><p>As children, we learn many useful skills by playing games. We learn coordination, strategy, and memory skills. These are all skills we take with us throughout our lives. The perfect place to start is a traditional childhood game.</p><p>In this chapter, we cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scenes versus layers</li><li class="listitem" style="list-style-type: disc">Sprites and sprite sheets</li><li class="listitem" style="list-style-type: disc">Loading sequential files</li><li class="listitem" style="list-style-type: disc">Random playfield generation</li><li class="listitem" style="list-style-type: disc">Touch handlers</li><li class="listitem" style="list-style-type: disc">Using actions</li><li class="listitem" style="list-style-type: disc">Basic matching strategies</li><li class="listitem" style="list-style-type: disc">Scoring</li><li class="listitem" style="list-style-type: disc">Tracking lives</li><li class="listitem" style="list-style-type: disc">Game over conditions</li><li class="listitem" style="list-style-type: disc">SimpleSoundEngine</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The project is...</h1></div></div></div><p>We will begin with classic <a id="id0" class="indexterm"/>
<a id="id1" class="indexterm"/>
<strong>memory game</strong>. Not just any memory game – <em>the</em> memory game that is the source of joy and frustration of children everywhere. In case you've never been exposed to this game (really?), the gameplay is simple. The playing field is a set of tiles with pretty pictures on the front, and a generic back image. You turn over two tiles to see if you made a match. If not, you turn them back over. Pick another pair of tiles and see if they match. Repeat this till all the tiles are matched. Let's take a look at the finished game:</p><div><img src="img/9007_01_01.jpg" alt="The project is..."/></div><p>Our memory game needs to be flexible enough to allow different skill levels in the game. We will create different skill levels by varying the number of memory tiles on the board. If there are four tiles (two each of two designs), that's pretty easy. Creating a 4 x 5 grid of tiles is a lot more challenging (20 tiles, 10 designs). <a id="id2" class="indexterm"/>We will build a single project that will handle these variations dynamically.</p><p>Our game will be a little different from the traditional version in two ways: it is single player only, and we will add a way to lose the game, to make it more exciting. We'll go into detail on that aspect later.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>We will detail several foundational design approaches in this chapter that will be used throughout the book. To avoid repetitive code, later chapters will omit some of the boilerplate detail that we cover here.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Let's build a menu</h1></div></div></div><p>We'll start building the project from the default cocos2d v2.x - cocos2d iOS template. Once the project is created, we first remove the <code class="literal">HelloWorldLayer.h/.m</code> files. <code class="literal">HelloWorld</code> is a good starting point for learning the code structure, but we don't really want (or need) this boilerplate class for anything <a id="id3" class="indexterm"/>
<a id="id4" class="indexterm"/>(don't forget to remove the <code class="literal">#import "HelloWorldLayer.h"</code> at the top of the <a id="id5" class="indexterm"/>
<code class="literal">IntroLayer.m</code> class<a id="id6" class="indexterm"/>). For now we'll leave the reference in the bottom of the <code class="literal">IntroLayer.m</code>'s <code class="literal">makeTransition</code> class.</p><p>One of the most commonly used classes in the cocos2d framework is probably the <code class="literal">CCLayer</code>. A <code class="literal">CCLayer</code> is the object that is (usually) represented on the screen, and acts as our "canvas" for our game. We use the <a id="id7" class="indexterm"/>
<a id="id8" class="indexterm"/>
<code class="literal">CCLayer</code> object as a basis, and then create subclasses of it to add our own game code.</p><p>There is another often-used class, the <code class="literal">CCScene</code> class. A <a id="id9" class="indexterm"/>
<a id="id10" class="indexterm"/>
<code class="literal">CCScene</code> class can be thought of as a "container" for <code class="literal">CCLayer</code> objects. A <a id="id11" class="indexterm"/>
<a id="id12" class="indexterm"/>
<code class="literal">CCScene</code> object is rarely used for much more than adding <code class="literal">CCLayer</code>s as children. A good comparison is like the creation of cartoons before the age of computers. Each scene was assembled from a stack of transparent plastic sheets, each with a different part of the scene on it: each main character would have their own layer, another for the background, another for each different element of the scene. Those plastic sheets are the equivalent of <a id="id13" class="indexterm"/>
<a id="id14" class="indexterm"/>a <code class="literal">CCLayer</code> objects, and the <code class="literal">CCScene</code> class is where these are stacked up to display on screen.</p><p>We will start with a basic <a id="id15" class="indexterm"/>
<a id="id16" class="indexterm"/>
<code class="literal">CCLayer</code> subclass, <code class="literal">MTMenuLayer</code>. <a id="id17" class="indexterm"/>We create a title, and a basic menu. We need to pay attention to how we call the <code class="literal">MTPlayfieldScene</code> <a id="id18" class="indexterm"/>
<a id="id19" class="indexterm"/>class (our main game screen) from the menu.</p><p>
<strong>Filename:</strong> <code class="literal">MTMenuLayer.m</code>
</p><div><pre class="programlisting">-(void) startGameEasy {
    [[CCDirector sharedDirector] replaceScene:
     [MTPlayfieldScene sceneWithRows:2 andColumns:2]];
}

-(void) startGameMedium {
    [[CCDirector sharedDirector] replaceScene:
     [MTPlayfieldScene sceneWithRows:3 andColumns:4]];
}

-(void) startGameHard {
    [[CCDirector sharedDirector] replaceScene:
     [MTPlayfieldScene sceneWithRows:4 andColumns:5]];
}</pre></div><p>You will notice that the <a id="id20" class="indexterm"/>
<a id="id21" class="indexterm"/>
<code class="literal">startGameXXX</code> methods are calling a custom constructor for the scene, rather than the normal <code class="literal">[MyLayer scene]</code> that is commonly used. We will explain the <a id="id22" class="indexterm"/>
<a id="id23" class="indexterm"/>
<code class="literal">sceneWithRows:andColumns:</code> method shortly.</p><p>This book will not include the complete code within the text. Portions that aren't interesting for the discussion will be omitted.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files </p><p>e-mailed directly to you.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Where is the scene?</h2></div></div></div><p>Oh, you noticed? The boilerplate cocos2d template includes a class method <code class="literal">+(id)</code> scene inside the layer (in <code class="literal">HelloWorldLayer</code>). While this approach works, it can lead to confusion as we build more complex scenes with multiple layers. Using the template-based approach may seem odd when you call a method that <a id="id24" class="indexterm"/>
<a id="id25" class="indexterm"/>takes a <code class="literal">CCScene</code> object as a parameter, yet you pass it a value like <code class="literal">[MySpecialLayer scene]</code>. So are you referencing a <code class="literal">CCScene</code> or  <code class="literal">CCLayer</code> object? It makes a lot more logical sense to us that you would, in this example, pass a value like <code class="literal">[MySpecialScene scene]</code>. It is less confusing to pass a scene object when a <code class="literal">CCScene</code> is requested. A <code class="literal">CCScene</code> object is a higher-level container that was designed to contain <code class="literal">CCLayer</code> objects, so why not keep it as its own class? Let's go ahead and examine our approach:</p><p>
<strong>Filename:</strong> <code class="literal">MTMenuScene.h</code>
</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "cocos2d.h"
#import "MTMenuLayer.h"

@interface MTMenuScene : CCScene {
}

+(id)scene;

@end</pre></div><p>
<strong>Filename:</strong> <code class="literal">MTMenuScene.m</code>
</p><div><pre class="programlisting">#import "MTMenuScene.h"

@implementation MTMenuScene

+(id)scene {
    return( [ [ [ self alloc ] init ] autorelease ] );
}

-(id) init
{
  if( (self=[super init])) {
        MTMenuLayer *layer = [MTMenuLayer node];
        [self addChild: layer];
  }
  return self;
}

@end</pre></div><p>Here we have followed the convention that the scene method returns an <a id="id26" class="indexterm"/>
<a id="id27" class="indexterm"/>
<code class="literal">autoreleased</code> object. We do not explicitly call <code class="literal">alloc</code> on it (when we instantiate the class), so we don't "own" the object.</p><p>Now we can go back to the <code class="literal">IntroLayer.m</code> file, and change the <a id="id28" class="indexterm"/>
<a id="id29" class="indexterm"/>
<code class="literal">makeTransition</code> method to point to our new menu scene:</p><div><pre class="programlisting">-(void) makeTransition:(ccTime)dt
{
  [[CCDirector sharedDirector] replaceScene:
     [CCTransitionFade transitionWithDuration:1.0
        scene:[MTMenuScene scene] withColor:ccWHITE]];
} </pre></div><p>We also need to make sure we are importing the <a id="id30" class="indexterm"/>
<a id="id31" class="indexterm"/>
<code class="literal">MTMenuScene.h</code> file in the <code class="literal">AppDelegate.m</code> file. Now that our menu is complete, <a id="id32" class="indexterm"/>we can concentrate on the game itself.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>It is important to note that this design of using <code class="literal">CCScene</code> as a separate class in the structure is not universally adopted. Many people choose to follow the same approach as the templates. Both ways will work, but we are of the "camp" that strongly believes these should kept separate, as we have done here. Both ways are perfectly valid coding practice, and you are free to structure your code in other way.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Building the playfield</h2></div></div></div><p>Next, we will add a <code class="literal">CCScene</code> class to drive our main <a id="id33" class="indexterm"/>game screen, here named <code class="literal">MTPlayfieldScene</code>. Much of this looks the same as the <a id="id34" class="indexterm"/>
<a id="id35" class="indexterm"/>
<code class="literal">MTMenuScene</code> class we defined earlier, except here we define a method <a id="id36" class="indexterm"/>
<a id="id37" class="indexterm"/>
<code class="literal">sceneWithRows:andColumns:</code> instead of the simpler scene method we <a id="id38" class="indexterm"/>used in the previous code.</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldScene.m</code>
</p><div><pre class="programlisting">+(id) sceneWithRows:(NSInteger)numRows
         andColumns:(NSInteger)numCols {
  return [[[self alloc] sceneWithRows:numRows
                             andColumns:numCols]
                                    autorelease];
}

-(id) sceneWithRows:(NSInteger)numRows
         andColumns:(NSInteger)numCols {
  
  if( (self=[super init])) {
        // Create an instance of the MTPlayfieldLayer
        MTPlayfieldLayer *layer = [MTPlayfieldLayer
                                   layerWithRows:numRows
                                   andColumns:numCols];
        [self addChild: layer];
  }
  return self;
} </pre></div><p>Here we have the custom <code class="literal">sceneWithRows:andColumns:</code> method we referenced in the <code class="literal">MTMenuLayer</code> earlier. The class method handles the <code class="literal">alloc</code> and <code class="literal">init</code> methods, and identifies it as an autoreleased object, so we don't have to worry about releasing it later. The <code class="literal">sceneWithRows:andColumns:</code> method passes the rows and columns variables directly to the <code class="literal">MTPlayfieldLayer</code> class' custom <code class="literal">init</code> method, <code class="literal">layerWithRows:andColumns:</code>. This lets us pass the <a id="id39" class="indexterm"/>requested values through the scene to the layer, where we can use the values later.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>We need sprites</h1></div></div></div><p>Before we proceed with building the playing field, we need some graphics to use in our game. Our design calls for square images for the tiles, and one image to use for the common back of the tiles. Because we want them to be able to scale to different sizes (for our different skill levels), we need images large enough to <a id="id40" class="indexterm"/>look good at the simplest skill level, which is a two by two grid. Unless your goal is the "chunky pixel" look, you never want to scale images up. Based on the screen size, we want our tiles to be 150 points wide and 150 points high. Since we want to use better graphics on iPhone (and iPod Touch) <a id="id41" class="indexterm"/>Retina Display devices, our -hd version of the graphics will need to be 300 pixels by 300 pixels.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Points are the easiest way to use cocos2d effectively. On an older iOS Device, one point equals one pixel on the screen. On Retina Display devices, one point equals <em>two</em> pixels, which occupy the same physical space on the screen as the one pixel on the non-Retina screens. From a practical perspective, this means that once you provide the -hd graphics, cocos2d will treat your Retina and non-Retina layouts identically, with no extra layout code. You <em>can</em> do things in pixels if you really want to, but we wouldn't recommend making a habit of it.</p></div></div><p>For this game, we will be using a variety of photos. There was some amount of manipulation needed to arrive at the proper aspect ratio and size. This is a great place to make use of Automator that is part of Mac OS X. There is an Automator script in the source code for this chapter inside a folder called <code class="literal">Helpers</code>. When you run it, it will prompt for a folder of images. Once selected, it will create a folder on your desktop called <code class="literal">ch1_tiles</code>, and it will contain sequentially numbered images (that is <code class="literal">tile1.png</code>, <code class="literal">tile2.png</code>, and so on), with each image being exactly 300 <a id="id42" class="indexterm"/>pixels by 300 pixels.</p><p>Two other images will be needed to build the game: <code class="literal">backButton.png</code> will be used for navigation and <code class="literal">tileback.png</code> will be used as the image for the back of the tiles when they are face down.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Building a sprite sheet</h2></div></div></div><p>
<strong>Sprite sheets</strong> are one of the foundations of any effective cocos2d game. Compiling all of your sprites into sprite sheets lets cocos2d load <a id="id43" class="indexterm"/>fewer files as well as giving you the ability to use a batch node. We won't delve into the "under the hood" details of the <a id="id44" class="indexterm"/>
<a id="id45" class="indexterm"/>
<code class="literal">CCSpriteBatchNode</code> class here except at a high level. <a id="id46" class="indexterm"/>When you load a sprite sheet into a batch node, it acts as a "parent" for all the sprites on it. When you use a batch node, the calls to draw the sprites on the screen are batched together, which gives a performance boost. This batch drawing allows the system to draw 100 sprites with about the same efficiency (and speed) as drawing one sprite. The bottom line is batch nodes allow you to draw a lot more on-screen without slowing your game down.</p><p>There are two files needed for a sprite sheet: the texture (image file) and the plist file. We don't even want to think about attempting to hand-build the sprite sheet. Fortunately, there are a number of very good tools that were built for this. The most established sprite sheet tools in the cocos2d community are <a id="id47" class="indexterm"/>
<a id="id48" class="indexterm"/>TexturePacker (<a class="ulink" href="http://www.texturepacker.com">http://www.texturepacker.com</a>) and Zwoptex <a id="id49" class="indexterm"/>
<a id="id50" class="indexterm"/>(<a class="ulink" href="http://zwopple.com/zwoptex">http://zwopple.com/zwoptex</a>), although there are a number of newer apps that are also available. Which tool you use is a matter of personal preference. Regardless of the tool, you will need to create both the standard and -hd versions of the images. (Most current tools have built-in options to aid in this process.)</p><p>No matter which tool is used, the desired result is four files: <code class="literal">memorysheet.png</code>, <code class="literal">memorysheet.plist</code>, <code class="literal">memorysheet-hd.png</code>, and <code class="literal">memorysheet-hd.plist</code>. The -hd files include the 300 x 300 images for the iPhone Retina Display, and the others include the 150 x 150 pixel images for non-Retina iPhone Displays. We also include the <code class="literal">backButton.png</code> and <code class="literal">tileback.png</code> files in appropriate sizing in <a id="id51" class="indexterm"/>both sprite sheets as well. Let's take a look at the final sprite sheet we will use for this game:</p><div><img src="img/9007_01_02.jpg" alt="Building a sprite sheet"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>On to the playfield</h1></div></div></div><p>Now we're ready to get to the playfield layer itself. We know we need to keep track of the size of the game screen, how big each tile should be, how big the game board should be, and how much spacing we need between the tiles when they are laid out in a grid.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Creating the playfield header</h2></div></div></div><p>In the header, we also <a id="id52" class="indexterm"/>have the <a id="id53" class="indexterm"/>declaration for the class method <code class="literal">initWithRows:andColumns:</code> <a id="id54" class="indexterm"/>
<a id="id55" class="indexterm"/>that we called in the <code class="literal">MTPlayfieldScene</code> class.</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.h</code>
</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "cocos2d.h"
#import "MTMemoryTile.h"
#import "SimpleAudioEngine.h"
#import "MTMenuScene.h"

@interface MTPlayfieldLayer : CCLayer {
    CGSize size; // The window size from CCDirector

    CCSpriteBatchNode *memorysheet;
    
    CGSize tileSize; // Size (in points) of the tiles
    
    NSMutableArray *tilesAvailable;
    NSMutableArray *tilesInPlay;
    NSMutableArray *tilesSelected; 

    CCSprite *backButton;
    
    NSInteger maxTiles;
    
    float boardWidth; // Max width of the game board
    float boardHeight; // Max height of the game board
    
    NSInteger boardRows; // Total rows in the grid
    NSInteger boardColumns; // Total columns in the grid

    NSInteger boardOffsetX; // Offset from the left
    NSInteger boardOffsetY; // Offset from the bottom
    NSInteger padWidth; // Space between tiles
    NSInteger padHeight; // Space between tiles
    
    NSInteger playerScore; // Current score value
    CCLabelTTF *playerScoreDisplay; // Score label

    NSInteger livesRemaining; // Lives value
    CCLabelTTF *livesRemainingDisplay; // Lives label
    BOOL isGameOver;
}

+(id) layerWithRows:(NSInteger)numRows
         andColumns:(NSInteger)numCols;

@end</pre></div><p>One item to point out in the header is the <a id="id56" class="indexterm"/>
<a id="id57" class="indexterm"/>
<code class="literal">CGSize size</code> variable. <a id="id58" class="indexterm"/>This is a convenience variable we use to avoid repetitive typing. The name <code class="literal">size</code> is an abbreviation for <code class="literal">winSize</code>, which is a value that the <code class="literal">CCDirector</code> class will provide for you that identifies the size of the screen, in points. You can read the value from the <code class="literal">CCDirector</code> every time you use it, but doing so will make your code lines a bit longer. Our approach will work fine, as long as we do not support both portrait and landscape modes in the same layer. If we do allow both orientations, then the value we have cached in the <code class="literal">size</code> variable <a id="id59" class="indexterm"/>will be incorrect. Since our app only allows <a id="id60" class="indexterm"/>
<a id="id61" class="indexterm"/>
<code class="literal">LandscapeLeft</code> and <a id="id62" class="indexterm"/>
<a id="id63" class="indexterm"/>
<code class="literal">LandscapeRight</code> orientations, the size is identical in both orientations, so the <code class="literal">size</code> will be stable for our game.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Creating the playfield layer</h2></div></div></div><p>In the <code class="literal">MTPlayfieldLayer.m</code> file, we <a id="id64" class="indexterm"/>
<a id="id65" class="indexterm"/>implement our custom <code class="literal">layerWithRows:andColumns:</code> and <code class="literal">initWithRows:andColumns:</code> methods as follows:</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">+(id) layerWithRows:(NSInteger)numRows
         andColumns:(NSInteger)numCols {
  return [[[self alloc] initWithRows:numRows
                    andColumns:numCols] autorelease];
}

-(id) initWithRows:(NSInteger)numRows
        andColumns:(NSInteger)numCols {
    if (self == [super init]) {
        
        self.isTouchEnabled = YES;
        
        // Get the window size from the CCDirector
        size = [[CCDirector sharedDirector] winSize];
        
        // Preload the sound effects
        [self preloadEffects];
        
        // make sure we've loaded the spritesheets
        [[CCSpriteFrameCache sharedSpriteFrameCache]
         addSpriteFramesWithFile:@"memorysheet.plist"];
        memorysheet = [CCSpriteBatchNode
                batchNodeWithFile:@"memorysheet.png"];
        
        // Add the batch node to the layer
        [self addChild:memorysheet];
        
        // Add the back Button to the bottom right corner
        backButton = [CCSprite spriteWithSpriteFrameName:
                      @"backbutton.png"];
        [backButton setAnchorPoint:ccp(1,0)];
        [backButton setPosition:ccp(size.width - 10, 10)];
        [memorysheet addChild:backButton];
        
        // Maximum size of the actual playing field
        boardWidth = 400;
        boardHeight = 320;
        
        // Set the board rows and columns
        boardRows = numRows;
        boardColumns = numCols;
        
        // If the total number of card positions is
        // not even, remove one row
        // This against an impossible board
        if ( (boardRows * boardColumns) % 2 ) {
            boardRows--;
        }
        
        // Set the number of images to choose from
        // We need 2 of each, so we halve the total tiles
        maxTiles = (boardRows * boardColumns) / 2;
        // Set up the padding between the tiles
        padWidth = 10;
        padHeight = 10;
        
        // We set the desired tile size
        float tileWidth = ((boardWidth -
                            (boardColumns * padWidth))
                           / boardColumns) - padWidth;
        float tileHeight = ((boardHeight -
                             (boardRows * padHeight))
                            / boardRows) - padHeight;

        // We force the tiles to be square
        if (tileWidth &gt; tileHeight) {
            tileWidth = tileHeight;
        } else {
            tileHeight = tileWidth;
        }
        
        // Store the tileSize so we can use it later
        tileSize = CGSizeMake(tileWidth, tileHeight);

        // Set the offset from the edge
        boardOffsetX = (boardWidth - ((tileSize.width +
                        padWidth) * boardColumns)) / 2;
        boardOffsetY = (boardHeight - ((tileSize.height+
                        padHeight) * boardRows)) / 2;
        
        // Set the score to zero
        playerScore = 0;
        
        // Initialize the arrays

        // Populate the tilesAvailable array
        [self acquireMemoryTiles];
        
        // Generate the actual playfield on-screen
        [self generateTileGrid];

        // Calculate the number of lives left
        [self calculateLivesRemaining];
        
        // We create the score and lives display here
        [self generateScoreAndLivesDisplay];
    }
  return self;
}</pre></div><p>The class method <a id="id66" class="indexterm"/>
<code class="literal">layerWithRows:andColumns:</code> is the method we saw in the <code class="literal">MTPlayfieldScene</code> class earlier. The class method calls the <code class="literal">alloc</code> and <a id="id67" class="indexterm"/>
<a id="id68" class="indexterm"/>
<code class="literal">initWithRows: andColumns:</code> methods, and then wraps it all in an <code class="literal">autorelease</code> call since it is a convenience method. The instance method <code class="literal">initWithRows:AndColumns:</code> (called by the class method) sets up a few of the variables we established in the header, including the assignment of our passed <a id="id69" class="indexterm"/>
<a id="id70" class="indexterm"/>
<code class="literal">numRows</code> and <a id="id71" class="indexterm"/>
<a id="id72" class="indexterm"/>
<code class="literal">numColumns</code> parameters into the instance variables <code class="literal">boardRows</code> and <code class="literal">boardColumns</code>.</p><p>Memory games are traditionally played with a square or rectangular layout. They also need an even number of tiles in the game, since there <a id="id73" class="indexterm"/>
<a id="id74" class="indexterm"/>will be two of each type of tile. Because we are allowing flexible parameters for the number of rows and the number of columns, there are certain combinations that will not work. Requesting five rows and five columns means we will have 25 tiles on the board, which is impossible to win. To protect our game from these invalid values, we multiply the <code class="literal">boardRows</code> times the <code class="literal">boardColumns</code>. If the result is not even (using the % 2 check), then we remove one <code class="literal">boardRow</code> from the game. From the prior example, if we requested a five by five board (resulting in 25 tiles), the code would alter it to a four by five grid, which has 20 tiles.</p><p>We also set the <code class="literal">tileSize</code> value here, based on an even spacing of the tiles, along with the extra pad space we will be using between the tiles. Because we need square tiles, there is also the additional check to force the tiles to be square if the source images are not. This will distort the images, but it won't disrupt the game mechanics. Additionally, the <code class="literal">boardOffsetX</code>
<a id="id75" class="indexterm"/>
<a id="id76" class="indexterm"/> and <a id="id77" class="indexterm"/>
<a id="id78" class="indexterm"/>
<code class="literal">boardOffsetY</code> variables simply <a id="id79" class="indexterm"/>ensure the board will be nicely centered in the available board space.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The flow of the game</h1></div></div></div><p>We will need several arrays in the game to help track the tiles. <a id="id80" class="indexterm"/>The first, <a id="id81" class="indexterm"/>
<a id="id82" class="indexterm"/>
<code class="literal">tilesAvailable</code>, will be used in the loading and building of the playfield. The second, <a id="id83" class="indexterm"/>
<a id="id84" class="indexterm"/>
<code class="literal">tilesInPlay</code>, will contain all of the tiles that have not yet been matched. The third, <a id="id85" class="indexterm"/>
<a id="id86" class="indexterm"/>
<code class="literal">tilesSelected</code>, will be used for the match detection methods. Since we are handling a relatively small number of tiles, using this multiple array structure will work fine for our purposes without any performance concerns. Let's add the code for the arrays now:</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.h</code> <a id="id87" class="indexterm"/>
<a id="id88" class="indexterm"/>(already in variable declarations)</p><div><pre class="programlisting">    NSMutableArray *tilesAvailable;
    NSMutableArray *tilesInPlay;
    NSMutableArray *tilesSelected; </pre></div><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code> <a id="id89" class="indexterm"/>
<a id="id90" class="indexterm"/>(<code class="literal">initWithRows</code>, add after "Initialize the arrays")</p><div><pre class="programlisting">        tilesAvailable = [[NSMutableArray alloc]
                          initWithCapacity:maxTiles];
        tilesInPlay = [[NSMutableArray alloc]
                       initWithCapacity:maxTiles];
        tilesSelected = [[NSMutableArray alloc]
                         initWithCapacity:2]; MTPlayfieldLayer.m:
- (void) dealloc
{ 
    // Release of the arrays
    [tilesAvailable release];
    [tilesInPlay release];
    [tilesSelected release];
    
  [super dealloc];
 }</pre></div><p>Here we established the three <a id="id91" class="indexterm"/>
<a id="id92" class="indexterm"/>
<code class="literal">NSMutableArray</code> arrays in the header as variables, instantiated them in the <code class="literal">initWithRows:andColumns:</code> method, and added them to a new <code class="literal">dealloc</code> method. The <a id="id93" class="indexterm"/>
<a id="id94" class="indexterm"/>
<code class="literal">dealloc</code> method releases the three arrays. The <a id="id95" class="indexterm"/>
<a id="id96" class="indexterm"/>
<code class="literal">[super dealloc]</code> call is always required, and it should be the last line of the <code class="literal">dealloc</code> method. This call to <a id="id97" class="indexterm"/>
<a id="id98" class="indexterm"/>
<code class="literal">super dealloc</code> tells the parent class of the current class to do whatever it needs to clean up. This is important to call because our current class doesn't have to worry about the details of any clean up that is done by the parent <code class="literal">CCLayer</code> class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>A stack of tiles</h1></div></div></div><p>Now we need to define the class for the tiles themselves. We <a id="id99" class="indexterm"/>have a few variables we need to <a id="id100" class="indexterm"/>track for the tiles and we will use the <code class="literal">MTMemoryTile</code> class to handle some of the touch detection and tile animation.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The memory tile class</h2></div></div></div><p>For this, we will be subclassing <code class="literal">CCSprite</code>. This will allow <a id="id101" class="indexterm"/>
<a id="id102" class="indexterm"/>us to still treat it like a <code class="literal">CCSprite</code>, but we will enhance it with other methods and properties specific to the tile.</p><p>
<strong>Filename:</strong> <code class="literal">MTMemoryTile.h</code>
</p><div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;
#import "cocos2d.h"
#import "SimpleAudioEngine.h"

// MemoryTile is a subclass of CCSprite
@interface MTMemoryTile : CCSprite {
    NSInteger _tileRow;
    NSInteger _tileColumn;
    
    NSString *_faceSpriteName;
    
    BOOL isFaceUp;
}

@property (nonatomic, assign) NSInteger tileRow;
@property (nonatomic, assign) NSInteger tileColumn;
@property (nonatomic, assign) BOOL isFaceUp;
@property (nonatomic, retain) NSString *faceSpriteName;

// Exposed methods to interact with the tile
-(void) showFace;
-(void) showBack;
-(void) flipTile;
-(BOOL) containsTouchLocation:(CGPoint)pos;

@end </pre></div><p>Here we are declaring the variables with an underscore prefix, but we set the corresponding property without the underscore prefix. This is usually done to avoid accidentally setting the variable value directly, which would bypass the getter and setter methods for the property. This split-naming is finalized in the <a id="id103" class="indexterm"/>
<a id="id104" class="indexterm"/>
<code class="literal">@synthesize</code> statements in the <code class="literal">.m</code> file, where the property will be set to the variable. These statements will be of the basic format:</p><div><pre class="programlisting">@synthesize propertyName = _variableName;</pre></div><p>We're planning ahead with this class, including the headers for three methods that we will use for the tile animation: <a id="id105" class="indexterm"/>
<a id="id106" class="indexterm"/>
<code class="literal">flipTile</code>, <a id="id107" class="indexterm"/>
<a id="id108" class="indexterm"/>
<code class="literal">showFace</code>, and <code class="literal">showBack</code>
<a id="id109" class="indexterm"/>
<a id="id110" class="indexterm"/>. This class will be responsible for handling its own animation.</p><p>All animation in our game will be done using cocos2d actions. Actions are essentially transformations of some sort that can be "run" on most types of cocos2d objects (for example, <code class="literal">CCLayer</code>, <code class="literal">CCSprite</code>, and so on). There are quite a number of different actions defined in the framework. Some of the most commonly used are actions such as <code class="literal">CCMoveTo</code> (to move an object), <code class="literal">CCScaleTo</code> (to change the scale of the object), and <code class="literal">CCCallFunc</code> (to call another method). Actions are a "fire and forget" feature. Once you schedule an action, unless you explicitly change the action (such as calling <code class="literal">stopAllActions</code>), the actions will continue until complete. This is further extended by "wrapping" several actions together in a <code class="literal">CCSequence</code> action, <a id="id111" class="indexterm"/>
<a id="id112" class="indexterm"/>which allows you to chain several actions together, to be run in the order specified. </p><p>We will use <code class="literal">CCSequence</code> "chaining" extensively throughout the book. Actions can be run on most cocos2d objects, but they are most commonly called (via the <code class="literal">runAction:</code> method) on the <code class="literal">CCSprite</code> and <code class="literal">CCLayer</code> objects.</p><p>
<strong>Filename:</strong> <code class="literal">MTMemoryTile.m</code>
</p><div><pre class="programlisting">@implementation MTMemoryTile

@synthesize tileRow = _tileRow;
@synthesize tileColumn = _tileColumn;
@synthesize faceSpriteName = _faceSpriteName;
@synthesize isFaceUp;

-(void) dealloc {
    // We set this to nil to let the string go away
    self.faceSpriteName = nil;
    
    [super dealloc];
}

-(void) showFace {
    // Instantly swap the texture used for this tile
    // to the faceSpriteName 
    [self setDisplayFrame:[[CCSpriteFrameCache
                            sharedSpriteFrameCache]
                spriteFrameByName:self.faceSpriteName]];
    
    self.isFaceUp = YES;
}

-(void) showBack {
    // Instantly swap the texture to the back image
    [self setDisplayFrame:[[CCSpriteFrameCache
                            sharedSpriteFrameCache]
                spriteFrameByName:@"tileback.png"]];
    
    self.isFaceUp = NO;
}

-(void) changeTile {
    // This is called in the middle of the flipTile
    // method to change the tile image while the tile is
    // "on edge", so the player doesn't see the switch
    if (isFaceUp) {
        [self showBack];
    } else {
        [self showFace];
    }
}

-(void) flipTile {
    // This method uses the CCOrbitCamera to spin the
    // view of this sprite so we simulate a tile flip
    
    // Duration is how long the total flip will last
    float duration = 0.25f;
    
    CCOrbitCamera *rotateToEdge = [CCOrbitCamera
                actionWithDuration:duration/2 radius:1
                deltaRadius:0 angleZ:0 deltaAngleZ:90
                angleX:0 deltaAngleX:0];
    CCOrbitCamera *rotateFlat = [CCOrbitCamera
                actionWithDuration:duration/2 radius:1
                deltaRadius:0 angleZ:270 deltaAngleZ:90
                angleX:0 deltaAngleX:0];
    [self runAction:[CCSequence actions: rotateToEdge,
                      [CCCallFunc actionWithTarget:self
                      selector:@selector(changeTile)],
                      rotateFlat, nil]];

    // Play the sound effect for flipping
    [[SimpleAudioEngine sharedEngine] playEffect:
                                    SND_TILE_FLIP];
}

- (BOOL)containsTouchLocation:(CGPoint)pos
{
    // This is called from the CCLayer to let the object
    // answer if it was touched or not
  return CGRectContainsPoint(self.boundingBox, pos);
}
@end</pre></div><p>We will not be using a touch handler inside this class, since we will need to handle the matching logic in the main layer anyway. Instead, we expose the <code class="literal">containsTouchLocation</code> method<a id="id113" class="indexterm"/>
<a id="id114" class="indexterm"/>, so the layer can "ask" the individual tiles if they were touched. This uses the tile's <code class="literal">boundingBox</code>, which is baked-in functionality in cocos2d. A <a id="id115" class="indexterm"/>
<a id="id116" class="indexterm"/>
<code class="literal">boundingBox</code> is a <code class="literal">CGRect</code> representing the smallest rectangle surrounding the sprite image itself.</p><p>We also see the <a id="id117" class="indexterm"/>
<a id="id118" class="indexterm"/>
<code class="literal">showFace</code> and <a id="id119" class="indexterm"/>
<a id="id120" class="indexterm"/>
<code class="literal">showBack</code> methods. These methods will set a new display frame for the tile. In order to retain the name of the sprite frame that is used for the face of this tile, we use the <code class="literal">faceSpriteName</code> variable to hold the sprite frame name (which is also the original image filename). We don't need to keep a variable <a id="id121" class="indexterm"/>for the tile back, since all tiles will be using the same image, so we can safely hardcode that name.</p><p>The <a id="id122" class="indexterm"/>
<a id="id123" class="indexterm"/>
<code class="literal">flipTile</code> method makes use of the <code class="literal">CCOrbitCamera</code> to deform the tile by rotating the "camera" around the sprite image. This is a bit of visual trickery and isn't a perfect flip (some extra deformation occurs nearer the edges of the screen), but it gives a fairly decent animation without a lot of heavy coding or prerendered animations. Here we use a <code class="literal">CCSequence</code> action to queue three actions. The first action, <code class="literal">rotateToEdge</code>, will rotate the tile on its axis until it is edge-wise to the screen. The second calls out to the <a id="id124" class="indexterm"/>
<a id="id125" class="indexterm"/>
<code class="literal">changeFace</code> method, which will do an instant swap between the front and back of the tile. The third action, <code class="literal">rotateFlat</code>, completes the rotation back to the original "flat" orientation. The same <code class="literal">flipTile</code> method can be used for flipping to the front and flipping to the back, because the <code class="literal">isFaceUp</code> Boolean being used allows the <a id="id126" class="indexterm"/>
<a id="id127" class="indexterm"/>
<code class="literal">changeTile</code> method to know whether front or back should be visible. Let's look at following screenshot, which shows the tile flips, in mid-flip:</p><div><img src="img/9007_01_03.jpg" alt="The memory tile class"/></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>
<strong>Downloading the color images of this book</strong>
</p><p>We also provide you a PDF file that has color images of the screenshots/diagrams used in this book. The color images will help you better understand the changes in the output.</p><p>You can download this file from <a class="ulink" href="http://www.packtpub.com/sites/default/files/downloads/9007OS_ColoredImages.pdf">http://www.packtpub.com/sites/default/files/downloads/9007OS_ColoredImages.pdf</a> </p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Loading tiles</h2></div></div></div><p>Now we have our tile class, we're ready to <a id="id128" class="indexterm"/>load some tiles into the <a id="id129" class="indexterm"/>
<a id="id130" class="indexterm"/>
<a id="id131" class="indexterm"/>
<code class="literal">tilesAvailable</code> array:</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) acquireMemoryTiles {
    // This method will create and load the MemoryTiles
    // into the tilesAvailable array
    
    // We assume the tiles all use standard names
    for (int cnt = 1; cnt &lt;= maxTiles; cnt++) {
        // Load the tile into the array
        // We loop so we add each tile in the array twice
        // This gives us a matched pair of each tile
        for (NSInteger tileNo = 1; tileNo &lt;= 2; tileNo++) {
            // Generate the tile image name
            NSString *imageName = [NSString
                    stringWithFormat:@"tile%i.png", cnt];
            
            //Create a new MemoryTile with this image
            MTMemoryTile *newTile = [MTMemoryTile
                    spriteWithSpriteFrameName:imageName];

            // We capture the image name for the card face
            [newTile setFaceSpriteName:imageName]; 
            
            // We want the tiles to start face down
            [newTile showBack];
            
            // Add the MemoryTile to the array
            [tilesAvailable addObject:newTile];
        }
    }
}</pre></div><p>Here we loop through all the unique tiles we need (up to the value of <code class="literal">maxTiles</code>, which is set to half of the available spaces on the board). Inside that loop, we set up another <em>for</em> loop that counts to <code class="literal">2</code>. We do this because we need two copies of each tile to assemble our board. Since we have established that our tiles are named as <code class="literal">tile#.png</code>, we create an <code class="literal">NSString</code> with the incremental name, and create an <code class="literal">MTMemoryTile</code> object with a standard <code class="literal">CCSprite</code> constructor. As we said earlier, we want to keep a copy of the <a id="id132" class="indexterm"/>
<a id="id133" class="indexterm"/>image name for the <code class="literal">showFace</code> method, so we set the <a id="id134" class="indexterm"/>
<a id="id135" class="indexterm"/>
<code class="literal">faceSpriteName</code> variable to that value. It wouldn't be much of a game if we had all the tiles face up, so we call <code class="literal">showBack</code>, so the tiles are face down before they are used on screen. Finally, we add the tile we just created to the <code class="literal">tilesAvailable</code> array. Once this method completes, the <a id="id136" class="indexterm"/>
<a id="id137" class="indexterm"/>
<code class="literal">tilesAvailable</code> array will be the only retain we have on the tiles.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Drawing tiles</h2></div></div></div><p>Now we need to draw a randomly selected tile in every position to make a nice grid. First we need to figure out where each tile should be positioned. <a id="id138" class="indexterm"/>
<a id="id139" class="indexterm"/>If we were using a fixed number of tiles, we could use absolute positioning. To account for the dynamic number of tiles, we add a "helper" method to determine positioning as follows:</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(CGPoint) tilePosforRow:(NSInteger)rowNum
               andColumn:(NSInteger)colNum {
    // Generate the coordinates for each tile
    float newX = boardOffsetX +
            (tileSize.width + padWidth) * (colNum - .5);
    float newY = boardOffsetY +
            (tileSize.height + padHeight) * (rowNum - .5);

    return ccp(newX, newY);
}</pre></div><p>To calculate the x position, we determine the total footprint of a single tile and the associated padding. We multiply this times the column number minus one half. We add this result to the board offset we calculated earlier. Why do we subtract one half? This is because our positions are based on the complete size of the tile and the padding. What we need is the center point of the tile, because that is our <a id="id140" class="indexterm"/>
<a id="id141" class="indexterm"/>
<code class="literal">anchorPoint</code> (that is the point on which the tile will pivot or rotate.). We need this anchor point left at the center (the default <code class="literal">anchorPoint</code> for a <a id="id142" class="indexterm"/>
<a id="id143" class="indexterm"/>
<code class="literal">CCSprite</code> object, as it happens), because when we flip the tiles, the flip will be based on this <code class="literal">anchorPoint</code>, so we want them to flip around the middle of the tile. Now that we have our tile positioning established, <a id="id144" class="indexterm"/>
<a id="id145" class="indexterm"/>we can go ahead and start building the tiles on the screen.</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) generateTileGrid {
    // This method takes the tilesAvailable array,
    // and deals the tiles out to the board randomly
    // Tiles used will be moved to the tilesInPlay array
    
    // Loop through all the positions on the board
    for (NSInteger newRow = 1; newRow &lt;= boardRows; newRow++) {
        for (NSInteger newCol = 1; newCol &lt;= boardColumns;
           newCol++) {
            
            // We randomize each card slot
            NSInteger rndPick = (NSInteger)arc4random() %
                                ([tilesAvailable count]);

            // Grab the MemoryTile from the array
            MTMemoryTile *newTile = [tilesAvailable
                                objectAtIndex:rndPick];

            // Let the card "know" where it is
            [newTile setTileRow:newRow];
            [newTile setTileColumn:newCol];
            
            // Scale the tile to size
            float tileScaleX = tileSize.width /
                            newTile.contentSize.width;

            // We scale by X only (tiles are square)
            [newTile setScale:tileScaleX];

            // Set the positioning for the tile
            [newTile setPosition:[self tilePosforRow:newRow
                                        andColumn:newCol]];
            
            // Add the tile as a child of our batch node
            [self addChild:newTile];
            
            // Since we don't want to re-use this tile,
            // we remove it from the array
            [tilesAvailable removeObjectAtIndex:rndPick];
            
            // We retain the MemoryTile for later access
            [tilesInPlay addObject:newTile];
        }
    }    
}</pre></div><p>Here we use two nested <em>for</em> loops to iterate through all rows and all columns. We use <code class="literal">arc4random()</code> <a id="id146" class="indexterm"/>
<a id="id147" class="indexterm"/>to select a random tile from the <code class="literal">tilesAvailable</code> array and build a new <a id="id148" class="indexterm"/>
<a id="id149" class="indexterm"/>
<code class="literal">MTMemoryTile</code> object that references the tile selected. After setting the <code class="literal">MTMemoryTile</code> object's variables for which row and column it represents, we set the scale factor for the tile. Since our images are bigger than needed for most game types, we divide the desired <code class="literal">tileSize</code> by the actual <code class="literal">contentSize</code> of the image. When applied, this will correctly scale our image to the desired display size. We only use the x (width) value, <a id="id150" class="indexterm"/>since we already enforced in the <code class="literal">initWithRows:andColumns:</code> method that the images will always be square.</p><p>We use the <a id="id151" class="indexterm"/>
<a id="id152" class="indexterm"/>
<code class="literal">tilePosforRow</code> method to determine where it should be on the layer, and we add it. After adding it to the layer, we also add the new tile to the <code class="literal">tilesInPlay</code> array and remove it from the <a id="id153" class="indexterm"/>
<a id="id154" class="indexterm"/>
<code class="literal">tilesAvailable</code> array. By removing it from <code class="literal">tilesAvailable</code>, we ensure that we cannot select the same tile twice. After all iterations of the nested loops, the <code class="literal">tilesAvailable</code> array should be empty, and the board should be fully populated with tiles.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Adding interactivity</h1></div></div></div><p>Now that we have our randomized grid of <a id="id155" class="indexterm"/>tiles on the board, we need to add the touch handler to let us interact with them. Since our game mechanics are pretty simple, we will use just the <a id="id156" class="indexterm"/>
<a id="id157" class="indexterm"/>
<a id="id158" class="indexterm"/>
<code class="literal">ccTouchesEnded</code> method as follows:</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) ccTouchesEnded:(NSSet *)touches
             withEvent:(UIEvent *)event {
    
    // If game over, go back to the main menu on any touch
    if (isGameOver) {
        [[CCDirector sharedDirector]
                    replaceScene:[MTMenuScene node]];
    }
    
    UITouch *touch = [touches anyObject];
  
    CGPoint location = [touch locationInView: [touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                            convertToGL:location];
    
    // If the back button was pressed, we exit
    if (CGRectContainsPoint([backButton boundingBox],
                            convLoc)) {
        [[CCDirector sharedDirector]
                replaceScene:[MTMenuScene node]];
    }
    
    // If we have 2 tiles face up, do not respond
    if ([tilesSelected count] == 2) {
        return;
    } else {
        // Iterate through tilesInPlay to see which tile
        // was touched
        for (MTMemoryTile *aTile in tilesInPlay) {
            if ([aTile containsTouchLocation:convLoc] &amp;&amp;
                [aTile isFaceUp] == NO) {
                // Flip the tile
                [aTile flipTile];
                // Hold the tile in a buffer array
                [tilesSelected addObject:aTile];
                
                // Call the score/fail check,
                // if it is the second tile
                if ([tilesSelected count] == 2) {
                    // We delay so player can see cards
                   [self scheduleOnce:@selector(checkForMatch)
                                 delay:1.0];
                   break;
                }
                
            }
        }
    }
}</pre></div><p>In the touch handler, the touches are provided in an <code class="literal">NSSet</code>. However, since we do not have multiple touches enabled, we can be sure we will only be getting a single touch that we care about. Why is there no multi-touch in this game? Multiple simultaneous touches would cause confusion for the player and really complicate the code to determine which tiles should be checked for a match. So by not enabling multiple touches, we save ourselves extra work, and reduce the confusion for the flow of the game.</p><p>The first section of the method checks to see if we have reached a game over state (as represented by a <code class="literal">YES</code> value in the <a id="id159" class="indexterm"/>
<a id="id160" class="indexterm"/>
<code class="literal">isGameOver</code> variable, any touch after we have reached game over will return the player to the menu screen.</p><p>The second section of the method is detecting touches on the back button. The <code class="literal">location</code> and <code class="literal">convLoc</code> variables together convert the touch into a coordinate in our game screen. We use this location to check if the <code class="literal">backButton</code> was touched. If it has been touched, we also exit to the menu screen, regardless of what else is going on in the game.</p><p>We then check to make sure the <a id="id161" class="indexterm"/>
<a id="id162" class="indexterm"/>
<code class="literal">tilesSelected</code> array doesn't have two items in it. The <code class="literal">tilesSelected</code> array is with the tiles that have been flipped face up. If there are two tiles already face up, that means the match checking has not yet been resolved. In those cases, we don't want to let the user keep flipping over tiles, so we simply return without responding to the touch. This will effectively throw away the touch, so we can safely move on with our game.</p><p>If we don't have two tiles selected already, then we iterate through all of the tiles in the <code class="literal">tilesInPlay</code> array and poll it to determine: a) are you being touched? and b) are you face down. If both of these are <code class="literal">true</code>, we send the message to the touched tile to flip over (<code class="literal">flipTile</code>), and we add the tile to the <code class="literal">tilesSelected</code> array. If this was our second tile added to the <code class="literal">tilesSelected</code> array, we will call the <a id="id163" class="indexterm"/>
<a id="id164" class="indexterm"/>
<code class="literal">checkForMatch</code> method after a delay of one second. This delay gives us two benefits: it allows the player to see the potential match they just made, and it gives plenty of time to finish iterating through the <a id="id165" class="indexterm"/>
<a id="id166" class="indexterm"/>
<code class="literal">tilesInPlay</code> array so we don't risk mutating the array. <a id="id167" class="indexterm"/>
<a id="id168" class="indexterm"/>
<strong>Mutating</strong> an array means you tried to change it while it was being evaluated. If we skipped the delay, the <code class="literal">checkForMatch</code> method would cause this mutation (and crash) because it can remove tiles from the <code class="literal">tilesInPlay</code> array. Go ahead and try it yourself. <a id="id169" class="indexterm"/>Actually seeing the error messages when you know what you did wrong will help you know where to look later, when you cause a crash without knowing what you did wrong.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Checking for matches</h2></div></div></div><p>Since we have done quite a bit of preparation for the rest of the <a id="id170" class="indexterm"/>mechanics of the game, it might come as a surprise that the logic to check for matching tiles is very simple. <a id="id171" class="indexterm"/>Since we stored the name of the image used for each tile inside the <code class="literal">MTMemoryTile</code> object, it is a matter of comparing the two and see if they are the same.</p><p>
<strong>Filename:</strong> MTPlayfieldLayer.m</p><div><pre class="programlisting">-(void) checkForMatch {
    // Get the MemoryTiles for this comparison
    MTMemoryTile *tileA = [tilesSelected objectAtIndex:0];
    MTMemoryTile *tileB = [tilesSelected objectAtIndex:1];
    
    // See if the two tiles matched
    if ([tileA.faceSpriteName
            isEqualToString:tileB.faceSpriteName]) {
        // We remove the matching tiles
        [self removeMemoryTile:tileA];
        [self removeMemoryTile:tileB];
    } else {
        // No match, flip the tiles back
        [tileA flipTile];
        [tileB flipTile];
    }

    // Remove the tiles from tilesSelected
    [tilesSelected removeAllObjects];
}

-(void) removeMemoryTile:(MTMemoryTile*)thisTile {
    [thisTile removeFromParentAndCleanup:YES];
}</pre></div><p>If you recall, in the <a id="id172" class="indexterm"/>
<a id="id173" class="indexterm"/>
<code class="literal">ccTouchesEnded</code> method we stored the face up tile in the <code class="literal">tilesSelected</code> array. Our logic only allows there to be two objects in the <code class="literal">tilesSelected</code> array, and the <a id="id174" class="indexterm"/>
<a id="id175" class="indexterm"/>
<code class="literal">checkForMatch</code> method is called only when there are two objects in that array. Because of those restrictions, we can safely assume that there are objects in that array at index <code class="literal">0</code> and index <code class="literal">1</code>. (We create references to them as <code class="literal">tileA</code> and <code class="literal">tileB</code> to make the code simpler.)</p><p>It is trivial at this point to call <a id="id176" class="indexterm"/>
<a id="id177" class="indexterm"/>
<code class="literal">isEqualToString</code> on the <a id="id178" class="indexterm"/>
<a id="id179" class="indexterm"/>
<code class="literal">faceSpriteName</code> variable of <code class="literal">tileA</code> and pass it the value of the <code class="literal">faceSpriteName variable from tileB</code>. If these strings are equal, we have a match. When comparing strings, you cannot use <code class="literal">==</code> operations, you must use <code class="literal">isEqualToString:</code>.</p><p>When a match is found, we call the <a id="id180" class="indexterm"/>
<a id="id181" class="indexterm"/>
<code class="literal">removeMemoryTile</code> method that simply removes the tile passed. If we don't have a match, we send the <a id="id182" class="indexterm"/>message to each tile to flip itself back over. Since we have resolved the matching, either by making a match or by turning the tiles back over, we then remove the tiles from the <a id="id183" class="indexterm"/>
<a id="id184" class="indexterm"/>
<code class="literal">tilesSelected</code> array so we have an empty <a id="id185" class="indexterm"/>array to hold the next possible match.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Scoring and excitement</h1></div></div></div><p>The game works well with the development we have covered, but there are a few places where we can add a little more visual flair and some excitement. Players love having a game that keeps score. They also love animation. There is excitement to be had by having the ability to lose. Let's give the player what they want.</p><p>We build the score and lives displays using <a id="id186" class="indexterm"/>
<a id="id187" class="indexterm"/>
<code class="literal">CCLabelTTF</code> labels, with the variables <code class="literal">playerScore</code> and <code class="literal">livesRemaining</code> as their label contents. These are declared as variables of the layer, so we can easily update them. When we <a id="id188" class="indexterm"/>
<a id="id189" class="indexterm"/>start animating tiles, it will be useful to know where the score and lives displays are on screen.</p><p>There are two main approaches to adding text to the screen: <a id="id190" class="indexterm"/>
<a id="id191" class="indexterm"/>
<code class="literal">CCLabelTTF</code> and <code class="literal">CCLabelBMFont</code>
<a id="id192" class="indexterm"/>
<a id="id193" class="indexterm"/>. Both have their uses, which we will briefly outline here. <code class="literal">CCLabelTTF</code> uses a standard TTF font file. The way it draws the text on the screen is not very efficient and can cause performance issues in some uses. The other approach, <code class="literal">CCLabelBMFont</code>, uses a bitmap (image file) of the font and internally uses a batch node to render the text. This means it is highly efficient at drawing, with very little performance concern. Other than the use of a TTF file versus an image file, the way you code for them is very similar. One potential issue with a <a id="id194" class="indexterm"/>
<a id="id195" class="indexterm"/>
<code class="literal">BMFont</code> file is that you must have the entire font in a single bitmap. If you are using a large font size, this often causes you to need to leave out some characters that may be needed to support international keyboards. A TTF file does not have this problem. Also, it is common with the <code class="literal">CCLabelBMFont</code> approach to have multiple versions of the font if you want to use different font sizes. In this book, we will use <code class="literal">CCLabelTTF</code> labels throughout because we do not have any performance (frame rate) concerns with any of these projects. </p><p>If we were to have performance issues, we would certainly switch to using <code class="literal">CCLabelBMFont</code> instead of <code class="literal">CCLabelTTF</code>. We leave it as an exercise for the reader to convert these projects to use the <code class="literal">CCLabelBMFont</code> class. (For creation of the bitmaps, an excellent resource is Glyph Designer, available at <a class="ulink" href="http://glyphdesigner.71squared.com">http://glyphdesigner.71squared.com</a>.)</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(CGPoint) scorePosition {
    return ccp(size.width - 10 - tileSize.width/2,
               (size.height/4) * 3);
}

-(CGPoint) livesPosition {
    return ccp(size.width - 10 - tileSize.width/2,
               size.height/4);
}</pre></div><p>Rather than hardcoding the values in multiple places, it is a preferred approach to create helper methods such as <code class="literal">scorePosition</code> and <code class="literal">livesPosition</code>, which return a <code class="literal">CGPoint</code> reference of where those elements are onscreen. Here we see the calculations, which place the score and lives near the left edge of the screen, with the score three quarters of the way up the screen, and the lives one quarter of the way up the screen.</p><p>The creation of simple labels is very basic, using the positioning we saw above. To see how the score and lives are created, please consult the <a id="id196" class="indexterm"/>accompanying code bundle for this book.</p><p>Now we will need a way to score and animate the tiles when the player makes a successful match. When a match is scored, we will fly the tiles to the score, and then have them shrink into the score position until they disappear. Let's see how that works:</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) scoreThisMemoryTile:(MTMemoryTile*)aTile {
    // We set a baseline speed for the tile movement
    float tileVelocity = 600.0;
    
    // We calculate the time needed to move the tile
    CGPoint moveDifference = ccpSub([self scorePosition],
                                    aTile.position);
    float moveDuration = ccpLength(moveDifference) /
                                    tileVelocity;
    // Define the movement actions
    CCMoveTo *move = [CCMoveTo actionWithDuration:
               moveDuration position:[self scorePosition]];
    CCScaleTo *scale = [CCScaleTo actionWithDuration:0.5
                                            scale:0.001];
    CCDelayTime *delay = [CCDelayTime
                          actionWithDuration:0.5];
    CCCallFuncND *remove = [CCCallFuncND
                    actionWithTarget:self
                    selector:@selector(removeMemoryTile:)
                    data:aTile];

    // Run the actions
    [aTile runAction:[CCSequence actions:move, scale,
                      delay, remove, nil]];
    
    // Play the sound effect
    [[SimpleAudioEngine sharedEngine]
                        playEffect:SND_TILE_SCORE];
    
    // Remove the tile from the tilesInPlay array
    [tilesInPlay removeObject:aTile];
    
    // Add 1 to the player's score
    playerScore++;
    
    // Recalculate the number of lives left
    [self calculateLivesRemaining];
}</pre></div><p>Here we leverage the cocos2d actions heavily, using the stock actions of <code class="literal">CCMoveTo</code>, <code class="literal">CCScaleTo</code>, <code class="literal">CCDelayTime</code>, and <code class="literal">CCCallFuncND</code>. One aspect of our flying-to-score effect is that we want the tiles to move at a constant rate. If we hardcoded a duration for the <code class="literal">CCMoveTo</code> action, the tiles closer to the score would move <a id="id197" class="indexterm"/>slowly, and those farther away would move really fast. To achieve a constant rate, we set a desired speed (<code class="literal">tileVelocity</code>), then calculate how far away the tile is from the score. We divide these out to arrive at the correct movement duration for this tile. After we initiate the actions, we increment the score by one (<code class="literal">playerScore++</code>), and call the <a id="id198" class="indexterm"/>
<a id="id199" class="indexterm"/>
<code class="literal">calculateLivesRemaining</code> method (which we will see shortly).</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Animating the score</h1></div></div></div><p>Now that we have the tile animation <a id="id200" class="indexterm"/>added, now we should do something more flashy with the score itself.</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) animateScoreDisplay {
    // We delay for a second to allow the tiles to get
    // to the scoring position before we animate
    CCDelayTime *firstDelay = [CCDelayTime
                actionWithDuration:1.0];
    CCScaleTo *scaleUp = [CCScaleTo
                actionWithDuration:0.2 scale:2.0];
    CCCallFunc *updateScoreDisplay = [CCCallFunc
                actionWithTarget:self
                selector:@selector(updateScoreDisplay)];
    CCDelayTime *secondDelay = [CCDelayTime
                actionWithDuration:0.2];
    CCScaleTo *scaleDown = [CCScaleTo
                actionWithDuration:0.2 scale:1.0];
    
    [playerScoreDisplay runAction:[CCSequence actions:
                firstDelay, scaleUp, updateScoreDisplay,
                secondDelay, scaleDown, nil]];
} 

-(void) updateScoreDisplay {
    // Change the score display to the new value
    [playerScoreDisplay setString:
     [NSString stringWithFormat:@"%i", playerScore]];
    
    // Play the "score" sound
    [[SimpleAudioEngine sharedEngine]
                            playEffect:SND_SCORE];
} </pre></div><p>We finally settled on scaling the score up, change it to the new value, and scale it back to normal. This is all done with standard cocos2d actions, so we could add in more flair with other effects.  A <code class="literal">CCRotateTo</code> action might add a nice touch by spinning <a id="id201" class="indexterm"/>the score around when it <a id="id202" class="indexterm"/>updates. For this game, we will stick to this simpler animation. We leave it as a challenge to the reader to add these types of enhancements for more "visual flair."</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Adding lives and game over</h2></div></div></div><p>Now we come to the point where we decide how the player can win or lose. You win after you have successfully matched all the tiles on the board. Losing is less obvious in a one-player game like this. Our approach is to give the player a number of lives. When you take a turn and fail to match the tiles, you lose a life. Lose all of them, and it's game over. The challenge comes from deciding how many <a id="id203" class="indexterm"/>lives the player should have. After testing several <a id="id204" class="indexterm"/>approaches, we determined the most exciting way would be to have the number of lives set to half the number of tiles currently on the board. If the board has 20 tiles in play, the player has 10 lives. Once the player makes a successful match, the lives are recalculated based on the new number of tiles in play. This gives some level of excitement as the lives are dwindling, and it encourages the player to think about their moves more carefully.</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) animateLivesDisplay {
    // We delay for a second to allow the tiles to flip back
    CCScaleTo *scaleUp = [CCScaleTo
            actionWithDuration:0.2 scale:2.0];
    CCCallFunc *updateLivesDisplay = [CCCallFunc
            actionWithTarget:self
            selector:@selector(updateLivesDisplay)];
    CCCallFunc *resetLivesColor = [CCCallFunc
            actionWithTarget:self
            selector:@selector(resetLivesColor)];
    CCDelayTime *delay = [CCDelayTime
            actionWithDuration:0.2];
    CCScaleTo *scaleDown = [CCScaleTo
            actionWithDuration:0.2 scale:1.0];
    [livesRemainingDisplay runAction:[CCSequence actions:
            scaleUp, updateLivesDisplay, delay, scaleDown,
            resetLivesColor, nil]];
}

-(void) updateLivesDisplayQuiet {
    // Change the lives display without the fanfare
    [livesRemainingDisplay setString:[NSString
            stringWithFormat:@"%i", livesRemaining]];
}

-(void) updateLivesDisplay {
    // Change the lives display to the new value
    [livesRemainingDisplay setString:[NSString
            stringWithFormat:@"%i", livesRemaining]];
    // Change the lives display to red
    [livesRemainingDisplay setColor:ccRED];

    // Play the "wrong" sound
    [[SimpleAudioEngine sharedEngine]
                        playEffect:SND_TILE_WRONG];
    
    [self checkForGameOver];
}

-(void) calculateLivesRemaining {
    // Lives equal half of the tiles on the board
    livesRemaining = [tilesInPlay count] / 2;
}

-(void) resetLivesColor {
    // Change the Lives counter back to blue
    [livesRemainingDisplay setColor:ccBLUE];
} </pre></div><p>The preceding section of code looks very similar to the score methods. We leverage cocos2d actions to animate the lives display, only this time <a id="id205" class="indexterm"/>we also turn the text red when the number of lives is reduced, and then change it back to blue at the end of the <code class="literal">CCSequence</code> of actions. <a id="id206" class="indexterm"/>One item of note here is the <a id="id207" class="indexterm"/>
<code class="literal">updateLivesDisplayQuiet</code> method. This method is called when the player makes a successful match to let us change the lives to their new value without the "oh-no" fanfare that we use when the player loses a life.</p><p>We now have two game over conditions to consider. If <code class="literal">livesRemaining</code> is zero, the player loses. If the <a id="id208" class="indexterm"/>
<a id="id209" class="indexterm"/>
<code class="literal">tilesInPlay</code> array is empty, the <a id="id210" class="indexterm"/>player has won. This feels like a good time to put the code together into a single method to check these conditions.</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) checkForGameOver {
    NSString *finalText;
    // Player wins
    if ([tilesInPlay count] == 0) {
        finalText = @"You Win!";
    // Player loses
    } else if (livesRemaining &lt;= 0) {
        finalText = @"You Lose!";
    } else {
        // No game over conditions met
        return;
    }
    
    // Set the game over flag
    isGameOver = YES;
    
    // Display the appropriate game over message
    CCLabelTTF *gameOver = [CCLabelTTF
                    labelWithString:finalText
                    fontName:@"Marker Felt" fontSize:60];
    [gameOver setPosition:ccp(size.width/2,size.height/2)];
    [self addChild:gameOver z:50];
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Bringing it all together</h2></div></div></div><p>We have added extra flash and flair in the code, but we haven't tied it all together yet. Most of the new code is integrated into the <a id="id211" class="indexterm"/>
<a id="id212" class="indexterm"/>
<code class="literal">checkForMatch</code> method, so let's see how that looks with everything integrated:</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) checkForMatch {
    // Get the MemoryTiles for this comparison
    MTMemoryTile *tileA = [tilesSelected objectAtIndex:0];
    MTMemoryTile *tileB = [tilesSelected objectAtIndex:1];
    
    // See if the two tiles matched
    if ([tileA.faceSpriteName
            isEqualToString:tileB.faceSpriteName]) {
        // We start the scoring, lives, and animations
        [self scoreThisMemoryTile:tileA];
        [self scoreThisMemoryTile:tileB];
        [self animateScoreDisplay];
        [self calculateLivesRemaining];
        [self updateLivesDisplayQuiet];
        [self checkForGameOver];
        
    } else {
        // No match, flip the tiles back
        [tileA flipTile];
        [tileB flipTile];
        
        // Take off a life and update the display
        livesRemaining--;
        [self animateLivesDisplay];
    }

    // Remove the tiles from tilesSelected
    [tilesSelected removeAllObjects];
}</pre></div><p>Now we have a fully functional game, complete with scoring, <a id="id213" class="indexterm"/>lives, a way to win and a way to lose. There is only one necessary element still missing.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>It's quiet...too quiet</h2></div></div></div><p>A major mistake some casual game designers make is to downplay the importance of audio. When you are playing a quiet game without the aid of a computer, there are always subtle sounds. Playing cards give a soft "thwap" sound when playing solitaire. Tokens in board games click as they tap their way around the board. Video games should have these "incidental" sound effects, too. These are the button clicks, the buzzers when something goes wrong, and so forth.</p><p>We will be using <code class="literal">CocosDenshion</code>, the <a id="id214" class="indexterm"/>
<a id="id215" class="indexterm"/>audio engine that is bundled with cocos2d. <code class="literal">CocosDenshion</code> includes a very easy to use interface appropriately named <code class="literal">SimpleAudioEngine</code>. To initialize it, you need to import it into your classes (including the <code class="literal">AppDelegate.m</code> file) and add one line near the end of <a id="id216" class="indexterm"/>
<a id="id217" class="indexterm"/>the <code class="literal">application:didFinishLaunchingWithOptions:</code> method (before the return <code class="literal">YES;</code> line).</p><p>
<strong>Filename:</strong> <code class="literal">AppDelegate.m</code>
</p><div><pre class="programlisting">    // Initialize the SimpleAudioEngine
    [SimpleAudioEngine sharedEngine]; </pre></div><p>For our implementation, we want to preload all of our sound effects so there is no lag the first time the sound effect is played. We do this with a method that is called from the <code class="literal">initWithRows:andColumns:</code> method <a id="id218" class="indexterm"/>
<a id="id219" class="indexterm"/>of our <code class="literal">MTPlayfieldLayer</code>.</p><p>
<strong>Filename:</strong> <code class="literal">MTPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) preloadEffects {
    // Preload all of our sound effects
    [[SimpleAudioEngine sharedEngine]
                        preloadEffect:SND_TILE_FLIP];
    [[SimpleAudioEngine sharedEngine]
                        preloadEffect:SND_TILE_SCORE];
    [[SimpleAudioEngine sharedEngine]
                        preloadEffect:SND_TILE_WRONG];
    [[SimpleAudioEngine sharedEngine]
                        preloadEffect:SND_SCORE];
}</pre></div><p>The <a id="id220" class="indexterm"/>
<a id="id221" class="indexterm"/>
<code class="literal">preloadEffect</code> method of <code class="literal">SimpleAudioEngine</code> actually takes an <code class="literal">NSString</code> as an argument. We have defined constants to hold the names of the sound files. (These constants are at the top of the <code class="literal">MTPlayfieldLayer.m</code> file, above the <code class="literal">@implementation</code> statement.)</p><div><pre class="programlisting">#define SND_TILE_FLIP @"button.caf"
#define SND_TILE_SCORE @"whoosh.caf"
#define SND_TILE_WRONG @"buzzer.caf"
#define SND_SCORE @"harprun.caf" </pre></div><p>Why do we do this? By using <code class="literal">#define</code> statements in a single location, we can easily change the sound files we are using in one place, rather than relying on find-and-replace functionality to change the filenames throughout our code. Having done this, anywhere we want to play the <code class="literal">button.caf</code> file, we can simply refer to it as <code class="literal">SND_TILE_FLIP</code> (no quotes around it), and Xcode takes care of the rest.</p><p>We have peppered the code with various playing of these sound effects, but we won't go into detail on where each sound is triggered. When you want to play a sound effect, you can call it with a single line of code, as follows:</p><div><pre class="programlisting">    [[SimpleAudioEngine sharedEngine]
                            playEffect:SND_SCORE];</pre></div><p>It doesn't get much simpler than that!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Summary</h1></div></div></div><p>We've covered a lot of ground with this memory game. At this point you should be familiar with the methodology we will continue you use throughout the book regarding <code class="literal">CCScene</code> and <code class="literal">CCLayer</code> organization. We have used a custom <code class="literal">init</code> method to make our game engine more flexible. We have also covered effective use of actions, <code class="literal">SimpleSoundEngine</code>, a couple ways of handling touches, and some basic game flow intelligence. And this is just the beginning! In the next chapter, we tackle a modern favorite, a Match-3 game. We'll explore a couple ways to solve the match detection problem, and build a fun game along the way.</p></div></body></html>