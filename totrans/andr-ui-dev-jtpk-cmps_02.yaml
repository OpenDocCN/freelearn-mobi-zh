- en: 'Chapter 1: Building Your First Compose App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Android was introduced more than 10 years ago, it quickly gained popularity
    among developers because it was incredibly easy to write apps. All you had to
    do was define the user interface (UI) in an XML file and connect it to your *activity*.
    This worked flawlessly because apps were small and developers needed to support
    just a handful of devices.
  prefs: []
  type: TYPE_NORMAL
- en: So much has changed since then.
  prefs: []
  type: TYPE_NORMAL
- en: With every new platform version, Android gained new features. Through the years,
    device manufacturers introduced thousands of devices with different screen sizes,
    pixel densities, and form factors. While Google did its best to keep the Android
    *view* system comprehendible, the complexity of apps increased significantly;
    basic tasks such as implementing scrolling lists or animations require lots of
    boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: It turned out that these problems were not specific to Android. Other platforms
    and operating systems faced them as well. Most issues stem from how UI toolkits
    used to work; they follow a so-called **imperative approach** (which I will explain
    in [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040), *Understanding the Declarative
    Paradigm*). The solution was a paradigm shift. The web framework React was the
    first to popularize a declarative approach. Other platforms and frameworks (for
    example, Flutter and SwiftUI) followed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jetpack Compose** is Google''s declarative UI framework for Android. It dramatically
    simplifies the creation of UIs. As you will surely agree after reading this book,
    using Jetpack Compose is both easy and fun. But before we dive in, please note
    that Jetpack Compose is Kotlin-only. This means that all your Compose code will
    have to be written in Kotlin. To follow this book, you should have a basic understanding
    of the Kotlin syntax and the functional programming model. If you want to learn
    more about these topics, please refer to the *Further reading* section at the
    end of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers three main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Saying hello to composable functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the preview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a Compose app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will explain how to build a simple UI with Jetpack Compose. Next, you will
    learn to use the **preview** feature in Android Studio and how to run a Compose
    app. By the end of this chapter, you will have a basic understanding of how composable
    functions work, how they are integrated into your app, and how your project must
    be configured in order to use Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01).
    Please download the zipped version or clone the repository to an arbitrary location
    on your computer. The projects require at least Android Studio Arctic Fox. You
    can download the latest version at [https://developer.android.com/studio](https://developer.android.com/studio).
    Please follow the detailed installation instructions at [https://developer.android.com/studio/install](https://developer.android.com/studio/install).
  prefs: []
  type: TYPE_NORMAL
- en: To open this book's project, launch Android Studio, click the **Open** button
    in the upper-right area of the **Welcome to Android Studio** window, and select
    the base directory of the project in the folder selection dialog. Please make
    sure to not open the base directory of the repository, because Android Studio
    would not recognize the projects. Instead, you must pick the directory that contains
    the project you want to work with.
  prefs: []
  type: TYPE_NORMAL
- en: To run a sample app, you need a real device or the Android Emulator. Please
    make sure that developer options and USB debugging are enabled on the real device,
    and that the device is connected to your development machine via USB or WLAN.
    Please follow the instructions at [https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options).
    You can also set up the Android Emulator. You can find detailed instructions at
    [https://developer.android.com/studio/run/emulator](https://developer.android.com/studio/run/emulator).
  prefs: []
  type: TYPE_NORMAL
- en: Saying hello to composable functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will see shortly, composable functions are the essential building blocks
    of Compose apps; these elements make up the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a first look at them, I will walk you through a simple app called `chapter_01`.
    Otherwise, please do so now. To follow this section, open the project in Android
    Studio and open `MainActivity.kt`. The use case of our first Compose app is very
    simple. After you have entered your name and clicked on the **Done** button, you
    will see a greeting message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The Hello app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – The Hello app
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, the app consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The welcome text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A row with an `EditText` equivalent and a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A greeting message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at how to create the app.
  prefs: []
  type: TYPE_NORMAL
- en: Showing a welcome text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the welcome text, our first composable function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Composable functions can be easily identified by the `@Composable` annotation.
    They do not need to have a particular return type but instead emit UI elements.
    This is usually done by invoking other composables (for the sake of brevity, I
    will sometimes omit the word "function"). [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*, will cover this in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `Welcome()` summons a text. `Text()` is a built-in composable
    function and belongs to the `androidx.compose.material` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke `Text()` just by its name, you need to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Please note that you can save `import` lines by using the `*` wildcard.
  prefs: []
  type: TYPE_NORMAL
- en: To use `Text()` and other Material Design elements, your `build.gradle` file
    must include an implementation dependency to `androidx.compose.material:material`.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the welcome text code, the `Text()` composable inside `Welcome()`
    is configured through two parameters, `text` and `style`.
  prefs: []
  type: TYPE_NORMAL
- en: The first, `text`, specifies what text will be displayed. `R.string` may look
    familiar; it refers to definitions inside the `strings.xml` files. Just like in
    view-based apps, you define text for UI elements there. `stringResource()` is
    a predefined composable function. It belongs to the `androidx.compose.ui.res`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The `style` parameter modifies the visual appearance of a text. In this case,
    the output will look like a subtitle. I will show you how to create your own themes
    in [*Chapter 6*](B17505_06_ePub.xhtml#_idTextAnchor105), *Putting Pieces Together*.
  prefs: []
  type: TYPE_NORMAL
- en: The next composable looks quite similar. Can you spot the differences?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `stringResource()` receives an additional parameter. This is very convenient
    for replacing placeholders with actual texts. The string is defined in `strings.xml`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `textAlign` parameter specifies how text is positioned horizontally. Here,
    each line is centered.
  prefs: []
  type: TYPE_NORMAL
- en: Using rows, text fields, and buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s turn to the text input field (`Row()`, which belongs to the `androidx.compose.foundation.layout`
    package. Just like all composable functions, `Row()` can receive a comma-separated
    list of parameters inside `( )` and its children are put inside curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`TextAndButton()` requires two parameters, `name` and `nameEntered`. You will
    see what they are used for in the *Showing a greeting message* section. For now,
    please ignore their `MutableState` type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Row()` receives a parameter called `modifier`. Modifiers are a key technique
    in Jetpack Compose to influence both the look and behavior of composable functions.
    I will explain them in greater detail in [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`padding(top = 8.dp)` means that the row will have a padding of eight density-independent
    pixels (`.dp`) at its upper side, thus separating itself from the welcome message
    above it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will look at the text input field, which allows the user to enter a
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`TextField()` belongs to the `androidx.compose.material` package. The composable
    can receive quite a few arguments; most of them are optional, though. Please note
    that the previous code fragment uses both the `name` and `nameEntered` parameters,
    which are passed to `TextAndButton()`. Their type is `MutableState`. `MutableState`
    objects carry changeable values, which you access as `name.value` or `nameEntered.value`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `value` parameter of a `TextField()` composable receives the current value
    of the text input field, for example, text that has already been input. `onValueChange`
    is invoked when changes to the text occur (if the user enters or deletes something).
    But why is `name.value` used in both places? I will answer this question in the
    *Showing a greeting message* section.
  prefs: []
  type: TYPE_NORMAL
- en: Recomposition
  prefs: []
  type: TYPE_NORMAL
- en: Certain types trigger a so-called recomposition. For now, think of this as repainting
    an associated composable. `MutableState` is such a type. If we change its value,
    the `TextField()` composable is redrawn or repainted. Please note that both terms
    are not entirely correct. We will cover recomposition in [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly look at the remaining code. With `alignByBaseline()`, we can nicely
    align the baselines of other composable functions in a particular `Row()`. `placeholder`
    contains the text that is shown until the user has entered something. `singleLine`
    controls whether the user can enter multiple lines of text. Finally, `keyboardOptions`
    and `keyboardActions` describe the behavior of the onscreen keyboard. For example,
    certain actions will set `nameEntered.value` to `true`. I will show you soon why
    we do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we need to take a look at the `Button()` composable first. It also
    belongs to the `androidx.compose.material` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Some things will already look familiar. For example, we call `alignByBaseline()`
    to align the baseline of the button with the text input field, and we apply a
    padding of eight density-independent pixels to all sides of the button using `padding()`.
    Now, `onClick()` specifies what to do when the button is clicked. Here, too, we
    set `nameEntered.value` to `true`. The next composable function, `Hello()`, finally
    shows you why this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Showing a greeting message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Hello()` emits `Box()`, which (depending on `nameEntered.value`) contains
    either the `Greeting()` or a `Column()` composable that, in turn, includes `Welcome()`
    and `TextAndButton()`. The `Column()` composable is quite similar to `Row()` but
    arranges its siblings vertically. Like the latter one and `Box()`, it belongs
    to the `androidx.compose.foundation.layout` package. `Box()` can contain one or
    more children. They are positioned inside the box according to the `contentAlignment`
    parameter. We will be exploring this in greater detail in the *Combining basic
    building blocks* section of [*Chapter 4*](B17505_04_ePub.xhtml#_idTextAnchor076),
    *Laying Out UI Elements*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you noticed `remember` and `mutableStateOf`? Both are very important for
    creating and maintaining state. Generally speaking, state in an app refers to
    a value that can change over time. While this also applies to domain data (for
    example, the result of a web service call), state usually refers to something
    being displayed or used by a UI element. If a composable function has (or relies
    on) state, it is recomposed (for now, repainted or redrawn) when that state changes.
    To get an idea of what this means, recall this composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Welcome()` is said to be stateless; all values that might trigger a recomposition
    remain the same for the time being. `Hello()`, on the other hand, is stateful,
    because it uses the `name` and `nameEntered` variables. They change over time.
    This may not be obvious if you look at the source code of `Hello()`. Please recall
    that both `name` and `nameEntered` are passed to `TextAndButton()` and modified
    there.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you recall that in the previous section I promised to explain why `name.value`
    is used in two places, providing the text to display and receiving changes after
    the user has entered something? This is a common pattern often used with states;
    `Hello()` creates and remembers state by invoking `mutableStateOf()` and `remember`.
    And it passes state to another composable (`TextAndButton()`), which is called
    **state hoisting**. You will learn more about this in [*Chapter 5*](B17505_05_ePub.xhtml#_idTextAnchor089),
    *Managing the State of Your Composable Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have seen the source code of quite a few composable functions but
    not their output. Android Studio has a very important feature called **Compose
    preview**. It allows you to view a composable function without running the app.
    In the next section, I will show you how to use this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Using the preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The upper-right corner of the Android Studio code editor contains three buttons,
    **Code**, **Split**, and **Design** (*Figure 1.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Compose preview (Split mode)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Compose preview (Split mode)
  prefs: []
  type: TYPE_NORMAL
- en: 'They switch between the following different display modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Code only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code and preview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the Compose preview, your composable functions must contain an additional
    annotation, `@Preview`, which belongs to the `androidx.compose.ui.tooling.preview`
    package. This requires an implementation dependency to `androidx.compose.ui:ui-tooling-preview`
    in your `build.gradle` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, if you try to add `@Preview` to `Greeting()`, you will see an
    error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, how can you preview composables that take parameters?
  prefs: []
  type: TYPE_NORMAL
- en: Preview parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most obvious solution is a wrapper composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This means that you write another composable function that takes no parameters
    but invokes your existing one and provides the required parameter (in my example,
    a text). Depending on how many composable functions your source file contains,
    you might be creating quite a lot of boilerplate code. The wrappers don't add
    value besides enabling the preview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there are other options. You can, for example, add default values
    to your composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While this looks less hacky, it alters how your composable functions can be
    invoked (that is, without passing a parameter). This may not be desirable if you
    had a reason for not defining a default value in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `@PreviewParameter`, you can pass values to a composable that affect only
    the preview. Unfortunately, this is a little verbose, though, because you need
    to write a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The class must extend `androidx.compose.ui.tooling.preview.PreviewParameterProvider`
    because it will provide a parameter for the preview. Now, you can annotate the
    parameter of the composable with `@PreviewParameter` and pass your new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In a way, you are creating boilerplate code, too. So, which method you choose
    in the end is a matter of personal taste. The `@Preview` annotation can receive
    quite a few parameters. They modify the visual appearance of the preview. Let's
    explore some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring previews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set a background color for a preview using `backgroundColor =`. The
    value is a `Long` type and represents an ARGB color. Please make sure to also
    set `showBackground` to `true`. The following snippet will produce a solid red
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, preview dimensions are chosen automatically. If you want to set
    them explicitly, you can pass `heightDp` and `widthDp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 1.3* shows the result. Both values are interpreted as density-independent
    pixels, so you don''t need to add `.dp` as you would do inside your composable
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Setting the width and height of a preview'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Setting the width and height of a preview
  prefs: []
  type: TYPE_NORMAL
- en: 'To test different user locales, you can add the `locale` parameter. If, for
    example, your app contains German strings inside `values-de-rDE`, you can use
    them by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The string matches the directory name after `values-`. Please recall that the
    directory is created by Android Studio if you add a language in the Translations
    Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to display the status and action bars, you can achieve this with
    `showSystemUi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To get an idea of how your composables react to different form factors, aspect
    ratios, and pixel densities, you can utilize the `device` parameter. It takes
    a string. Pass one of the values from `Devices`, for example, `Devices.PIXEL_C`
    or `Devices.AUTOMOTIVE_1024p`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have seen how to configure a preview. Next, I will introduce
    you to preview groups. They are very handy if your source code file contains more
    than a few composable functions that you want to preview.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping previews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android Studio shows composable functions with a `@Preview` annotation in the
    order of their appearance in the source code. You can choose between **Vertical
    Layout** and **Grid Layout** (*Figure 1.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Switching between Vertical Layout and Grid Layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Switching between Vertical Layout and Grid Layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the number of your composables, the preview pane may at some point
    feel crowded. If this is the case, just put your composables into different groups
    by adding a `group` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then show either all composable functions or just those that belong
    to a particular group (*Figure 1.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Switching between groups'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Switching between groups
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, I have shown you what the source code of composable functions looks
    like and how you can preview them inside Android Studio. In the next section,
    we will execute a composable on the Android Emulator or a real device, and you
    will learn how to connect composable functions to the other parts of an app. But
    before that, here is one more tip:'
  prefs: []
  type: TYPE_NORMAL
- en: Export a Preview as an Image
  prefs: []
  type: TYPE_NORMAL
- en: If you click on a Compose preview with the secondary mouse button, you will
    see a small pop-up menu. Select **Copy Image** to put a bitmap of the preview
    on the system clipboard. Most graphics applications allow you to paste it into
    a new document.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Compose app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to see how a composable function looks and feels on the Android
    Emulator or a real device, you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a composable function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is useful if you want to focus on a particular composable rather
    than the whole app. Also, the time needed to deploy a composable may be significantly
    shorter than deploying a complete app (depending on the app size). So, let's start
    with this one.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a composable function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To deploy a composable function to a real device or the Android Emulator, click
    on the **Deploy Preview** button, which is a small image in the upper-right corner
    of a preview (*Figure 1.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Deploying a composable function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – Deploying a composable function
  prefs: []
  type: TYPE_NORMAL
- en: 'This will automatically create new launch configurations (*Figure 1.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Launch configurations representing Compose previews'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Launch configurations representing Compose previews
  prefs: []
  type: TYPE_NORMAL
- en: You can modify or delete Compose preview configurations in the **Run/Debug Configurations**
    dialog. To access them, open the **Compose Preview** node. Then you can, for example,
    change its name or deny parallel runs by unchecking **Allow parallel run**.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to deploy and run your first Compose app on a real
    device or the Android Emulator. You are almost there; in the next section, I will
    show you how to embed composable functions in an activity, which is a prerequisite.
    You will finally be running the app in the *Pressing the play button* section.
  prefs: []
  type: TYPE_NORMAL
- en: Using composable functions in activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Activities** have been one of the basic building blocks of Android apps since
    the first platform version. Practically every app has at least one activity. They
    are configured in the manifest file. To launch an activity from the home screen,
    the corresponding entry looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still true for Compose apps. An activity that wishes to show composable
    functions is set up just like one that inflates a traditional layout file. But
    what does its source code look like? The main activity of the `Hello` app is called
    `MainActivity`, shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very short. The UI (the `Hello()` composable function)
    is displayed by invoking a function called `setContent`, which is an extension
    function to `androidx.activity.ComponentActivity` and belongs to the `androidx.activity.compose`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: To render composables, your activity must extend either `ComponentActivity`
    or another class that has `ComponentActivity` as its direct or indirect ancestor.
    This is the case for `androidx.fragment.app.FragmentActivity` and `androidx.appcompat.app.AppCompatActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an important difference; while Compose apps invoke `setContent()`,
    View-based apps call `setContentView()` and pass either the ID of a layout (`R.layout.``activity_main`)
    or the root view itself (which is usually obtained through some binding mechanism).
    Let''s see how the older mechanism works. The following code snippet is taken
    from one of my open source apps (you can find it on GitHub at [https://github.com/MATHEMA-GmbH/TKWeek](https://github.com/MATHEMA-GmbH/TKWeek)
    but it won''t be discussed any further in this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you compare both approaches, a striking difference is that with Jetpack Compose,
    there is no need for maintaining references to the UI component tree or individual
    elements of it. I will explain in [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040),
    *Understanding the Declarative Paradigm*, why this leads to code that is easily
    maintainable and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now return to `setContent()`. It receives two parameters, a `parent` (which
    can be `null`) and the `content` (the UI). The `parent` is an instance of `androidx.compose.runtime.CompositionContext`.
    It is used to logically link together two compositions. This is an advanced topic
    that I will be discussing in [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed that `MainActivity` does not contain any composable functions?
    They do not need to be part of a class. In fact, you should implement them as
    top-level functions whenever possible. Jetpack Compose provides alternative means
    to access `android.content.Context`. You have already seen the `stringResource()`
    composable function, which is a replacement for `getString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen how to embed composable functions in activities, it is
    time to look at the structure of Jetpack Compose-based projects. While Android
    Studio sets everything up for you if you create a Compose app using the project
    wizard, it is important to know which files are involved under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Looking under the hood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jetpack Compose heavily relies on Kotlin. This means that your app project must
    be configured to use Kotlin. It does not imply, though, that you cannot use Java
    at all. In fact, you can easily mix Kotlin and Java in your project, as long as
    your composable functions are written in Kotlin. You can also combine traditional
    views and composables. I will be discussing this topic in [*Chapter 9*](B17505_09_ePub.xhtml#_idTextAnchor148),
    *Exploring Interoperability APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure to configure the Android Gradle plugin that corresponds to
    your version of Android Studio in the project-level build.gradle file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippets belong in the module-level build.gradle file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, please make sure that your app''s minimum API level is set to 21 or higher
    and that Jetpack Compose is enabled. The following code snippet also sets the
    version for the Kotlin compiler plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, declare dependencies. The following code snippet acts as a good starting
    point. Depending on which packages your app uses, you may need additional ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once you have configured your project, building and running a Compose app works
    just like traditional view-based apps.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the play button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run your Compose app, select your target device, make sure that the **app**
    module is selected, and press the green *play* button (*Figure 1.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Android Studio toolbar elements to launch an app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17505_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Android Studio toolbar elements to launch an app
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Well done. You have now launched your first Compose app, and
    you have achieved quite a lot. Let's recap.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to write our first composables: Kotlin functions
    that have been annotated with `@Composable`. Composable functions are the core
    building blocks of Jetpack Compose-based UIs. You combined existing library composables
    with your own to create beautiful app screens. To see a preview, we can add the
    `@Preview` annotation. To use Jetpack Compose in a project, both `build.gradle`
    files must be configured accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040), *Understanding the
    Declarative Paradigm*, we will take a closer look at the differences between the
    declarative approach of Jetpack Compose and the imperative nature of traditional
    UI frameworks such as Android's view-based component library.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book assumes you have a basic understanding of the syntax of Kotlin and
    Android development in general. If you would like to learn more about this, I
    suggest looking at *Android Programming with Kotlin for Beginners*, *John Horton*,
    *Packt Publishing*, *2019*, *ISBN 9781789615401*.
  prefs: []
  type: TYPE_NORMAL
