- en: 'Chapter 1: Building Your First Compose App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：构建你的第一个Compose应用
- en: When Android was introduced more than 10 years ago, it quickly gained popularity
    among developers because it was incredibly easy to write apps. All you had to
    do was define the user interface (UI) in an XML file and connect it to your *activity*.
    This worked flawlessly because apps were small and developers needed to support
    just a handful of devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当安卓系统在10多年前推出时，它迅速在开发者中获得了人气，因为它编写应用极其简单。你只需在XML文件中定义用户界面（UI）并将其连接到你的*activity*即可。这工作得非常完美，因为应用体积小，开发者只需要支持少数几款设备。
- en: So much has changed since then.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自那以后，发生了许多变化。
- en: With every new platform version, Android gained new features. Through the years,
    device manufacturers introduced thousands of devices with different screen sizes,
    pixel densities, and form factors. While Google did its best to keep the Android
    *view* system comprehendible, the complexity of apps increased significantly;
    basic tasks such as implementing scrolling lists or animations require lots of
    boilerplate code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每当新的平台版本推出时，安卓都会获得新的功能。经过多年，设备制造商推出了数千款具有不同屏幕尺寸、像素密度和形态的设备。虽然谷歌尽力保持安卓*视图*系统的可理解性，但应用的复杂性显著增加；基本任务，如实现滚动列表或动画，需要大量的模板代码。
- en: It turned out that these problems were not specific to Android. Other platforms
    and operating systems faced them as well. Most issues stem from how UI toolkits
    used to work; they follow a so-called **imperative approach** (which I will explain
    in [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040), *Understanding the Declarative
    Paradigm*). The solution was a paradigm shift. The web framework React was the
    first to popularize a declarative approach. Other platforms and frameworks (for
    example, Flutter and SwiftUI) followed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这些问题并不仅限于安卓。其他平台和操作系统也面临着这些问题。大多数问题源于UI工具包过去的工作方式；它们遵循所谓的**命令式方法**（我将在[*第二章*](B17505_02_ePub.xhtml#_idTextAnchor040)，*理解声明式范式*中解释）。解决方案是一个范式转变。Web框架React是第一个普及声明式方法的应用。其他平台和框架（例如Flutter和SwiftUI）随后效仿。
- en: '**Jetpack Compose** is Google''s declarative UI framework for Android. It dramatically
    simplifies the creation of UIs. As you will surely agree after reading this book,
    using Jetpack Compose is both easy and fun. But before we dive in, please note
    that Jetpack Compose is Kotlin-only. This means that all your Compose code will
    have to be written in Kotlin. To follow this book, you should have a basic understanding
    of the Kotlin syntax and the functional programming model. If you want to learn
    more about these topics, please refer to the *Further reading* section at the
    end of this chapter.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jetpack Compose**是谷歌为安卓提供的声明式UI框架。它极大地简化了UI的创建。在阅读完这本书后，你一定会同意使用Jetpack Compose既简单又有趣。但在我们深入之前，请注意Jetpack
    Compose仅支持Kotlin。这意味着你所有的Compose代码都必须用Kotlin编写。为了跟随这本书，你应该对Kotlin语法和函数式编程模型有基本的了解。如果你想要了解更多关于这些主题的内容，请参考本章末尾的*进一步阅读*部分。'
- en: 'This chapter covers three main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了三个主要主题：
- en: Saying hello to composable functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向可组合函数问好
- en: Using the preview
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预览功能
- en: Running a Compose app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Compose应用
- en: I will explain how to build a simple UI with Jetpack Compose. Next, you will
    learn to use the **preview** feature in Android Studio and how to run a Compose
    app. By the end of this chapter, you will have a basic understanding of how composable
    functions work, how they are integrated into your app, and how your project must
    be configured in order to use Jetpack Compose.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将解释如何使用Jetpack Compose构建一个简单的UI。接下来，你将学习如何在Android Studio中使用**预览**功能以及如何运行一个Compose应用。在本章结束时，你将基本了解可组合函数的工作方式、它们如何集成到你的应用中以及你的项目必须如何配置才能使用Jetpack
    Compose。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01).
    Please download the zipped version or clone the repository to an arbitrary location
    on your computer. The projects require at least Android Studio Arctic Fox. You
    can download the latest version at [https://developer.android.com/studio](https://developer.android.com/studio).
    Please follow the detailed installation instructions at [https://developer.android.com/studio/install](https://developer.android.com/studio/install).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_01)。请下载压缩版本或克隆存储库到您计算机上的任意位置。项目至少需要
    Android Studio Arctic Fox。您可以在 [https://developer.android.com/studio](https://developer.android.com/studio)
    下载最新版本。请按照 [https://developer.android.com/studio/install](https://developer.android.com/studio/install)
    上的详细安装说明进行操作。
- en: To open this book's project, launch Android Studio, click the **Open** button
    in the upper-right area of the **Welcome to Android Studio** window, and select
    the base directory of the project in the folder selection dialog. Please make
    sure to not open the base directory of the repository, because Android Studio
    would not recognize the projects. Instead, you must pick the directory that contains
    the project you want to work with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开本书的项目，启动 Android Studio，在“欢迎使用 Android Studio”窗口右上角点击**打开**按钮，并在文件夹选择对话框中选择项目的基目录。请确保不要打开存储库的基目录，因为
    Android Studio 不会识别项目。相反，您必须选择包含您想要工作的项目的目录。
- en: To run a sample app, you need a real device or the Android Emulator. Please
    make sure that developer options and USB debugging are enabled on the real device,
    and that the device is connected to your development machine via USB or WLAN.
    Please follow the instructions at [https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options).
    You can also set up the Android Emulator. You can find detailed instructions at
    [https://developer.android.com/studio/run/emulator](https://developer.android.com/studio/run/emulator).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例应用程序，您需要一个真实设备或 Android 模拟器。请确保在真实设备上启用了开发者选项和 USB 调试，并且设备通过 USB 或 WLAN
    连接到您的开发机器。请按照 [https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options)
    上的说明操作。您还可以设置 Android 模拟器。您可以在 [https://developer.android.com/studio/run/emulator](https://developer.android.com/studio/run/emulator)
    找到详细说明。
- en: Saying hello to composable functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向可组合函数问好
- en: As you will see shortly, composable functions are the essential building blocks
    of Compose apps; these elements make up the UI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您很快就会看到的，可组合函数是 Compose 应用程序的基本构建块；这些元素构成了用户界面。
- en: 'To take a first look at them, I will walk you through a simple app called `chapter_01`.
    Otherwise, please do so now. To follow this section, open the project in Android
    Studio and open `MainActivity.kt`. The use case of our first Compose app is very
    simple. After you have entered your name and clicked on the **Done** button, you
    will see a greeting message:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要初步了解它们，我将带您浏览一个名为 `chapter_01` 的简单应用程序。否则，请现在就这样做。要跟随本节内容，请在 Android Studio
    中打开项目并打开 `MainActivity.kt`。我们的第一个 Compose 应用程序的使用场景非常简单。在您输入您的名字并点击**完成**按钮后，您将看到一个问候信息：
- en: '![Figure 1.1 – The Hello app'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – Hello 应用程序'
- en: '](img/B17505_01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17505_01_01.jpg](img/B17505_01_01.jpg)'
- en: Figure 1.1 – The Hello app
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Hello 应用程序
- en: 'Conceptually, the app consists of the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，应用程序由以下内容组成：
- en: The welcome text
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎文本
- en: A row with an `EditText` equivalent and a button
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 `EditText` 等效元素和按钮
- en: A greeting message
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条问候信息
- en: Let's take a look at how to create the app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建应用程序。
- en: Showing a welcome text
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示欢迎文本
- en: 'Let''s start with the welcome text, our first composable function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从欢迎文本开始，这是我们的第一个可组合函数：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Composable functions can be easily identified by the `@Composable` annotation.
    They do not need to have a particular return type but instead emit UI elements.
    This is usually done by invoking other composables (for the sake of brevity, I
    will sometimes omit the word "function"). [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*, will cover this in greater detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合函数可以通过 `@Composable` 注解轻松识别。它们不需要有特定的返回类型，而是发出 UI 元素。这通常是通过调用其他可组合函数（为了简洁起见，我有时会省略“函数”一词）来完成的。[第
    3 章](B17505_03_ePub.xhtml#_idTextAnchor054)，*探索 Compose 的关键原则*，将更详细地介绍这一点。
- en: In this example, `Welcome()` summons a text. `Text()` is a built-in composable
    function and belongs to the `androidx.compose.material` package.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Welcome()` 调用一个文本。`Text()` 是一个内置的可组合函数，属于 `androidx.compose.material`
    包。
- en: 'To invoke `Text()` just by its name, you need to import it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅通过其名称调用 `Text()`，您需要导入它：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please note that you can save `import` lines by using the `*` wildcard.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用 `*` 通配符来保存 `import` 行。
- en: To use `Text()` and other Material Design elements, your `build.gradle` file
    must include an implementation dependency to `androidx.compose.material:material`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Text()` 和其他 Material Design 元素，您的 `build.gradle` 文件必须包含对 `androidx.compose.material:material`
    的实现依赖项。
- en: Looking back at the welcome text code, the `Text()` composable inside `Welcome()`
    is configured through two parameters, `text` and `style`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾欢迎文本代码，`Welcome()` 中的 `Text()` 可组合函数通过两个参数 `text` 和 `style` 进行配置。
- en: The first, `text`, specifies what text will be displayed. `R.string` may look
    familiar; it refers to definitions inside the `strings.xml` files. Just like in
    view-based apps, you define text for UI elements there. `stringResource()` is
    a predefined composable function. It belongs to the `androidx.compose.ui.res`
    package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`text`，指定将显示什么文本。`R.string` 可能看起来很熟悉；它指的是 `strings.xml` 文件中的定义。就像在基于视图的应用程序中一样，您在那里为
    UI 元素定义文本。`stringResource()` 是一个预定义的可组合函数。它属于 `androidx.compose.ui.res` 包。
- en: The `style` parameter modifies the visual appearance of a text. In this case,
    the output will look like a subtitle. I will show you how to create your own themes
    in [*Chapter 6*](B17505_06_ePub.xhtml#_idTextAnchor105), *Putting Pieces Together*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 参数修改文本的视觉外观。在这种情况下，输出将看起来像副标题。我将在 [*第 6 章*](B17505_06_ePub.xhtml#_idTextAnchor105)，*将部件组合在一起*
    中向您展示如何创建自己的主题。'
- en: The next composable looks quite similar. Can you spot the differences?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个可组合函数看起来相当相似。你能找到它们之间的区别吗？
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `stringResource()` receives an additional parameter. This is very convenient
    for replacing placeholders with actual texts. The string is defined in `strings.xml`,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`stringResource()` 接收一个额外的参数。这对于用实际文本替换占位符非常方便。字符串在 `strings.xml` 中定义，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `textAlign` parameter specifies how text is positioned horizontally. Here,
    each line is centered.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`textAlign` 参数指定文本如何水平定位。在这里，每一行都是居中的。'
- en: Using rows, text fields, and buttons
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用行、文本字段和按钮
- en: 'Next, let''s turn to the text input field (`Row()`, which belongs to the `androidx.compose.foundation.layout`
    package. Just like all composable functions, `Row()` can receive a comma-separated
    list of parameters inside `( )` and its children are put inside curly braces:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转向文本输入字段（`Row()`，它属于 `androidx.compose.foundation.layout` 包。就像所有可组合函数一样，`Row()`
    可以在括号内接收一个逗号分隔的参数列表，其子项放在花括号内：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`TextAndButton()` requires two parameters, `name` and `nameEntered`. You will
    see what they are used for in the *Showing a greeting message* section. For now,
    please ignore their `MutableState` type.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextAndButton()` 需要两个参数，`name` 和 `nameEntered`。您将在 *显示问候消息* 部分看到它们是如何使用的。现在，请忽略它们的
    `MutableState` 类型。'
- en: '`Row()` receives a parameter called `modifier`. Modifiers are a key technique
    in Jetpack Compose to influence both the look and behavior of composable functions.
    I will explain them in greater detail in [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row()` 接收一个名为 `modifier` 的参数。修饰符是 Jetpack Compose 中影响可组合函数外观和行为的关键技术。我将在 [*第
    3 章*](B17505_03_ePub.xhtml#_idTextAnchor054)，*探索 Compose 的关键原则* 中更详细地解释它们。'
- en: '`padding(top = 8.dp)` means that the row will have a padding of eight density-independent
    pixels (`.dp`) at its upper side, thus separating itself from the welcome message
    above it.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`padding(top = 8.dp)` 表示该行在其顶部将有一个八密度无关像素（`.dp`）的填充，从而使其与上面的欢迎信息隔开。'
- en: 'Now, we will look at the text input field, which allows the user to enter a
    name:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看文本输入字段，它允许用户输入一个名字：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`TextField()` belongs to the `androidx.compose.material` package. The composable
    can receive quite a few arguments; most of them are optional, though. Please note
    that the previous code fragment uses both the `name` and `nameEntered` parameters,
    which are passed to `TextAndButton()`. Their type is `MutableState`. `MutableState`
    objects carry changeable values, which you access as `name.value` or `nameEntered.value`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextField()` 属于 `androidx.compose.material` 包。该可组合函数可以接收相当多的参数；尽管大多数是可选的。请注意，前面的代码片段同时使用了
    `name` 和 `nameEntered` 参数，这些参数传递给了 `TextAndButton()`。它们的类型是 `MutableState`。`MutableState`
    对象携带可变值，您可以通过 `name.value` 或 `nameEntered.value` 访问它们。'
- en: The `value` parameter of a `TextField()` composable receives the current value
    of the text input field, for example, text that has already been input. `onValueChange`
    is invoked when changes to the text occur (if the user enters or deletes something).
    But why is `name.value` used in both places? I will answer this question in the
    *Showing a greeting message* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextField()` 可组合组件的 `value` 参数接收文本输入字段的当前值，例如，已经输入的文字。当文本发生变化时（如果用户输入或删除了某些内容），会调用
    `onValueChange`。但为什么两个地方都使用了 `name.value`？我将在 *显示问候消息* 部分回答这个问题。'
- en: Recomposition
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重组
- en: Certain types trigger a so-called recomposition. For now, think of this as repainting
    an associated composable. `MutableState` is such a type. If we change its value,
    the `TextField()` composable is redrawn or repainted. Please note that both terms
    are not entirely correct. We will cover recomposition in [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类型会触发所谓的重组。现在，你可以将这想象成重新绘制一个相关的可组合组件。`MutableState` 就是这样一种类型。如果我们改变它的值，`TextField()`
    可组合组件就会被重新绘制或重绘。请注意，这两个术语并不完全准确。我们将在 [*第3章*](B17505_03_ePub.xhtml#_idTextAnchor054)
    中介绍重组，*探索 Compose 的关键原则*。
- en: Let's briefly look at the remaining code. With `alignByBaseline()`, we can nicely
    align the baselines of other composable functions in a particular `Row()`. `placeholder`
    contains the text that is shown until the user has entered something. `singleLine`
    controls whether the user can enter multiple lines of text. Finally, `keyboardOptions`
    and `keyboardActions` describe the behavior of the onscreen keyboard. For example,
    certain actions will set `nameEntered.value` to `true`. I will show you soon why
    we do this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看剩余的代码。使用 `alignByBaseline()`，我们可以很好地对齐特定 `Row()` 中的其他可组合函数的基线。`placeholder`
    包含用户输入内容之前的文本。`singleLine` 控制用户是否可以输入多行文本。最后，`keyboardOptions` 和 `keyboardActions`
    描述了屏幕键盘的行为。例如，某些操作会将 `nameEntered.value` 设置为 `true`。我很快就会向你展示我们为什么要这样做。
- en: 'However, we need to take a look at the `Button()` composable first. It also
    belongs to the `androidx.compose.material` package:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们首先需要看看 `Button()` 可组合组件。它也属于 `androidx.compose.material` 包：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Some things will already look familiar. For example, we call `alignByBaseline()`
    to align the baseline of the button with the text input field, and we apply a
    padding of eight density-independent pixels to all sides of the button using `padding()`.
    Now, `onClick()` specifies what to do when the button is clicked. Here, too, we
    set `nameEntered.value` to `true`. The next composable function, `Hello()`, finally
    shows you why this is done.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些东西看起来可能已经熟悉了。例如，我们调用 `alignByBaseline()` 来对齐按钮的基线与文本输入字段，并使用 `padding()` 在按钮的四周应用八个密度无关像素的填充。现在，`onClick()`
    指定了按钮被点击时要执行的操作。在这里，我们也设置了 `nameEntered.value` 为 `true`。下一个可组合函数 `Hello()` 最终会向你展示为什么要这样做。
- en: Showing a greeting message
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示问候消息
- en: '`Hello()` emits `Box()`, which (depending on `nameEntered.value`) contains
    either the `Greeting()` or a `Column()` composable that, in turn, includes `Welcome()`
    and `TextAndButton()`. The `Column()` composable is quite similar to `Row()` but
    arranges its siblings vertically. Like the latter one and `Box()`, it belongs
    to the `androidx.compose.foundation.layout` package. `Box()` can contain one or
    more children. They are positioned inside the box according to the `contentAlignment`
    parameter. We will be exploring this in greater detail in the *Combining basic
    building blocks* section of [*Chapter 4*](B17505_04_ePub.xhtml#_idTextAnchor076),
    *Laying Out UI Elements*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello()` 发射 `Box()`，它（根据 `nameEntered.value`）包含 `Greeting()` 或一个包含 `Welcome()`
    和 `TextAndButton()` 的 `Column()` 可组合组件。`Column()` 可组合组件与 `Row()` 很相似，但垂直排列其兄弟组件。像后者和
    `Box()` 一样，它属于 `androidx.compose.foundation.layout` 包。`Box()` 可以包含一个或多个子组件。它们根据
    `contentAlignment` 参数在盒内定位。我们将在 [*第4章*](B17505_04_ePub.xhtml#_idTextAnchor076)
    的 *组合基本构建块* 部分更详细地探讨这一点，*布局 UI 元素*：'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Have you noticed `remember` and `mutableStateOf`? Both are very important for
    creating and maintaining state. Generally speaking, state in an app refers to
    a value that can change over time. While this also applies to domain data (for
    example, the result of a web service call), state usually refers to something
    being displayed or used by a UI element. If a composable function has (or relies
    on) state, it is recomposed (for now, repainted or redrawn) when that state changes.
    To get an idea of what this means, recall this composable:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到 `remember` 和 `mutableStateOf` 吗？它们对于创建和维护状态都非常重要。一般来说，应用中的状态指的是随时间可能发生变化的值。虽然这也适用于领域数据（例如，网络服务调用的结果），但状态通常指的是由
    UI 元素显示或使用的某些内容。如果一个可组合函数（或依赖于）状态，当该状态发生变化时，它将重新组合（目前，重新绘制或重新绘制）。为了理解这意味着什么，请回忆这个可组合组件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Welcome()` is said to be stateless; all values that might trigger a recomposition
    remain the same for the time being. `Hello()`, on the other hand, is stateful,
    because it uses the `name` and `nameEntered` variables. They change over time.
    This may not be obvious if you look at the source code of `Hello()`. Please recall
    that both `name` and `nameEntered` are passed to `TextAndButton()` and modified
    there.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Welcome()` 被称为无状态；所有可能触发重新组合的值在目前都保持不变。另一方面，`Hello()` 是有状态的，因为它使用了 `name`
    和 `nameEntered` 变量。这些变量会随时间变化。如果你查看 `Hello()` 的源代码，这可能并不明显。请记住，`name` 和 `nameEntered`
    都被传递给了 `TextAndButton()` 并在那里进行了修改。'
- en: Do you recall that in the previous section I promised to explain why `name.value`
    is used in two places, providing the text to display and receiving changes after
    the user has entered something? This is a common pattern often used with states;
    `Hello()` creates and remembers state by invoking `mutableStateOf()` and `remember`.
    And it passes state to another composable (`TextAndButton()`), which is called
    **state hoisting**. You will learn more about this in [*Chapter 5*](B17505_05_ePub.xhtml#_idTextAnchor089),
    *Managing the State of Your Composable Functions*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在上一节中我承诺解释为什么在两个地方使用了 `name.value`，提供要显示的文本并在用户输入某些内容后接收变化吗？这是一个常见的模式，通常与状态一起使用；`Hello()`
    通过调用 `mutableStateOf()` 和 `remember` 来创建和记住状态，并将状态传递给另一个可组合组件（`TextAndButton()`），这被称为**状态提升**。你将在[*第五章*](B17505_05_ePub.xhtml#_idTextAnchor089)中了解更多关于*管理你的可组合函数的状态*。
- en: So far, you have seen the source code of quite a few composable functions but
    not their output. Android Studio has a very important feature called **Compose
    preview**. It allows you to view a composable function without running the app.
    In the next section, I will show you how to use this feature.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了很多可组合函数的源代码，但还没有看到它们的输出。Android Studio 有一个非常重要的功能，称为**Compose 预览**。它允许你在不运行应用的情况下查看可组合函数。在下一节中，我将向你展示如何使用这个功能。
- en: Using the preview
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预览
- en: 'The upper-right corner of the Android Studio code editor contains three buttons,
    **Code**, **Split**, and **Design** (*Figure 1.2*):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 代码编辑器的右上角有三个按钮，**代码**、**分割**和**设计**（*图 1.2*）：
- en: '![Figure 1.2 – Compose preview (Split mode)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – Compose 预览（分割模式）'
- en: '](img/B17505_01_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_01_02.jpg)'
- en: Figure 1.2 – Compose preview (Split mode)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Compose 预览（分割模式）
- en: 'They switch between the following different display modes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它们会在以下不同的显示模式之间切换：
- en: Code only
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅代码
- en: Code and preview
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码和预览
- en: Preview only
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅预览
- en: To use the Compose preview, your composable functions must contain an additional
    annotation, `@Preview`, which belongs to the `androidx.compose.ui.tooling.preview`
    package. This requires an implementation dependency to `androidx.compose.ui:ui-tooling-preview`
    in your `build.gradle` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Compose 预览，你的可组合函数必须包含一个额外的注解，`@Preview`，它属于 `androidx.compose.ui.tooling.preview`
    包。这需要在你的 `build.gradle` 文件中实现依赖 `androidx.compose.ui:ui-tooling-preview`。
- en: 'Unfortunately, if you try to add `@Preview` to `Greeting()`, you will see an
    error message like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你尝试将 `@Preview` 添加到 `Greeting()` 中，你会看到一个类似这样的错误信息：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, how can you preview composables that take parameters?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何预览接受参数的可组合组件呢？
- en: Preview parameters
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预览参数
- en: 'The most obvious solution is a wrapper composable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的解决方案是一个包装可组合组件：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This means that you write another composable function that takes no parameters
    but invokes your existing one and provides the required parameter (in my example,
    a text). Depending on how many composable functions your source file contains,
    you might be creating quite a lot of boilerplate code. The wrappers don't add
    value besides enabling the preview.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您编写了另一个不接收任何参数但调用现有函数并提供所需参数（在我的例子中是文本）的复合函数。根据您的源文件中包含的复合函数数量，您可能需要创建相当多的样板代码。这些包装器除了启用预览外，没有增加任何价值。
- en: 'Fortunately, there are other options. You can, for example, add default values
    to your composable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有其他选项。例如，您可以为您的复合函数添加默认值：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While this looks less hacky, it alters how your composable functions can be
    invoked (that is, without passing a parameter). This may not be desirable if you
    had a reason for not defining a default value in the first place.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做看起来不那么复杂，但它改变了调用复合函数的方式（即，不传递参数）。如果您最初没有定义默认值的原因，这可能不是您想要的。
- en: 'With `@PreviewParameter`, you can pass values to a composable that affect only
    the preview. Unfortunately, this is a little verbose, though, because you need
    to write a new class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@PreviewParameter`，您可以传递仅影响预览的值。不幸的是，这有点冗长，因为您需要编写一个新的类：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The class must extend `androidx.compose.ui.tooling.preview.PreviewParameterProvider`
    because it will provide a parameter for the preview. Now, you can annotate the
    parameter of the composable with `@PreviewParameter` and pass your new class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该类必须扩展 `androidx.compose.ui.tooling.preview.PreviewParameterProvider`，因为它将为预览提供参数。现在，您可以使用
    `@PreviewParameter` 注解复合函数的参数并传递您的新类：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In a way, you are creating boilerplate code, too. So, which method you choose
    in the end is a matter of personal taste. The `@Preview` annotation can receive
    quite a few parameters. They modify the visual appearance of the preview. Let's
    explore some of them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，您也在创建样板代码。因此，您最终选择哪种方法取决于个人喜好。`@Preview` 注解可以接收相当多的参数。它们修改预览的视觉外观。让我们探索其中的一些。
- en: Configuring previews
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置预览
- en: 'You can set a background color for a preview using `backgroundColor =`. The
    value is a `Long` type and represents an ARGB color. Please make sure to also
    set `showBackground` to `true`. The following snippet will produce a solid red
    background:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `backgroundColor =` 为预览设置背景颜色。该值是 `Long` 类型，表示 ARGB 颜色。请确保也将 `showBackground`
    设置为 `true`。以下代码片段将生成纯红色背景：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By default, preview dimensions are chosen automatically. If you want to set
    them explicitly, you can pass `heightDp` and `widthDp`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，预览维度是自动选择的。如果您想显式设置它们，可以传递 `heightDp` 和 `widthDp`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Figure 1.3* shows the result. Both values are interpreted as density-independent
    pixels, so you don''t need to add `.dp` as you would do inside your composable
    function.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.3* 展示了结果。两个值都被解释为密度无关像素，因此您不需要像在复合函数内部那样添加 `.dp`。'
- en: '![Figure 1.3 – Setting the width and height of a preview'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 设置预览的宽度和高度'
- en: '](img/B17505_01_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_01_03.jpg)'
- en: Figure 1.3 – Setting the width and height of a preview
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 设置预览的宽度和高度
- en: 'To test different user locales, you can add the `locale` parameter. If, for
    example, your app contains German strings inside `values-de-rDE`, you can use
    them by adding the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试不同的用户区域设置，您可以添加 `locale` 参数。例如，如果您的应用在 `values-de-rDE` 中包含德语字符串，您可以通过添加以下内容来使用它们：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The string matches the directory name after `values-`. Please recall that the
    directory is created by Android Studio if you add a language in the Translations
    Editor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串匹配 `values-` 后的目录名。请记住，如果您在翻译编辑器中添加语言，Android Studio 会创建该目录。
- en: 'If you want to display the status and action bars, you can achieve this with
    `showSystemUi`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想显示状态栏和操作栏，您可以使用 `showSystemUi` 来实现这一点：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To get an idea of how your composables react to different form factors, aspect
    ratios, and pixel densities, you can utilize the `device` parameter. It takes
    a string. Pass one of the values from `Devices`, for example, `Devices.PIXEL_C`
    or `Devices.AUTOMOTIVE_1024p`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解您的复合函数对不同形态因子、宽高比和像素密度的反应，您可以使用 `device` 参数。它接受一个字符串。传递 `Devices` 中的其中一个值，例如，`Devices.PIXEL_C`
    或 `Devices.AUTOMOTIVE_1024p`。
- en: In this section, you have seen how to configure a preview. Next, I will introduce
    you to preview groups. They are very handy if your source code file contains more
    than a few composable functions that you want to preview.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经看到了如何配置预览。接下来，我将向您介绍预览组。如果您的源代码文件包含多个您想要预览的复合函数，它们将非常有用。
- en: Grouping previews
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预览分组
- en: 'Android Studio shows composable functions with a `@Preview` annotation in the
    order of their appearance in the source code. You can choose between **Vertical
    Layout** and **Grid Layout** (*Figure 1.4*):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 以源代码中出现的顺序显示带有 `@Preview` 注解的可组合函数。您可以选择 **垂直布局** 和 **网格布局**（*图
    1.4*）：
- en: '![Figure 1.4 – Switching between Vertical Layout and Grid Layout'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 在垂直布局和网格布局之间切换'
- en: '](img/B17505_01_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_01_04.jpg)'
- en: Figure 1.4 – Switching between Vertical Layout and Grid Layout
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 在垂直布局和网格布局之间切换
- en: 'Depending on the number of your composables, the preview pane may at some point
    feel crowded. If this is the case, just put your composables into different groups
    by adding a `group` parameter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的可组合函数数量，预览窗格可能会在某些时候显得拥挤。如果是这种情况，只需通过添加 `group` 参数将您的可组合函数放入不同的组中：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can then show either all composable functions or just those that belong
    to a particular group (*Figure 1.5*):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以显示所有可组合函数或仅显示属于特定组的那些函数（*图 1.5*）：
- en: '![Figure 1.5 – Switching between groups'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 在组之间切换'
- en: '](img/B17505_01_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_01_05.jpg)'
- en: Figure 1.5 – Switching between groups
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 在组之间切换
- en: 'So far, I have shown you what the source code of composable functions looks
    like and how you can preview them inside Android Studio. In the next section,
    we will execute a composable on the Android Emulator or a real device, and you
    will learn how to connect composable functions to the other parts of an app. But
    before that, here is one more tip:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向您展示了可组合函数的源代码看起来是什么样子，以及您如何在 Android Studio 中预览它们。在下一节中，我们将在一个 Android
    模拟器或真实设备上执行一个可组合函数，您将学习如何将可组合函数连接到应用程序的其他部分。但在那之前，这里有一个小贴士：
- en: Export a Preview as an Image
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将预览导出为图片
- en: If you click on a Compose preview with the secondary mouse button, you will
    see a small pop-up menu. Select **Copy Image** to put a bitmap of the preview
    on the system clipboard. Most graphics applications allow you to paste it into
    a new document.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您用鼠标右键单击 Compose 预览，您将看到一个小的弹出菜单。选择 **复制图像** 将预览的位图放入系统剪贴板。大多数图形应用程序允许您将其粘贴到新文档中。
- en: Running a Compose app
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Compose 应用程序
- en: 'If you want to see how a composable function looks and feels on the Android
    Emulator or a real device, you have two options:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看可组合函数在 Android 模拟器或真实设备上的外观和感觉，您有两个选择：
- en: Deploying a composable function
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署可组合函数
- en: Running the app
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: The first option is useful if you want to focus on a particular composable rather
    than the whole app. Also, the time needed to deploy a composable may be significantly
    shorter than deploying a complete app (depending on the app size). So, let's start
    with this one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想专注于特定的可组合函数而不是整个应用程序，第一个选项很有用。此外，部署一个可组合函数所需的时间可能比部署一个完整的应用程序短得多（取决于应用程序的大小）。所以，让我们从这个开始。
- en: Deploying a composable function
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署可组合函数
- en: 'To deploy a composable function to a real device or the Android Emulator, click
    on the **Deploy Preview** button, which is a small image in the upper-right corner
    of a preview (*Figure 1.6*):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要将可组合函数部署到真实设备或 Android 模拟器，请单击右上角的小图像 **部署预览** 按钮（*图 1.6*）：
- en: '![Figure 1.6 – Deploying a composable function'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 部署可组合函数'
- en: '](img/B17505_01_06.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_01_06.jpg)'
- en: Figure 1.6 – Deploying a composable function
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 部署可组合函数
- en: 'This will automatically create new launch configurations (*Figure 1.7*):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动创建新的启动配置（*图 1.7*）：
- en: '![Figure 1.7 – Launch configurations representing Compose previews'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 表示 Compose 预览的启动配置'
- en: '](img/B17505_01_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_01_07.jpg)'
- en: Figure 1.7 – Launch configurations representing Compose previews
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 表示 Compose 预览的启动配置
- en: You can modify or delete Compose preview configurations in the **Run/Debug Configurations**
    dialog. To access them, open the **Compose Preview** node. Then you can, for example,
    change its name or deny parallel runs by unchecking **Allow parallel run**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 **运行/调试配置** 对话框中修改或删除 Compose 预览配置。要访问它们，请打开 **Compose 预览** 节点。然后，例如，您可以更改其名称或通过取消选中
    **允许并行运行** 来阻止并行运行。
- en: The goal of this chapter is to deploy and run your first Compose app on a real
    device or the Android Emulator. You are almost there; in the next section, I will
    show you how to embed composable functions in an activity, which is a prerequisite.
    You will finally be running the app in the *Pressing the play button* section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是在真实设备或 Android 模拟器上部署和运行你的第一个 Compose 应用。你几乎就完成了；在下一节中，我将向你展示如何将组合函数嵌入到活动中，这是先决条件。你最终将在
    *按下播放按钮* 部分运行该应用。
- en: Using composable functions in activities
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在活动中使用组合函数
- en: '**Activities** have been one of the basic building blocks of Android apps since
    the first platform version. Practically every app has at least one activity. They
    are configured in the manifest file. To launch an activity from the home screen,
    the corresponding entry looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动** 自从第一个平台版本以来一直是 Android 应用的基本构建块之一。几乎每个应用至少有一个活动。它们在清单文件中配置。要从主屏幕启动活动，相应的条目看起来像这样：'
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is still true for Compose apps. An activity that wishes to show composable
    functions is set up just like one that inflates a traditional layout file. But
    what does its source code look like? The main activity of the `Hello` app is called
    `MainActivity`, shown in the next code block:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这对 Compose 应用仍然成立。一个希望显示组合函数的活动设置起来就像一个填充传统布局文件的活动一样。但它的源代码是什么样的呢？`Hello` 应用程序的主活动被命名为
    `MainActivity`，如下一个代码块所示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, it is very short. The UI (the `Hello()` composable function)
    is displayed by invoking a function called `setContent`, which is an extension
    function to `androidx.activity.ComponentActivity` and belongs to the `androidx.activity.compose`
    package.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它非常简短。UI（`Hello()` 组合函数）是通过调用一个名为 `setContent` 的函数来显示的，这是一个扩展函数，属于 `androidx.activity.ComponentActivity`
    并属于 `androidx.activity.compose` 包。
- en: To render composables, your activity must extend either `ComponentActivity`
    or another class that has `ComponentActivity` as its direct or indirect ancestor.
    This is the case for `androidx.fragment.app.FragmentActivity` and `androidx.appcompat.app.AppCompatActivity`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染组合，你的活动必须扩展 `ComponentActivity` 或具有 `ComponentActivity` 作为其直接或间接祖先的另一个类。这是
    `androidx.fragment.app.FragmentActivity` 和 `androidx.appcompat.app.AppCompatActivity`
    的情况。
- en: 'This is an important difference; while Compose apps invoke `setContent()`,
    View-based apps call `setContentView()` and pass either the ID of a layout (`R.layout.``activity_main`)
    or the root view itself (which is usually obtained through some binding mechanism).
    Let''s see how the older mechanism works. The following code snippet is taken
    from one of my open source apps (you can find it on GitHub at [https://github.com/MATHEMA-GmbH/TKWeek](https://github.com/MATHEMA-GmbH/TKWeek)
    but it won''t be discussed any further in this book):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的区别；虽然 Compose 应用调用 `setContent()`，基于视图的应用调用 `setContentView()` 并传递布局的
    ID（例如 `R.layout.activity_main`）或根视图本身（这通常是通过某种绑定机制获得的）。让我们看看旧机制是如何工作的。以下代码片段取自我的一个开源应用（你可以在
    GitHub 上找到它 [https://github.com/MATHEMA-GmbH/TKWeek](https://github.com/MATHEMA-GmbH/TKWeek)，但本书将不再进一步讨论）：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you compare both approaches, a striking difference is that with Jetpack Compose,
    there is no need for maintaining references to the UI component tree or individual
    elements of it. I will explain in [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040),
    *Understanding the Declarative Paradigm*, why this leads to code that is easily
    maintainable and less error-prone.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较这两种方法，一个显著的区别是，在使用 Jetpack Compose 时，不需要维护 UI 组件树或其单个元素的引用。我将在 [*第 2 章*](B17505_02_ePub.xhtml#_idTextAnchor040)，“理解声明式范式”中解释为什么这会导致易于维护且错误率较低的代码。
- en: Let's now return to `setContent()`. It receives two parameters, a `parent` (which
    can be `null`) and the `content` (the UI). The `parent` is an instance of `androidx.compose.runtime.CompositionContext`.
    It is used to logically link together two compositions. This is an advanced topic
    that I will be discussing in [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到 `setContent()`。它接收两个参数，一个 `parent`（可以是 `null`）和 `content`（UI）。`parent`
    是 `androidx.compose.runtime.CompositionContext` 的一个实例。它用于在逻辑上将两个组合连接起来。这是一个高级主题，我将在
    [*第 3 章*](B17505_03_ePub.xhtml#_idTextAnchor054)，“探索 Compose 的关键原则”中进行讨论。
- en: Important Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Have you noticed that `MainActivity` does not contain any composable functions?
    They do not need to be part of a class. In fact, you should implement them as
    top-level functions whenever possible. Jetpack Compose provides alternative means
    to access `android.content.Context`. You have already seen the `stringResource()`
    composable function, which is a replacement for `getString()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您有没有注意到 `MainActivity` 不包含任何可组合函数？它们不需要成为类的一部分。实际上，您应该尽可能地将它们实现为顶级函数。Jetpack
    Compose 提供了访问 `android.content.Context` 的替代方法。您已经看到了 `stringResource()` 可组合函数，它是
    `getString()` 的替代品。
- en: Now that you have seen how to embed composable functions in activities, it is
    time to look at the structure of Jetpack Compose-based projects. While Android
    Studio sets everything up for you if you create a Compose app using the project
    wizard, it is important to know which files are involved under the hood.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经看到了如何在活动中嵌入可组合函数，是时候看看基于 Jetpack Compose 的项目的结构了。虽然如果您使用项目向导创建 Compose
    应用程序，Android Studio 会为您设置一切，但了解底层涉及哪些文件是很重要的。
- en: Looking under the hood
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看底层
- en: Jetpack Compose heavily relies on Kotlin. This means that your app project must
    be configured to use Kotlin. It does not imply, though, that you cannot use Java
    at all. In fact, you can easily mix Kotlin and Java in your project, as long as
    your composable functions are written in Kotlin. You can also combine traditional
    views and composables. I will be discussing this topic in [*Chapter 9*](B17505_09_ePub.xhtml#_idTextAnchor148),
    *Exploring Interoperability APIs*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 严重依赖于 Kotlin。这意味着您的应用程序项目必须配置为使用 Kotlin。但这并不意味着您不能完全使用 Java。实际上，只要您的可组合函数是用
    Kotlin 编写的，您就可以轻松地在项目中混合使用 Kotlin 和 Java。您还可以结合传统视图和可组合项。我将在 [*第 9 章*](B17505_09_ePub.xhtml#_idTextAnchor148)
    中讨论此主题，*探索互操作性 API*。
- en: 'First, make sure to configure the Android Gradle plugin that corresponds to
    your version of Android Studio in the project-level build.gradle file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保在项目级别的 build.gradle 文件中配置与您的 Android Studio 版本相对应的 Android Gradle 插件：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code snippets belong in the module-level build.gradle file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段属于模块级别的 build.gradle 文件：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, please make sure that your app''s minimum API level is set to 21 or higher
    and that Jetpack Compose is enabled. The following code snippet also sets the
    version for the Kotlin compiler plugin:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请确保您的应用程序的最小 API 级别设置为 21 或更高，并且已启用 Jetpack Compose。以下代码片段还设置了 Kotlin 编译器插件的版本：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, declare dependencies. The following code snippet acts as a good starting
    point. Depending on which packages your app uses, you may need additional ones:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，声明依赖项。以下代码片段是一个很好的起点。根据您的应用程序使用的包，您可能需要额外的依赖项：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once you have configured your project, building and running a Compose app works
    just like traditional view-based apps.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您配置了项目，构建和运行 Compose 应用程序的工作方式就像传统的基于视图的应用程序一样。
- en: Pressing the play button
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按下播放按钮
- en: 'To run your Compose app, select your target device, make sure that the **app**
    module is selected, and press the green *play* button (*Figure 1.8*):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行您的 Compose 应用程序，请选择您的目标设备，确保已选中 **app** 模块，然后按下绿色的 *播放* 按钮 (*图 1.8*)：
- en: '![Figure 1.8 – Android Studio toolbar elements to launch an app'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – 启动应用程序的 Android Studio 工具栏元素]'
- en: '](img/B17505_01_08.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_01_08.jpg]'
- en: Figure 1.8 – Android Studio toolbar elements to launch an app
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 启动应用程序的 Android Studio 工具栏元素
- en: Congratulations! Well done. You have now launched your first Compose app, and
    you have achieved quite a lot. Let's recap.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！做得好。您现在已经启动了您的第一个 Compose 应用程序，并且已经取得了相当大的成就。让我们回顾一下。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned how to write our first composables: Kotlin functions
    that have been annotated with `@Composable`. Composable functions are the core
    building blocks of Jetpack Compose-based UIs. You combined existing library composables
    with your own to create beautiful app screens. To see a preview, we can add the
    `@Preview` annotation. To use Jetpack Compose in a project, both `build.gradle`
    files must be configured accordingly.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何编写我们的第一个可组合项：带有 `@Composable` 注解的 Kotlin 函数。可组合函数是基于 Jetpack Compose
    的 UI 的核心构建块。您将现有的库可组合项与您自己的组合在一起，以创建美观的应用程序屏幕。要查看预览，我们可以添加 `@Preview` 注解。要在项目中使用
    Jetpack Compose，两个 `build.gradle` 文件都必须相应地配置。
- en: In [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040), *Understanding the
    Declarative Paradigm*, we will take a closer look at the differences between the
    declarative approach of Jetpack Compose and the imperative nature of traditional
    UI frameworks such as Android's view-based component library.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B17505_02_ePub.xhtml#_idTextAnchor040)《理解声明式范式》中，我们将更深入地探讨Jetpack Compose的声明式方法和传统UI框架（如Android的基于视图的组件库）的命令式本质之间的区别。
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: This book assumes you have a basic understanding of the syntax of Kotlin and
    Android development in general. If you would like to learn more about this, I
    suggest looking at *Android Programming with Kotlin for Beginners*, *John Horton*,
    *Packt Publishing*, *2019*, *ISBN 9781789615401*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您对Kotlin的语法和Android开发有基本的了解。如果您想了解更多关于这方面的内容，我建议查看*《Kotlin编程入门》*，作者*约翰·霍顿*，*Packt
    Publishing*出版社，*2019年*，*ISBN 9781789615401*。
