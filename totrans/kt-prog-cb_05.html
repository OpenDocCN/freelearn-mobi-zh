<html><head></head><body><div><h1 class="header-title">Object-Oriented Programming</h1>
                
            
            
                
<p class="mce-root">The following recipes will be covered in this chapter:</p>
<ul>
<li>Working with interfaces in Kotlin</li>
<li>How to implement complicated interfaces with multiple overridden methods in Kotlin</li>
<li>How to extend a class in Kotlin (Inheritance and Extension functions)</li>
<li>How to work with Generics in Kotlin</li>
<li>How to implement polymorphism in Kotlin</li>
<li>Restricting class hierarchies</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p><strong>Object-Oriented Programming</strong>, also known as <strong>OOP</strong>, is a programming paradigm based on objects. In this programming paradigm, objects contain data in the form of fields and code in the form of methods, which can be used to modify the data of the same object. In some object-oriented languages, objects are instances of classes (for example, Java and Kotlin). In object-oriented programming, our code is made up of objects that interact with each other. In this chapter, we will learn about some key components of OOPs, such as interfaces, classes, class hierarchies, and Generics.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with interfaces in Kotlin</h1>
                
            
            
                
<p><strong>Interfaces</strong> in OOP are like the <em>contract</em>. They define the behavior or rules. The classes that implement them need to do so in order to conform to the behavior defined by interfaces. However, that's not it. Interfaces in Kotlin provide much more. Prior to Java 8, we couldn't have the implementation of methods in the interfaces, but in Kotlin, we can have that too! In this recipe, we will see how to deal with interfaces in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using IntelliJ IDEA for writing and executing code. You are free to use any IDE where you can run the Kotlin code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>As we have just discussed, interfaces in Kotlin can have the implementation of methods; let's follow these mentioned steps to check that out:</p>
<ol>
<li>Let's create an interface named <kbd>DemoInterface</kbd>:</li>
</ol>
<pre style="padding-left: 60px">interface DemoInterface {<br/><br/>    fun implementatedMethod() {<br/>        println("From demo interface")<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Defining a method with implementation in the interface is just like you would do inside a class.</p>
<ol start="2">
<li>Now, let's see a class that has implemented the preceding interface:</li>
</ol>
<pre style="padding-left: 60px">class IntefaceImplementation: DemoInterface</pre>
<ol start="3">
<li>Then, you can call the method like this:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var interfaceImplementation= IntefaceImplementation()<br/>    interfaceImplementation.implementatedMethod()<br/>}</pre>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px"><strong> From demo interface</strong></pre>
<ol start="4">
<li>A key benefit to this new type of interface is that you can have the behavior of multiple interfaces since it allows method implementation:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var interfaceImplementation= IntefaceImplementation()<br/>    interfaceImplementation.foo()<br/>    interfaceImplementation.bar()<br/><br/>}<br/>interface A {<br/><br/>    fun foo() {<br/>        println("foo from A")<br/>    }<br/>}<br/>class IntefaceImplementation: A,B<br/><br/>interface B  {<br/>    fun bar() {<br/>        println("foo from B")<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As you can see in the preceding code, using multiple interfaces, we have the behavior of two entities. Yes, this may sound like multiple inheritance.</p>
<ol start="5">
<li>Suppose you have two types of interfaces, and both have the methods with the same name, as follows:</li>
</ol>
<pre style="padding-left: 60px">interface A {<br/>    fun foo() {<br/>        println("foo from A")<br/>    }<br/>}<br/>interface B  {<br/>    fun foo() {<br/>        println("foo from B")<br/>    }<br/>}</pre>
<ol start="6">
<li>Now, if you try to implement both interfaces to a class, the compiler will throw an error:</li>
</ol>
<pre style="padding-left: 60px">Error:(24, 1) Kotlin: Class 'IntefaceImplementation' must override public open fun foo(): Unit defined in packageB.A because it inherits multiple interface methods of it</pre>
<ol start="7">
<li>The reason is intuitive, as it brings ambiguity of which method to call. Hence, Kotlin will require you to implement that method and call the desired method inside it, something like this:</li>
</ol>
<pre style="padding-left: 60px">class IntefaceImplementation: A,B {<br/>    override fun foo() {<br/>        super&lt;A&gt;.foo()<br/>        super&lt;B&gt;.foo()<br/>    }<br/>}</pre>
<ol start="8">
<li> Now, you will simply call the <kbd>foo</kbd> method, as earlier:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var interfaceImplementation= IntefaceImplementation()<br/>    interfaceImplementation.foo()<br/>}</pre>
<p>This is the output:</p>
<pre style="padding-left: 60px"><strong>foo from A</strong><br/><strong>foo from B</strong></pre>
<p class="mce-root">Interfaces in Kotlin can have the implementation of methods, but can't have states. This means you can't declare a property in the interface and store the state in it. Either the class implementing it needs to override it, or you need to implement its accessor also.</p>
<p>For example, you can't have <kbd>val a=23</kbd> in an interface, though you can have something like the following:</p>
<pre style="padding-left: 60px">val a: Int<br/>    get() = 2</pre>
<p>Alternatively, simply define it in the interface and override it in the implementing class, like this:</p>
<pre style="padding-left: 60px">class InterfaceImplementation: A,B {<br/>    override val a: Int=25}</pre>
<p style="padding-left: 60px">Next, we will look at interfaces delegation in Kotlin:</p>
<ol>
<li>A delegation pattern, an object ( <a href="https://en.wikipedia.org/wiki/Object_(computer_science)">https://en.wikipedia.org/wiki/Object_(computer_science)</a>) handles a request by delegating to a second object. Let's take a look at the following code:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var interfaceImplementation= InterfaceImplementation(object :A{<br/>    })<br/>    interfaceImplementation.someMethod()<br/>}<br/>class InterfaceImplementation(var a:A){<br/>    fun someMethod(){<br/>        a.foo()<br/>    }<br/>}<br/>interface A {<br/>    fun foo() {<br/>        println("foo from A")<br/>    }<br/>}</pre>
<ol start="2">
<li>In the preceding example, we are delegating the call to the <kbd>foo</kbd> method, to the object that has implemented the interface A. While the preceding code is perfectly fine, Kotlin allows us to use the function directly. Look at this code:</li>
</ol>
<pre style="padding-left: 60px">class InterfaceImplementation(var a:A):A by a{<br/>    fun someMethod(){<br/>        foo()<br/>    }<br/>}</pre>
<ol start="3">
<li>As you can see, the <kbd>InterfaceImplementation</kbd> class is implementing <kbd>A</kbd> but is delegating the implementation to the objects that it is receiving as parameters.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p class="mce-root">Now that Kotlin supports the implementation of methods in interfaces, you might be thinking what's the difference between an <kbd>interface</kbd> and <kbd>abstract</kbd> methods.</p>
<p>In interfaces, you can only define the property, which needs to be overridden by implementing class. However, in an abstract class, you can have an implementation that works with the state so that it cannot be overridden in the derived classes. In an abstract class, you can define some states and methods that will be the same in the derived class.</p>
<p>Another key difference is that you can have final members in an abstract class, but not in interfaces. Also, interfaces don't support <kbd>protected</kbd> and <kbd>internal</kbd> modifiers. It only supports <kbd>private</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to implement complicated interfaces with multiple overridden methods in Kotlin</h1>
                
            
            
                
<p class="graf graf--p graf-after--figure"><strong>SOLID </strong>is a mnemonic acronym that is used to define the five basic <strong>object-oriented design</strong> principles:</p>
<ul class="postList">
<li class="graf graf--li graf-after--p">Single Responsibility Principle</li>
<li class="graf graf--li graf-after--li">Open-Closed Principle</li>
<li class="graf graf--li graf-after--li">Liskov Substitution Principle</li>
<li class="graf graf--li graf-after--li">Interface Segregation Principle</li>
<li class="graf graf--li graf-after--li">Dependency Inversion Principle</li>
</ul>
<p>The <strong>Interface Segregation Principle</strong>(<strong>ISP</strong>) states that if an interface becomes too long, it is better to split it into smaller pieces (interfaces) so that the client doesn't need to implement the ones in which they are not interested. In this recipe, we will understand what and why this is important.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using Android Studio 3.0. Ensure that you have its latest version.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's see an example where ISP can help us:</p>
<ol>
<li>This is a simple example of a "fat" interface:</li>
</ol>
<pre style="padding-left: 60px" class="graf graf--pre graf-after--p">button<strong>.</strong>setOnClickListener<strong>(object :</strong> View<strong>.</strong>OnClickListener <strong>{</strong><br/>    <strong>fun</strong> onClick<strong>(</strong>View v<strong>)</strong> <strong>{</strong><br/>       <em>// TODO: do some stuff...</em><br/>       <br/>    <strong>}</strong><br/>    <br/>    fun onLongClick<strong>(</strong>View v<strong>)</strong> <strong>{</strong><br/>        <em>// we don't need it</em><br/>    <strong>}</strong><br/><br/>    fun onTouch<strong>(</strong>View v<strong>,</strong> MotionEvent event<strong>)</strong> <strong>{</strong><br/>        <em>// we don't need it<br/></em>    <strong>}</strong> <br/><strong>});</strong></pre>
<ol start="2">
<li>As you can see, the problem of a big interface is that we are forced to implement the methods even if we don't have anything to do it in there.</li>
<li>A simple solution is to break that interface into smaller interfaces, like the following code:</li>
</ol>
<pre style="padding-left: 60px" class="graf graf--pre graf-after--p"><strong>interface</strong> <strong>OnClickListener</strong> <strong>{</strong> <br/>    <strong>fun</strong> onClick<strong>(</strong> v:View <strong>)</strong><br/><strong>}<br/></strong><strong>public</strong> <strong>interface</strong> <strong>OnLongClickListener</strong> <strong>{</strong> <br/>    <strong>fun</strong> onLongClick<strong>(</strong> v: View<strong>)</strong><br/><strong>}<br/></strong><strong>interface</strong> <strong>OnTouchListener</strong> <strong>{</strong> <br/>    fun onTouch<strong>(</strong> v: View<strong>,</strong>  event: MotionEvent<strong>)</strong></pre>
<ol start="4">
<li>Note that now we have divided the one big interface into smaller ones, which can be implemented independently.</li>
</ol>
<ol start="5">
<li>Kotlin also has a powerful feature that allows you to write full implementation of methods in the interfaces itself. Let's take a look at the following code to understand it:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    Simple().callMethod()<br/>}<br/>class Simple:A{<br/>    fun callMethod(){<br/>        bar()<br/>    }<br/>}<br/>interface A{<br/>    fun bar(){<br/>        println("Printing from interface")<br/>    }<br/>}</pre>
<ol start="6">
<li>As you can see, we implemented the whole method in the interface, and we were able to call it from the class that implemented that interface.</li>
<li>This feature can also be used to follow the ISP principle, as we can put a commonly used method in the interfaces itself; as a result, we will not need to implement it every time we implement that interface.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">How to extend a class in Kotlin (Inheritance and Extension functions)</h1>
                
            
            
                
<p>In this recipe, we will learn how to extend a class (Inheritance) and how to extend the functionality of a class using Kotlin's Extension functions.</p>
<p><strong>Inheritance</strong> is probably the first concept you learn in object-oriented programming. It is a mechanism where a new class is derived from an existing class. Via this, the classes may inherit or acquire the properties and methods of other classes. <strong>Extension functions</strong>, on the other hand, let us skip creating wrapper for functionality and enable us to add extra functions to the classes. Let's see both of them now.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Since we will be dealing with Android code, it is recommended that you use Android Studio as IDE. The source code can be found in the 1-recycler-view-in-kotlin branch of the <a href="https://gitlab.com/aanandshekharroy/kotlin-cookbook">https://gitlab.com/aanandshekharroy/kotlin-cookbook</a> repository.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>A class derived from another class is called a subclass, whereas the class from which a subclass is derived is called a superclass. In this example, we will create a superclass A and a subclass B. To extend class B, we need to use <kbd>:</kbd> in the class declaration, and then add the superclass name with its primary constructor. Let's take a look at the following steps:</p>
<ol>
<li>A key thing to remember is that classes in Kotlin are <em>closed</em> for extension by default, so we need to open them by adding the <em>open</em> keyword before the class declaration. So our superclass A looks like this:</li>
</ol>
<pre style="padding-left: 60px">open class A</pre>
<ol start="2">
<li>Then, we can extend our class B, as follows:</li>
</ol>
<pre style="padding-left: 60px">class B:A()</pre>
<ol start="3">
<li>Now, suppose our class A has a primary constructor that takes in a <kbd>String</kbd> variable, such as this:</li>
</ol>
<pre style="padding-left: 60px">open class A(var str:String)</pre>
<p style="padding-left: 60px">Now, if we wish to extend B with A, there are two ways to do so:</p>
<ul>
<li style="padding-left: 60px">Initialize A in B's primary constructor. In this approach, we will initialize A by passing arguments from B's primary constructor. Consider this example:</li>
</ul>
<pre style="padding-left: 120px">class B(var randomString:String): A(randomString)</pre>
<ul>
<li style="padding-left: 60px">If B, or any class, doesn't have a primary constructor, then each secondary class of the extending class needs to initialize the superclass using the <kbd>super</kbd> keyword. Consider the given example:</li>
</ul>
<pre style="padding-left: 120px">class B: A{<br/>    constructor(randomString:String) : super(randomString)<br/>    constructor(randomString:String, randomInt:Int) : super(randomString)</pre>
<ol start="4">
<li>We generally extend a class to import the functionalities from a superclass and sometimes, we might also like to override them to have our own implementation. Similar to classes, methods are also closed by default, and we need to "open" them with the open modifier:</li>
</ol>
<pre style="padding-left: 60px">open class A(var str:String){<br/>    open fun foo(){<br/>        println("foo from A")<br/>    }<br/>}<br/>class B(var string: String): A(string) {<br/>    override fun foo(){<br/>        println("foo from B")<br/>    }<br/>}</pre>
<ol start="5">
<li>You can also mark a method "final" to prevent any other subclass from overriding it. Take this example into consideration:</li>
</ol>
<pre style="padding-left: 60px">open class A(var str:String){<br/>    final fun foo(){<br/>        println("foo from A")<br/>    }<br/>}</pre>
<ol start="6">
<li class="mce-root">If you extend your class with an abstract class, you need to implement all the methods defined as abstract in the abstract class. Note that you don't need to mark them open in order for them to be overridden by the extending class. Making them abstract does the job itself, as shown in this example:</li>
</ol>
<pre style="padding-left: 60px">class B(var string: String): C() {<br/>    override fun methodC() {<br/>        // Do something here<br/>    }<br/>}<br/>abstract class C{<br/>    abstract fun methodC()<br/>    fun impl(){}<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Extension functions</h1>
                
            
            
                
<p><strong>Extension functions</strong> are useful, as they allow us to extend the functionality of a class without actually touching it. For example, if you've used Glide or Picasso library for placing an image inside the <kbd>Imageview</kbd>, you must be familiar with the following code:</p>
<pre>Glide.with(context).load(image_url).into(imageView)</pre>
<p>We can make this look much better using an extension function. Let's call the <kbd>loadImage(imageUrl)</kbd> function on <kbd>imageView</kbd>. If you do it, you will see an error—Unresolved reference- loadImage:</p>
<div><img src="img/e3ed60f9-8df2-4d3b-a1d5-b7bdd7467c4c.png" width="876" height="60"/></div>
<p>You will also see two suggestions, one of which is Create extension function:</p>
<div><img src="img/b442b29a-96fb-4153-9db2-6ba84378122f.png" width="968" height="107"/></div>
<p>If you click on Create extension function, you'll be provided with some choices, as in the this screenshot:</p>
<div><img src="img/3066a626-c699-4ad2-b9c5-cdc6f9c24305.png" width="839" height="213"/></div>
<p>Click on ImageView, because we want to create an extension function on it.</p>
<p>When you click on it, an extension function is created in the same file, which looks like this:</p>
<pre>private fun ImageView.loadImage(image_url: String) {<br/>    <br/>}</pre>
<p>Here, we can place our Glide/Picasso code for image loading:</p>
<pre>private fun ImageView.loadImage(image_url: String) {<br/>    Glide.with(context).load(image_url).into(this)<br/>}</pre>
<p>So, even if the <kbd>loadImage</kbd> function was not present in the <kbd>ImageView</kbd> class, we were able to extend it and use it as if this function was part of <kbd>ImageView</kbd>, and we didn't even have to touch the <kbd>ImageView</kbd> class. The extension function extended the functionality of <kbd>ImageView</kbd> externally.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>The prefix to the extension function (the name that comes before the dot) is called <strong>receiver</strong> <strong>type</strong>, that is, the type being extended. This receiver object is accessed inside the function using the <kbd>this</kbd> keyword. The extension functions are resolved statically; it's like calling a static method. Since this is a static method, it's not needed to be defined under the class, but since it's a static method, it's hard to test. For example, Mockito (a testing framework) cannot test static methods, so to produce great code quality, use extension function only if that function doesn't require any testing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>What happens when you create an extension function with a name similar to that of a member function? For example, in the following code, what will happen if we call <kbd>c.foo()</kbd>?:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    var c= C()<br/>    c.foo()<br/>}<br/>class C{<br/>    fun foo(){<br/>        println("from member")<br/>    }<br/>}<br/>private fun C.foo() {<br/>    println("from extension")<br/>}</pre>
<p>This is the output we get:</p>
<pre><strong> from member</strong></pre>
<p>So a member function will win if an extension function with the same name is called.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to work with Generics in Kotlin</h1>
                
            
            
                
<p>Generic methods and classes help us use the same method or class for various types. This improves code reusability. In this recipe, we will understand Generics and how to use it in Kotlin. Generics in Kotlin is quite similar to Generics in Java, but there are additional special keywords in Kotlin that make Generics in Kotlin more intuitive. Let's dive in.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for the purpose, for which you need a Kotlin compiler installed along with JDK. I am using IntelliJ IDE to compile and run my Kotlin code for this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Now, let's follow these steps to understand how Generics works in Kotlin, with the help of some examples:</p>
<ol>
<li class="mce-root">Let's start with a generic class that we can instantiate using any type of parameter:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    val intgen: GenCl&lt;Int&gt; = GenCl&lt;Int&gt;(10)<br/>    println(intgen.a)<br/><br/>    // We are letting Kotlin compiler infer type<br/>    val strgen = GenCl("A string")<br/>    println(strgen.a)<br/>}<br/><br/>class GenCl&lt;T&gt;(t: T) {<br/>    var a = t<br/>}</pre>
<p style="padding-left: 60px">The output of this program is this:</p>
<pre style="padding-left: 60px"><strong>10</strong><br/><strong>A string</strong></pre>
<ol start="2">
<li class="mce-root">We can also restrict what types are allowed in our generic class like this:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">fun main(args: Array&lt;String&gt;) {<br/>    val intgen: GenCl&lt;Int&gt; = GenCl&lt;Int&gt;(10)<br/>    println(intgen.a)<br/><br/>    val flgen = GenCl(1.0)<br/>    println(flgen.a)<br/>}<br/><br/>// Restricting T to only be of type Number<br/>class GenCl&lt;T: Number&gt;(t: T) {<br/>    var a = t<br/>}</pre>
<ol start="3">
<li>If we try to use the preceding class with a type that is not a <kbd>Number</kbd>, for example, a <kbd>String</kbd>, we get the following error:</li>
</ol>
<pre style="padding-left: 60px">Error:(8, 17) Type parameter bound for T in constructor GenCl&lt;T : Number&gt;(t: T)<br/> is not satisfied: inferred type String is not a subtype of Number</pre>
<ol start="4">
<li class="mce-root">Now, let's try an example of a generic method:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    fun &lt;T&gt; addTwo(a: List&lt;T&gt;) {<br/>        for(x in a) {<br/>            println(x)<br/>        }<br/>    }<br/><br/>    addTwo(listOf(10,20,30,40))<br/>    addTwo(listOf("a","b","c","d","e"))<br/>}</pre>
<p>The output of the preceding code will be as follows:</p>
<pre><strong>10 <br/>20 <br/>30 <br/>40 <br/>a <br/>b <br/>c <br/>d <br/>e</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>Generic types in Java are invariant, which means <kbd>List&lt;String&gt;</kbd> is not a subtype of <kbd>List&lt;Object&gt;</kbd>. Java has this so that we are not able to add, say, a <kbd>Float</kbd> to a <kbd>List</kbd> that contains <kbd>String</kbd> and has the type as <kbd>Object</kbd>. In Kotlin, we have a better solution where we use the wildcard argument as  <kbd>? extends E</kbd>, which denotes that the method accepts a subtype of E or collection of E and not just E itself. This gives us the power to read from a collection of E but not write to it, as we do not know what items are accepted. This makes Kotlin covariant.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to implement polymorphism in Kotlin</h1>
                
            
            
                
<p><strong>Polymorphism</strong> is the ability of an object to take many forms, depending on the situation. Kotlin supports two types of polymorphism: <strong>compile-time polymorphism</strong> and <strong>run-time polymorphism</strong>. In this recipe, we will try both. Let's get started.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to install a preferred development environment that compiles and runs Kotlin. You can also use the command line for the purpose, for which you need a Kotlin compiler installed along with JDK. I am using IntelliJ IDE to compile and run my Kotlin code for this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, we will learn how to use polymorphism in Kotlin:</p>
<ol>
<li>Let's start with compile-time polymorphism. In <strong>compile-time polymorphism</strong>, the name functions, that is, the signature remains the same but parameters or return type is different. At compile time, the compiler then resolves which functions we are trying to call based on the type of parameters and more. Check out this example:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    println(doubleOf(4))<br/>    <br/>    println(doubleOf(4.3))<br/>    <br/>    println(doubleOf(4.323))<br/>}<br/><br/>fun doubleOf(a: Int): Int {<br/>    return 2*a<br/>}<br/><br/>fun doubleOf(a: Float): Float {<br/>    return 2*a<br/>}<br/><br/>fun doubleOf(a: Double): Double {<br/>    return 2.00*a<br/>}</pre>
<p style="padding-left: 60px">Here's the output of the preceding code:</p>
<pre style="padding-left: 60px"><strong>8</strong><br/><strong>8.6</strong><br/><strong>8.646</strong></pre>
<ol start="2">
<li>Now, let's talk about run-time polymorphism. In <strong>run-time polymorphism</strong>, the compiler resolves a call to overridden/overloaded methods at runtime. We can achieve run-time polymorphism using method overriding. Let's try an example where we extend a superclass and override one of its member methods:</li>
</ol>
<pre style="padding-left: 60px">fun main(args: Array&lt;String&gt;) {<br/>    var a = Sup()<br/>    a.method1()<br/>    a.method2()<br/><br/>    var b = Sum()<br/>    b.method1()<br/>    b.method2()<br/>}<br/><br/>open class Sup {<br/>    open fun method1() {<br/>        println("Printing method 1 from inside Sup")<br/>    }<br/><br/>    fun method2() {<br/>        println("Printing method 2 from inside Sup")<br/>    }<br/>}<br/><br/>class Sum: Sup() {<br/>    override fun method1() {<br/>        println("Printing method 1 from inside Sum")<br/>    }<br/>}</pre>
<p>The output of the preceding code is this:</p>
<pre><strong>Printing method 1 from inside Sup</strong><br/><strong>Printing method 2 from inside Sup</strong><br/><strong>Printing method 1 from inside Sum</strong><br/><strong>Printing method 2 from inside Sup</strong></pre>
<p>Here, the compiler resolves, at run-time, which method to execute.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Restricting class hierarchies</h1>
                
            
            
                
<p>In this recipe, we will learn how to restrict the class hierarchies in Kotlin. Before we move ahead, let's understand why this is a cause worth spending our time on.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio to run the code described in this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>When we are sure that a value or a class can have only a limited set of types or number of subclasses, that's when we try to restrict class hierarchy. Yes, this might sound like an enum class but, actually, it's much more than that. Enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances that can contain state. Let's look at an example in the mentioned steps:<br/></p>
<ol>
<li>We will create a <strong>sealed</strong> class named <kbd>ToastOperation</kbd>. Under the same source file, we will define a <kbd>ShowMessageToast</kbd> subclass:</li>
</ol>
<pre style="padding-left: 60px">class ShowMessageToast(val message:String):ToastOperation()</pre>
<ol start="2">
<li>Also, we'll define a <kbd>ShowErrorToast</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">object ShowErrorToast:ToastOperation()</pre>
<ol start="3">
<li>As you may have noted, I have defined an <strong>object</strong> rather than a full class declaration, because the <kbd>ShowErrorToast</kbd> <strong>object</strong> doesn't have any state. Also, by doing so, we have removed <em>is</em> from the <em>when</em> block, since there is just one instance.</li>
</ol>
<p style="padding-left: 60px">Now, we can use it in a <kbd>when</kbd> statement, as follows:</p>
<pre style="padding-left: 60px">fun doToastOperation(toastOperation: ToastOperation){<br/>    when(toastOperation){<br/>        is ShowMessageToast -&gt;Toast.makeText(this,toastOperation.message,Toast.LENGTH_LONG).show()<br/>        ShowErrorToast-&gt;Toast.makeText(this,"Error.. Grr!",Toast.LENGTH_LONG).show()<br/>    }<br/>}</pre>
<ol start="4">
<li>The key benefit is that we don't need to implement the <kbd>else</kbd> block, which acted as the default block when the other statements didn't fit the bill.</li>
</ol>
<p>According to documentation, a <kbd>sealed</kbd> class can have subclasses, but all of them must be declared in the same file as the sealed class itself. However, the subclasses of subclasses need not be defined in the same file. It is abstract by itself, and you cannot instantiate objects from it.</p>
<p>Here's our structure of <kbd>sealed</kbd> classes:</p>
<pre>sealed class ToastOperation {<br/>}<br/>object ShowErrorToast:ToastOperation()<br/>class ShowMessageToast(val message:String):ToastOperation()</pre>
<p class="mce-root">As you can see, we've kept all the subclasses under the same source file in which we have defined the <strong>sealed</strong> class.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>In the preceding example, we were sure that we can only have two types of toasts: an error toast and a toast with a custom message. So we created a <strong>sealed</strong> class <kbd>ToastOperation</kbd> and created two subclasses of <kbd>ToastOperation</kbd>. Note that if we aren't sure of types of subclasses, we will not use a <strong>sealed</strong> class, in that case, an <strong>enum</strong> class might be better suited.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>If you are using Kotlin versions prior to 1.1, you'll need to implement the subclasses inside the sealed class, much like this:</p>
<pre>sealed class ToastOperation {<br/>    object ShowErrorToast:ToastOperation()<br/>    class ShowMessageToast(val message:String):ToastOperation()<br/>}</pre>
<p>Note that you can use the preceding way in the new version of Kotlin as well.</p>


            

            
        
    </div>



  </body></html>