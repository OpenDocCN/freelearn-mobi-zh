<html><head></head><body>
		<div id="_idContainer025">
			<h1 id="_idParaDest-40"><em class="italic"><a id="_idTextAnchor042"/>Chapter 3</em>: Handling Coroutine Cancelations and Exceptions</h1>
			<p>In the previous chapter, you dove deep into Kotlin coroutines and learned how to use them for asynchronous programming in Android with simple code. You learned how to create coroutines with coroutine builders. Finally, you explored coroutine dispatchers, coroutine scopes, coroutine contexts, and jobs.</p>
			<p>Coroutines can be canceled when their purpose has been fulfilled or their job has been done. You can also cancel them based on specific instances in your app, such as when you want users to manually stop a task with a tap of a button. Coroutines do not always succeed and can fail; developers must be able to handle these cases so that the app will not crash, and they can inform the users by displaying a toast or snackbar message.</p>
			<p>In this chapter, we will start by understanding coroutine cancelation. You will learn how to cancel coroutines and handle cancelations and timeouts for your coroutines. Then, you will learn how to manage failures and exceptions that can happen in your coroutines.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Canceling coroutines</li>
				<li>Managing coroutine timeouts</li>
				<li>Catching exceptions in coroutines</li>
			</ul>
			<p>By the end of this chapter, you will understand coroutine cancelations and how you can make your coroutines cancelable. You will be able to add and handle timeouts in your coroutines. You will also know how to add code to catch exceptions in your coroutines.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor043"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: Intel Core i5 or equivalent or higher, 4 GB RAM minimum, and 4 GB available space.</p>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter03">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor044"/>Canceling coroutines</h1>
			<p>In this section, we<a id="_idIndexMarker129"/> will start by looking at coroutine cancelations Developers can cancel coroutines in their projects manually or programmatically. You must make sure your application can handle these cancelations.</p>
			<p>If your application is doing a long-running operation that is taking longer than expected and you think it could cause a crash, you might want to stop that task. You can also end tasks that are no longer necessary to free up memory and resources, such as when the user moves out of the activity that launched the task or closes the application. Users can also manually discontinue certain operations if you have that feature in your application. Coroutines make it easier for developers to cancel these tasks.</p>
			<p>If you are using <strong class="source-inline">viewModelScope</strong> from <strong class="source-inline">ViewModel</strong> or <strong class="source-inline">lifecycleScope</strong> from the Jetpack Lifecycle Kotlin extension libraries, you can easily create coroutines without manually handling the cancelation. When <strong class="source-inline">ViewModel</strong> is cleared, <strong class="source-inline">viewModelScope</strong> is automatically canceled, while <strong class="source-inline">lifecycleScope</strong> is automatically canceled when the life cycle is destroyed. If you created your own coroutine scope, you must add the cancelation yourself.</p>
			<p>In the previous chapter, you learned that using coroutine builders such as <strong class="source-inline">launch</strong> returns a <strong class="bold">job</strong>. Using <a id="_idIndexMarker130"/>this <strong class="bold">job</strong> object, you can call the <strong class="source-inline">cancel()</strong> function to cancel the coroutine. Take the following example:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            job.cancel()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">job.cancel()</strong> function will cancel the coroutine launched to call the <strong class="source-inline">fetchMovies()</strong> function.</p>
			<p>After<a id="_idIndexMarker131"/> canceling the job, you may want to wait for the cancelation to be finished before continuing to the next task to avoid race conditions. You can do that by calling the <strong class="source-inline">join</strong> function after calling the <strong class="source-inline">call</strong> function:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            job.cancel()</pre>
			<pre class="source-code">            job.join()</pre>
			<pre class="source-code">            hideProgressBar()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Adding <strong class="source-inline">job.join()</strong> here would make the code wait for the job to be canceled before doing the next task, which is <strong class="source-inline">hideProgressBar()</strong>.</p>
			<p>You can also use the <strong class="source-inline">Job.cancelAndJoin()</strong> extension function, which is the same as calling <strong class="source-inline">cancel</strong> and then the <strong class="source-inline">join</strong> function:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            job.cancelAndJoin()</pre>
			<pre class="source-code">            hideProgressBar()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">cancelAndJoin</strong> function <a id="_idIndexMarker132"/>simplifies the call to the <strong class="source-inline">cancel</strong> and <strong class="source-inline">join</strong> functions into a single line of code.</p>
			<p>Coroutine jobs can have child coroutine jobs. When you cancel a job, its child jobs (if there are any) will also be canceled, recursively.</p>
			<p>If your coroutine scope has multiple coroutines and you need to cancel all of them, you can use the <strong class="source-inline">cancel</strong> function from the coroutine scope instead of canceling the jobs one by one. This will cancel all the coroutines in the scope. Here’s an example of using the coroutine scope’s <strong class="source-inline">cancel</strong> function to cancel coroutines:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.Main +</pre>
			<pre class="source-code">      Job())</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            val job1 = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            val job2 = launch {</pre>
			<pre class="source-code">                displayLoadingText()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    override fun onCleared() {</pre>
			<pre class="source-code">        scope.cancel()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, when <strong class="source-inline">scope.cancel()</strong> is called, it will cancel both the <strong class="source-inline">job1</strong> and <strong class="source-inline">job2</strong> coroutines, which were created in the coroutine <strong class="source-inline">scope</strong> scope.</p>
			<p>Using the <strong class="source-inline">cancel</strong> function <a id="_idIndexMarker133"/>from the coroutine scope makes it easier to cancel multiple jobs launched with the specified scope. However, the coroutine scope won’t be able to launch new coroutines after you called the <strong class="source-inline">cancel</strong> function on it. If you want to cancel the scope’s coroutines but still want to create coroutines from the scope later, you can use <strong class="source-inline">scope.coroutineContext.cancelChildren()</strong> instead:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() { </pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.Main +</pre>
			<pre class="source-code">      Job()) </pre>
			<pre class="source-code">    init { </pre>
			<pre class="source-code">        scope.launch() { </pre>
			<pre class="source-code">            val job1 = launch { </pre>
			<pre class="source-code">                fetchMovies() </pre>
			<pre class="source-code">            } </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            val job2 = launch { </pre>
			<pre class="source-code">                displayLoadingText()</pre>
			<pre class="source-code">            } </pre>
			<pre class="source-code">        } </pre>
			<pre class="source-code">    } </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    fun cancelAll() { </pre>
			<pre class="source-code">        scope.coroutineContext.cancelChildren()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">}</pre>
			<p>Calling the <strong class="source-inline">cancelAll</strong> function will cancel all the child jobs in the coroutine context of the scope. You will still be able to use the scope later to create coroutines.</p>
			<p>Canceling <a id="_idIndexMarker134"/>a coroutine will throw <strong class="source-inline">CancellationException</strong>, a special exception that indicates the coroutine was canceled. This exception will not crash the application. You will learn more about coroutines and exceptions later in this chapter.</p>
			<p>You can also pass a subclass of <strong class="source-inline">CancellationException</strong> to the <strong class="source-inline">cancel</strong> function to specify a different cause:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() { </pre>
			<pre class="source-code">private lateinit var movieJob: Job</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    init { </pre>
			<pre class="source-code">        movieJob = scope.launch() { </pre>
			<pre class="source-code">            fetchMovies() </pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    fun stopFetching() { </pre>
			<pre class="source-code">        movieJob.cancel(CancellationException("Cancelled by</pre>
			<pre class="source-code">          user"))</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">}</pre>
			<p>This cancels the <strong class="source-inline">movieJob</strong> job with <strong class="source-inline">CancellationException</strong> containing the message <strong class="source-inline">Cancelled by user</strong> as the cause when the user calls the <strong class="source-inline">stopFetching</strong> function.</p>
			<p>When you <a id="_idIndexMarker135"/>cancel a coroutine, the coroutine’s job’s state will change to <strong class="source-inline">Cancelling</strong>. It won’t automatically go to the <strong class="source-inline">Cancelled</strong> state and cancel the coroutine. The coroutine can continue to run even after the cancelation, unless your coroutine has code that can stop it from running. These states of a job and its life cycle are summarized in the following diagram:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_3.1_B17773.jpg" alt="Figure 3.1 – Coroutine job life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Coroutine job life cycle</p>
			<p>Your <a id="_idIndexMarker136"/>coroutine code needs to cooperate to be cancelable. The coroutine should handle cancelations as quickly as possible. It must check for cancelations of the coroutine and if the coroutine is already canceled, it throws <strong class="source-inline">CancellationException</strong>.</p>
			<p>One way to make your coroutine cancelable is to check whether the coroutine job is active (still running or completing) or not by using <strong class="source-inline">isActive</strong>. The value of <strong class="source-inline">isActive</strong> will become false once the coroutine job changes its state to <strong class="source-inline">Cancelling</strong>, <strong class="source-inline">Cancelled</strong>, or <strong class="source-inline">Completed</strong>. You can make your coroutine cancelable with <strong class="source-inline">isActive</strong> with the following approaches:</p>
			<ul>
				<li>Perform tasks while <strong class="source-inline">isActive</strong> is true.</li>
				<li>Perform tasks only if <strong class="source-inline">isActive</strong> is true.</li>
				<li>Return or throw an exception if <strong class="source-inline">isActive</strong> is false.</li>
			</ul>
			<p>Another function you can also use is <strong class="source-inline">Job.ensureActive()</strong>. It will check whether the coroutine job is active, and if it’s not, it will throw <strong class="source-inline">CancellationException</strong>.</p>
			<p>Here’s an example of how you can make your coroutine cancelable with <strong class="source-inline">isActive</strong>:</p>
			<pre class="source-code">class SensorActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.IO)</pre>
			<pre class="source-code">    private lateinit var job: Job</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">    private fun processSensorData() {</pre>
			<pre class="source-code">        job = scope.launch {</pre>
			<pre class="source-code">            if (isActive) {</pre>
			<pre class="source-code">                val data = fetchSensorData()</pre>
			<pre class="source-code">                saveData(data)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    fun stopProcessingData() {</pre>
			<pre class="source-code">        job.cancel()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker137"/>coroutine in the <strong class="source-inline">processSensorData</strong> function will check whether the job is active and will only proceed with the task if the value of <strong class="source-inline">isActive</strong> is true.</p>
			<p>Another way to make your coroutine code cancelable is to use suspending functions from the <strong class="source-inline">kotlinx.coroutines</strong> package, such as <strong class="source-inline">yield</strong> or <strong class="source-inline">delay</strong>. The <strong class="source-inline">yield</strong> function yields a thread (or a thread pool) of the current coroutine dispatcher to other coroutines to run. </p>
			<p>The <strong class="source-inline">yield</strong> and <strong class="source-inline">delay</strong> functions already check for cancelation and stop the execution or throw <strong class="source-inline">CancellationException</strong>. Thus, you no longer need to manually check for cancelation when you are using them in your coroutines. Here’s an example using the preceding <a id="_idIndexMarker138"/>code snippet, which has been updated with suspending function delay to make the coroutine cancelable:</p>
			<pre class="source-code">class SensorActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.IO)</pre>
			<pre class="source-code">    private lateinit var job: Job</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        processSensorData()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun processSensorData() {</pre>
			<pre class="source-code">        job = scope.launch {</pre>
			<pre class="source-code">            delay (1_000L)</pre>
			<pre class="source-code">            val data = fetchSensorData()</pre>
			<pre class="source-code">            saveData(data)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    fun stopProcessingData() {</pre>
			<pre class="source-code">        job.cancel()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">delay</strong> suspending <a id="_idIndexMarker139"/>function will check whether the coroutine job is canceled and will throw <strong class="source-inline">CancellationException</strong> if it is, making your coroutine cancelable.</p>
			<p>Let’s learn how to implement a coroutine cancelation for an Android project in the next section.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor045"/>Exercise 3.01 – canceling coroutines in an Android app</h2>
			<p>In this exercise, you<a id="_idIndexMarker140"/> will work on an application that uses a coroutine that slowly counts down from 100 to 0 and displays the value on <strong class="source-inline">TextView</strong>. You will then add a button to cancel the coroutine to stop the countdown before it reaches 0:</p>
			<ol>
				<li>Create a new project in Android Studio. Don’t change the suggested name of <strong class="source-inline">MainActivity</strong> for the activity.</li>
				<li>Open the <strong class="source-inline">app/build.gradle</strong> file and add the dependency for <strong class="source-inline">kotlinx-coroutines-android</strong>:<p class="source-code">implementation ‘org.jetbrains.kotlinx:kotlinx-</p><p class="source-code">  coroutines-android:1.6.0’</p></li>
			</ol>
			<p>This will add the <strong class="source-inline">kotlinx-coroutines-core</strong> and <strong class="source-inline">kotlinx-coroutines-android</strong> libraries to your project, allowing you to use coroutines in your code.</p>
			<ol>
				<li value="3">Open the <strong class="source-inline">activity_main.xml</strong> layout file and add an <strong class="source-inline">id</strong> attribute to <strong class="source-inline">TextView</strong>:<p class="source-code">&lt;TextView</p><p class="source-code">    android:id="@+id/textView"</p><p class="source-code">    style="@style/TextAppearance.AppCompat.Large"</p><p class="source-code">    android:layout_width="wrap_content"</p><p class="source-code">    android:layout_height="wrap_content"</p><p class="source-code">    app:layout_constraintBottom_toBottomOf="parent"</p><p class="source-code">    app:layout_constraintLeft_toLeftOf="parent"</p><p class="source-code">    app:layout_constraintRight_toRightOf="parent"</p><p class="source-code">    app:layout_constraintTop_toTopOf="parent"</p><p class="source-code">    tools:text="0" /&gt;</p></li>
			</ol>
			<p>The <strong class="source-inline">id</strong> attribute will allow you to change the content of this <strong class="source-inline">TextView</strong> later.</p>
			<ol>
				<li value="4">Open<a id="_idIndexMarker141"/> the <strong class="source-inline">MainActivity</strong> file. Add the following properties to the <strong class="source-inline">MainActivity</strong> class:<p class="source-code">private val scope = CoroutineScope(Dispatchers.Main)</p><p class="source-code">private?var job: Job? = null</p><p class="source-code">private lateinit var textView: TextView</p><p class="source-code">private var count = 100</p></li>
				<li>The first line specifies the scope for the coroutine, <strong class="source-inline">CoroutineScope</strong>, with <strong class="source-inline">Dispatchers.Main</strong> as the dispatcher. The second line creates a <strong class="source-inline">job</strong> property for the coroutine job. The <strong class="source-inline">textView</strong> property will be used to display the countdown text and <strong class="source-inline">count</strong> initializes the countdown to 100. In the <strong class="source-inline">onCreate</strong> function of the <strong class="source-inline">MainActivity</strong> file, initialize the value for <strong class="source-inline">TextView</strong>:<p class="source-code">textView = findViewById(R.id.textView)</p></li>
			</ol>
			<p>You will update this <strong class="source-inline">textView</strong> with the decreasing value of value later.</p>
			<ol>
				<li value="6">Create a countdown function that will do the counting down of the value:<p class="source-code">private fun countdown() {</p><p class="source-code">    count--</p><p class="source-code">    textView.text = count.toString()</p><p class="source-code">}</p></li>
			</ol>
			<p>This decreases the value of <strong class="source-inline">count</strong> by 1 and displays it on the text view.</p>
			<ol>
				<li value="7">In the <strong class="source-inline">onCreate</strong> function, below the <strong class="source-inline">textView</strong> initialization, add the following <a id="_idIndexMarker142"/>to start the coroutine to count down the value and display it on the text view:<p class="source-code">job = scope.launch {</p><p class="source-code">    while (count &gt; 0) {</p><p class="source-code">        delay(100)</p><p class="source-code">        countdown()</p><p class="source-code">    }</p><p class="source-code">} </p></li>
			</ol>
			<p>This will call the countdown function every <strong class="source-inline">0.1</strong> seconds, which will count down and display the value on the text view.</p>
			<ol>
				<li value="8">Run the application. You will see that it slowly counts down and displays the value from 100 to 0, similar to the following:</li>
			</ol>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_3.02_B17773_new.jpg" alt="Figure 3.2 – The app counting down from 100 to 0&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The app counting down from 100 to 0</p>
			<ol>
				<li value="9">Open<a id="_idIndexMarker143"/> the <strong class="source-inline">strings.xml</strong> file and add a string for the button:<p class="source-code">&lt;string name="stop"&gt;Stop&lt;/string&gt;</p></li>
			</ol>
			<p>You will use this as the text for the button to stop the countdown. </p>
			<ol>
				<li value="10">Go to the <strong class="source-inline">activity_main.xml</strong> file again and add a button below <strong class="source-inline">TextView</strong>:<p class="source-code">&lt;Button</p><p class="source-code">        android:id="@+id/button"</p><p class="source-code">        android:layout_width="wrap_content"</p><p class="source-code">        android:layout_height="wrap_content"</p><p class="source-code">        android:layout_marginTop="16dp"</p><p class="source-code">        android:text="@string/stop"</p><p class="source-code">        app:layout_constraintEnd_toEndOf="parent"</p><p class="source-code">        app:layout_constraintStart_toStartOf="parent"</p><p class="source-code">        app:layout_constraintTop_toBottomOf="@id/textView" /&gt;</p></li>
			</ol>
			<p>This <a id="_idIndexMarker144"/>will add a <strong class="source-inline">Button</strong> below <strong class="source-inline">TextView</strong>. The button will be used to stop the countdown later. </p>
			<ol>
				<li value="11">Open <strong class="source-inline">MainActivity</strong> and after the job initialization, create a variable for the button:<p class="source-code">val button = findViewById&lt;Button&gt;(R.id.button)</p></li>
			</ol>
			<p>This button, when tapped, will allow the user to stop the countdown. </p>
			<ol>
				<li value="12">Below that, add a click listener to the button that cancels the job:<p class="source-code">button.setOnClickListener {</p><p class="source-code">    job?.cancel()</p><p class="source-code">}</p></li>
			</ol>
			<p>When you click the button, it will cancel the coroutine. </p>
			<ol>
				<li value="13">Run the application again. Tap on the <strong class="bold">STOP</strong> button and notice that the counting down stops, as shown in the following figure:</li>
			</ol>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.03_B17773_new.jpg" alt="Figure 3.3 – Clicking the STOP button cancels the coroutine&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Clicking the STOP button cancels the coroutine</p>
			<p>Tapping <a id="_idIndexMarker145"/>on the <strong class="bold">STOP</strong> button cancels the coroutine with the <strong class="source-inline">job.cancel()</strong> call. This works because the coroutine is using the suspending <strong class="source-inline">delay</strong> function, which checks whether the coroutine is active or not.</p>
			<p>In this exercise, you have worked on adding code to cancel a running coroutine in an Android app by tapping on a button.</p>
			<p>There may be instances where you want to continue work even if you have canceled the job. To ensure the tasks will be done even if the coroutine is canceled, you can use <strong class="source-inline">withContext(NonCancellable)</strong> on<a id="_idIndexMarker146"/> the task.</p>
			<p>In this section, you learned how to cancel coroutines and how to make sure your coroutine code is cancelable. You will learn how to handle coroutine timeouts in the next section.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor046"/>Managing coroutine timeouts</h1>
			<p>In this section, you <a id="_idIndexMarker147"/>will learn about timeouts and how you can cancel your coroutines with a timeout. Setting a fixed amount of time after which to stop asynchronous code that is running longer than expected can help you save resources and immediately notify users of any issues.</p>
			<p>When your application is doing a background task, you may want to stop it because it is taking too long. You can manually track the time and cancel the task. Or you can use the <strong class="source-inline">withTimeout</strong> suspending function. With the <strong class="source-inline">withTimeout</strong> function, you can set your timeout in milliseconds or <strong class="source-inline">Duration</strong>. Once this timeout is exceeded, it will throw <strong class="source-inline">TimeOutCancellationException</strong>, a subclass of <strong class="source-inline">CancellationException</strong>. Here’s an example of how you can use <strong class="source-inline">withTimeout</strong>:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                withTimeout(5_000L) {</pre>
			<pre class="source-code">                    fetchMovies()</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>A timeout of 5,000 milliseconds (5 seconds) has been set for the coroutine. If the <strong class="source-inline">fetchMovies</strong> task takes longer than that, the coroutine will time out and throw <strong class="source-inline">TimeoutCancellationException</strong>.</p>
			<p>Another function <a id="_idIndexMarker148"/>you can use is <strong class="source-inline">withTimeoutOrNull</strong>. It is similar to the <strong class="source-inline">withTimeout</strong> function, but it will return null if the timeout was exceeded. Here’s an example of how you can use <strong class="source-inline">withTimeoutOrNull</strong>:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = async {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            val movies = withTimeoutOrNull(5_000L) {</pre>
			<pre class="source-code">                job.await()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The coroutine will return null if <strong class="source-inline">fetchMovies</strong> times out after 5 seconds, and if not, it will return the list of movies fetched.</p>
			<p>As you learned in the previous section, the coroutine must be cancelable so that it will be canceled after the timeout. In the next section, you will learn how to handle the cancelation exception <a id="_idTextAnchor047"/>from coroutines.</p>
			<p>In this section, you have learned about coroutine timeouts and how you can set an amount of time after which to automatically cancel a coroutine.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor048"/>Catching exceptions in coroutines</h1>
			<p>In this section, you<a id="_idIndexMarker149"/> will learn about coroutine exceptions and how to handle them in your application. As it is always possible that your coroutines will fail, it is important to learn how to catch exceptions so that you can avoid crashes and notify your users.</p>
			<p>To handle <a id="_idIndexMarker150"/>exceptions in your coroutines, you can simply use <strong class="source-inline">try-catch</strong>. For example, if you have a coroutine started with a <strong class="source-inline">launch</strong> coroutine builder, you can do the following to handle exceptions:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            try {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            } catch (exception: Exception) {</pre>
			<pre class="source-code">                Log.e("MovieViewModel",</pre>
			<pre class="source-code">                  exception.message.toString())</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>If <strong class="source-inline">fetchMovies</strong> has an exception, <strong class="source-inline">ViewModel</strong> will write the exception message to the logs.</p>
			<p>If your coroutine was built using the <strong class="source-inline">async</strong> coroutine builder, the exception will be thrown when<a id="_idIndexMarker151"/> you call the <strong class="source-inline">await</strong> function on the <strong class="source-inline">Deferred</strong> object. Your code to handle the <a id="_idIndexMarker152"/>exception would look like the following:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = async {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            var movies = emptyList&lt;Movie&gt;()</pre>
			<pre class="source-code">            try {</pre>
			<pre class="source-code">                movies = job.await()</pre>
			<pre class="source-code">            } catch (exception: Exception) {</pre>
			<pre class="source-code">                Log.e("MovieViewModel",</pre>
			<pre class="source-code">                  exception.message.toString())</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>If an exception is encountered while the <strong class="source-inline">fetchMovies</strong> call is running, the movies list will be an empty list of movies, and <strong class="source-inline">ViewModel</strong> will write the exception message to the logs.</p>
			<p>When a coroutine encounters an exception, it will cancel the job and pass on the exception to its parent. This parent coroutine will be canceled, as well as its children. Exceptions in the child coroutines will not affect the parent and its sibling coroutines if you use <strong class="source-inline">SupervisorJob</strong> as follows:</p>
			<ul>
				<li>Creating the coroutine scope with the suspending <strong class="source-inline">supervisorScope{}</strong> builder</li>
				<li>Using <strong class="source-inline">SupervisorJob</strong> for your coroutine scope: <strong class="source-inline">CoroutineScope(SupervisorJob())</strong></li>
			</ul>
			<p>If the<a id="_idIndexMarker153"/> exception of your coroutine is a subclass of <strong class="source-inline">CancellationException</strong>, for example, <strong class="source-inline">TimeoutCancellationException</strong> or a custom one you pass to the <strong class="source-inline">cancel</strong> function, the <a id="_idIndexMarker154"/>exception will not be transmitted to the parent. </p>
			<p>When handling coroutine exceptions, you can also use a single place to handle these exceptions with <strong class="source-inline">CoroutineExceptionHandler</strong>. <strong class="source-inline">CoroutineExceptionHandler</strong> is a coroutine context element that you can add to your coroutine to handle uncaught exceptions. The following lines of code show how you can use it:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    private val exceptionHandler =</pre>
			<pre class="source-code">      CoroutineExceptionHandler { _, exception -&gt;</pre>
			<pre class="source-code">        Log.e("MovieViewModel",</pre>
			<pre class="source-code">          exception.message.toString())</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    private val scope = CoroutineScope(exceptionHandler)</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The exceptions from the coroutines started from the scope will be handled by <strong class="source-inline">exceptionHandler</strong>, if it’s not handled wherever an error could occur, which will write the exception message to the logs.</p>
			<p>Let’s try to add code to handle exceptions in your coroutines.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor049"/>Exercise 3.02 – catching exceptions in your coroutines</h2>
			<p>In this exercise, you will <a id="_idIndexMarker155"/>continue working on the application that displays on <strong class="source-inline">TextView</strong> a number from 100 and slowly decreases it down to 0. You<a id="_idIndexMarker156"/> will be adding code to handle exceptions in the coroutine:</p>
			<ol>
				<li value="1">Open the countdown app you built in the previous exercise.</li>
				<li>Go the <strong class="source-inline">MainActivity</strong> file and at the end of the countdown function, add the following to simulate an exception:<p class="source-code">if ((0..9).random() == 0) throw Exception("An error</p><p class="source-code">  occurred")</p></li>
			</ol>
			<p>This will generate a random number from 0 to 9 and if it’s 0, it will throw an exception. It will simulate the coroutine encountering an exception.</p>
			<ol>
				<li value="3">Run the application. It will start to count down and some point later, it will throw the exception and crash the app. </li>
				<li>Surround the code in your coroutine with a <strong class="source-inline">try-catch</strong> block to catch the exception in the app:<p class="source-code">job = scope.launch {</p><p class="source-code">    try {</p><p class="source-code">        while (count &gt; 0) {</p><p class="source-code">            delay(100)</p><p class="source-code">            countdown()</p><p class="source-code">        }</p><p class="source-code">    } catch (exception: Exception) {</p><p class="source-code">        //TODO</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This will catch the exception from the countdown function. The app will no longer crash but you will need to inform the user about the exception.</p>
			<ol>
				<li value="5">Inside<a id="_idIndexMarker157"/> the <strong class="source-inline">catch</strong> block, replace <strong class="source-inline">//TODO</strong> with <strong class="source-inline">Snackbar</strong> to display the exception message:<p class="source-code">Snackbar.make(textView, exception.message.toString(),</p><p class="source-code">  Snackbar.LENGTH_LONG).show()</p></li>
			</ol>
			<p>This will display <a id="_idIndexMarker158"/>a snackbar message with the text <strong class="source-inline">An error occurred</strong>, which is the message of the exception.</p>
			<ol>
				<li value="6">Run the application again. It will start to count down but instead of crashing, a snackbar message will be displayed, as shown in the following figure:</li>
			</ol>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.04_B17773_new.jpg" alt="Figure 3.4 – Snackbar displayed when the coroutine has encountered the exception&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Snackbar displayed when the coroutine has encountered the exception</p>
			<p>In this<a id="_idIndexMarker159"/> exercise, you updated your application so that it can <a id="_idIndexMarker160"/>handle exceptions in the coroutines instead of crashing.</p>
			<p>In this section, you have learned about coroutine exceptions and how you can catch them in your Android apps. </p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor050"/>Summary</h1>
			<p>In this chapter, you learned about coroutine cancelations. You can cancel coroutines by using the <strong class="source-inline">cancel</strong> or <strong class="source-inline">cancelAndJoin</strong> function from the coroutine job or the <strong class="source-inline">cancel</strong> function from the coroutine scope. </p>
			<p>You learned that a coroutine cancelation needs to be cooperative. You also learned how you can change your code to make your coroutine cancelable by using <strong class="source-inline">isActive</strong> checks or by using suspending functions from the <strong class="source-inline">kotlinx.coroutines</strong> package.</p>
			<p>Then, you learned about coroutine timeouts. You can set a timeout (in milliseconds or <strong class="source-inline">Duration</strong>) using <strong class="source-inline">withTimeout</strong> or <strong class="source-inline">withTimeoutOrNull</strong>. </p>
			<p>You also learned about coroutine exceptions and how to catch them. <strong class="source-inline">try-catch</strong> blocks can be used to handle exceptions. You can also use <strong class="source-inline">CoroutineExceptionHandler</strong> in your coroutine scope to catch and handle exceptions in a single location. </p>
			<p>Finally, you worked on an exercise to add cancelation to a coroutine and another exercise to update your code to handle coroutine exceptions.</p>
			<p>In the next chapter, you will dive into creating and running tests for the coroutines in your Android projects.</p>
		</div>
	</body></html>