<html><head></head><body>
		<div><h1 id="_idParaDest-40"><em class="italic"><a id="_idTextAnchor042"/>Chapter 3</em>: Handling Coroutine Cancelations and Exceptions</h1>
			<p>In the previous chapter, you dove deep into Kotlin coroutines and learned how to use them for asynchronous programming in Android with simple code. You learned how to create coroutines with coroutine builders. Finally, you explored coroutine dispatchers, coroutine scopes, coroutine contexts, and jobs.</p>
			<p>Coroutines can be canceled when their purpose has been fulfilled or their job has been done. You can also cancel them based on specific instances in your app, such as when you want users to manually stop a task with a tap of a button. Coroutines do not always succeed and can fail; developers must be able to handle these cases so that the app will not crash, and they can inform the users by displaying a toast or snackbar message.</p>
			<p>In this chapter, we will start by understanding coroutine cancelation. You will learn how to cancel coroutines and handle cancelations and timeouts for your coroutines. Then, you will learn how to manage failures and exceptions that can happen in your coroutines.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Canceling coroutines</li>
				<li>Managing coroutine timeouts</li>
				<li>Catching exceptions in coroutines</li>
			</ul>
			<p>By the end of this chapter, you will understand coroutine cancelations and how you can make your coroutines cancelable. You will be able to add and handle timeouts in your coroutines. You will also know how to add code to catch exceptions in your coroutines.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor043"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: Intel Core i5 or equivalent or higher, 4 GB RAM minimum, and 4 GB available space.</p>
			<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter03">https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor044"/>Canceling coroutines</h1>
			<p>In this section, we<a id="_idIndexMarker129"/> will start by looking at coroutine cancelations Developers can cancel coroutines in their projects manually or programmatically. You must make sure your application can handle these cancelations.</p>
			<p>If your application is doing a long-running operation that is taking longer than expected and you think it could cause a crash, you might want to stop that task. You can also end tasks that are no longer necessary to free up memory and resources, such as when the user moves out of the activity that launched the task or closes the application. Users can also manually discontinue certain operations if you have that feature in your application. Coroutines make it easier for developers to cancel these tasks.</p>
			<p>If you are using <code>viewModelScope</code> from <code>ViewModel</code> or <code>lifecycleScope</code> from the Jetpack Lifecycle Kotlin extension libraries, you can easily create coroutines without manually handling the cancelation. When <code>ViewModel</code> is cleared, <code>viewModelScope</code> is automatically canceled, while <code>lifecycleScope</code> is automatically canceled when the life cycle is destroyed. If you created your own coroutine scope, you must add the cancelation yourself.</p>
			<p>In the previous chapter, you learned that using coroutine builders such as <code>launch</code> returns a <code>cancel()</code> function to cancel the coroutine. Take the following example:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            job.cancel()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <code>job.cancel()</code> function will cancel the coroutine launched to call the <code>fetchMovies()</code> function.</p>
			<p>After<a id="_idIndexMarker131"/> canceling the job, you may want to wait for the cancelation to be finished before continuing to the next task to avoid race conditions. You can do that by calling the <code>join</code> function after calling the <code>call</code> function:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            job.cancel()</pre>
			<pre class="source-code">            job.join()</pre>
			<pre class="source-code">            hideProgressBar()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Adding <code>job.join()</code> here would make the code wait for the job to be canceled before doing the next task, which is <code>hideProgressBar()</code>.</p>
			<p>You can also use the <code>Job.cancelAndJoin()</code> extension function, which is the same as calling <code>cancel</code> and then the <code>join</code> function:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">            job.cancelAndJoin()</pre>
			<pre class="source-code">            hideProgressBar()</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <code>cancelAndJoin</code> function <a id="_idIndexMarker132"/>simplifies the call to the <code>cancel</code> and <code>join</code> functions into a single line of code.</p>
			<p>Coroutine jobs can have child coroutine jobs. When you cancel a job, its child jobs (if there are any) will also be canceled, recursively.</p>
			<p>If your coroutine scope has multiple coroutines and you need to cancel all of them, you can use the <code>cancel</code> function from the coroutine scope instead of canceling the jobs one by one. This will cancel all the coroutines in the scope. Here’s an example of using the coroutine scope’s <code>cancel</code> function to cancel coroutines:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.Main +</pre>
			<pre class="source-code">      Job())</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        scope.launch {</pre>
			<pre class="source-code">            val job1 = launch {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            val job2 = launch {</pre>
			<pre class="source-code">                displayLoadingText()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    override fun onCleared() {</pre>
			<pre class="source-code">        scope.cancel()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In this example, when <code>scope.cancel()</code> is called, it will cancel both the <code>job1</code> and <code>job2</code> coroutines, which were created in the coroutine <code>scope</code> scope.</p>
			<p>Using the <code>cancel</code> function <a id="_idIndexMarker133"/>from the coroutine scope makes it easier to cancel multiple jobs launched with the specified scope. However, the coroutine scope won’t be able to launch new coroutines after you called the <code>cancel</code> function on it. If you want to cancel the scope’s coroutines but still want to create coroutines from the scope later, you can use <code>scope.coroutineContext.cancelChildren()</code> instead:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() { </pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.Main +</pre>
			<pre class="source-code">      Job()) </pre>
			<pre class="source-code">    init { </pre>
			<pre class="source-code">        scope.launch() { </pre>
			<pre class="source-code">            val job1 = launch { </pre>
			<pre class="source-code">                fetchMovies() </pre>
			<pre class="source-code">            } </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">            val job2 = launch { </pre>
			<pre class="source-code">                displayLoadingText()</pre>
			<pre class="source-code">            } </pre>
			<pre class="source-code">        } </pre>
			<pre class="source-code">    } </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    fun cancelAll() { </pre>
			<pre class="source-code">        scope.coroutineContext.cancelChildren()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">}</pre>
			<p>Calling the <code>cancelAll</code> function will cancel all the child jobs in the coroutine context of the scope. You will still be able to use the scope later to create coroutines.</p>
			<p>Canceling <a id="_idIndexMarker134"/>a coroutine will throw <code>CancellationException</code>, a special exception that indicates the coroutine was canceled. This exception will not crash the application. You will learn more about coroutines and exceptions later in this chapter.</p>
			<p>You can also pass a subclass of <code>CancellationException</code> to the <code>cancel</code> function to specify a different cause:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() { </pre>
			<pre class="source-code">private lateinit var movieJob: Job</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    init { </pre>
			<pre class="source-code">        movieJob = scope.launch() { </pre>
			<pre class="source-code">            fetchMovies() </pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    fun stopFetching() { </pre>
			<pre class="source-code">        movieJob.cancel(CancellationException("Cancelled by</pre>
			<pre class="source-code">          user"))</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">}</pre>
			<p>This cancels the <code>movieJob</code> job with <code>CancellationException</code> containing the message <code>Cancelled by user</code> as the cause when the user calls the <code>stopFetching</code> function.</p>
			<p>When you <a id="_idIndexMarker135"/>cancel a coroutine, the coroutine’s job’s state will change to <code>Cancelling</code>. It won’t automatically go to the <code>Cancelled</code> state and cancel the coroutine. The coroutine can continue to run even after the cancelation, unless your coroutine has code that can stop it from running. These states of a job and its life cycle are summarized in the following diagram:</p>
			<div><div><img src="img/Figure_3.1_B17773.jpg" alt="Figure 3.1 – Coroutine job life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Coroutine job life cycle</p>
			<p>Your <a id="_idIndexMarker136"/>coroutine code needs to cooperate to be cancelable. The coroutine should handle cancelations as quickly as possible. It must check for cancelations of the coroutine and if the coroutine is already canceled, it throws <code>CancellationException</code>.</p>
			<p>One way to make your coroutine cancelable is to check whether the coroutine job is active (still running or completing) or not by using <code>isActive</code>. The value of <code>isActive</code> will become false once the coroutine job changes its state to <code>Cancelling</code>, <code>Cancelled</code>, or <code>Completed</code>. You can make your coroutine cancelable with <code>isActive</code> with the following approaches:</p>
			<ul>
				<li>Perform tasks while <code>isActive</code> is true.</li>
				<li>Perform tasks only if <code>isActive</code> is true.</li>
				<li>Return or throw an exception if <code>isActive</code> is false.</li>
			</ul>
			<p>Another function you can also use is <code>Job.ensureActive()</code>. It will check whether the coroutine job is active, and if it’s not, it will throw <code>CancellationException</code>.</p>
			<p>Here’s an example of how you can make your coroutine cancelable with <code>isActive</code>:</p>
			<pre class="source-code">class SensorActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.IO)</pre>
			<pre class="source-code">    private lateinit var job: Job</pre>
			<pre class="source-code">   …</pre>
			<pre class="source-code">    private fun processSensorData() {</pre>
			<pre class="source-code">        job = scope.launch {</pre>
			<pre class="source-code">            if (isActive) {</pre>
			<pre class="source-code">                val data = fetchSensorData()</pre>
			<pre class="source-code">                saveData(data)</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    fun stopProcessingData() {</pre>
			<pre class="source-code">        job.cancel()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker137"/>coroutine in the <code>processSensorData</code> function will check whether the job is active and will only proceed with the task if the value of <code>isActive</code> is true.</p>
			<p>Another way to make your coroutine code cancelable is to use suspending functions from the <code>kotlinx.coroutines</code> package, such as <code>yield</code> or <code>delay</code>. The <code>yield</code> function yields a thread (or a thread pool) of the current coroutine dispatcher to other coroutines to run. </p>
			<p>The <code>yield</code> and <code>delay</code> functions already check for cancelation and stop the execution or throw <code>CancellationException</code>. Thus, you no longer need to manually check for cancelation when you are using them in your coroutines. Here’s an example using the preceding <a id="_idIndexMarker138"/>code snippet, which has been updated with suspending function delay to make the coroutine cancelable:</p>
			<pre class="source-code">class SensorActivity : AppCompatActivity() {</pre>
			<pre class="source-code">    private val scope = CoroutineScope(Dispatchers.IO)</pre>
			<pre class="source-code">    private lateinit var job: Job</pre>
			<pre class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        processSensorData()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private fun processSensorData() {</pre>
			<pre class="source-code">        job = scope.launch {</pre>
			<pre class="source-code">            delay (1_000L)</pre>
			<pre class="source-code">            val data = fetchSensorData()</pre>
			<pre class="source-code">            saveData(data)</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    fun stopProcessingData() {</pre>
			<pre class="source-code">        job.cancel()</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The <code>delay</code> suspending <a id="_idIndexMarker139"/>function will check whether the coroutine job is canceled and will throw <code>CancellationException</code> if it is, making your coroutine cancelable.</p>
			<p>Let’s learn how to implement a coroutine cancelation for an Android project in the next section.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor045"/>Exercise 3.01 – canceling coroutines in an Android app</h2>
			<p>In this exercise, you<a id="_idIndexMarker140"/> will work on an application that uses a coroutine that slowly counts down from 100 to 0 and displays the value on <code>TextView</code>. You will then add a button to cancel the coroutine to stop the countdown before it reaches 0:</p>
			<ol>
				<li>Create a new project in Android Studio. Don’t change the suggested name of <code>MainActivity</code> for the activity.</li>
				<li>Open the <code>app/build.gradle</code> file and add the dependency for <code>kotlinx-coroutines-android</code>:<pre>implementation ‘org.jetbrains.kotlinx:kotlinx-
  coroutines-android:1.6.0’</pre></li>
			</ol>
			<p>This will add the <code>kotlinx-coroutines-core</code> and <code>kotlinx-coroutines-android</code> libraries to your project, allowing you to use coroutines in your code.</p>
			<ol>
				<li value="3">Open the <code>activity_main.xml</code> layout file and add an <code>id</code> attribute to <code>TextView</code>:<pre>&lt;TextView
    android:id="@+id/textView"
    style="@style/TextAppearance.AppCompat.Large"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    tools:text="0" /&gt;</pre></li>
			</ol>
			<p>The <code>id</code> attribute will allow you to change the content of this <code>TextView</code> later.</p>
			<ol>
				<li value="4">Open<a id="_idIndexMarker141"/> the <code>MainActivity</code> file. Add the following properties to the <code>MainActivity</code> class:<pre>private val scope = CoroutineScope(Dispatchers.Main)
private?var job: Job? = null
private lateinit var textView: TextView
private var count = 100</pre></li>
				<li>The first line specifies the scope for the coroutine, <code>CoroutineScope</code>, with <code>Dispatchers.Main</code> as the dispatcher. The second line creates a <code>job</code> property for the coroutine job. The <code>textView</code> property will be used to display the countdown text and <code>count</code> initializes the countdown to 100. In the <code>onCreate</code> function of the <code>MainActivity</code> file, initialize the value for <code>TextView</code>:<pre>textView = findViewById(R.id.textView)</pre></li>
			</ol>
			<p>You will update this <code>textView</code> with the decreasing value of value later.</p>
			<ol>
				<li value="6">Create a countdown function that will do the counting down of the value:<pre>private fun countdown() {
    count--
    textView.text = count.toString()
}</pre></li>
			</ol>
			<p>This decreases the value of <code>count</code> by 1 and displays it on the text view.</p>
			<ol>
				<li value="7">In the <code>onCreate</code> function, below the <code>textView</code> initialization, add the following <a id="_idIndexMarker142"/>to start the coroutine to count down the value and display it on the text view:<pre>job = scope.launch {
    while (count &gt; 0) {
        delay(100)
        countdown()
    }
} </pre></li>
			</ol>
			<p>This will call the countdown function every <code>0.1</code> seconds, which will count down and display the value on the text view.</p>
			<ol>
				<li value="8">Run the application. You will see that it slowly counts down and displays the value from 100 to 0, similar to the following:</li>
			</ol>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<div><div><img src="img/Figure_3.02_B17773_new.jpg" alt="Figure 3.2 – The app counting down from 100 to 0&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The app counting down from 100 to 0</p>
			<ol>
				<li value="9">Open<a id="_idIndexMarker143"/> the <code>strings.xml</code> file and add a string for the button:<pre>&lt;string name="stop"&gt;Stop&lt;/string&gt;</pre></li>
			</ol>
			<p>You will use this as the text for the button to stop the countdown. </p>
			<ol>
				<li value="10">Go to the <code>activity_main.xml</code> file again and add a button below <code>TextView</code>:<pre>&lt;Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text="@string/stop"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/textView" /&gt;</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker144"/>will add a <code>Button</code> below <code>TextView</code>. The button will be used to stop the countdown later. </p>
			<ol>
				<li value="11">Open <code>MainActivity</code> and after the job initialization, create a variable for the button:<pre>val button = findViewById&lt;Button&gt;(R.id.button)</pre></li>
			</ol>
			<p>This button, when tapped, will allow the user to stop the countdown. </p>
			<ol>
				<li value="12">Below that, add a click listener to the button that cancels the job:<pre>button.setOnClickListener {
    job?.cancel()
}</pre></li>
			</ol>
			<p>When you click the button, it will cancel the coroutine. </p>
			<ol>
				<li value="13">Run the application again. Tap on the <strong class="bold">STOP</strong> button and notice that the counting down stops, as shown in the following figure:</li>
			</ol>
			<div><div><img src="img/Figure_3.03_B17773_new.jpg" alt="Figure 3.3 – Clicking the STOP button cancels the coroutine&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Clicking the STOP button cancels the coroutine</p>
			<p>Tapping <a id="_idIndexMarker145"/>on the <code>job.cancel()</code> call. This works because the coroutine is using the suspending <code>delay</code> function, which checks whether the coroutine is active or not.</p>
			<p>In this exercise, you have worked on adding code to cancel a running coroutine in an Android app by tapping on a button.</p>
			<p>There may be instances where you want to continue work even if you have canceled the job. To ensure the tasks will be done even if the coroutine is canceled, you can use <code>withContext(NonCancellable)</code> on<a id="_idIndexMarker146"/> the task.</p>
			<p>In this section, you learned how to cancel coroutines and how to make sure your coroutine code is cancelable. You will learn how to handle coroutine timeouts in the next section.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor046"/>Managing coroutine timeouts</h1>
			<p>In this section, you <a id="_idIndexMarker147"/>will learn about timeouts and how you can cancel your coroutines with a timeout. Setting a fixed amount of time after which to stop asynchronous code that is running longer than expected can help you save resources and immediately notify users of any issues.</p>
			<p>When your application is doing a background task, you may want to stop it because it is taking too long. You can manually track the time and cancel the task. Or you can use the <code>withTimeout</code> suspending function. With the <code>withTimeout</code> function, you can set your timeout in milliseconds or <code>Duration</code>. Once this timeout is exceeded, it will throw <code>TimeOutCancellationException</code>, a subclass of <code>CancellationException</code>. Here’s an example of how you can use <code>withTimeout</code>:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch {</pre>
			<pre class="source-code">            val job = launch {</pre>
			<pre class="source-code">                withTimeout(5_000L) {</pre>
			<pre class="source-code">                    fetchMovies()</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>A timeout of 5,000 milliseconds (5 seconds) has been set for the coroutine. If the <code>fetchMovies</code> task takes longer than that, the coroutine will time out and throw <code>TimeoutCancellationException</code>.</p>
			<p>Another function <a id="_idIndexMarker148"/>you can use is <code>withTimeoutOrNull</code>. It is similar to the <code>withTimeout</code> function, but it will return null if the timeout was exceeded. Here’s an example of how you can use <code>withTimeoutOrNull</code>:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = async {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            val movies = withTimeoutOrNull(5_000L) {</pre>
			<pre class="source-code">                job.await()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            ...</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The coroutine will return null if <code>fetchMovies</code> times out after 5 seconds, and if not, it will return the list of movies fetched.</p>
			<p>As you learned in the previous section, the coroutine must be cancelable so that it will be canceled after the timeout. In the next section, you will learn how to handle the cancelation exception <a id="_idTextAnchor047"/>from coroutines.</p>
			<p>In this section, you have learned about coroutine timeouts and how you can set an amount of time after which to automatically cancel a coroutine.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor048"/>Catching exceptions in coroutines</h1>
			<p>In this section, you<a id="_idIndexMarker149"/> will learn about coroutine exceptions and how to handle them in your application. As it is always possible that your coroutines will fail, it is important to learn how to catch exceptions so that you can avoid crashes and notify your users.</p>
			<p>To handle <a id="_idIndexMarker150"/>exceptions in your coroutines, you can simply use <code>try-catch</code>. For example, if you have a coroutine started with a <code>launch</code> coroutine builder, you can do the following to handle exceptions:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            try {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            } catch (exception: Exception) {</pre>
			<pre class="source-code">                Log.e("MovieViewModel",</pre>
			<pre class="source-code">                  exception.message.toString())</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>If <code>fetchMovies</code> has an exception, <code>ViewModel</code> will write the exception message to the logs.</p>
			<p>If your coroutine was built using the <code>async</code> coroutine builder, the exception will be thrown when<a id="_idIndexMarker151"/> you call the <code>await</code> function on the <code>Deferred</code> object. Your code to handle the <a id="_idIndexMarker152"/>exception would look like the following:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    init {</pre>
			<pre class="source-code">        viewModelScope.launch() {</pre>
			<pre class="source-code">            val job = async {</pre>
			<pre class="source-code">                fetchMovies()</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            var movies = emptyList&lt;Movie&gt;()</pre>
			<pre class="source-code">            try {</pre>
			<pre class="source-code">                movies = job.await()</pre>
			<pre class="source-code">            } catch (exception: Exception) {</pre>
			<pre class="source-code">                Log.e("MovieViewModel",</pre>
			<pre class="source-code">                  exception.message.toString())</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>If an exception is encountered while the <code>fetchMovies</code> call is running, the movies list will be an empty list of movies, and <code>ViewModel</code> will write the exception message to the logs.</p>
			<p>When a coroutine encounters an exception, it will cancel the job and pass on the exception to its parent. This parent coroutine will be canceled, as well as its children. Exceptions in the child coroutines will not affect the parent and its sibling coroutines if you use <code>SupervisorJob</code> as follows:</p>
			<ul>
				<li>Creating the coroutine scope with the suspending <code>supervisorScope{}</code> builder</li>
				<li>Using <code>SupervisorJob</code> for your coroutine scope: <code>CoroutineScope(SupervisorJob())</code></li>
			</ul>
			<p>If the<a id="_idIndexMarker153"/> exception of your coroutine is a subclass of <code>CancellationException</code>, for example, <code>TimeoutCancellationException</code> or a custom one you pass to the <code>cancel</code> function, the <a id="_idIndexMarker154"/>exception will not be transmitted to the parent. </p>
			<p>When handling coroutine exceptions, you can also use a single place to handle these exceptions with <code>CoroutineExceptionHandler</code>. <code>CoroutineExceptionHandler</code> is a coroutine context element that you can add to your coroutine to handle uncaught exceptions. The following lines of code show how you can use it:</p>
			<pre class="source-code">class MovieViewModel: ViewModel() {</pre>
			<pre class="source-code">    private val exceptionHandler =</pre>
			<pre class="source-code">      CoroutineExceptionHandler { _, exception -&gt;</pre>
			<pre class="source-code">        Log.e("MovieViewModel",</pre>
			<pre class="source-code">          exception.message.toString())</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    private val scope = CoroutineScope(exceptionHandler)</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>The exceptions from the coroutines started from the scope will be handled by <code>exceptionHandler</code>, if it’s not handled wherever an error could occur, which will write the exception message to the logs.</p>
			<p>Let’s try to add code to handle exceptions in your coroutines.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor049"/>Exercise 3.02 – catching exceptions in your coroutines</h2>
			<p>In this exercise, you will <a id="_idIndexMarker155"/>continue working on the application that displays on <code>TextView</code> a number from 100 and slowly decreases it down to 0. You<a id="_idIndexMarker156"/> will be adding code to handle exceptions in the coroutine:</p>
			<ol>
				<li value="1">Open the countdown app you built in the previous exercise.</li>
				<li>Go the <code>MainActivity</code> file and at the end of the countdown function, add the following to simulate an exception:<pre>if ((0..9).random() == 0) throw Exception("An error
  occurred")</pre></li>
			</ol>
			<p>This will generate a random number from 0 to 9 and if it’s 0, it will throw an exception. It will simulate the coroutine encountering an exception.</p>
			<ol>
				<li value="3">Run the application. It will start to count down and some point later, it will throw the exception and crash the app. </li>
				<li>Surround the code in your coroutine with a <code>try-catch</code> block to catch the exception in the app:<pre>job = scope.launch {
    try {
        while (count &gt; 0) {
            delay(100)
            countdown()
        }
    } catch (exception: Exception) {
        //TODO
    }
}</pre></li>
			</ol>
			<p>This will catch the exception from the countdown function. The app will no longer crash but you will need to inform the user about the exception.</p>
			<ol>
				<li value="5">Inside<a id="_idIndexMarker157"/> the <code>catch</code> block, replace <code>//TODO</code> with <code>Snackbar</code> to display the exception message:<pre>Snackbar.make(textView, exception.message.toString(),
  Snackbar.LENGTH_LONG).show()</pre></li>
			</ol>
			<p>This will display <a id="_idIndexMarker158"/>a snackbar message with the text <code>An error occurred</code>, which is the message of the exception.</p>
			<ol>
				<li value="6">Run the application again. It will start to count down but instead of crashing, a snackbar message will be displayed, as shown in the following figure:</li>
			</ol>
			<div><div><img src="img/Figure_3.04_B17773_new.jpg" alt="Figure 3.4 – Snackbar displayed when the coroutine has encountered the exception&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Snackbar displayed when the coroutine has encountered the exception</p>
			<p>In this<a id="_idIndexMarker159"/> exercise, you updated your application so that it can <a id="_idIndexMarker160"/>handle exceptions in the coroutines instead of crashing.</p>
			<p>In this section, you have learned about coroutine exceptions and how you can catch them in your Android apps. </p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor050"/>Summary</h1>
			<p>In this chapter, you learned about coroutine cancelations. You can cancel coroutines by using the <code>cancel</code> or <code>cancelAndJoin</code> function from the coroutine job or the <code>cancel</code> function from the coroutine scope. </p>
			<p>You learned that a coroutine cancelation needs to be cooperative. You also learned how you can change your code to make your coroutine cancelable by using <code>isActive</code> checks or by using suspending functions from the <code>kotlinx.coroutines</code> package.</p>
			<p>Then, you learned about coroutine timeouts. You can set a timeout (in milliseconds or <code>Duration</code>) using <code>withTimeout</code> or <code>withTimeoutOrNull</code>. </p>
			<p>You also learned about coroutine exceptions and how to catch them. <code>try-catch</code> blocks can be used to handle exceptions. You can also use <code>CoroutineExceptionHandler</code> in your coroutine scope to catch and handle exceptions in a single location. </p>
			<p>Finally, you worked on an exercise to add cancelation to a coroutine and another exercise to update your code to handle coroutine exceptions.</p>
			<p>In the next chapter, you will dive into creating and running tests for the coroutines in your Android projects.</p>
		</div>
	</body></html>