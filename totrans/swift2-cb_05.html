<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Multitasking in Your App</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Word counting using threads</li><li class="listitem">Creating an SEO app</li><li class="listitem">Creating a CycloneChecker app</li><li class="listitem">Checking links of our website</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec41" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">Nowadays, multitasking is very common, as an application can do lots of things at the same time. If we have a multicore processor such as an iPhone 4S or newer, or an iPad 2 or newer, you can even improve the performance. Of course you shouldn't use multitasking for everything because commuting from one task to another countlessly can harm the performance.</p><p class="calibre7">In this chapter, we are going to learn different types of multitasking and when you should use each of them. First, we will start with threads, then we are going to see NSOperations, and at last, how to use the GCD.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec42" class="calibre1"/>Word counting using threads</h1></div></div></div><p class="calibre7">Sometimes, if <a id="id200" class="calibre1"/>you don't pay attention to multitasking, it <a id="id201" class="calibre1"/>might result in a frozen screen. As a developer and knowing what is going on in the application, we can wait, but as a user who doesn't know anything about the application operation, they may think that their app has hanged and that it is necessary to restart.</p><p class="calibre7">In this recipe, we are going to create another thread to prevent this situation. Creating threads can also be some kind of mechanism of dividing tasks in different tracks, making debugging easier.</p><p class="calibre7">Let's pretend that we need to count the number of words of a document. We will have two buttons, one that is going to do this task without using a thread and another one that will do the same task using a thread.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec120" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Before you start, you must have a text file. You can use any text file you want but to get a good result, you should have something big, like more than 30K. A suggestion is downloading an RFC of any protocol.</p><p class="calibre7">So, create a new <a id="id202" class="calibre1"/>project called <code class="email">Chapter 5 Thread</code>, add a file named <a id="id203" class="calibre1"/>
<code class="email">WordCounter.swift</code>, and let's start coding.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec121" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">In this recipe, we are going to start by downloading a file from the Internet and then we are going to work with it by following these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open your <a id="id204" class="calibre1"/>favorite web browser on your computer and download this text document: <a class="calibre1" href="https://www.ietf.org/rfc/rfc2821.txt">https://www.ietf.org/rfc/rfc2821.txt</a>.</li><li class="listitem" value="2">Drag the document into your project, preferably into your <strong class="calibre8">Supporting files</strong> group.<div><img src="img/00043.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Now click on the <code class="email">WordCounter.swift</code> file and create a class with the same name:<div><pre class="programlisting">class WordCounter:NSObject {
    private var file:String
    lazy private var _words = [String:Int]()
    var words:[String:Int] {
        return _words
    }</pre></div></li><li class="listitem" value="4">Now, let's create an initializer; as you can see, the only attribute we need to initialize is the file attribute:<div><pre class="programlisting">    init(file:String){
    super.init()
        self.file = file
    }</pre></div></li><li class="listitem" value="5">The next step is typing the execute method. Here we are going to open our file and <a id="id205" class="calibre1"/>count the number of words. Of course you <a id="id206" class="calibre1"/>can improve this method, but for now it should be enough for us:<div><pre class="programlisting">    func execute(){
        _words = [String:Int]()
        
        // First step opening the file
        var manager = NSFileManager.defaultManager()
        var data = manager.contentsAtPath(NSBundle.mainBundle().pathForResource(file, ofType: "txt")!)!
        var content = String(data: data, encoding:NSUTF8StringEnconding)!
        
        // spliting the documento into words
        var wordsArray = content.componentsSeparatedByString(" ")
        wordsArray = wordsArray.map({ (word) -&gt; String in
            return word.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())
        }) .map({ (word) -&gt; String in
            return word.lowercaseString
        }) .filter({(word) -&gt; Bool in
             if let regex = try? NSRegularExpression(pattern: "\\w+(-\\w+)*", options: .CaseInsensitive) {
               let matches = regex.matchesInString(word, options: nil, range: NSMakeRange(0, word.characters.count))
    return matches.count &gt; 0
}
            
        })
        
        // computing the results
        for word:String in wordsArray {
            if let tot = _words[word] {
                _words[word] = tot + 1
            }else{
                _words[word] = 1
            }
        }
    }
}</pre></div></li><li class="listitem" value="6">Now that we have the model part done, we can do the view and the controller part. Open <a id="id207" class="calibre1"/>your storyboard and add three buttons: one for counting the file words without using a thread, another one for using a <a id="id208" class="calibre1"/>thread, and another one for going to the website that is typed on the text field.<div><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre7">With iOS9, Apple <a id="id209" class="calibre1"/>introduced a new security feature called <strong class="calibre8">App Transport Security</strong> (<strong class="calibre8">ATP</strong>). This blocks all non-secure (HTTPS) URL requests, including with <code class="email">UIWebView</code>.</p></div></li><li class="listitem" value="7">For this recipe we will disable ATP; however, it is recommended that you follow the proper ATS procedures for any production applications. In your <code class="email">info.plist</code> file, add a new key <code class="email">NSAppTransportSecurity</code> and set its value to <code class="email">NSAllowsArbitraryLoads</code>. This will allow all URLs to load without error. As you can imagine, you have to add a text field and also a web view. You should have a layout similar to this one:<div><img src="img/00044.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">Now let's <a id="id210" class="calibre1"/>link the text field and the web view with the <a id="id211" class="calibre1"/>corresponding attributes. We also need to create two attributes to know the time when we started counting the words and the time we finished doing it. So, let's complete our view controller with this code:<div><pre class="programlisting">    @IBOutlet var textField: UITextField!
    @IBOutlet var webView: UIWebView!
    lazy private var start = CFAbsoluteTimeGetCurrent()
    lazy private var finish = CFAbsoluteTimeGetCurrent()</pre></div></li><li class="listitem" value="9">Once we have these attributes done, we can start with the easiest method. In this case, this method is the <code class="email">go</code> button event, which loads the web page on the web view:<div><pre class="programlisting">    @IBAction func loadWeb(sender: UIButton) {
        let url = NSURL(string: textField.text!)
        let request = NSURLRequest(URL: url!)
        webView.loadRequest(request)
    }</pre></div></li><li class="listitem" value="10">Now we have <a id="id212" class="calibre1"/>to create a method that will call the <a id="id213" class="calibre1"/>word counter. This method should be common to both buttons, to the one that processes with a thread, and the other that processes without a thread, so let's do a method now that is not bound by any button:<div><pre class="programlisting">    func countWords(file:String){
        let wordCounter = WordCounter(file: file)
        wordCounter.execute()
        finish = CFAbsoluteTimeGetCurrent()
        print("\(finish-start)")
        var result = ""
        for (total, word) in wordCounter.words.enumerate(){
            result += "\(word) -&gt; \(total)\n"
        }
        UIAlertView(title: "Result", message: result, delegate: nil, cancelButtonTitle: "Ok").show()
    }</pre></div></li><li class="listitem" value="11">To finish the application, we have to create the click event for each button:<div><pre class="programlisting">    @IBAction func countWordsWithoutThreads(sender: UIButton) {
        start = CFAbsoluteTimeGetCurrent()
        countWords("rfc2821")
    }

    @IBAction func countWordsWithThreads(sender: UIButton){
        start = CFAbsoluteTimeGetCurrent()
        let thread1 = NSThread(target: self, selector: Selector("countWords:"), object: "rfc2821")
        thread1.start()
    }</pre></div></li><li class="listitem" value="12">Now it's time to test the application; pay attention to the different behaviors. First, press the button that processes the words without a thread and after that, try to type anything on the text field. Until the word counter finishes, you won't be able to type anything. Once the operation has finished, press the button that works with a thread and try to type a URL and navigate through it. Now you are able to navigate while the program is processing something else.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec122" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Threads are like tracks of a program; even if you have lots of threads, you still share global variables or attributes like we did with the <code class="email">start</code> attribute. People used to relate threads with earning on performance; that's not exactly true.</p><p class="calibre7">If you have an operation with IO, such as reading a file, or using a sensor like Bluetooth, you can earn a good performance due to the fact that a processor can work while the I/O doesn't send a reply.</p><p class="calibre7">Although you can earn on performance when using I/O on our application, you will probably have a lower <a id="id214" class="calibre1"/>performance using threads. Why? This is because the <a id="id215" class="calibre1"/>program needs to waste time creating the thread and commuting between threads.</p><p class="calibre7">Why did we have better usability when we created a thread on this app? The reason is that anything that you do with the user interface is done on the main thread. If you have a large operation on this thread, as we had counting the words, it will prevent the program from rendering or answering an event until your operation is done.</p><p class="calibre7">Creating a new thread will make your application answer to the user interface while you are counting the words on another thread. In this case, we didn't earn or lose performance, but the user got a much better usability.</p><p class="calibre7">We could also see in this recipe the usage of regular expressions, which is a feature that made a computer language <a id="id216" class="calibre1"/>called Perl very famous, and other languages such as JavaScript also have this feature incorporated as part of their language. Unfortunately, that's not the case with Swift (or at least for this version). Regular expressions are very useful to find patterns and also to create some filters, such as validating e-mails, product codes, or URLs.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec123" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Unfortunately, the NSThread is not as complete as the <code class="email">posix</code> thread functions, as we don't have, for example, the join method. If your thread function is a C function, you can still use functions such as <code class="email">pthread_create</code> and <code class="email">pthread_join</code>.</p><p class="calibre7">In the next recipe, we <a id="id217" class="calibre1"/>are going to learn about NSOperation, which is recommended by Apple.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec43" class="calibre1"/>Creating an SEO app</h1></div></div></div><p class="calibre7">As you might <a id="id218" class="calibre1"/>know, nowadays it's very common to analyze a website to get a better result on search engines. Counting the words of a website is a common task to know how search engines retrieve information from our website. As we already have a <code class="email">WordCounter</code> class from the previous recipe, we are going to recycle it and create a new program that is to count the words of a website.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec124" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">First of all, check some URLs from a website that you would like to count the words of. It can be any website, but the idea is to have a few URLs to check that use a lot of words.</p><p class="calibre7">To know that the task has finished, we are going to show an icon, so you can download it from the book resources or you can download your own icon.</p><p class="calibre7">Once you have your URL list and your icon ready, let's create a project called <code class="email">Chapter 5 SEO</code>, add your icon, and let's code.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec125" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Follow these steps to create an SEO app:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, copy the <code class="email">WordCounter.swift</code> from the other previous recipe. To do it, just drag the file from a finder window to your project. Of course, it would be better if this file could be located in a common directory.<div><h3 class="title2"><a id="tip30" class="calibre1"/>Tip</h3><p class="calibre7">When you have files that could be used in other projects, it's a good idea to store them in a common directory.</p></div></li><li class="listitem" value="2">Now, click on this file and let's improve this code. First, let's remove the file attribute because we are going to read the file contents into the initializer. Second, let's create a new string attribute called <code class="email">content</code>.</li><li class="listitem" value="3">The next step is modifying the current initializer, just transferring the code that opens and reads the file to the initializer. You also need to create a new initializer that receives the contents instead of a file name. To summarize, now your <code class="email">WordCounter</code> may have a code like this one:<div><pre class="programlisting">class WordCounter:NSObject {
    lazy private var _words = [String:Int]()
    var words:[String:Int] {
        return _words
    }
    lazy private var content:String = ""
    
    init(file:String){
        super.init()
        let manager = NSFileManager.defaultManager()
        let data = manager.contentsAtPath(NSBundle.mainBundle().pathForResource(file, ofType: "txt")!)!
        content = NSString(data: data, encoding: NSUTF8StringEncoding) as! String
    }
    
    init(content:String){
        super.init()
        self.content = content
    }
    
    func execute(){
        _words = [String:Int]()

        // spliting the document into words
        var wordsArray = content.componentsSeparatedByString(" ")
        wordsArray = wordsArray.map({ (word) -&gt; String in
            return word.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())
        }) .map({ (word) -&gt; String in
            return word.lowercaseString
        }) .filter({(word) -&gt; Bool in
            if let regex = try? NSRegularExpression(pattern: "\\w+(-\\w+)*", options: .CaseInsensitive) {
              let matches = regex.matchesInString(word, options: nil, range: NSMakeRange(0, word.characters.count))
    return matches.count &gt; 0
}        
})
        
        // computing the results
        for word:String in wordsArray {
            if let tot = _words[word] {
                _words[word] = tot + 1
            }else{
                _words[word] = 1
            }
        }
    }
}</pre></div></li><li class="listitem" value="4">It's time to create the application interface. In this case, we will need a text field to let the user enter a URL, a label to show a message, a button to indicate that the user has finished writing a URL, and a table view, something <a id="id219" class="calibre1"/>similar to the following screenshot:<div><img src="img/00045.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Inherit the view controller from <code class="email">UITableViewDataSource</code> and from <code class="email">UITableViewDelegate</code> after that. Link the table view datasource and delegate with the view controller. Don't worry if the compiler complains about some missing functions; we are going to implement them in a while.</li><li class="listitem" value="6">Now, go to the view controller and let's create an auxiliary struct. This struct will help us <a id="id220" class="calibre1"/>to know whether the evaluation of the requested website is done and also the result. So, add the following code inside the view controller class:<div><pre class="programlisting">    struct UrlInfo {
        var url:String
        var finished:Bool = false
        lazy var words = [String:Int]()
        init(url:String){
            self.url = url
        }
    }</pre></div></li><li class="listitem" value="7">The next step is adding some attributes; in this case, we will need a text field for entering the URL, a table view, an array of <code class="email">UrlInfo</code>, and a queue for our operations:<div><pre class="programlisting">@IBOutlet let urlTextField: UITextField!
@IBOutlet let urlsTables: UITableView!
var urls = [UrlInfo]()
let queue = NSOperationQueue()</pre></div></li><li class="listitem" value="8">Now we can implement the button event, so link the button with a method called <code class="email">analyze</code> and type its code:<div><pre class="programlisting">    @IBAction func analyze(sender: UIButton) {
        var url = urlTextField.text.stringByReplacingOccurrencesOfString(" ", withString: "", options: [], range: nil)
        if url == "" {
            return
        }
        
        let position = self.urls.count
        self.urls.append(UrlInfo(url: url))
        self.urlsTables.reloadData()
        
        queue.addOperationWithBlock(){
            var data = NSData(contentsOfURL: NSURL(string: url)!)
            var textResponse = NSString(data: data!, encoding: NSASCIIStringEncoding) as! String
            print(textResponse)
            let wordCounter = WordCounter(content: textResponse)
            wordCounter.execute()
            self.urls[position].words = wordCounter.words
            self.urls[position].finished = true
            
            NSOperationQueue.mainQueue().addOperationWithBlock({
                self.urlsTables.reloadData()
            })
        }
    }</pre></div><div><h3 class="title2"><a id="tip31" class="calibre1"/>Tip</h3><p class="calibre7">While this code was written, my Xcode was updated and also the Swift API, so it was necessary to fix some parts of it. Consider this kind of change when you are coding with Swift.</p></div></li><li class="listitem" value="9">The last step is implementing the corresponding part of the table view. First, let's indicate <a id="id221" class="calibre1"/>the current number of cells of the table view:<div><pre class="programlisting">    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int{
        return urls.count
    }</pre></div></li><li class="listitem" value="10">Next, let's create a cell for the URL. In this case, when the URL has been computed, we are going to add an <code class="email">OK</code> icon:<div><pre class="programlisting">        func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell{
        var cell = urlsTables.dequeueReusableCellWithIdentifier("url") if cell == nil {
          cell = UITableViewCell(style: .Default, reuseIdentifier: "url")
            cell?.textLabel?.text = urls[indexPath.row].url
        }
        
        if self.urls[indexPath.row].finished {
            cell?.imageView?.image = UIImage(named: "ok.png")
        }else {
            cell?.imageView?.image = nil
        }
        return cell!
    }</pre></div></li><li class="listitem" value="11">And, of course, we need to show the result when the user selects a cell from the table view. This result is going to be shown only if the URL analysis has finished:<div><pre class="programlisting">    func tableView(tableView: UITableView, didHighlightRowAtIndexPath indexPath: NSIndexPath) {
        if urls[indexPath.row].finished {
            var result = ""
            for (total, word) in urls[indexPath.row].words.enumerate(){
                result += "\(word) -&gt; \(total)\n"
            }
            UIAlertView(title: "Result", message: result, delegate: nil, cancelButtonTitle: "Ok").show()   
        }
    }</pre></div></li><li class="listitem" value="12">Now the application is done. Try to check a URL and see its results.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec126" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">NSOperation <a id="id222" class="calibre1"/>is something built on the top level of the <strong class="calibre8">GCD (Grand Central Dispatch)</strong>, which is the way Apple does multitasking. The NSOperation <a id="id223" class="calibre1"/>needs a queue, which can be a new queue created by the programmer, or it could be an existing one.</p><p class="calibre7">As mentioned before, you have to consider that operations related to the user interface, such as refreshing the table view content, must be done on the main thread. Speaking in NSOperation terms, it should be done on the main queue. You can also have a low priority queue for those tasks that don't need to finish as soon as possible.</p><p class="calibre7">One advantage about NSOperation over threads is that it is more optimized for multicore devices, meaning a better performance on Mac computers and new iPhones and iPads.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec127" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Of course, you can use threads and NSOperation together but you have to take care with it. Avoid using NSOperation with fork on OS X, for example. In the next recipe, we are going to use the GCD directly, which could give us more flexibility.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec44" class="calibre1"/>Creating a CycloneChecker app</h1></div></div></div><p class="calibre7">Sometimes it's good <a id="id224" class="calibre1"/>that our mobile phone, or even our computer, can tell us weather predictions, mainly when some kind of disaster is going to come, such as a storm, an earthquake, or a cyclone. To do this, the application must be continuously asking for weather predictions on the Internet but it shouldn't block the application operation.</p><p class="calibre7">In this recipe, we are going to develop an application that will ask every five minutes for cyclone predictions; in the case of finding one cyclone, it will write down the URL where the user can retrieve information about the found cyclone. If the application is on in the background, it will throw a notification.</p><p class="calibre7">Here we are going <a id="id225" class="calibre1"/>to create a multitask using the <strong class="calibre8">Grand Central Dispatch</strong>, which is the method Apple recommends.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec128" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create an application <a id="id226" class="calibre1"/>called <code class="email">Chapter 5 Cyclones</code> and add a file called <code class="email">CycloneChecker.swift</code>, also check whether you have an Internet connection on your computer or device.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec129" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Follow these steps for creating the CycloneChecker app:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to specify that this class (<code class="email">CycloneChecker</code>) is a <code class="email">XMLParserDelegate</code>, which forces us to inherit from <code class="email">NSObject</code>:<div><pre class="programlisting">class CycloneChecker:NSObject, NSXMLParserDelegate{</pre></div></li><li class="listitem" value="2">Now add its attribute. We will need a constant that will represent the frequency that the app is going to check about cyclones, another constant that contains the URLs where the application can check the cyclone predictions, an attribute that indicates the current website we are visiting, a queue to add our operation, an attribute to indicate whether the object is working or not, and a closure to run every time we find a cyclone:<div><pre class="programlisting">    private let interval = 300
    private let urls = ["http://www.nhc.noaa.gov/nhc_at1.xml",
    "http://www.nhc.noaa.gov/nhc_at2.xml",
    "http://www.nhc.noaa.gov/nhc_at3.xml",
    "http://www.nhc.noaa.gov/nhc_at4.xml",
    "http://www.nhc.noaa.gov/nhc_at5.xml"]
    private var position = 0
    private let queue = dispatch_queue_create("cyclone.queue",DISPATCH_QUEUE_SERIAL)
    private var started = false
    var action: (String) -&gt; (Void) = {(url) -&gt; Void in
    }</pre></div></li><li class="listitem" value="3">The first two methods that we are going to implement are the methods that make the object work or stop working:<div><pre class="programlisting">    func start(){
        started = true
        initQueue()
    }
    func stop(){
        started = false
    }</pre></div></li><li class="listitem" value="4">As you can <a id="id227" class="calibre1"/>see, we need a method called <code class="email">initQueue,</code> which will add the tasks to the object queue:<div><pre class="programlisting">    private func initQueue(){
        self.position = 0
        for i in 1...urls.count {
            dispatch_async(queue, { () -&gt; Void in
              if self.started {
                  print("checking \(self.position)")
                  var xmlParser = NSXMLParser(contentsOfURL: NSURL(string: self.urls[self.position])!)
                  xmlParser?.delegate = self
                  xmlParser?.parse()
              }
          })
      }
      dispatch_async(queue, { () -&gt; Void in
          if self.started {
              sleep(UInt32(self.interval))
              self.initQueue()
          }
      })
  }</pre></div></li><li class="listitem" value="5">Once the object finds a cyclone, it needs to notify the user about it:<div><pre class="programlisting">    func parser(parser: NSXMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : AnyObject]){
        if elementName == "cyclone"{
            self.action(self.urls[self.position])
        }
    }</pre></div></li><li class="listitem" value="6">To finish this class, we need to mark that the current XML has been parsed; next time, we will need to parse the next one:<div><pre class="programlisting">    func parserDidEndDocument(parser: NSXMLParser) {
        position += 1
    }</pre></div></li><li class="listitem" value="7">The CycloneChecker is done; the next step is creating the view, so click on the storyboard, add two buttons on it (one to start checking and another one to stop checking), a label to indicate the object status (running or stopped), and a text field to <a id="id228" class="calibre1"/>display a text that a cyclone is coming.<div><img src="img/00046.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="8">As you might imagine, now we are going to code the attributes, start linking the views we've <a id="id229" class="calibre1"/>added on the storyboard, and create an object of <code class="email">CycloneChecker</code>:<div><pre class="programlisting">    var cycloneChecker = CycloneChecker()
    @IBOutlet var buttonStart: UIButton!
    @IBOutlet var buttonStop: UIButton!
    @IBOutlet var textView: UITextView!
    @IBOutlet var labelStatus: UILabel!</pre></div></li><li class="listitem" value="9">Let's initialize the application on the <code class="email">viewDidLoad</code> method, adding an action to the <code class="email">CycloneChecker</code>. In this case, we are going to add it to the text view and send a user notification if the application is on in the background:<div><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        cycloneChecker.action = {(url) -&gt; Void in
            if UIApplication.sharedApplication().applicationState == .Background   {
                var localNotification:UILocalNotification = UILocalNotification()
                localNotification.alertAction = "Cyclone found"
                localNotification.alertBody = "A cyclone was found. visit \(url) for more information"
                localNotification.fireDate = NSDate(timeIntervalSinceNow: 10)
                UIApplication.sharedApplication().scheduleLocalNotification(localNotification)
            }
            dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
                self.textView.text = "\(self.textView.text)\nA cyclone was found. visit \(url) for more information"
            })
        }
        self.textView.text = ""
        self.textView.layer.borderWidth = 0.5
    }</pre></div></li><li class="listitem" value="10">Now we can finish the view controller, adding the <code class="email">start</code> and <code class="email">stop</code> events:<div><pre class="programlisting">    @IBAction func start(sender: AnyObject) {
        cycloneChecker.start()
        labelStatus.text = "Status: started"
        buttonStart.enabled = false
        buttonStop.enabled = true
    }
        @IBAction func stop(sender: AnyObject) {
        cycloneChecker.stop()
        labelStatus.text = "Status: stopped"
        buttonStart.enabled = true
        buttonStop.enabled = false
    }</pre></div></li><li class="listitem" value="11">To finish the <a id="id230" class="calibre1"/>application, you need to add on the app delegate, preferably on the method <code class="email">didFinishLauchingWithOptions</code>. Use the following code to use notifications:<div><pre class="programlisting">    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [String: AnyObject]?) -&gt; Bool {
        if UIApplication.instancesRespondToSelector(Selector("registerUserNotificationSettings:"))
            {
        
            application.registerUserNotificationSettings(UIUserNotificationSettings(forTypes: UIUserNotificationType.Sound | UIUserNotificationType.Alert |
            UIUserNotificationType.Badge, categories: nil))
            }
        return true
    }</pre></div></li><li class="listitem" value="12">Lastly, you need to test the app, so press the play button and check whether there is a cyclone near you. Hope not.<div><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre7">Don't forget to allow notifications if you are using iOS 8 or above.</p></div></li><li class="listitem" value="13">Once the application launches, you should see something similar to the following screenshot. Tap <strong class="calibre8">OK</strong> to allow notifications, as shown:<div><img src="img/00047.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec130" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">This app works using the Grand Central Dispatch, which will create a thread and a queue for running the assigned tasks. As it creates a separated thread, it doesn't block the user interface, and as it <a id="id231" class="calibre1"/>is not creating a thread for each task, the application doesn't lose performance due to thread commuting.</p><p class="calibre7">As you could see when the queue was created, we had to specify that we would like a serial queue, meaning that a task doesn't start until the previous one finishes. We also used a function called dispatch async, meaning that the caller isn't going to wait to finish the task, so the code can continue running concurrently to the queue tasks.</p><p class="calibre7">Of course, when we find a cyclone, we need to write this information on the text view, which is required on the main thread, so that's the reason that we had to create another task adding it to the main queue.</p><p class="calibre7">Another interesting part is <a id="id232" class="calibre1"/>that one task added to our queue had a call to the <code class="email">sleep</code> function. As you know, the new queue is executed on a separated thread and the next task isn't going to run until the current one finishes, so it's perfectly allowed to use this function.</p><p class="calibre7">If you haven't worked with notifications before on the view controller, here you have a sample of it. Don't forget that notifications work only with iOS 7 or higher, and on iOS 8, the user must accept the permission to send notifications.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec131" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">We still have two pending topics: the first one is using concurrent queues and the other one is preventing two tasks changing the same object at the same time. Both topics are going to be revealed in the next recipe.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec45" class="calibre1"/>Checking links of our website</h1></div></div></div><p class="calibre7">In this chapter, we <a id="id233" class="calibre1"/>created an application that could help us position our website by checking its word frequencies, but as you might know, SEO is not only about counting words, it's also about website links.</p><p class="calibre7">In this recipe, we are going to check the links of a website; in this case, as we are using the networks, so we can do tasks in parallel.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec132" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a project called <code class="email">Chapter 5 weblinks</code> and add a file called <code class="email">LinkChecker.swift</code>. Check whether you have an Internet connection on your simulator or device.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec133" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Once you have checked <a id="id234" class="calibre1"/>that your device or simulator has an Internet connection, follow these steps for creating the Link Checker app:</p><div><ol class="orderedlist"><li class="listitem" value="1">Before we start creating the <code class="email">LinkChecker</code> class, we will need to create an auxiliary class, which is going to store the common information between objects of type <code class="email">LinkChecker</code>. This class is going to be called <code class="email">UrlManager</code> and it needs to store the queue, a file handler to log the found URLs, an array with the URLs, and <a id="id235" class="calibre1"/>a constant to indicate the maximum number of links we want (some websites have a lot of links):<div><pre class="programlisting">private class UrlManager {
    enum UrlAddStatus {
        case OK, FULL, REPEATED, WRONG_URL
    }

    private var _queue = dispatch_queue_create("concurrentqueue", DISPATCH_QUEUE_CONCURRENT)
    var queue:dispatch_queue_t{
        return _queue
    }
    private var fileHandle:NSFileHandle?
    private lazy var _urls = [String]()
    let LIMIT = 10</pre></div></li><li class="listitem" value="2">Now, let's create some auxiliary functions to help this object know whether a URL should be stored or not. One of them will tell it whether a URL is already stored on our list, the other one is going to tell whether the list is full, the third one will check whether the URL is valid or not, and the last one will log the URL on a file:<div><pre class="programlisting">    func contains(url:String) -&gt; Bool{
        objc_sync_enter(self._urls)
        for u in self._urls {
            if u == url {
                objc_sync_exit(self._urls)
                return true
            }
        }
        objc_sync_exit(self._urls)
        return false
    }
    
    var full:Bool {
        return self._urls.count &gt;= self.LIMIT
    }
    
    private func validUrl(url:String) -&gt; Bool{
        var error:NSError?
        var regex = NSRegularExpression(pattern:"^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$", options: .CaseInsensitive, error: &amp;error)
        let matches = regex?.matchesInString(url, options: nil, range: NSMakeRange(0, count(url)))
        return matches?.count &gt; 0
    }

    private func writeMessage(message:String){
        objc_sync_enter(self.fileHandle)
        self.fileHandle?.writeData(message.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!)
        objc_sync_exit(self.fileHandle)
    }</pre></div></li><li class="listitem" value="3">Now let's <a id="id236" class="calibre1"/>code the initializer; in this case, we only need <a id="id237" class="calibre1"/>to open the log file:<div><pre class="programlisting">    init(){
        var path:String = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as! String
        let fullpath = (path as NSString).stringByAppendingPathComponent("application.log")
        NSFileManager.defaultManager().createFileAtPath(fullpath, contents: nil, attributes: nil)
        self.fileHandle=NSFileHandle(forWritingAtPath:fullpath)!
    }</pre></div></li><li class="listitem" value="4">To finish this class, we have to create the main method, which is <code class="email">addUrl</code>. This function will <a id="id238" class="calibre1"/>return if it was possible to add the URL or not:<div><pre class="programlisting">    func addUrl(url:String) -&gt; UrlAddStatus {
        if full {
            // WRITE FULL
            self.writeMessage("Couldn't store the url \(url). Buffer is full")
            return .FULL
        }
        if self.contains(url){
            self.writeMessage("Couldn't store the url \(url). Already on buffer")
            return .REPEATED
        }
        if !self.validUrl(url) {
            self.writeMessage("Couldn't store the url \(url). Invalid url")
            return .WRONG_URL
        }
        objc_sync_enter(self._urls)
        self._urls.append(url)
        objc_sync_exit(self._urls)
        self.writeMessage("Url \(url) successfully stored")
        return .OK
    }   
} // Class end</pre></div></li><li class="listitem" value="5">On the same file, we are going to create a class called <code class="email">LinkChecker</code>. To do it, we are again going to use the <code class="email">XMLParser</code>.<div><h3 class="title2"><a id="tip32" class="calibre1"/>Tip</h3><p class="calibre7">In this recipe, we are using the <code class="email">XMLParser</code> because it's built on the Swift standard libraries, but if you would like a better HTML parser, you can search on the Internet for a specific <a id="id239" class="calibre1"/>library, such as NDHpple, <a class="calibre1" href="https://github.com/ndavidsson/NDHpple/">https://github.com/ndavidsson/NDHpple/</a>.</p></div></li><li class="listitem" value="6">Let's start with the <a id="id240" class="calibre1"/>attributes. For the implementation of this class, we will need an <code class="email">NSXMlParser</code>, a <code class="email">UrlManager</code>, and a closure to execute every time we find a URL:<div><pre class="programlisting">class LinkChecker:NSObject, NSXMLParserDelegate {
    private var xmlParser:NSXMLParser
    private var urlManager:UrlManager
    var foundAction: (String) -&gt; (Void) = {
        (url) -&gt; Void in
    }</pre></div></li><li class="listitem" value="7">The next step is <a id="id241" class="calibre1"/>creating the initializers. In this case, we are going to develop two of them. The first one is the one that is going to be called from outside (view controller) and the other one is going to be created by the same <code class="email">LinkChecker</code>, receiving as an argument the same <code class="email">UrlManager</code>, and that's the reason why it is a private initializer:<div><pre class="programlisting">    init(url:String) {
        self.xmlParser = NSXMLParser(contentsOfURL: NSURL(string: url)!)!
        self.urlManager = UrlManager()
        super.init()
        self.xmlParser.delegate = self
        self.urlManager.addUrl(url)
    }
    
    private init(url:String, urlManager:UrlManager) {
        self.xmlParser = NSXMLParser(contentsOfURL: NSURL(string: url)!)!
        self.urlManager = urlManager
        super.init()
        self.xmlParser.delegate = self
    }</pre></div></li><li class="listitem" value="8">The next function is the <code class="email">start</code> method, which will create the first task:<div><pre class="programlisting">    func start(){
        dispatch_async(urlManager.queue, { () -&gt; Void in
            self.xmlParser.parse()
            return
        })
    }</pre></div></li><li class="listitem" value="9">The last method of this <code class="email">LinkChecker</code> class is the parser function of the <code class="email">NSXMLParserDelegate</code> <a id="id242" class="calibre1"/>protocol. Here we are going to check <a id="id243" class="calibre1"/>whether we've found a link, represented by the <code class="email">a</code> HTML tag:<div><pre class="programlisting">    func parser(parser: NSXMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [NSObject : AnyObject]){
        if elementName.lowercaseString == "a" {
            let href = "href"
            var newUrl = attributeDict["href"] as! String
            if let  range = newUrl.rangeOfString("#", options: .CaseInsensitiveSearch, range: nil, locale: nil){
                newUrl = newUrl.substringToIndex(range.startIndex)
            }

            print("found link \(newUrl)")
            if self.urlManager.addUrl(attributeDict[href] as! String) == .OK {
                self.foundAction(attributeDict[href] as! String)
                dispatch_async(urlManager.queue, { () -&gt; Void in
                    self.xmlParser.parse()
                    return
                })
            }
        }
    }
} // class end</pre></div></li><li class="listitem" value="10">Now, click on the <a id="id244" class="calibre1"/>storyboard and let's create a screen with a text <a id="id245" class="calibre1"/>field to write a URL, a button to start analyzing it, and a table view to display the result.<div><img src="img/00048.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="11">Now inherit the <code class="email">ViewController</code> from the <code class="email">UITableViewDataSource</code> beside the <code class="email">UIViewController</code> and add the text field, the <code class="email">tableview</code>, an array of strings <a id="id246" class="calibre1"/>to store the URLs, and a <code class="email">LinkChecker</code> as <a id="id247" class="calibre1"/>attributes:<div><pre class="programlisting">class ViewController: UIViewController, UITableViewDataSource {
    
    @IBOutlet let urlTextField: UITextField!
    @IBOutlet let tableView: UITableView!
    private var _urls = [String]()
    private var linkChecker:LinkChecker?</pre></div></li><li class="listitem" value="12">Once it is done, we can add an event to our button to start analyzing the URL:<div><pre class="programlisting">    @IBAction func analyze(sender: UIButton) {
        linkChecker = LinkChecker(url:self.urlTextField.text)
        self.linkChecker?.foundAction = {
            (url) -&gt; Void in
            self._urls.append(url)
            dispatch_async(dispatch_get_main_queue(),
                {() -&gt; Void in
                    self.tableView.reloadData()
            })
        }
        linkChecker?.start()
        self.urlTextField.resignFirstResponder()
    }</pre></div></li><li class="listitem" value="13">To finish this <a id="id248" class="calibre1"/>class, let's implement the <code class="email">tableview</code> methods, which will display the content of the <code class="email">_urls</code> attribute:<div><pre class="programlisting">    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int{
        return self._urls.count
    }

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell{
        var cell = self.tableView.dequeueReusableCellWithIdentifier(_urls[indexPath.row]) as? UITableViewCell

        if cell == nil {
            cell = UITableViewCell(style: .Default, reuseIdentifier: _urls[indexPath.row])
            cell?.textLabel?.text = _urls[indexPath.row]
        }
        return cell!
    }</pre></div></li><li class="listitem" value="14">Now the application is done, test your website and see how many links you get from it. You should see results similar to the following:<div><img src="img/00049.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec134" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Requesting something from the network is something that will take time. However, in the meantime, the application can work with the next task, so, in this case, we need to create a concurrent queue instead of a serial queue.</p><p class="calibre7">With this in mind, we <a id="id249" class="calibre1"/>have to take care when working with some variables, mainly <a id="id250" class="calibre1"/>because the application can commute from one task to another when it hasn't finished working with a variable. To prevent tasks overlapping the same attribute or variable, we should control it using <code class="email">objc_sync_enter</code> and <code class="email">objc_sync_exit</code>.</p><div><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre7">Unfortunately, Swift doesn't have some kind of mutex yet, so it needs to use the Objective-C <code class="email">@synchronize</code>, and that's the reason for these functions' prefixes.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec135" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">As you can see, sometimes it's hard to work with concurrent tasks and the developer needs to think about a lot of detail; fixing issues can also be very difficult because sometimes it's hard to reproduce it.</p><p class="calibre7">In the next chapter, we are going to learn how to test our code without the need for running the whole application.</p></div></div></body></html>