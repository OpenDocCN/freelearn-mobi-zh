<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"/>1</h1>
<h1 id="_idParaDest-16" class="calibre5"><a id="_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"/>Building the UI for Your Messaging App</h1>
<p class="calibre3">In this first chapter, we’re going to start building a messaging app called WhatsPackt (referring to a popular messaging app that you probably already know about). At this point in the project, we must make some important technical decisions and create the structure needed to build it. This is what we will be focusing on, as well as working on the app’s user interface.</p>
<p class="calibre3">By the end of this chapter, you will have hands-on experience creating a messaging app from scratch, organizing and defining the app modules, deciding which dependency injection framework you will use, using Jetpack Navigation to navigate between the app features, and using Jetpack Compose to build the main parts of the user interface.</p>
<p class="calibre3">This chapter is organized into the following topics:</p>
<ul class="calibre15">
<li class="calibre14">Defining the app structure and navigation</li>
<li class="calibre14">Building the main screen</li>
<li class="calibre14">Building the chats list</li>
<li class="calibre14">Building the messages list</li>
</ul>
<h1 id="_idParaDest-17" class="calibre5"><a id="_idTextAnchor017" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">Android Studio is the official <a id="_idIndexMarker000" class="calibre6 pcalibre1 pcalibre"/>standard <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) for developing Android apps. Although you can use other IDEs, editors, and Android tools if you prefer, all the examples in this book will be based on this IDE.</p>
<p class="calibre3">For that reason, we recommend that you set up your computer with the latest stable version of Android Studio installed. If you haven’t already, you can download it here: <a href="https://developer.android.com/studio" class="calibre6 pcalibre1 pcalibre">https://developer.android.com/studio</a>. By following the installation steps, you will be able to install the IDE and set up at least one emulator with one Android SDK installed.</p>
<p class="calibre3">Once installed, we can start creating the project. Android Studio will offer us a set of templates to start with. We will choose the <strong class="bold">Empty Activity</strong> option, as shown in the following screenshot:</p>
<div><div><img alt="Figure 1.1: Android Studio new project template selection with the Empty Activity option selected" src="img/B19443_01_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.1: Android Studio new project template selection with the Empty Activity option selected</p>
<p class="calibre3">You will<a id="_idIndexMarker001" class="calibre6 pcalibre1 pcalibre"/> then be asked to select a project and package name:</p>
<div><div><img alt="Figure 1.2: Android Studio – adding a new project name and package name" src="img/B19443_01_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.2: Android Studio – adding a new project name and package name</p>
<p class="calibre3">After that, you’re <a id="_idIndexMarker002" class="calibre6 pcalibre1 pcalibre"/>all set! Android Studio will generate the main folders and files needed so that you can start working on our project. Your project structure should look as follows:</p>
<div><div><img alt="Figure 1.3: Android Studio – project template structure" src="img/B19443_01_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.3: Android Studio – project template structure</p>
<p class="calibre3">Note that all the code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt</a>.</p>
<p class="calibre3">Now, we are ready to start coding our new messaging app. To do so, we will have to make some important technical decisions: we will have to decide how our project is going to be<a id="_idIndexMarker003" class="calibre6 pcalibre1 pcalibre"/> structured, how we will navigate between the different screens or features, and how we are going to set and provide the components needed (defining and organizing the dependencies between every component).</p>
<h1 id="_idParaDest-18" class="calibre5"><a id="_idTextAnchor018" class="calibre6 pcalibre1 pcalibre"/>Defining the app structure and navigation</h1>
<p class="calibre3">Before designing <a id="_idIndexMarker004" class="calibre6 pcalibre1 pcalibre"/>the app structure, we must have a basic idea of the features it should include. In our case, we want to have the following:</p>
<ul class="calibre15">
<li class="calibre14">A main screen to create new or access already existing conversations</li>
<li class="calibre14">A list containing all the conversations</li>
<li class="calibre14">A screen for a single conversation</li>
</ul>
<p class="calibre3">As this is going to be a production-ready app, we must design its code base while considering that it should be easy to scale and maintain. In that regard, we should use modularization.</p>
<h2 id="_idParaDest-19" class="calibre7"><a id="_idTextAnchor019" class="calibre6 pcalibre1 pcalibre"/>Modularization</h2>
<p class="calibre3"><strong class="bold">Modularization</strong> is the <a id="_idIndexMarker005" class="calibre6 pcalibre1 pcalibre"/>practice of <a id="_idIndexMarker006" class="calibre6 pcalibre1 pcalibre"/>dividing the code of an application into loosely coupled and self-contained parts, each of which can be compiled and tested in isolation. This technique allows developers to break down large and complex applications into more manageable parts that are easier to maintain.</p>
<p class="calibre3">By modularizing Android applications, modules can be built in parallel, which can significantly improve build time. Additionally, independent modules can be tested separately, which makes it easier to identify and correct errors.</p>
<p class="calibre3">While the most common way to create modules in Android development is by utilizing the Android libraries system via Gradle dependencies, alternative build systems such as Bazel and Buck also facilitate modularization. Bazel provides a robust system for declaring modules and dependencies, and its parallelized building capabilities can lead to even faster build times. Similarly, Buck also supports modular development by providing fine-grained build rules and speeding up incremental builds.</p>
<p class="calibre3">By exploring various build systems, such as Gradle, Bazel, and Buck, developers can find the most suitable modular approach to structure their Android applications. Each build system offers unique features for managing dependencies and organizing code, enabling developers to implement various patterns to achieve a modular architecture.</p>
<p class="calibre3">Among the<a id="_idIndexMarker007" class="calibre6 pcalibre1 pcalibre"/> organizational <a id="_idIndexMarker008" class="calibre6 pcalibre1 pcalibre"/>patterns, the most common ones are modularization by layers and modularization by feature modules.</p>
<h3 class="calibre9">Modularization by layers</h3>
<p class="calibre3">It is common to<a id="_idIndexMarker009" class="calibre6 pcalibre1 pcalibre"/> structure<a id="_idIndexMarker010" class="calibre6 pcalibre1 pcalibre"/> an app by grouping its components based on a set of layers depending on the architecture chosen by the developers. One popular architecture is clean architecture, which splits the code base between the data, domain (or business), and presentation layers.</p>
<p class="calibre3">With this approach, each module focuses on a specific layer of the architecture, such as the presentation layer, domain layer, or data layer. These modules are usually more independent of each other and may have different responsibilities and technologies, depending on the layer they belong to. Following this pattern, our app structure would look like this:</p>
<div><div><img alt="Figure 1.4: App modularization by layers" src="img/B19443_01_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.4: App modularization by layers</p>
<p class="calibre3">From this <a id="_idIndexMarker011" class="calibre6 pcalibre1 pcalibre"/>diagram, you can see<a id="_idIndexMarker012" class="calibre6 pcalibre1 pcalibre"/> why layer modularization is also referred to as vertical modularization.</p>
<h3 class="calibre9">Modularization by feature</h3>
<p class="calibre3">When modularizing<a id="_idIndexMarker013" class="calibre6 pcalibre1 pcalibre"/> an app <a id="_idIndexMarker014" class="calibre6 pcalibre1 pcalibre"/>by feature (or using horizontal modularization), the application is divided into modules that focus on specific features or related tasks, such as authentication or navigation. These horizontal modules can share common components and resources. We can see this structure in the following figure:</p>
<div><div><img alt="Figure 1.5: App modularization by feature" src="img/B19443_01_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.5: App modularization by feature</p>
<p class="calibre3">In our case, we are going to have a main <code>app</code> module that will depend on every one of the feature modules that our app needs (one for every one of the features we are going to implement). Then, every one of the feature modules will also depend on two other common modules (in this example, we have divided them into <code>common</code> and <code>common_framework</code>, using the first to include framework-independent code, and the second to use code that depends on the Android framework).</p>
<p class="calibre3">One of the main advantages of this pattern is that it can scale with the company if it evolves into a feature-based team (where every team is focused on a single or group of features). This will enable every team to be responsible for one feature module, or a set of feature modules, where<a id="_idIndexMarker015" class="calibre6 pcalibre1 pcalibre"/> they have ownership of the code in those modules. It also allows<a id="_idIndexMarker016" class="calibre6 pcalibre1 pcalibre"/> teams to be easily autonomous regarding their problem space and features.</p>
<h3 class="calibre9">WhatsPackt modularization</h3>
<p class="calibre3">In our WhatsPackt<a id="_idIndexMarker017" class="calibre6 pcalibre1 pcalibre"/> example, we are going to combine both modularization approaches:</p>
<ul class="calibre15">
<li class="calibre14">We will use a modularization based on features for our features.</li>
<li class="calibre14">We will use a modularization based on layers for the common modules. This will allow us to share common code between the feature modules.</li>
</ul>
<p class="calibre3">The structure of our modules and its dependencies will be as follows:</p>
<div><div><img alt="Figure 1.6: Our app modules structure and dependencies" src="img/B19443_01_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.6: Our app modules structure and dependencies</p>
<p class="calibre3">Now, we are <a id="_idIndexMarker018" class="calibre6 pcalibre1 pcalibre"/>going to start creating this structure in Android Studio. To create a module, follow these steps:</p>
<ol class="calibre13">
<li class="calibre14">Select <strong class="bold">File</strong> | <strong class="bold">New...</strong> | <strong class="bold">New Module</strong>.</li>
<li class="calibre14">In the <strong class="bold">Create New Module</strong> dialog, choose the <strong class="bold">Android </strong><strong class="bold">Library</strong> template.</li>
<li class="calibre14">Fill in the <strong class="bold">Module name</strong>, <strong class="bold">Package name</strong>, and <strong class="bold">Language</strong> fields, as shown here:</li>
</ol>
<div><div><img alt="Figure 1.7: The Create New Module dialog" src="img/B19443_01_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.7: The Create New Module dialog</p>
<ol class="calibre13">
<li value="4" class="calibre14">Click <strong class="bold">Finish</strong>.</li>
</ol>
<p class="calibre3">We will have to do <a id="_idIndexMarker019" class="calibre6 pcalibre1 pcalibre"/>this same process for all the modules we want to build, except for the <code>:app</code> module, which should have been already created when we created the project. This is going to be our main point of entry to the app. So, we must create the following modules:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">:</strong><strong class="source-inline1">common:domain</strong></li>
<li class="calibre14"><strong class="source-inline1">:</strong><strong class="source-inline1">common:data</strong></li>
<li class="calibre14"><strong class="source-inline1">:</strong><strong class="source-inline1">common:framework</strong></li>
<li class="calibre14"><strong class="source-inline1">:</strong><strong class="source-inline1">feature:create_chat</strong></li>
<li class="calibre14"><strong class="source-inline1">:</strong><strong class="source-inline1">feature:conversations</strong></li>
<li class="calibre14"><strong class="source-inline1">:</strong><strong class="source-inline1">feature:chat</strong></li>
</ul>
<p class="calibre3">Once we’ve done this, we should have built the following project structure:</p>
<div><div><img alt="Figure 1.8: Project structure, including all modules" src="img/B19443_01_8.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.8: Project structure, including all modules</p>
<p class="calibre3">The next step is to set the dependencies between modules. We will do this in the <code>build.gradle</code> file of<a id="_idIndexMarker020" class="calibre6 pcalibre1 pcalibre"/> every module. For example, in the <code>build.gradle</code> file of the <code>:app</code> module, include the following code in the <code>dependencies</code> section:</p>
<pre class="source-code">
dependencies {
    implementation project(':feature:chat')
    implementation project(':feature:conversations')
    implementation project(':feature:create_chat')
    // The rest of dependencies
}</pre> <p class="calibre3">Now that our app modules are ready, we can start working on the next step: dependency<a id="_idIndexMarker021" class="calibre6 pcalibre1 pcalibre"/> injection.</p>
<h2 id="_idParaDest-20" class="calibre7"><a id="_idTextAnchor020" class="calibre6 pcalibre1 pcalibre"/>Dependency injection</h2>
<p class="calibre3"><strong class="bold">Dependency injection</strong> is a design <a id="_idIndexMarker022" class="calibre6 pcalibre1 pcalibre"/>pattern <a id="_idIndexMarker023" class="calibre6 pcalibre1 pcalibre"/>and technique that’s used in software engineering to decouple the objects in an application and reduce dependencies between them. In Android, dependency injection involves providing an instance of a class or a component to another class, rather than creating it explicitly within the class itself.</p>
<p class="calibre3">By implementing dependency injection in an Android app, you can make the app’s code more modular, reusable, and testable. Dependency injection also helps improve the maintainability of the code base and reduce the complexity of the application architecture.</p>
<p class="calibre3">Some of the most popular dependency injection libraries that are used in Android development are as follows:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Dagger</strong> (<a href="https://dagger.dev/" class="calibre6 pcalibre1 pcalibre">https://dagger.dev/</a>): Dagger <a id="_idIndexMarker024" class="calibre6 pcalibre1 pcalibre"/>is a compile-time dependency injection library developed<a id="_idIndexMarker025" class="calibre6 pcalibre1 pcalibre"/> by Google that uses annotations and code generation to create a dependency graph that can be used to provide dependencies to the app’s components. Its main advantage is that it builds this dependency graph at compile time, whereas other libraries (such as Koin) do it at runtime. For larger apps, this can imply a performance problem.</li>
<li class="calibre14"><strong class="bold">Hilt</strong> (<a href="https://dagger.dev/hilt/" class="calibre6 pcalibre1 pcalibre">https://dagger.dev/hilt/</a>): Hilt is a dependency injection library built on top of Dagger that<a id="_idIndexMarker026" class="calibre6 pcalibre1 pcalibre"/> provides a simplified way to perform dependency injection in Android apps. It reduces the boilerplate code required for Dagger and provides predefined bindings for Android-specific components, such as activities and fragments.</li>
<li class="calibre14"><strong class="bold">Koin</strong> (<a href="https://insert-koin.io/" class="calibre6 pcalibre1 pcalibre">https://insert-koin.io/</a>): Koin is <a id="_idIndexMarker027" class="calibre6 pcalibre1 pcalibre"/>a lightweight dependency injection library for Kotlin that focuses on simplicity and ease of use. It uses a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) to<a id="_idIndexMarker028" class="calibre6 pcalibre1 pcalibre"/> define the dependencies and provide them to the app’s components, which<a id="_idIndexMarker029" class="calibre6 pcalibre1 pcalibre"/> makes it easier to do the setup and start using it.</li>
</ul>
<p class="calibre3">Ultimately, the choice of dependency injection library depends on your specific requirements and preferences, and both Dagger and Koin are worth considering, depending on your needs. In this case, we are going to use Hilt as it is the current recommendation by Google.</p>
<p class="calibre3">To set up Hilt in our project, follow these steps:</p>
<ol class="calibre13">
<li class="calibre14">Add the Hilt <a id="_idIndexMarker030" class="calibre6 pcalibre1 pcalibre"/>Gradle plugin to your project-level <strong class="source-inline1">build.gradle</strong> file (replace <strong class="source-inline1">[version]</strong> with the latest version available for you):<pre class="source-code">
buildscript {
    repositories {
        google()
    }
    dependencies {
        classpath "com.google.dagger:hilt-android-
            gradle-plugin:[version]"
    }
}</pre></li> <li class="calibre14">Apply the <a id="_idIndexMarker031" class="calibre6 pcalibre1 pcalibre"/>Hilt Gradle plugin and enable view binding in your app-level <strong class="source-inline1">build.gradle</strong> file:<pre class="source-code">
apply plugin: 'kotlin-kapt'
apply plugin: 'dagger.hilt.android.plugin'
android {
    ...
    buildFeatures {
        viewBinding true
    }
}
dependencies {
    implementation "com.google.dagger:hilt-
        android:[version]"
    kapt "com.google.dagger:hilt-android-
        compiler:[version]"
    ...
}</pre></li> <li class="calibre14">Finally, create an <strong class="source-inline1">Application</strong> class in our <strong class="source-inline1">:app</strong> module. The <strong class="source-inline1">Application</strong> class serves as a base class for maintaining the global application state (this refers to data or settings that need to be maintained throughout the entire life cycle of the application). While it’s not created by default, creating<a id="_idIndexMarker032" class="calibre6 pcalibre1 pcalibre"/> a custom <strong class="source-inline1">Application</strong> class is crucial for initialization tasks, such as setting up dependency injection frameworks or initializing libraries. In this particular instance, to make Hilt work, you should annotate your <strong class="source-inline1">Application</strong> class with the <strong class="source-inline1">@</strong><strong class="source-inline1">HiltAndroidApp</strong> annotation:<pre class="source-code">
@HiltAndroidApp
class WhatsPacktApplication : Application() {
    // ...
}</pre></li> </ol>
<p class="calibre3">With that, we<a id="_idIndexMarker033" class="calibre6 pcalibre1 pcalibre"/> are all set – we will continue defining the modules and dependencies once we advance in this project.</p>
<h2 id="_idParaDest-21" class="calibre7"><a id="_idTextAnchor021" class="calibre6 pcalibre1 pcalibre"/>Navigation</h2>
<p class="calibre3">The next step is to <a id="_idIndexMarker034" class="calibre6 pcalibre1 pcalibre"/>decide what our approach to handling the navigation between screens and features in our application will be. It is important to note that we are going to use Jetpack Compose to build the user interface of our app, so the chosen approach must be compatible with it.</p>
<p class="calibre3">In this case, we’re going to use Navigation Compose as it provides a simple and easy-to-use way to handle in-app navigation within an Android app. Here are some benefits of using Navigation Compose:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Declarative UI</strong>: Navigation Compose follows the same declarative approach as Jetpack Compose, which makes it easier to understand and maintain the navigation flow in your application.</li>
<li class="calibre14"><strong class="bold">Type-safety</strong>: With Navigation Compose, you can define your navigation graph and actions in a type-safe way. This helps prevent runtime crashes caused by incorrect navigation action names and arguments.</li>
<li class="calibre14"><strong class="bold">Animation and transition support</strong>: Navigation Compose provides built-in support for animating screen transitions, making it easy to create smooth and visually appealing navigation experiences.</li>
<li class="calibre14"><strong class="bold">Deep linking</strong>: Navigation Compose supports deep linking, allowing you to create URLs that can directly navigate to specific screens or actions within your app. This is useful for implementing features such as app shortcuts, notifications, or sharing content.</li>
<li class="calibre14"><strong class="bold">Integration with Jetpack Compose</strong>: As part of the Jetpack Compose family, Navigation Compose works seamlessly with other Compose libraries and components, allowing you to build a consistent UI and navigation experience across your app.</li>
<li class="calibre14"><strong class="bold">Modularity and scalability</strong>: Navigation Compose enables you to build modular navigation graphs, making it easier to scale your app and manage complex navigation flows.</li>
</ul>
<p class="calibre3">In summary, Navigation Compose simplifies navigation management, improves the robustness of our app, and will help us to create a more consistent, accessible, and visually appealing user experience.</p>
<p class="calibre3">To start using Navigation Compose, we must do the following:</p>
<ol class="calibre13">
<li class="calibre14">First, we need to include the dependencies that are required in our Gradle files:<pre class="source-code">
dependencies {
    implementation "androidx.navigation:navigation-
    compose:2.5.3"
}</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">The version used in the previous code is the latest stable one at the time of writing this book, but there will likely be a new version by the time you are reading this.</p>
<ol class="calibre13">
<li value="2" class="calibre14">Next, in the <strong class="source-inline1">app</strong> module, create a new package called <strong class="source-inline1">ui.navigation</strong>. Then, create <a id="_idIndexMarker035" class="calibre6 pcalibre1 pcalibre"/>a file called <strong class="source-inline1">WhatsPacktNavigation</strong>.</li>
<li class="calibre14">Now, create a <strong class="source-inline1">NavHost</strong> composable and provide a <strong class="source-inline1">NavController</strong> instance. The <strong class="source-inline1">NavHost</strong> composable functions as a container for managing navigation between different composables in an app. It acts as the central hub where navigation routes are defined and composables are switched in and out based on the navigation state. Each screen or view in your application corresponds to a composable that <strong class="source-inline1">NavHost</strong> can display. Here, we will start by creating the <strong class="source-inline1">WhatsPacktNavigation</strong> composable function. This will be responsible for holding <strong class="source-inline1">NavHost</strong>:<pre class="source-code">
import androidx.compose.runtime.Composable
import androidx.navigation.compose.NavHost
import
androidx.navigation.compose.rememberNavController
@Composable
fun WhatsPacktNavigation() {
    val navController = rememberNavController()
    NavHost(navController = navController,
    startDestination = "start_screen") {
        // Add composable destinations here
    }
}</pre></li> <li class="calibre14">Once we’ve created the first screen (which we’ll call <strong class="source-inline1">MainScreen</strong>), we will complete <strong class="source-inline1">NavHost</strong>, as follows:<pre class="source-code">
    NavHost(navController = navController,
    startDestination = "start_screen") {
        composable("start_screen") {
        MainScreen(navController) }
    }</pre></li> <li class="calibre14">We can also<a id="_idIndexMarker036" class="calibre6 pcalibre1 pcalibre"/> include dynamic parameters in the route, like so:<pre class="source-code">
NavHost(
    navController = navController,
    startDestination = "start_screen"
) {
    composable("start_screen") {
        MainScreen(navController) }
    composable("chat/{chatId}") { backStackEntry -&gt;
        val chatId =
            backStackEntry.arguments?.getString(
                "chatId")
        ChatScreen(navController, chatId)
    }
}</pre><p class="calibre3">Here, we have a second composable that defines another navigation destination associated with the <code>"chat/{chatId}"</code> route. The <code>{chatId}</code> part is a dynamic parameter that can be passed when navigating to this destination.</p></li> </ol>
<p class="calibre3">Using these two configurations – that is, navigation with and without parameters – should have us covered but since we are using feature-based modularization, we might encounter the problem of having to navigate from one module to another where there isn’t a direct dependency between them. In those cases, we will use deep links.</p>
<p class="calibre3"><code>NavHost</code>, you need to add a <code>deepLink</code> parameter with the URI pattern you want to use for that destination. This pattern should include <a id="_idIndexMarker038" class="calibre6 pcalibre1 pcalibre"/>a scheme, a host, and an optional path. In our example, if we have <code>ChatScreen</code>, which takes a <code>chatId</code> argument, we can add a deep link <code>URI</code> like this:</p>
<pre class="source-code">
NavHost(
    navController = navController,
    startDestination = "start_screen")
{
    composable("start_screen") { MainScreen(navController)
    }
    composable(
        route = "chat?id={id}",
        deepLinks = listOf(navDeepLink { uriPattern =
            "whatspackt://chat/{id}" })
    ) { backStackEntry -&gt;
        ChatScreen(
            navController,
            backStackEntry.arguments?.getString("id"))
    }
}</pre> <p class="calibre3">One common practice to keep our <code>NavHost</code> leaner and delegate the definition of routes and URIs to<a id="_idIndexMarker039" class="calibre6 pcalibre1 pcalibre"/> every screen is to define the route with constants. Here is an example:</p>
<pre class="source-code">
@Composable
fun ChatScreen(
    ...
) {
    object {
        val uri = "whatspackt://chat/{id}"
        val name = "chat?id={id}"
    }
}</pre> <p class="calibre3">By doing this, developers can easily manage, update, and maintain the routes in a centralized manner.</p>
<p class="calibre3">Then, in <code>NavHost</code>, we would define <code>uriPattern</code> using these constants:</p>
<pre class="source-code">
composable(
    route = NavRoutes.Chat,
    arguments = listOf(
        navArgument(NavRoutes.ChatArgs.ChatId) {
            type = NavType.StringType
        }
    )
) { backStackEntry -&gt;
    val chatId = backStackEntry.arguments?.getString(
        NavRoutes.ChatArgs.ChatId)
    ChatScreen(chatId = chatId, onBack = {
        navController.popBackStack() })
}</pre> <p class="calibre3">Instead of adding this information to every screen, a better option is to create a class where we are going to put all the route constants:</p>
<pre class="source-code">
object NavRoutes {
    const val ConversationsList = "conversations_list"
    const val NewConversation = "create_conversation"
    const val Chat = "chat/{chatId}"
    object ChatArgs {
        const val ChatId = "chatId"
    }
}</pre> <p class="calibre3">Having the route’s <a id="_idIndexMarker040" class="calibre6 pcalibre1 pcalibre"/>definition in the same place will facilitate reading and maintaining our code so that we can easily manage, update, and maintain the routes in a centralized manner, while also improving code readability and reducing the possibility of errors caused by hardcoded or duplicated strings throughout the code base.</p>
<p class="calibre3">We will place the file that contains this class in our <code>:common:framework</code> module as we will need to access those constants from every feature module. Another common practice is to create a dedicated <code>:common:navigation</code> module and add the definition of the route and even the <code>NavHost</code> definition there. In our case, we will define the routes using the latest approach – that is, route constants:</p>
<pre class="source-code">
package com.packt.whatspackt.ui.navigation
import androidx.compose.runtime.Composable
import androidx.navigation.NavGraphBuilder
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import com.packt.feature.chat.ui.ChatScreen
import androidx.navigation.navArgument
import com.packt.framework.navigation.NavRoutes
@Composable
fun MainNavigation(navController: NavHostController) {
    NavHost(
        navController,
        startDestination = NavRoutes.ConversationsList)
    {
        addConversationsList(navController)
        addNewConversation(navController)
        addChat(navController)
    }
}</pre> <p class="calibre3">In the preceding code, we completed our <code>NavHost</code> definition.</p>
<p class="calibre3">In our app, we will want to navigate to three different parts of the app (conversations list, create new chat, and the single chat screen). The navigation destinations can be added to <code>NavHost</code> by using extension functions on <code>NavGraphBuilder</code>. These extension<a id="_idIndexMarker041" class="calibre6 pcalibre1 pcalibre"/> functions are defined as follows:</p>
<pre class="source-code">
private fun NavGraphBuilder.addConversationsList(
    navController: NavHostController
) {
    composable(NavRoutes.ConversationsList) {
        ConversationsListScreen(
            onNewConversationClick = {
                navController.navigate(
                    NavRoutes.NewConversation)
            },
            onConversationClick = { chatId -&gt;
                navController.navigate(
                NavRoutes.Chat.replace("{chatId}", chatId))
            }
        )
    }
}
private fun NavGraphBuilder.addNewConversation(
navController: NavHostController) {
    composable(NavRoutes.NewConversation) {
        CreateConversationScreen(onCreateConversation = {
            navController.navigate(NavRoutes.Chat)
        })
    }
}
private fun NavGraphBuilder.addChat(navController:
NavHostController) {
    composable(
        route = NavRoutes.Chat,
        arguments = listOf(navArgument(
        NavRoutes.ChatArgs.ChatId) {
            type = NavType.StringType
        })
    ) { backStackEntry -&gt;
        val chatId = backStackEntry.arguments?.getString(
            NavRoutes.ChatArgs.ChatId)
        ChatScreen(chatId = chatId, onBack = {
            navController.popBackStack() })
    }
}</pre> <p class="calibre3">Here, <code>addConversationsList(navController)</code> sets up <code>ConversationsListScreen</code> and <a id="_idIndexMarker042" class="calibre6 pcalibre1 pcalibre"/>defines click listeners for navigating to the <code>NewConversation</code> and <code>Chat</code> destinations.</p>
<p class="calibre3">Then, <code>addNewConversation(navController)</code> sets up <code>CreateConversationScreen</code> and defines a click listener for navigating to the <code>Chat</code> destination upon creating a new conversation.</p>
<p class="calibre3">Finally, <code>addChat(navController)</code> sets up <code>ChatScreen</code> and extracts the <code>chatId</code> argument from <code>backStackEntry</code>. It also defines a click listener for navigating back to the previous screen using <code>navController.popBackStack()</code>.</p>
<p class="calibre3">Now, we are almost ready to hit the <strong class="bold">Run</strong> button for the first time. But first, to avoid compilation problems, we should create the screen’s composables in their respective modules:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">ConversationsListScreen</strong> in <strong class="source-inline1">:feature:conversations</strong></li>
<li class="calibre14"><strong class="source-inline1">CreateConversationScreen</strong> in <strong class="source-inline1">:feature:create_chat</strong></li>
<li class="calibre14"><strong class="source-inline1">ChatScreen</strong> in <strong class="source-inline1">:feature:chat</strong></li>
</ul>
<p class="calibre3">For example, we <a id="_idIndexMarker043" class="calibre6 pcalibre1 pcalibre"/>can create <code>ChatScreen</code> and leave it as follows:</p>
<pre class="source-code">
package com.packt.feature.chat.ui
import androidx.compose.runtime.Composable
@Composable
fun ChatScreen(
    chatId: String?,
    onBack: () -&gt; Unit
) {
}</pre> <p class="calibre3">We are missing one last change (for now). We need to include the <code>MainNavigation</code> composable as the content in <code>MainActivity</code>:</p>
<pre class="source-code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            WhatsPacktTheme {
                val navHostController =
                    rememberNavController()
                MainNavigation(navController =
                    navHostController)
            }
        }
    }
}</pre> <p class="calibre3">As we can see, we’ve added <code>navHostController</code>, which we created using <code>rememberNav</code><strong class="source-inline">
Controller()</strong>. This is used to remember the navigation state across recompositions. Here, <code>navHostController</code> manages the navigation between different composables in the application. Then, the <code>MainNavigation</code> composable is called with <code>navHostController</code>.</p>
<p class="calibre3">So far, we have chosen and created the module structure for our app, chosen a dependency injection framework, added the dependencies we need, and structured the navigation that <a id="_idIndexMarker044" class="calibre6 pcalibre1 pcalibre"/>defines how our screens are going to be accessed. Now, it’s time for us to start working on each of the screens we need to build this app.</p>
<h1 id="_idParaDest-22" class="calibre5"><a id="_idTextAnchor022" class="calibre6 pcalibre1 pcalibre"/>Building the main screen</h1>
<p class="calibre3">Now that we have<a id="_idIndexMarker045" class="calibre6 pcalibre1 pcalibre"/> the main structure of our app ready, it is time to start building the main screen.</p>
<p class="calibre3">Let’s analyze what components our main screen will have:</p>
<div><div><img alt="Figure 1.9: The ConversationsList screen" src="img/B19443_01_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.9: The ConversationsList screen</p>
<p class="calibre3">As you can see, we <a id="_idIndexMarker046" class="calibre6 pcalibre1 pcalibre"/>are going to include the following:</p>
<ul class="calibre15">
<li class="calibre14">A top bar</li>
<li class="calibre14">A tab bar to navigate to the main sections (note that this book will only cover the development of the chat section; we will not cover the status and calls sections)</li>
<li class="calibre14">A list containing the current conversations (which we will complete later in this chapter)</li>
<li class="calibre14">A floating button to create a new chat</li>
</ul>
<p class="calibre3">Let’s start with<a id="_idIndexMarker047" class="calibre6 pcalibre1 pcalibre"/> the main screen.</p>
<h2 id="_idParaDest-23" class="calibre7"><a id="_idTextAnchor023" class="calibre6 pcalibre1 pcalibre"/>Adding a scaffold to the main screen</h2>
<p class="calibre3">Previously, we<a id="_idIndexMarker048" class="calibre6 pcalibre1 pcalibre"/> created an empty version <a id="_idIndexMarker049" class="calibre6 pcalibre1 pcalibre"/>of the first screen (<code>ConversationsListScreen</code>), as follows:</p>
<pre class="source-code">
package com.packt.feature.conversations.ui
import androidx.compose.runtime.Composable
@Composable
fun ConversationsListScreen(
    onNewConversationClick: () -&gt; Unit,
    onConversationClick: (chatId: String) -&gt; Unit
) {
// We will add here the ConversactionsListScreen components
}</pre> <p class="calibre3">Now, it’s time to start working on this screen. The first component we are going to add is a <code>Scaffold</code>, you can easily organize your app’s layout and maintain a consistent look and feel across different screens.</p>
<p class="calibre3">Here’s a brief overview of the main components of <code>Scaffold</code>:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">topBar</strong>: A slot for placing a top app bar, typically used for displaying the app’s title and navigation icons. You can use the <strong class="source-inline1">TopAppBar</strong> composable to create a top app bar.</li>
<li class="calibre14"><strong class="source-inline1">bottomBar</strong>: A slot for placing a bottom app bar, typically used for actions, navigation tabs, or a bottom navigation bar. You can use the <strong class="source-inline1">BottomAppBar</strong> or <strong class="source-inline1">TabRow</strong> composable to create a bottom app bar.</li>
<li class="calibre14"><strong class="source-inline1">drawerContent</strong>: A slot for placing a navigation drawer, which is a panel that displays the app’s navigation options. You can use the <strong class="source-inline1">Drawer</strong> or <strong class="source-inline1">ModalDrawer</strong> composable to create a navigation drawer.</li>
<li class="calibre14"><strong class="source-inline1">floatingActionButton</strong>: A slot for placing a floating action button, which is a circular button that hovers above the content and represents the primary action of the screen. You can use the <strong class="source-inline1">FloatingActionButton</strong> composable to create a floating action button.</li>
<li class="calibre14"><strong class="source-inline1">content</strong>: A slot for placing the main content of the screen, which can be any composable that displays the app’s data or UI elements.</li>
</ul>
<p class="calibre3">In our case, we are going to use <code>topBar</code>, <code>bottomBar</code> with <code>TabRow</code> (to navigate between tabs), <code>floatingActionButton</code> (to create new chats), and the content, where we are <a id="_idIndexMarker050" class="calibre6 pcalibre1 pcalibre"/>going to place our main content – in <a id="_idIndexMarker051" class="calibre6 pcalibre1 pcalibre"/>our case, the list of conversations.</p>
<p class="calibre3">Let’s create the <code>Scaffold</code> composable in our <code>ConversationsListScreen</code>. We will add the modifiers for all the components we want to include, but we’ll leave them empty (for now):</p>
<pre class="source-code">
@Composable
fun ConversationsListScreen(
    onNewConversationClick: () -&gt; Unit,
    onConversationClick: (chatId: String) -&gt; Unit
) {
    Scaffold(
        topBar = { /* TopAppBar code */ },
        bottomBar = { /* TabRow code */ },
        floatingActionButton =
            { /* FloatingActionButton code */ }
    ) {
        /* Content code */
    }
}</pre> <p class="calibre3">The <code>Scaffold</code> composable we have created includes <code>topBar</code>, <code>bottomBar</code>, <code>floatingAction</code><strong class="source-inline">
Button</strong>, and the content of the main area of the screen. We will continue implementing each of those components.</p>
<p class="calibre3">Now, depending on your Android Studio version, you may see the following error:</p>
<div><div><img alt="Figure 1.10: An error with the content padding parameter" src="img/B19443_01_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.10: An error with the content padding parameter</p>
<p class="calibre3">This is<a id="_idIndexMarker052" class="calibre6 pcalibre1 pcalibre"/> happening<a id="_idIndexMarker053" class="calibre6 pcalibre1 pcalibre"/> because the <code>Scaffold</code> composable provides a padding parameter to the content Lambda. We will need to take this padding into account when we place the inside components since the scaffold could overlap them if we don’t. For example, in our case, we must consider the padding because otherwise, our content will be kept behind <code>bottomBar</code>. We will<a id="_idIndexMarker054" class="calibre6 pcalibre1 pcalibre"/> use this parameter layer<a id="_idIndexMarker055" class="calibre6 pcalibre1 pcalibre"/> when we build the content.</p>
<p class="calibre3">Now, we will add a <code>TopAppBar</code> composable to the <code>Scaffold</code> composable.</p>
<h2 id="_idParaDest-24" class="calibre7"><a id="_idTextAnchor024" class="calibre6 pcalibre1 pcalibre"/>Adding the TopAppBar composable to the main screen</h2>
<p class="calibre3">The <code>TopAppBar</code> composable <a id="_idIndexMarker056" class="calibre6 pcalibre1 pcalibre"/>represents a toolbar <a id="_idIndexMarker057" class="calibre6 pcalibre1 pcalibre"/>located at the top of the screen and provides a consistent look and feel across different screens in your app. It typically displays the following elements:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Title</strong>: The main text that’s displayed in the app bar, usually representing the app’s name or the current screen’s title</li>
<li class="calibre14"><strong class="bold">Navigation icon</strong>: An optional icon located at the beginning of the app bar, usually used to open a navigation drawer or navigate back into the app</li>
<li class="calibre14"><strong class="bold">Actions</strong>: A set of optional icons or buttons located at the end of the app bar, representing common actions or settings related to the current screen</li>
</ul>
<p class="calibre3">To add a <code>TopAppBar</code> composable, we must create the <code>conversations_list_title</code> string in the module’s <code>strings.xml</code> file.</p>
<p class="calibre3">Then, we are going to create the <code>TopAppBar</code> composable while setting the title to <code>WhatsPackt</code> and adding <code>IconButton</code> with a menu icon. Here, <code>IconButton</code> has an <code>onClick</code> function where you can define the action to perform when the button is clicked:</p>
<pre class="source-code">
topBar = {
    TopAppBar(
        title = {
            Text(stringResource(
            R.string.conversations_list_title))
        },
        actions = {
            IconButton(onClick = { /* Menu action */ }) {
                Icon(Icons.Rounded.Menu,
                contentDescription = "Menu")
            }
        }
    )
},</pre> <p class="calibre3">Next, we <a id="_idIndexMarker058" class="calibre6 pcalibre1 pcalibre"/>are <a id="_idIndexMarker059" class="calibre6 pcalibre1 pcalibre"/>going to create a <code>TabRow</code> composable.</p>
<h2 id="_idParaDest-25" class="calibre7"><a id="_idTextAnchor025" class="calibre6 pcalibre1 pcalibre"/>Adding the TabRow composable to the bottom of the main screen</h2>
<p class="calibre3">The <code>TabRow</code> composable is<a id="_idIndexMarker060" class="calibre6 pcalibre1 pcalibre"/> a horizontal<a id="_idIndexMarker061" class="calibre6 pcalibre1 pcalibre"/> row of tabs that allows users to navigate between different views or sections within an app. The <code>TabRow</code> composable mainly consists of the following elements:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Tabs</strong>: A collection of individual <strong class="source-inline1">Tab</strong> composables that represent different sections or views within the app. Each <strong class="source-inline1">Tab</strong> composable can have a text label, an icon, or both to describe its content.</li>
<li class="calibre14"><strong class="bold">Selected tab indicator</strong>: A visual indicator that highlights the currently selected tab, making it easy for users to understand which section they are viewing.</li>
</ul>
<p class="calibre3">Before creating the <code>TabRow</code> composable, we’ll have to provide a list and the tabs it is going to contain:</p>
<pre class="source-code">
@Composable
fun ConversationsListScreen(
    onNewConversationClick: () -&gt; Unit,
    onConversationClick: (chatId: String) -&gt; Unit
) {
    val tabs = listOf("Status", "Chats", "Calls")
    Scaffold(
        topBar = {
...</pre> <p class="calibre3">Then, we can add <code>TabRow</code>:</p>
<pre class="source-code">
bottomBar = {
    TabRow(selectedTabIndex = 1) {
        tabs.forEachIndexed { index, tab -&gt;
            Tab(
                text = { Text(tab) },
                selected = index == 1,
                onClick = { /* Navigation action */ }
            )
        }
    }
},</pre> <p class="calibre3">For every row, we are adding a <code>Tab</code> composable, where we indicate the title (using a <code>Text</code> composable), the selected value when the tab is selected, and the <code>onClick</code> action (which we are not implementing).</p>
<p class="calibre3">After that, we<a id="_idIndexMarker062" class="calibre6 pcalibre1 pcalibre"/> can make <a id="_idIndexMarker063" class="calibre6 pcalibre1 pcalibre"/>our code more readable by creating a data class to store the title of the <code>Tab</code> composable:</p>
<pre class="source-code">
data class ConversationsListTab(
    @StringRes val title: Int
)
fun generateTabs(): List&lt;ConversationsListTab&gt; {
    return listOf(
        ConversationsListTab(
            title = R.string.conversations_tab_status_title
        ),
        ConversationsListTab(
            title = R.string.conversations_tab_chats_title
        ),
        ConversationsListTab(
            title = R.string.conversations_tab_calls_title
        ),
    )
}</pre> <p class="calibre3">Then, we can <a id="_idIndexMarker064" class="calibre6 pcalibre1 pcalibre"/>change our <code>TabRow</code> code:</p>
<pre class="source-code">
bottomBar = {
    TabRow(selectedTabIndex = 1) {
        tabs.forEachIndexed { index, _ -&gt;
            Tab(
                text = { Text(stringResource(
                    tabs[index].title)) },
                selected = index == 1,
                onClick = {
                    // Navigate to every tab content
                }
            )
        }
    }
}</pre> <p class="calibre3"><code>TabRow</code> composables <a id="_idIndexMarker065" class="calibre6 pcalibre1 pcalibre"/>are usually<a id="_idIndexMarker066" class="calibre6 pcalibre1 pcalibre"/> combined with a pager, where the content will be shown. When clicking and navigating between tabs, the main content that’s displayed should change.</p>
<p class="calibre3">Now, let’s add the pager to our screen content.</p>
<h2 id="_idParaDest-26" class="calibre7"><a id="_idTextAnchor026" class="calibre6 pcalibre1 pcalibre"/>Adding a pager</h2>
<p class="calibre3">A pager is a UI <a id="_idIndexMarker067" class="calibre6 pcalibre1 pcalibre"/>component that allows users to <a id="_idIndexMarker068" class="calibre6 pcalibre1 pcalibre"/>swipe through multiple pages or screens horizontally or vertically. It is commonly used to display screens or views in a carousel-like fashion.</p>
<p class="calibre3">We are going to use <code>HorizontalPager</code>, which, as its name suggests, allows the user to horizontally swipe between screens or composables. One of its main advantages is that it will not create all pages at once; it will only create the current page and the immediate previous/next pages, which will be off-screen. Once a page is out of this three-page window, it will be removed.</p>
<p class="calibre3">To do so, we are going to have to tweak some of the previous code we had in our <code>Conversations</code><strong class="source-inline">
</strong><code>ListScreen</code> composable:</p>
<pre class="source-code">
@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ConversationsListScreen(
    onNewConversationClick: () -&gt; Unit,
    onConversationClick: (chatId: String) -&gt; Unit
) {
    val tabs = generateTabs()
    val selectedIndex = remember { mutableStateOf(1) }
    val pagerState = rememberPagerState(initialPage = 1)
    …
}</pre> <p class="calibre3">First, since <code>HorizontalPager</code> is part of the foundation API and is (at the time of writing) an experimental API (which means that it could change its public interface in the future), we need to add the <code>@</code><code>OptIn(ExperimentalFoundationApi::class)</code> annotation.</p>
<p class="calibre3">Second, we have added a new field called <code>pagerState</code>. Its responsibility is to hold the state of the pager, including information about the number of pages, the current page, the scrolling position, and the scrolling behavior.</p>
<p class="calibre3">Next, we will<a id="_idIndexMarker069" class="calibre6 pcalibre1 pcalibre"/> add <code>HorizontalPager</code> to<a id="_idIndexMarker070" class="calibre6 pcalibre1 pcalibre"/> the content function, as follows:</p>
<pre class="source-code">
content = { innerPadding -&gt;
    HorizontalPager(
    modifier = Modifier.padding(innerPadding),
    pageCount = tabs.size,
    state = pagerState
) { index -&gt;
    when (index) {
        0 -&gt; {
            //Status
        }
        1 -&gt; {
            ConversationList(
                conversations = emptyList(),
                onConversationClick = onConversationClick
            )
        }
        2-&gt; {
            // Calls
        }
    }
}
    LaunchedEffect(selectedIndex.value) {
        pagerState.animateScrollToPage(selectedIndex.value)
    }
}</pre> <p class="calibre3">Here, we will be using a <code>LaunchedEffect</code> function. This function is used to manage side effects, such as launching tasks that have been completed asynchronously in the context of a composable hierarchy. Side effects are operations that can have an impact outside of the composable function itself, such as network requests, database operations, or, in the case of the previous example, scrolling to a specific page in a pager.</p>
<p class="calibre3"><code>LaunchedEffect</code> takes a key (or a set of keys) as its first parameter. When the key changes, the effect will be re-launched, canceling any ongoing work from the previous effect. The second parameter is a suspending Lambda function, which will be executed in the effect’s coroutine scope.</p>
<p class="calibre3">The main advantage of using <code>LaunchedEffect</code> is that it integrates well with the Compose life cycle. When the composable that called <code>LaunchedEffect</code> leaves the composition, the effect will be automatically canceled, cleaning up any ongoing work.</p>
<p class="calibre3">Coming back to our code, in our case, we are changing the current page in <code>pagerState</code> and animating the scroll to the next selected page. This will be triggered every time <code>selectedIndex.value</code> is changed.</p>
<p class="calibre3">The next <a id="_idIndexMarker071" class="calibre6 pcalibre1 pcalibre"/>component<a id="_idIndexMarker072" class="calibre6 pcalibre1 pcalibre"/> will allow the user to create a new chat – we will create this button using a <code>FloatingActionButton</code> composable.</p>
<h2 id="_idParaDest-27" class="calibre7"><a id="_idTextAnchor027" class="calibre6 pcalibre1 pcalibre"/>Adding the FloatingActionButton composable</h2>
<p class="calibre3">The <code>FloatingActionButton</code> composable is a Material Design composable that represents a<a id="_idIndexMarker073" class="calibre6 pcalibre1 pcalibre"/> circular button <a id="_idIndexMarker074" class="calibre6 pcalibre1 pcalibre"/>floating above the UI. It’s typically used to promote the primary action in an application (for example, adding a new item, composing a message, or starting a new process). Following the Material Design guidelines (you can check them here: <a href="https://m3.material.io/" class="calibre6 pcalibre1 pcalibre">https://m3.material.io/</a>), we are going to use it to create a new chat from <code>ConversationsListScreen</code>:</p>
<pre class="source-code">
floatingActionButton = {
    FloatingActionButton(
        onClick = { onNewConversationClick() }
    ) {
        Icon(
            imageVector = Icons.Default.Add,
            contentDescription = "Add"
        )
    }
}</pre> <p class="calibre3">Our <code>FloatingActionButton</code> composable is taking an <code>onClick</code> modifier. Here, we will include the code <a id="_idIndexMarker075" class="calibre6 pcalibre1 pcalibre"/>to navigate to the create chat screen. Inside this button, we have included an <code>Icon</code> composable, which we are using as an image of one of the <code>Icons.Default</code> predefined images.</p>
<p class="calibre3">At this point, our conversations list screen should look similar to this:</p>
<div><div><img alt="Figure 1.11: The conversations list screen with a top bar, tab bar, and floating action button" src="img/B19443_01_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.11: The conversations list screen with a top bar, tab bar, and floating action button</p>
<p class="calibre3">With that, we have created our <code>Scaffold</code> composable with all the elements we need to help the user navigate. Now, we are ready for the last step (and the most important one) to<a id="_idIndexMarker076" class="calibre6 pcalibre1 pcalibre"/> complete <a id="_idIndexMarker077" class="calibre6 pcalibre1 pcalibre"/>the screen: creating the list of existing conversations. To do that, we are going to start creating a conversation item.</p>
<h1 id="_idParaDest-28" class="calibre5"><a id="_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"/>Creating the conversations list</h1>
<p class="calibre3">In this section, we <a id="_idIndexMarker078" class="calibre6 pcalibre1 pcalibre"/>are going to create all the pieces<a id="_idIndexMarker079" class="calibre6 pcalibre1 pcalibre"/> we need to show the conversations list. We will start with the UI data model, which will represent the information that the app is going to show in the list, the <code>Conversation</code> composable, which will draw every item of the list, and finally the list composable itself.</p>
<h2 id="_idParaDest-29" class="calibre7"><a id="_idTextAnchor029" class="calibre6 pcalibre1 pcalibre"/>Modeling the conversation</h2>
<p class="calibre3">First, we are going to <a id="_idIndexMarker080" class="calibre6 pcalibre1 pcalibre"/>model what is going to be the entity we<a id="_idIndexMarker081" class="calibre6 pcalibre1 pcalibre"/> will be using through our conversations list components: the <code>Conversation</code> model.</p>
<p class="calibre3">As part of the conversation model, we want to show the avatar of the other participant (we are just doing one-to-one conversations), their name, the first line of the last message, the time the message was received, and a number indicating how many unread messages there are.</p>
<p class="calibre3">Taking that information into account, we will start creating a data class to hold the data we’ll need:</p>
<pre class="source-code">
data class Conversation(
    val id: String,
    val name: String,
    val message: String,
    val timestamp: String,
    val unreadCount: Int,
    val avatar: String
)</pre> <p class="calibre3">As the avatar could be reusable across the app, we are going to create it first. We can include it in the <code>:common:framework</code> module so that it is visible and can be reused from the other feature modules.</p>
<p class="calibre3">Jetpack Compose doesn’t include support to asynchronously load images from a URL out of the box, but there are plenty of third-party libraries that will help us accomplish this. The most popular options are Coil and Glide, which, in terms of performance, caching, and image loading, are quite similar. We are going to use Coil just for simplicity and because it is Kotlin-first (whereas Glide is programmed in Java).</p>
<p class="calibre3">As always, we need to include the dependency in our module’s <code>build.gradle</code> file:</p>
<pre class="source-code">
dependencies {
...
implementation "io.coil-kt:coil-compose:${latest_version}"
...
}</pre> <p class="calibre3">At this <a id="_idIndexMarker082" class="calibre6 pcalibre1 pcalibre"/>point, we’re<a id="_idIndexMarker083" class="calibre6 pcalibre1 pcalibre"/> ready to create our <code>Avatar</code> composable:</p>
<pre class="source-code">
@Composable
fun Avatar(
    modifier: Modifier = Modifier,
    imageUrl: String,
    size: Dp,
    contentDescription: String? = "User avatar"
) {
    AsyncImage(
        model = imageUrl,
        contentDescription = contentDescription,
        modifier = modifier
            .size(size)
            .clip(CircleShape),
        contentScale = ContentScale.Crop
    )
}</pre> <p class="calibre3">Here, we are creating an avatar using <code>AsyncImage</code>, which will load an image provided by a URL. This image will be modified to have a circular shape. Also, we should pass the size of the image when using this composable (we have chosen 50 density-independent pixels).</p>
<p class="calibre3">Now, we <a id="_idIndexMarker084" class="calibre6 pcalibre1 pcalibre"/>can <a id="_idIndexMarker085" class="calibre6 pcalibre1 pcalibre"/>create <code>ConversationItem</code>:</p>
<pre class="source-code">
import androidx.compose.foundation.layout.*
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.packt.feature.conversations.ui.model.Conversation
import com.packt.framework.ui.Avatar
@Composable
fun ConversationItem(conversation: Conversation) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Avatar(
            imageUrl = conversation.avatar,
            size = 50.dp,
            contentDescription =
                "${conversation.name}'s avatar"
        )
        Spacer(modifier = Modifier.width(8.dp))
        Column {
            Text(
                text = conversation.name,
                fontWeight = FontWeight.Bold,
                modifier = Modifier.fillMaxWidth(0.7f)
            )
            Text(text = conversation.message)
        }
        Spacer(modifier = Modifier.width(8.dp))
        Column(horizontalAlignment = Alignment.End) {
            Text(text = conversation.timestamp)
            if (conversation.unreadCount &gt; 0) {
                Text(
                    text =
                    conversation.unreadCount.toString(),
                    color = MaterialTheme.colors.primary,
                    modifier = Modifier.padding(top = 4.dp)
                )
            }
        }
    }
}</pre> <p class="calibre3">Let’s take a closer look at what this composable does:</p>
<ul class="calibre15">
<li class="calibre14">The <strong class="source-inline1">ConversationItem</strong> composable accepts the following parameters: name, message, timestamp, <strong class="source-inline1">avatarUrl</strong>, and an optional <strong class="source-inline1">unreadMessages </strong>with a default value of <strong class="source-inline1">0</strong>.</li>
<li class="calibre14">A <strong class="source-inline1">Row</strong> layout is used to arrange the contents horizontally. It has a <strong class="source-inline1">fillMaxWidth()</strong> modifier to occupy the full width of the parent and a padding of 8 density-independent pixels.</li>
<li class="calibre14">The <strong class="source-inline1">Avatar</strong> composable is used to display the avatar. We already know how it works – the only thing to remark on is that we want it to have a size of 50 density-independent pixels.</li>
<li class="calibre14">A <strong class="source-inline1">Spacer</strong> composable with a width of 8 density pixels is added to provide some space between the avatar and the text content.</li>
<li class="calibre14">A <strong class="source-inline1">Column</strong> layout is used to arrange the name and message text vertically. The <strong class="source-inline1">Column</strong> layout has a <strong class="source-inline1">Modifier.weight()</strong> modifier, which ensures that it takes up all the available space between the avatar and the timestamp.</li>
<li class="calibre14">Inside the <strong class="source-inline1">Column</strong> layout, a <strong class="source-inline1">Text</strong> composable is used to display the name with a bold font<a id="_idIndexMarker086" class="calibre6 pcalibre1 pcalibre"/> weight and a font size<a id="_idIndexMarker087" class="calibre6 pcalibre1 pcalibre"/> of 16 scale-independent pixels. Another <strong class="source-inline1">Text</strong> composable is used to display the message with a maximum of one line and an ellipsis overflow.</li>
<li class="calibre14">Another <strong class="source-inline1">Column</strong> layout is added to the main <strong class="source-inline1">Row</strong> layout to arrange the timestamp and unread messages badge vertically. The <strong class="source-inline1">Column</strong> layout has a <strong class="source-inline1">horizontalAlignment</strong> value of <strong class="source-inline1">Alignment.End</strong> to align its children to the end of the available space.</li>
<li class="calibre14">Inside this second <strong class="source-inline1">Column</strong> layout, a <strong class="source-inline1">Text</strong> composable is used to display the time with a font size of 12 scale-independent pixels and a gray color.</li>
<li class="calibre14">A conditional statement checks if there are any unread messages (that is, <strong class="source-inline1">conversation.unreadMessages &gt; 0</strong>). If there are unread messages, the unread messages count shows a text with a circular background drawn using the <strong class="source-inline1">drawBehind</strong> modifier.</li>
</ul>
<p class="calibre3">Now that we <a id="_idIndexMarker088" class="calibre6 pcalibre1 pcalibre"/>have our <code>ConversationItem</code> composable, it is<a id="_idIndexMarker089" class="calibre6 pcalibre1 pcalibre"/> time to finish this screen. Let’s create the <code>ConversationList</code> composable!</p>
<h2 id="_idParaDest-30" class="calibre7"><a id="_idTextAnchor030" class="calibre6 pcalibre1 pcalibre"/>Creating the ConversationList composable</h2>
<p class="calibre3">As the last step<a id="_idIndexMarker090" class="calibre6 pcalibre1 pcalibre"/> for this screen, we<a id="_idIndexMarker091" class="calibre6 pcalibre1 pcalibre"/> are going to create the list of conversations:</p>
<pre class="source-code">
@Composable
fun ConversationList(conversations: List&lt;Conversation&gt;) {
    LazyColumn {
        items(conversations) { conversation -&gt;
            ConversationItem(
                conversation = conversation
            )
        }
    }
}</pre> <p class="calibre3">The <code>ConversationList</code> composable takes a list of <code>Conversation</code> objects and uses <code>LazyColumn</code> to display them efficiently. The <code>items</code> function is used to loop through the conversations list and will render <code>ConversationItem</code> for each conversation.</p>
<p class="calibre3">Finally, we will include the list in the <code>HorizontalPager</code> logic, in our <code>ConversationsListScreen</code> composable:</p>
<pre class="source-code">
HorizontalPager(
    modifier = Modifier.padding(innerPadding),
    pageCount = tabs.size,
    state = pagerState
) { index -&gt;
    when (index) {
        0 -&gt; {
            //Status
        }
        1 -&gt; {
            ConversationList(
                conversations = emptyList(), // Leaving the
                                                list empty
                                                for now
                onConversationClick = onConversationClick
            )
        }
        2-&gt; {
            // Calls
        }
    }
}</pre> <p class="calibre3">If we want to <a id="_idIndexMarker092" class="calibre6 pcalibre1 pcalibre"/>test it, we <a id="_idIndexMarker093" class="calibre6 pcalibre1 pcalibre"/>can fake the data of the conversations:</p>
<pre class="source-code">
fun generateFakeConversations(): List&lt;Conversation&gt; {
    return listOf(
        Conversation(
            id = "1",
            name = "John Doe",
            message = "Hey, how are you?",
            timestamp = "10:30",
            avatar = "https://i.pravatar.cc/150?u=1",
            unreadCount = 2
        ),
        Conversation(
            id = "2",
            name = "Jane Smith",
            message = "Looking forward to the party!",
            timestamp = "11:15",
            avatar = "https://i.pravatar.cc/150?u=2"
        ),
//Add more conversations here</pre> <p class="calibre3">Note that here, I’m<a id="_idIndexMarker094" class="calibre6 pcalibre1 pcalibre"/> using a random avatar <a id="_idIndexMarker095" class="calibre6 pcalibre1 pcalibre"/>generator just to make it as similar as possible to how it would be when we connect this UI with real conversations.</p>
<p class="calibre3">The following screenshot shows what our app would look like with more conversations:</p>
<div><div><img alt="Figure 1.12: ConversationsList screen completed" src="img/B19443_01_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.12: ConversationsList screen completed</p>
<p class="calibre3">Now, let’s switch to the chat screen, also known as the messages list. Whereas the conversations<a id="_idIndexMarker096" class="calibre6 pcalibre1 pcalibre"/> list is a list showing all the<a id="_idIndexMarker097" class="calibre6 pcalibre1 pcalibre"/> conversations we have, the messages list will show the list of messages we have with one user (a single chat screen).</p>
<h1 id="_idParaDest-31" class="calibre5"><a id="_idTextAnchor031" class="calibre6 pcalibre1 pcalibre"/>Building the messages list</h1>
<p class="calibre3">In this section, we<a id="_idIndexMarker098" class="calibre6 pcalibre1 pcalibre"/> are going to create the UI models<a id="_idIndexMarker099" class="calibre6 pcalibre1 pcalibre"/> that are needed to create the chat screen and the messages two users could have exchanged. Then, we will create the <code>Message</code> composable, and finally, the rest of the screen, including<a id="_idIndexMarker100" class="calibre6 pcalibre1 pcalibre"/> the list <a id="_idIndexMarker101" class="calibre6 pcalibre1 pcalibre"/>of messages.</p>
<h2 id="_idParaDest-32" class="calibre7"><a id="_idTextAnchor032" class="calibre6 pcalibre1 pcalibre"/>Modeling the Chat and Message models</h2>
<p class="calibre3">Taking into account <a id="_idIndexMarker102" class="calibre6 pcalibre1 pcalibre"/>the<a id="_idIndexMarker103" class="calibre6 pcalibre1 pcalibre"/> information we have to show on the chat screen, we are going to need two data models: one for the static data related to the conversation (for example, the name of the user we are talking to, their avatar, and so on) and one data model per message. This will be the model for the <code>Chat</code> model:</p>
<pre class="source-code">
data class Chat(
    val id: String,
    val name: String,
    val avatar: String
)</pre> <p class="calibre3">In this case, we will need the ID of the chat, the name of the person we are talking to, and their avatar address.</p>
<p class="calibre3">Regarding the <code>Message</code> model, we will create the following classes:</p>
<pre class="source-code">
data class Message(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val timestamp: String,
    val isMine: Boolean,
    val messageContent: MessageContent
)
sealed class MessageContent {
    data class TextMessage(val message: String) :
        MessageContent()
    data class ImageMessage(val imageUrl: String,
        val contentDescription: String) : MessageContent()
}</pre> <p class="calibre3">In this case, we need the sender’s name, their avatar, the timestamp, whether the message is mine or not (which we will take into account so that we can arrange the message one to the left or the right), and the content of the message.</p>
<p class="calibre3">Since our application is going to have two types of content (messages and images), we need two different kinds of <code>MessageContent</code>. That’s the reason it has been modeled as a sealed class. We<a id="_idIndexMarker104" class="calibre6 pcalibre1 pcalibre"/> have <a id="_idIndexMarker105" class="calibre6 pcalibre1 pcalibre"/>two data classes with the data needed for every type of message content.</p>
<p class="calibre3">Now, we need to convert these models into some composables.</p>
<h2 id="_idParaDest-33" class="calibre7"><a id="_idTextAnchor033" class="calibre6 pcalibre1 pcalibre"/>Creating the MessageItem composable</h2>
<p class="calibre3">The <code>MessageItem</code> composable <a id="_idIndexMarker106" class="calibre6 pcalibre1 pcalibre"/>is going<a id="_idIndexMarker107" class="calibre6 pcalibre1 pcalibre"/> to draw each of our chat messages.</p>
<p class="calibre3">To start, we will create a <code>Row</code> layout. We will set the arrangement of the row contents depending on the message’s author:</p>
<pre class="source-code">
@Composable
fun MessageItem(message: Message) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = if (message.isMine)
        Arrangement.End else Arrangement.Start
    ) {
...
}
}</pre> <p class="calibre3">Then, inside this row, we are going to place the rest of the components of the message. We will start with the avatar; we will only show the avatar if the message is not from the user:</p>
<pre class="source-code">
if (!message.isMine) {
    Avatar(
        imageUrl = message.senderAvatar,
        size = 40.dp,
        contentDescription = "${message.senderName}'s
                              avatar"
    )
    Spacer(modifier = Modifier.width(8.dp))
}</pre> <p class="calibre3">Then, we <a id="_idIndexMarker108" class="calibre6 pcalibre1 pcalibre"/>are <a id="_idIndexMarker109" class="calibre6 pcalibre1 pcalibre"/>going to add a <code>Column</code> layout so that we can arrange the rest of the message information:</p>
<pre class="source-code">
Column {
    if (message.isMine) {
        Spacer(modifier = Modifier.height(8.dp))
    } else {
        Text(
            text = message.senderName,
            fontWeight = FontWeight.Bold
        )
    }
    when (val content = message.messageContent) {
        is MessageContent.TextMessage -&gt; {
            Surface(
                shape = RoundedCornerShape(8.dp),
                color = if (message.isMine)
                MaterialTheme.colors.primarySurface else
                MaterialTheme.colors.secondary
            ) {
                Text(
                    text = content.message,
                    modifier = Modifier.padding(8.dp),
                    color = if (message.isMine)
                    MaterialTheme.colors.onPrimary else
                    Color.White
                )
            }
        }
        is MessageContent.ImageMessage -&gt; {
            AsyncImage(
                model = content.imageUrl,
                contentDescription =
                content.contentDescription,
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
        }
    }
    Text(
        text = message.timestamp,
        fontSize = 12.sp
    )
}</pre> <p class="calibre3">The message will include the following information:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">The name of the sender (if the author is not the current user)</strong>: To know if the message is from the current user, the app will check if the author of the message is the current user using <strong class="source-inline1">if (message.isMine</strong>. If this is positive, we will add a <strong class="source-inline1">Space</strong> composable; if the message author is not the current user, we will show the <strong class="source-inline1">Text</strong> composable and their name.</li>
<li class="calibre14"><strong class="bold">The content</strong>: The app will show a bubble containing text if the content is text. The color of the bubble will depend on whether the sender of the message is the current user and the time the message was created. A timestamp with the date and time of creation will be shown at the bottom of the message.</li>
</ul>
<p class="calibre3">Now that we<a id="_idIndexMarker110" class="calibre6 pcalibre1 pcalibre"/> have <code>MessageItem</code>, it’s time <a id="_idIndexMarker111" class="calibre6 pcalibre1 pcalibre"/>to create the rest of the chat screen.</p>
<h2 id="_idParaDest-34" class="calibre7"><a id="_idTextAnchor034" class="calibre6 pcalibre1 pcalibre"/>Adding the TopAppBar and BottomRow composables</h2>
<p class="calibre3">As we did for the<a id="_idIndexMarker112" class="calibre6 pcalibre1 pcalibre"/> conversations list, we <a id="_idIndexMarker113" class="calibre6 pcalibre1 pcalibre"/>are going to add the <code>Scaffold</code> structure and its <code>TopAppBar</code> and <code>BottomRow</code> composables to this screen:</p>
<pre class="source-code">
@Composable
fun ChatScreen(
    chatId: String?,
    onBack: () -&gt; Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(stringResource(
                    R.string.chat_title, "Alice"))
                }
            )
        },
        bottomBar = {
            SendMessageBox()
        }
    ) { paddingValues-&gt;
        ListOfMessages(paddingValues = paddingValues)
    }
}</pre> <p class="calibre3">Note that we are hardcoding the title of the chat. This is just for preview purposes; we’ll correct that in<a id="_idIndexMarker114" class="calibre6 pcalibre1 pcalibre"/> the<a id="_idIndexMarker115" class="calibre6 pcalibre1 pcalibre"/> next chapter.</p>
<p class="calibre3">In the case of the bottom bar, we are adding a new composable that will contain <code>Textfield</code> and the send button needed to send a message. This is what this composable will look like:</p>
<pre class="source-code">
@Composable
fun SendMessageBox() {
    Box(
        modifier = Modifier
            .defaultMinSize()
            .padding(top = 0.dp, start = 16.dp,
                end = 16.dp,
            bottom = 16.dp)
            .fillMaxWidth()
    ) {
        var text by remember { mutableStateOf("") }
        OutlinedTextField(
            value = text,
            onValueChange = { newText -&gt; text = newText },
            modifier = Modifier
                .fillMaxWidth(0.85f)
                .align(Alignment.CenterStart)
                .height(56.dp),
        )
        IconButton(
            modifier = Modifier
                .align(Alignment.CenterEnd)
                .height(56.dp),
            onClick = {
                // Send message here
                text = ""
            }
        ) {
            Icon(
                imageVector = Icons.Default.Send,
                tint = MaterialTheme.colors.primary,
                contentDescription = "Send message"
            )
        }
    }
}</pre> <p class="calibre3">Here, we are creating a <code>Box</code> composable to arrange the children composables accordingly (the text field at the left and the <code>Send</code> button at the right). Then, we’re defining a property called <code>text</code> to store text field changes and using the <code>remember</code> delegate to remember its last value between recompositions.</p>
<p class="calibre3">As shown in the preceding code block, the main components of this composable are as follows:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">OutlinedTextField</strong>: To write the message. It will take its value from the text property and modify it every time the value of the text field changes.</li>
<li class="calibre14"><strong class="source-inline1">IconButton</strong>: To send the message. Its <strong class="source-inline1">onClick</strong> parameter is not doing anything yet (apart from restarting the <strong class="source-inline1">text</strong> property value). We will configure this in the next chapter.</li>
</ul>
<p class="calibre3">With that, our <a id="_idIndexMarker116" class="calibre6 pcalibre1 pcalibre"/>chat screen <a id="_idIndexMarker117" class="calibre6 pcalibre1 pcalibre"/>is almost ready. The last thing we need to do is add the messages list.</p>
<h2 id="_idParaDest-35" class="calibre7"><a id="_idTextAnchor035" class="calibre6 pcalibre1 pcalibre"/>Adding the messages list</h2>
<p class="calibre3">Earlier, we were adding <a id="_idIndexMarker118" class="calibre6 pcalibre1 pcalibre"/>the messages list as a composable<a id="_idIndexMarker119" class="calibre6 pcalibre1 pcalibre"/> in the <code>content</code> parameter of the <code>Scaffold</code> composable. This composable will look as follows:</p>
<pre class="source-code">
@Composable
fun ListOfMessages(paddingValues: PaddingValues) {
    Box(modifier = Modifier
        .fillMaxSize()
        .padding(paddingValues)) {
        Row(modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
        ) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize(),
                verticalArrangement =
                    Arrangement.spacedBy(8.dp),
            ) {
                items(getFakeMessages()) { message -&gt;
                    MessageItem(message = message)
                }
            }
        }
    }
}</pre> <p class="calibre3">With that, we have <a id="_idIndexMarker120" class="calibre6 pcalibre1 pcalibre"/>added <code>LazyColumn</code>, which will <a id="_idIndexMarker121" class="calibre6 pcalibre1 pcalibre"/>show the list – every item in the list is a <code>MessageItem</code> composable.</p>
<p class="calibre3">Since we haven’t connected it to any kind of data source yet, we are using a function to generate a list of fake messages just for preview purposes:</p>
<pre class="source-code">
fun getFakeMessages(): List&lt;Message&gt; {
    return listOf(
        Message(
            id = "1",
            senderName = "Alice",
            senderAvatar =
                "https://i.pravatar.cc/300?img=1",
            isMine = false,
            timestamp = "10:00",
            messageContent = MessageContent.TextMessage(
                message = "Hi, how are you?"
            )
        ),
        Message(
            id = "2",
            senderName = "Lucy",
            senderAvatar =
                "https://i.pravatar.cc/300?img=2",
            isMine = true,
            timestamp = "10:01",
            messageContent = MessageContent.TextMessage(
                message = "I'm good, thank you! And you?"
            )
        ),
)
}</pre> <p class="calibre3">You can add <a id="_idIndexMarker122" class="calibre6 pcalibre1 pcalibre"/>more messages if you want by adding them<a id="_idIndexMarker123" class="calibre6 pcalibre1 pcalibre"/> to the list that’s been created inside the <code>getFakeMessages()</code> function.</p>
<p class="calibre3">Finally, we should have a screen that looks like this:</p>
<div><div><img alt="Figure 1.13: Chat screen UI finished" src="img/B19443_01_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.13: Chat screen UI finished</p>
<p class="calibre3">With that, we <a id="_idIndexMarker124" class="calibre6 pcalibre1 pcalibre"/>are done with the user interface for<a id="_idIndexMarker125" class="calibre6 pcalibre1 pcalibre"/> now. We will continue working on this app during the next two chapters!</p>
<h1 id="_idParaDest-36" class="calibre5"><a id="_idTextAnchor036" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this first chapter, we started our first project, WhatsPackt, a messaging app.</p>
<p class="calibre3">We accomplished several initial tasks to build this app, such as organizing modules, preparing dependency injection and navigation, constructing the main screen, creating the conversations list, and building the messages list.</p>
<p class="calibre3">Throughout this process, we’ve learned about modularization and the various approaches to organizing it. We’ve also learned about popular libraries for managing dependency injection, how to initialize them, and how to set up Compose navigation. Additionally, we became familiar with using Jetpack Compose to create our user interface.</p>
<p class="calibre3">As we move forward, it’s time to give some love and life to our chats. In the next chapter, we will explore how to retrieve and send messages and integrate them into our recently created user interfaces.</p>
</div>
</body></html>