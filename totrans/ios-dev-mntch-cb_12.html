<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Multitasking</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detecting application states</li><li class="listitem" style="list-style-type: disc">Receiving notifications for application states</li><li class="listitem" style="list-style-type: disc">Running code in the background</li><li class="listitem" style="list-style-type: disc">Playing audio in the background</li><li class="listitem" style="list-style-type: disc">Network connectivity maintenance</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec01"/>Introduction</h1></div></div></div><p>When the iOS platform was introduced in 2007, bringing lots of exciting new features to users, it drastically changed the concept of mobile devices.</p><p>Despite its huge success, it lacked some features at the time that were considered as "basic". One of these features was multitasking; that is, support for running multiple processes at the same time. The platform actually did support multitasking to system processes internally, but it was not available to developers. Starting with iOS 4, Apple provided support for multitasking, although it is still quite different to what most developers are accustomed to.<a id="id933" class="indexterm"/>
</p><p>In this chapter, we will discuss how to make use of the platform's multitasking features. We will see under what circumstances we can use these features and what functionality we can provide through multitasking to the users of our applications. Specifically, we will learn about an application's states and its runtime lifecycle. Through a series of detailed example projects, we will be able to execute code while an application is in the background, support audio playback, and VoIP connection maintenance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec02"/>Detecting application states</h1></div></div></div><p>In this recipe, we will discuss how to detect and respond accordingly when an application transitions from the active to the inactive state, and vice versa.<a id="id934" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec01"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> AppStateApp</code>. There is no need for a view controller in this example.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add the following method overrides in the<code class="literal"> AppDelegate</code> class:<a id="id935" class="indexterm"/><div><pre class="programlisting">public override void OnActivated (UIApplication application){
Console.WriteLine("Activated, application state: {0}", application.ApplicationState);
}
public override void OnResignActivation (UIApplication application){
Console.WriteLine("Resign activation, application state: {0}", application.ApplicationState);
}
public override void DidEnterBackground (UIApplication application){
Console.WriteLine("Entered background, application state: {0}", application.ApplicationState);
}
public override void WillEnterForeground (UIApplication application){
Console.WriteLine("Will enter foreground, application state: {0}", application.ApplicationState);
}
</pre></div></li><li class="listitem"> Compile and run the application either on the simulator or on the device.</li><li class="listitem"> Press the<strong> home</strong> button to suspend the application, and watch the<strong> Application Output</strong> pad in MonoDevelop.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec03"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIApplicationDelegate</code> class contains methods that are triggered at specific notifications issued by the runtime. These methods are:<a id="id936" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OnActivated:</code> This method is called when the application is made active, for example, when unlocking the screen, or when the application starts.<a id="id937" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnResignActivation:</code> This method is called when the application is about to become inactive, for example, when the screen is locked or when the multitasking bar is presented.<a id="id938" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">DidEnterBackground:</code> This method is called when the application has entered the background, for example, when pressing the<strong> home</strong> button. The application is suspended.<a id="id939" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">WillEnterForeground:</code> This method is called when the application is about to return to the foreground.<a id="id940" class="indexterm"/></li></ul></div><p>Note that when the application is moved to the background, both the<code class="literal"> OnResignActivation</code> and<code class="literal"> DidEnterBackground</code> methods are called. Similarly, when the application is moved to the foreground, both the<code class="literal"> WillEnterForeground</code> and<code class="literal"> OnActivated</code> methods are called.</p><p>All these methods contain one parameter, which contains the<code class="literal"> UIApplication</code> instance of the application. The<code class="literal"> UIApplication</code> class contains the property<code class="literal"> ApplicationState</code>, which returns the state of the application in values of the<code class="literal"> UIApplicationState</code> property. These values are:<a id="id941" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Active:</code> This value indicates that the application is active</li><li class="listitem" style="list-style-type: disc"><code class="literal">Inactive:</code> This value indicates that the application is inactive, for example, when a notification alert is displayed</li><li class="listitem" style="list-style-type: disc"><code class="literal">Background:</code> This value indicates that the application is in the background</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec04"/>There's more...</h2></div></div></div><p>Multitasking is a feature of iOS 4+, and not all devices support multitasking, even if they are running on iOS 4+. For versions prior to 4, when the<strong> home</strong> button is pressed, the<code class="literal"> WillTerminate</code> method is called:<a id="id942" class="indexterm"/>
</p><div><pre class="programlisting">public override void WillTerminate (UIApplication application){
Console.WriteLine("App will terminate!");
}
</pre></div><p>There are cases, however, in which iOS will kill your application; for example, when a memory warning is issued and your application does not free up resources. The<code class="literal"> WillTerminate</code> method will also be called in these cases.<a id="id943" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec01"/>Support for multitasking</h3></div></div></div><p>To check if the device supports multitasking, check the<code class="literal"> UIDevice.CurrentDevice.IsMultitaskingSupported</code> property.<a id="id944" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec02"/>Proper usage</h3></div></div></div><p>These methods are very useful because they allow us to save the current data that is presented to the user when the application changes state. When the application transitions to an inactive or background state, each method is given a limited amount of time to execute, so we should make sure they do not perform long-running operations, or iOS will kill the application.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec03"/>Receiving notifications for application states</h1></div></div></div><p>In this recipe, we will discuss getting notified to application state changes outside the scope of the<code class="literal"> UIApplicationDelegate</code> implementation.<a id="id945" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec05"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> NotifyStatesApp</code>. Add a view with controller to the project, and name it<code class="literal"> MainController</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec06"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Enter the following fields in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private NSObject didEnterBgdObserver;
private NSObject willEnterFgdObserver;
</pre></div></li><li class="listitem"> Create the following methods:<div><pre class="programlisting">private void AddAppStateObservers(){
this.didEnterBgdObserver = NSNotificationCenter.DefaultCenter. AddObserver(UIApplication.DidEnterBackgroundNotification, delegate(NSNotification obj) {
Console.WriteLine("App entered background, app state: {0}", UIApplication.SharedApplication.ApplicationState);
} );
this.willEnterFgdObserver = NSNotificationCenter.DefaultCenter. AddObserver(UIApplication.WillEnterForegroundNotification, delegate(NSNotification obj) {
Console.WriteLine("App will enter foreground, app state: {0}", UIApplication.SharedApplication.ApplicationState);
} );
}
private void RemoveAppStateObservers(){
NSNotificationCenter.DefaultCenter.RemoveObservers(new NSObject[] { this.didEnterBgdObserver, this.willEnterFgdObserver });
}
</pre></div></li><li class="listitem"> In the<code class="literal"> ViewDidLoad</code> override, call the<code class="literal"> AddAppStateObservers</code> method:<a id="id946" class="indexterm"/><div><pre class="programlisting">this.AddAppStateObservers();
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Press the<strong> home</strong> button, and watch the output in the<strong> Application Output</strong> pad. It should be similar to the following screenshot:</li></ol></div><div><img src="img/1468EXP_12_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec07"/>How it works...</h2></div></div></div><p>Apart from calling the methods of the<code class="literal"> UIApplicationDelegate</code> object for application states, iOS issues notifications that we can receive. This is very useful, because in most cases we need to be notified for application state changes outside of the scope of the<code class="literal"> AppDelegate</code> class.<a id="id947" class="indexterm"/>
</p><p>To accomplish this, we use the<code class="literal"> NSNotificationCenter:</code>
<a id="id948" class="indexterm"/>
</p><div><pre class="programlisting">this.didEnterBgdObserver = NSNotificationCenter.DefaultCenter. AddObserver(UIApplication.DidEnterBackgroundNotification, delegate(NSNotification obj) {
Console.WriteLine("App entered background, app state: {0}", UIApplication.SharedApplication.ApplicationState);
} );
</pre></div><p>The notification keys we are interested in are exposed through the<code class="literal"> UIApplication</code> static properties. This example only adds notification observers for transition between background and foreground.<a id="id949" class="indexterm"/>
</p><p>The result is similar to the example of the previous recipe, but only after the<code class="literal"> MainController</code> is loaded.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec08"/>There's more...</h2></div></div></div><p>To add notification observers for when the application is activated or resigns activation, we use the<code class="literal"> UIApplication.DidBecomeActiveNotification</code> and<code class="literal"> UIApplication.WillResignActiveNotification</code> keys, respectively.<a id="id950" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec03"/>Removing notification observers</h3></div></div></div><p>To remove the notification observers when they are no longer needed, call the<code class="literal"> RemoveAppStateObservers</code> method inside the<code class="literal"> ViewDidUnload</code> override:<a id="id951" class="indexterm"/>
</p><div><pre class="programlisting">this.RemoveAppStateObservers();
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec09"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Detecting application states</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec04"/>Running code in the background</h1></div></div></div><p>In this recipe, we will learn how to execute code in the background, taking full advantage of iOS' multitasking feature.<a id="id952" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec10"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> BackgroundCodeApp</code>. There is no need for a view controller in this example.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec11"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Enter the following code in the<code class="literal"> AppDelegate</code> class:<a id="id953" class="indexterm"/><div><pre class="programlisting">private int taskID;
public override void DidEnterBackground (UIApplication application){
if (UIDevice.CurrentDevice.IsMultitaskingSupported &amp;&amp; this.taskID == 0){
this.taskID = application.BeginBackgroundTask(delegate {
application.EndBackgroundTask(taskID);
this.taskID = 0;
} );
ThreadPool.QueueUserWorkItem(delegate {
for (int i = 0; i &lt; 60; i++){
Console.WriteLine("Task: {0} - Current Time: {1}", this.taskID, DateTime.Now);
Thread.Sleep(1000);
}
application.EndBackgroundTask(this.taskID);
this.taskID = 0;
} );
}
}
public override void WillEnterForeground (UIApplication application){
if (this.taskID != 0){
Console.WriteLine("Background task is running!");
} else{
Console.WriteLine("Background task completed!");
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Press the<strong> home</strong> button to make the application enter the background, and watch the<strong> Application Output</strong>.</li><li class="listitem"> Before the background task completes (one minute), bring the application to the foreground by either tapping on its icon in the multitasking bar, or on its icon on the<strong> home</strong> screen.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec12"/>How it works...</h2></div></div></div><p>In the previous tasks, we learned how to get informed of an application's transitions from the foreground to the background, and vice versa.</p><p>Multitasking on iOS is not quite what we are used to on other platforms. The iOS platform makes sure that the foreground application will have all the available resources at its disposal (and the user's). To accomplish this, when the application enters the background, it is being suspended by the operating system. When it is suspended, it does not execute any code whatsoever.<a id="id954" class="indexterm"/>
</p><p>If we want to prevent the application from being suspended when the user presses the<strong> home</strong> button, we can ask for background time. The time we ask for is limited to 600 seconds (10 minutes), which is more than enough for the majority of tasks we are likely to perform in the background (for example, save UI state, complete a file download/upload, close any open connections, and so on).</p><p>To ask for background time, we call the<code class="literal"> BeginBackgroundTask</code> method of our<code class="literal"> UIApplication</code> instance:<a id="id955" class="indexterm"/>
</p><div><pre class="programlisting">this.taskID = application.BeginBackgroundTask(delegate {
application.EndBackgroundTask(taskID);
this.taskID = 0;
} );
</pre></div><p>The method accepts one parameter of the type<code class="literal"> NSAction</code> and returns an integer, which corresponds to the task ID. The<code class="literal"> NSAction</code> parameter represents the block of code that will be executed just before the background time elapses. Inside that block of code, we have to call the<code class="literal"> EndBackgroundTask</code> method, passing the ID of the task that was started, which will inform the runtime that we no longer need background time. Each call of<code class="literal"> BeginBackgroundTask</code> should be followed by a call to<code class="literal"> EndBackgroundTask</code>. If we do not call this method and the background time elapses, the application will be terminated.<a id="id956" class="indexterm"/>
</p><p>After calling the<code class="literal"> BeginBackgroundTask</code> method, we can execute the code we want. To allow the<code class="literal"> DidEnterBackground</code> method to complete and to avoid blocking the main thread, we just enclose our code to either an asynchronous call, or in a separate thread. In this example, we use a thread from the<code class="literal"> ThreadPool</code>. Since this specific task will be completed before the time we have elapses, we call the<code class="literal"> EndBackgroundTask</code> method to let the system know that the job is done. The block of code we passed to the<code class="literal"> BeginBackgroundTask</code> method will not be executed, since we ended the task.</p><p>There are cases, however, where the user might bring the application to the foreground while a background task is still running. To cover this scenario, we need to override the<code class="literal"> WillEnterForeground</code> method and handle it in an appropriate manner. We can either stop the background task (by calling<code class="literal"> EndBackgroundTask)</code>, or provide some sort of feedback to the user that a task is still running. Making an asynchronous call to our code in this scenario is best practice. If the code of our background task is synchronous, when the user brings the application to the foreground and the task is still running, the application will be frozen until the task completes.<a id="id957" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec13"/>There's more...</h2></div></div></div><p>To know how much time is left to perform background tasks, we can check the value of the<code class="literal"> BackgroundTimeRemaining</code> property:<a id="id958" class="indexterm"/>
</p><div><pre class="programlisting">Console.WriteLine("Remaining time: {0}", application.BackgroundTimeRemaining);
</pre></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec04"/>Important considerations for background code</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Do not update the UI while the application is in the background:</strong> doing so may cause your application to be terminated or crash. Any updates to UI elements that take place while the application is in the background are queued to be performed when it returns to the foreground. This will surely make the application unresponsive.<a id="id959" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Do not inform the user to bring your application to the foreground, just to give more time to the task:</strong> doing so will surely get your application rejected from the application store approval process. If a background task is in progress and the user brings the application to the foreground, moving the application back to the background again basically resets the background time.</li><li class="listitem" style="list-style-type: disc">Perform lightweight operations in the background to avoid the runtime from killing your application.</li><li class="listitem" style="list-style-type: disc">Avoid using external resources (for example, resources retrieved through the assets library).</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec14"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Detecting application states</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec05"/>Playing audio in the background</h1></div></div></div><p>In this recipe, we will learn how to prevent the application from being suspended, in order to allow audio playback.<a id="id960" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec15"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> BackgroundAudioApp</code>. Add a button on the view of<code class="literal"> MainController</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec16"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> Info.plist</code> file, and add the key<code class="literal"> UIBackgroundModes</code>.<a id="id961" class="indexterm"/></li><li class="listitem"> Add the item audio under it. Add the<code class="literal"> MonoTouch.AVFoundation</code> namespace.</li><li class="listitem"> Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private AVAudioPlayer audioPlayer;
public override void ViewDidLoad (){
base.ViewDidLoad ();
NSError error = null;
AVAudioSession.SharedInstance ().SetCategory (AVAudioSession.CategoryPlayback, out error);
if (error != null){
Console.WriteLine("Error setting audio session category: {0}", error.LocalizedDescription);
}
this.audioPlayer = AVAudioPlayer.FromUrl(NSUrl.FromFilename ("audio/sound.m4a"));
this.buttonStart.TouchUpInside += delegate {
this.audioPlayer.Play();
} ;
}
</pre></div></li><li class="listitem"> Add a sound file to the project, and set its<strong> Build Action</strong> to<strong> Content</strong>. This example uses a 20 second-long sound file named<code class="literal"> sound.m4a</code>.</li><li class="listitem"> Compile and run the application on the device.</li><li class="listitem"> Tap the<strong> Start playing</strong> button, and press the<strong> home</strong> button to make the application enter the background. Notice that the sound continues playing.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec17"/>How it works...</h2></div></div></div><p>To make sure our application will be able to play audio while it is in the background, we have to set the audio item in the<code class="literal"> UIBackgroundModes</code> key in the<code class="literal"> Info.plist</code> file.</p><p>In this example, we use the<code class="literal"> AVAudioPlayer</code> class to play a sound file. Just creating an instance of the class and calling its<code class="literal"> Play</code> method is not enough though. We have to set a specific type for the audio session category:<a id="id962" class="indexterm"/>
</p><div><pre class="programlisting">NSError error = null;
AVAudioSession.SharedInstance ().SetCategory (AVAudioSession.CategoryPlayback, out error);
</pre></div><p>The static method<code class="literal"> AVAudioSession.SharedInstance</code> returns the current audio session object. The audio session category is set to<code class="literal"> AVAudioSession.CategoryPlayback</code>, which allows the<code class="literal"> AVAudioPlayer</code> to play sounds while the application is in the background. This requirement is specific to objects in the<code class="literal"> MonoTouch.AVFoundation</code> namespace.<a id="id963" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec18"/>There's more...</h2></div></div></div><p>The available audio session categories are the following:<a id="id964" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryAmbient:</code> In this category, sounds are silenced when the device screen locks or when the device sound silence switch is on. Sounds from external resources (such as the iPod application) are mixed with this category.<a id="id965" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">CategorySoloAmbient:</code> This is the default category. Sounds from external resources are silenced with this category. Sounds are silenced when the screen is locked or when the device silent switch is on.<a id="id966" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryPlayback:</code> In this category, sounds are not silenced when the screen is locked or when the silent switch is on. Sounds from external resources are silenced, but can be mixed if the<code class="literal"> MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers</code> property is set to<code class="literal"> true</code>.<a id="id967" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryRecord:</code> This category is for recording audio. All audio playback is silenced. Recording continues even when the screen is locked.<a id="id968" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryPlayAndRecord:</code> This category is for applications that need to record and play audio. Sounds from external resources are silenced, but can be mixed if the<code class="literal"> MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers</code> property is set to<code class="literal"> true</code>. Sounds continue playing when the screen is locked or the silent switch is on.<a id="id969" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryAudioProcessing:</code> This category is specific for processing audio. Sound playback and recording is disabled.<a id="id970" class="indexterm"/></li></ul></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec05"/>Background state for audio</h3></div></div></div><p>Even when the application is configured through the<code class="literal"> Info.plist</code> file to support background audio playback, when the playback completes, the application will be suspended.<a id="id971" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec19"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Network connectivity maintenance</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch10.html" title="Chapter 10. Location Services and Maps">Chapter 10</a>, Location Services and Maps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Location services in the background</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec06"/>Network connectivity maintenance</h1></div></div></div><p>In this recipe, we will learn how to periodically wake the application to perform network connectivity checks.<a id="id972" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec20"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> NetCheckApp</code>. There is no need for a view controller in this example.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec21"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add the following<code class="literal"> DidEnterBackground</code> override in the<code class="literal"> AppDelegate</code> class:<div><pre class="programlisting">public override void DidEnterBackground (UIApplication application){
application.SetKeepAliveTimeout(610, delegate {
Console.WriteLine("App woken up for network connection maintenance!");
} );
}
</pre></div></li><li class="listitem"> Add the<code class="literal"> UIBackgroundModes</code> key in the<code class="literal"> Info.plist</code> file with the item<code class="literal"> voip</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec22"/>How it works...</h2></div></div></div><p>Apple provides this multitasking feature to allow applications utilizing<strong> Voice over Internet Protocol</strong> (VoIP) communication to perform periodic network connectivity checks with the appropriate servers. To allow the application to be woken for this functionality, call the<code class="literal"> SetKeepAliveTimeout</code> method of the<code class="literal"> UIApplication</code> class:<a id="id973" class="indexterm"/>
</p><div><pre class="programlisting">application.SetKeepAliveTimeout(610, delegate {
Console.WriteLine("App woken up for network connection maintenance!");
} );
</pre></div><p>The first parameter is the interval in seconds at which the application will be woken. The minimum interval that is allowed is 600 seconds (10 minutes). Setting an interval below the minimum value will cause the method to fail, and the application will be suspended. The second parameter is the handler that will be executed just before the interval elapses. This handler has only 30 seconds to execute. If it takes more than 30 seconds, the application will be terminated.<a id="id974" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec23"/>There's more...</h2></div></div></div><p>The objects that can be used for network connectivity in the keep alive handler are<code class="literal"> NSInputStream, NSOutputStream</code>, and<code class="literal"> NSUrlRequest</code>.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec06"/>Combining items for the UIBackgroundModes key</h3></div></div></div><p>An application can use any combination or all of the available items for the<code class="literal"> UIBackgroundModes</code> key. However, avoid adding a background mode for implementing different functionality than what it is intended for. In this case, your application will probably be rejected from the application store.<a id="id975" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec24"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Playing audio in the background</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch10.html" title="Chapter 10. Location Services and Maps">Chapter 10</a>, Location Services and Maps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Location services in the background</em></li></ul></div></div></div></body></html>