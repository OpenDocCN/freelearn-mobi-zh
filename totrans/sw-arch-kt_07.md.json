["```kt\ndata class Household(\n    val name: String,\n    val members: List<String>\n) {\n    init {\n        require(members.isNotEmpty()) { \"Household must have at least one member\" }\n    }\n}\n```", "```kt\nenum class ContractState {\n    DRAFTED,\n    UNDER_REVIEW,\n    AGREED,\n    REJECTED,\n    PARTIALLY_EXERCISED,\n    FULLY_EXERCISED,\n    WITHDRAWN\n}\n```", "```kt\ndata class Party(\n    val household: Household,\n    val serviceProvided: String,\n    val agreedAt: Instant? = null,\n    val completedAt: Instant? = null\n)\ndata class Contract(\n    val partyA: Party,\n    val partyB: Party,\n    val contractState: ContractState\n)\n```", "```kt\nfun draftContract(\n    householdA: Household,\n    householdB: Household,\n    serviceProvidedByHouseholdA: String,\n    serviceProvidedByHouseholdB: String,\n): Contract {\n    require(householdA != householdB) { \"Parties must be from different households\" }\n    return Contract(Party(\n        householdA,\n        serviceProvidedByHouseholdA,\n    ), Party(\n        householdB,\n        serviceProvidedByHouseholdB,\n    ), ContractState.DRAFTED)\n}\n```", "```kt\nfun draftContract(\n    householdA: Household,\n    householdB: Household,\n    serviceProvidedByHouseholdA: String,\n    serviceProvidedByHouseholdB: String,\n): Contract\n```", "```kt\n interface ContractService {\n    fun draftContract(\n        householdA: Household,\n        householdB: Household,\n        serviceProvidedByHouseholdA: String,\n        serviceProvidedByHouseholdB: String,\n    ): Contract\n}\n```", "```kt\ninterface ContractRepository {\n    fun save(contract: Contract)\n}\n```", "```kt\n class ContractServiceImpl(\n    private val contractRepository: ContractRepository,\n) : ContractService {\n    override fun draftContract(\n        householdA: Household,\n        householdB: Household,\n        serviceProvidedByHouseholdA: String,\n        serviceProvidedByHouseholdB: String,\n    ): Contract =\n        draftContract(\n            householdA,\n            householdB,\n            serviceProvidedByHouseholdA,\n            serviceProvidedByHouseholdB,\n        ).also { contractRepository.save(it) }\n}\n```", "```kt\ndata class DraftContractRequest(\n    val householdA: String,\n    val householdB: String,\n    val serviceProvidedByHouseholdA: String,\n    val serviceProvidedByHouseholdB: String\n)\n```", "```kt\ninterface HouseholdRepository {\n    fun findByName(householdName: String): Household?\n}\n```", "```kt\n@RestController\n@RequestMapping(\"/contracts/\")\nclass ContractController(\n    private val contractService: ContractService,\n    private val householdRepository: HouseholdRepository,\n) {\n```", "```kt\n    @PostMapping(\n        value = [\"draft\"],\n        consumes = [MediaType.APPLICATION_JSON_VALUE],\n        produces = [MediaType.APPLICATION_JSON_VALUE],\n    )\n```", "```kt\n    fun draftContract(\n        @RequestBody request: DraftContractRequest,\n    ): ResponseEntity<ContractDto> {\n        val householdA = householdRepository.findByName(request.householdA) ?: return ResponseEntity(HttpStatus.NOT_FOUND)\n        val householdB = householdRepository.findByName(request.householdB) ?: return ResponseEntity(HttpStatus.NOT_FOUND)\n```", "```kt\n         val contract =\n            contractService.draftContract(\n                householdA,\n                householdB,\n                request.serviceProvidedByHouseholdA,\n                request.serviceProvidedByHouseholdB,\n            )\n```", "```kt\n         return ResponseEntity(contract.toDto(), HttpStatus.CREATED)\n}\n```", "```kt\n data class ContractDto(\n    val householdA: String,\n    val householdB: String,\n    val serviceProvidedByHouseholdA: String,\n    val serviceProvidedByHouseholdB: String,\n    val contractState: String,\n)\n```", "```kt\n fun Contract.toDto(): ContractDto =\n    ContractDto(\n        partyA.household.name,\n        partyB.household.name,\n        this.partyA.serviceProvided,\n        this.partyB.serviceProvided,\n        this.contractState.name,\n    )\n```", "```kt\nenum class ErrorType {\n    HOUSEHOLD_NOT_FOUND,\n    SAME_HOUSEHOLD_IN_CONTRACT\n}\n```", "```kt\ndata class Error(\n    val reason: String,\n    val type: ErrorType\n)\n```", "```kt\n fun draftContract(\n    householdA: Household,\n    householdB: Household,\n    serviceProvidedByHouseholdA: String,\n    serviceProvidedByHouseholdB: String,\n): Either<Error, Contract> =\n```", "```kt\n    if (householdA.name == householdB.name) {\n        Either.Left(\n            Error(\"Parties must be from different households\", ErrorType.SAME_HOUSEHOLD_IN_CONTRACT),\n        )\n    }\n```", "```kt\n      else {\n        Either.Right(\n            Contract(\n                partyA = Party(householdA, serviceProvidedByHouseholdA),\n                partyB = Party(householdB, serviceProvidedByHouseholdB),\n                contractState = ContractState.DRAFTED,\n            ),\n        )\n    }\n```", "```kt\ntypealias HouseholdLookup = (String) -> Household?\ntypealias ContractPersist = (Contract) -> Either<Error, Contract>\n```", "```kt\nfun DraftContractRequest.ensureHouseholdExist(\n    householdLookup: HouseholdLookup\n): Either<Error, Pair<Household, Household>> {\n    val householdARecord = householdLookup(householdA)\n    val householdBRecord = householdLookup(householdB)\n    return if (householdARecord == null) {\n        Either.Left(\n            Error(\"Households not found: $householdA\", ErrorType.HOUSEHOLD_NOT_FOUND),\n        )\n    } else if (householdBRecord == null) {\n        Either.Left(\n            Error(\"Households not found: $householdB\", ErrorType.HOUSEHOLD_NOT_FOUND),\n        )\n    } else {\n        Either.Right(\n            householdARecord to householdBRecord,\n        )\n    }\n}\n```", "```kt\n @RequestMapping(\"/contracts/\")\nclass ContractControllerShell(\n    private val householdLookup: HouseholdLookup,\n    private val contractPersist: ContractPersist,\n) {\n    @PostMapping(\n        value = [\"draft\"],\n        consumes = [MediaType.APPLICATION_JSON_VALUE],\n        produces = [MediaType.APPLICATION_JSON_VALUE],\n    )\n```", "```kt\n    fun draft(\n        @RequestBody draftContractRequest: DraftContractRequest,\n    ): ResponseEntity<ContractDto> =\n        draftContractRequest\n            .ensureHouseholdExist(householdLookup)\n            .flatMap { (householdA, householdB) ->\n                draftContract(\n                    householdA,\n                    householdB,\n                    draftContractRequest.serviceProvidedByHouseholdA,\n                    draftContractRequest.serviceProvidedByHouseholdB,\n                )\n            }.flatMap { contractPersist(it) }\n            .flatMap { Either.Right(it.toDto()) }\n            .fold(\n                { error -> ResponseEntity(error.type.toHttpStatus()) },\n                { contractDto -> ResponseEntity(contractDto, HttpStatus.CREATED) },\n            )\n```", "```kt\nfun ErrorType.toHttpStatus(): HttpStatus = when (this) {\n    ErrorType.HOUSEHOLD_NOT_FOUND -> HttpStatus.NOT_FOUND\n    ErrorType.SAME_HOUSEHOLD_IN_CONTRACT -> HttpStatus.BAD_REQUEST\n}\n```", "```kt\ninterface HouseholdApiAction<R> {\n    fun toRequest(): Request\n    fun fromResponse(response: Response): R\n}\n```", "```kt\nval householdLens = Body.auto<Household>().toLens()\ndata class GetHousehold(\n    val householdName: String,\n) : HouseholdApiAction<Household> {\n    override fun toRequest(): Request = Request(Method.GET, \"/households/$householdName\")\n    override fun fromResponse(response: Response): Household = householdLens(response)\n}\n```", "```kt\ndata class Household(\n    val name: String,\n    val emailAddress: String,\n)\n```", "```kt\ninterface HouseholdApi {\n    operator fun <R : Any> invoke(action: HouseholdApiAction<R>): R\n    companion object\n}\n```", "```kt\nval token = \"fakeToken\"\nfun HouseholdApi.Companion.Http(client: HttpHandler) =\n    object : HouseholdApi {\n        private val http =\n SetBaseUriFrom(Uri.of(\"http://localhost:9000\"))\n                .then(\n                    Filter { next -> { next(it.header(\"Authorization\", \"Bearer $token\")) } },\n                ).then(client)\n        override fun <R : Any> invoke(action: HouseholdApiAction<R>) = action.fromResponse(http(action.toRequest()))\n    }\n```", "```kt\nfun HouseholdApi.getHousehold(householdName: String) = invoke(GetHousehold(householdName))\n```", "```kt\nval app: HttpHandler =\n    routes(\n        \"/households/{name}\" bind GET to { request ->\n            val householdName = request.path(\"name\")!!.toString()\n            Response(OK).with(householdLens of Household(name = householdName, emailAddress = \"same.address@domain.com\"))\n        },\n    )\nfun main() {\n    val householdApi = HouseholdApi.Http(JavaHttpClient())\n    val household: Household = householdApi.getHousehold(\"Whittington\")\n    println(household)\n}\n```", "```kt\n    @Test\n    fun `Get the household from Household API`() {\n        assertEquals(\n            Response(OK)\n                .contentType(ContentType.APPLICATION_JSON)\n                .body(\"{\\\"name\\\":\\\"Whittington\\\",\\\"emailAddress\\\":\\\"same.address@domain.com\\\"}\"),\n            app(Request(GET, \"/households/Whittington\")),\n        )\n    }\n```", "```kt\nclass DummyContractPersist: ContractPersist {\n    override fun invoke(p1: Contract): Either<Error, Contract> {\n```", "```kt\n    val persist = DummyContractPersist()\n    val result = persist(contract)\n```", "```kt\n    org.example.service.negotiation.entity\n    org.example.service.negotiation.usecase\n    org.example.service.negotiation.interface\n    org.example.service.negotiation.framework\n    org.example.service.negotiation.framework.rest\n    ```", "```kt\n    org.example.service.negotiation.core\n    org.example.service.negotiation.core.port\n    org.example.service.negotiation.adapter\n    org.example.service.negotiation.adapter.rest\n    ```", "```kt\n    org.example.service.negotiation.core\n    org.example.service.negotiation.shell\n    org.example.service.negotiation.shell.rest\n    ```", "```kt\n    val classes = ClassFileImporter().importPackages(\"fcis\")\n    @Test\n    fun `layer dependencies are_respected`() {\n        layeredArchitecture()\n            .consideringAllDependencies()\n            .layer(\"Imperative Shell\")\n            .definedBy(\"fcis.shell..\")\n            .layer(\"Functional Core\")\n            .definedBy(\"fcis.core..\")\n            .whereLayer(\"Imperative Shell\")\n            .mayNotBeAccessedByAnyLayer()\n            .whereLayer(\"Functional Core\")\n            .mayOnlyBeAccessedByLayers(\"Imperative Shell\")\n            .check(classes)\n    }\n```", "```kt\nimplementation(\"com.example:service-negotiation-core\")\n```"]