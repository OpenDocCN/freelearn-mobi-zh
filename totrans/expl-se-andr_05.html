<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Booting the System</h1></div></div></div><p>Now that we have an SE for Android system, we need to see how we can make use of it, and get it into a usable state. In this chapter, we will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Modify the log level to gain more details while debugging</li><li class="listitem" style="list-style-type: disc">Follow the boot process relative to the policy loader</li><li class="listitem" style="list-style-type: disc">Investigate SELinux APIs and SELinuxFS</li><li class="listitem" style="list-style-type: disc">Correct issues with the maximum policy version number</li><li class="listitem" style="list-style-type: disc">Apply patches to load and verify an NSA policy</li></ul></div><p>You might have noticed some disturbing error messages <code class="literal">dmesg</code> in <a class="link" href="ch04.html" title="Chapter 4. Installation on the UDOO">Chapter 4</a>, <em>Installation on the UDOO</em>. To refresh your memory, here are some of them:</p><div><pre class="programlisting">
<strong># dmesg | grep –i selinux</strong>
<strong>&lt;6&gt;SELinux: Initializing.</strong>
<strong>&lt;7&gt;SELinux: Starting in permissive mode</strong>
<strong>&lt;7&gt;SELinux: Registering netfilter hooks</strong>
<strong>&lt;3&gt;SELinux: policydb version 26 does not match my version range 15-23</strong>
<strong>...</strong>
</pre></div><p>It would appear that even though SELinux is enabled, we don't quite have an error-free system. At this point, we need to understand what causes this error, and what we can do to rectify it. At the end of this chapter, we should be able to identify the boot process of an SE for Android device with respect to policy loading, and how that policy is loaded into the kernel. We will then address the policy version error.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Policy load</h1></div></div></div><p>An <a id="id125" class="indexterm"/>Android device follows a boot sequence similar to that of the *NIX booting sequence. The boot loader boots the kernel, and the kernel finally executes the init process. The init process is responsible for managing the boot process of the device through init scripts and some hard coded logic in the daemon. Like all processes, init has an entry point at the main function. This is where the first userspace process begins. The code can be found by navigating to <code class="literal">system/core/init/init.c</code>.</p><p>When the<a id="id126" class="indexterm"/> init process enters <code class="literal">main</code> (refer to the following code excerpt), it processes <code class="literal">cmdline</code>, mounts some <code class="literal">tmpfs </code>filesystems such as <code class="literal">/dev</code>, and some pseudo-filesystems such as <code class="literal">procfs</code>. For SE for Android devices, init was modified to load the policy into the kernel as early in the boot process as possible. The policy in an SELinux system is not built into the kernel; it resides in a separate file. In Android, the only filesystem mounted in early boot is the root filesystem, a ramdisk built into <code class="literal">boot.img</code>. The policy can be found in this root filesystem at <code class="literal">/sepolicy</code> on the UDOO or target device. At this point, the init process calls a function to load the policy from the disk and sends it to the kernel, as follows:</p><div><pre class="programlisting">int main(int argc, char *argv[]) {
...
  process_kernel_cmdline();
  unionselinux_callback cb;
  cb.func_log = klog_write;
  selinux_set_callback(SELINUX_CB_LOG, cb);

  cb.func_audit = audit_callback;
  selinux_set_callback(SELINUX_CB_AUDIT, cb);

  INFO("loading selinux policy\n");
  if (selinux_enabled) {
    if (selinux_android_load_policy() &lt; 0) {
      selinux_enabled = 0;
      INFO("SELinux: Disabled due to failed policy load\n");
    } else {
      selinux_init_all_handles();
    }
  } else {
    INFO("SELinux:  Disabled by command line option\n");
  }
…</pre></div><p>In the preceding code, you will notice the very nice log message, <code class="literal">SELinux: Disabled due to failed policy load</code>, and wonder why we didn't see this when we ran <code class="literal">dmesg</code> before. This code executes before <code class="literal">setlevel</code> in <code class="literal">init.rc</code> is executed.</p><p>The default init log level is set by the definition of <code class="literal">KLOG_DEFAULT_LEVEL</code> in <code class="literal">system/core/include/cutils/klog.h</code>. If we really wanted to, we could change that, rebuild, and actually see that message.</p><p>Now that we have identified the initial path of the policy load, let's follow it on its course through the system. The <code class="literal">selinux_android_load_policy()</code> function can be found in the Android fork of <code class="literal">libselinux</code>, which is in the UDOO Android source tree. The library can be found at <code class="literal">external/libselinux</code>, and all of the Android modifications can be found in <code class="literal">src/android.c</code>.</p><p>The function starts by mounting a pseudo-filesystem called <strong>SELinuxFS</strong>. If you recall, this was<a id="id127" class="indexterm"/> one of the new filesystems mentioned in <code class="literal">/proc/filesystems</code> that we saw in <a class="link" href="ch04.html" title="Chapter 4. Installation on the UDOO">Chapter 4</a>, <em>Installation on the UDOO</em>. In systems that do not have <code class="literal">sysfs</code> mounted, the mount point is <code class="literal">/selinux</code>; on systems that have <code class="literal">sysfs</code> mounted, the mount point is <code class="literal">/sys/fs/selinux</code>.</p><p>You can <a id="id128" class="indexterm"/>check <code class="literal">mountpoints</code> on a running system using the following command:</p><div><pre class="programlisting">
<strong># mount | grep selinuxfs </strong>
<strong>selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</strong>
</pre></div><p>SELinuxFS is an important filesystem as it provides the interface between the kernel and userspace for controlling and manipulating SELinux. As such, it has to be mounted for the policy load to work. The policy load uses the filesystem to send the policy file bytes to the kernel. This happens in the <code class="literal">selinux_android_load_policy()</code> function:</p><div><pre class="programlisting">int selinux_android_load_policy(void)
{
  char *mnt = SELINUXMNT;
  int rc;
  rc = mount(SELINUXFS, mnt, SELINUXFS, 0, NULL);
  if (rc &lt; 0) {
    if (errno == ENODEV) {
      /* SELinux not enabled in kernel */
      return -1;
    }
    if (errno == ENOENT) {
      /* Fall back to legacy mountpoint. */
      mnt = OLDSELINUXMNT;
      rc = mkdir(mnt, 0755);
      if (rc == -1 &amp;&amp; errno != EEXIST) {
        selinux_log(SELINUX_ERROR,"SELinux: Could not mkdir:  %s\n",
        strerror(errno));
        return -1;
      }
      rc = mount(SELINUXFS, mnt, SELINUXFS, 0, NULL);
    }
  }
  if (rc &lt; 0) {
    selinux_log(SELINUX_ERROR,"SELinux:  Could not mount selinuxfs:  %s\n",
    strerror(errno));
    return -1;
  }
  set_selinuxmnt(mnt);

  return selinux_android_reload_policy();
}</pre></div><p>The <code class="literal">set_selinuxmnt(car *mnt)</code> function changes a global variable in <code class="literal">libselinux</code> so that other <a id="id129" class="indexterm"/>routines can find the location of this vital interface. From there it calls another helper function, <code class="literal">selinux_android_reload_policy()</code>, which is located in the same <code class="literal">libselinux</code> <code class="literal">android.c</code> file. It loops through an array of possible policy locations in priority order. This array is defined as follows:</p><div><pre class="programlisting">Static const char *const sepolicy_file[] = {
  "/data/security/current/sepolicy",
  "/sepolicy",
  0 };</pre></div><p>Since only the root filesystem is mounted, it chooses <code class="literal">/sepolicy</code> at this time. The other path is for dynamic runtime reloads of policy. After acquiring a valid file descriptor to the policy file, the system is memory mapped into its address space, and calls <code class="literal">security_load_policy(map, size)</code> to load it to the kernel. This function is defined in <code class="literal">load_policy.c</code>. Here, the map parameter is the pointer to the beginning of the policy file, and the size parameter is the size of the file in bytes:</p><div><pre class="programlisting">int selinux_android_reload_policy(void)
{
  int fd = -1, rc;
  struct stat sb;
  void *map = NULL;
  int i = 0;

  while (fd &lt; 0 &amp;&amp; sepolicy_file[i]) {
    fd = open(sepolicy_file[i], O_RDONLY | O_NOFOLLOW);
    i++;
  }
  if (fd &lt; 0) {
    selinux_log(SELINUX_ERROR, "SELinux:  Could not open sepolicy:  %s\n",
    strerror(errno));
    return -1;
  }
  if (fstat(fd, &amp;sb) &lt; 0) {
    selinux_log(SELINUX_ERROR, "SELinux:  Could not stat %s:  %s\n",
    sepolicy_file[i], strerror(errno));
    close(fd);
    return -1;
  }
  map = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
  if (map == MAP_FAILED) {
    selinux_log(SELINUX_ERROR, "SELinux:  Could not map %s:  %s\n",
    sepolicy_file[i], strerror(errno));
    close(fd);
    return -1;
  }

  rc = security_load_policy(map, sb.st_size);
  if (rc &lt; 0) {
    selinux_log(SELINUX_ERROR, "SELinux:  Could not load policy:  %s\n",
    strerror(errno));
    munmap(map, sb.st_size);
    close(fd);
    return -1;
  }

  munmap(map, sb.st_size);
  close(fd);
  selinux_log(SELINUX_INFO, "SELinux: Loaded policy from %s\n", sepolicy_file[i]);

  return 0;
}</pre></div><p>The security <a id="id130" class="indexterm"/>load policy opens the <code class="literal">&lt;selinuxmnt&gt;/load</code> file, which in our case is <code class="literal">/sys/fs/selinux/load</code>. At this point, the policy is written to the kernel via this pseudo file:</p><div><pre class="programlisting">int security_load_policy(void *data, size_t len)
{
  char path[PATH_MAX];
  int fd, ret;

  if (!selinux_mnt) {
    errno = ENOENT;
    return -1;
  }

  snprintf(path, sizeof path, "%s/load", selinux_mnt);
  fd = open(path, O_RDWR);
  if (fd &lt; 0)
  return -1;

  ret = write(fd, data, len);
  close(fd);
  if (ret &lt; 0)
  return -1;
  return 0;
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Fixing the policy version</h1></div></div></div><p>At this <a id="id131" class="indexterm"/>point, we have a clear idea of how the policy is loaded into the kernel. This is very important. SELinux integration with Android began in Android 4.0, so when porting to various forks and fragments, this breaks, and code is often missing. Understanding all parts of the system, however cursory, will help us to correct issues as they appear in the wild and develop. This information is also useful to understand the system as a whole, so when modifications need to be made, you'll know where to look and how things work. At this point, we're ready to correct the policy versions.</p><p>The logs and kernel config are clear; only policy versions up to 23 are supported, and we're trying to load policy version 26. This will probably be a common problem with Android considering kernels are often out of date.</p><p>There is also an issue with the 4.3 sepolicy shipped by Google. Some changes by Google made it a bit more difficult to configure devices as they tailored the policy to meet their release goals. Essentially, the policy allows nearly everything and therefore generates very few denial logs. Some domains in the policy are completely permissive via a per-domain permissive statement, and those domains also have rules to allow everything so denial logs do not get generated. To correct this, we can use a more complete policy from the NSA. Replace <code class="literal">external/sepolicy</code> with the download from <a class="ulink" href="https://bitbucket.org/seandroid/external-sepolicy/get/seandroid-4.3.tar.bz2">https://bitbucket.org/seandroid/external-sepolicy/get/seandroid-4.3.tar.bz2</a>.</p><p>After we extract the NSA's policy, we need to correct the policy version. The policy is located in <code class="literal">external/sepolicy</code> and is compiled with a tool called <code class="literal">check_policy</code>. The <code class="literal">Android.mk</code> file for sepolicy will have to pass this version number to the compiler, so we can adjust this here. On the top of the file, we find the culprit:</p><div><pre class="programlisting">
<strong>...</strong>
<strong># Must be &lt;= /selinux/policyvers reported by the Android kernel.</strong>
<strong># Must be within the compatibility range reported by checkpolicy -V.</strong>
<strong>POLICYVERS ?= 26</strong>
<strong>...</strong>
</pre></div><p>Since the variable is overridable by the <code class="literal">?=</code> assignment. We can override this in <code class="literal">BoardConfig.mk</code>. Edit <code class="literal">device/fsl/imx6/BoardConfigCommon.mk</code>, adding the following <code class="literal">POLICYVERS</code> line to the bottom of the file:</p><div><pre class="programlisting">
<strong>...</strong>
<strong>BOARD_FLASH_BLOCK_SIZE := 4096</strong>
<strong>TARGET_RECOVERY_UI_LIB := librecovery_ui_imx</strong>
<strong># SELinux Settings</strong>
<strong>POLICYVERS := 23</strong>
<strong>-include device/google/gapps/gapps_config.mk</strong>
</pre></div><p>Since the policy is on the <code class="literal">boot.img</code> image, build the policy and <code class="literal">bootimage</code>:</p><div><pre class="programlisting">
<strong>$ mmm -B external/sepolicy/</strong>
<strong>$ make –j4 bootimage 2&gt;&amp;1 | tee logz</strong>
<strong>!!!!!!!!! WARNING !!!!!!!!! VERIFY BLOCK DEVICE !!!!!!!!!</strong>
<strong>$ sudo chmod 666 /dev/sdd1</strong>
<strong>$ dd if=$OUT/boot.img of=/dev/sdd1 bs=8192 conv=fsync</strong>
</pre></div><p>Eject <a id="id132" class="indexterm"/>the SD card, place it into the UDOO, and boot.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>The first of the preceding commands should produce the following log output:</p><div><pre class="programlisting">
<strong>out/host/linux-x86/bin/checkpolicy: writing binary representation (version 23) to out/target/product/udoo/obj/ETC/sepolicy_intermediates/sepolicy</strong>
</pre></div></div></div><p>At this point, by checking the SELinux logs using <code class="literal">dmesg</code>, we can see the following:</p><div><pre class="programlisting">
<strong># dmesg | grep –i selinux</strong>
<strong>&lt;6&gt;init: loading selinux policy</strong>
<strong>&lt;7&gt;SELinux: 128 avtab hash slots, 490 rules.</strong>
<strong>&lt;7&gt;SELinux: 128 avtab hash slots, 490 rules.</strong>
<strong>&lt;7&gt;SELinux: 1 users, 2 roles, 274 types, 0 bools, 1 sens, 1024 cats</strong>
<strong>&lt;7&gt;SELinux: 84 classes, 490 rules</strong>
<strong>&lt;7&gt;SELinux: Completing initialization.</strong>
</pre></div><p>Another command we need to run is <code class="literal">getenforce</code>. The <code class="literal">getenforce</code> command gets the SELinux enforcing status. It can be in one of three states:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Disabled</strong>: No <a id="id133" class="indexterm"/>policy is loaded or there is no kernel support</li><li class="listitem" style="list-style-type: disc"><strong>Permissive</strong>: Policy<a id="id134" class="indexterm"/> is loaded and the device logs denials (but is not in enforcing mode)</li><li class="listitem" style="list-style-type: disc"><strong>Enforcing</strong>: This <a id="id135" class="indexterm"/>state is similar to the permissive state except that policy violations result in EACCESS being returned to userspace</li></ul></div><p>One of the goals while booting an SELinux system is to get to the enforcing state. Permissive is<a id="id136" class="indexterm"/> used for debugging, as follows:</p><div><pre class="programlisting">
<strong># getenforce</strong>
<strong>Permissive</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we covered the important policy load flow through the init process. We also changed the policy version to suit our development efforts and kernel version. From there, we were able to load the NSA policy and verify that the system loaded it. This chapter additionally showcased some of the SELinux APIs and their interactions with SELinuxFS. In the next chapter, we will examine the filesystem and then move forward in our quest to get the system into enforcing mode.</p></div></body></html>