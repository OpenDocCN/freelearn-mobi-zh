<html><head></head><body>
        

            
                <h1 class="header-title">Creating Your Own Device on VirtualBox</h1>
            

            
                
<p>We have learned how to customize and enhance an existing device to support new features using x86emu. The x86emu device is a device created on top of the following Android emulators: goldfish and ranchu. From this chapter to <a href="3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml">Chapter 11</a>, <em>Enabling VirtualBox-Specific Hardware Interfaces</em>, we will move to an advanced topic: porting  Android systems. What can we do with a hardware platform that is not supported by AOSP?</p>
<p>In this chapter, we will move to a new device, x86vbox. We will create this new x86vbox device to run it on VirtualBox. Since VirtualBox is virtual hardware that is not supported by AOSP directly, we have to create the HAL layer by ourselves. Creating the HAL layer by ourselves doesn't mean we have to create everything from scratch. As I mentioned earlier, porting and customization are the art of integration. We can integrate device drivers for the devices that we need from other open source projects. In this chapter, we will cover the following topics:</p>
<ul>
<li>Analyzing the HAL of the Android-x86 project and using the Android-x86 HAL for the x86vbox device</li>
<li>Creating the x86vbox device based on the analysis of Android-x86 HAL</li>
<li>Analyzing the start-up process for x86vbox</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">HAL of x86vbox</h1>
            

            
                
<p>Before we create the new x86vbox device, we need to resolve a key issue: creating the HAL for x86vbox. What this means is that we need to support the hardware devices that appear on VirtualBox. As we said previously, the Android-x86 project is a project that aims to provide <strong>Board Support Package</strong> (<strong>BSP</strong>) for any x86-based computing devices. Even though VirtualBox is a virtualized x86 hardware environment, we can still use part of Android-x86 projects to support it. In the following table, we can see a list of projects that we reused from Android-x86. There are three project categories that we need to include in our build from Android-x86:</p>
<ul>
<li><strong>Linux kernel</strong>: Android-x86 provides a kernel that can work with Android for Intel x86 architecture.</li>
<li><strong>HAL for Intel x86 architecture</strong>: Android-x86 includes HAL support on most devices that you can find on your PC.</li>
<li><strong>Android system projects and framework projects</strong>: Android-x86 changed some projects under the <kbd>system/</kbd> and <kbd>frameworks/</kbd> directories to meet x86 architecture-specific requirements. For example, <kbd>init</kbd> and <kbd>init.rc</kbd> under <kbd>system/core</kbd> have been changed to work with the two-stage start up of Android-x86.</li>
</ul>
<p>In the following table, we can also look at the projects in another dimension:</p>
<ul>
<li>AOSP projects changed by Android-x86.</li>
<li>Android-x86 only projects.</li>
<li>x86vbox--only projects.</li>
</ul>
<p>In this chapter and the following chapters, we will create the x86vbox device and make changes to some of the following projects to run x86vbox on VirtualBox.</p>
<p>In the following table, all kernel- and HAL-related projects from AOSP, Android-x86, and x86vbox are listed. The projects that are created or changed by them are marked with <strong>X</strong>:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Project</strong></p>
</td>
<td>
<p><strong>AOSP</strong></p>
</td>
<td>
<p><strong>Android-x86</strong></p>
</td>
<td>
<p><strong>x86vbox</strong></p>
</td>
<td>
<p><strong>HAL module</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>kernel</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>device/generic/x86vbox</kbd></p>
</td>
<td/>
<td/>
<td>
<p>X</p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>bionic</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>bootable/newinstaller</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>device/generic/common</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>device/generic/firmware</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/alsa-lib</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/alsa-utils</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/bluetooth/bluez</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>bluetooth.default</kbd><br/>
<kbd>audio.a2dp.default</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>external/bluetooth/glib</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/bluetooth/sbc</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/busybox</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/drm_gralloc</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>gralloc.drm</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>external/drm_hwcomposer</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>hwcomposer.drm</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>external/e2fsprogs</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/ffmpeg</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/libdrm</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/libpciaccess</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/libtruezip</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/llvm</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/mesa</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/s2tc</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/stagefright-plugins</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>external/v86d</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>frameworks/av</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>frameworks/base</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>frameworks/native</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>hardware/broadcom/wlan</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>hardware/gps</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>gps.default</kbd><br/>
<kbd>gps.huawei</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/intel/audio_media</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>audio.primary.hdmi</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/intel/libsensors</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>sensors.hsb</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/libaudio</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>audio.primary.x86</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/libcamera</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>camera.x86</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/libhardware</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>libhardware</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/libhardware_legacy</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>audio_policy.default</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/liblights</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>lights.default</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/libsensors</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>sensors.hdaps</kbd><br/>
<kbd>sensors.iio</kbd><br/>
<kbd>sensors.kbd</kbd><br/>
<kbd>sensors.s103t</kbd><br/>
<kbd>sensors.w500</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware/ril</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>hardware/x86power</kbd></p>
</td>
<td/>
<td>
<p>X</p>
</td>
<td/>
<td>
<p><kbd>power.x86</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>system/core</kbd></p>
</td>
<td>
<p>X</p>
</td>
<td>
<p>X</p>
</td>
<td/>
<td/>
</tr>
</tbody>
</table>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">The manifest for x86vbox</h1>
            

            
                
<p>Based on an analysis of the preceding table, we can create the manifest file for x86vbox. From the preceding table, we can see that we reuse 39 projects from Android-x86 to form the HAL of VirtualBox. Out of these 39 projects, 16 of them are from AOSP and changed by Android-x86. To run our x86vbox device on VirtualBox, we need to create the device x86vbox at <kbd>device/generic/x86vbox</kbd>. We also need to change four projects: <kbd>kernel</kbd>, <kbd>bootable/newinstaller</kbd>, <kbd>device/generic/common</kbd>, and <kbd>frameworks/base</kbd>.</p>
<p>In the manifest of the x86vbox, we will include the preceding projects for the x86 kernel, HAL, and have modified <kbd>system/</kbd> as well as <kbd>frameworks/</kbd>:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="github" <br/>           revision="refs/tags/android-7.1.1_r4_x86vbox_ch08_r1" <br/>           fetch="." /&gt; <br/><br/>  &lt;remote  name="aosp" <br/>           fetch="https://android.googlesource.com/" /&gt; <br/>  &lt;default revision="refs/tags/android-7.1.1_r4" <br/>           remote="aosp" <br/>           sync-c="true" <br/>           sync-j="1" /&gt; <br/><br/>  &lt;!-- github/android-7.1.1_r4_ch08 --&gt; <br/>  &lt;project path="kernel" name="goldfish" remote="github" /&gt; <br/>  &lt;project path="bootable/newinstaller"   <br/>  name="platform_bootable_newinstaller" <br/>  remote="github" /&gt; <br/>  &lt;project path="device/generic/common" name="device_generic_common" <br/>  groups="pdk" <br/>  remote="github" /&gt; <br/>  &lt;project path="device/generic/x86vbox" name="x86vbox" <br/>  remote="github" /&gt; <br/>  &lt;project path="bootable/recovery" name="android_bootable_recovery" <br/>  remote="github" groups="pdk" /&gt; <br/><br/>  &lt;project path="frameworks/base" name="platform_frameworks_base" <br/>  groups="pdk-cw-fs,pdk-fs" remote="github" /&gt; <br/><br/>  &lt;project path="bionic" name="platform_bionic" groups="pdk" <br/>  remote="github" /&gt; <br/>  &lt;project path="device/generic/firmware" <br/>  name="device_generic_firmware" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/alsa-lib" name="platform_external_alsa-lib" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/alsa-utils" <br/>  name="platform_external_alsa-utils" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/bluetooth/bluez" <br/>  name="platform_external_bluetooth_bluez" remote="github" /&gt; <br/>  &lt;project path="external/bluetooth/glib" <br/>  name="platform_external_bluetooth_glib" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/bluetooth/sbc" <br/>  name="platform_external_bluetooth_sbc" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/busybox" name="platform_external_busybox" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/drm_gralloc" <br/>  name="platform_external_drm_gralloc" <br/>  groups="drm_gralloc" remote="github" /&gt; <br/>  &lt;project path="external/drm_hwcomposer" <br/>  name="platform_external_drm_hwcomposer" <br/>  groups="drm_hwcomposer" remote="github" /&gt; <br/>  &lt;project path="external/e2fsprogs" name="platform_external_e2fsprogs" <br/>  groups="pdk" remote="github" /&gt; <br/>  &lt;project path="external/ffmpeg" name="platform_external_ffmpeg" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/libdrm" name="platform_external_libdrm" <br/>  groups="pdk" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/libtruezip" <br/>  name="platform_external_libtruezip" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/llvm" name="platform_external_llvm" <br/>  groups="pdk" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/mesa" name="platform_external_mesa" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/s2tc" name="platform_external_s2tc" <br/>  remote="github" /&gt; <br/>  &lt;project path="external/stagefright-plugins" <br/>  name="platform_external_stagefright-plugins" remote="github" /&gt; <br/>  &lt;project path="external/v86d" name="platform_external_v86d" <br/>  remote="github" /&gt; <br/>  &lt;project path="frameworks/av" name="platform_frameworks_av" <br/>  groups="pdk" <br/>  remote="github" /&gt; <br/>  &lt;project path="frameworks/native" name="platform_frameworks_native" <br/>  groups="pdk" remote="github" /&gt; <br/>  &lt;project path="hardware/broadcom/wlan" <br/>  name="platform_hardware_broadcom_wlan" <br/>  groups="pdk,broadcom_wlan" remote="github" /&gt; <br/>  &lt;project path="hardware/gps" name="platform_hardware_gps" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/intel/audio_media" <br/>  name="platform_hardware_intel_audio_media" groups="intel" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/intel/libsensors" <br/>  name="platform_hardware_intel_libsensors" remote="github" /&gt; <br/>  &lt;project path="hardware/libaudio" name="platform_hardware_libaudio" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/libcamera" name="platform_hardware_libcamera" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/libhardware" <br/>  name="platform_hardware_libhardware" <br/>  groups="pdk" remote="github" /&gt; <br/>  &lt;project path="hardware/libhardware_legacy" <br/>  name="platform_hardware_libhardware_legacy" groups="pdk" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/liblights" name="platform_hardware_liblights" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/libsensors" <br/>  name="platform_hardware_libsensors" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/ril" name="platform_hardware_ril" <br/>  groups="pdk" <br/>  remote="github" /&gt; <br/>  &lt;project path="hardware/x86power" name="platform_hardware_x86power" <br/>  remote="github" /&gt; <br/>  &lt;project path="system/core" name="platform_system_core" groups="pdk" <br/>  remote="github" /&gt; <br/><br/>  &lt;!-- aosp --&gt; <br/>  &lt;project path="build" name="platform/build" groups="pdk,tradefed" &gt; <br/>    &lt;copyfile src="img/root.mk" dest="Makefile" /&gt; <br/>  &lt;/project&gt; <br/><br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>We can see that the manifest of x86vbox includes two parts. The first part includes the x86 kernel, x86vbox HAL, and modified AOSP projects that are all in GitHub. The second part includes the original AOSP projects. All the projects in the second part are not touched by either Android-x86 or x86vbox. The majority of projects in the first part are changed by Android-x86 only so we don't have to do anything for these projects as well.</p>
<p>In the first part of manifest, all the projects in the <kbd>external/</kbd> or <kbd>hardware/</kbd> directory are x86 HAL-related projects. The only AOSP project that you may have questions is <strong>bionic</strong>. You may be wondering why it is changed by Android-x86, since it is the C library of Android. You may know that system calls are implemented in the C library in the Linux system. There are two system calls <kbd>ioperm</kbd> and <kbd>iopl</kbd> missing from the original bionic and they are needed by the <kbd>external/v86d</kbd> project, which is the user space daemon for the <kbd>vesafb</kbd> frame buffer driver.</p>
<p>All the preceding analysis helps us to clarify the scope of work. As we can see, the scope of work is not as big as we thought at the beginning. There are many open source projects available nowadays. If we can reuse them as much as possible, the amount of work usually can be reduced dramatically.</p>
<p>All Android-x86 projects in GitHub are forked from the Android-x86 mirror so that we can change them.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a new x86vbox device</h1>
            

            
                
<p>Once we have the HAL for VirtualBox, we can create a new device named x86vbox now. If we review how we created the x86emu device in <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a>, <em>Customizing the Android Emulator</em>, we know that we need to have a board/device configuration Makefile and a product definition Makefile for a new device. We can also create a new device by inheriting it from an existing device. If we look at the preceding table of x86 HAL, we can see that there is a common x86 device project, <kbd>device/common</kbd>, which can be found in Android-x86. We will create our new device x86vbox by inheriting from this common device for x86. The x86vbox that we create in this chapter is a 32-bit x86 device. You can follow the same instructions to create an x86_64 device by yourself.</p>
<p>As we did in <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a>, <em>Customizing the Android Emulator</em>, we create an <kbd>AndroidProducts.mk</kbd> Makefile to include the product definition Makefile for x86vbox as follows:</p>
<pre>
PRODUCT_MAKEFILES := \ <br/>    $(LOCAL_DIR)/x86vbox.mk 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Product definition Makefile of x86vbox</h1>
            

            
                
<p>As we know, the AOSP build system will look for <kbd>AndroidProducts.mk</kbd> to find the product definition Makefile for a particular device. Let's review the product definition Makefile <kbd>x86vbox.mk</kbd> as follows:</p>
<pre>
# includes the base of Android-x86 platform <br/>$(call inherit-product,device/generic/common/x86.mk) <br/><br/># Overrides <br/>PRODUCT_NAME := x86vbox <br/>PRODUCT_BRAND := Android-x86 <br/>PRODUCT_DEVICE := x86vbox <br/>PRODUCT_MODEL := x86vbox_ch8 <br/><br/>TARGET_KERNEL_SOURCE := kernel <br/>TARGET_KERNEL_CONFIG := android-x86_defconfig <br/>TARGET_ARCH := x86 <br/><br/>PRODUCT_OUT ?= out/target/product/$(PRODUCT_DEVICE) <br/><br/>include $(TARGET_KERNEL_SOURCE)/AndroidKernel.mk <br/><br/># define build targets for kernel <br/>.PHONY: $(TARGET_PREBUILT_KERNEL) <br/><br/>LOCAL_KERNEL := $(TARGET_PREBUILT_KERNEL) <br/><br/>PRODUCT_COPY_FILES += \ <br/>    $(LOCAL_KERNEL):kernel \ 
</pre>
<p>As we can see, the product definition Makefile is very simple. It does the following things:</p>
<ul>
<li>It includes the general x86 product definition Makefile, <kbd>device/generic/common/x86.mk</kbd></li>
<li>It defines product definition variables such as <kbd>PRODUCT_NAME</kbd>, <kbd>PRODUCT_BRAND</kbd>, <kbd>PRODUCT_DEVICE</kbd>, <kbd>PRODUCT_MODEL</kbd>, and so on</li>
<li>It specifies how to build the kernel for x86vbox</li>
</ul>
<p>It looks even simpler than the one we created in <a href="f69f330a-932c-4a32-bb78-e427c860b65e.xhtml">Chapter 4</a>, <em>Customizing the Android Emulator</em> for x86emu. The inherited <kbd>x86.mk</kbd> Makefile did most actual work and we will analyze it in greater depth later.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Board configuration of x86vbox</h1>
            

            
                
<p>Another Makefile that we will create for x86vbox is the board configuration Makefile <kbd>BoardConfig.mk</kbd> as follows:</p>
<pre>
TARGET_NO_BOOTLOADER := true <br/><br/>TARGET_ARCH := x86 <br/>TARGET_CPU_ABI := x86 <br/><br/>TARGET_CPU_ABI_LIST_32_BIT := $(TARGET_CPU_ABI) $(TARGET_CPU_ABI2) $(NATIVE_BRIDGE_ABI_LIST_32_BIT) <br/>TARGET_CPU_ABI_LIST := $(TARGET_CPU_ABI_LIST_32_BIT) <br/><br/>TARGET_USERIMAGES_USE_EXT4 := true <br/>BOARD_SYSTEMIMAGE_PARTITION_SIZE := 1153433600 <br/>BOARD_USERDATAIMAGE_PARTITION_SIZE := 419430400 <br/>BOARD_CACHEIMAGE_PARTITION_SIZE := 69206016 <br/>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4 <br/>BOARD_FLASH_BLOCK_SIZE := 512 <br/>TARGET_USERIMAGES_SPARSE_EXT_DISABLED := true <br/><br/>BOARD_SEPOLICY_DIRS += build/target/board/generic/sepolicy <br/>BOARD_SEPOLICY_DIRS += build/target/board/generic_x86/sepolicy <br/><br/>include device/generic/common/BoardConfig.mk 
</pre>
<p>This looks very simple as well. It defines the target architecture--specific variables <kbd>TARGET_ARCH</kbd>, <kbd>TARGET_CPU_ABI</kbd>, <kbd>TARGET_CPU_ABI_LIST_32_BIT</kbd>, and <kbd>TARGET_CPU_ABI_LIST</kbd>. Then it defines the parameters for the system image file. Finally, it includes the common board configuration the Makefile <kbd>device/generic/common/BoardConfig.mk</kbd> and we will look at this in a moment.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Common x86 devices</h1>
            

            
                
<p>In the Android-x86 project, it defines a common x86 device so that everybody can create a specific x86 device based on it. The inherited device can be either a 32-bit or a 64-bit x86 device.</p>
<p>We can have a look at the content of <kbd>device/generic/common</kbd> first as follows:</p>
<div><img height="291" width="454" class=" image-border" src="img/image_08_001.png"/></div>
<p>We can see that there are a lot of files and directories. We will start the analysis from the <kbd>BoardConfig.mk</kbd> and <kbd>x86.mk</kbd> Makefiles first.</p>
<p>In <kbd>BoardConfig.mk</kbd>, the variables needed by the build system are defined as follows:</p>
<pre>
TARGET_BOARD_PLATFORM := android-x86 <br/><br/># Some framework code requires this to enable BT <br/>BOARD_HAVE_BLUETOOTH := true <br/><br/>BOARD_USE_LEGACY_UI := true <br/><br/># BOARD_SYSTEMIMAGE_PARTITION_SIZE = $(if $(MKSQUASHFS),0,1610612736) <br/><br/># customize the malloced address to be 16-byte aligned <br/>BOARD_MALLOC_ALIGNMENT := 16 <br/><br/># Enable dex-preoptimization to speed up the first boot sequence <br/># of an SDK AVD. Note that this operation only works on Linux for now <br/>ifeq ($(HOST_OS),linux) <br/>WITH_DEXPREOPT := true <br/>WITH_DEXPREOPT_PIC := true <br/>endif <br/><br/># the following variables could be overridden <br/>TARGET_PRELINK_MODULE := false <br/>TARGET_NO_KERNEL ?= false <br/>TARGET_NO_RECOVERY ?= true <br/>TARGET_EXTRA_KERNEL_MODULES := tp_smapi <br/>ifneq ($(filter efi_img,$(MAKECMDGOALS)),) <br/>TARGET_KERNEL_ARCH ?= x86_64 <br/>endif <br/>TARGET_USES_64_BIT_BINDER := $(if $(filter x86_64,$(TARGET_ARCH) $(TARGET_KERNEL_ARCH)),true) <br/><br/>BOARD_USES_GENERIC_AUDIO ?= false <br/>BOARD_USES_ALSA_AUDIO ?= true <br/>... 
</pre>
<p>It is a long list. It defines audio, Wi-Fi, GPU, and Bluetooth-related features. It is also a disabled emulator-related build.</p>
<p>Now, let's have a look at <kbd>x86.mk</kbd>:</p>
<pre>
PRODUCT_PROPERTY_OVERRIDES := \ <br/>    ro.com.android.dateformat=MM-dd-yyyy \ <br/><br/>$(call inherit-product,$(LOCAL_PATH)/device.mk) <br/>$(call inherit-product,$(LOCAL_PATH)/packages.mk) <br/><br/># Get a list of languages. <br/>$(call inherit-product,$(SRC_TARGET_DIR)/product/locales_full.mk) <br/><br/># Get everything else from the parent package <br/>$(call inherit-product,$(SRC_TARGET_DIR)/product/full.mk) 
</pre>
<p>In <kbd>x86.mk</kbd>, it includes two generic Makefiles, <kbd>full.mk</kbd> and <kbd>locales_full.mk</kbd>, from the AOSP build system. If we recall the device definition Makefile for x86emu, it also includes these two Makefiles from the build system.</p>
<p>There are another two local Makefiles, <kbd>device.mk</kbd> and <kbd>packages.mk</kbd>, imported by <kbd>x86.mk</kbd>. In <kbd>packages.mk</kbd>, the HAL module packages are defined as follows:</p>
<pre>
PRODUCT_PACKAGES := \ <br/>    camera.x86 \ <br/>    com.android.future.usb.accessory \ <br/>    drmserver \ <br/>    gps.default \ <br/>    gps.huawei \ <br/>    hwcomposer.x86 \ <br/>    io_switch \ <br/>    libGLES_android \ <br/>    libhuaweigeneric-ril \ <br/>    lights.default \ <br/>    power.x86 \ <br/>    powerbtnd \ <br/>    sensors.hsb \ <br/>    tablet-mode \ <br/>    v86d \ <br/>    wacom-input \ <br/><br/>PRODUCT_PACKAGES += \ <br/>    libwpa_client \ <br/>    hostapd \ <br/>    wpa_supplicant \ <br/>    wpa_supplicant.conf \ 
</pre>
<p>This is not an exhaustive list of packages. There are more components added to <kbd>PRODUCT_PACKAGES</kbd> in <kbd>device.mk</kbd> as follows:</p>
<pre>
PRODUCT_DIR := $(dir $(lastword $(filter-out device/common/%,$(filter device/%,$(ALL_PRODUCTS))))) <br/><br/>PRODUCT_PROPERTY_OVERRIDES := \ <br/>    ro.ril.hsxpa=1 \ <br/>    ro.ril.gprsclass=10 \ <br/>    keyguard.no_require_sim=true \ <br/>    ro.com.android.dataroaming=true <br/><br/>PRODUCT_DEFAULT_PROPERTY_OVERRIDES := \ <br/>    ro.arch=x86 \ <br/>    persist.rtc_local_time=1 \ <br/><br/><strong>PRODUCT_COPY_FILES := \</strong><strong>...</strong> <br/>PRODUCT_TAGS += dalvik.gc.type-precise <br/><br/>PRODUCT_CHARACTERISTICS := tablet <br/><br/>PRODUCT_AAPT_CONFIG := normal large xlarge mdpi hdpi <br/>PRODUCT_AAPT_PREF_CONFIG := mdpi <br/><br/>DEVICE_PACKAGE_OVERLAYS := $(LOCAL_PATH)/overlay <br/><br/># Get the firmwares <br/>$(call inherit-product,device/generic/firmware/firmware.mk) <br/><br/># Get the touchscreen calibration tool <br/>$(call inherit-product-if-exists,external/tslib/tslib.mk) <br/><br/># Get the alsa files <br/>$(call inherit-product-if-exists,hardware/libaudio/alsa.mk) <br/><br/># Get GPS configuration <br/>$(call inherit-product-if-exists,device/common/gps/gps_as.mk) <br/><br/># Get the hardware acceleration libraries <br/>$(call inherit-product-if-exists,$(LOCAL_PATH)/gpu/gpu_mesa.mk) <br/><br/># Get the sensors hals <br/>$(call inherit-product-if-exists,hardware/libsensors/sensors.mk) <br/><br/># Get tablet dalvik parameters <br/>$(call inherit-product,frameworks/native/build/tablet-10in-xhdpi-2048-dalvik-heap.mk) <br/><br/># Get GMS <br/>$(call inherit-product-if-exists,vendor/google/products/gms.mk) <br/><br/># Get native bridge settings <br/>$(call inherit-product-if-exists,$(LOCAL_PATH)/nativebridge/nativebridge.mk) 
</pre>
<p>In <kbd>device.mk</kbd>, it defines the properties for x86 devices and it is followed by a long list of files to be copied. At the end, it includes individual Makefiles for various components, such as firmware, touchscreen a calibration tool, audio, GPS, a sensor and native bridge, and so on. You can find and investigate each of them in the respective folders by yourself. In this chapter, we just give an overview about how we can create the x86vbox device. We will delve into the details of some hardware interfaces in later chapters.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting the source code and building the x86vbox device</h1>
            

            
                
<p>To build the x86vbox device, we can get the source code from GitHub and AOSP using the following command:</p>
<pre>
<strong>$ repo init https://github.com/shugaoye/manifests -b android-7.1.1_r4_ch08_aosp</strong><br/><strong>$ repo sync</strong>  
</pre>
<p>The <kbd>android-7.1.1_r4_ch08_aosp</kbd> tag is used to baseline the changes in this chapter.</p>
<p>After we get the source code for this chapter, we can set the environment and build the system as follows:</p>
<pre>
<strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86vbox-eng</strong><br/><strong>$ make -j4</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Boot up process and device initialization</h1>
            

            
                
<p>Since we use the Android-x86 kernel and HAL for x86vbox, we will further analyze about the start-up process of x86vbox in this section. From the analysis, we can understand how Android-x86 supports multiple devices using one codebase. You can review the two-stage start-up process that we discussed in <a href="b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml">Chapter 6</a>, <em>Debugging the Boot Up Process using a Customized ramdisk</em>. We will work on a more detailed analysis on top of that introduction now.</p>
<p>The kernel of Android-x86 is different from the kernel that we used in <a href="b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml">Chapter 6</a>, <em>Debugging the Boot Up Process using a Customized ramdisk</em> for emulators. The Android-x86 kernel does not have any idea about what hardware interfaces it needs to support, so it builds as many device drivers as possible with it. On the other hand, the goldfish kernel does know what hardware it needs to support. This difference means they are built in two different ways. The goldfish kernel includes all devices supported inside the kernel, so it does not use kernel modules at all. However, it is impossible for Android-x86 kernel to do this, since it would make the size of the kernel too big. The kernel of Android-x86 uses kernel modules extensively.</p>
<p>We will focus on an analysis about how device nodes are created and how the kernel modules are loaded during the start-up process in this chapter. Since Android-x86 boots up in two stages, the device initialization is also split into two stages.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Device initialization before Android start-up</h1>
            

            
                
<p>The boot-up process will start with an embedded Linux environment as the first stage. Most devices will be initialized during this stage. The good thing is that Android-x86 can enter a shell environment with a debug console using a defined environment variable. In this console, we can check the system status to find out whether we have the right configuration that we want to create. The default init script comes with two debug checkpoints. The first checkpoint is after the root device is mounted. The second checkpoint is entered after all the drivers are loaded. Of course, you can set up as many checkpoints as you want by changing the init script.</p>
<p>The following is the part of the init script that we want to look at before we enter the first checkpoint:</p>
<pre>
PATH=/sbin:/bin:/system/bin:/system/xbin; export PATH <br/>... <br/># early boot <br/>if test x"$HAS_CTTY" != x"Yes"; then <br/>    # initialise /proc and /sys <br/>    busybox mount -t proc proc /proc <br/>    busybox mount -t sysfs sys /sys <br/>    # let busybox install all applets as symlinks <br/>    busybox --install -s <br/>    # spawn shells on tty 2 and 3 if debug or installer <br/>    if test -n "$DEBUG" || test -n "$INSTALL"; then <br/>        # ensure they can open a controlling tty <br/>        mknod /dev/tty c 5 0 <br/>        # create device nodes then spawn on them <br/>        mknod /dev/tty2 c 4 2 &amp;&amp; openvt <br/>        mknod /dev/tty3 c 4 3 &amp;&amp; openvt <br/>    fi <br/>    if test -z "$DEBUG" || test -n "$INSTALL"; then <br/>        echo 0 0 0 0 &gt; /proc/sys/kernel/printk <br/>    fi <br/>    # initialise /dev (first time) <br/>    mkdir -p /dev/block <br/>    echo /sbin/mdev &gt; /proc/sys/kernel/hotplug <br/>    mdev -s <br/>    # re-run this script with a controlling tty <br/>    exec env HAS_CTTY=Yes setsid cttyhack /bin/sh "$0" "$@" <br/>fi <br/>... 
</pre>
<p>In the early boot stage, the init script mounts the <kbd>/proc</kbd> and <kbd>/sys</kbd> filesystems using by kernels. After that, it sets up the symbolic links of <kbd>busybox</kbd> so that we can use all the commands of <kbd>busybox</kbd>. Then, it will set <kbd>/sbin/mdev</kbd> as the handler for hotplug. The <kbd>mdev</kbd> command is a minimal implementation of <kbd>udev</kbd>. <kbd>mdev</kbd> can dynamically manage the device nodes under <kbd>/dev</kbd>, when a new device is detected by the kernel. <kbd>mdev</kbd> is part of <kbd>busybox</kbd> so we need to create all <kbd>busybox</kbd> symbolic links first. It also requires the <kbd>/proc</kbd> and <kbd>/sys</kbd> filesystem. After the hotplug is set, the script runs the command <kbd>mdev -s</kbd> to find all existing devices currently found by the kernel. At this point, all device nodes under <kbd>/dev</kbd> are created.</p>
<p>udev and <strong>mdev</strong><strong><br/>
udev</strong> is a device manager for the Linux kernel. As the successor to devfsd and hotplug, udev primarily manages device nodes in the <kbd>/dev</kbd> directory. At the same time, udev also handles all user space events raised while hardware devices are added into the system or removed from it, including firmware loading as required by certain <strong>devices.</strong><br/>
<strong>mdev</strong> is a minimum implementation of udev in <kbd>busybox</kbd>. It is used in embedded systems to replace udev. mdev lacks some features in udev, such as completed implementation of device driver loading, and so on. We can see that Android-x86 uses mdev in the first start up stage.</p>
<p>Let's look at the kernel modules and device nodes at this stage:</p>
<div><img height="272" width="424" class=" image-border" src="img/image_08_002.png"/></div>
<p>Kernel modules and device nodes</p>
<p>As we can see from the preceding screenshot, all device nodes are created under <kbd>/dev</kbd>. However, there is only one kernel module loaded at this time. We are in the first checkpoint now.</p>
<p>Let's move on and see what happens in the script before we hit another checkpoint in the following code snippet. To exit from the first checkpoint, we need to run the <kbd>exit</kbd> command to continue executing the script.</p>
<pre>
<strong>(debug-found)@android:/android # exit</strong>  
</pre>
<p>After exit from the first checkpoint, it will continue to execute the following script:</p>
<pre>
... <br/>[ -n "$INSTALL" ] &amp;&amp; do_install <br/><br/>load_modules <br/>mount_data <br/>mount_sdcard <br/>setup_tslib <br/>setup_dpi <br/>post_detect <br/><br/>if [ 0$DEBUG -gt 1 ]; then <br/>    echo -e "\nUse Alt-F1/F2/F3 to switch between virtual consoles" <br/>    echo -e "Type 'exit' to enter Android...\n" <br/><br/>    debug_shell debug-late <br/>fi <br/><br/>... 
</pre>
<p>We can see that the init script performs the following tasks before it enters the next checkpoint:</p>
<ol>
<li>Loads kernel modules.</li>
<li>Mounts the data partition.</li>
<li>Mounts the SD card.</li>
<li>Sets up the touch screen calibration tool.</li>
<li>Sets up the screen DPI.</li>
<li>Performs any other post-boot detection.</li>
</ol>
<p>You can study the script for tasks 2 to 6 by yourself, since they are very straightforward and easy to understand. We want to look at the first task in more detail here:</p>
<pre>
auto_detect() <br/>{ <br/>    tmp=/tmp/dev2mod <br/>    echo 'dev2mod() { while read dev; do case $dev in' &gt; $tmp <br/>    sort -r /lib/modules/`uname -r`/modules.alias | \ <br/>        sed -n 's/^alias  *\([^ ]*\)  *\(.*\)/\1)busybox modprobe <br/>        \2;;/p' &gt;&gt; $tmp <br/>    echo 'esac; done; }' &gt;&gt; $tmp <br/>    sed -i '/brcmfmac/d' $tmp <br/>    source $tmp <br/>    cat /sys/bus/*/devices/*/uevent | grep MODALIAS | sed <br/>    's/^MODALIAS=//' <br/>    | sort -u | dev2mod <br/>    cat /sys/devices/virtual/wmi/*/modalias | dev2mod <br/>} <br/><br/>load_modules() <br/>{ <br/>    if [ -z "$FOUND" ]; then <br/>        auto_detect <br/>    fi <br/><br/>    # 3G modules <br/>    for m in $EXTMOD; do <br/>        busybox modprobe $m <br/>    done <br/>} 
</pre>
<p>The <kbd>load_modules</kbd> script function is implemented in the script file <kbd>0-auto-detect</kbd>, as shown in the preceding snippet. It calls another function, <kbd>auto-detect</kbd>, to do the actual work. This function is not that easy to understand. Let's explain what it does now. The purpose of this function is to create a shell command called <kbd>dev2mod</kbd> on-the-fly. What this <kbd>dev2mod</kbd> function does is take the module alias as a parameter and load the respective driver module according to the module alias. After the <kbd>dev2mod</kbd> command is created, <kbd>auto_detect</kbd> will call this function using the devices found by the kernel under the <kbd>/sys/bus</kbd> folder.</p>
<p>All the kernel modules of the Android-x86 kernel can be found in the <kbd>/lib/modules/4.x.x-android-x86/modules.alias</kbd> file. This file is processed to add the <kbd>modprobe</kbd> command at the end of each line so that the kernel module can be loaded with the module alias as a parameter. The temporary script file can be found at <kbd>/tmp/dev2mod</kbd> and it looks like the following code snippet:</p>
<pre>
<strong># cat /tmp/dev2mod</strong><br/><strong>dev2mod() { while read dev; do case $dev in </strong><br/><strong>xts)busybox modprobe xts;; </strong><br/><strong>xtea)busybox modprobe tea;; </strong><br/><strong>xeta)busybox modprobe tea;; </strong><br/><strong>xcbc)busybox modprobe xcbc;; </strong><br/><strong>wp512)busybox modprobe wp512;; </strong><br/><strong>wp384)busybox modprobe wp512;; </strong><br/><strong>wp256)busybox modprobe wp512;; </strong><br/><strong>...</strong><br/><strong>acpi*:80860ABC:*)busybox modprobe intel_lpss_acpi;; </strong><br/><strong>acpi*:80860AAC:*)busybox modprobe intel_lpss_acpi;; </strong><br/><strong>acpi*:193C9890:*)busybox modprobe snd_soc_max98090;; </strong><br/><strong>acpi*:10EC5670:*)busybox modprobe snd_soc_rt5670;; </strong><br/><strong>acpi*:10EC5650:*)busybox modprobe snd_soc_rt5645;; </strong><br/><strong>acpi*:10EC5645:*)busybox modprobe snd_soc_rt5645;; </strong><br/><strong>acpi*:10EC5642:*)busybox modprobe snd_soc_rt5640;; </strong><br/><strong>acpi*:10EC5640:*)busybox modprobe snd_soc_rt5640;; </strong><br/><strong>acpi)busybox modprobe acpi_cpufreq;; </strong><br/><strong>esac; done; } </strong>  
</pre>
<p>Before the devices in the <kbd>/sys</kbd> filesystem are passed to the <kbd>dev2mod</kbd> function, we can take a look at how the output looks like on my system as follows:</p>
<pre>
<strong># cat /sys/bus/*/devices/*/uevent | grep MODALIAS | sed 's/^MODALIAS=//' <br/>| sort -u</strong><br/><strong>acpi:ACPI0003: </strong><br/><strong>acpi:APP0001:SMC-NAPA: </strong><br/><strong>acpi:LNXCPU: </strong><br/><strong>acpi:LNXPWRBN: </strong><br/><strong>acpi:LNXSLPBN: </strong><br/><strong>acpi:LNXSYBUS: </strong><br/><strong>acpi:LNXSYSTM: </strong><br/><strong>acpi:LNXVIDEO: </strong><br/><strong>acpi:PNP0000: </strong><br/><strong>acpi:PNP0100: </strong><br/><strong>acpi:PNP0103:PNP0C01: </strong><br/><strong>acpi:PNP0200: </strong><br/><strong>acpi:PNP0303: </strong><br/><strong>acpi:PNP0400: </strong><br/><strong>acpi:PNP0501: </strong><br/><strong>acpi:PNP0700: </strong><br/><strong>acpi:PNP0A03: </strong><br/><strong>acpi:PNP0B00: </strong><br/><strong>acpi:PNP0C02: </strong><br/><strong>acpi:PNP0C0A: </strong><br/><strong>acpi:PNP0C0F: </strong><br/><strong>acpi:PNP0F03: </strong><br/><strong>acpi:PNP8390: </strong><br/><strong>cpu:type:x86,ven0000fam0006mod003A:feature:,0000,0001,0002,0003,0004,0005,0006,0</strong><br/><strong>hdaudio:v83847680r00103401a01 </strong><br/><strong>hid:b0003g0001v000080EEp00000021 </strong><br/><strong>pci:v0000106Bd0000003Fsv00000000sd00000000bc0Csc03i10 </strong><br/><strong>pci:v00001AF4d00001000sv00001AF4sd00000001bc02sc00i00 </strong><br/><strong>pci:v00008086d00001237sv00000000sd00000000bc06sc00i00 </strong><br/><strong>pci:v00008086d0000265Csv00000000sd00000000bc0Csc03i20 </strong><br/><strong>pci:v00008086d00002668sv00008384sd00007680bc04sc03i00 </strong><br/><strong>pci:v00008086d00007000sv00000000sd00000000bc06sc01i00 </strong><br/><strong>pci:v00008086d00007111sv00000000sd00000000bc01sc01i8A </strong><br/><strong>pci:v00008086d00007113sv00000000sd00000000bc06sc80i00 </strong><br/><strong>pci:v000080EEd0000BEEFsv00000000sd00000000bc03sc00i00 </strong><br/><strong>pci:v000080EEd0000CAFEsv00000000sd00000000bc08sc80i00 </strong><br/><strong>platform:alarmtimer </strong><br/><strong>platform:goldfish_pdev_bus</strong><br/><strong>platform:i8042 </strong><br/><strong>platform:microcode </strong><br/><strong>platform:pcspkr </strong><br/><strong>platform:platform-framebuffer </strong><br/><strong>platform:reg-dummy </strong><br/><strong>platform:rtc_cmos </strong><br/><strong>platform:serial8250 </strong><br/><strong>scsi:t-0x00 </strong><br/><strong>scsi:t-0x05 </strong><br/><strong>serio:ty01pr00id00ex00 </strong><br/><strong>serio:ty06pr00id00ex00 </strong><br/><strong>usb:v1D6Bp0001d0404dc09dsc00dp00ic09isc00ip00in00 </strong><br/><strong>usb:v1D6Bp0002d0404dc09dsc00dp00ic09isc00ip00in00 </strong><br/><strong>usb:v80EEp0021d0100dc00dsc00dp00ic03isc00ip00in00 </strong><br/><strong>virtio:d00000001v00001AF4</strong>
</pre>
<p>As we can see from the preceding output, it includes all module aliases found by the kernel. The preceding output of module aliases will be passed to the shell script function <kbd>dev2mod</kbd> through a pipe. The <kbd>dev2mod</kbd> function will load all respective kernel modules found by the kernel.</p>
<p>After the <kbd>load_modules</kbd> are executed, we enter the second checkpoint and we can take a look at the system status now:</p>
<div><img height="322" width="502" class=" image-border" src="img/image_08_003.png"/></div>
<p>Kernel modules are loaded</p>
<p>We can see from the preceding screenshot that there are many kernel modules loaded in the system now. From the kernel module name, we can see that the audio, mouse, and keyboard drivers are loaded. This is how the device drivers are loaded automatically by the Android-x86 init script in <kbd>initrd.img</kbd>. At the end of the init script, it will invoke <kbd>chroot</kbd> or <kbd>switch_root</kbd> according to the setting of the environment variable <kbd>DEBUG</kbd>. In either case, the root filesystem will be changed to the Android <kbd>ramdisk.img</kbd> and will start the Android init process as follows:</p>
<pre>
... <br/>[ -n "$DEBUG" ] &amp;&amp; SWITCH=${SWITCH:-chroot} <br/><br/># We must disable mdev before switching to Android <br/># since it conflicts with Android's init <br/>echo &gt; /proc/sys/kernel/hotplug <br/><br/>exec ${SWITCH:-switch_root} /android /init <br/>... 
</pre>
<p>The Android init process will perform the hardware initialization for these devices that cannot be detected by the kernel automatically. The init process will also initialize the HAL of Android-x86.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">HAL initialization during the Android start-up</h1>
            

            
                
<p>Let's look in greater detail into the hardware initialization of devices that cannot be detected by the kernel automatically, and the initialization of Android-x86 HAL, in this section. One of the peripherals that haven't been initialized is the frame buffer for the graphic user interface in Android. We will use it as an example to explain how hardware is initialized by the init process in Android's <kbd>ramdisk.img</kbd>.</p>
<p>If we recall the analysis of the init process in <a href="b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml">Chapter 6</a>, <em>Debugging the Boot Up Process Using a Customized ramdisk</em>, the init process will execute the <kbd>init.rc</kbd> script, which is general for all Android devices. In the <kbd>init.rc</kbd> script, it will import a device-specific script <kbd>init.${ro.hardware}.rc</kbd>. In our case, this script is <kbd>init.x86vbox.rc</kbd> on the target device. The <kbd>ro.hardware</kbd> property is set according to the kernel command-line parameter, <kbd>androidboot.hardware</kbd>, which we set it to <kbd>x86vbox</kbd>. The source code of <kbd>init.x86vbox.rc</kbd> can be found at <kbd>device/generic/common/init.x86.rc</kbd>. It is copied to the target output using the following line in <kbd>device.mk</kbd>. Be aware that the script name is changed after the copy:</p>
<pre>
... <br/>PRODUCT_COPY_FILES := \ <br/>    $(if $(wildcard $(PRODUCT_DIR)init.rc),$(PRODUCT_DIR)init.rc:root/init.rc) \ <br/>    $(if $(wildcard $(PRODUCT_DIR)init.sh),$(PRODUCT_DIR),$(LOCAL_PATH)/)init.sh:system/etc/init.sh \  <br/>... <br/>    $(if $(wildcard $(PRODUCT_DIR)init.$(TARGET_PRODUCT).rc),$(PRODUCT_DIR)init.$(TARGET_PRODUCT).rc,$(LOCAL_PATH)/init.x86.rc):root/init.$(TARGET_PRODUCT).rc \ <br/>    $(if $(wildcard $(PRODUCT_DIR)ueventd.$(TARGET_PRODUCT).rc),$(PRODUCT_DIR)ueventd.$(TARGET_PRODUCT).rc,$(LOCAL_PATH)/ueventd.x86.rc):root/ueventd.$(TARGET_PRODUCT).rc \ <br/>... 
</pre>
<p>Another thing that we can see from the preceding code snippet is that a shell script, <kbd>init.sh</kbd>, is also copied to the system image at <kbd>/system/etc/init.sh</kbd>. This is the script used to load device drivers and initialize HAL in <kbd>init.x86vbox.rc</kbd>.</p>
<p>In <kbd>init.x86vbox.rc</kbd>, an action trigger is defined as follows:</p>
<pre>
on post-fs <br/>    exec -- /system/bin/logwrapper /system/bin/sh /system/etc/init.sh 
</pre>
<p>In the predefined trigger, <kbd>post-fs</kbd>, the <kbd>init.sh</kbd> script will be executed as part of the initialization process. The following is the code snippet of <kbd>init.sh</kbd>:</p>
<pre>
... <br/>PATH=/sbin:/system/bin:/system/xbin <br/><br/>DMIPATH=/sys/class/dmi/id <br/>BOARD=$(cat $DMIPATH/board_name) <br/>PRODUCT=$(cat $DMIPATH/product_name) <br/><br/># import cmdline variables <br/>for c in `cat /proc/cmdline`; do <br/>    case $c in <br/>        BOOT_IMAGE=*|iso-scan/*|*.*=*) <br/>            ;; <br/>        *=*) <br/>            eval $c <br/>            if [ -z "$1" ]; then <br/>                case $c in <br/>                    HWACCEL=*) <br/>                        set_property debug.egl.hw $HWACCEL <br/>                        ;; <br/>                    DEBUG=*) <br/>                        [ -n "$DEBUG" ] &amp;&amp; set_property debug.logcat 1 <br/>                        ;; <br/>                esac <br/>            fi <br/>            ;; <br/>    esac <br/>done <br/><br/>[ -n "$DEBUG" ] &amp;&amp; set -x || exec &amp;&gt; /dev/null <br/><br/># import the vendor specific script <br/>hw_sh=/vendor/etc/init.sh <br/>[ -e $hw_sh ] &amp;&amp; source $hw_sh <br/><br/>case "$1" in <br/>    netconsole) <br/>        [ -n "$DEBUG" ] &amp;&amp; do_netconsole <br/>        ;; <br/>    bootcomplete) <br/>        do_bootcomplete <br/>        ;; <br/>    hci) <br/>        do_hci <br/>        ;; <br/>    init|"") <br/>        do_init <br/>        ;; <br/>esac <br/><br/>return 0 
</pre>
<p>As we can see from the preceding code snippet, the <kbd>init.sh</kbd> script processes the kernel command line first. After that, it runs into a multi-selection statement. It executes a function according to the first parameter passed to it. This parameter is used to let the <kbd>do_init</kbd> function initialize a particular HAL module. In the case of the first parameter, it's <kbd>init</kbd> or without parameter, it will execute the <kbd>do_init</kbd> function. In this case, all HAL modules will be initialized and this is the case that we want to investigate now. We can see what the <kbd>do_init</kbd> function does as follows:</p>
<pre>
function do_init() <br/>{ <br/>    init_misc <br/>    init_hal_audio <br/>    init_hal_bluetooth <br/>    init_hal_camera <br/>    init_hal_gps <br/>    init_hal_gralloc <br/>    init_hal_hwcomposer <br/>    init_hal_lights <br/>    init_hal_power <br/>    init_hal_sensors <br/>    init_tscal <br/>    init_ril <br/>    post_init <br/>} 
</pre>
<p>The <kbd>do_init</kbd> function will call individual HAL module initialization functions one by one. We won't look at all of them here. We will take a look at how the frame buffer device is initialized in the <kbd>init_hal_gralloc</kbd> function. This is the one that we will investigate more in Chapter 10, <em>Enabling Graphics</em>, since graphic support is one of the most important tasks when it comes to porting:</p>
<pre>
function init_uvesafb() <br/>{ <br/>    case "$PRODUCT" in <br/>        ET2002*) <br/>            UVESA_MODE=${UVESA_MODE:-1600x900} <br/>            ;; <br/>        *) <br/>            ;; <br/>    esac <br/><br/>    [ "$HWACCEL" = "0" ] &amp;&amp; bpp=16 || bpp=32 <br/>    modprobe uvesafb mode_option=${UVESA_MODE:-1024x768}-$bpp <br/>    ${UVESA_OPTION:-mtrr=3 scroll=redraw} <br/>} <br/><br/>function init_hal_gralloc() <br/>{ <br/>    case "$(cat /proc/fb | head -1)" in <br/>        *virtiodrmfb) <br/>        # set_property ro.hardware.hwcomposer drm <br/>            ;&amp; <br/>        0*inteldrmfb|0*radeondrmfb|0*nouveaufb|0*svgadrmfb) <br/>            set_property ro.hardware.gralloc drm <br/>            set_drm_mode <br/>            ;; <br/>        "") <br/>            init_uvesafb <br/>            ;&amp; <br/>        0*) <br/>            ;; <br/>    esac <br/><br/>    [ -n "$DEBUG" ] &amp;&amp; set_property debug.egl.trace error <br/>} 
</pre>
<p>In the <kbd>init_hal_gralloc</kbd> function, it will perform the respective tasks according to the content of <kbd>/proc/fb</kbd>. From <kbd>/proc/fb</kbd>, it can detect the type of graphic hardware on the device. If the type of graphic hardware cannot be detected, it will use a general VESA frame buffer (uvesafb), which is used in our case for VirtualBox. It will call another shell function, <kbd>init_uvesafb</kbd>, to load the VESA frame buffer driver. The uvesafb driver will start a user space daemon <kbd>v86d</kbd> to execute the x86 BIOS code. The code is executed in a controlled environment and the results are passed back to the kernel via the netlink interface. This is how the graphic driver is initialized in our environment.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we analyzed the Android-x86 HAL and integrated it to x86vbox so that we are able to boot x86vbox over the next few chapters. We also analyzed the start-up process of Android-x86. We used the debug console in the first stage of the start-up process to analyze the kernel module loading process. Before we can actually boot the x86vbox on VirtualBox, one issue that we haven't resolved is which bootloader we should use. Unlike the emulator, it does not need a bootloader, since the emulator uses a built-in mini bootloader to load the kernel and ramdisk. VirtualBox is very similar to real hardware. We won't be able to boot up an operating system without a proper bootloader.</p>
<p>In the next chapter, we will discuss this issue and we will explain how we can resolve it using PXE boot supported by VirtualBox.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>