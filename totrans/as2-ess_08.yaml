- en: Chapter 8. Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debugging environment is one of the most important features of an IDE. Using
    a debugging tool allows you to easily optimize your application and improve its
    performance. Do you want to use a debug tool while programming in Android Studio?
    Android Studio includes the **Dalvik Debug Monitor Server** (**DDMS**) debugging
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will start by learning about the **run** and **debug**
    options and how to emulate your application in one of the Android virtual devices
    you learned to create in a previous chapter. You will learn about the **Debugger**,
    **Console**, and **LogCat** tabs in depth. You will also learn how to use breakpoints
    when using the debugger. We will end this chapter with information about each
    tab available in the advanced debugger tool included in Android Studio DDMS and
    the Hierarchy View.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics we''ll be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LogCat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instant run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device Monitor tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchy View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications can be run from Android Studio in a real device using a
    USB connection or in a virtual device using the emulator. Virtual devices make
    it possible to test our applications on different types of hardware and software
    configurations. In this chapter, we will use the emulator to run and debug our
    application because of its simplicity and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: To run an application directly, navigate to **Run** | **Run 'app'**. You can
    also click on the play icon from the toolbar. To debug an application, navigate
    to **Run** | **Debug 'app'** or click on the bug icon from the toolbar. If your
    app is already running, you can start the debug mode by navigating to **Run**
    | **Attach debugger to Android process**.
  prefs: []
  type: TYPE_NORMAL
- en: When we select the **Debug 'app'** option, a dialog to choose the device is
    opened. The **Connected Devices** section is used to choose a running device;
    the current connected devices are listed, real or virtual. The **Available Emulators**
    section is used to launch a new instance of the emulator; the available virtual
    devices are listed. You can also create a new emulator from this dialog using
    the **Create New Emulator** button. This option will open the virtual device configuration
    dialog that was explained in [Chapter 6](ch06.html "Chapter 6. Tools"), *Tools*.
    One last option in this dialog is the **Use same selection for future launches**
    checkbox. Check this if you want to skip this step in future.
  prefs: []
  type: TYPE_NORMAL
- en: Select the virtual device created in [Chapter 6](ch06.html "Chapter 6. Tools"),
    *Tools*, from the **Available Emulators** section as shown in the following screenshot
    and click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and debugging](img/B05459_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The emulator will be launched. The next time we run or debug the application,
    the emulator will be running, so we will select it from the **Connected Devices**
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'While debugging, you will note that, at the bottom of Android Studio as shown
    in the next screenshot, there is a new panel, **Debug**, which contains two tabs:
    **Debugger** and **Console**. The **Android Monitor** tab contains two other tools:
    **LogCat** and **Monitors**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and debugging](img/B05459_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Console** displays the events that are taking place while the emulator is
    being launched or while it is running. Open it to examine the messages and check
    that the emulator and the application are being correctly executed. The actions
    that should appear are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for device**: This is the starting point when the emulator is being
    launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uploading file** (the `adb push` command): This event states that the application
    is packed and stored in the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installing** (the `adb shell pm` install command): This event states that
    the application is being installed in the device. After the installation, a success
    message should be printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launching application** (the `adb shell am start` command): This event takes
    place when the application starts to execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waiting for process**: This event takes place when the application is running
    and the debug system tries to connect to the application process in the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the success of the previous steps, the application will be visible in
    the emulator. Test it by typing any name in the text input and clicking on the
    **Accept** button. The greeting message should change.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Debugger** manages the breakpoints, controls the execution of the code, and
    shows information about the variables. To add a breakpoint in your code, just
    click on the left edge of a line of code. A red point will appear next to the
    line of code to indicate the breakpoint. To delete the breakpoint, click on it.
    If you right-click on a breakpoint, more options become available in a small dialog,
    in which you can click on the **More to open the Breakpoints** window, which is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger](img/B05459_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also open the **Breakpoints** window by navigating to **Run** | **View
    Breakpoints...**. In the left-side panel of the **Breakpoints** window, all the
    breakpoints of your app are listed. You can add new breakpoints, remove them,
    or enable and disable them. You can enable **Exception Breakpoints**, which will
    be triggered when an exception is thrown while your app is running. If you select
    one breakpoint from the left-side panel, you can configure it using the right-side
    panel. For example, you can set a condition for the breakpoint, log a message
    to console, or remove it once it is hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a breakpoint in the conditional statement of the `onAcceptClick` method
    of our main activity and debug the application again, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger](img/B05459_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter your name in the application and click on the **Accept** button. When
    the execution gets to the breakpoint, it pauses, and the **Debugger** tab is opened.
    Since we added the breakpoint in the conditional statement before assigning the
    text, our greeting message has not changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the debugger tab, we can examine the method call hierarchy and the state
    of the variables at that point of execution. The available variables are the parameter
    of the `v` method, the `TextView` and `EditText` objects obtained by the `findViewById`
    method, and the reference to the current activity (`this`). Expand the `EditText`
    object named `etName`, as shown in the following screenshot, and search for the
    `mText` property. This property should contain the name you typed before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger](img/B05459_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the `EditText` object to open a menu with more options and select
    **Evaluate Expression...**. The **Evaluate Expression** dialog allows you to query
    methods in the context of the selected object. For example, type `etName.getText()`
    and press *Enter* to evaluate the expression. The result of the expression will
    be displayed like in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger](img/B05459_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the execution of your app is stopped in a breakpoint, you can do the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: To execute the next line of code without stepping into the method call, you
    can navigate to **Run** | **Step Over**, click on the button in the top toolbar
    of the **Debug** panel, or press the keyboard shortcut indicated for this option,
    usually the *F8* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To step into the method call, you can navigate to **Run** | **Step Into**, click
    on the button in the top toolbar of the **Debug** panel, or press *F7*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To choose the method you want to step into, navigate to **Run** | **Smart Step
    Into** or press *Shift* +*F7*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To step to the cursor position in your code, you can navigate to **Run** | **Run
    to Cursor**, click on the button in the top toolbar of the **Debug** panel, or
    press *Alt* + *F9*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To resume the execution until the next breakpoint, you can navigate to **Run**
    | **Resume Program**, click on the button in the left-side toolbar of the **Debug**
    panel, or press *F9*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop the execution, you can navigate to **Run** | **Stop**, click on the
    button in left-side toolbar of the **Debug** panel, or press *Ctrl* + *F2* (*Cmd*
    + *F2* on OS X).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options, among others, are also available from the debugger tab as icon
    shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `tvGreeting` object to check the value of its `mText` property. Now,
    step over the conditional statement and the call of the `setText` method. Note
    how the value of the `mText` property has changed, which is shown in the next
    screenshot. Finally, resume the execution so the greeting message changes in the
    device screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger](img/B05459_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new breakpoint inside the `if` clause. We can add a condition to the
    endpoint so the execution is only paused when the name typed by the user is `"no
    name"`, otherwise, the execution will continue as usual. The following screenshot
    of the **Breakpoints** window shows the breakpoint details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugger](img/B05459_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Condition** field of the breakpoint, add the following condition that
    compares the text typed by the user in the name field (`etName`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you write your name in the app, no breakpoint will suspend the execution.
    If you type `"no name"`, execution will be suspended at the recently created breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: LogCat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LogCat** is the Android logging system that displays all the log messages
    generated by the Android system in the running device. Log messages have several
    levels of significance. From the **LogCat** tab, we can filter the log messages
    by these levels. For example, if we select the information level as the filter,
    the messages from **information**, **warning**, and **error** levels will be displayed.
    The levels are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LogCat](img/B05459_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To print log messages from our code, we need to import the `Log` class. This
    class has a method for each level: the `v` method for verbose, the `d` method
    for debug, the `i` method for information, the `w` method for warning, and the
    `e` method for the error level. These methods receive two string parameters. The
    first string parameter usually identifies the source class of the message and
    the second string parameter identifies the message itself. To identify the source
    class, we recommend using a constant, static string tag. However, in the next
    example, we directly use the string to simplify the code. Add the following log
    messages to the `onAcceptClick` method of our main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have a log message to inform us about the name obtained from the user input
    and a log message to print a warning if the user did not type a name. Remove any
    breakpoint we previously created and then debug the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **LogCat** tab in the **Android Monitor** has by default printed the log
    messages generated by the current application. Reading the messages of your application
    can sometimes be complex and you need to filter the messages. In the **LogCat**
    tab, there is an expandable list where you can filter the log messages by their
    level of significance. You can also use the search field to look for certain log
    messages. There is another expandable list to configure some extra filters: the
    **No Filters** option displays all the logs generated by the device; the **Show
    only selected application** option displays the logs generated only by your app;
    and the **Edit Filter Configuration** option allows you to create a more complex
    filter. Select **Edit Filter Configuration** to examine this option. A dialog
    to create filters is opened as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LogCat](img/B05459_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Log messages can be filtered using regular expressions by their **Log Tag**,
    their **Log Message**, or by the name of the package that printed them. Logs can
    also be filtered by the **process ID** (**PID**) or by their level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new filter named `MyApplication`, filter it by **Package Name** writing
    `com.example.myapplication` (our application package name), and click on **OK**.
    Now, the **LogCat** log has been filtered and it is easier to read our messages.
    Now, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Focus on the **Emulator** window, enter a name in the application, and click
    on **Accept**. Observe how our log message is printed in the **LogCat** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete your name from the application and click on **Accept**. This time, a
    warning message is printed. Notice the different colors used for each type of
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Monitors** panel is available at the bottom-right corner of Android Studio.
    Select the device or emulator running your application, and select the process
    corresponding to your application from the two top expandable lists. There are
    four monitors available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory**: This shows the free and allocated memory of the selected application
    over time, as shown in the following screenshot:![Monitors](img/B05459_08_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: This shows the CPU usage in real time of your app, as shown in the
    following screenshot:![Monitors](img/B05459_08_12.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network**: This shows the network usage of your app, as shown in the following
    screenshot:![Monitors](img/B05459_08_13.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPU**: This shows the GPU usage of your app, indicating the time to execute,
    process, prepare, and draw the frames, as shown in the following screenshot:![Monitors](img/B05459_08_14.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instant run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instant run is a new feature introduced in Android Studio 2.0 that allows you
    to update your app while it is running on a device without building a new APK.
    This feature reduces deployment time.
  prefs: []
  type: TYPE_NORMAL
- en: Instant run requires SDK 15 or higher, though it's recommended to use SDK 21
    or higher. You will also need to have your Android Plugin for Gradle updated to
    version 2.0 or higher. Instant run works for both the emulator and a real device.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first deployment of your app, you will note that the run/debug icon
    has changed and has an additional thunderbolt icon, such as the debug icon in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instant run](img/B05459_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next time you click on the **Debug** button, Android Studio will analyze
    the changes in your code to make the deployment of your app faster, instead of
    creating a new APK and doing a full deployment. There are three types of updates
    depending on the code that needs to be pushed to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hot swap**: This is the fastest swap. This type of swap is done if you change
    the code of an existing method. Android Studio will create a stub method with
    the new code and restart the current activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you do not want Android Studio to restart the current activity after a hot
    swap, you can disable this behavior in the settings screen. Instant run settings
    are in the **Build, Execution, Deployment** section of the main settings. The
    following screenshot shows the instant run settings screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Instant run](img/B05459_08_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can disable the restart of the activity by disabling the **Restart activity
    on code changes** option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Warm swap**: This type of swap is done if you change or remove an existing
    resource. Android Studio will always restart the current activity and you can''t
    disable this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cold swap**: This is the slowest swap and it requires API 21 or higher. If
    the device runs an API lower than 21, Android Studio will create a new APK and
    perform a full deployment. This type of swap is done if changes in the code are
    structural, such as changing the parent class, the implemented interfaces, a field,
    or a method signature. Android Studio will restart your app in a cold swap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio will deploy a new build if you change the app manifest or anything
    that affects the app manifest, such as a resource referenced in the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change some code in your app, for example, change the `Hello` text message
    to a `Goodbye` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Debug** button with the thunderbolt. Since you changed the code
    in a method, Android Studio will do a hot swap. You will notice a flicker while
    the current activity restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the hot swap is finished, a message is displayed in the bottom part of
    Android Studio, as you can see in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instant run](img/B05459_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can read in the message, the code changes were applied and the current
    activity was restarted. Type a name and click on `ACCEPT`. The text message is
    the `Goodbye` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instant run](img/B05459_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Disable the **Restart activity on code changes** option from the settings to
    observe the differences. Change the code back to the `Hello` text message and
    debug the app. There is no flicker now and, when the hot swap is finished, the
    message displayed in Android Studio is now different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instant run](img/B05459_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the hot swap is finished, a message is also displayed in the emulator,
    like in the following screenshot. In this case, the message shown is: *Applied
    code changes without activity restart*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instant run](img/B05459_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now change a resource, for example, change the hint of the `EditText` to the
    following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Debug** button with the thunderbolt. Since you changed a resource,
    Android Studio will do a warm swap this time. You will notice that the current
    activity restarts again. The same message displays in the bottom part of Android
    Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instant run](img/B05459_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to disable instant run completely, you can do it from the settings
    screen by unmarking the **Enable Instant Run to hot swap code/resource changes
    on deploy (default enabled)** option.
  prefs: []
  type: TYPE_NORMAL
- en: Android Device Monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DDMS is a more advanced debugging tool available in the SDK. The DDMS can
    be accessed from Android Studio through the **Android Device Monitor** tool. This
    tool is able to monitor both a real device and the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: To open the DDMS perspective, navigate to **Tools** | **Android** | **Android
    Device Monitor**. You can also click on the Android Device Monitor icon from the
    toolbar. A new window will be opened with the DDMS perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In the left part of the window, the list of connected devices is shown. Currently,
    just our virtual device is listed. In the **Devices** section, the list of the
    processes running on each device is also presented. We should be able to locate
    our application in the processes of the device we launched before. From the toolbar
    of the **Devices** section, we can stop a process using the Stop sign icon. We
    can also take a screen capture of the virtual device by clicking on the Camera
    icon. Some of the other options will be explained later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the right part of the window, detailed information about the device is provided.
    This information is divided into seven tabs: **Threads**, **Heap**, **Allocation
    Tracker**, **Network Statistics**, **File Explorer**, **Emulator Control**, and
    **System Information**. **LogCat**, which has also been integrated in the DDMS
    perspective, is placed at the bottom part of the window.'
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Threads** tab displays the list of threads that belong to the selected
    process. Select our application process from the **Devices** section. The process
    is identified by the package name, in this case `com.example.myapplication`, click
    on the **Update Threads** icon button from the toolbar of the **Devices** section
    and the threads will be loaded in the content of the tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Threads](img/B05459_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first columns are the IDs of the threads. The **Status** column indicates
    the thread state, **utime** indicates the total time spent by the thread executing
    the user code, **stime** indicates the total time spent by the thread executing
    system code, and **Name** indicates the name of the thread. The threads that interest
    us are those that spend time executing our user code.
  prefs: []
  type: TYPE_NORMAL
- en: This **Threads** tool is useful if we create threads in our application apart
    from the main thread. We can check if they are being executed at a certain point
    of the application and whether their execution time is moderate or not.
  prefs: []
  type: TYPE_NORMAL
- en: Method profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Method profiling is a tool to measure the performance of methods execution
    in the selected process. The measured parameters are the number of calls and the
    CPU time spent while executing. There are the following two types of spent time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exclusive time**: This is the time spent in the execution of a method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inclusive time**: This is the total time spent on the execution of a method.
    This measure includes the time spent by any called methods inside the method.
    These called functions are known as its **children methods**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To collect the method profiling data, select our application process from the
    **Devices** section and click on the **Start Method Profiling** icon from the
    toolbar of the **Devices** section, next to the **Update Threads** icon. A dialog
    to select the profiling option that you prefer is displayed. **Sample based profiling**
    profiles with less runtime performance impact using a sampling frequency, which
    can be configured. Sample-based profiling is available in Android 4.4 and later.
    **Trace based profiling** profiles the entry and exit of all the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Perform some actions in the application; for example, in our example application,
    type a name and click on the **Accept** button in order to execute the `onAcceptClick`
    method of the main activity. Stop the method profiling by clicking on the **Stop
    Method Profiling** icon button.
  prefs: []
  type: TYPE_NORMAL
- en: When the method profiling is stopped, a new tab with the resultant trace is
    opened in the DDMS perspective. On the top of this new tab, the method calls are
    represented in a time graph; each row belongs to a thread. On the bottom of the
    trace, the summary of the time spent in a method is represented in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Order the methods by their name to search for our `onAcceptClick` method (`com.example.myapplication.MainActivity.onAcceptClick`).
    Click on it to expand the detailed information about its execution. Now, note
    the following facts:'
  prefs: []
  type: TYPE_NORMAL
- en: The children methods called inside the `onAcceptClick` method are listed. We
    can see the `EditText.getText` method, the `Activity.findViewById` method, and
    the `TextView.setText` method, which we indeed directly call inside the method,
    as shown in the next screenshot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of calls is detailed in the **Calls/Total** column. For example,
    we can see that the `Activity.findViewById` method is called twice (**2/2** value)—one
    call to find the `TextView` object and a second call to find the `EditText` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Exclusive time** columns have no values for the parent or children methods
    due to their own definition of this type of measured time:![Method profiling](img/B05459_08_23.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method profiling is very useful to detect methods that spend too much time on
    their execution and to subsequently optimize them. We can identify the most expensive
    methods to avoid unnecessary calls to them.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Heap** tab displays the heap memory usage information and the statistics
    of the selected process. Select the application process and click on the **Update
    Heap** icon button from the toolbar of the **Devices** section to enable it. The
    heap information is shown after a **garbage collector** (**GC**) execution. To
    force it, click on the **Cause GC** button or the garbage icon from the toolbar
    of the **Devices** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first table displays the summary of the heap usage: the total size, the
    allocated space, the free space, and the number of allocated objects. The **Stats**
    table gives the following detail of the objects allocated in the heap by type:
    the number of objects (**Count** column), the total size of those objects (**Total
    Size** column), the size of the smallest (**Smallest** column) and largest objects
    (**Largest** column), the median size (**Median** column), and the average size
    (**Average** column). Select one of the types to load the bottom bar graph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph shows the count of the objects of a type by size, in bytes. If we
    right-click on the graph, we can change its properties (title, colors, font, labels,
    and so on) and save it as an image in the PNG format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Heap](img/B05459_08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Allocation Tracker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Allocation Tracker** tab displays the memory allocations of the selected
    process. Select the application process and click on the **Start Tracking** button
    to start tracking the memory information. Then, click on the **Get Allocations**
    button to get the list of allocated objects.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the filter on the top of the tab to filter the objects allocated
    in our own classes. Type our package name `com.example.myapplication` in the filter.
    For each object, the table shows its allocation size (**Allocation Size**), the
    thread (**Thread**), the object or class (**Allocated Class**), and the method
    in which the object was allocated (**Allocated in**). Click on any object to see
    more information, for example, the line number that allocated it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the next screenshot, a `java.lang.StringBuilder` object was
    allocated in the `onAcceptClick` of the main activity. In the bottom part, you
    can check the details of its allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Allocation Tracker](img/B05459_08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, click on the **Stop Tracking** button.
  prefs: []
  type: TYPE_NORMAL
- en: The allocation tracker is very useful to examine the objects that are being
    allocated when doing certain interactions in our application, in order to improve
    memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Network Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Network Statistics** tab displays how our application uses the network's
    resources. To get the network statistics of any application that uses the network,
    click on the **Start** button. The data transfers will begin to appear in the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: The network statistics are useful to optimize the network requests in our code
    and control the data transferred at a certain point of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: File Explorer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **File Explorer** tab exposes the whole filesystem of the device. We can
    examine the size, date, or permissions of each element. Navigate to `/data/app/`
    to search for our `com.example.myapplication.apk` application package file.
  prefs: []
  type: TYPE_NORMAL
- en: Emulator Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Emulator Control** tab allows us to emulate some special states or activities
    in the virtual device. We can test our application in different environments and
    situations to check whether it behaves as expected. If our application has features
    that depend on the device''s physical location, we can use mock locations. Some
    of these special states are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Telephony Status**: This allows you to choose the voice and data status and
    its speed and latency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telephony Actions**: This is used to simulate an incoming call or SMS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location Controls**: This is used to set the geolocation of the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **System Information** tab presents the frame render time, total CPU load,
    and total memory usage of the device as graphs. We can search for our application
    and easily compare it with the rest of the processes running on the device.
  prefs: []
  type: TYPE_NORMAL
- en: We can change the properties of the graphs such as colors, font, and title and
    we can save them as images in PNG format. To open these options, right-click on
    the graph elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the CPU load and save the graph while our application is running in the
    foreground. Then, close the application and update the CPU load by clicking on
    the **Update from Device** button. Note the difference between both graphs and
    the growth of the idle percentage, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![System Information](img/B05459_08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hierarchy View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android Device Monitor contains a second perspective apart from the DDMS—the
    **Hierarchy View**. On the top bar of the Android Device, you can change from
    one perspective to the other. The two options in the top bar are shown in the
    next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchy View](img/B05459_08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the **Hierarchy View** perspective and select your app from the left-side
    list. In the left-side panel, click on the following icon (the **Load the view
    hierarchy into the tree view** action):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchy View](img/B05459_08_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The view hierarchy is loaded as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchy View](img/B05459_08_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three different panels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tree Overview**: This panel shows the overview of the complete view hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree View**: This panel shows in detail a specific area of the view hierarchy.
    At the bottom of the hierarchy, we can find the `TextView` with the ID `textView_greeting`,
    the `EditText` with the ID `editText_name`, and the `Button` with the ID `button_accept`.
    The parent of all of them is the `RelativeLayout`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout View**: This panel shows the layout view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you select one of the view elements, you can see its details. The following
    screenshot shows the details of the `button_accept` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchy View](img/B05459_08_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open the **View Properties** tab from the left-side panel. You can check the
    properties of the button, such as the `mText` property, the value of which is
    `Accept`.
  prefs: []
  type: TYPE_NORMAL
- en: On the top of the **Tree View** panel, there are some actions like saving the
    tree view as a PNG image or capturing the window layers as a Photoshop file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know the different launch options for your application as well as how
    to use the console and the **LogCat** for debugging. We also saw how to debug
    an application and interpret the data provided by the DDMS in each of the tabs
    available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will prepare our application for its release using Android
    Studio. First, you will learn about the necessary steps to prepare the application
    before building it in the release mode. You will also learn how applications are
    compressed in `APK` files and how to generate your own `APK` file. Finally, you
    will learn how to get your certificate as a developer and how to generate a signed
    `APK` file, making it ready for release.
  prefs: []
  type: TYPE_NORMAL
