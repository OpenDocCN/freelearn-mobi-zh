- en: Chapter 2. Groovy Essentials for Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn some fundamental concepts of the Groovy programming
    language. This chapter briefly covers Groovy data types, control structures, object
    oriented concepts, collections, closures, and builders. This is just the tip of
    the iceberg. As this is not a Groovy book, we won't be able to cover all the topics.
    This chapter is meant for beginners who are coming from a Java background and
    have a basic understanding of **Object-oriented programming** (**OOP**) concepts.
    This will help them get started with Groovy. This chapter will also act as a tool
    box to proceed with Gradle scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Groovy is a dynamic programming language for the Java Platform. You might be
    wondering why we specifically mention the Java platform. By the Java platform,
    it means Groovy code compiles into the bytecode, and bytecodes are executed on
    JVM similar to any other Java class. Along with the OOP features, it also provides
    the capability of scripting languages such as Python and Smalltalk, making them
    available to use in Groovy using a Java-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: As Groovy runs on JVM, it can be easily integrated with Java and nicely fits
    into the existing infrastructure. For example, the build and deployment of Groovy
    code is the same as the build and deployment of Java code, and you can easily
    mix Groovy and Java together by just adding another JAR file to the library. Groovy
    is not the only language that runs on JVM. Some of the other languages are Scala,
    Clojure, JRuby, Jython, and so on. In my opinion, if you have some Java background,
    Groovy is much easier to learn when compared with other languages. It has a very
    Java-like syntax to it, and most of the Java syntaxes are valid Groovy syntaxes.
    It just simplifies coding. Groovy is never intended to replace Java. It is intended
    to supplement Java to extend it to make it easier, and also it uses modern language
    features such as closures, builders, and metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: The following are some of the key features of Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people think Groovy is a scripting language. Yes, it provides scripting
    support, but it's not right to say Groovy is only a scripting language. Along
    with scripting, it perfectly fits into the OOP world. As mentioned earlier, Groovy
    also provides seamless integration with Java. Calling Java from Groovy is as simple
    as writing Groovy code. Every Groovy type is a subtype of `java.lang.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One good thing about Groovy is that it reduces the amount of code required to
    do some complex tasks, such as parsing XML files and accessing databases. With
    Groovy, you can always mix in Java code. If you've been using Java for a while,
    I think you'll appreciate the simplicity of using Groovy since you can program
    more functionality by writing less code.
  prefs: []
  type: TYPE_NORMAL
- en: Simpler I/O operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I/O operations, one of the main pain points for the developer while working
    with Java, is made much simpler in Groovy. It's more fun to perform I/O operations
    in Groovy. Groovy provides simple properties to read/write from the file. It has
    added so many utility methods to the `java.io.File` class.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Ant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Java, Groovy provides seamless integration with Ant. Groovy has a helper
    class, `AntBuilder`, which gives Groovy the power of using Ant features to make
    the developer's life much simpler. Be it calculating the checksum of any file
    or copying the content of a directory from one location to another with any filter
    criteria. With Ant capabilities, Groovy makes developers more productive. In [Chapter
    8](ch08.html "Chapter 8. Migration"), *Migration*, we will discuss more on this
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Builder classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from AntBuilder, Groovy provides the capability of `NodeBuilder`, `MarkupBuilder`,
    and `SwingBuilder`. With the help of these Builders, the developer is able to
    achieve things in a much simpler way, as compared to life without the Builders.
    `MarkupBuilder` is useful while dealing with XML operations. `SwingBuilder` provides
    simplified API to the Swing framework that helps in building user-friendly GUI
    applications. `NodeBuilder` helps while working with object tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: Closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The inclusion of closures was a big selling point for Groovy. A closure in Groovy
    is an anonymous chunk of code that may take arguments, return a value, and reference
    and use variables declared in its surrounding scope. Closure has usually been
    associated with functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: A Groovy closure is like a code block that is defined and then executed at a
    later point. It has some special properties such as implicit variables and free
    variables. We will discuss Closure in detail in later section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are many more features to learn. We will discuss a few in this
    chapter. For more details refer to the Groovy documentation at [http://www.groovy-lang.org/](http://www.groovy-lang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Groovy script for Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed what Groovy is and some of its important features. Let us
    create a Hello World program and feel the magic with Groovy. Here we are assuming
    that Groovy is installed on the system, `GROOVY_HOME` is pointing to the installation
    directory and `<GROOVY_HOME>/bin` has been added to the PATH environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And that's all. Yes, for a simple Groovy program, you don't need to declare
    any packaging, any main class, or any semicolons, only a simple `println` statement
    would create your first Groovy program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the program, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `groovy` command is used to execute the Groovy script. The beauty of the
    Groovy script is that it can execute any file, not only files with the `.groovy`
    extension. Even you can write the preceding `println` statement in the `Test.text`
    file and use the groovy command to execute the file. File extension doesn't matter
    in groovy, but to make the file structures more readable, it is recommended to
    use `.groovy` extensions for Groovy files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way of executing Groovy files. You can compile Groovy files,
    generate class files like Java, and then execute the class files. Perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile and generate the class file, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the class file generated, you need to execute the following command
    on Windows. If executing on Linux/Unix environment use `$GROOVY_HOME`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Executing a Groovy compiled file is same as executing the Java file. Developer
    needs to add `groovy-all-<version>.jar` in its classpath. You also need to make
    sure that the directory in which your compiled classes are present, it should
    be in the classpath. In the preceding example, we have added "`.`" as the current
    directory to the classpath to find the `GroovyTest.class` file.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter which way you execute the Groovy scripts. In both the cases,
    Groovy scripts execute inside JVM only. Both the methods compile the Groovy scripts
    into bytecode. The `groovy <filename>` stores the classes into memory in a direct
    way, whereas compiling the script using the `groovyc` command creates a class
    file and stores it on disk, which you can later execute using Java command.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you learn about any programming language are the data types;
    how any programming language stores the data. Similar to the other programming
    languages, Groovy also offers a different set of data types for numerical, strings,
    char, and so on. As compared to Java, there are no primitive types present in
    Groovy. Groovy treats everything as an object, which makes Groovy a pure Object
    Oriented language. The problem with primitive data types is that developers can''t
    perform any object-level operations, such as calling methods on them. Also, you
    can''t store them as an object in maps and sets (collections that require objects).
    The following table shows primitive data types and wrapper types with default
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Wrapper type | Default values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| byte | Byte | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| short | Short | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| int | Integer | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| long | Long | 0L |'
  prefs: []
  type: TYPE_TB
- en: '| float | Float | 0.0f |'
  prefs: []
  type: TYPE_TB
- en: '| double | Double | 0.0d |'
  prefs: []
  type: TYPE_TB
- en: '| char | Character | \u0000 |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | Boolean | false |'
  prefs: []
  type: TYPE_TB
- en: '| String | Not Applicable | null |'
  prefs: []
  type: TYPE_TB
- en: Groovy gives you the flexibility to even declare variables using int, byte,
    short, and so on, which it internally converts into its respective classes, for
    example, int to Integer, char to Character, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be thinking, why are we discussing only String here? This is because
    Groovy provides different variants to represent String compared to Java, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `s1` contains String in single quotes. This String is fixed in size as
    we have written it.
  prefs: []
  type: TYPE_NORMAL
- en: The `s2` variable contains String in double quotes similar to Java String.
  prefs: []
  type: TYPE_NORMAL
- en: Variable `s3` contains String enclosed in three double quotes, which allows
    you to declare a multiline String.
  prefs: []
  type: TYPE_NORMAL
- en: In `s4`, String contains an embedded variable, which will be resolved to its
    value. This is formally known as GString. You can declare place holder using either
    `${variable}` or `$variable`.
  prefs: []
  type: TYPE_NORMAL
- en: Another format Groovy supports is String declared inside `/` (slash). It also
    supports multiline Strings.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing in Groovy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Groovy provides support for both static typing and dynamic typing features.
    Static typing provides more checks at compile time, more memory optimization,
    and better support for the IDE used for Groovy. It also provides additional information
    about the type of variable or method parameters. However, the power of Groovy
    lies in dynamic typing. In many scenarios, you are not sure about the kind of
    value that would be stored in the variable or returned by the functions. In that
    scenario, Groovy provides flexibility to use dynamic typing. You can just define
    a variable or methods by using the `def` keyword, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Another use of dynamic typing is calling methods on objects that have no guaranteed
    type. This is often called **duck typing**. For example, consider the following
    scenario where a simple addition method is called on different data types such
    as Integer, List, and String. Based on different input parameters, each time the
    method returns different output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when the addition method was invoked with an Integer as an argument,
    it performed an arithmetic addition. With list-type arguments, the addition method
    creates a new list by doing a union of two lists. Similarly, on string-type arguments,
    it does a simple concatenation. In this example, the `+` operator was interpreted
    as different method calls based on the input type arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A major difference between Java and Groovy is that Groovy supports operator
    overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so good. But what happens if the addition method is called on a user-defined
    object, say `Person`? This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is expected because in the `Person` class we did not define the plus method.
    If we define the plus method in the `Person` class, the call to the addition (which
    invokes `p1 + p2` or `p1.plus(p2))` method will be successful.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is to implement `methodMissing` method. This is a very powerful
    concept in Groovy. In the Gradle source code, you will find reference for this
    method many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of defining a plus method, we can define a `methodMissing` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we call the addition method on the `Person` object, we will find `plus
    method intercepted` as the new output, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Classes, beans, and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section introduces classes, methods, and beans. Groovy classes are similar
    to Java classes declared with the `class` keyword. Usually, a class definition
    starts with the package name, and then import package statements. One key difference
    with the Java counterpart is that Groovy imports six packages and two classes
    by default. So, if you create any class, these packages and classes are automatically
    available to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes and methods in Groovy by default have public access, whereas in Java
    it is set to `package-private`. We will start with a sample Groovy class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we have created two classes, `Order` and `Customer`, with some fields;
    in the main method, we have created objects, and finally, called the `showMail()`
    method on the `Customer` object. Notice how objects are initialized with values.
    The `Order` object is created by the default constructor, then the object was
    initialized with the `setter` methods defined on fields.
  prefs: []
  type: TYPE_NORMAL
- en: However, for the `Customer` object, it is done with a constructor with named
    parameters. The `Customer` object is initialized with a property-value pair in
    the constructor. However, we haven't defined any parameterized constructors in
    the class definition. So how does it work?
  prefs: []
  type: TYPE_NORMAL
- en: We have created fields in the class with no access modifier. If fields are created
    with default access, then Groovy automatically creates a field with public `getter`
    and `setter` methods. If we specify any access modifier (`public`, `private`,
    or `protected`), then only fields will be created; no `getter` or `setter` method
    will be created. In our preceding example, `orderNo`, `orderByCustomer`, and `description`
    are declared with no access modifier. So, we were able to call the `setDescription`
    method on the `Order` object. Other fields are accessed by field names. In this
    scenario, Groovy calls the respective `getter` or `setter` methods internally
    on the fields. This feature is called **Property** in Groovy. So, each class in
    Groovy has properties and autocreated `getter` and `setter` methods for those
    properties. This is similar to the Java bean approach, where private fields are
    created with public `getter` and `setter` methods, but with less number of lines
    of code as, `getter` and `setter` methods are implicitly provided by Groovy. This
    is why, often, Groovy objects are referred to as **Plain Old Groovy Object** (**POGO**).
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the constructor declaration, when the `Customer` object was created
    with named parameters, actually, a default constructor was created, and then,
    for each of the properties in the constructor, respective `setter` methods were
    called to initialize the properties.
  prefs: []
  type: TYPE_NORMAL
- en: Methods in Groovy are similar to Java, but the class method's visibility is
    set to `public` by default. To invoke a method on a class, we need to create an
    object of that class. In case of Groovy scripts where you do not provide any class
    definition, method invocation is done by calling the method by name. If a method
    supports a dynamic return type, then the method declaration should start with
    the `def` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Groovy also supports method invocation with default parameter values. In the
    following example, the `sum` method is defined with three parameters `x`, `y`,
    and `z`, with values of `y` and `z` as `10` and `1`, respectively. The `sum(1)`
    and `sum(1,2)` methods should give results `12` and `4`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Groovy does not require an explicit return statement in methods. By default,
    the last evaluated expression is returned as the method output. In the preceding
    example, we have not mentioned `return x+y+z`. It would be returned by default.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the basic control structures, namely the `if…else`
    statement, the `switch` statement, the `for` loop, and the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The if-else condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if…else` condition in Groovy is similar to Java with one exception, how
    Groovy evaluates the logical `if` condition. In the following example, the `if`
    condition is evaluated true for both Boolean and int values. In Groovy, non-zero
    integers, non-null values, nonempty strings, initialized collections, and a valid
    matcher are evaluated as Boolean true values. This is known as **Groovy Truths**.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Groovy also supports ternary operators `(x? y: z)`, such as Java, which can
    be used to write the standard `if-else` logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Groovy also provides one additional operator known as the Elvis operator. It
    can be used as a shorter version of the ternary operator in the scenario, where
    the user wants to validate a variable against the null value. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If inputName is not null username would be inputName else default value "guest"
    would be assigned to username
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Groovy supports Class, Object, Range, Collection, Pattern, and Closure as classifiers
    in the `switch` statement. Anything that implements the `isCase` method can be
    used as a classifier in the `switch` statement. The following example shows a
    case defined for various classifiers. Just try different values of input and observe
    the output of the `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Groovy supports both `for (initialize; condition; increment)` and `for-each`
    type looping. The `for-each` style is expressed as `for(variable in Iterable)
    { body}`. As loop works on an iterable object collection, it can be easily applied
    to array, range, collections, and so on. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop is similar to the Java `while` loop, though Groovy doesn''t
    support the `do-while` style of looping. Let''s demonstrate the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We assume you have basic knowledge on **Java Collection Framework** (**JCF**),
    so we are not going to discuss the fundamentals of the collection framework. We
    start on what Groovy provides on collection framework and frequently used utility
    methods provided by different collection objects.
  prefs: []
  type: TYPE_NORMAL
- en: Groovy supports different collective data types to store group of objects, such
    as range, lists, sets, and maps. If you are already a Java programmer, you will
    find how easy it is in Groovy to play with collective data types as compared to
    Java. Apart from sets, lists, and maps, Groovy has introduced ranges, which was
    not available in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set is an unordered collection of objects, with no duplicates. It can be considered
    as an unordered list with restrictions on uniqueness, and is often constructed
    from a list. Set can also contain at most one null element. As implied by its
    name, this interface models the mathematical set abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet explains how to create a `Set`. Elements can be added
    or removed from the `Set` using the `add`, `addAll`, `remove`, or `removeAll`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: You might have learned a lot about `Set` in your math classes, where the instructor
    teaches you different set operations, such as union and intersection. Groovy also
    provides similar functionalities. The union of two sets contains all the unique
    elements and common elements present in both the sets without repetition. The
    intersection finds common elements between the two sets. The complement of `Set1`
    and `Set2` will contain all those elements of `Set1` that are not present in `Set2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As compared to `Set`, a `List` is an ordered collection of objects, and a `List`
    can contain duplicate elements. A `List` can be created using `List list = []`,
    which creates an empty list that is an implementation of `java.util.ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to create a `List`, read values from the
    list, and list some utility methods on the `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the `List` methods accept Closure. The following example shows how
    to find the first even number using the `find` method, and list of all the even
    numbers using the `findAll` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Do not get confused by the "it" keyword inside the curly brackets. We will discuss
    this in the *Closure* section.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Map is a key-value pair collection, where the key is unique. In Groovy, key-value
    pairs are delimited by colons. An empty Map can be created via [`:`]. By default,
    a Map is of the type `java.util.HashMap`. If the keys are of type String, you
    can avoid the single or double quotes in the Map declaration. For example, if
    you want to create a Map with `name` as the key and `Groovy` as the value, you
    can use the following notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `[name: "Groovy"]` is the same as `["name":"Groovy"]`. By default, Map
    keys are Strings. But if you want to put some variable as the key, then use parentheses,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can create a Map in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can get the objects from the Map using `key m2.get("id")` or `m2["id"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If key is a String, then to get a value, you need to specify the key in double
    quotes (`""`). If you do not specify the key in double quotes, it will treat it
    as a variable name and will try to resolve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will discuss some of the utility methods (each, any, and every) of Maps,
    which accept Closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse every entry of `Map`, you can use `each`. It takes either entry or
    key-value as a parameter, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to validate the `Map` data, you can use either `.every` or `.any`,
    based on your requirements. The `.every` method checks and makes sure all records
    fulfil the mentioned condition, while `.any` just checks whether any one record
    fulfils the condition. For example, if you want to check whether there is any
    user who is more than 25 years old:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It returns the output as a Boolean value; in this case, true, as Meera is 28.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check whether all the users are above 18:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It will return false, as Harry is 18.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `find` and `findAll` methods for `Map` in the same pattern
    as we used for `List` in the *List* section.
  prefs: []
  type: TYPE_NORMAL
- en: Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from Java collection types, Groovy also supports a new collective data
    type `Range`. It is defined as two values (generally starting point and ending
    point) separated by two dots.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `Range`, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To read values from `Range`, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `.any` and `.every` operators to validate range for your
    specific requirement. It checks for the condition and returns a Boolean value.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For modifying the range interval, use the following code. If you want to modify
    range interval from default 1 to any other number, you can set it via step method.
    It returns a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch the starting element and ending element of a range, use the `From`
    and `To` element, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isReverse()` method is used to check the range trend to see whether the
    range is constructed using `to value` ( higher value) to `from value` (lower value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Closure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closure has usually been associated with functional languages. Groovy provides
    a very easy way of creating closure objects. A Groovy Closure is like a code block
    written in curly braces. Many people associate Closure to be an anonymous function
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Closure in Groovy may accept arguments and returns a value. By default, the
    last statement in a Groovy Closure is the `return` statement. It means that if
    you are not explicitly returning any value from Closure, it will by default, returns
    the output of the last statement of Closure. Commonly, we define a Closure like
    this `{argument list-> closure body}`. Here, an argument list is a comma separated
    value that Closure accepts. Arguments are optional. If no argument is specified,
    then one implicit untyped argument named `it` will be available in the Closure
    body. The argument `it` will be null if no argument is supplied during Closure
    invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, for the first call of Closure `addTwo` the variable
    `it` is assigned is `2`, but in the second call, `it` is assigned null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can even declare a variable of type Closure. In Groovy,
    Closures are a subclass of the `groovy.lang.Closure` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To separate the Closure body from the argument list, we use the `->` operator.
    The closure body consists of zero or more Groovy statements. Like methods, it
    can also reference and declare variables in its scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, the `addOne` method was able to reference the
    `constantValue` variable in its scope, though it was defined outside of the Closure
    scope. Such variables are referred to as `free` variables. A variable which is
    defined within the curly braces of a Closure would be treated as a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the argument of the Closure was of Integer type. With
    Closures, the statements within the curly braces are not executed until you explicitly
    invoke them, using either `call()` or by an `unnamed ()` invocation syntax of
    Closure. In our example, the closure is declared in the second line, but it's
    not evaluated at that time. It will be executed if the `call()` method is explicitly
    made on the Closure. This is an important differentiator between Closures and
    code blocks. They may look the same, but they are not. Closures are only executed
    if the `call()` method is invoked on the Closure; not during its definition time.
    Remember, Closures are first class objects in Groovy, and can be referred using
    untyped variables or by using Closure variables. In both the cases, it is derived
    from `groovy.lang.Closure`. This class has overloaded `call()` methods with no
    or multiple arguments to invoke Closures.
  prefs: []
  type: TYPE_NORMAL
- en: When `addOne` Closure was called with an Integer as an argument, it executed
    successfully. However, for String type as an argument, it throws an exception.
    Also observe that the compiler didn't complain when we passed a String as an argument
    to the `addOne` Closure. This is because all arguments are checked at runtime;
    there is no static type checking done by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The `doCall()` method on this Closure is generated dynamically, which accepts
    only Integer as an argument. So any invocation other than Integer type will throw
    an exception. The `doCall()` method is the implicit method, which cannot be overridden
    and cannot be redefined. This method is always invoked implicitly when we invoke
    call method or `unnamed ()` syntax on a Closure.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude Closure by discussing the concept of delegate. This feature
    is widely used in Gradle. For example, when we define a repository Closure or
    dependency Closure in the build script, those Closures are executed in the `RepositoryHandler`
    or `DependencyHandler` classes. These classes are passed to the closures as delegates.
    You can refer to the Gradle API for more details. Let us not complicate things
    here. We will try to understand the concept with simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where we are trying to print a `myValue` variable,
    which is undefined in the class. Obviously, this call will throw an exception
    as this variable is not defined in the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There could be a situation where we want to execute this closure against another
    class. This class can be passed to the closure as a delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `PrintHandler` class has defined the `myValue` variable.
    We have delegated and executed the closure against the `PrintHandler` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, it is working as expected. Now, what if `myValue` is redefined in the
    `PrintValue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, on executing the Closure, we will find the output as `I''m
    owner`. This is because, when closure was trying to resolve the `myValue` variable,
    it found the variable defined within the scope of the owner (the `PrintValue`
    class, where the Closure is defined), so it didn''t delegate the call to the `PrintHandler`
    class. Formally, this is known as `OWNER_FIRST` strategy, which is the default
    strategy. The strategy resolves this way—the closure will be checked first, followed
    by the closure''s scope, then the owner of the closure, and, finally, the delegate.
    Groovy is so flexible that it provides us with the capability to change the strategy.
    For example, to delegate the call to the `PrintHandler` class, we should specify
    the strategy as `DELEGATE_FIRST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `DELEGATE_FIRST` strategy, the closure will try to resolve the property
    or methods to the delegate first and then the owner. The other important strategies
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OWNER_ONLY`: It attempts to resolve the property or methods within the owner
    only and doesn''t delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELEGATE_ONLY`: Closure will resolve the property references or methods to
    the delegate. It completely ignores the owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TO_SELF`: It will resolve the property references or methods to itself and
    go through the usual `MetaClass` look-up process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This was indeed a very short description. I suggest you to refer to the Groovy
    documentation for more details at: [http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html](http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important feature in Groovy is Builder. Groovy Builders allow you to
    create complex tree-like hierarchical object structures. For example, SwingUI
    or XML documents can be created very easily using the DSL or Closure-like features
    in Groovy, with the support of the `BuilderSupport` class and its subclasses,
    `MarkupBuilder` and `SwingBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand with an example. We created the `Order` class earlier
    in this chapter. Assume we have a list of orders and we want to store the details
    in a file called `orders.xml`. So every `Order` object in our list should be saved
    as a node in the XML file. Each of these `Order` nodes, again should contain child
    nodes, grand children nodes, and so on. Creating this tree-like structure can
    be complex if we try to implement a DOM-like parser in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: But in Groovy, this is just few lines of code with some method calls combined
    with Closure and named parameters. In the following example, we have created a
    `builder` object from the `MarkupBuilder` class to create the XML document. Then
    we have defined `orders` as the root of the document. However, `builder` has no
    method defined as `orders`. So then, how does this work?
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the `MarkupBuilder` class is a subclass of the `BuilderSupport`
    class. `BuilderSupport` has methods such as `createNode`, `invokeMethod`, `nodeCompleted`,
    `setCurrent`, `setParent`, and a few more. In runtime, an object is created by
    calling the `createNode` method on the builder with the name `orders`. In a similar
    fashion, for each `order` object, `no`, `description`, and `customer` nodes are
    created. Finally, each `order` node is attached to the parent `orders` node by
    calling the `setParent` method of the builder object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed some basic fundamental concepts. We learned about
    concepts of classes, methods, beans, collection frameworks, and closures. We also
    developed a markup builder to produce XML files. This was indeed a very short
    introduction to Groovy. However, in my opinion this introduction should be good
    enough to write Gradle scripts for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: From the next chapter onwards, we will start exploring the core features of
    Gradle. In the next chapter, we will learn task management in Groovy. We will
    take a close look at the different in-built tasks supported by Gradle. We will
    also learn about task dependencies and task configurations. Then we will create
    some custom tasks for build scripts.
  prefs: []
  type: TYPE_NORMAL
