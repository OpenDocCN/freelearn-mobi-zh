- en: Chapter 2. Groovy Essentials for Gradle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：Gradle的Groovy基础知识
- en: In this chapter, we will learn some fundamental concepts of the Groovy programming
    language. This chapter briefly covers Groovy data types, control structures, object
    oriented concepts, collections, closures, and builders. This is just the tip of
    the iceberg. As this is not a Groovy book, we won't be able to cover all the topics.
    This chapter is meant for beginners who are coming from a Java background and
    have a basic understanding of **Object-oriented programming** (**OOP**) concepts.
    This will help them get started with Groovy. This chapter will also act as a tool
    box to proceed with Gradle scripting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Groovy编程语言的一些基本概念。本章简要介绍了Groovy数据类型、控制结构、面向对象概念、集合、闭包和构建器。这只是冰山一角。由于这不是一本Groovy书籍，我们无法涵盖所有主题。本章旨在为那些来自Java背景并基本了解**面向对象编程**（**OOP**）概念的初学者提供帮助。这将帮助他们开始使用Groovy。本章还将作为继续Gradle脚本编写的一个工具箱。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Groovy is a dynamic programming language for the Java Platform. You might be
    wondering why we specifically mention the Java platform. By the Java platform,
    it means Groovy code compiles into the bytecode, and bytecodes are executed on
    JVM similar to any other Java class. Along with the OOP features, it also provides
    the capability of scripting languages such as Python and Smalltalk, making them
    available to use in Groovy using a Java-like syntax.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy是Java平台上的动态编程语言。你可能想知道为什么我们特别提到Java平台。通过Java平台，我们的意思是Groovy代码编译成字节码，字节码在JVM上执行，类似于任何其他Java类。除了面向对象（OOP）特性外，它还提供了脚本语言（如Python和Smalltalk）的能力，使得它们可以通过类似Java的语法在Groovy中使用。
- en: As Groovy runs on JVM, it can be easily integrated with Java and nicely fits
    into the existing infrastructure. For example, the build and deployment of Groovy
    code is the same as the build and deployment of Java code, and you can easily
    mix Groovy and Java together by just adding another JAR file to the library. Groovy
    is not the only language that runs on JVM. Some of the other languages are Scala,
    Clojure, JRuby, Jython, and so on. In my opinion, if you have some Java background,
    Groovy is much easier to learn when compared with other languages. It has a very
    Java-like syntax to it, and most of the Java syntaxes are valid Groovy syntaxes.
    It just simplifies coding. Groovy is never intended to replace Java. It is intended
    to supplement Java to extend it to make it easier, and also it uses modern language
    features such as closures, builders, and metaprogramming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Groovy运行在JVM上，它可以很容易地与Java集成，并且很好地融入现有的基础设施中。例如，Groovy代码的构建和部署与Java代码的构建和部署相同，你只需向库中添加另一个JAR文件就可以轻松地将Groovy和Java混合在一起。Groovy不是唯一运行在JVM上的语言。其他一些语言包括Scala、Clojure、JRuby、Jython等等。在我看来，如果你有一些Java背景，与其它语言相比，Groovy的学习要容易得多。它具有非常类似Java的语法，并且大多数Java语法都是有效的Groovy语法。它只是简化了编码。Groovy从未打算取代Java。它的目的是补充Java，扩展它使其更容易使用，并且它还使用了现代语言特性，如闭包、构建器和元编程。
- en: The following are some of the key features of Groovy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Groovy的关键特性。
- en: Integration with Java
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Java的集成
- en: Many people think Groovy is a scripting language. Yes, it provides scripting
    support, but it's not right to say Groovy is only a scripting language. Along
    with scripting, it perfectly fits into the OOP world. As mentioned earlier, Groovy
    also provides seamless integration with Java. Calling Java from Groovy is as simple
    as writing Groovy code. Every Groovy type is a subtype of `java.lang.Object`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为Groovy是一种脚本语言。是的，它提供了脚本支持，但说Groovy只是一种脚本语言是不正确的。除了脚本之外，它完美地融入了面向对象的世界。如前所述，Groovy还提供了与Java的无缝集成。从Groovy调用Java就像编写Groovy代码一样简单。每个Groovy类型都是`java.lang.Object`的子类型。
- en: Minimum code
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化代码
- en: One good thing about Groovy is that it reduces the amount of code required to
    do some complex tasks, such as parsing XML files and accessing databases. With
    Groovy, you can always mix in Java code. If you've been using Java for a while,
    I think you'll appreciate the simplicity of using Groovy since you can program
    more functionality by writing less code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的一个优点是它减少了执行一些复杂任务（如解析XML文件和访问数据库）所需的代码量。使用Groovy，你总是可以混合Java代码。如果你已经使用Java一段时间了，我认为你会欣赏使用Groovy的简单性，因为你可以通过编写更少的代码来实现更多的功能。
- en: Simpler I/O operations
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化的I/O操作
- en: I/O operations, one of the main pain points for the developer while working
    with Java, is made much simpler in Groovy. It's more fun to perform I/O operations
    in Groovy. Groovy provides simple properties to read/write from the file. It has
    added so many utility methods to the `java.io.File` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Java进行开发时，I/O操作是开发者面临的主要痛点之一，在Groovy中变得简单得多。在Groovy中执行I/O操作更有趣。Groovy提供了简单的属性来读取/写入文件。它已经向`java.io.File`类添加了如此多的实用方法。
- en: Integration with Ant
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Ant的集成
- en: Like Java, Groovy provides seamless integration with Ant. Groovy has a helper
    class, `AntBuilder`, which gives Groovy the power of using Ant features to make
    the developer's life much simpler. Be it calculating the checksum of any file
    or copying the content of a directory from one location to another with any filter
    criteria. With Ant capabilities, Groovy makes developers more productive. In [Chapter
    8](ch08.html "Chapter 8. Migration"), *Migration*, we will discuss more on this
    topic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java一样，Groovy提供了与Ant的无缝集成。Groovy有一个辅助类`AntBuilder`，它赋予了Groovy使用Ant功能的能力，使开发者的生活变得更加简单。无论是计算任何文件的校验和，还是根据任何过滤条件将目录内容从一个位置复制到另一个位置。借助Ant功能，Groovy使开发者更加高效。在[第8章](ch08.html
    "第8章。迁移")“迁移”中，我们将更详细地讨论这个话题。
- en: Builder classes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建器类
- en: Apart from AntBuilder, Groovy provides the capability of `NodeBuilder`, `MarkupBuilder`,
    and `SwingBuilder`. With the help of these Builders, the developer is able to
    achieve things in a much simpler way, as compared to life without the Builders.
    `MarkupBuilder` is useful while dealing with XML operations. `SwingBuilder` provides
    simplified API to the Swing framework that helps in building user-friendly GUI
    applications. `NodeBuilder` helps while working with object tree structure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了AntBuilder之外，Groovy还提供了`NodeBuilder`、`MarkupBuilder`和`SwingBuilder`的能力。借助这些构建器，开发者能够以更简单的方式完成任务，与没有构建器的生活相比。`MarkupBuilder`在处理XML操作时很有用。`SwingBuilder`提供了简化了Swing框架的API，有助于构建用户友好的GUI应用程序。`NodeBuilder`在处理对象树结构时很有帮助。
- en: Closure
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: The inclusion of closures was a big selling point for Groovy. A closure in Groovy
    is an anonymous chunk of code that may take arguments, return a value, and reference
    and use variables declared in its surrounding scope. Closure has usually been
    associated with functional languages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的引入是Groovy的一个大卖点。Groovy中的闭包是一个匿名代码块，它可以接受参数，返回值，并引用和使用其周围作用域中声明的变量。闭包通常与函数式语言相关联。
- en: A Groovy closure is like a code block that is defined and then executed at a
    later point. It has some special properties such as implicit variables and free
    variables. We will discuss Closure in detail in later section of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy闭包就像是一个定义后并在稍后执行的代码块。它具有一些特殊属性，例如隐式变量和自由变量。我们将在本章后面的部分详细讨论闭包。
- en: Of course, there are many more features to learn. We will discuss a few in this
    chapter. For more details refer to the Groovy documentation at [http://www.groovy-lang.org/](http://www.groovy-lang.org/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有很多其他特性需要学习。我们将在本章中讨论其中的一些。更多详细信息，请参阅[http://www.groovy-lang.org/](http://www.groovy-lang.org/)的Groovy文档。
- en: Groovy script for Hello World
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Groovy脚本中的Hello World
- en: 'We have discussed what Groovy is and some of its important features. Let us
    create a Hello World program and feel the magic with Groovy. Here we are assuming
    that Groovy is installed on the system, `GROOVY_HOME` is pointing to the installation
    directory and `<GROOVY_HOME>/bin` has been added to the PATH environment variable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Groovy是什么以及它的一些重要特性。让我们创建一个Hello World程序，并用Groovy感受它的魔力。这里我们假设Groovy已安装在系统上，`GROOVY_HOME`指向安装目录，并且`<GROOVY_HOME>/bin`已添加到PATH环境变量中：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And that's all. Yes, for a simple Groovy program, you don't need to declare
    any packaging, any main class, or any semicolons, only a simple `println` statement
    would create your first Groovy program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。是的，对于一个简单的Groovy程序，你不需要声明任何包，任何主类，或者任何分号，只需一个简单的`println`语句就能创建你的第一个Groovy程序。
- en: 'To execute the program, use the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行程序，请使用以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `groovy` command is used to execute the Groovy script. The beauty of the
    Groovy script is that it can execute any file, not only files with the `.groovy`
    extension. Even you can write the preceding `println` statement in the `Test.text`
    file and use the groovy command to execute the file. File extension doesn't matter
    in groovy, but to make the file structures more readable, it is recommended to
    use `.groovy` extensions for Groovy files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`groovy`命令来执行Groovy脚本。Groovy脚本的美妙之处在于它可以执行任何文件，而不仅仅是扩展名为`.groovy`的文件。甚至你可以在`Test.text`文件中编写前面的`println`语句，并使用groovy命令来执行该文件。在Groovy中，文件扩展名并不重要，但为了使文件结构更易于阅读，建议为Groovy文件使用`.groovy`扩展名。
- en: 'There is another way of executing Groovy files. You can compile Groovy files,
    generate class files like Java, and then execute the class files. Perform the
    following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Groovy文件还有另一种方法。你可以编译Groovy文件，生成类似于Java的类文件，然后执行这些类文件。请执行以下步骤：
- en: 'To compile and generate the class file, use the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译并生成类文件，请使用以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run the class file generated, you need to execute the following command
    on Windows. If executing on Linux/Unix environment use `$GROOVY_HOME`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Windows上运行生成的类文件，你需要执行以下命令。如果在Linux/Unix环境中执行，请使用`$GROOVY_HOME`：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Executing a Groovy compiled file is same as executing the Java file. Developer
    needs to add `groovy-all-<version>.jar` in its classpath. You also need to make
    sure that the directory in which your compiled classes are present, it should
    be in the classpath. In the preceding example, we have added "`.`" as the current
    directory to the classpath to find the `GroovyTest.class` file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行编译后的Groovy文件与执行Java文件相同。开发者需要在类路径中添加`groovy-all-<version>.jar`。你还需要确保你的编译类所在的目录在类路径中。在先前的示例中，我们将当前目录"`.`"添加到类路径中，以查找`GroovyTest.class`文件。
- en: It doesn't matter which way you execute the Groovy scripts. In both the cases,
    Groovy scripts execute inside JVM only. Both the methods compile the Groovy scripts
    into bytecode. The `groovy <filename>` stores the classes into memory in a direct
    way, whereas compiling the script using the `groovyc` command creates a class
    file and stores it on disk, which you can later execute using Java command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Groovy脚本的方式并不重要。在这两种情况下，Groovy脚本都在JVM内部执行。这两种方法都将Groovy脚本编译成字节码。`groovy <filename>`命令直接将类存储在内存中，而使用`groovyc`命令编译脚本会创建一个类文件并将其存储在磁盘上，你可以稍后使用Java命令执行它。
- en: Data types
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'The first thing you learn about any programming language are the data types;
    how any programming language stores the data. Similar to the other programming
    languages, Groovy also offers a different set of data types for numerical, strings,
    char, and so on. As compared to Java, there are no primitive types present in
    Groovy. Groovy treats everything as an object, which makes Groovy a pure Object
    Oriented language. The problem with primitive data types is that developers can''t
    perform any object-level operations, such as calling methods on them. Also, you
    can''t store them as an object in maps and sets (collections that require objects).
    The following table shows primitive data types and wrapper types with default
    values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的第一件事就是了解数据类型；任何编程语言如何存储数据。与其它编程语言类似，Groovy也提供了一套不同的数据类型，用于数值、字符串、字符等。与Java相比，Groovy中没有原始数据类型。Groovy将一切视为对象，这使得Groovy成为一门纯粹的面向对象语言。原始数据类型的问题在于，开发者无法对它们执行任何对象级别的操作，例如调用它们的方法。此外，你也不能将它们作为对象存储在映射和集合（需要对象的集合）中。以下表格显示了原始数据类型和包装类型及其默认值：
- en: '| Data type | Wrapper type | Default values |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 包装类型 | 默认值 |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| byte | Byte | 0 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| byte | Byte | 0 |'
- en: '| short | Short | 0 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 短名 | 简称 | 0 |'
- en: '| int | Integer | 0 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| int | Integer | 0 |'
- en: '| long | Long | 0L |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| long | Long | 0L |'
- en: '| float | Float | 0.0f |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| float | Float | 0.0f |'
- en: '| double | Double | 0.0d |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| double | Double | 0.0d |'
- en: '| char | Character | \u0000 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| char | Character | \u0000 |'
- en: '| boolean | Boolean | false |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| boolean | Boolean | false |'
- en: '| String | Not Applicable | null |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| String | 不适用 | null |'
- en: Groovy gives you the flexibility to even declare variables using int, byte,
    short, and so on, which it internally converts into its respective classes, for
    example, int to Integer, char to Character, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy允许你甚至使用int、byte、short等声明变量，它内部将它们转换为相应的类，例如，int转换为Integer，char转换为Character，等等。
- en: String
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'You may be thinking, why are we discussing only String here? This is because
    Groovy provides different variants to represent String compared to Java, as shown
    in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么我们只在这里讨论字符串？这是因为与Java相比，Groovy提供了不同的变体来表示字符串，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `s1` contains String in single quotes. This String is fixed in size as
    we have written it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1`包含单引号中的字符串。这个字符串的大小是固定的，因为我们这样写它。
- en: The `s2` variable contains String in double quotes similar to Java String.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`s2`变量包含与Java字符串类似的被双引号包围的字符串。'
- en: Variable `s3` contains String enclosed in three double quotes, which allows
    you to declare a multiline String.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`s3`包含被三个双引号包围的字符串，这允许你声明一个多行字符串。
- en: In `s4`, String contains an embedded variable, which will be resolved to its
    value. This is formally known as GString. You can declare place holder using either
    `${variable}` or `$variable`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`s4`中，字符串包含一个嵌入的变量，它将被解析为其值。这正式称为GString。你可以使用`${variable}`或`$variable`来声明占位符。
- en: Another format Groovy supports is String declared inside `/` (slash). It also
    supports multiline Strings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy还支持另一种格式，即字符串在`/`（斜杠）内声明。它也支持多行字符串。
- en: Dynamic typing in Groovy
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Groovy中的动态类型
- en: 'Groovy provides support for both static typing and dynamic typing features.
    Static typing provides more checks at compile time, more memory optimization,
    and better support for the IDE used for Groovy. It also provides additional information
    about the type of variable or method parameters. However, the power of Groovy
    lies in dynamic typing. In many scenarios, you are not sure about the kind of
    value that would be stored in the variable or returned by the functions. In that
    scenario, Groovy provides flexibility to use dynamic typing. You can just define
    a variable or methods by using the `def` keyword, as shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy提供了对静态类型和动态类型特性的支持。静态类型在编译时提供更多的检查，更多的内存优化，以及更好的对Groovy使用的IDE的支持。它还提供了关于变量或方法参数类型的额外信息。然而，Groovy的力量在于动态类型。在许多场景中，你不确定变量将存储什么类型的值或函数将返回什么类型的值。在这种情况下，Groovy提供了使用动态类型的使用灵活性。你可以使用`def`关键字定义变量或方法，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another use of dynamic typing is calling methods on objects that have no guaranteed
    type. This is often called **duck typing**. For example, consider the following
    scenario where a simple addition method is called on different data types such
    as Integer, List, and String. Based on different input parameters, each time the
    method returns different output.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型的另一个用途是在没有保证类型的对象上调用方法。这通常被称为**鸭子类型**。例如，考虑以下场景，在整数、列表和字符串等不同数据类型上调用简单的加法方法。根据不同的输入参数，每次方法返回不同的输出。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, when the addition method was invoked with an Integer as an argument,
    it performed an arithmetic addition. With list-type arguments, the addition method
    creates a new list by doing a union of two lists. Similarly, on string-type arguments,
    it does a simple concatenation. In this example, the `+` operator was interpreted
    as different method calls based on the input type arguments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当加法方法以整数作为参数被调用时，它执行了算术加法。对于列表类型的参数，加法方法通过合并两个列表创建一个新的列表。同样，对于字符串类型的参数，它执行简单的连接。在这个例子中，`+`运算符根据输入类型参数被解释为不同的方法调用。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A major difference between Java and Groovy is that Groovy supports operator
    overloading.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java和Groovy之间一个主要的不同点在于Groovy支持操作符重载。
- en: 'So far so good. But what happens if the addition method is called on a user-defined
    object, say `Person`? This is shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。但如果在用户定义的对象，比如`Person`上调用加法方法会怎样呢？这将在下面的代码中展示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is expected because in the `Person` class we did not define the plus method.
    If we define the plus method in the `Person` class, the call to the addition (which
    invokes `p1 + p2` or `p1.plus(p2))` method will be successful.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为在`Person`类中我们没有定义加法方法。如果我们定义`Person`类中的加法方法，对加法（调用`p1 + p2`或`p1.plus(p2)`）方法的调用将会成功。
- en: Another solution is to implement `methodMissing` method. This is a very powerful
    concept in Groovy. In the Gradle source code, you will find reference for this
    method many times.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是实现`methodMissing`方法。这是Groovy中的一个非常强大的概念。在Gradle源代码中，你会多次找到对这个方法的引用。
- en: 'So, instead of defining a plus method, we can define a `methodMissing` method
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要定义一个加法方法，我们可以定义一个`methodMissing`方法，如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we call the addition method on the `Person` object, we will find `plus
    method intercepted` as the new output, as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`Person`对象的加法方法，我们会发现输出为`plus method intercepted`，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Classes, beans, and methods
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、bean和方法
- en: 'This section introduces classes, methods, and beans. Groovy classes are similar
    to Java classes declared with the `class` keyword. Usually, a class definition
    starts with the package name, and then import package statements. One key difference
    with the Java counterpart is that Groovy imports six packages and two classes
    by default. So, if you create any class, these packages and classes are automatically
    available to you:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了类、方法和bean。Groovy类与使用`class`关键字声明的Java类类似。通常，类定义从包名开始，然后是导入包语句。与Java对应物的一个关键区别是，Groovy默认导入六个包和两个类。所以，如果你创建任何类，这些包和类将自动可用：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Classes and methods in Groovy by default have public access, whereas in Java
    it is set to `package-private`. We will start with a sample Groovy class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy中的类和方法默认具有公共访问权限，而在Java中它被设置为`package-private`。我们将从一个示例Groovy类开始：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we have created two classes, `Order` and `Customer`, with some fields;
    in the main method, we have created objects, and finally, called the `showMail()`
    method on the `Customer` object. Notice how objects are initialized with values.
    The `Order` object is created by the default constructor, then the object was
    initialized with the `setter` methods defined on fields.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个类，`Order`和`Customer`，并包含了一些字段；在`main`方法中，我们创建了对象，最后在`Customer`对象上调用`showMail()`方法。注意对象是如何用值初始化的。`Order`对象是通过默认构造函数创建的，然后对象通过在字段上定义的`setter`方法进行初始化。
- en: However, for the `Customer` object, it is done with a constructor with named
    parameters. The `Customer` object is initialized with a property-value pair in
    the constructor. However, we haven't defined any parameterized constructors in
    the class definition. So how does it work?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`Customer`对象，它是通过具有命名参数的构造函数完成的。`Customer`对象通过构造函数中的属性值对进行初始化。然而，我们还没有在类定义中定义任何参数化构造函数。那么它是如何工作的呢？
- en: We have created fields in the class with no access modifier. If fields are created
    with default access, then Groovy automatically creates a field with public `getter`
    and `setter` methods. If we specify any access modifier (`public`, `private`,
    or `protected`), then only fields will be created; no `getter` or `setter` method
    will be created. In our preceding example, `orderNo`, `orderByCustomer`, and `description`
    are declared with no access modifier. So, we were able to call the `setDescription`
    method on the `Order` object. Other fields are accessed by field names. In this
    scenario, Groovy calls the respective `getter` or `setter` methods internally
    on the fields. This feature is called **Property** in Groovy. So, each class in
    Groovy has properties and autocreated `getter` and `setter` methods for those
    properties. This is similar to the Java bean approach, where private fields are
    created with public `getter` and `setter` methods, but with less number of lines
    of code as, `getter` and `setter` methods are implicitly provided by Groovy. This
    is why, often, Groovy objects are referred to as **Plain Old Groovy Object** (**POGO**).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类中创建了没有访问修饰符的字段。如果字段使用默认访问权限创建，那么Groovy会自动创建一个具有公共`getter`和`setter`方法的字段。如果我们指定了任何访问修饰符（`public`、`private`或`protected`），则只会创建字段；不会创建`getter`或`setter`方法。在我们前面的例子中，`orderNo`、`orderByCustomer`和`description`字段没有使用访问修饰符声明。因此，我们能够调用`Order`对象的`setDescription`方法。其他字段通过字段名进行访问。在这种情况下，Groovy会在字段上内部调用相应的`getter`或`setter`方法。这个特性在Groovy中被称为**属性**。因此，Groovy中的每个类都有属性，并为这些属性自动创建`getter`和`setter`方法。这与Java
    bean方法类似，其中私有字段通过公共`getter`和`setter`方法创建，但代码行数更少，因为`getter`和`setter`方法是由Groovy隐式提供的。这就是为什么Groovy对象通常被称为**纯旧Groovy对象**（**POGO**）。
- en: Coming back to the constructor declaration, when the `Customer` object was created
    with named parameters, actually, a default constructor was created, and then,
    for each of the properties in the constructor, respective `setter` methods were
    called to initialize the properties.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回到构造函数声明，当使用命名参数创建`Customer`对象时，实际上创建了一个默认构造函数，然后，对于构造函数中的每个属性，分别调用相应的`setter`方法来初始化属性。
- en: Methods in Groovy are similar to Java, but the class method's visibility is
    set to `public` by default. To invoke a method on a class, we need to create an
    object of that class. In case of Groovy scripts where you do not provide any class
    definition, method invocation is done by calling the method by name. If a method
    supports a dynamic return type, then the method declaration should start with
    the `def` keyword.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 中的方法与 Java 类似，但类方法的可见性默认设置为 `public`。要调用类上的方法，我们需要创建该类的对象。在 Groovy 脚本中，如果您没有提供任何类定义，方法调用将通过按名称调用方法来完成。如果方法支持动态返回类型，则方法声明应从
    `def` 关键字开始。
- en: Groovy also supports method invocation with default parameter values. In the
    following example, the `sum` method is defined with three parameters `x`, `y`,
    and `z`, with values of `y` and `z` as `10` and `1`, respectively. The `sum(1)`
    and `sum(1,2)` methods should give results `12` and `4`, respectively.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 还支持具有默认参数值的方法调用。在以下示例中，`sum` 方法被定义为具有三个参数 `x`、`y` 和 `z`，其中 `y` 和 `z`
    的值分别为 `10` 和 `1`。`sum(1)` 和 `sum(1,2)` 方法应分别返回 `12` 和 `4`。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Groovy does not require an explicit return statement in methods. By default,
    the last evaluated expression is returned as the method output. In the preceding
    example, we have not mentioned `return x+y+z`. It would be returned by default.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 在方法中不需要显式返回语句。默认情况下，最后一个评估的表达式会被作为方法输出返回。在上面的例子中，我们没有提到 `return x+y+z`。它将默认返回。
- en: Control structures
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: In this section, we will discuss the basic control structures, namely the `if…else`
    statement, the `switch` statement, the `for` loop, and the `while` loop.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论基本控制结构，即 `if…else` 语句、`switch` 语句、`for` 循环和 `while` 循环。
- en: The if-else condition
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if-else 条件
- en: 'The `if…else` condition in Groovy is similar to Java with one exception, how
    Groovy evaluates the logical `if` condition. In the following example, the `if`
    condition is evaluated true for both Boolean and int values. In Groovy, non-zero
    integers, non-null values, nonempty strings, initialized collections, and a valid
    matcher are evaluated as Boolean true values. This is known as **Groovy Truths**.
    Let''s take a look at the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 中的 `if…else` 条件与 Java 类似，只有一个例外，那就是 Groovy 如何评估逻辑 `if` 条件。在以下示例中，`if`
    条件对布尔值和整数值都评估为真。在 Groovy 中，非零整数、非空值、非空字符串、初始化的集合和有效的匹配器都被评估为布尔值 true。这被称为 **Groovy
    真值**。让我们看一下以下代码：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Groovy also supports ternary operators `(x? y: z)`, such as Java, which can
    be used to write the standard `if-else` logic:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'Groovy 也支持三元运算符 `(x? y: z)`，类似于 Java，可以用来编写标准的 `if-else` 逻辑：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Groovy also provides one additional operator known as the Elvis operator. It
    can be used as a shorter version of the ternary operator in the scenario, where
    the user wants to validate a variable against the null value. Consider the following
    example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 还提供了一个称为 Elvis 运算符的额外运算符。它可以用作在用户想要验证变量是否为 null 值的场景中三元运算符的简短版本。考虑以下示例：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If inputName is not null username would be inputName else default value "guest"
    would be assigned to username
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 inputName 不为空，则 username 将会是 inputName，否则将默认值 "guest" 分配给 username
- en: The switch statement
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 语句
- en: 'Groovy supports Class, Object, Range, Collection, Pattern, and Closure as classifiers
    in the `switch` statement. Anything that implements the `isCase` method can be
    used as a classifier in the `switch` statement. The following example shows a
    case defined for various classifiers. Just try different values of input and observe
    the output of the `switch` statement:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 支持 Class、Object、Range、Collection、Pattern 和 Closure 作为 `switch` 语句中的分类器。任何实现了
    `isCase` 方法的对象都可以用作 `switch` 语句中的分类器。以下示例展示了为各种分类器定义的案例。只需尝试不同的输入值并观察 `switch`
    语句的输出：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Loops
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Groovy supports both `for (initialize; condition; increment)` and `for-each`
    type looping. The `for-each` style is expressed as `for(variable in Iterable)
    { body}`. As loop works on an iterable object collection, it can be easily applied
    to array, range, collections, and so on. Let''s take a look at the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 支持两种循环类型：`for (initialize; condition; increment)` 和 `for-each`。`for-each`
    风格表示为 `for(variable in Iterable) { body}`。由于循环在可迭代的对象集合上工作，它可以很容易地应用于数组、范围、集合等。让我们看一下以下代码：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `while` loop is similar to the Java `while` loop, though Groovy doesn''t
    support the `do-while` style of looping. Let''s demonstrate the `while` loop:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环与 Java 的 `while` 循环类似，尽管 Groovy 不支持 `do-while` 风格的循环。让我们演示一下 `while`
    循环：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Collections
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: We assume you have basic knowledge on **Java Collection Framework** (**JCF**),
    so we are not going to discuss the fundamentals of the collection framework. We
    start on what Groovy provides on collection framework and frequently used utility
    methods provided by different collection objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经对 **Java 集合框架**（**JCF**）有基本的了解，所以我们不会讨论集合框架的基本原理。我们从 Groovy 提供的集合框架和不同集合对象提供的常用实用方法开始。
- en: Groovy supports different collective data types to store group of objects, such
    as range, lists, sets, and maps. If you are already a Java programmer, you will
    find how easy it is in Groovy to play with collective data types as compared to
    Java. Apart from sets, lists, and maps, Groovy has introduced ranges, which was
    not available in Java.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 支持不同的集体数据类型来存储对象组，例如范围、列表、集合和映射。如果你已经是 Java 程序员，你会发现与 Java 相比，在 Groovy
    中操作集体数据类型是多么容易。除了集合、列表和映射之外，Groovy 还引入了范围，这在 Java 中是不存在的。
- en: Set
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Set
- en: A set is an unordered collection of objects, with no duplicates. It can be considered
    as an unordered list with restrictions on uniqueness, and is often constructed
    from a list. Set can also contain at most one null element. As implied by its
    name, this interface models the mathematical set abstraction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个无序的对象集合，没有重复元素。它可以被视为一个具有唯一性限制的无序列表，通常由列表构建而成。集合最多可以包含一个 `null` 元素。正如其名称所暗示的，这个接口模型化了数学集合抽象。
- en: The following code snippet explains how to create a `Set`. Elements can be added
    or removed from the `Set` using the `add`, `addAll`, `remove`, or `removeAll`
    methods.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段解释了如何创建 `Set`。可以使用 `add`、`addAll`、`remove` 或 `removeAll` 方法向 `Set` 中添加或删除元素。
- en: You might have learned a lot about `Set` in your math classes, where the instructor
    teaches you different set operations, such as union and intersection. Groovy also
    provides similar functionalities. The union of two sets contains all the unique
    elements and common elements present in both the sets without repetition. The
    intersection finds common elements between the two sets. The complement of `Set1`
    and `Set2` will contain all those elements of `Set1` that are not present in `Set2`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在数学课上已经学到了很多关于 `Set` 的知识，老师会教你不同的集合操作，例如并集和交集。Groovy 也提供了类似的功能。两个集合的并集包含两个集合中所有独特的元素和共同元素，且不重复。交集找出两个集合之间的共同元素。`Set1`
    和 `Set2` 的补集将包含所有在 `Set2` 中不存在的 `Set1` 的元素。
- en: 'Let''s take a look at the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: List
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: List
- en: As compared to `Set`, a `List` is an ordered collection of objects, and a `List`
    can contain duplicate elements. A `List` can be created using `List list = []`,
    which creates an empty list that is an implementation of `java.util.ArrayList`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Set` 相比，`List` 是一个有序的对象集合，`List` 可以包含重复元素。可以使用 `List list = []` 创建一个 `List`，这会创建一个空的列表，它是
    `java.util.ArrayList` 的一个实现。
- en: 'The following code snippet shows how to create a `List`, read values from the
    list, and list some utility methods on the `List`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何创建 `List`、从列表中读取值以及列出 `List` 的一些实用方法：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Some of the `List` methods accept Closure. The following example shows how
    to find the first even number using the `find` method, and list of all the even
    numbers using the `findAll` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `List` 方法接受闭包。以下示例展示了如何使用 `find` 方法找到第一个偶数，以及使用 `findAll` 方法列出所有偶数：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Do not get confused by the "it" keyword inside the curly brackets. We will discuss
    this in the *Closure* section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被花括号内的 "it" 关键字弄混淆。我们将在 *闭包* 部分讨论这个问题。
- en: Map
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map
- en: 'Map is a key-value pair collection, where the key is unique. In Groovy, key-value
    pairs are delimited by colons. An empty Map can be created via [`:`]. By default,
    a Map is of the type `java.util.HashMap`. If the keys are of type String, you
    can avoid the single or double quotes in the Map declaration. For example, if
    you want to create a Map with `name` as the key and `Groovy` as the value, you
    can use the following notation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Map 是一个键值对集合，其中键是唯一的。在 Groovy 中，键值对由冒号分隔。可以通过 `[:]` 创建一个空的 Map。默认情况下，Map 的类型是
    `java.util.HashMap`。如果键是 `String` 类型，你可以在 Map 声明中避免使用单引号或双引号。例如，如果你想创建一个以 `name`
    为键、以 `Groovy` 为值的 Map，你可以使用以下表示法：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, `[name: "Groovy"]` is the same as `["name":"Groovy"]`. By default, Map
    keys are Strings. But if you want to put some variable as the key, then use parentheses,
    as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`[name: "Groovy"]` 与 `["name":"Groovy"]` 是相同的。默认情况下，Map 的键是字符串。但如果你想要将某个变量作为键，那么请使用括号，如下面的代码所示：'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, you can create a Map in the following way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以按以下方式创建一个Map：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can get the objects from the Map using `key m2.get("id")` or `m2["id"]`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`key m2.get("id")`或`m2["id"]`从Map中获取对象。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If key is a String, then to get a value, you need to specify the key in double
    quotes (`""`). If you do not specify the key in double quotes, it will treat it
    as a variable name and will try to resolve it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键是字符串，那么要获取值，你需要指定双引号内的键（`""`）。如果你没有指定双引号内的键，它将把它视为变量名并尝试解析它。
- en: 'Now we will discuss some of the utility methods (each, any, and every) of Maps,
    which accept Closures:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论Map的一些实用方法（each、any和every），这些方法接受闭包：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To parse every entry of `Map`, you can use `each`. It takes either entry or
    key-value as a parameter, as shown in the following table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析`Map`中的每个条目，你可以使用`each`。它接受条目或键值作为参数，如下表所示：
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'If you want to validate the `Map` data, you can use either `.every` or `.any`,
    based on your requirements. The `.every` method checks and makes sure all records
    fulfil the mentioned condition, while `.any` just checks whether any one record
    fulfils the condition. For example, if you want to check whether there is any
    user who is more than 25 years old:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想验证`Map`数据，你可以根据需要使用`.every`或`.any`。`.every`方法检查并确保所有记录都满足所述条件，而`.any`只是检查是否有任何记录满足条件。例如，如果你想检查是否有任何用户年龄超过25岁：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It returns the output as a Boolean value; in this case, true, as Meera is 28.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个布尔值作为输出；在这种情况下，为真，因为Meera是28岁。
- en: 'If you want to check whether all the users are above 18:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查所有用户是否都超过18岁：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It will return false, as Harry is 18.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回false，因为Harry是18岁。
- en: You can also use the `find` and `findAll` methods for `Map` in the same pattern
    as we used for `List` in the *List* section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用与我们在*列表*部分中使用`List`相同的模式使用`find`和`findAll`方法为`Map`。
- en: Range
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: Apart from Java collection types, Groovy also supports a new collective data
    type `Range`. It is defined as two values (generally starting point and ending
    point) separated by two dots.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java集合类型外，Groovy还支持一种新的集体数据类型`Range`。它定义为两个值（通常是起点和终点），由两个点分隔。
- en: 'To create a `Range`, use the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`范围`，请使用以下代码：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To read values from `Range`, use the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Range`读取值，请使用以下代码：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also use the `.any` and `.every` operators to validate range for your
    specific requirement. It checks for the condition and returns a Boolean value.
    Let''s take a look at the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`.any`和`.every`运算符来验证特定要求的范围。它检查条件并返回一个布尔值。让我们看看以下代码：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For modifying the range interval, use the following code. If you want to modify
    range interval from default 1 to any other number, you can set it via step method.
    It returns a list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改范围间隔，请使用以下代码。如果你想将范围间隔从默认的1修改为任何其他数字，你可以通过step方法设置它。它返回一个列表：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To fetch the starting element and ending element of a range, use the `From`
    and `To` element, as shown in the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取范围的起始元素和结束元素，请使用`From`和`To`元素，如下所示代码：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `isReverse()` method is used to check the range trend to see whether the
    range is constructed using `to value` ( higher value) to `from value` (lower value):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`isReverse()`方法用于检查范围趋势，以查看范围是否使用`to value`（较高值）到`from value`（较低值）构建：'
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Closure
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: Closure has usually been associated with functional languages. Groovy provides
    a very easy way of creating closure objects. A Groovy Closure is like a code block
    written in curly braces. Many people associate Closure to be an anonymous function
    in Java.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包通常与函数式语言相关联。Groovy提供了一种非常简单的方法来创建闭包对象。Groovy闭包就像用花括号编写的代码块。许多人将闭包与Java中的匿名函数相关联。
- en: Closure in Groovy may accept arguments and returns a value. By default, the
    last statement in a Groovy Closure is the `return` statement. It means that if
    you are not explicitly returning any value from Closure, it will by default, returns
    the output of the last statement of Closure. Commonly, we define a Closure like
    this `{argument list-> closure body}`. Here, an argument list is a comma separated
    value that Closure accepts. Arguments are optional. If no argument is specified,
    then one implicit untyped argument named `it` will be available in the Closure
    body. The argument `it` will be null if no argument is supplied during Closure
    invocation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 中的闭包可以接受参数并返回一个值。默认情况下，Groovy 闭包中的最后一个语句是 `return` 语句。这意味着如果你没有从闭包显式返回任何值，它将默认返回闭包最后一个语句的输出。通常，我们定义闭包如下
    `{argument list-> closure body}`。在这里，参数列表是闭包接受的逗号分隔值。参数是可选的。如果没有指定参数，则在闭包体中将有一个隐式的无类型参数
    `it` 可用。如果闭包调用时没有提供参数，则 `it` 将为 null。
- en: 'In the following example, for the first call of Closure `addTwo` the variable
    `it` is assigned is `2`, but in the second call, `it` is assigned null:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，对于闭包 `addTwo` 的第一次调用，分配给变量 `it` 的值是 `2`，但在第二次调用中，`it` 被分配为 null：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, you can even declare a variable of type Closure. In Groovy,
    Closures are a subclass of the `groovy.lang.Closure` type:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你甚至可以声明一个类型为闭包的变量。在 Groovy 中，闭包是 `groovy.lang.Closure` 类的子类：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To separate the Closure body from the argument list, we use the `->` operator.
    The closure body consists of zero or more Groovy statements. Like methods, it
    can also reference and declare variables in its scope.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将闭包体与参数列表分开，我们使用 `->` 操作符。闭包体由零个或多个 Groovy 语句组成。像方法一样，它也可以在其作用域内引用和声明变量。
- en: 'In the following code snippet, the `addOne` method was able to reference the
    `constantValue` variable in its scope, though it was defined outside of the Closure
    scope. Such variables are referred to as `free` variables. A variable which is
    defined within the curly braces of a Closure would be treated as a local variable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`addOne` 方法能够在其作用域内引用 `constantValue` 变量，尽管它是在闭包作用域外定义的。这样的变量被称为 `free`
    变量。在闭包的花括号内定义的变量将被视为局部变量：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding example, the argument of the Closure was of Integer type. With
    Closures, the statements within the curly braces are not executed until you explicitly
    invoke them, using either `call()` or by an `unnamed ()` invocation syntax of
    Closure. In our example, the closure is declared in the second line, but it's
    not evaluated at that time. It will be executed if the `call()` method is explicitly
    made on the Closure. This is an important differentiator between Closures and
    code blocks. They may look the same, but they are not. Closures are only executed
    if the `call()` method is invoked on the Closure; not during its definition time.
    Remember, Closures are first class objects in Groovy, and can be referred using
    untyped variables or by using Closure variables. In both the cases, it is derived
    from `groovy.lang.Closure`. This class has overloaded `call()` methods with no
    or multiple arguments to invoke Closures.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，闭包的参数类型是整数类型。使用闭包时，花括号内的语句不会在显式调用它们之前执行，无论是使用 `call()` 方法还是通过闭包的 `unnamed
    ()` 调用语法。在我们的例子中，闭包在第二行被声明，但当时并没有进行评估。只有在显式地对闭包调用 `call()` 方法时，它才会执行。这是闭包和代码块之间的重要区别。它们看起来可能相同，但实际上并不相同。闭包只有在调用
    `call()` 方法时才会执行；不是在其定义时间。记住，闭包在 Groovy 中是一等对象，可以使用无类型变量或使用闭包变量来引用。在这两种情况下，它都源自
    `groovy.lang.Closure` 类。这个类有重载的 `call()` 方法，可以没有参数或多个参数来调用闭包。
- en: When `addOne` Closure was called with an Integer as an argument, it executed
    successfully. However, for String type as an argument, it throws an exception.
    Also observe that the compiler didn't complain when we passed a String as an argument
    to the `addOne` Closure. This is because all arguments are checked at runtime;
    there is no static type checking done by the compiler.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `addOne` 闭包以整数作为参数被调用时，它执行成功。然而，对于字符串类型作为参数，它抛出异常。同时观察，当我们将字符串作为参数传递给 `addOne`
    闭包时，编译器并没有抱怨。这是因为所有参数都是在运行时检查的；编译器没有进行静态类型检查。
- en: The `doCall()` method on this Closure is generated dynamically, which accepts
    only Integer as an argument. So any invocation other than Integer type will throw
    an exception. The `doCall()` method is the implicit method, which cannot be overridden
    and cannot be redefined. This method is always invoked implicitly when we invoke
    call method or `unnamed ()` syntax on a Closure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包上的 `doCall()` 方法是动态生成的，它只接受 Integer 类型的参数。因此，任何非 Integer 类型的调用都将抛出异常。`doCall()`
    方法是隐式方法，不能被重写也不能被重新定义。当我们调用闭包的 call 方法或 `unnamed ()` 语法时，这个方法总是隐式调用。
- en: We will conclude Closure by discussing the concept of delegate. This feature
    is widely used in Gradle. For example, when we define a repository Closure or
    dependency Closure in the build script, those Closures are executed in the `RepositoryHandler`
    or `DependencyHandler` classes. These classes are passed to the closures as delegates.
    You can refer to the Gradle API for more details. Let us not complicate things
    here. We will try to understand the concept with simple examples.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论代理的概念来结束对闭包的讨论。这个特性在 Gradle 中被广泛使用。例如，当我们定义构建脚本中的存储库闭包或依赖闭包时，这些闭包将在 `RepositoryHandler`
    或 `DependencyHandler` 类中执行。这些类作为代理传递给闭包。您可以参考 Gradle API 获取更多详细信息。在这里，我们不妨简单化问题。我们将通过简单的示例来理解这个概念。
- en: 'Consider the following example, where we are trying to print a `myValue` variable,
    which is undefined in the class. Obviously, this call will throw an exception
    as this variable is not defined in the scope:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，我们正在尝试打印一个 `myValue` 变量，该变量在类中未定义。显然，这个调用将抛出异常，因为这个变量在作用域内未定义：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There could be a situation where we want to execute this closure against another
    class. This class can be passed to the closure as a delegate:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一种情况，我们想要在另一个类上执行这个闭包。这个类可以作为代理传递给闭包：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, the `PrintHandler` class has defined the `myValue` variable.
    We have delegated and executed the closure against the `PrintHandler` class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PrintHandler` 类已定义了 `myValue` 变量。我们已经委托并针对 `PrintHandler` 类执行了闭包。
- en: 'So far, it is working as expected. Now, what if `myValue` is redefined in the
    `PrintValue` class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它按预期工作。现在，如果 `myValue` 在 `PrintValue` 类中被重新定义：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this scenario, on executing the Closure, we will find the output as `I''m
    owner`. This is because, when closure was trying to resolve the `myValue` variable,
    it found the variable defined within the scope of the owner (the `PrintValue`
    class, where the Closure is defined), so it didn''t delegate the call to the `PrintHandler`
    class. Formally, this is known as `OWNER_FIRST` strategy, which is the default
    strategy. The strategy resolves this way—the closure will be checked first, followed
    by the closure''s scope, then the owner of the closure, and, finally, the delegate.
    Groovy is so flexible that it provides us with the capability to change the strategy.
    For example, to delegate the call to the `PrintHandler` class, we should specify
    the strategy as `DELEGATE_FIRST`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，在执行闭包时，我们将找到输出为 `I'm owner`。这是因为，当闭包尝试解析 `myValue` 变量时，它发现该变量定义在所有者的作用域内（定义闭包的
    `PrintValue` 类），因此它没有将调用委托给 `PrintHandler` 类。正式来说，这被称为 `OWNER_FIRST` 策略，这是默认策略。策略的解析方式是这样的——首先检查闭包，然后是闭包的作用域，然后是闭包的所有者，最后是代理。Groovy
    非常灵活，它为我们提供了更改策略的能力。例如，要将调用委托给 `PrintHandler` 类，我们应该指定策略为 `DELEGATE_FIRST`：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With the `DELEGATE_FIRST` strategy, the closure will try to resolve the property
    or methods to the delegate first and then the owner. The other important strategies
    are:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DELEGATE_FIRST` 策略时，闭包将首先尝试将属性或方法解析到代理，然后是所有者。其他重要的策略包括：
- en: '`OWNER_ONLY`: It attempts to resolve the property or methods within the owner
    only and doesn''t delegate.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OWNER_ONLY`：它尝试仅在所有者内部解析属性或方法，并不进行代理。'
- en: '`DELEGATE_ONLY`: Closure will resolve the property references or methods to
    the delegate. It completely ignores the owner.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELEGATE_ONLY`：闭包将解析属性引用或方法到代理。它完全忽略所有者。'
- en: '`TO_SELF`: It will resolve the property references or methods to itself and
    go through the usual `MetaClass` look-up process.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TO_SELF`：它将解析属性引用或方法到自身，并经过常规的 `MetaClass` 查找过程。'
- en: 'This was indeed a very short description. I suggest you to refer to the Groovy
    documentation for more details at: [http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html](http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个非常简短的描述。我建议您参考Groovy文档以获取更多详细信息，链接如下：[http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html](http://docs.groovy-lang.org/latest/html/api/groovy/lang/Closure.html)。
- en: Builder
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器
- en: Another important feature in Groovy is Builder. Groovy Builders allow you to
    create complex tree-like hierarchical object structures. For example, SwingUI
    or XML documents can be created very easily using the DSL or Closure-like features
    in Groovy, with the support of the `BuilderSupport` class and its subclasses,
    `MarkupBuilder` and `SwingBuilder`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，另一个重要特性是Builder。Groovy Builders允许您创建复杂的树状分层对象结构。例如，SwingUI或XML文档可以非常容易地使用Groovy中的DSL或类似闭包的功能创建，得益于`BuilderSupport`类及其子类`MarkupBuilder`和`SwingBuilder`的支持。
- en: 'Let''s try to understand with an example. We created the `Order` class earlier
    in this chapter. Assume we have a list of orders and we want to store the details
    in a file called `orders.xml`. So every `Order` object in our list should be saved
    as a node in the XML file. Each of these `Order` nodes, again should contain child
    nodes, grand children nodes, and so on. Creating this tree-like structure can
    be complex if we try to implement a DOM-like parser in Java:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来尝试理解。我们在本章的早期创建了`Order`类。假设我们有一个订单列表，我们想要将详细信息存储在名为`orders.xml`的文件中。因此，我们列表中的每个`Order`对象都应该作为XML文件中的一个节点保存。这些`Order`节点再次应该包含子节点、孙子节点，依此类推。如果我们尝试在Java中实现类似DOM的解析器，创建这种树状结构可能会很复杂：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: But in Groovy, this is just few lines of code with some method calls combined
    with Closure and named parameters. In the following example, we have created a
    `builder` object from the `MarkupBuilder` class to create the XML document. Then
    we have defined `orders` as the root of the document. However, `builder` has no
    method defined as `orders`. So then, how does this work?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Groovy中，这只是一些代码行和一些方法调用，结合闭包和命名参数。在下面的示例中，我们从`MarkupBuilder`类创建了一个`builder`对象来创建XML文档。然后我们定义`orders`为文档的根。然而，`builder`没有定义名为`orders`的方法。那么这是怎么工作的呢？
- en: 'As mentioned earlier, the `MarkupBuilder` class is a subclass of the `BuilderSupport`
    class. `BuilderSupport` has methods such as `createNode`, `invokeMethod`, `nodeCompleted`,
    `setCurrent`, `setParent`, and a few more. In runtime, an object is created by
    calling the `createNode` method on the builder with the name `orders`. In a similar
    fashion, for each `order` object, `no`, `description`, and `customer` nodes are
    created. Finally, each `order` node is attached to the parent `orders` node by
    calling the `setParent` method of the builder object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`MarkupBuilder`类是`BuilderSupport`类的子类。`BuilderSupport`具有`createNode`、`invokeMethod`、`nodeCompleted`、`setCurrent`、`setParent`等方法。在运行时，通过在名为`orders`的构建器上调用`createNode`方法创建一个对象。以类似的方式，对于每个`order`对象，创建`no`、`description`和`customer`节点。最后，通过调用构建器对象的`setParent`方法将每个`order`节点附加到父`orders`节点：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some basic fundamental concepts. We learned about
    concepts of classes, methods, beans, collection frameworks, and closures. We also
    developed a markup builder to produce XML files. This was indeed a very short
    introduction to Groovy. However, in my opinion this introduction should be good
    enough to write Gradle scripts for your projects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些基本的基本概念。我们学习了类、方法、bean、集合框架和闭包的概念。我们还开发了一个标记构建器来生成XML文件。这确实是对Groovy的非常简短的介绍。然而，在我看来，这个介绍应该足够编写您项目的Gradle脚本。
- en: From the next chapter onwards, we will start exploring the core features of
    Gradle. In the next chapter, we will learn task management in Groovy. We will
    take a close look at the different in-built tasks supported by Gradle. We will
    also learn about task dependencies and task configurations. Then we will create
    some custom tasks for build scripts.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将开始探索Gradle的核心功能。在下一章中，我们将学习Groovy中的任务管理。我们将仔细研究Gradle支持的不同内置任务。我们还将了解任务依赖和任务配置。然后我们将为构建脚本创建一些自定义任务。
