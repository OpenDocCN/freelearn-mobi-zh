- en: Exploiting the Widgets Variety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will first take a look at constraints in Flutter and understand
    how it will help in your application development. We will then have a quick introduction
    to animations and its categories, and take a look at common patterns in it. Then,
    we will move on to using `ListView` and scrolling widgets, and, finally, have
    a quick section about silvers. All these topics will be covered in the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Constraints in Flutter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing animations in Flutter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ListView` and scrolling widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing silvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints in Flutter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every widget in Flutter is rendered by a `RenderBox` object that takes the constraints
    given by the parent and sizes itself within those constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between constraint and size is that the former gives a minimum
    and maximum of height and width, while the latter consists of a specific height
    and width.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of RenderBoxes, distinguished by their behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Those that try to be as big as possible (`ListView`, Center and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those that try to be the same size as their children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those that try to be a particular size (image, text and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in every rule, we need exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Some widgets vary their behavior depending on their constructor arguments. For
    example, the Container widget tends to be as big as possible, but, if you give
    it a width (or height), it tries to be that particular size.
  prefs: []
  type: TYPE_NORMAL
- en: A particular constraint is the unbounded (or infinite) one. In this case, either
    the maximum width or height is set to `double.INFINITY`.
  prefs: []
  type: TYPE_NORMAL
- en: A box that tries to be as big as possible won't work with unbounded constraint,
    and the framework will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: This can happen within flex boxes (row/column) and scrollable regions (`ListView`
    and other `ScrollView` subclasses).
  prefs: []
  type: TYPE_NORMAL
- en: A constraint can be tight. This means that it leaves no room for the `RenderBox`
    object to choose a size. An example is the App widget, which forces the view to
    be as big as the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flex boxes (row and columns) behave differently based on whether they are in
    bounded or unbounded constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: In bounded constraints, they try to be as big as possible in that direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In unbounded constraints, they try to fit their children in that direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing animations in Flutter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations are one of the important features of a widget. Sometimes, developers
    think that animations are not very important, but designers know that a good set
    of animations can attract many users. They also contribute to the look and feel
    of the application, giving it more personality.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter has a great animation support, making it easy to build nice effects
    and movements. Many widgets come with standard motion effects designed in their
    design specification, but you can always customize them according to your own
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the animation categories, where we will see the two categories
    the animations in Flutter are divided into, and then take a look at the common
    patterns of animations.
  prefs: []
  type: TYPE_NORMAL
- en: Animation categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, animations are defined in two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tween animations**: Short for **in-betweening**. In this case, we define the
    beginning and ending point, the timeline, and a curve of time and speed. The framework
    will do the rest of the work, calculating the transition and executing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics-based animations**: These types of animations are made with the aim
    to represent the real-world behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a user, you may have noticed that some types of animations are constantly
    used in most apps. These types of animations are the common patterns in animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Flutter, you can find three common patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Animated list/grid**: A simple list or grid animating when adding/removing
    an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared element transition**: This is used when navigating between two pages
    that have common elements. For example, an image that shows a thumbnail in one
    route and a normal picture in another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staggered animation**: A sequence of animations that compose a bigger one.
    They can be sequential or overlapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ListView and scrolling widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flutter supports several scrolling widgets, such as `Gridview`, `ListView`,
    `and PageView`. Lists are the most commonly used scrolling widgets, and are a
    scrollable, linear list of widgets. It enables the display of its children one
    after another in the scroll direction.
  prefs: []
  type: TYPE_NORMAL
- en: ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ListView` is a linear list of scrollable items, and is one of the most commonly
    used widgets. If you have worked on `ListView`s in Android or iOS, this will be
    straightforward. As in every case, `ListView` produces child-list items one after
    another. There are several ways to build `ListView`s, so let''s take a look at
    the approaches one-by-one.'
  prefs: []
  type: TYPE_NORMAL
- en: Using List<Widget>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest and most standalone way of building `ListView` is by using an explicit
    `List<Widget>` of children. This method is ideal for lists with a fixed number
    of children. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows how the preview will look after you run the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/920fb3e4-0960-4832-b722-8b529369b94f.png)'
  prefs: []
  type: TYPE_IMG
- en: Using ListView.Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ListView.builder` constructor calls for `IndexedWidgetBuilder`, which helps
    developers to build children lists items on demand. This is ideally used for a
    large or infinite number of visible children, unlike the `ListView` constructor.
    The other difference is that, while in the case of `ListView`, all the list items
    have to be defined first, in this case, the `ListView.builder` constructor will
    create runtimes for the list items as they are scrolled onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining `ListView.builder` is simple and straightforward, as you can see in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding code, you will see a `ListView` constructor that shows
    the index of each item with a text glued to it. The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the code, the app will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef07a627-b5c8-4be6-bf0d-6b8c4ff7c8fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we could add a data source to work with. The data source can be messages,
    search results, or the sources on the internet that you wish to fetch the data
    from. We will use the `List<E>.generate` constructorto generate values using the
    following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This creates a list of values with length positions and fills it with values
    created by calling generator for each index in the range 0 till length–1 in increasing
    order. The created list is fixed unless the value of `growable` value is set to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code using the data source to generate `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/070eb0ed-23ea-4cd8-8050-2b719bee298a.png)'
  prefs: []
  type: TYPE_IMG
- en: ListView separated by calling ListView.separated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous cases of code executions, we saw that even though the `ListTiles`
    were listed, there was no separation among them. To build a divider between the
    `ListTiles`, it also provides a helper constructor for creating a `ListView`.
    The constructor is `ListView.separated`. This divider is called by the **divider
    class** to build a one device pixel-thick horizontal line, having padding on either
    side. Dividers can be used in lists, drawers, or separate content, vertically
    or horizontally based on the value of the `Axis` enum, as specified in the following `ListView.separated` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor can be called in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This builds a fixed-length scrollable linear array of list items that are separated
    by list items `separators`. The `itemBuilder` callback will be called with indices
    greater than or equal to `0`, and less than `itemCount`. The separator is built
    after the first item and before the last item in the list. The `separatorBuilder`
    callback will be called with indices greater than or equal to `0`, and less than
    `itemCount 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the sample of the `ListView` constructor using `ListView.separated`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the preceding code, you will see the `ListView` with separators.
  prefs: []
  type: TYPE_NORMAL
- en: Using ListView.custom constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By making use of `SilverChildDelegate`, this method provides the ability to
    customize several aspects of the child model, defining the way in which they are
    built. The main parameter required for this is `SliverChildDelegate`, which builds
    the items. The types of `SliverChildDelegates` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SliverChildListDelegate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SliverChildBuilderDelegate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SliverChildListDelegate` accepts a direct list of children, while, on the
    other hand, `SliverChildBuiderDelegate` accepts `IndexedWidgetBuilder`. Take a
    look at the `ListView.custom` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Horizontal lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have received a hands-on with vertical lists, horizontal lists are
    simple. In this case, we call the `ListView` constructor, passing through a horizontal
    `scrollDirection`. This simply overrides the default vertical direction. In this
    case, we use a `Container` widget, which is an easy-to-use widget that combines
    common painting, positioning, and sizing widgets. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListView` `scrollDirection: Axis.horizontal` property ensures that the
    list is horizontally scrollable. Once you run the code successfully, you will
    see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5ff0cb7-65b7-43f1-9793-e2980c385192.png)'
  prefs: []
  type: TYPE_IMG
- en: Grid lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like in the case of horizontal lists, event grid lists are easy to build.
    It uses a `GridView.count` constructor that allows us to specify how many rows
    and columns we want on the screen. In the following example, we build `100` widgets
    that print the value of the position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a25ccd3e-975a-43a0-923a-f6340bccc371.png)'
  prefs: []
  type: TYPE_IMG
- en: Introducing silvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We took a look at the `ListView`, now let's quickly take a look at what silvers
    are, taking a quick example from the `ListView`. Being fancy in your layout can
    be visually pleasing if executed well. That's exactly how silver can help you. A
    silver is a portion of a scrollable area using which you can bring in custom scrolling
    into your view. Let's take a simple example in the form of `ListView`. If an app
    bar remains static it can sometimes obstruct the view, so, in this case, silver
    can be used to hide the app bar while you scroll.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that has to be noted is that all of the sliver components go inside `CustomScrollView`.
    As a developer, you can then combine your lists of silvers to build your custom
    scrollable area.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of the chapter, we began discussing constraints in Flutter. We
    then discussed animations and forms of animation in Flutter. In the next section,
    we executed some examples of different types of lists. In the final section, we
    looked at how we can custom animate the portion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will widen our Flutter horizon and look at network and
    accessibility with Flutter.
  prefs: []
  type: TYPE_NORMAL
