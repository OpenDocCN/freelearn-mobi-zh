<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. New Features of OpenGL ES 3.0</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Managing variable attributes with qualifiers</li><li class="listitem" style="list-style-type: disc">Grouping uniforms and creating buffer objects</li><li class="listitem" style="list-style-type: disc">Managing VBO with Vertex Array Objects</li><li class="listitem" style="list-style-type: disc">Reading and writing buffer objects with mapping</li><li class="listitem" style="list-style-type: disc">Rendering multiple objects with geometry instancing</li><li class="listitem" style="list-style-type: disc">Rendering multiple primitives with primitive restart</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Introduction</h1></div></div></div><p>OpenGL ES 3.0 was <a id="id208" class="indexterm"/>publicly released in August 2012. It brings the mobile 3D graphics to the next level. This release was focused to provide 3D-enriched features and enhanced the portability across diverse mobiles, embedded operating systems, and platforms. OpenGL ES 3.0 is fully backward compatible with OpenGL ES 2.0. This enables the applications to grow the graphics capabilities and visual features <a id="id209" class="indexterm"/>incrementally. OpenGL ES 3.0 also introduces a new version of <strong>GL Shading Language</strong> (<strong>GLSL</strong>) 3.0. The GLSL is used for programing shaders. The new shading language has also extended the capabilities in many directions, which you will learn in the next section.</p><p>This chapter will be helpful in understanding the new features introduced in OpenGL ES 3.0 and GL shading language 3.0. This book uses OpenGL ES 3.0 in conjunction with GLSL 3.0 for all its recipes.</p><p>The new features of <a id="id210" class="indexterm"/>OpenGL ES 3.0 can be broadly divided into the following five categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Geometry</strong>: These features focus on the vertex attributes specifications, such as data storage, data <a id="id211" class="indexterm"/>transfer, attribute states, primitive assembly, and so on. They are explained as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Transform feedback</strong>: This feature allows us to capture the vertex shader output to provide feedback to the GPU for next frame rendering. This way, it avoids CPU intervention and makes the rendering efficient.</li><li class="listitem" style="list-style-type: disc"><strong>Occlusion query</strong>: This enables fast hardware testing to check whether a pixel is going to appear on screen or whether it is occluded by another pixel. This kind of check is helpful in deciding whether to skip certain operations such as geometry processing because it's occluded.</li><li class="listitem" style="list-style-type: disc"><strong>Geometry instancing</strong>: This allows efficient rendering of an object multiple times without calling multiple render API's. This is very helpful in situations such as crowd simulation, trees rendering, and so on.</li><li class="listitem" style="list-style-type: disc"><strong>Primitive restart</strong>: This new feature allows us to render multiple disconnected primitives using a single drawing API call. The index array is used to pack multiple primitives (of the same type) in a single bundle. This array contains multiple disconnected primitives with a special marker that helps the GPU o render disconnected primitives in one go.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Textures</strong>: There are <a id="id212" class="indexterm"/>many new features added into OpenGL ES 3.0 for textures. The features are described here:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Depth textures and shadow comparison</strong>: Depth textures allow the storing of the depth buffer information into a texture. This is helpful in rendering shadows using the <strong>percentile closest filtering</strong> (<strong>PCF</strong>) technique in which depth information is explicitly stored from the <a id="id213" class="indexterm"/>depth buffer <a id="id214" class="indexterm"/>to a texture using the render-to-texture technique. Later, this information is used to test incoming fragments for whether they are a part of shadow or not. OpenGL ES 3.0 allows this comparison test implicitly.</li><li class="listitem" style="list-style-type: disc"><strong>Seamless cube maps</strong>: The cubemap rendering is improved to remove artifacts from the boundary edges of the images. Now, the filtering techniques take adjacent faces texture data into account to produce seamless texture boundaries on the face edges. You can refer to the <em>Implementing Skybox with seamless cube mapping</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Textures and Mapping Techniques">Chapter 7</a>, <em>Textures and Mapping Techniques</em>.</li><li class="listitem" style="list-style-type: disc"><strong>ETC2/EAC texture-compression formats</strong>: Before OpenGL ES 3.0, there was no standard compression format officially supported by OpenGL ES. Developers relied on the specific compression formats provided by different vendors, such as PVRTC by Imagination Technologies, <strong>Ericsson Texture Compression</strong> (<strong>ETC</strong>) by Sony Ericsson, ATC by Qualcomm, and so on. Now, ETC2 and EAC texture-compression formats are integrally <a id="id215" class="indexterm"/>supported in OpenGL ES 3.0. Refer to the <em>Efficient rendering with ETC2 compressed texture </em>recipe in <a class="link" href="ch07.html" title="Chapter 7. Textures and Mapping Techniques">Chapter 7</a>, <em>Textures and Mapping Techniques</em>.</li><li class="listitem" style="list-style-type: disc"><strong>Nonpower of two</strong> (<strong>NPOT</strong>) texture: Now, textures with pixel dimensions of the nonpower of two texture are supported with full wrap mode <a id="id216" class="indexterm"/>and mipmapping. In earlier specifications of OpenGL ES, the textures had to be in the form of power of two (POT) dimensions. Therefore, external imaging tools were required to convert NPOT to POT format.</li><li class="listitem" style="list-style-type: disc"><strong>Texture swizzles</strong>: The GLSL provides a level of abstraction in accessing the components of texture, R, G, B, and A, irrespective of the order in which they are stored physically.</li><li class="listitem" style="list-style-type: disc"><strong>Increased 2D texture dimension</strong>: The dimension of 2D texture in OpenGL ES 3.0 is 2048, which is much more compared to OpenGL ES 2.0.</li><li class="listitem" style="list-style-type: disc"><strong>3D texture</strong>: OpenGL ES 3.0 supports 3D texture targets. 3D textures are <a id="id217" class="indexterm"/>widely used in medical imaging.</li><li class="listitem" style="list-style-type: disc"><strong>Arrays of 2D texture</strong>: This new features allows us to store multiple 2D <a id="id218" class="indexterm"/>textures in the form of an array. This is useful for animation purpose. Prior to this, texture sprites were used.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Shaders</strong>: These are the special small programs that are used in modern computer graphics <a id="id219" class="indexterm"/>programming to control geometry and pixel color shading. The features on shaders are as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Program binaries</strong>: The vertex and fragment shaders are compiled and stored in a binary format. This binary format needs to be linked to the program at run time in OpenGL ES 2.0. OpenGL ES 3.0 allows an optimization by storing this binary into an offline binary format that does not require linking at run time. This optimization helps load the application faster by avoiding runtime linking.</li><li class="listitem" style="list-style-type: disc"><strong>Flat/smooth interpolators</strong>: In OpenGL ES 2.0, all the interpolators perform linear interpolation across the primitives. With the help of GLSL 3.0, in OpenGL ES 3.0, the interpolation can be <a id="id220" class="indexterm"/>explicitly declared to have flat and smooth shading.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Buffer objects</strong>: These allow us to store vertex data on the GPU memory. The new features have <a id="id221" class="indexterm"/>extended the capabilities of buffer objects to make them more efficient. Here are the new features:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Uniform blocks</strong>: This allows to group related uniform values into a single manageable group. This increases the readability of the shader program.</li><li class="listitem" style="list-style-type: disc"><strong>Layout qualifiers</strong>: The attributes defined in the vertex and fragment shaders can be directly bound to the user-defined locations. This way, the on-fly binding API calls are not required.</li><li class="listitem" style="list-style-type: disc"><strong>Vertex Array Objects</strong>: This feature provides an efficient way to bind vertex <a id="id222" class="indexterm"/>array data and respective attributes. <strong>Vertex Array Objects</strong> (<strong>VAO</strong>) are used to encapsulate the VBO. When a VAO API is called, it efficiently switches the states stored in VBO without calling several APIs. This reduces the overhead in the switching of vertex array states.</li><li class="listitem" style="list-style-type: disc"><strong>Uniform buffer object</strong>: This feature stores the uniform block in an efficient <a id="id223" class="indexterm"/>way as a buffer object. This uniform block object can be bound on fly time. This gives an opportunity to share the uniform data among multiple programs at once. Additionally, it allows us to set multiple uniform variables in one go.</li><li class="listitem" style="list-style-type: disc"><strong>Subrange buffer mapping</strong>: Unlike mapping the complete buffer from the GPU to the <a id="id224" class="indexterm"/>CPU side, this mechanism provides an efficient way to access a range of memory contents from the GPU memory space. Sometimes, the intention is to update only a small section of the buffer. Therefore, mapping the complete buffer is inefficient. In such situations, subrange buffer mapping reduces the time of marshaling from GPU to CPU to GPU.</li><li class="listitem" style="list-style-type: disc"><strong>Buffer object copies</strong>: This mechanism transfers the data of one buffer object to the other one without intervening the CPU.</li><li class="listitem" style="list-style-type: disc"><strong>Sync object</strong>: This provides a synchronized mechanism between the applications and GPU. In this way, the application can assure completion of OpenGL ES operations on the GPU side.</li><li class="listitem" style="list-style-type: disc"><strong>Fencing</strong>: This feature informs the GPU to wait for queuing up new OpenGL ES operations until the old operations are completely <a id="id225" class="indexterm"/>executed on the GPU.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Framebuffer</strong>: The new features also include enhancements related to off-screen rendering for <a id="id226" class="indexterm"/>the framebuffer. Here are the new features:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Multiple render target (MRT)</strong>: This feature allows us to perform off-screen rendering simultaneously to several color buffers <a id="id227" class="indexterm"/>or textures at the same time. These textures can be used as input to other shaders or can be used on 3D models. MRTs are most commonly used to achieve deferred shading.</li><li class="listitem" style="list-style-type: disc"><strong>Multisample render buffer</strong>: This feature enables the application to <a id="id228" class="indexterm"/>perform off-screen framebuffer rendering with multisample anti-aliasing. This improves the visual quality of the generated image and reduces the <a id="id229" class="indexterm"/>jagged-line effect that appears in the lines or sharp geometry edges drawn diagonally to the screen.</li></ul></div></li></ul></div><p>This chapter will focus on the new features of geometry and buffer objects. As we progress with the upcoming chapters, we will also introduce the new features of shaders, textures, and framebuffers.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>You can explore <a id="id230" class="indexterm"/>more about OpenGL ES 3.0 specifications and documentation on <a class="ulink" href="http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf">http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf</a> and <a class="ulink" href="http://www.khronos.org/opengles/sdk/docs/man3/">http://www.khronos.org/opengles/sdk/docs/man3/</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Managing variable attributes with qualifiers</h1></div></div></div><p>GLSL 3.0 has <a id="id231" class="indexterm"/>introduced two new qualifiers: storage <a id="id232" class="indexterm"/>and layout. Let's take a look at them in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Storage qualifier</strong>: This is a special keyword that specifies the storage or the behavior of a <a id="id233" class="indexterm"/>global or local variable. It is used in shader programming. It enables the communication bridge between the application and shaders. It is also used to share information from one shader stage to another. For example, a 3D light illumination technique requires an object's geometry information in order to create realistic light shading. This geometry information is calculated in the vertex shader and passed to the fragment shader, where this input is used to color the fragments of the geometric primitives.<p>There are six types of storage qualifiers available in GL SL 3.0. They are described in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Qualifier</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">const</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the value of variable does not alter compile time.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">in</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the copied input variable from the previous stage, which is linked to the current shader. If specified in a function argument, this is an input variable.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">centroid in</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the input type variable linked to the centroid interpolator.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">out</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the copied input variable from the previous stage, which is linked to the current shader. If specified in a function argument, this is an output variable.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">centroid out</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the output type variable that is linked to the centroid interpolator.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">uniform</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the value of the variables does not change across the primitives during the processing. The uniforms are shared across the shaders.</p>
</td></tr></tbody></table></div></li><li class="listitem" style="list-style-type: disc"><strong>Layout qualifier</strong>: This influences the properties of a variable, such as storage, location, memory alignment, and so on. This qualifier is widely used in declaring the <a id="id234" class="indexterm"/>location of the variable(s) in shaders. Each variable or generic attribute declared in the shader is stored in an allocated memory location on the GPU. This memory <a id="id235" class="indexterm"/>location is used to store data in the variables as a result of runtime calculation or input data from the previous stage of the shader. Unlike C/C++ pointers, the shading language uses a location ID to access the variable. A location is an ID (numeric value(s)) of a variable that is used to connect the variable present in the shading language to the application program.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec87"/>Getting ready</h2></div></div></div><p>The next table specifies the syntax for the storage and layout qualifiers. The storage qualifiers are mentioned before the data type of the variable. The most commonly used qualifiers are in and out. These storage qualifiers tell us whether the vertex attribute is an incoming or outgoing variable.</p><p>The layout qualifier assigns an ID or location to the vertex attribute so that run the binding and querying of the location can be avoided. The layout qualifier is always mentioned <a id="id236" class="indexterm"/>before the storage qualifier.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Qualifier</p>
</th><th style="text-align: left" valign="bottom">
<p>Syntax</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Storage</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">(storage qualifier) [Data type] [Variable Name]</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Layout</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">layout (qualfier1, qualifier2 = value, . . .)  [Storage qualifier]</code></p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec88"/>How to do it...</h2></div></div></div><p>The variables in a shader are abstracted in the form of location IDs. Each variable or generic attribute is recognized using its location ID and used to bind the data in the OpenGL ES program. These location IDs/indexes can be defined using the <code class="literal">location</code> keyword in the layout qualifier.</p><p>In our first recipe, we will <a id="id237" class="indexterm"/>demonstrate the <a id="id238" class="indexterm"/>use of storage and layout qualifiers:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a vertex shader <code class="literal">LayoutVertex.glsl</code>, as shown here:<div><pre class="programlisting">#version 300 es
layout(location = 0) in vec4 VertexPosition; 
layout(location = 1) in vec4 VertexColor; 
out vec4 Color;
uniform mat4 MODELVIEWPROJECTIONMATRIX;

// Function with two input and one output storage qualifier
void calculatePosition(in mat4 MVP, in vec4 vp, out vec4 position){
   position = MVP * vp;
}

void main() 
{
   vec4 position;
   calculatePosition(MODELVIEWPROJECTIONMATRIX,
                         VertexPosition, position);
   gl_Position  = position;
   Color        = VertexColor;
}</pre></div></li><li class="listitem">Create the fragment shader <code class="literal">LayoutFragment.glsl</code> and modify it, as shown here:<div><pre class="programlisting">#version 300 es
precision mediump float;
in vec4 Color; //in variable receive from shader
float blendFactor = 0.8;
layout(location = 0) out vec4 outColor; 
// Function with input argument and output as return type
vec4 addBlend( in vec4 colorOpaque ) 
{
    return vec4(colorOpaque.x, colorOpaque.y, 
colorOpaque.z, blendFactor);
}

void main() {
    outColor = addBlend( Color );
}</pre></div></li><li class="listitem">Reuse the <em>Efficient rendering with Vertex Buffer Object</em> recipe <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <em>OpenGL ES 3.0 Essentials</em> and define the location index according to your choice in the application program, <code class="literal">Cube.cpp</code>. Make sure that the same index is specified in the shader program:<div><pre class="programlisting">#define VERTEX_LOCATION 0
#define COLOR_LOCATION 1</pre></div></li><li class="listitem">Create <a id="id239" class="indexterm"/>the VBO and IBO in the constructor and enable the following attributes like:<div><pre class="programlisting">glGenBuffers(1, &amp;vId); // Create VBO and bind data
glGenBuffers(1, &amp;iId); // Create IBO and bind data

// Enable the attribute locations
glEnableVertexAttribArray(VERTEX_LOCATION);
glEnableVertexAttribArray(COLOR_LOCATION);</pre></div></li><li class="listitem">Attach the <a id="id240" class="indexterm"/>VBO geometry data to the location ID. This will be used to send data from application to the GPU shader processor. Clearly, with the layout qualifier, the <a id="id241" class="indexterm"/>location query (<code class="literal">glGetAttribLocation</code>) for the vertex attribute can be avoided:<div><pre class="programlisting">void Cube::RenderCube() {
   . . . . . 
   glBindBuffer( GL_ARRAY_BUFFER, vId );
   glVertexAttribPointer(VERTEX_LOCATION, 3, 
   GL_FLOAT, GL_FALSE, 0, (void*)0);
   glVertexAttribPointer(COLOR_LOCATION, 3, GL_FLOAT, 
   GL_FALSE, 0, (void*)size);
   glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iId );
   glDrawElements(GL_TRIANGLES, 36, 
   GL_UNSIGNED_SHORT, (void*)0);
   . . . . . 
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec89"/>How it works...</h2></div></div></div><p>The OpenGL ES program defines two index ID's in <code class="literal">Cube.cpp</code>, <code class="literal">VERTEX_LOCATION</code> and <code class="literal">COLOR_LOCATION</code> for vertex and color data, respectively. These indices will be used to define the attribute location in the shader program. The programmer must ensure that the layout location ID used in the shader program for the attribute must be same as the one used in the OpenGL ES program. This can be achieved by declaring the variable attributes using the layout qualifier. Prefixing the <code class="literal">layout</code> keyword in conjunction with the <code class="literal">location</code> qualifier allows the user-defined locations to attach with attribute variables. If some attribute variables are not specified by user-defined location indices, then the compiler would automatically generate and assign them.</p><p>In the shader program, <code class="literal">VertexPosition</code> and <code class="literal">VertexColor</code> are assigned to the same location indices, <code class="literal">0</code> and <code class="literal">1</code>, respectively, what was defined in the OpenGL ES program. These two variable declarations are of the <code class="literal">vec4</code> type, which is prefixed with the storage qualifier <code class="literal">in</code>. This gives information that these two variables are input to the vertex shader from the OpenGL ES program. The geometry data (vertex and color) is sent to the vertex shader by attaching the data to the location indexes of <code class="literal">VertexPosition</code> and <code class="literal">VertexColor</code> using the <code class="literal">glVertexAttribPointer</code> API in the <code class="literal">RenderCube</code> function. It should be noted that the generic attribute variables must be enabled before they are attached using the <code class="literal">glEnableVertexAttribArray</code> API. This recipe enables them in the <code class="literal">Cube</code> constructor.</p><p>When the <a id="id242" class="indexterm"/>vertex shader receives an input data for <a id="id243" class="indexterm"/>vertices in <code class="literal">VertexPosition</code> and transformation coordinates in the uniform <code class="literal">MODELVIEWPROJECTIONMATRIX</code>, it uses these two variables as an input argument to the <code class="literal">calculatePosition</code> function to calculate the transformed position of the incoming vertex. This calculated position returns to the main function as an output storage qualifier in the variable called position. The <code class="literal">calculatePosition</code> function is introduced in this recipe to demonstrate another possible use of storage qualifiers in the local scope of the shader program.</p><p>The <code class="literal">Color</code> <a id="id244" class="indexterm"/>variable uses the incoming value of <code class="literal">VertexColor</code> and passes it to the next stage in which the fragment shader consumes this value to assign the color to the fragments. In order to send data from the vertex shader to fragment shader, both shaders should use the same attribute variable name. The storage qualifier for the vertex shader must be defined as <code class="literal">out</code> since it is producing an output data for fragment shader. In contrast, the fragment shader must be specified with the <code class="literal">in</code> storage qualifier, as this receives the data from the previous stage. The fragment <a id="id245" class="indexterm"/>shader demonstrates another way of using return values from the shader programming functions.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec90"/>There's more...</h2></div></div></div><p>In the current recipe, you learned how to bind the location indices of the generic attribute variables in OpenGL ES from the shader program using layout qualifiers. As an alternative, the <code class="literal">glBindAttribLocation</code> API can also be used to explicitly bind the location index.</p><p><strong>Syntax</strong>:</p><div><pre class="programlisting">void glBindAttribLocation( GLuint program, GLuint index, const GLchar *name );</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the program object handle</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">index</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the index of the generic vertex attribute or variable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the vertex shader attribute variable that the index is to be bound</p>
</td></tr></tbody></table></div><p>However, it is advisable to encourage layout qualifier as it does not produce the overhead of an API call for attaching the location index to shader program. The use of a layout location qualifier <a id="id246" class="indexterm"/>in the shader programing <a id="id247" class="indexterm"/>avoids the binding of attribute location at runtime in the OpenGL ES program.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec91"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Using the per-vertex attribute to send data to a shader</em> recipe in <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <em>OpenGL ES 3.0 on Android/iOS</em></li><li class="listitem" style="list-style-type: disc">Refer to the <em>Efficient rendering with Vertex Buffer Object</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <em>OpenGL ES 3.0 Essentials</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Grouping uniforms and creating buffer objects</h1></div></div></div><p>The interface <a id="id248" class="indexterm"/>block helps in grouping the uniform variables into one logical bunch. This is very useful in grouping the related variables in the shader programing. The <a id="id249" class="indexterm"/>interface block gives an opportunity to share the uniform data among multiple programs at once. This allows us to set multiple uniform variables in one go, which can be used many times.</p><p>A <strong>Uniform Buffer Object</strong> (<strong>UBO</strong>) is a buffer object for the interface blocks (containing uniform) similar to <a id="id250" class="indexterm"/>VBO, IBO, and so on. It stores the contents of the interface block in the GPU memory for quick data access at runtime. The UBO uses bind points that act as a mediator between the uniform block and uniform buffer. In this recipe, we will create a uniform block and learn how to program uniform buffer objects.</p><p>This recipe demonstrates the concept of interface block. In this recipe, we created an interface block to store transformation matrices. This block contain three uniforms. The interface block is stored as a buffer object using the UBO feature. This allows us to store the interface block as an OpenGL ES buffer object.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec92"/>Getting ready</h2></div></div></div><p>The syntax to create the uniform block is very simple. The following table shows the syntax and use test cases of the implementation:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Syntax</p>
</th><th style="text-align: left" valign="bottom">
<p>Individual uniforms</p>
</th><th style="text-align: left" valign="bottom">
<p>Uniform blocks</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
</p><div><pre class="programlisting">uniform &lt;block name&gt;{
[Type] &lt;variable name 1&gt;;
[Type] &lt;variable name 2&gt;;
. . .
};</pre></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>
</p><div><pre class="programlisting">uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;</pre></div><p>
</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">uniform Transformation{
    mat4 ModelMatrix;
    mat4 ViewMatrix;
    mat4 ProjectionMatrix;
};</pre></div><p>
</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec93"/>How to do it...</h2></div></div></div><p>Here is the <a id="id251" class="indexterm"/>step-by-step description that demonstrates the interface block <a id="id252" class="indexterm"/>and helps in programming the uniform block object:</p><div><ol class="orderedlist arabic"><li class="listitem">Reuse the previous recipe, <em>Managing variable attributes with qualifiers</em>, and create the vertex shader (<code class="literal">UniformBlockVertex.glsl</code>) as shown here:<div><pre class="programlisting">#version 300 es

layout(location = 0) in vec4 VertexPosition;
layout(location = 1) in vec4 VertexColor;

out vec4 Color;
// Uniform Block Declaration
uniform Transformation{
    mat4 ModelMatrix;
    mat4 ViewMatrix;
    mat4 ProjectionMatrix;
};

void main()
{
    gl_Position = ProjectionMatrix * ViewMatrix * 
                  ModelMatrix * VertexPosition;
    Color = VertexColor;
}</pre></div></li><li class="listitem">Create the fragment shader, (<code class="literal">UniformBlockFragment.glsl</code>), as follows:<div><pre class="programlisting">#version 300 es
precision mediump float;
in vec4 Color;
layout(location = 0) out vec4 outColor;
void main() {
  outColor = vec4(Color.x, Color.y, Color.z, 1.0);
}</pre></div></li><li class="listitem">In the <code class="literal">Cube::InitModel()</code> function, compile the given shader(s) and create the program object. Make sure that the program is in use (<code class="literal">glUseProgram</code>) before the UBO creation is attempted. In this recipe, we created the UBO in a separate <a id="id253" class="indexterm"/>class member function <code class="literal">CreateUniformBufferObject</code>. Follow these steps to understand this function:<div><pre class="programlisting">void Cube::CreateUniformBufferObject()
{
    // Get the index of the uniform block
    char blockIdx = glGetUniformBlockIndex
    (program-&gt;ProgramID, "Transformation");

    // Query uniform block size
    GLint blockSize;
    glGetActiveUniformBlockiv(program-&gt;ProgramID, blockIdx,
    GL_UNIFORM_BLOCK_DATA_SIZE, &amp;blockSize);

    // Bind the block index to BindPoint
    GLint bindingPoint = 0;
    glUniformBlockBinding(program-&gt;ProgramID, 
    blockIdx, bindingPoint);

    // Create Uniform Buffer Object(UBO) Handle
    glGenBuffers(1, &amp;UBO);
    glBindBuffer(GL_UNIFORM_BUFFER, UBO);
    glBufferData(GL_UNIFORM_BUFFER, blockSize, 
    0, GL_DYNAMIC_DRAW);

    // Bind the UBO handle to BindPoint
    glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, UBO);
}</pre></div></li><li class="listitem">Query the index of the uniform block that is defined in the vertex shader using the <code class="literal">glGetUniformBlockIndex</code> API into <code class="literal">blockIdx</code>. This API accepts the program ID and the name of the uniform block whose block index needs to be queried.</li><li class="listitem">Use <code class="literal">blockIdx</code> and query the block data size in the <code class="literal">blockSize</code> variable with the help of the <code class="literal">glGetActiveUniformBlockiv</code> API. Bind the uniform block index to binding point <code class="literal">bindingPoint</code> with <code class="literal">glUniformBlockBinding</code>.</li><li class="listitem">Create the object handle for uniform buffer block and bind it to the symbolic constant <code class="literal">GL_UNIFORM_BUFFER</code>, and allocate the required memory specified by <code class="literal">blockSize</code>. Finally, bind the UBO with binding point by using <code class="literal">glBindBufferBase</code>.</li><li class="listitem">In the <a id="id254" class="indexterm"/>render function, make use of buffer object memory mapping to modify the content of UBO:<div><pre class="programlisting">void Cube::RenderCube()
{
   // Bind the UBO
   glBindBuffer( GL_UNIFORM_BUFFER, UBO );
   // Map the buffer block for MVP matrix
   glm::mat4* matrixBuf = (glm::mat4*)glMapBufferRange
   (GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4*)*(3),
GL_MAP_WRITE_BIT);
// Assign updated matrix
   matrixBuf[0] = *TransformObj-&gt;TransformGetModelMatrix();
   matrixBuf[1] = *TransformObj-&gt;TransformGetViewMatrix();
            matrixBuf[2]=*TransformObj-&gt;TransformGetProjectionMatrix();
// UnMap the buffer block
   glUnmapBuffer ( GL_UNIFORM_BUFFER );
   
// Draw Geometry using VBO..
. . . .    
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec94"/>How it works...</h2></div></div></div><p>The uniform block declaration in the vertex shader groups the model, view, and projection matrices into <a id="id255" class="indexterm"/>one logical block called <strong>transformation</strong>. When the shader program gets compiled, it assigns a unique ID/index to the block called block index. The user-defined location indexes are not permitted in uniform blocks. The following five steps are required to create a UBO:</p><div><ol class="orderedlist arabic"><li class="listitem">Use the <code class="literal">glGetUniformBlockIndex</code> API to query the <code class="literal">Transformation</code> ID in the <code class="literal">blockIdx</code> variable.</li><li class="listitem">In order to allocate the memory for the UBO, use the <code class="literal">glGetActiveUniformBlockiv</code> API to query the size of the <code class="literal">Transformation</code> uniform block in the <code class="literal">blockSize</code> variable.</li><li class="listitem">Bind <code class="literal">blockIdx</code> (block index) to <code class="literal">bindingPoint</code> (binding point) using the <code class="literal">glUniformBlockBinding</code> API. UBO uses the concept of binding points to create a connection between the block index and the buffer object. Both must be bound to the binding point.</li><li class="listitem">Unlike the buffer objects (VBO and IBO) are created in OpenGL ES, similarly create the uniform buffer object. The <code class="literal">glBindBuffer</code> and <code class="literal">glBufferData</code> APIs must use the <code class="literal">GL_UNIFORM_BUFFER</code> symbolic constant to ensure UBO buffer to the OpenGL ES state machine.</li><li class="listitem">As mentioned in step 3, we need to attach the UBO with the respective binding point that is already attached to the block index. Use the <code class="literal">glBindBufferBase</code> API to bind UBO and <code class="literal">bindingPoint</code>.</li></ol></div><p>The UBO can be used to set several values with the single UBO binding call. <code class="literal">RenderCube()</code> binds the UBO to set the uniform values for model, view, and projection matrices. The buffer object allows modifications to buffer elements using buffer-mapping techniques.</p><p>The <a id="id256" class="indexterm"/>OpenGL ES 3.0 release has introduced a new feature for range buffer mapping. This feature allows us to modify a subset of the buffer object. Unlike the old buffer-mapping technique, where the complete buffer needs to be mapped onto the CPU side, this technique appears to be much more efficient.</p><p>Use the <code class="literal">glMapBufferRange</code> API to map the UBO on the client side to modify the model, view, and projection matrices with updated values. Make sure that you unmap the buffer object after modification is completed by sing the <code class="literal">glUnmapBufferAPI</code>. Use the existing code for VBO rendering.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec95"/>There's more...</h2></div></div></div><p>The following figure describes the concept of binding point in UBOs. Each uniform block is identified with a unique index within the shader program. This index is attached to a binding point. Similarly, the UBO is also attached to the binding point and provides a mechanism to share the same data among different programs.</p><div><img src="img/5527OT_03_01.jpg" alt="There's more..."/></div><p>In the <a id="id257" class="indexterm"/>preceding figure, <strong>P1_2</strong> and <strong>P2_1</strong> are pointing to the same binding point. Therefore, both share the same data.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec96"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Efficient rendering with Vertex Buffer Object</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <em>OpenGL ES 3.0 Essentials</em></li><li class="listitem" style="list-style-type: disc"><em>Reading and writing buffer objects with mapping</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Managing VBO with Vertex Array Objects</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <em>OpenGL ES 3.0 Essentials</em>, we introduced two features to load the vertex attributes <a id="id258" class="indexterm"/>using vertex arrays and <strong>Vertex Buffer Object</strong> (<strong>VBO</strong>). Both these features allow us to load the vertex attribute in the OpenGL ES rendering pipeline. The VBO are considered efficient compared to vertex arrays because they store the vertex data in the GPU memory. This reduces the cost of data copy between CPU and GPU. In this <a id="id259" class="indexterm"/>recipe, we will understand a new feature: <strong>Vertex Array Objects</strong> (<strong>VAO</strong>) of OpenGL ES 3.0. This feature is more efficient compared to VBO.</p><p>When a vertex attribute is loaded, it requires some additional calls to set the attribute states in the OpenGL ES rendering pipeline. For example, prior to rendering, the buffer object is bound using the <code class="literal">glBindBuffer</code> API, the data array is assigned using the <code class="literal">glVertexAttributePointer</code> API, and the vertex attribute is enabled using the <code class="literal">glEnableVertexAttribArray</code> API. The VAO stores all such states into a single object in order to remove the overhead caused by these calls.</p><p>This allows the application to quickly switch among available vertex array buffers and set their respective states. This makes the rendering efficient and also helps keep the programming code compact and clean.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec97"/>How to do it...</h2></div></div></div><p>This recipe <a id="id260" class="indexterm"/>demonstrates a simple grid geometry rendering using VAO in conjunction with VBO. There is no change required in shaders for programming VAO. Perhaps previous recipes from this chapter can be used.</p><p>The steps to create VAO are very straightforward:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">Grid</code> class and define the geometry in the <code class="literal">CreateGrid</code> function. This function takes the dimension and division of the grid. Inside this function, create a VBO, IBO, and VAO, as shown in the following code:<div><pre class="programlisting">void Grid::CreateGrid(GLfloat XDim, GLfloat ZDim, int XDiv, int ZDiv)
{
   // Define geometry using Dimension and divisions
   // Create VBO and IBO for grid geometry
   // Create Vertex Array Object
   // Enable VBO and set attribute parameters
   // Unbind VAO, VBO and IBO 
}</pre></div></li><li class="listitem">Create a VBO, generate the buffer, and fill in the buffer object with the vertex information:<div><pre class="programlisting"> // Create VBO ID
 glGenBuffers(1, &amp;vIdGrid);
 glBindBuffer( GL_ARRAY_BUFFER, vIdGrid);
 glBufferData( GL_ARRAY_BUFFER,size,0, GL_STATIC_DRAW);
 glBufferSubData( GL_ARRAY_BUFFER, 0, size,gridVertex);</pre></div></li><li class="listitem">Similarly, create an IBO and fill in the buffer with the element indexes:<div><pre class="programlisting"> // Create IBO for Grid
 unsigned short indexSize=sizeof(unsigned short)*indexNum;
 glGenBuffers(1, &amp;iIdGrid);
 glBindBuffer( GL_ARRAY_BUFFER, iIdGrid );
 glBufferData(GL_ARRAY_BUFFER,indexSize,0,GL_STATIC_DRAW);
 glBufferSubData(GL_ARRAY_BUFFER,0,indexSize,gridIndices);</pre></div></li><li class="listitem">Generate the VAO ID using the <code class="literal">glGenVertexArrays</code> API. Bind this generated <code class="literal">Vertex_VAO_Id</code> using <code class="literal">glBindVertexArray</code>. The code written after the creation of the VAO is recorded in the state vector of the VAO object. Therefore, use the VBO and bind the data to the required vertex attribute for rendering purposes:<div><pre class="programlisting">      // Create Vertex Array Object
      glGenVertexArrays(1, &amp;Vertex_VAO_Id);
      glBindVertexArray(Vertex_VAO_Id);    
      // Create VBO and set attribute parameters
      glBindBuffer( GL_ARRAY_BUFFER, vIdGrid );
      glEnableVertexAttribArray(VERTEX_LOCATION);
      glVertexAttribPointer(VERTEX_LOCATION,3,GL_FLOAT,
      GL_FALSE,0, (void*)0);
      glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iIdGrid );</pre></div></li><li class="listitem">Unbind <a id="id261" class="indexterm"/>the VAO, VBO, and IBO, once the vertex states and attributes are set properly:<div><pre class="programlisting">glBindVertexArray(0);
glBindBuffer( GL_ARRAY_BUFFER, 0 );
glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );</pre></div></li><li class="listitem">Render the geometry with VAO using the <code class="literal">Render()</code> function, as shown here:<div><pre class="programlisting">   // void Grid::Render() 
   // Use shader program and apply transformation    
   . . . . .
   glBindVertexArray(Vertex_VAO_Id); // Bind VAO
   glDrawElements(GL_LINES,((XDivision+1)+(ZDivision+1))*2,
   GL_UNSIGNED_SHORT, (void*)0); }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec98"/>How it works...</h2></div></div></div><p>The VAO stores the vertex array client states and the buffer binding in a state vector. When the VAO ID is bound, the subsequent operation calls, such as calls to bind with VBO, enable client states, and attach data buffer to generic attributes, are stored in the state vector of the VAO. This way, when the VAO is bound, the state vector provides the full state of current settings, configurations, and client states of the vertex array. Instead of making several calls, this one binding call will be sufficient to enable vertex array configurations and states.</p><div><img src="img/5527OT_03_02.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec99"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer <a id="id262" class="indexterm"/>to the <em>Rendering primitives with vertex arrays</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <em>OpenGL ES 3.0 Essentials</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Reading and writing buffer objects with mapping</h1></div></div></div><p>The <a id="id263" class="indexterm"/>previous recipe introduced a new feature to <a id="id264" class="indexterm"/>access vertex arrays using VAO. This object <a id="id265" class="indexterm"/>minimizes the overhead of switch <a id="id266" class="indexterm"/>among vertex arrays and their respective states. This recipe will go one step ahead in order to teach you how to update the data of the buffer objects using buffer mapping. The VBO can be updated using <code class="literal">glBufferData</code> and <code class="literal">glBufferSubData</code> as demonstrated in many recipes. These APIs can be used to upload or download data to the device. In contrast, the buffer mapping is an efficient way to update the buffer objects that are residing in the GPU memory.</p><p>This recipe will demonstrate buffer object range mapping. In this recipe, we will reuse the cube geometry and render each vertex of the cube as a point primitive, instead of a triangle primitive. Each vertex of the cube is programmed to change its colors randomly using the buffer object range mapping feature after a fixed interval of time.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec100"/>Getting ready</h2></div></div></div><p>Before we start with a step-by-step description, here is the overview of buffer object range mapping:</p><div><ol class="orderedlist arabic"><li class="listitem">Bind the buffer that needs to be mapped using <code class="literal">glBindBuffer</code>.</li><li class="listitem">Get the pointer to the memory location from driver memory space using the <code class="literal">glMapBufferRange</code> API.</li><li class="listitem">Use this pointer to perform any read/write operations on the acquired memory.</li><li class="listitem">Invalidate the acquire pointer using the <code class="literal">glUnmapBuffer</code> API. This API allows us to send updated memory contents to the GPU memory space.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec101"/>How to do it...</h2></div></div></div><p>This recipe does not require any special change in the vertex and fragment shaders. For this recipe, we used a new GL shading language API called <code class="literal">gl_PointSize</code>. This API is used to specify the <a id="id267" class="indexterm"/>size of the <code class="literal">GL_POINTS</code> primitives. Make <a id="id268" class="indexterm"/>use of the <em>Efficient rendering with </em><a id="id269" class="indexterm"/>
<em>Vertex Buffer Object</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <em>OpenGL ES 3.0 Essentials</em>, and proceed with the following steps to program range <a id="id270" class="indexterm"/>mapping onto a buffer object:</p><div><ol class="orderedlist arabic"><li class="listitem">First, create the VAO of the cube geometry using the previous VAO recipe.</li><li class="listitem">Program the map range buffer inside the <code class="literal">Render()</code> function as shown here. The following steps will describe this function:<div><pre class="programlisting">void Cube::RenderCube(){
     if (clock() - last &gt;= CLOCKS_PER_SEC * 0.1){
        // Bind the Buffer Object for vertex Array.
        glBindBuffer( GL_ARRAY_BUFFER, vId );
        // Get the mapped memory pointer.
        GLfloat* colorBuf = (GLfloat* )glMapBufferRange(
 GL_ARRAY_BUFFER, size, size, GL_MAP_WRITE_BIT);
        for(int i=0; i&lt;size/sizeof(GLfloat); i++)
{  colorBuf[i] = float(rand()%255)/255; }
        last = clock();
        // Invalidate the mapped memory.
        glUnmapBuffer ( GL_ARRAY_BUFFER );
    }
    // Perform Transformation.
   . . . . . . .    
    // Bind the VAO and Render the cube 
    // with Point primitive.
    glBindVertexArray(Vertex_VAO_Id);
    glDrawElements(GL_POINTS,36,GL_UNSIGNED_SHORT,(void*)0);
}</pre></div></li><li class="listitem">First, bind the VBO in order to map the color buffer data using the <code class="literal">glBindBuffer</code> API. Map the pointer to the color data memory. The color data in the VBO starts from the size index and is also size bytes long:<div><pre class="programlisting">colorBuf = (GLfloat*)glMapBufferRange (GL_ARRAY_BUFFER,
 size, size, GL_MAP_WRITE_BIT);</pre></div><p>On successful mapping of the buffer object, it returns a valid pointer to the memory mapped location. If an error occurs, the API would return the <code class="literal">NULL</code> pointer.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Syntax</strong>:<div><pre class="programlisting">void *glMapBufferRange(GLenum target, GLintptr offset,
                GLsizeiptr length, GLbitfield access);</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">target</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the type of buffer, which is expected to bind for memory mapping, for example, <code class="literal">GL_MAP_READ_BIT</code> and <code class="literal">GL_MAP_WRITE_BIT</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">offset</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the starting offset within the buffer object that is the subject of interest for mapping</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">length</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the range of the buffer that needs to be mapped</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">access</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the symbol constant flag combination that indicates the desired access to the buffer range</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Copy the new <a id="id271" class="indexterm"/>color values in this mapped <a id="id272" class="indexterm"/>memory buffer:<div><pre class="programlisting">// size/sizeof(GLfloat) gives total number of elements 
// that needs to be updated with new color, the formula 
// is- total size of buffer / unit item size 
for(int i=0; i&lt;size/sizeof(GLfloat); i++){
    colorBuf[i] = float(rand()%255)/255;
}</pre></div></li><li class="listitem">Unmap the <a id="id273" class="indexterm"/>memory mapped <a id="id274" class="indexterm"/>buffer to indicate the OpenGL ES rendering pipeline to transfer this data to the GPU memory space:<div><pre class="programlisting">glUnmapBuffer ( GL_ARRAY_BUFFER );</pre></div><p>The <code class="literal">UnmapBuffer</code> API returns the Boolean <code class="literal">TRUE</code> if it successfully unmaps the current mapped buffer. If some error occurs, it returns <code class="literal">FALSE</code>.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Syntax</strong>:<div><pre class="programlisting">GLboolean glUnmapBuffer(GLenum target);</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">target</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the type of the buffer that needs to unbound</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Bind the VAO and render the geometry using the <code class="literal">GL_POINTS</code> primitive. The <code class="literal">GL_POINTS</code> primitive renders small dots on the screen. In order to increase the dimension of these dots, the <code class="literal">gl_PointSize</code> API can be used in the vertex shader, as shown in the next step:<div><pre class="programlisting">glBindVertexArray(Vertex_VAO_Id);
glDrawElements(GL_POINTS, 36, GL_UNSIGNED_SHORT, (void*)0);</pre></div></li><li class="listitem">Create <a id="id275" class="indexterm"/><code class="literal">BufferMappingVertex.glsl</code> as follows:<div><pre class="programlisting">layout(location = 0) in vec4 VertexPosition;
layout(location = 1) in vec4 VertexColor;
uniform mat4 MODELVIEWPROJECTIONMATRIX;
out vec4 Color;
void main(){
  gl_Position = MODELVIEWPROJECTIONMATRIX * VertexPosition;
  gl_PointSize= 80.0; // Size of GL_POINTS primitive
  Color       = VertexColor;
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec102"/>How it works...</h2></div></div></div><p>In the VBO, <code class="literal">glBufferData</code> and <code class="literal">glBufferSubData</code> use the user data and copy it into a hooked/pinned <a id="id276" class="indexterm"/>location in the device memory location. This hooked location can be accessed by the GPU. The user data is copied to this memory <a id="id277" class="indexterm"/>location like <code class="literal">memcpy</code> internally. As the <a id="id278" class="indexterm"/>data copying process gets completed, the driver starts <strong>direct memory allocation</strong> (<strong>DMA</strong>) without intervening the CPU cycles.</p><p>The target destination <a id="id279" class="indexterm"/>of the DMA depends upon the usage <a id="id280" class="indexterm"/>hints from the (<code class="literal">GL_STREAM_DRAW</code>, <code class="literal">GL_STREAM_READ</code>, <code class="literal">GL_STREAM_COPY</code>, <code class="literal">GL_STATIC_DRAW</code>, <code class="literal">GL_STATIC_READ</code>, <code class="literal">GL_STATIC_COPY</code>, <code class="literal">GL_DYNAMIC_DRAW</code>, <code class="literal">GL_DYNAMIC_READ</code>, or <code class="literal">GL_DYNAMIC_COPY</code>) APIs.</p><p>In contrast, the <code class="literal">glMapBufferRange</code> method is considered much more efficient. The API first hooks a memory <a id="id281" class="indexterm"/>location directly into the driver memory <a id="id282" class="indexterm"/>space. This pinned memory location is available through a pointer to the application. This pointer can be directly used to update the location for the uploading or downloading of data for read/write purposes. Once the operation on the mapped location for read/write is completed, the pointer can be made invalid by calling <code class="literal">glUnMapBuffer</code>. This API call hints the OpenGL ES pipeline to push the updated data to the GPU memory using DMA calls.</p><div><img src="img/5527OT_03_03.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec103"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Swizzling</em> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <em>Supplementary Information on OpenGL ES 3.0</em></li><li class="listitem" style="list-style-type: disc">Refer to the <em>Transform feedback particle system with sync objects and fences</em> recipe in <a class="link" href="ch12.html" title="Chapter 12. Real-time Shadows and Particle System">Chapter 12</a>, <em>Real-time Shadows and Particle System</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Render multiple objects with geometry instancing</h1></div></div></div><p>The <a id="id283" class="indexterm"/>geometry instancing allows us to <a id="id284" class="indexterm"/>render multiple instances of the same object in a single rendering API call. These multiple instances differ in their generic attributes, such as transformation matrices, color, scale, and so on. This feature is very useful to implement particle systems, crowd simulation, rendering of jungle trees, and so on. Compared to the traditional way of rendering multiple objects that use multiple rendering calls, this technique is very efficient as it requires a single API call. This reduces the overhead of CPU processing in sending multiple rendering calls to the OpenGL ES rendering engine.</p><p>This recipe demonstrates the rendering of 1000 cubes using geometric instancing. For this, we will use 1000 matrices in a VBO. Each matrix contains a transformation to place a cube in the 3D space. The information of the matrices are updated using the range map buffer feature as discussed in the previous recipe. This allows us to pass new transformation data on the fly at run time. The transformed data contains new rotation and translated positions.</p><div><img src="img/5527OT_03_04.jpg" alt="Render multiple objects with geometry instancing"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec104"/>How to do it...</h2></div></div></div><p>So far, in our recipes, the model-view-projection matrix is always treated as uniform in the vertex shader. For this recipe, we will make use of the VAO and declare the model-view-projection matrix as a generic attribute instead of a uniform. Since the matrix is an attribute, a new VBO is required. This VBO is stored in the <code class="literal">matrixId</code> variable. <code class="literal">RenderCube()</code> uses the map buffer to update transformation matrix data.</p><p>Here are the <a id="id285" class="indexterm"/>steps to implement <a id="id286" class="indexterm"/>geometric instancing:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the vertex shader and add the following code. There is no change required for the fragment shader. It can be reused:<div><pre class="programlisting">#version 300 es
layout(location = 0) in vec4 VertexPosition;
layout(location = 1) in vec4 VertexColor;
layout(location = 2) in mat4 MODELVIEWPROJECTIONMATRIX;
out vec4 Color;
void main() {
  gl_Position = MODELVIEWPROJECTIONMATRIX * VertexPosition;
  Color = VertexColor;
}</pre></div></li><li class="listitem">In <code class="literal">Cube::InitModel()</code>, use the existing code and add a new VBO for matrix transformation. Get the ID of the generated buffer object in <code class="literal">matrixId</code>:<div><pre class="programlisting">// Create VBO for transformation matrix
glGenBuffers(1, &amp;matrixId);
glBindBuffer (GL_ARRAY_BUFFER, matrixId);</pre></div></li><li class="listitem">Allocate the memory to the VBO for matrix transformation. The dimension variable is initialized with 10. It gives the number of cubes along an axis. Therefore, along <em>x</em>, <em>y</em>, and <em>z</em> axes, <em>10 x 10 x1 0 = 1000 cubes</em>. The total size of the buffer would be size of <em>(GLfloat) * 16 (16 float elements in mat4) * 1000 (cubes)</em>:<div><pre class="programlisting">glm::mat4 transformMatrix[dimension][dimension][dimension];
glBufferData(GL_ARRAY_BUFFER, sizeof(transformMatrix) , 0, GL_DYNAMIC_DRAW);</pre></div><p>The <code class="literal">glBufferData</code> uses <code class="literal">GL_DYNAMIC_DRAW</code>. This symbolic constant specifies that the buffer is going to contain some data that is dynamic in nature. In other words, the data will require updates in the buffer. This symbolic constant helps the graphics driver to manage buffer memory in the best possible way to achieve high-performance graphics rendering.</p></li><li class="listitem">In the <a id="id287" class="indexterm"/>same function, after creating the VAO (<code class="literal">Vertex_VAO_Id</code>), define the generic attribute <a id="id288" class="indexterm"/>states and configuration of the transformation matrix buffer object. This helps in saving the vertex array client states and the buffer binding in the VAO (<code class="literal">Vertex_VAO_Id</code>). The <code class="literal">glVertexAttribDivisor</code> calculates the instance ID from the total number of instances given. For more information, refer to the <em>There's more…</em> section in this recipe:<div><pre class="programlisting">// Create VBO for transformation matrix and set attributes
glBindBuffer( GL_ARRAY_BUFFER, matrixId );
glEnableVertexAttribArray(MATRIX1_LOCATION);
glEnableVertexAttribArray(MATRIX2_LOCATION);
glEnableVertexAttribArray(MATRIX3_LOCATION);
glEnableVertexAttribArray(MATRIX4_LOCATION);
    
glVertexAttribPointer(MATRIX1_LOCATION,4,GL_FLOAT,GL_FALSE,
  sizeof(glm::mat4),(void*)(sizeof(float)*0));
glVertexAttribPointer(MATRIX2_LOCATION,4,GL_FLOAT,GL_FALSE,
  sizeof(glm::mat4),(void*)(sizeof(float)*4));
glVertexAttribPointer(MATRIX3_LOCATION,4,GL_FLOAT,GL_FALSE,
  sizeof(glm::mat4), (void*)(sizeof(float)*8));
glVertexAttribPointer(MATRIX4_LOCATION,4,GL_FLOAT,GL_FALSE,
  sizeof(glm::mat4), (void*)(sizeof(float)*12));
    
glVertexAttribDivisor(MATRIX1_LOCATION, 1);
glVertexAttribDivisor(MATRIX2_LOCATION, 1);
glVertexAttribDivisor(MATRIX3_LOCATION, 1);
glVertexAttribDivisor(MATRIX4_LOCATION, 1);</pre></div></li><li class="listitem">In <code class="literal">Cube::RenderCube()</code>, use range buffer mapping to map the transformation buffer on the client-side memory. Update the data in the memory <a id="id289" class="indexterm"/>and unmap it. Use VAO and render the cube of cubes using the geometric instance API called <code class="literal">glDrawElementsInstanced</code>. This API's last argument specifies the <a id="id290" class="indexterm"/>number of instances the given primitive will be rendered:<div><pre class="programlisting">void Cube::RenderCube()
{
   glBindBuffer( GL_ARRAY_BUFFER, matrixId );
   glm::mat4* matrixBuf = (glm::mat4*)glMapBufferRange
   (GL_ARRAY_BUFFER, 0, sizeof(glm::mat4*)*(dimension    *dimension*dimension), GL_MAP_WRITE_BIT);
   static float l = 0;
   TransformObj-&gt;TransformRotate(l++, 1, 1, 1);
   TransformObj-&gt;TransformTranslate
   (-distance*dimension/4,-distance*dimension/4, -distance*dimension/4);
   glm::mat4 projectionMatrix = *TransformObj-&gt;
   TransformGetProjectionMatrix();
   glm::mat4 modelMatrix = *TransformObj-&gt;
   TransformGetModelMatrix();
   glm::mat4 viewMatrix = *TransformObj-&gt;
   TransformGetViewMatrix();
   int instance= 0;
   for ( int i = 0; i &lt; dimension; i++ ){
   for ( int j = 0; j &lt; dimension; j++ ){
   for ( int k = 0; k &lt; dimension; k++ ){
   matrixBuf[instance++] = projectionMatrix *
   viewMatrix * glm::translate(modelMatrix, glm::vec3( i*distance , j*distance, k*distance)) * glm::rotate( modelMatrix, l, glm::vec3(1.0, 0.0, 0.0));
                                        }
                                        }
                                        }
        
   glUnmapBuffer ( GL_ARRAY_BUFFER );
   
   glBindVertexArray(Vertex_VAO_Id);
   glDrawElementsInstanced(GL_TRIANGLES,36,
   GL_UNSIGNED_SHORT, (void*)0, dimension*dimension*dimension);
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec105"/>How it works...</h2></div></div></div><p>The application first compiles the shader programs. This makes us aware of all the generic attribute locations used in the shader program. Create a VBO of 1000 matrix elements. Each element represents a transformation matrix. This matrix element is updated with new values of the transformation of every frame in the <code class="literal">RenderCube</code> function.</p><p>The generic <a id="id291" class="indexterm"/>attributes are first enabled using <a id="id292" class="indexterm"/>
<code class="literal">glEnableVertexAttribArray</code>. The data array is attached to the generic location with <code class="literal">glVertexAttribPointer</code>. The following figure shows how the OpenGL ES program API is attached to the layout location of the vertex shader to send data:</p><div><img src="img/5527OT_03_05.jpg" alt="How it works..."/></div><p>Note that the generic attributes are sent as a group of four. Therefore, for a 4 x 4 matrix, we will need four attribute locations. The start location of the attribute should be mentioned into the vertex shader using a layout qualifier:</p><div><pre class="programlisting">layout(location = 2) in mat4 MODELVIEWPROJECTIONMATRIX;</pre></div><p>The following figure <a id="id293" class="indexterm"/>shows how the attribute locations are managed by the compiler:</p><div><img src="img/5527OT_03_06.jpg" alt="How it works..."/></div><p>Similar to the other locations such as <code class="literal">VERTEX_LOCATION (0)</code> and <code class="literal">COLOR_LOCATION (1)</code>, the transformation matrix locations (<code class="literal">2</code>, <code class="literal">3</code>, <code class="literal">4</code>, <code class="literal">5</code>) also need to be enabled and attached to the array data.</p><p>The <code class="literal">glVertexAttribDivisor</code> API is responsible for controlling the rate at which OpenGL ES <a id="id294" class="indexterm"/>advances the data from an instanced array. The first parameter of this API specifies the generic attribute that needs to be treated as an instanced array. This tells the OpenGL ES pipeline to use this attribute per instance rendering. For example, in this example, the generic attributes, <code class="literal">2</code>, <code class="literal">3</code>, <code class="literal">4</code>, <code class="literal">5</code>, are instanced attributes. Therefore, OpenGL ES consumes the data from the transformation matrix array as an instance ID. We will see how this instance ID is calculated in a moment.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>The default value of the divisor is <code class="literal">0</code> when it is not specified in the program explicitly. If the divisor is <code class="literal">0</code>, the attribute index is advanced once per-vertex. If the divisor is not <code class="literal">0</code>, the attribute advances once per divisor instance of the set(s) of the vertices being rendered.</p></div></div><p><strong>Syntax</strong>:</p><div><pre class="programlisting">void glVertexAttribDivisor(GLuint index, GLuint divisor);</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">index</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies generic attribute layout location</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">divisor</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the number of instances that will pass between updates of the generic attribute at the index slot</p>
</td></tr></tbody></table></div><p>The rendering of the <a id="id295" class="indexterm"/>geometric instancing requires special instanced-based drawing APIs from OpenGL ES 3.0, as mentioned here for array- and index-based geometric data.</p><p><strong>Syntax</strong>:</p><div><pre class="programlisting">void glDrawElementsInstanced(GLenum mode, GLsizei count, 
GLenum type, const void * indices, GLsizei primcount);</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">mode</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the type of the primitive that needs to be rendered</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">count</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the number of indices considered in the drawing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">type</code></p>
</td><td style="text-align: left" valign="top">
<p>This is used by <code class="literal">glDrawElementsInstanced</code>, this specifies the data type of the indices stored</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">indices</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the arrays containing the order of the indices</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">primcount</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the number of copies to be rendered</p>
</td></tr></tbody></table></div><p>In the present recipe, the <code class="literal">glDrawElementsInstanced</code> API is used to render multiple instances of the same object. This API works in conjunction with another API called <code class="literal">glVertexAttribDivisor</code>. In order to update the VBO matrix elements, buffer mapping is used, which is an efficient way to update the buffer elements. If the geometric data is not index based <a id="id296" class="indexterm"/>but array based, then <code class="literal">glDrawArraysInstanced</code> can be used. This API accepts almost the same parameters. Refer <a id="id297" class="indexterm"/>to the online <em>OpenGL ES 3.0 Reference Manual</em> for more information.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec106"/>There's more...</h2></div></div></div><p>The second attribute of <code class="literal">glVertexAttribDivisor</code> specifies the divisor. This divisor helps in calculating the instance ID from the total number of instances. The following figure shows a simple example of the working logic of this API. In this figure, we assumed that there are total five instances to be rendered, and the figure contains five matrices. When the divisor is <code class="literal">5</code>, it produces <code class="literal">5</code> instance ID of the (<code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>, <code class="literal">4</code>). This instance ID will be used as an index to the transformation matrix array. Similarly, when the divisor is <code class="literal">2</code>, it generates three instances (<code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">2</code>). It generates two instances (<code class="literal">0</code>, <code class="literal">1</code>) when the divisor is <code class="literal">3</code>.</p><div><img src="img/5527OT_03_07.jpg" alt="There's more..."/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec107"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Managing VBO with Vertex Array Objects</em></li><li class="listitem" style="list-style-type: disc">Refer to the <em>Efficient rendering with ETC2 compressed texture </em>and <em>Implementing Skybox with seamless cube mapping</em> recipes in <a class="link" href="ch07.html" title="Chapter 7. Textures and Mapping Techniques">Chapter 7</a>, <em>Texture and Mapping Techniques</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Rendering multiple primitives with primitive restart</h1></div></div></div><p>OpenGL ES 3.0 introduced a new feature called primitive restart, where multiple disconnected <a id="id298" class="indexterm"/>geometry primitives can <a id="id299" class="indexterm"/>be rendered using a single API. This feature uses a special marker in the vertex data or the index data to concatenate different geometries of the same drawing type into a single batch. The restart primitive feature executes on the GPU. Therefore, it eliminates the communication overhead per drawing call. This provides high-performance graphics by avoiding multiple drawing calls from CPU to GPU.</p><p>The recipe shows us how to use the primitive restart technique to render a cube using two sets of geometries, which are separated by a special marker.</p><div><img src="img/5527OT_03_08.jpg" alt="Rendering multiple primitives with primitive restart"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec108"/>Getting ready</h2></div></div></div><p>The marker used by the restart primitive feature to separate geometries is the highest value of the <a id="id300" class="indexterm"/>data type with which the element index or vertex data array is specified. For instance, an index value of <code class="literal">GLushort</code> and <a id="id301" class="indexterm"/>
<code class="literal">GLint</code> should be <em>0 x FFFF</em> (<em>65535</em>) and <em>0 x FFFFFFFF</em> (4<em>294967295</em>), respectively.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec109"/>How to do it...</h2></div></div></div><p>To render multiple primitives, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Define the cube vertices and indices, as shown here:<div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Cube vertices</p>
</th><th style="text-align: left" valign="bottom">
<p>Indices</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
</p><div><pre class="programlisting">GLfloat  cubeVerts[][3] = {
  -1, -1, 1 , // V0
  -1, 1, 1 ,  // V1
  1, 1, 1 ,   // V2
  1, -1, 1 ,  // V3
  -1, -1, -1 ,// V4
  -1, 1, -1 , // V5
  1, 1, -1 ,  // V6
  1, -1, -1   // V7
  };</pre></div><p>
</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">// 36 indices
GLushort cubeIndices[] = {
    0,3,1, 3,2,1,
    7,4,6, 4,5,6,
    4,0,5, 0,1,5,
    0xFFFF, 3,7,2,
    7,6,2, 1,2,5,
    2,6,5, 3,0,7,
    0,4,7
};</pre></div><p>
</p>
</td></tr></tbody></table></div></li><li class="listitem">In order to render the cube with primitive restart, it must first of all be enabled, using <code class="literal">glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX)</code>. Specify the total size <a id="id302" class="indexterm"/>of the indice and include the number of markers that are used in the geometry indices:<div><pre class="programlisting">//Bind the VBO
glBindBuffer( GL_ARRAY_BUFFER, vId );
glVertexAttribPointer(VERTEX_LOCATION, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
glVertexAttribPointer(COLOR_LOCATION, 3, GL_FLOAT, GL_FALSE, 0, (void*)size);

glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);
glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iId );
// Plus 36 + 1 because it has 1 Primitive Restart Index.
glDrawElements(GL_TRIANGLES, 36+1, GL_UNSIGNED_SHORT, (void*)0);
glDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec110"/>There's more...</h2></div></div></div><p>The other way in which the disconnected geometry primitives can be rendered is called triangle degeneration. Triangle degeneration is the capability of the GPU to recognize disconnected <a id="id303" class="indexterm"/>primitives in the triangle strip or triangle fan index information on the basis of some special pattern.</p><p>For example, the following figure shows the special index pattern data that can be used to render degenerated triangles using the <code class="literal">glDrawElement</code> or <code class="literal">glDrawElementsInstanced</code> API.</p><div><img src="img/5527OT_03_09.jpg" alt="There's more..."/></div><p>The degeneration between the two geometries is achieved by repeating the last index of the previous geometry and the first index of the next primitive. This rule of degeneration is only applicable when the previous geometry contains an odd number of triangles. Behind the curtains, the triangle would be drawn in the following order: (0, 1, 2), (2, 1, 3), (2, 3, 3), (3, 3, 6), (3, 6, 6), (6, 6, 7), (6, 7, 8), (8, 7, 10). The repeated indices form an area equivalent to zero, allowing the GPU to discard the triangles. These zero area triangles are mentioned using the bold font.</p><p>The second type of degeneration case is where the first geometry contains an odd number of triangles. For <a id="id304" class="indexterm"/>instance, the following <a id="id305" class="indexterm"/>image demonstrates the first geometry with three (odd) triangles. As per this case rule, the last index of the first geometry is repeated twice, followed by the first index of the second geometry.</p><div><img src="img/5527OT_03_10.jpg" alt="There's more..."/></div><p>For instance, the indices specified for degenerate triangles (0, 1, 2, 3, 4, 4, 4, 8, 8, 9, 10, 11) generate the <a id="id306" class="indexterm"/>following triangles: (0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 4), (4, 4, 4), (4, 4, 6), (4, 6, 6), (6, 6, 9), (6, 7, 8), (8, 7, 9), (9, 8, 10).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec111"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Using the per-vertex attribute to send data to a shader</em> recipe in <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <em>OpenGL ES 3.0 on Android/iOS</em></li><li class="listitem" style="list-style-type: disc">Refer to the <em>Efficient rendering with Vertex Buffer Object</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <em>OpenGL ES 3.0 Essentials</em></li></ul></div></div></div></body></html>