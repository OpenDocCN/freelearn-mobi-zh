<html><head></head><body>
		<div id="_idContainer165">
			<h1 id="_idParaDest-141" class="chapter number"><a id="_idTextAnchor499"/>9</h1>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor500"/>Building User Interfaces Using Jetpack Compose</h1>
			<p>In this section, you will learn how to use Jetpack Compose to create user interfaces using Kotlin code, how Compose revolutionized the way we built user interfaces, and how we can translate existing applications to Jetpack Compose. By the end of the chapter, you will be familiar with the most common UI elements in Compose and how to handle <span class="No-Break">user actions.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>What is <span class="No-Break">Jetpack Compose?</span></li>
				<li>Handling <span class="No-Break">user actions</span></li>
				<li>Theming <span class="No-Break">in Compose</span></li>
				<li>Adding Compose to <span class="No-Break">existing projects</span></li>
			</ul>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor501"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/kb5FW"><span class="No-Break">https://packt.link/kb5FW</span></a></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor502"/>What is Jetpack Compose?</h1>
			<p>In past chapters, you learned how to set data into the Android View hierarchy and learned how to use<a id="_idIndexMarker736"/> different types of views for different purposes. That approach to user interface<a id="_idIndexMarker737"/> building is referred to as the <span class="No-Break"><strong class="bold">imperative approach</strong></span><span class="No-Break">.</span></p>
			<p>In the imperative approach, when we want to change the state of the user interface, we will need to manually change each user interface element until we reach the <span class="No-Break">desired outcome.</span></p>
			<p>Let’s assume that because of a user action, we want our <strong class="source inline">TextView</strong> to change the text and text color. This means that we would need to invoke <strong class="source inline">setText</strong> and <strong class="source inline">setTextColor</strong> to achieve our <span class="No-Break">desired effect.</span></p>
			<p>As an alternative to<a id="_idIndexMarker738"/> the imperative approach, we have the <strong class="bold">declarative approach</strong>, in which we would need to describe the final state that we want our user interface to reach, and internally, the required invocations would <span class="No-Break">be performed.</span></p>
			<p>This means that our <strong class="source inline">TextView</strong> would instead have the text and text color as attributes, and we could define<a id="_idIndexMarker739"/> different objects holding the states we want. In Jetpack Compose, this would look like the <span class="No-Break">following example:</span></p>
			<pre class="source code">
@Composable
fun MyTextDisplay(myState: MyState) {
    Text(text = myState.text, color = myState.color)
}
data class MyState(
    val text: String,
    val color: Color
)</pre>
			<p>In the preceding example, we define a <strong class="source inline">@Composable</strong> function that will display a <strong class="source inline">Text</strong> element. The values for <strong class="source inline">text</strong> and <strong class="source inline">color</strong> would be held in a separate data class that will represent the state of <span class="No-Break">the text.</span></p>
			<p>This mechanism allows Jetpack Compose to redraw the user interface for any change that occurs in <strong class="source inline">MyState</strong>. This process is called <strong class="bold">recomposition</strong>, and the way it works is that Compose<a id="_idIndexMarker740"/> will invoke the <strong class="source inline">@Composable</strong> functions that had <span class="No-Break">a change.</span></p>
			<p>If we want to create a new screen in Compose, we have the choice of <strong class="source inline">Row</strong> or <strong class="source inline">Column</strong> functions to arrange elements. For vertical arrangement, we can use <strong class="source inline">Column</strong>, and for horizontal alignment, we <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">Row</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@Composable
fun MyScreen(){
    Column {
        Text(text = "My Static Text")
        TextField(value = "My Text Field", onValueChange = {
        })
        Button(onClick = { }) { }
        Icon(painter = painterResource(R.drawable.icon),
            contentDescription = stringResource(id =
            R.string.icon_content_description))
    }
}</pre>
			<p>In the preceding example, using <strong class="source inline">Column</strong>, we show different user interface elements above <span class="No-Break">each other:</span></p>
			<ul>
				<li><strong class="source inline">Text</strong> will show a <a id="_idIndexMarker741"/>simple label with the <strong class="source inline">My Static Text</strong> label <span class="No-Break">as </span><span class="No-Break"><strong class="source inline">text</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source inline">TextField</strong> will show an input field that’s pre-filled with the <strong class="source inline">My Text Field</strong> text through the <strong class="source inline">value</strong> parameter. The <strong class="source inline">onValueChange</strong> lambda will pick up any text that the <span class="No-Break">user inserts.</span></li>
				<li><strong class="source inline">Button</strong> will show a button, and through the <strong class="source inline">onClick</strong> lambda, we can pick up the click events <span class="No-Break">on it.</span></li>
				<li><strong class="source inline">Icon</strong> will display a particular icon from the <strong class="source inline">drawable</strong> or <strong class="source inline">mipmap</strong> folders and will have a content description set from the <span class="No-Break">string resources.</span></li>
			</ul>
			<p>If we want to display lists of items, we can use the following approach when the number of items is known and small enough to fit on the screen of <span class="No-Break">the device:</span></p>
			<pre class="source code">
@Composable
fun MyList(items: List&lt;String&gt;) {
    Column {
        items.forEach { item -&gt; Text(text = item) }
    }
}</pre>
			<p>In the preceding example, we iterate over each item in the list and show a <strong class="source inline">Text</strong> for each item. If the number of items is unknown and large enough to require scrolling, then we would run into <a id="_idIndexMarker742"/>performance issues because the recomposition would go over both visible and not visible items. For this scenario, we could use the <span class="No-Break">following approach:</span></p>
			<pre class="source code">
@Composable
fun MyList(items: List&lt;String&gt;) {
    LazyColumn {
        item { Text(text = "Header") }
        items(items){ item-&gt; Text(text = item) }
        item { Text(text = "Footer") }
    }
}</pre>
			<p>Here, we are using a <strong class="source inline">LazyColumn</strong> function and wrapping our collection with the <strong class="source inline">items</strong> function. We are also able to add static items as a header and footer of the list through the <strong class="source inline">item</strong> function. Like <strong class="source inline">Column</strong>, we can use <strong class="source inline">LazyRow</strong> to display a list of items with a <span class="No-Break">horizontal scroll.</span></p>
			<p>If we want to add spacings between the UI elements, then <strong class="source inline">Modifiers</strong> <span class="No-Break">become useful:</span></p>
			<pre class="source code">
@Composable
fun MyScreen(){
    Column {
        Text(text = "My Static Text")
        TextField(value = "My Text Field", onValueChange =
        { }
}</pre>
			<p>In the preceding example, we’ve added <strong class="source inline">16.dp</strong> padding to the entire column of items in all directions. If we wanted<a id="_idIndexMarker743"/> different paddings in different directions, we would’ve had something like <span class="No-Break">the following:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column(
        modifier = Modifier.padding(
            top = 5.dp, bottom = 5.dp,
            start = 10.dp, end = 10.dp)
    ) {
    }
}</pre>
			<p>In the preceding example, we’ve set <strong class="source inline">5.dp</strong> vertical padding and <strong class="source inline">10.dp</strong> horizontal padding. Because the values are repeated, we can instead use the <span class="No-Break">following approach:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column(
        modifier = Modifier.padding(
            vertical = 5.dp,
            horizontal = 10.dp)
    ) {
    }
}</pre>
			<p>Here, we’ve used the <strong class="source inline">vertical</strong> and <strong class="source inline">horizontal</strong> parameters to set the vertical and horizontal paddings. If we want to make the row clickable, then we can use the <span class="No-Break">following modifier:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column(
        modifier = Modifier.padding(
            vertical = 5.dp,
            horizontal = 10.dp
        ).clickable { }
    ) { }
}</pre>
			<p>In the preceding example, we’ve used the <strong class="source inline">clickable</strong> method from <strong class="source inline">Modifier</strong>. This will register a<a id="_idIndexMarker744"/> click listener on the <span class="No-Break">entire </span><span class="No-Break"><strong class="source inline">Column</strong></span><span class="No-Break">.</span></p>
			<p>When it comes to the relationship between Activities and Fragments and screens built in Compose, we have the following extensions <span class="No-Break">for Compose:</span></p>
			<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent { MyScreen() }
    }
}</pre>
			<p>In the preceding example, we have the <strong class="source inline">setContent</strong> extension function defined for <strong class="source inline">ComponentActivity</strong>, which will set a <strong class="source inline">@Composable</strong> function as the content for an <strong class="source inline">Activity</strong>. The same is true for Fragments; however, when starting a new project, the current recommendation is to have a single Activity and make all your additional screens separate <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">Composable</strong></span><span class="No-Break"> functions.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">In Android Studio, we have the possibility of having previews of our <strong class="source inline">@Composable</strong> functions with the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">Preview</strong></span><span class="No-Break"> annotation.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor503"/>Exercise 9.01 – first Compose screen</h2>
			<p>Create an Android application that has one screen defined using <strong class="source inline">@Composable</strong> functions. The screen should have the<a id="_idIndexMarker745"/> <span class="No-Break">following elements:</span></p>
			<ul>
				<li><strong class="source inline">Text</strong>, which will say <strong class="source inline">"Enter </strong><span class="No-Break"><strong class="source inline">a number"</strong></span></li>
				<li><strong class="source inline">TextField</strong>, which will only <span class="No-Break">accept integers</span></li>
				<li><strong class="source inline">Button</strong>, which has the text <strong class="source inline">"</strong><span class="No-Break"><strong class="source inline">Click Me"</strong></span></li>
				<li><strong class="source inline">LazyColumn</strong>, which will display a list of 100 items with the following format for each row: <strong class="source inline">"</strong><span class="No-Break"><strong class="source inline">Item c"</strong></span></li>
			</ul>
			<p>Perform the following steps to complete <span class="No-Break">the exercise:</span></p>
			<ol>
				<li>Create a new Android Studio project and select <strong class="bold">Empty </strong><span class="No-Break"><strong class="bold">Compose Activity</strong></span><span class="No-Break">.</span></li>
				<li>Add the following to <strong class="source inline">strings.xml</strong> in the <span class="No-Break"><strong class="source inline">res/values</strong></span><span class="No-Break"> folder:</span><pre class="source code">
    &lt;string name="enter_number"&gt;Enter a
        number&lt;/string&gt;
    &lt;string name="click_me"&gt;Click Me&lt;/string&gt;
    &lt;string name="item_format"&gt;Item %s&lt;/string&gt;</pre></li>
				<li>Define the user interface of <span class="No-Break">the exercise:</span><pre class="source code">
@Composable
fun MyScreen(
    items: List&lt;String&gt;
) {
    LazyColumn {
        item {
            Column(modifier = Modifier.padding(16.dp))
            {
                Text(text = stringResource(id =
                R.string.enter_number))
                TextField(
                    value = "",
                    keyboardOptions =
                    KeyboardOptions(keyboardType =
                    KeyboardType.Number),
                    onValueChange = {
                    })
                Button(onClick = { }) {
                    Text(text = stringResource(id =
                    R.string.click_me))
                }
            }
        }
        items(items) { item -&gt;
            Column(modifier =
            Modifier.padding(vertical = 4.dp)) {
                Text(text = item)
            }
        }
    }
}</pre></li>
			</ol>
			<p>We have chosen to place everything inside the <strong class="source inline">LazyColumn</strong> block. This will make the entire content<a id="_idIndexMarker746"/> scrollable, including <strong class="source inline">Text</strong>, <strong class="source inline">TextField</strong>, and <strong class="source inline">Button</strong>, and not just the list <span class="No-Break">of items.</span></p>
			<p>To make the keyboard only accept numeric input, we have used the <strong class="source inline">keyboardOptions</strong> parameter of the <strong class="source inline">TextField</strong> function. For <strong class="source inline">Button</strong>, to add text to it, we needed to use the content parameter of the function and place a new <strong class="source inline">Text</strong> inside <span class="No-Break">the lambda.</span></p>
			<ol>
				<li value="4">Finally, modify the <strong class="source inline">MainActivity</strong> code to use the function we’ve <span class="No-Break">just defined:</span><pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val items = (1..100).toList().map {
                stringResource(id =
                R.string.item_format, formatArgs =
                arrayOf("$it"))
            }
            MyScreen(items)
        }
    }
}</pre></li>
			</ol>
			<p>Here, we generate a new list of items that will say <strong class="source inline">"Item [count]"</strong> and invoke the <strong class="source inline">@Composable</strong> <span class="No-Break">function, </span><span class="No-Break"><strong class="source inline">MyScreen</strong></span><span class="No-Break">.</span></p>
			<p>If we run the preceding example, we will see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B19411_09_01.jpg" alt="Figure 9.1 – Output of Exercise 9.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Output of Exercise 9.01</p>
			<p>We can see in the preceding figure that the screen was built according to the exercise specifications. One thing to note is the fact that we aren’t allowed to input any text in the input field. This is because we have set the value of <strong class="source inline">TextField</strong> to an empty string. We will look at how we can<a id="_idIndexMarker747"/> properly handle this aspect in further sections of <span class="No-Break">the book.</span></p>
			<p>In this section, we have looked at how we can use Jetpack Compose to build user interfaces in a simple way without the involvement of other languages and syntaxes such as Kotlin. Next, we will continue the exploration of Compose and how we can handle user actions and <span class="No-Break">manage states.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor504"/>Handling user actions</h1>
			<p>In the previous section, we learned how<a id="_idIndexMarker748"/> to build user interfaces using Jetpack Compose. In the exercise, we were unable to collect the data that the user sets in <strong class="source inline">TextField</strong>. In this section, we will learn how to handle the user input as well as the state of the <span class="No-Break">user interface.</span></p>
			<p>Let’s assume we have the <span class="No-Break">following example:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column { TextField(value = "", onValueChange = {}) }
}</pre>
			<p>In this example, we define a <strong class="source inline">TextField</strong> that is empty and has no handling for the change of the value. As we’ve seen, this won’t let us introduce any new input from the keyboard because it will always set the text to an <span class="No-Break">empty string.</span></p>
			<p>For us to be able to introduce a <a id="_idIndexMarker749"/>new text, we will need to create a mutable variable to store the text inside and for it to survive recomposition. In Jetpack Compose, we can use the <strong class="source inline">@Composable</strong> function called <strong class="source inline">remember</strong> to define a <strong class="source inline">MutableState</strong> that will hold <span class="No-Break">our text:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    var text by remember { mutableStateOf("") }
    Column { TextField(value = text, onValueChange = {}) }
}</pre>
			<p>In the preceding example, we define a mutable variable called <strong class="source inline">text</strong>, which we then set in <strong class="source inline">TextField</strong>. The <strong class="source inline">text</strong> variable is initialized through the <strong class="source inline">remember</strong> function, which will hold a <strong class="source inline">MutableState</strong> that has the initial value set to an empty string. This still isn’t complete; we will now need to connect the state with the change in value <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">TextField</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    var text by remember { mutableStateOf("") }
    Column {
        TextField(value = text, onValueChange = { <strong class="bold">text = it</strong> })
    }
}</pre>
			<p>Here, we modify the <strong class="source inline">onValueChange</strong> lambda to change the <strong class="source inline">text</strong> state with the latest text that the <span class="No-Break">user inserted.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">We can use the <strong class="source inline">rememberSaveable</strong> function to instead retain the value of objects across configuration changes such as <span class="No-Break">Activity recreation.</span></p>
			<p>When dealing with states, we<a id="_idIndexMarker750"/> tend to turn <strong class="source inline">@Composable</strong> functions from being stateless (doesn’t manage a state) to stateful (manages one or more states). As a guideline, we should try to keep our functions as stateless as possible through a pattern called <strong class="bold">state hoisting</strong>. This<a id="_idIndexMarker751"/> involves moving the state management to the caller of our <strong class="source inline">@Composable</strong> function. This would turn the preceding example into <span class="No-Break">the following:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    var text by rememberSaveable { mutableStateOf("") }
    MyScreenContent(text = text, onTextChange = { text = it })
}
@Composable
fun MyScreenContent(text: String, onTextChange: (String) -&gt; Unit) {
    Column {
        TextField(value = text, onValueChange =
            onTextChange)
    }
}</pre>
			<p>In the preceding example, we’ve split our functions in two. The <strong class="source inline">MyScreen</strong> function will manage the state of the text and invoke the <strong class="source inline">MyScreenContent</strong> function, which is now stateless. This approach introduces multiple benefits such as the <em class="italic">reusability</em> of our stateless functions, <em class="italic">decoupled</em> state management, and <em class="italic">a single source of truth</em> for <span class="No-Break">our state.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">When you use the Jetpack Compose State and <strong class="source inline">MutableState</strong> objects, you might need to manually import the following two methods for getting and setting a state: <strong class="source inline">androidx.compose.runtime.getValue</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">androidx.compose.runtime.setValue</strong></span><span class="No-Break">.</span></p>
			<p>When dealing with states in<a id="_idIndexMarker752"/> Jetpack Compose, when a change occurs in a state, then the recomposition process is triggered. This might cause problems when we want to show one-off events such as <strong class="source inline">Snackbar</strong> and <strong class="source inline">Toast</strong>. To achieve this, we can <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">LaunchedEffect</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@Composable
fun MyScreenContent() {
    val context = LocalContext.current
    LaunchedEffect(anObjectToChange) {
        Toast.makeText(context, "Toast text",
        Toast.LENGTH_SHORT).show()
    }
}</pre>
			<p>The preceding example will show a <strong class="source inline">Toast</strong> message every time <strong class="source inline">anObjectToChange</strong> takes on a different value. If we replace <strong class="source inline">anObjectToChange</strong> with <strong class="source inline">Unit</strong>, then the <strong class="source inline">LaunchedEffect</strong> block will be executed <span class="No-Break">only once.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor505"/>Exercise 9.02 – handling user inputs</h2>
			<p>Modify <em class="italic">Exercise 9.01 – first Compose screen</em> such that when the user introduces a number in <strong class="source inline">TextField</strong> and clicks the button, then a list of items as big as the number introduced will be generated and the list below the button will be populated with them. The text will be the<a id="_idIndexMarker753"/> same for each item <span class="No-Break">as before.</span></p>
			<p>To represent the state of the user interface, a data class will be created that will hold the number of items, with <strong class="source inline">0</strong> as a default, and the list of items, which will be empty <span class="No-Break">by default.</span></p>
			<p>Perform the following steps to complete <span class="No-Break">the exercise:</span></p>
			<ol>
				<li>Create the <strong class="source inline">MyScreenState</strong> data class, which will hold the state of the <span class="No-Break">user interface:</span><pre class="source code">
data class MyScreenState(
    val itemCount: String = "",
    val items: List&lt;String&gt; = emptyList()
)</pre></li>
				<li>Create the <strong class="source inline">@Composable</strong> method called <strong class="source inline">MyScreenContent</strong>, which will have <strong class="source inline">MyScreenState</strong> as a parameter and render <span class="No-Break">the state:</span><pre class="source code">
@Composable
fun MyScreenContent(
    myScreenState: MyScreenState,
    onItemCountChange: (String) -&gt; Unit,
    onButtonClick: @Composable () -&gt; Unit
) {
    LazyColumn {
        item {
            Column(modifier = Modifier.padding(16.dp))
            {
                Text(text = stringResource(id =
                R.string.enter_number))
                TextField(
                    value = myScreenState.itemCount,
                    keyboardOptions =
                    KeyboardOptions(keyboardType =
                    KeyboardType.Number),
                    onValueChange =
                    onItemCountChange
                )
                Button(onClick = onButtonClick) {
                    Text(text = stringResource(id =
                    R.string.click_me))
                }
            }
        }
        items(myScreenState.items) { item -&gt;
            Column(modifier =
            Modifier.padding(vertical = 4.dp)) {
                Text(text = item)
            }
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding example, we set <strong class="source inline">itemCount</strong> from <strong class="source inline">myScreenState</strong> in our <strong class="source inline">TextField</strong> and <strong class="source inline">items</strong> from <strong class="source inline">myScreenState</strong> as items in the list. We’ve also added our text change <a id="_idIndexMarker754"/>listener and button listener as parameters to the function, making <span class="No-Break">it stateless.</span></p>
			<ol>
				<li value="3">Modify the <strong class="source inline">MyScreen</strong> function such that it will call <strong class="source inline">MyScreenContent</strong> and handle the listener for the text change and for the <span class="No-Break">button click:</span><pre class="source code">
@Composable
fun MyScreen() {
    var state by remember {
        mutableStateOf(MyScreenState())
    }
    val context = LocalContext.current
    MyScreenContent(state, {
        state = state.copy(itemCount = it)
    }, {
        state = state.copy(items =
        (1..state.itemCount.toInt()).toList().map {
            context.getString(R.string.item_format,
            "$it")
        })
    })
}</pre></li>
			</ol>
			<p>Here, we are creating a new <strong class="source inline">MutableState</strong> that will hold <strong class="source inline">MyScreenState</strong> with its defaults. We will then invoke <strong class="source inline">MyScreenContent</strong> in which we pass the state. When the text changes, we set the state to be the copy of the existing state with the new text, and when the button is clicked, we generate a new list of items up until the current <strong class="source inline">itemCount</strong> and update <span class="No-Break">the state.</span></p>
			<ol>
				<li value="4">Update the <strong class="source inline">MainActivity</strong> class to<a id="_idIndexMarker755"/> invoke the <strong class="source inline">MyScreen</strong> function without <span class="No-Break">any parameters:</span><pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyScreen()
        }
    }
}</pre></li>
			</ol>
			<p>If we run the exercise and insert a number, then we should see the <span class="No-Break">following screen:</span></p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B19411_09_02.jpg" alt="Figure 9.2 – Output of Exercise 9.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Output of Exercise 9.02</p>
			<p>When the app is first launched, we should see the <strong class="source inline">TextField</strong> empty and no elements in the list below the button. When a number is set, then the state is changed to reflect the new text, and when the button is clicked, then the list of items is displayed with the size being that of the <span class="No-Break">inserted number.</span></p>
			<p>In this section, we have looked at<a id="_idIndexMarker756"/> how we can handle user input, keep it in a state, and manage that state across recomposition. In the section that follows, we will look at how we can further decorate our user <span class="No-Break">interface elements.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor506"/>Theming in Compose</h1>
			<p>In the previous section, we learned how to<a id="_idIndexMarker757"/> handle user actions and how to manage the state of a particular screen. But how do we keep our application’s user interface elements consistent across the entire application? In this section, we will look at how we can create reusable elements that are linked to the <span class="No-Break">application’s theme.</span></p>
			<p>You may have noticed, when you carried out the previous exercises, that Android Studio created some files in a <strong class="source inline">ui.theme</strong> package. This is because Jetpack Compose is built upon the Material Design library and will assign a theme to your application that is built on Material Design. The approach taken is <span class="No-Break">the following:</span></p>
			<ol>
				<li>In the <strong class="source inline">Color.kt</strong> file, all the <a id="_idIndexMarker758"/>colors of the application <span class="No-Break">are declared:</span><pre class="source code">
val Purple200 = Color(0xFFBB86FC)
val Purple500 = Color(0xFF6200EE)
val Purple700 = Color(0xFF3700B3)
val Teal200 = Color(0xFF03DAC5)</pre></li>
			</ol>
			<p>In the preceding example, we have the color <span class="No-Break">hexadecimal names.</span></p>
			<ol>
				<li value="2">In <strong class="source inline">Shape.kt</strong>, the following code <span class="No-Break">is generated:</span><pre class="source code">
val Shapes = Shapes(
    small = RoundedCornerShape(4.dp),
    medium = RoundedCornerShape(4.dp),
    large = RoundedCornerShape(0.dp)
)</pre></li>
			</ol>
			<p>This will indicate what the size of the icons you use in the application <span class="No-Break">should be.</span></p>
			<ol>
				<li value="3">In <strong class="source inline">Type.kt</strong>, the following code <span class="No-Break">is generated:</span><pre class="source code">
val Typography = Typography(
    body1 = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp
    )
)</pre></li>
			</ol>
			<p>This will represent how the text in your application is rendered. The <strong class="source inline">Typography</strong> class holds configurations for how your headings, subtitles, paragraphs, buttons, and captions text <span class="No-Break">should be.</span></p>
			<ol>
				<li value="4">In the <strong class="source inline">Theme.kt</strong> file, we<a id="_idIndexMarker759"/> have two color <span class="No-Break">palettes defined:</span><pre class="source code">
private val DarkColorPalette = darkColors(
    primary = Purple200,
    primaryVariant = Purple700,
    secondary = Teal200
)
private val LightColorPalette = lightColors(
    primary = Purple500,
    primaryVariant = Purple700,
    secondary = Teal200
)</pre></li>
			</ol>
			<p>Here, there’s a light and dark color palette defined and the <strong class="source inline">primary</strong>, <strong class="source inline">primaryVariant</strong>, and <strong class="source inline">secondary</strong> colors are set. The rest of the colors in the <strong class="source inline">lightColors</strong> and <strong class="source inline">darkColors</strong> functions will remain with their <span class="No-Break">default values.</span></p>
			<ol>
				<li value="5">In the same file, the application’s theme <span class="No-Break">is generated:</span><pre class="source code">
@Composable
fun MyApplicationTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -&gt; Unit
) {
    val colors = if (darkTheme) {
        DarkColorPalette
    } else {
        LightColorPalette
    }
    MaterialTheme(
        colors = colors,
        typography = Typography,
        shapes = Shapes,
        content = content
    )
}</pre></li>
			</ol>
			<p>Here, a check will be made to see whether the device has light or dark mode enabled and use the appropriate set of colors for each mode. It will also set the typography you configured<a id="_idIndexMarker760"/> and how the shapes in your application should be. Just because it is set in the theme, that doesn’t mean that our user interface elements will automatically <span class="No-Break">inherit it.</span></p>
			<ol>
				<li value="6">When the <strong class="source inline">MainActivity</strong> class is generated, it will have the <span class="No-Break">following structure:</span><pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyApplicationTheme {
                Surface(color =
                MaterialTheme.colors.background) { }
            }
        }
    }
}</pre></li>
			</ol>
			<p>When <strong class="source inline">setContent</strong> is called, then your application’s theme will be called, and the <strong class="source inline">Surface</strong> function will set your <span class="No-Break">application’s background.</span></p>
			<p>We can now use the preceding setup as a starting point to define a theme for our application and start to create<a id="_idIndexMarker761"/> reusable user interface components. Let’s assume we want all the paragraphs in the application to use the same typography and have the same color; in this case, we will use <strong class="source inline">MaterialTheme.typography.body1</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">MaterialTheme.colors.onBackground</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@Composable
fun ParagraphText(text: String) {
    Text(
        text = text,
        style = MaterialTheme.typography.body1,
        color = MaterialTheme.colors.onBackground
    )
}</pre>
			<p>In the preceding example, we’ve defined the <strong class="source inline">ParagraphText</strong> function, which will set the style and color of the text from <strong class="source inline">MaterialTheme</strong>. We might now have a problem if we want the same style and a different text color, where we need to duplicate the style attribute for each. Another solution is to create two functions – one for the style and the other on top of it for <span class="No-Break">the color:</span></p>
			<pre class="source code">
@Composable
fun OnBackgroundParagraphText(text: String) {
    ParagraphText(text = text, color =
    MaterialTheme.colors.onBackground)
}
@Composable
fun ParagraphText(text: String, color: Color) {
    Text(
        text = text,
        style = MaterialTheme.typography.body1,
        color = color
    )
}</pre>
			<p>In the preceding example, we’ve <a id="_idIndexMarker762"/>moved the color to be a parameter in the <strong class="source inline">ParagraphText</strong> function and then created a new function called <strong class="source inline">OnBackgroundParagraphText</strong>, which allows us to set <strong class="source inline">MaterialTheme.colors.onBackground</strong> to the <strong class="source inline">Text</strong> defined in <strong class="source inline">ParagraphText</strong>. If we want to use our new function, then we can do <span class="No-Break">the following:</span></p>
			<pre class="source code">
@Composable
fun MyScreen() {
    OnBackgroundParagraphText(text = "My text")
}</pre>
			<p>This is a simple function call, just like using the <span class="No-Break"><strong class="source inline">Text</strong></span><span class="No-Break"> function.</span></p>
			<p>Now, let’s assume we are using this text across our entire application and the application goes through a redesign where instead of using <strong class="source inline">MaterialTheme.typography.body1</strong>, we need to use <strong class="source inline">MaterialTheme.typography.body2</strong>, and the text color needs to be red. In this case, we would then modify the <strong class="source inline">ParagraphText</strong> function <span class="No-Break">as follows:</span></p>
			<pre class="source code">
@Composable
fun ParagraphText(text: String, color: Color) {
    Text(
        text = text,
        style = MaterialTheme.typography.body2,
        color = color
    )
}</pre>
			<p>Here, we have changed the style of the <strong class="source inline">Text</strong> function to use <strong class="source inline">MaterialTheme.typography.body2</strong>. To change the color, we could modify <strong class="source inline">OnBackgroundParagraphText</strong>, but the color currently used is recommended to be used on top of the current background, so we <a id="_idIndexMarker763"/>could also change the value of <strong class="source inline">MaterialTheme.colors.onBackground</strong>. For this, we could go into <strong class="source inline">Theme.kt</strong> and do <span class="No-Break">the following:</span></p>
			<pre class="source code">
private val DarkColorPalette = darkColors(
    primary = Purple200,
    primaryVariant = Purple700,
    secondary = Teal200,
    onBackground = Color.Red
)
private val LightColorPalette = lightColors(
    primary = Purple500,
    primaryVariant = Purple700,
    secondary = Teal200,
    onBackground = Color.Red
)</pre>
			<p>Here, we changed the value of <strong class="source inline">onBackground</strong> to red, which will impact all the user interface elements that reference <strong class="source inline">onBackground</strong>. We can now see how we can easily apply this across all the user interface elements in the application without touching the code where those elements <span class="No-Break">are used.</span></p>
			<p>If we want to have multiple<a id="_idIndexMarker764"/> screens in our application, we can connect Compose with the <strong class="source inline">navigation</strong> library, which is <span class="No-Break">available here:</span></p>
			<pre class="source code">
implementation "androidx.navigation:navigation-compose:2.5.3</pre>
			<p>Let’s now assume we have two screens defined in <span class="No-Break">Jetpack Compose:</span></p>
			<pre class="source code">
@Composable
fun Screen1(onButtonClick: () -&gt; Unit) {
    Button(onClick = onButtonClick) {
        Text(text = "Click Me")
    }
}
@Composable
fun Screen2(input1: String, input2: String) {
    Text(text = "My inputs are $input1 and $input2")
}</pre>
			<p><strong class="source inline">Screen1</strong> will display one button and <strong class="source inline">Screen2</strong> has two inputs that will be displayed. We now want to connect the screens so that when the button is clicked on <strong class="source inline">Screen1</strong>, <strong class="source inline">Screen2</strong> opens with two hardcoded inputs passed. This would look like <span class="No-Break">the following:</span></p>
			<pre class="source code">
@Composable
fun MyApp(navController: NavHostController) {
    NavHost(navController = navController,
    startDestination = "screen1") {
        composable("screen1") {
            Screen1 { navController.navigate
            ("screen2/Input1?input2=Input2") }
        }
        composable(
            "screen2/{input1}?input2={input2}",
            arguments = listOf(navArgument("input1") {
            type = NavType.StringType },
            navArgument("input2") { type =
            NavType.StringType }
            )
        ) {
            Screen2(
                input1 = it.arguments?
                .getString("input1").orEmpty(),
                input2 = it.arguments?
                .getString("input2").orEmpty()
            )
        }
    }
}</pre>
			<p>We have defined a new <strong class="source inline">@Composable</strong> function called <strong class="source inline">MyApp</strong>, which uses <strong class="source inline">NavHost</strong> to keep all the screens in the application. <strong class="source inline">NavHost</strong> will open <strong class="source inline">Screen1</strong> as a default through the <strong class="source inline">screen1</strong> URL. In the <strong class="source inline">onButtonClick</strong> lambda from <strong class="source inline">Screen1</strong>, we navigate to <strong class="source inline">Screen2</strong> and we<a id="_idIndexMarker765"/> pass the <strong class="source inline">input1</strong> and <span class="No-Break"><strong class="source inline">input2</strong></span><span class="No-Break"> strings.</span></p>
			<p>This is done through the <strong class="source inline">screen2/{input1}?input2={input2}</strong> URL. This is also how we will pass arguments between the two screens, through either the path parameter (<strong class="source inline">input1</strong>) or the argument (<strong class="source inline">input2</strong>). For each input, we will need to specify that we will be expecting a string as <span class="No-Break">a type.</span></p>
			<p><strong class="source inline">Screen2</strong> will then be opened, and the input extracted through the <strong class="source inline">it</strong> variable, which is a <strong class="source inline">NavBackStackEntry</strong> type. We can call this function from the <strong class="source inline">setContent</strong> method of <span class="No-Break">the Activity:</span></p>
			<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyApplicationTheme {
                Surface(color =
                MaterialTheme.colors.background) {
                    val navController =
                        rememberNavController()
                    MyApp(navController)
                }
            }
        }
    }
}</pre>
			<p>Here, we hoist the state of <strong class="source inline">NavHostController</strong> and then<a id="_idIndexMarker766"/> call the <span class="No-Break"><strong class="source inline">MyApp</strong></span><span class="No-Break"> function.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor507"/>Exercise 9.03 – applying themes</h2>
			<p>Modify <em class="italic">Exercise 9.02 – handling user inputs</em> such<a id="_idIndexMarker767"/> that <strong class="source inline">MyScreen</strong>, <strong class="source inline">MyScreenContent</strong>, and <strong class="source inline">MyScreenState</strong> are split into two screens, with <strong class="source inline">ItemCountScreen</strong>, <strong class="source inline">ItemCountScreenContent</strong>, and <strong class="source inline">ItemCountScreenState</strong> on one side, which will hold <strong class="source inline">Text</strong>, <strong class="source inline">TextField</strong>, and <strong class="source inline">Button</strong>, and <strong class="source inline">ItemScreen</strong>, <strong class="source inline">ItemScreenContent</strong>, and <strong class="source inline">ItemScreenState</strong> on the other, which will hold the <span class="No-Break">item list.</span></p>
			<p>The two screens will be saved in <strong class="source inline">ItemCountScreen.kt</strong> and <strong class="source inline">ItemScreen.kt</strong> files. <strong class="source inline">ItemCountScreen</strong> will be shown first, and when the button is clicked, then <strong class="source inline">ItemScreen</strong> is shown with the number of items set in the <span class="No-Break">previous screen.</span></p>
			<p>New functions will also be created to represent <strong class="source inline">Text</strong> used across the application: one for the <strong class="source inline">"Enter a number"</strong> text, which will be <strong class="source inline">MaterialTheme.typography.h5</strong>; the <strong class="source inline">"Click Me"</strong> text will be <strong class="source inline">MaterialTheme.typography.button</strong>; and <strong class="source inline">"Item [count]"</strong> will <span class="No-Break">be </span><span class="No-Break"><strong class="source inline">MaterialTheme.typography.body1</strong></span><span class="No-Break">.</span></p>
			<p>The colors will be set to <strong class="source inline">MaterialTheme.colors.onBackground</strong> for the text, and <strong class="source inline">Color.red</strong> for the <span class="No-Break">button text.</span></p>
			<p>Perform the following steps to<a id="_idIndexMarker768"/> complete <span class="No-Break">the exercise:</span></p>
			<ol>
				<li>In the <strong class="source inline">app/build.gradle</strong> file, add the <strong class="source inline">navigation</strong> <span class="No-Break">library dependency:</span><pre class="source code">
implementation "androidx.navigation:navigation-compose:2.5.3"</pre></li>
				<li>In the <strong class="source inline">ui.theme</strong> package, create a Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">Elements</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source inline">Elements.kt</strong> file, add the functions for the title text on the <span class="No-Break">first screen:</span><pre class="source code">
@Composable
fun OnBackgroundTitleText(text: String) {
    TitleText(text = text, color =
        MaterialTheme.colors.onBackground)
}
@Composable
fun TitleText(text: String, color: Color) {
    Text(text = text, style =
        MaterialTheme.typography.h5, color = color)
}</pre></li>
				<li>In the same file, add the functions for the <strong class="source inline">"Item [</strong><span class="No-Break"><strong class="source inline">count]"</strong></span><span class="No-Break"> text:</span><pre class="source code">
@Composable
fun OnBackgroundItemText(text: String) {
    ItemText(text = text, color =
        MaterialTheme.colors.onBackground)
}
@Composable
fun ItemText(text: String, color: Color) {
    Text(text = text, style =
        MaterialTheme.typography.body1, color = color)
}</pre></li>
				<li>In the same file, add the <a id="_idIndexMarker769"/>functions for the <span class="No-Break">button text:</span><pre class="source code">
@Composable
fun PrimaryTextButton(text: String, onClick: () -&gt;
Unit) {
    TextButton(text = text, textColor = Color.Red,
    onClick = onClick)
}
@Composable
fun TextButton(text: String, textColor: Color,
onClick: () -&gt; Unit) {
    Button(
        onClick = onClick, colors = ButtonDefaults
        .buttonColors(contentColor = textColor)
    ) {
        Text(text = text, style =
        MaterialTheme.typography.button)
    }
}</pre></li>
			</ol>
			<p>In this example, as the button sets the color for the content in a different way, we had to use <strong class="source inline">contentColor</strong> from the <span class="No-Break"><strong class="source inline">ButtonColors</strong></span><span class="No-Break"> class.</span></p>
			<ol>
				<li value="6">Create a new Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">ItemCountScreen</strong></span><span class="No-Break">.</span></li>
				<li>In this file, create a new <a id="_idIndexMarker770"/>class <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">ItemCountScreenState</strong></span><span class="No-Break">:</span><pre class="source code">
data class ItemCountScreenState(
    val itemCount: String = ""
)</pre></li>
				<li>In the same file, create a new function called <strong class="source inline">ItemCountScreenContent</strong>, which will hold the newly created <strong class="source inline">OnBackgroundTitleText</strong> and <span class="No-Break"><strong class="source inline">PrimaryTextButton</strong></span><span class="No-Break"> functions:</span><pre class="source code">
@Composable
fun ItemCountScreenContent(
    itemCountScreenState: ItemCountScreenState,
    onItemCountChange: (String) -&gt; Unit,
    onButtonClick: () -&gt; Unit
) {
    Column {
        OnBackgroundTitleText(text = stringResource(id
            = R.string.enter_number))
        TextField(
            value = itemCountScreenState.itemCount,
            keyboardOptions = KeyboardOptions(
            keyboardType = KeyboardType.Number),
            onValueChange = onItemCountChange
        )
        PrimaryTextButton(text = stringResource(id =
        R.string.click_me), onClick = onButtonClick)
    }
}</pre></li>
				<li>In the same file, create a<a id="_idIndexMarker771"/> new function <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">ItemCountScreen</strong></span><span class="No-Break">:</span><pre class="source code">
@Composable
fun ItemCountScreen(onButtonClick: (String) -&gt; Unit) {
    var state by remember {
        mutableStateOf(ItemCountScreenState())
    }
    ItemCountScreenContent(state, {
        state = state.copy(itemCount = it)
    }, {
        onButtonClick(state.itemCount)
    })
}</pre></li>
				<li>Create a new Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">ItemScreen</strong></span><span class="No-Break">.</span></li>
				<li>In that file, create a new class <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">ItemScreenState</strong></span><span class="No-Break">:</span><pre class="source code">
data class ItemScreenState(
    val items: List&lt;String&gt; = emptyList()
)</pre></li>
				<li>In the same file, create a<a id="_idIndexMarker772"/> new function called <strong class="source inline">ItemScreenContent</strong>, which will <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">OnBackgroundItemText</strong></span><span class="No-Break">:</span><pre class="source code">
@Composable
fun ItemScreenContent(
    itemScreenState: ItemScreenState
) {
    LazyColumn {
        items(itemScreenState.items) { item -&gt;
            Column(modifier =
            Modifier.padding(vertical = 4.dp)) {
                OnBackgroundItemText(text = item)
            }
        }
    }
}</pre></li>
				<li>In the same file, create a new function <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">ItemScreen</strong></span><span class="No-Break">:</span><pre class="source code">
@Composable
fun ItemScreen(itemCount: String) {
    ItemScreenContent(itemScreenState =
    ItemScreenState((1..itemCount.toInt()).toList()
    .map {
        stringResource(id = R.string.item_format,
        formatArgs = arrayOf("$it"))
    }))
}</pre></li>
				<li>In the <strong class="source inline">MainActivity</strong> file, create<a id="_idIndexMarker773"/> the <strong class="source inline">MyApp</strong> function, which will manage our two screens <span class="No-Break">defined previously:</span><pre class="source code">
@Composable
fun MyApp(navController: NavHostController) {
    NavHost(navController = navController,
    startDestination = "itemCountScreen") {
        composable("itemCountScreen") {
            ItemCountScreen { navController.navigate(
            "itemScreen/?itemCount=$it") }
        }
        composable(
            "itemScreen/?itemCount={itemCount}",
            arguments =
            listOf(navArgument("itemCount") {type =
            NavType.StringType })
        ) {
            ItemScreen(
                it.arguments?.getString("itemCount")
                .orEmpty()
            )
        }
    }
}</pre></li>
				<li>Finally, modify the <strong class="source inline">setContent</strong> function <a id="_idIndexMarker774"/>so that <strong class="source inline">MyApp</strong> will <span class="No-Break">be called:</span><pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContent {
            MyApplicationTheme {
                Surface(color =
                MaterialTheme.colors.background) {
                    val navController =
                        rememberNavController()
                    Column(modifier =
                        Modifier.padding(16.dp)) {
                            MyApp(navController)
                    }
                }
            }
        }
    }
}</pre></li>
			</ol>
			<p>If we run the application, we should see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B19411_09_03.jpg" alt="Figure 9.3 – Output of Exercise 9.03"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Output of Exercise 9.03</p>
			<p>We should be able to see the screens split in two, and on entering a number in one screen, we should transition to the other screen with a generated list of items. We should also see the newly <a id="_idIndexMarker775"/>defined styles for the <strong class="source inline">Text</strong> functions. We should be able to control these styles only from the <strong class="source inline">Elements</strong> class and cause no modifications to the <span class="No-Break">screens themselves.</span></p>
			<p>In this section, we have learned how to apply theming to an application and how we can create multiple screens and navigate between them using Jetpack Compose. In the section that follows, we will look at how we can integrate Compose into an existing project and how well it can be integrated with other <span class="No-Break">popular libraries.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor508"/>Adding Compose to existing projects</h1>
			<p>In this section, we will look<a id="_idIndexMarker776"/> at what options we have in terms of introducing Jetpack Compose into an existing Android application and how to get Compose to work with <span class="No-Break">different libraries.</span></p>
			<p>When using Jetpack Compose, you should ideally have a small number of activities, or one if possible, and have all your screens built using Compose. For an existing project to be able to achieve this, it would need to start at the bottom of the <strong class="source inline">View</strong> hierarchy, meaning that your existing views should start being migrated to be built <span class="No-Break">in Compose.</span></p>
			<p>To facilitate this transition, Jetpack<a id="_idIndexMarker777"/> Compose offers the possibility of using <strong class="source inline">ComposeView</strong> in your XML layout, as in the <span class="No-Break">following example:</span></p>
			<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android=
      "http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;androidx.compose.ui.platform.ComposeView
        android:id="@+id/compose_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;</pre>
			<p>Here, we have an existing layout that will need to include a view that was defined using Jetpack Compose. In the layout XML file, we can put a <strong class="source inline">ComposeView</strong> placeholder of where our view would live, and then in the Kotlin code, we can include the Compose user <span class="No-Break">interface element:</span></p>
			<pre class="source code">
class MyFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(
        R.layout.my_fragment_layout, container).apply {
            findViewById&lt;ComposeView&gt;(R.id.compose_view)
            .apply {
                setViewCompositionStrategy(
                ViewCompositionStrategy
                .DisposeOnViewTreeLifecycleDestroyed)
                setContent {
                    MaterialTheme {
                        Text("My Text")
                    }
                }
            }
        }
    }
}</pre>
			<p>In this example, <strong class="source inline">Fragment</strong> inflates the XML layout, looks up <strong class="source inline">ComposeView</strong>, and marks the Compose content to be<a id="_idIndexMarker778"/> destroyed when the <strong class="source inline">View</strong> of <strong class="source inline">Fragment</strong> is also destroyed to prevent any leaks, and then sets the content of <strong class="source inline">ComposeView</strong> to <span class="No-Break">be </span><span class="No-Break"><strong class="source inline">Text</strong></span><span class="No-Break">.</span></p>
			<p>When we want to go the opposite route and add Android views into the Compose code, then we have the option of <span class="No-Break">using </span><span class="No-Break"><strong class="source inline">AndroidView</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@Composable
fun MyCustomisedElement(text: String) {
    AndroidView(factory = { context -&gt;
        TextView(context).apply {
            this.text = text
        }
    })
}</pre>
			<p>In this example, we have defined a new <strong class="source inline">@Composable</strong> function called <strong class="source inline">MyCustomisedElement</strong>, which will invoke <strong class="source inline">AndroidView</strong>, which in turn will create a <strong class="source inline">TextView</strong> on which it will set the text we have defined as <span class="No-Break">a parameter.</span></p>
			<p>As we’ve seen in previous sections, we can use <strong class="source inline">LocalContext.current</strong> to obtain a <strong class="source inline">Context</strong> reference. This allows us to perform actions such as starting activities and services and <span class="No-Break">showing </span><span class="No-Break"><strong class="source inline">Toasts</strong></span><span class="No-Break">.</span></p>
			<p>Compose is also able to<a id="_idIndexMarker779"/> interact with other libraries that are useful when building Android applications. We will analyze these libraries in the chapters that follow, but now, we will look at how they work with <span class="No-Break">Jetpack Compose:</span></p>
			<ul>
				<li>The <strong class="source inline">ViewModel</strong> library is useful for keeping data across configuration changes in our Activities and Fragments and helps to make our code more testable. Compose can obtain references to <strong class="source inline">ViewModel</strong> objects through the <strong class="source inline">@Composable</strong> function <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">viewModel</strong></span><span class="No-Break">:</span><pre class="source code">
@Composable
fun MyScreen(viewModel: MyViewModel = viewModel()) {
    Text(text = viewModel.myText)
}</pre></li>
			</ul>
			<p>Here, we call <strong class="source inline">viewModel</strong> to obtain a reference to <strong class="source inline">MyViewModel</strong> and set <strong class="source inline">Text</strong> with the value that <strong class="source inline">viewModel</strong> <span class="No-Break">was holding.</span></p>
			<ul>
				<li>Data stream libraries are useful in combination with the <strong class="source inline">ViewModel</strong> library, as when we want to load data asynchronously from the internet or the local filesystem, we will need to notify the user interface that the data <span class="No-Break">was loaded.</span></li>
			</ul>
			<p>Common data stream libraries are LiveData, RxJava, and Coroutines and Flows. We’ve seen that Compose uses a <strong class="source inline">State</strong> object when we want to manage the state of the user interface. For each of the three libraries, Compose provides extension libraries in which a stream of data is converted into a <span class="No-Break"><strong class="source inline">State</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source code">
@Composable
fun MyScreen(viewModel: MyViewModel = viewModel()) {
    viewModel.myLiveData.observeAsState()?.let{
    myLiveDataText-&gt;
        Text(text = myLiveDataText)
    }
    viewModel.myObservable.subscribeAsState()?.let{
     myObservableText-&gt;
        Text(text = myObservableText)
    }
    viewModel.myFlow.collectAsState()?.let{
    myFlowText-&gt;
        Text(text = myFlowText)
    }
}</pre>
			<p>In this example, our <strong class="source inline">viewModel</strong> object would have each of the data streams that would hold a string. For each of the streams, Compose calls the equivalent method to subscribe<a id="_idIndexMarker780"/> and monitor for changes in the value of the string. When a new value is emitted for each stream, then Compose sets it in <span class="No-Break">the </span><span class="No-Break"><strong class="source inline">Text</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li>Hilt is a dependency injection library designed for Android app development. If the <strong class="source inline">navigation</strong> library is not present in the project, then using the <strong class="source inline">viewModel</strong> function described previously should be enough to obtain a reference to your <strong class="source inline">ViewModel</strong>; however, if the <strong class="source inline">navigation</strong> library is present, then a library that makes <strong class="source inline">hilt</strong> and <strong class="source inline">navigation</strong> work together also needs to <span class="No-Break">be included:</span><pre class="source code">
implementation 'androidx.hilt:hilt-navigation-compose:1.0.0'</pre></li>
			</ul>
			<p>To obtain references to <strong class="source inline">ViewModel</strong> objects in the Compose code, we will need to replace the invocation to <strong class="source inline">viewModel</strong> with an invocation <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">hiltViewModel</strong></span><span class="No-Break">.</span></p>
			<p>You can find more information<a id="_idIndexMarker781"/> about integrating Jetpack Compose into your Android application at <a href="https://developer.android.com/jetpack/compose">https://developer.android.com/jetpack/compose</a>, and about compatibility with other libraries <span class="No-Break">here: </span><a href="https://developer.android.com/jetpack/compose/libraries"><span class="No-Break">https://developer.android.com/jetpack/compose/libraries</span></a><span class="No-Break">.</span></p>
			<p>In this section, we have looked at how we can integrate the Jetpack Compose library and make it work with existing <strong class="source inline">View</strong> objects and existing libraries in <span class="No-Break">the project.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor509"/>Activity 9.01 – first Compose app</h2>
			<p>Create a new app using Jetpack Compose, which will have <span class="No-Break">three screens:</span></p>
			<ul>
				<li>The <strong class="bold">insert rows</strong> screen will have <a id="_idIndexMarker782"/>a title, a text field, and a button where a number can be inserted. When the button is clicked, then the user navigates to the <span class="No-Break">next screen.</span></li>
				<li>The <strong class="bold">insert columns</strong> screen will have a title, a text field where a number can be inserted, and a button. When the button is clicked, then the user navigates to the <span class="No-Break">next screen.</span></li>
				<li>A grid screen will display a grid with the number of rows and the number of columns inserted above. Each row will independently scroll using <strong class="source inline">LazyRow</strong>, and for the columns, <strong class="source inline">LazyColumn</strong> will be used. Each grid item will display the text <strong class="source inline">"</strong><span class="No-Break"><strong class="source inline">Item [row][column]"</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The first two screens will have their user interface elements using the same styling for the titles, text fields, and buttons, and the third screen will have a style for displaying the text in <span class="No-Break">the grid.</span></p>
			<p>To complete this activity, you need to take the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create a new Android Studio project using an empty <span class="No-Break">Compose Activity.</span></li>
				<li>Add the <strong class="source inline">navigation</strong> library dependency to the <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file.</span></li>
				<li>In the <strong class="source inline">ui.theme</strong> package, create a new Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">Elements</strong></span><span class="No-Break">.</span></li>
				<li>In that file, create <strong class="source inline">@Composable</strong> functions for the titles used in <span class="No-Break">the application.</span></li>
				<li>In the same file, create <strong class="source inline">@Composable</strong> functions for the text fields used in <span class="No-Break">the application.</span></li>
				<li>In the same file, create <strong class="source inline">@Composable</strong> functions for the <span class="No-Break">grid items.</span></li>
				<li>In the same file, create <strong class="source inline">@Composable</strong> functions for <span class="No-Break">the buttons.</span></li>
				<li>Create a new Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">InsertRowsScreen</strong></span><span class="No-Break">.</span></li>
				<li>Create <strong class="source inline">InsertRowsScreenState</strong>, <strong class="source inline">InsertRowsScreenContent</strong>, and <strong class="source inline">InsertRowsScreen</strong>, which will be responsible for holding the screen state and the screen<a id="_idIndexMarker783"/> content and for managing the <span class="No-Break">screen state.</span></li>
				<li>Create a new Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">InsertColumnsScreen</strong></span><span class="No-Break">.</span></li>
				<li>Create <strong class="source inline">InsertColumnsScreenState</strong>, <strong class="source inline">InsertColumnsScreenContent</strong>, and <strong class="source inline">InsertColumnsScreen</strong>, which will be responsible for holding the screen state and the screen content and for managing the <span class="No-Break">screen state.</span></li>
				<li>Create a new Kotlin file <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">GridScreen</strong></span><span class="No-Break">.</span></li>
				<li>Create <strong class="source inline">GridScreenState</strong>, <strong class="source inline">GridScreenContent</strong>, and <strong class="source inline">GridScreen</strong>, which will be responsible for holding the screen state and the screen content and for managing the <span class="No-Break">screen state.</span></li>
				<li>In <strong class="source inline">MainActivity</strong>, create <a id="_idIndexMarker784"/>a new function that will set up the navigation between <span class="No-Break">your screens.</span></li>
				<li>In <strong class="source inline">MainActivity</strong>, modify the <strong class="source inline">setContent</strong> method block to invoke the function <span class="No-Break">created previously.</span></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">at </span><a href="https://packt.link/Le1jE"><span class="No-Break">https://packt.link/Le1jE</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor510"/>Summary</h1>
			<p>In this chapter, we looked at how we can build user interfaces using Jetpack Compose. We started by creating simple user interface elements, and we looked at how we can make an entire screen using <strong class="source inline">@Composable</strong> functions without any <span class="No-Break">XML code.</span></p>
			<p>Then, we analyzed state management and how we can handle user input, and looked at patterns such as state hoisting, in which we keep our functions as stateless as possible to increase reusability. We then looked at how we can define our own user interface elements and apply themes and styles to them, which allows us to change the entire look of an application without modifying the screens that use the <span class="No-Break">changed elements.</span></p>
			<p>Finally, we looked at how we can add Compose to an existing project and how Compose interacts with popular libraries used for app development. In the chapter’s activity, we applied all these concepts and created an application with a consistent user interface definition with multiple screens defined <span class="No-Break">in Compose.</span></p>
			<p>In the next chapter, we will analyze how we can test our code on Android and look at some popular libraries we can use to <span class="No-Break">achieve this.</span></p>
		</div>
		<div>
			<div id="_idContainer166" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer167" class="Content">
			<h1 id="_idParaDest-153"><a id="_idTextAnchor511"/>Part 3: Testing and Code Structure</h1>
			<p>In this part, we will look at how we can structure our code to make it testable and the types of testing we can do in the code base. The Android Architecture Components will be used to assist in code structuring by separating code that performs tasks that can be tested from code that interacts with the user interface, which is harder <span class="No-Break">to test.</span></p>
			<p>We will then look at the available options we have with regard to saving data on the device. Finally, we will explore how we can manage the dependencies inside the application with the help of <span class="No-Break">dependency injection.</span></p>
			<p>We will cover the following chapters in <span class="No-Break">this section:</span></p>
			<ul>
				<li><a href="B19411_10.xhtml#_idTextAnchor512"><em class="italic">Chapter 10</em></a>, <em class="italic">Unit Tests and Integration Tests with JUnit, Mockito, and Espresso</em></li>
				<li><a href="B19411_11.xhtml#_idTextAnchor582"><em class="italic">Chapter 11</em></a>, <em class="italic">Android Architecture Components</em></li>
				<li><a href="B19411_12.xhtml#_idTextAnchor638"><em class="italic">Chapter 12</em></a>, <em class="italic">Persisting Data</em></li>
				<li><a href="B19411_13.xhtml#_idTextAnchor695"><em class="italic">Chapter 13</em></a>, <em class="italic">Dependency Injection with Dagger, Hilt, and Koin</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer168">
			</div>
		</div>
	</body></html>