<html><head></head><body>
		<div><h1 id="_idParaDest-141" class="chapter number"><a id="_idTextAnchor499"/>9</h1>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor500"/>Building User Interfaces Using Jetpack Compose</h1>
			<p>In this section, you will learn how to use Jetpack Compose to create user interfaces using Kotlin code, how Compose revolutionized the way we built user interfaces, and how we can translate existing applications to Jetpack Compose. By the end of the chapter, you will be familiar with the most common UI elements in Compose and how to handle user actions.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>What is Jetpack Compose?</li>
				<li>Handling user actions</li>
				<li>Theming in Compose</li>
				<li>Adding Compose to existing projects</li>
			</ul>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor501"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/kb5FW">https://packt.link/kb5FW</a></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor502"/>What is Jetpack Compose?</h1>
			<p>In past chapters, you learned how to set data into the Android View hierarchy and learned how to use<a id="_idIndexMarker736"/> different types of views for different purposes. That approach to user interface<a id="_idIndexMarker737"/> building is referred to as the <strong class="bold">imperative approach</strong>.</p>
			<p>In the imperative approach, when we want to change the state of the user interface, we will need to manually change each user interface element until we reach the desired outcome.</p>
			<p>Let’s assume that because of a user action, we want our <code>TextView</code> to change the text and text color. This means that we would need to invoke <code>setText</code> and <code>setTextColor</code> to achieve our desired effect.</p>
			<p>As an alternative to<a id="_idIndexMarker738"/> the imperative approach, we have the <strong class="bold">declarative approach</strong>, in which we would need to describe the final state that we want our user interface to reach, and internally, the required invocations would be performed.</p>
			<p>This means that our <code>TextView</code> would instead have the text and text color as attributes, and we could define<a id="_idIndexMarker739"/> different objects holding the states we want. In Jetpack Compose, this would look like the following example:</p>
			<pre class="source code">
@Composable
fun MyTextDisplay(myState: MyState) {
    Text(text = myState.text, color = myState.color)
}
data class MyState(
    val text: String,
    val color: Color
)</pre>
			<p>In the preceding example, we define a <code>@Composable</code> function that will display a <code>Text</code> element. The values for <code>text</code> and <code>color</code> would be held in a separate data class that will represent the state of the text.</p>
			<p>This mechanism allows Jetpack Compose to redraw the user interface for any change that occurs in <code>MyState</code>. This process is called <code>@Composable</code> functions that had a change.</p>
			<p>If we want to create a new screen in Compose, we have the choice of <code>Row</code> or <code>Column</code> functions to arrange elements. For vertical arrangement, we can use <code>Column</code>, and for horizontal alignment, we use <code>Row</code>:</p>
			<pre class="source code">
@Composable
fun MyScreen(){
    Column {
        Text(text = "My Static Text")
        TextField(value = "My Text Field", onValueChange = {
        })
        Button(onClick = { }) { }
        Icon(painter = painterResource(R.drawable.icon),
            contentDescription = stringResource(id =
            R.string.icon_content_description))
    }
}</pre>
			<p>In the preceding example, using <code>Column</code>, we show different user interface elements above each other:</p>
			<ul>
				<li><code>Text</code> will show a <a id="_idIndexMarker741"/>simple label with the <code>My Static Text</code> label as <code>text</code>.</li>
				<li><code>TextField</code> will show an input field that’s pre-filled with the <code>My Text Field</code> text through the <code>value</code> parameter. The <code>onValueChange</code> lambda will pick up any text that the user inserts.</li>
				<li><code>Button</code> will show a button, and through the <code>onClick</code> lambda, we can pick up the click events on it.</li>
				<li><code>Icon</code> will display a particular icon from the <code>drawable</code> or <code>mipmap</code> folders and will have a content description set from the string resources.</li>
			</ul>
			<p>If we want to display lists of items, we can use the following approach when the number of items is known and small enough to fit on the screen of the device:</p>
			<pre class="source code">
@Composable
fun MyList(items: List&lt;String&gt;) {
    Column {
        items.forEach { item -&gt; Text(text = item) }
    }
}</pre>
			<p>In the preceding example, we iterate over each item in the list and show a <code>Text</code> for each item. If the number of items is unknown and large enough to require scrolling, then we would run into <a id="_idIndexMarker742"/>performance issues because the recomposition would go over both visible and not visible items. For this scenario, we could use the following approach:</p>
			<pre class="source code">
@Composable
fun MyList(items: List&lt;String&gt;) {
    LazyColumn {
        item { Text(text = "Header") }
        items(items){ item-&gt; Text(text = item) }
        item { Text(text = "Footer") }
    }
}</pre>
			<p>Here, we are using a <code>LazyColumn</code> function and wrapping our collection with the <code>items</code> function. We are also able to add static items as a header and footer of the list through the <code>item</code> function. Like <code>Column</code>, we can use <code>LazyRow</code> to display a list of items with a horizontal scroll.</p>
			<p>If we want to add spacings between the UI elements, then <code>Modifiers</code> become useful:</p>
			<pre class="source code">
@Composable
fun MyScreen(){
    Column {
        Text(text = "My Static Text")
        TextField(value = "My Text Field", onValueChange =
        { }
}</pre>
			<p>In the preceding example, we’ve added <code>16.dp</code> padding to the entire column of items in all directions. If we wanted<a id="_idIndexMarker743"/> different paddings in different directions, we would’ve had something like the following:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column(
        modifier = Modifier.padding(
            top = 5.dp, bottom = 5.dp,
            start = 10.dp, end = 10.dp)
    ) {
    }
}</pre>
			<p>In the preceding example, we’ve set <code>5.dp</code> vertical padding and <code>10.dp</code> horizontal padding. Because the values are repeated, we can instead use the following approach:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column(
        modifier = Modifier.padding(
            vertical = 5.dp,
            horizontal = 10.dp)
    ) {
    }
}</pre>
			<p>Here, we’ve used the <code>vertical</code> and <code>horizontal</code> parameters to set the vertical and horizontal paddings. If we want to make the row clickable, then we can use the following modifier:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column(
        modifier = Modifier.padding(
            vertical = 5.dp,
            horizontal = 10.dp
        ).clickable { }
    ) { }
}</pre>
			<p>In the preceding example, we’ve used the <code>clickable</code> method from <code>Modifier</code>. This will register a<a id="_idIndexMarker744"/> click listener on the entire <code>Column</code>.</p>
			<p>When it comes to the relationship between Activities and Fragments and screens built in Compose, we have the following extensions for Compose:</p>
			<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent { MyScreen() }
    }
}</pre>
			<p>In the preceding example, we have the <code>setContent</code> extension function defined for <code>ComponentActivity</code>, which will set a <code>@Composable</code> function as the content for an <code>Activity</code>. The same is true for Fragments; however, when starting a new project, the current recommendation is to have a single Activity and make all your additional screens separate <code>@</code><code>Composable</code> functions.</p>
			<p class="callout heading">Note</p>
			<p class="callout">In Android Studio, we have the possibility of having previews of our <code>@Composable</code> functions with the <code>@</code><code>Preview</code> annotation.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor503"/>Exercise 9.01 – first Compose screen</h2>
			<p>Create an Android application that has one screen defined using <code>@Composable</code> functions. The screen should have the<a id="_idIndexMarker745"/> following elements:</p>
			<ul>
				<li><code>Text</code>, which will say <code>"Enter </code><code>a number"</code></li>
				<li><code>TextField</code>, which will only accept integers</li>
				<li><code>Button</code>, which has the text <code>"</code><code>Click Me"</code></li>
				<li><code>LazyColumn</code>, which will display a list of 100 items with the following format for each row: <code>"</code><code>Item c"</code></li>
			</ul>
			<p>Perform the following steps to complete the exercise:</p>
			<ol>
				<li>Create a new Android Studio project and select <strong class="bold">Empty </strong><strong class="bold">Compose Activity</strong>.</li>
				<li>Add the following to <code>strings.xml</code> in the <code>res/values</code> folder:<pre class="source code">
    &lt;string name="enter_number"&gt;Enter a
        number&lt;/string&gt;
    &lt;string name="click_me"&gt;Click Me&lt;/string&gt;
    &lt;string name="item_format"&gt;Item %s&lt;/string&gt;</pre></li>
				<li>Define the user interface of the exercise:<pre class="source code">
@Composable
fun MyScreen(
    items: List&lt;String&gt;
) {
    LazyColumn {
        item {
            Column(modifier = Modifier.padding(16.dp))
            {
                Text(text = stringResource(id =
                R.string.enter_number))
                TextField(
                    value = "",
                    keyboardOptions =
                    KeyboardOptions(keyboardType =
                    KeyboardType.Number),
                    onValueChange = {
                    })
                Button(onClick = { }) {
                    Text(text = stringResource(id =
                    R.string.click_me))
                }
            }
        }
        items(items) { item -&gt;
            Column(modifier =
            Modifier.padding(vertical = 4.dp)) {
                Text(text = item)
            }
        }
    }
}</pre></li>
			</ol>
			<p>We have chosen to place everything inside the <code>LazyColumn</code> block. This will make the entire content<a id="_idIndexMarker746"/> scrollable, including <code>Text</code>, <code>TextField</code>, and <code>Button</code>, and not just the list of items.</p>
			<p>To make the keyboard only accept numeric input, we have used the <code>keyboardOptions</code> parameter of the <code>TextField</code> function. For <code>Button</code>, to add text to it, we needed to use the content parameter of the function and place a new <code>Text</code> inside the lambda.</p>
			<ol>
				<li value="4">Finally, modify the <code>MainActivity</code> code to use the function we’ve just defined:<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val items = (1..100).toList().map {
                stringResource(id =
                R.string.item_format, formatArgs =
                arrayOf("$it"))
            }
            MyScreen(items)
        }
    }
}</pre></li>
			</ol>
			<p>Here, we generate a new list of items that will say <code>"Item [count]"</code> and invoke the <code>@Composable</code> function, <code>MyScreen</code>.</p>
			<p>If we run the preceding example, we will see the following output:</p>
			<div><div><img src="img/B19411_09_01.jpg" alt="Figure 9.1 – Output of Exercise 9.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Output of Exercise 9.01</p>
			<p>We can see in the preceding figure that the screen was built according to the exercise specifications. One thing to note is the fact that we aren’t allowed to input any text in the input field. This is because we have set the value of <code>TextField</code> to an empty string. We will look at how we can<a id="_idIndexMarker747"/> properly handle this aspect in further sections of the book.</p>
			<p>In this section, we have looked at how we can use Jetpack Compose to build user interfaces in a simple way without the involvement of other languages and syntaxes such as Kotlin. Next, we will continue the exploration of Compose and how we can handle user actions and manage states.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor504"/>Handling user actions</h1>
			<p>In the previous section, we learned how<a id="_idIndexMarker748"/> to build user interfaces using Jetpack Compose. In the exercise, we were unable to collect the data that the user sets in <code>TextField</code>. In this section, we will learn how to handle the user input as well as the state of the user interface.</p>
			<p>Let’s assume we have the following example:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    Column { TextField(value = "", onValueChange = {}) }
}</pre>
			<p>In this example, we define a <code>TextField</code> that is empty and has no handling for the change of the value. As we’ve seen, this won’t let us introduce any new input from the keyboard because it will always set the text to an empty string.</p>
			<p>For us to be able to introduce a <a id="_idIndexMarker749"/>new text, we will need to create a mutable variable to store the text inside and for it to survive recomposition. In Jetpack Compose, we can use the <code>@Composable</code> function called <code>remember</code> to define a <code>MutableState</code> that will hold our text:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    var text by remember { mutableStateOf("") }
    Column { TextField(value = text, onValueChange = {}) }
}</pre>
			<p>In the preceding example, we define a mutable variable called <code>text</code>, which we then set in <code>TextField</code>. The <code>text</code> variable is initialized through the <code>remember</code> function, which will hold a <code>MutableState</code> that has the initial value set to an empty string. This still isn’t complete; we will now need to connect the state with the change in value for <code>TextField</code>:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    var text by remember { mutableStateOf("") }
    Column {
        TextField(value = text, onValueChange = { <strong class="bold">text = it</strong> })
    }
}</pre>
			<p>Here, we modify the <code>onValueChange</code> lambda to change the <code>text</code> state with the latest text that the user inserted.</p>
			<p class="callout heading">Note</p>
			<p class="callout">We can use the <code>rememberSaveable</code> function to instead retain the value of objects across configuration changes such as Activity recreation.</p>
			<p>When dealing with states, we<a id="_idIndexMarker750"/> tend to turn <code>@Composable</code> functions from being stateless (doesn’t manage a state) to stateful (manages one or more states). As a guideline, we should try to keep our functions as stateless as possible through a pattern called <code>@Composable</code> function. This would turn the preceding example into the following:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    var text by rememberSaveable { mutableStateOf("") }
    MyScreenContent(text = text, onTextChange = { text = it })
}
@Composable
fun MyScreenContent(text: String, onTextChange: (String) -&gt; Unit) {
    Column {
        TextField(value = text, onValueChange =
            onTextChange)
    }
}</pre>
			<p>In the preceding example, we’ve split our functions in two. The <code>MyScreen</code> function will manage the state of the text and invoke the <code>MyScreenContent</code> function, which is now stateless. This approach introduces multiple benefits such as the <em class="italic">reusability</em> of our stateless functions, <em class="italic">decoupled</em> state management, and <em class="italic">a single source of truth</em> for our state.</p>
			<p class="callout heading">Note</p>
			<p class="callout">When you use the Jetpack Compose State and <code>MutableState</code> objects, you might need to manually import the following two methods for getting and setting a state: <code>androidx.compose.runtime.getValue</code> and <code>androidx.compose.runtime.setValue</code>.</p>
			<p>When dealing with states in<a id="_idIndexMarker752"/> Jetpack Compose, when a change occurs in a state, then the recomposition process is triggered. This might cause problems when we want to show one-off events such as <code>Snackbar</code> and <code>Toast</code>. To achieve this, we can use <code>LaunchedEffect</code>:</p>
			<pre class="source code">
@Composable
fun MyScreenContent() {
    val context = LocalContext.current
    LaunchedEffect(anObjectToChange) {
        Toast.makeText(context, "Toast text",
        Toast.LENGTH_SHORT).show()
    }
}</pre>
			<p>The preceding example will show a <code>Toast</code> message every time <code>anObjectToChange</code> takes on a different value. If we replace <code>anObjectToChange</code> with <code>Unit</code>, then the <code>LaunchedEffect</code> block will be executed only once.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor505"/>Exercise 9.02 – handling user inputs</h2>
			<p>Modify <em class="italic">Exercise 9.01 – first Compose screen</em> such that when the user introduces a number in <code>TextField</code> and clicks the button, then a list of items as big as the number introduced will be generated and the list below the button will be populated with them. The text will be the<a id="_idIndexMarker753"/> same for each item as before.</p>
			<p>To represent the state of the user interface, a data class will be created that will hold the number of items, with <code>0</code> as a default, and the list of items, which will be empty by default.</p>
			<p>Perform the following steps to complete the exercise:</p>
			<ol>
				<li>Create the <code>MyScreenState</code> data class, which will hold the state of the user interface:<pre class="source code">
data class MyScreenState(
    val itemCount: String = "",
    val items: List&lt;String&gt; = emptyList()
)</pre></li>
				<li>Create the <code>@Composable</code> method called <code>MyScreenContent</code>, which will have <code>MyScreenState</code> as a parameter and render the state:<pre class="source code">
@Composable
fun MyScreenContent(
    myScreenState: MyScreenState,
    onItemCountChange: (String) -&gt; Unit,
    onButtonClick: @Composable () -&gt; Unit
) {
    LazyColumn {
        item {
            Column(modifier = Modifier.padding(16.dp))
            {
                Text(text = stringResource(id =
                R.string.enter_number))
                TextField(
                    value = myScreenState.itemCount,
                    keyboardOptions =
                    KeyboardOptions(keyboardType =
                    KeyboardType.Number),
                    onValueChange =
                    onItemCountChange
                )
                Button(onClick = onButtonClick) {
                    Text(text = stringResource(id =
                    R.string.click_me))
                }
            }
        }
        items(myScreenState.items) { item -&gt;
            Column(modifier =
            Modifier.padding(vertical = 4.dp)) {
                Text(text = item)
            }
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding example, we set <code>itemCount</code> from <code>myScreenState</code> in our <code>TextField</code> and <code>items</code> from <code>myScreenState</code> as items in the list. We’ve also added our text change <a id="_idIndexMarker754"/>listener and button listener as parameters to the function, making it stateless.</p>
			<ol>
				<li value="3">Modify the <code>MyScreen</code> function such that it will call <code>MyScreenContent</code> and handle the listener for the text change and for the button click:<pre class="source code">
@Composable
fun MyScreen() {
    var state by remember {
        mutableStateOf(MyScreenState())
    }
    val context = LocalContext.current
    MyScreenContent(state, {
        state = state.copy(itemCount = it)
    }, {
        state = state.copy(items =
        (1..state.itemCount.toInt()).toList().map {
            context.getString(R.string.item_format,
            "$it")
        })
    })
}</pre></li>
			</ol>
			<p>Here, we are creating a new <code>MutableState</code> that will hold <code>MyScreenState</code> with its defaults. We will then invoke <code>MyScreenContent</code> in which we pass the state. When the text changes, we set the state to be the copy of the existing state with the new text, and when the button is clicked, we generate a new list of items up until the current <code>itemCount</code> and update the state.</p>
			<ol>
				<li value="4">Update the <code>MainActivity</code> class to<a id="_idIndexMarker755"/> invoke the <code>MyScreen</code> function without any parameters:<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyScreen()
        }
    }
}</pre></li>
			</ol>
			<p>If we run the exercise and insert a number, then we should see the following screen:</p>
			<div><div><img src="img/B19411_09_02.jpg" alt="Figure 9.2 – Output of Exercise 9.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Output of Exercise 9.02</p>
			<p>When the app is first launched, we should see the <code>TextField</code> empty and no elements in the list below the button. When a number is set, then the state is changed to reflect the new text, and when the button is clicked, then the list of items is displayed with the size being that of the inserted number.</p>
			<p>In this section, we have looked at<a id="_idIndexMarker756"/> how we can handle user input, keep it in a state, and manage that state across recomposition. In the section that follows, we will look at how we can further decorate our user interface elements.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor506"/>Theming in Compose</h1>
			<p>In the previous section, we learned how to<a id="_idIndexMarker757"/> handle user actions and how to manage the state of a particular screen. But how do we keep our application’s user interface elements consistent across the entire application? In this section, we will look at how we can create reusable elements that are linked to the application’s theme.</p>
			<p>You may have noticed, when you carried out the previous exercises, that Android Studio created some files in a <code>ui.theme</code> package. This is because Jetpack Compose is built upon the Material Design library and will assign a theme to your application that is built on Material Design. The approach taken is the following:</p>
			<ol>
				<li>In the <code>Color.kt</code> file, all the <a id="_idIndexMarker758"/>colors of the application are declared:<pre class="source code">
val Purple200 = Color(0xFFBB86FC)
val Purple500 = Color(0xFF6200EE)
val Purple700 = Color(0xFF3700B3)
val Teal200 = Color(0xFF03DAC5)</pre></li>
			</ol>
			<p>In the preceding example, we have the color hexadecimal names.</p>
			<ol>
				<li value="2">In <code>Shape.kt</code>, the following code is generated:<pre class="source code">
val Shapes = Shapes(
    small = RoundedCornerShape(4.dp),
    medium = RoundedCornerShape(4.dp),
    large = RoundedCornerShape(0.dp)
)</pre></li>
			</ol>
			<p>This will indicate what the size of the icons you use in the application should be.</p>
			<ol>
				<li value="3">In <code>Type.kt</code>, the following code is generated:<pre class="source code">
val Typography = Typography(
    body1 = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp
    )
)</pre></li>
			</ol>
			<p>This will represent how the text in your application is rendered. The <code>Typography</code> class holds configurations for how your headings, subtitles, paragraphs, buttons, and captions text should be.</p>
			<ol>
				<li value="4">In the <code>Theme.kt</code> file, we<a id="_idIndexMarker759"/> have two color palettes defined:<pre class="source code">
private val DarkColorPalette = darkColors(
    primary = Purple200,
    primaryVariant = Purple700,
    secondary = Teal200
)
private val LightColorPalette = lightColors(
    primary = Purple500,
    primaryVariant = Purple700,
    secondary = Teal200
)</pre></li>
			</ol>
			<p>Here, there’s a light and dark color palette defined and the <code>primary</code>, <code>primaryVariant</code>, and <code>secondary</code> colors are set. The rest of the colors in the <code>lightColors</code> and <code>darkColors</code> functions will remain with their default values.</p>
			<ol>
				<li value="5">In the same file, the application’s theme is generated:<pre class="source code">
@Composable
fun MyApplicationTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -&gt; Unit
) {
    val colors = if (darkTheme) {
        DarkColorPalette
    } else {
        LightColorPalette
    }
    MaterialTheme(
        colors = colors,
        typography = Typography,
        shapes = Shapes,
        content = content
    )
}</pre></li>
			</ol>
			<p>Here, a check will be made to see whether the device has light or dark mode enabled and use the appropriate set of colors for each mode. It will also set the typography you configured<a id="_idIndexMarker760"/> and how the shapes in your application should be. Just because it is set in the theme, that doesn’t mean that our user interface elements will automatically inherit it.</p>
			<ol>
				<li value="6">When the <code>MainActivity</code> class is generated, it will have the following structure:<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyApplicationTheme {
                Surface(color =
                MaterialTheme.colors.background) { }
            }
        }
    }
}</pre></li>
			</ol>
			<p>When <code>setContent</code> is called, then your application’s theme will be called, and the <code>Surface</code> function will set your application’s background.</p>
			<p>We can now use the preceding setup as a starting point to define a theme for our application and start to create<a id="_idIndexMarker761"/> reusable user interface components. Let’s assume we want all the paragraphs in the application to use the same typography and have the same color; in this case, we will use <code>MaterialTheme.typography.body1</code> and <code>MaterialTheme.colors.onBackground</code>:</p>
			<pre class="source code">
@Composable
fun ParagraphText(text: String) {
    Text(
        text = text,
        style = MaterialTheme.typography.body1,
        color = MaterialTheme.colors.onBackground
    )
}</pre>
			<p>In the preceding example, we’ve defined the <code>ParagraphText</code> function, which will set the style and color of the text from <code>MaterialTheme</code>. We might now have a problem if we want the same style and a different text color, where we need to duplicate the style attribute for each. Another solution is to create two functions – one for the style and the other on top of it for the color:</p>
			<pre class="source code">
@Composable
fun OnBackgroundParagraphText(text: String) {
    ParagraphText(text = text, color =
    MaterialTheme.colors.onBackground)
}
@Composable
fun ParagraphText(text: String, color: Color) {
    Text(
        text = text,
        style = MaterialTheme.typography.body1,
        color = color
    )
}</pre>
			<p>In the preceding example, we’ve <a id="_idIndexMarker762"/>moved the color to be a parameter in the <code>ParagraphText</code> function and then created a new function called <code>OnBackgroundParagraphText</code>, which allows us to set <code>MaterialTheme.colors.onBackground</code> to the <code>Text</code> defined in <code>ParagraphText</code>. If we want to use our new function, then we can do the following:</p>
			<pre class="source code">
@Composable
fun MyScreen() {
    OnBackgroundParagraphText(text = "My text")
}</pre>
			<p>This is a simple function call, just like using the <code>Text</code> function.</p>
			<p>Now, let’s assume we are using this text across our entire application and the application goes through a redesign where instead of using <code>MaterialTheme.typography.body1</code>, we need to use <code>MaterialTheme.typography.body2</code>, and the text color needs to be red. In this case, we would then modify the <code>ParagraphText</code> function as follows:</p>
			<pre class="source code">
@Composable
fun ParagraphText(text: String, color: Color) {
    Text(
        text = text,
        style = MaterialTheme.typography.body2,
        color = color
    )
}</pre>
			<p>Here, we have changed the style of the <code>Text</code> function to use <code>MaterialTheme.typography.body2</code>. To change the color, we could modify <code>OnBackgroundParagraphText</code>, but the color currently used is recommended to be used on top of the current background, so we <a id="_idIndexMarker763"/>could also change the value of <code>MaterialTheme.colors.onBackground</code>. For this, we could go into <code>Theme.kt</code> and do the following:</p>
			<pre class="source code">
private val DarkColorPalette = darkColors(
    primary = Purple200,
    primaryVariant = Purple700,
    secondary = Teal200,
    onBackground = Color.Red
)
private val LightColorPalette = lightColors(
    primary = Purple500,
    primaryVariant = Purple700,
    secondary = Teal200,
    onBackground = Color.Red
)</pre>
			<p>Here, we changed the value of <code>onBackground</code> to red, which will impact all the user interface elements that reference <code>onBackground</code>. We can now see how we can easily apply this across all the user interface elements in the application without touching the code where those elements are used.</p>
			<p>If we want to have multiple<a id="_idIndexMarker764"/> screens in our application, we can connect Compose with the <code>navigation</code> library, which is available here:</p>
			<pre class="source code">
implementation "androidx.navigation:navigation-compose:2.5.3</pre>
			<p>Let’s now assume we have two screens defined in Jetpack Compose:</p>
			<pre class="source code">
@Composable
fun Screen1(onButtonClick: () -&gt; Unit) {
    Button(onClick = onButtonClick) {
        Text(text = "Click Me")
    }
}
@Composable
fun Screen2(input1: String, input2: String) {
    Text(text = "My inputs are $input1 and $input2")
}</pre>
			<p><code>Screen1</code> will display one button and <code>Screen2</code> has two inputs that will be displayed. We now want to connect the screens so that when the button is clicked on <code>Screen1</code>, <code>Screen2</code> opens with two hardcoded inputs passed. This would look like the following:</p>
			<pre class="source code">
@Composable
fun MyApp(navController: NavHostController) {
    NavHost(navController = navController,
    startDestination = "screen1") {
        composable("screen1") {
            Screen1 { navController.navigate
            ("screen2/Input1?input2=Input2") }
        }
        composable(
            "screen2/{input1}?input2={input2}",
            arguments = listOf(navArgument("input1") {
            type = NavType.StringType },
            navArgument("input2") { type =
            NavType.StringType }
            )
        ) {
            Screen2(
                input1 = it.arguments?
                .getString("input1").orEmpty(),
                input2 = it.arguments?
                .getString("input2").orEmpty()
            )
        }
    }
}</pre>
			<p>We have defined a new <code>@Composable</code> function called <code>MyApp</code>, which uses <code>NavHost</code> to keep all the screens in the application. <code>NavHost</code> will open <code>Screen1</code> as a default through the <code>screen1</code> URL. In the <code>onButtonClick</code> lambda from <code>Screen1</code>, we navigate to <code>Screen2</code> and we<a id="_idIndexMarker765"/> pass the <code>input1</code> and <code>input2</code> strings.</p>
			<p>This is done through the <code>screen2/{input1}?input2={input2}</code> URL. This is also how we will pass arguments between the two screens, through either the path parameter (<code>input1</code>) or the argument (<code>input2</code>). For each input, we will need to specify that we will be expecting a string as a type.</p>
			<p><code>Screen2</code> will then be opened, and the input extracted through the <code>it</code> variable, which is a <code>NavBackStackEntry</code> type. We can call this function from the <code>setContent</code> method of the Activity:</p>
			<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyApplicationTheme {
                Surface(color =
                MaterialTheme.colors.background) {
                    val navController =
                        rememberNavController()
                    MyApp(navController)
                }
            }
        }
    }
}</pre>
			<p>Here, we hoist the state of <code>NavHostController</code> and then<a id="_idIndexMarker766"/> call the <code>MyApp</code> function.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor507"/>Exercise 9.03 – applying themes</h2>
			<p>Modify <em class="italic">Exercise 9.02 – handling user inputs</em> such<a id="_idIndexMarker767"/> that <code>MyScreen</code>, <code>MyScreenContent</code>, and <code>MyScreenState</code> are split into two screens, with <code>ItemCountScreen</code>, <code>ItemCountScreenContent</code>, and <code>ItemCountScreenState</code> on one side, which will hold <code>Text</code>, <code>TextField</code>, and <code>Button</code>, and <code>ItemScreen</code>, <code>ItemScreenContent</code>, and <code>ItemScreenState</code> on the other, which will hold the item list.</p>
			<p>The two screens will be saved in <code>ItemCountScreen.kt</code> and <code>ItemScreen.kt</code> files. <code>ItemCountScreen</code> will be shown first, and when the button is clicked, then <code>ItemScreen</code> is shown with the number of items set in the previous screen.</p>
			<p>New functions will also be created to represent <code>Text</code> used across the application: one for the <code>"Enter a number"</code> text, which will be <code>MaterialTheme.typography.h5</code>; the <code>"Click Me"</code> text will be <code>MaterialTheme.typography.button</code>; and <code>"Item [count]"</code> will be <code>MaterialTheme.typography.body1</code>.</p>
			<p>The colors will be set to <code>MaterialTheme.colors.onBackground</code> for the text, and <code>Color.red</code> for the button text.</p>
			<p>Perform the following steps to<a id="_idIndexMarker768"/> complete the exercise:</p>
			<ol>
				<li>In the <code>app/build.gradle</code> file, add the <code>navigation</code> library dependency:<pre class="source code">
implementation "androidx.navigation:navigation-compose:2.5.3"</pre></li>
				<li>In the <code>ui.theme</code> package, create a Kotlin file called <code>Elements</code>.</li>
				<li>In the <code>Elements.kt</code> file, add the functions for the title text on the first screen:<pre class="source code">
@Composable
fun OnBackgroundTitleText(text: String) {
    TitleText(text = text, color =
        MaterialTheme.colors.onBackground)
}
@Composable
fun TitleText(text: String, color: Color) {
    Text(text = text, style =
        MaterialTheme.typography.h5, color = color)
}</pre></li>
				<li>In the same file, add the functions for the <code>"Item [</code><code>count]"</code> text:<pre class="source code">
@Composable
fun OnBackgroundItemText(text: String) {
    ItemText(text = text, color =
        MaterialTheme.colors.onBackground)
}
@Composable
fun ItemText(text: String, color: Color) {
    Text(text = text, style =
        MaterialTheme.typography.body1, color = color)
}</pre></li>
				<li>In the same file, add the <a id="_idIndexMarker769"/>functions for the button text:<pre class="source code">
@Composable
fun PrimaryTextButton(text: String, onClick: () -&gt;
Unit) {
    TextButton(text = text, textColor = Color.Red,
    onClick = onClick)
}
@Composable
fun TextButton(text: String, textColor: Color,
onClick: () -&gt; Unit) {
    Button(
        onClick = onClick, colors = ButtonDefaults
        .buttonColors(contentColor = textColor)
    ) {
        Text(text = text, style =
        MaterialTheme.typography.button)
    }
}</pre></li>
			</ol>
			<p>In this example, as the button sets the color for the content in a different way, we had to use <code>contentColor</code> from the <code>ButtonColors</code> class.</p>
			<ol>
				<li value="6">Create a new Kotlin file called <code>ItemCountScreen</code>.</li>
				<li>In this file, create a new <a id="_idIndexMarker770"/>class called <code>ItemCountScreenState</code>:<pre class="source code">
data class ItemCountScreenState(
    val itemCount: String = ""
)</pre></li>
				<li>In the same file, create a new function called <code>ItemCountScreenContent</code>, which will hold the newly created <code>OnBackgroundTitleText</code> and <code>PrimaryTextButton</code> functions:<pre class="source code">
@Composable
fun ItemCountScreenContent(
    itemCountScreenState: ItemCountScreenState,
    onItemCountChange: (String) -&gt; Unit,
    onButtonClick: () -&gt; Unit
) {
    Column {
        OnBackgroundTitleText(text = stringResource(id
            = R.string.enter_number))
        TextField(
            value = itemCountScreenState.itemCount,
            keyboardOptions = KeyboardOptions(
            keyboardType = KeyboardType.Number),
            onValueChange = onItemCountChange
        )
        PrimaryTextButton(text = stringResource(id =
        R.string.click_me), onClick = onButtonClick)
    }
}</pre></li>
				<li>In the same file, create a<a id="_idIndexMarker771"/> new function called <code>ItemCountScreen</code>:<pre class="source code">
@Composable
fun ItemCountScreen(onButtonClick: (String) -&gt; Unit) {
    var state by remember {
        mutableStateOf(ItemCountScreenState())
    }
    ItemCountScreenContent(state, {
        state = state.copy(itemCount = it)
    }, {
        onButtonClick(state.itemCount)
    })
}</pre></li>
				<li>Create a new Kotlin file called <code>ItemScreen</code>.</li>
				<li>In that file, create a new class called <code>ItemScreenState</code>:<pre class="source code">
data class ItemScreenState(
    val items: List&lt;String&gt; = emptyList()
)</pre></li>
				<li>In the same file, create a<a id="_idIndexMarker772"/> new function called <code>ItemScreenContent</code>, which will use <code>OnBackgroundItemText</code>:<pre class="source code">
@Composable
fun ItemScreenContent(
    itemScreenState: ItemScreenState
) {
    LazyColumn {
        items(itemScreenState.items) { item -&gt;
            Column(modifier =
            Modifier.padding(vertical = 4.dp)) {
                OnBackgroundItemText(text = item)
            }
        }
    }
}</pre></li>
				<li>In the same file, create a new function called <code>ItemScreen</code>:<pre class="source code">
@Composable
fun ItemScreen(itemCount: String) {
    ItemScreenContent(itemScreenState =
    ItemScreenState((1..itemCount.toInt()).toList()
    .map {
        stringResource(id = R.string.item_format,
        formatArgs = arrayOf("$it"))
    }))
}</pre></li>
				<li>In the <code>MainActivity</code> file, create<a id="_idIndexMarker773"/> the <code>MyApp</code> function, which will manage our two screens defined previously:<pre class="source code">
@Composable
fun MyApp(navController: NavHostController) {
    NavHost(navController = navController,
    startDestination = "itemCountScreen") {
        composable("itemCountScreen") {
            ItemCountScreen { navController.navigate(
            "itemScreen/?itemCount=$it") }
        }
        composable(
            "itemScreen/?itemCount={itemCount}",
            arguments =
            listOf(navArgument("itemCount") {type =
            NavType.StringType })
        ) {
            ItemScreen(
                it.arguments?.getString("itemCount")
                .orEmpty()
            )
        }
    }
}</pre></li>
				<li>Finally, modify the <code>setContent</code> function <a id="_idIndexMarker774"/>so that <code>MyApp</code> will be called:<pre class="source code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContent {
            MyApplicationTheme {
                Surface(color =
                MaterialTheme.colors.background) {
                    val navController =
                        rememberNavController()
                    Column(modifier =
                        Modifier.padding(16.dp)) {
                            MyApp(navController)
                    }
                }
            }
        }
    }
}</pre></li>
			</ol>
			<p>If we run the application, we should see the following output:</p>
			<div><div><img src="img/B19411_09_03.jpg" alt="Figure 9.3 – Output of Exercise 9.03"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Output of Exercise 9.03</p>
			<p>We should be able to see the screens split in two, and on entering a number in one screen, we should transition to the other screen with a generated list of items. We should also see the newly <a id="_idIndexMarker775"/>defined styles for the <code>Text</code> functions. We should be able to control these styles only from the <code>Elements</code> class and cause no modifications to the screens themselves.</p>
			<p>In this section, we have learned how to apply theming to an application and how we can create multiple screens and navigate between them using Jetpack Compose. In the section that follows, we will look at how we can integrate Compose into an existing project and how well it can be integrated with other popular libraries.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor508"/>Adding Compose to existing projects</h1>
			<p>In this section, we will look<a id="_idIndexMarker776"/> at what options we have in terms of introducing Jetpack Compose into an existing Android application and how to get Compose to work with different libraries.</p>
			<p>When using Jetpack Compose, you should ideally have a small number of activities, or one if possible, and have all your screens built using Compose. For an existing project to be able to achieve this, it would need to start at the bottom of the <code>View</code> hierarchy, meaning that your existing views should start being migrated to be built in Compose.</p>
			<p>To facilitate this transition, Jetpack<a id="_idIndexMarker777"/> Compose offers the possibility of using <code>ComposeView</code> in your XML layout, as in the following example:</p>
			<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android=
      "http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;
    &lt;androidx.compose.ui.platform.ComposeView
        android:id="@+id/compose_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" /&gt;
&lt;/LinearLayout&gt;</pre>
			<p>Here, we have an existing layout that will need to include a view that was defined using Jetpack Compose. In the layout XML file, we can put a <code>ComposeView</code> placeholder of where our view would live, and then in the Kotlin code, we can include the Compose user interface element:</p>
			<pre class="source code">
class MyFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(
        R.layout.my_fragment_layout, container).apply {
            findViewById&lt;ComposeView&gt;(R.id.compose_view)
            .apply {
                setViewCompositionStrategy(
                ViewCompositionStrategy
                .DisposeOnViewTreeLifecycleDestroyed)
                setContent {
                    MaterialTheme {
                        Text("My Text")
                    }
                }
            }
        }
    }
}</pre>
			<p>In this example, <code>Fragment</code> inflates the XML layout, looks up <code>ComposeView</code>, and marks the Compose content to be<a id="_idIndexMarker778"/> destroyed when the <code>View</code> of <code>Fragment</code> is also destroyed to prevent any leaks, and then sets the content of <code>ComposeView</code> to be <code>Text</code>.</p>
			<p>When we want to go the opposite route and add Android views into the Compose code, then we have the option of using <code>AndroidView</code>:</p>
			<pre class="source code">
@Composable
fun MyCustomisedElement(text: String) {
    AndroidView(factory = { context -&gt;
        TextView(context).apply {
            this.text = text
        }
    })
}</pre>
			<p>In this example, we have defined a new <code>@Composable</code> function called <code>MyCustomisedElement</code>, which will invoke <code>AndroidView</code>, which in turn will create a <code>TextView</code> on which it will set the text we have defined as a parameter.</p>
			<p>As we’ve seen in previous sections, we can use <code>LocalContext.current</code> to obtain a <code>Context</code> reference. This allows us to perform actions such as starting activities and services and showing <code>Toasts</code>.</p>
			<p>Compose is also able to<a id="_idIndexMarker779"/> interact with other libraries that are useful when building Android applications. We will analyze these libraries in the chapters that follow, but now, we will look at how they work with Jetpack Compose:</p>
			<ul>
				<li>The <code>ViewModel</code> library is useful for keeping data across configuration changes in our Activities and Fragments and helps to make our code more testable. Compose can obtain references to <code>ViewModel</code> objects through the <code>@Composable</code> function called <code>viewModel</code>:<pre class="source code">
@Composable
fun MyScreen(viewModel: MyViewModel = viewModel()) {
    Text(text = viewModel.myText)
}</pre></li>
			</ul>
			<p>Here, we call <code>viewModel</code> to obtain a reference to <code>MyViewModel</code> and set <code>Text</code> with the value that <code>viewModel</code> was holding.</p>
			<ul>
				<li>Data stream libraries are useful in combination with the <code>ViewModel</code> library, as when we want to load data asynchronously from the internet or the local filesystem, we will need to notify the user interface that the data was loaded.</li>
			</ul>
			<p>Common data stream libraries are LiveData, RxJava, and Coroutines and Flows. We’ve seen that Compose uses a <code>State</code> object when we want to manage the state of the user interface. For each of the three libraries, Compose provides extension libraries in which a stream of data is converted into a <code>State</code> object:</p>
			<pre class="source code">
@Composable
fun MyScreen(viewModel: MyViewModel = viewModel()) {
    viewModel.myLiveData.observeAsState()?.let{
    myLiveDataText-&gt;
        Text(text = myLiveDataText)
    }
    viewModel.myObservable.subscribeAsState()?.let{
     myObservableText-&gt;
        Text(text = myObservableText)
    }
    viewModel.myFlow.collectAsState()?.let{
    myFlowText-&gt;
        Text(text = myFlowText)
    }
}</pre>
			<p>In this example, our <code>viewModel</code> object would have each of the data streams that would hold a string. For each of the streams, Compose calls the equivalent method to subscribe<a id="_idIndexMarker780"/> and monitor for changes in the value of the string. When a new value is emitted for each stream, then Compose sets it in the <code>Text</code>.</p>
			<ul>
				<li>Hilt is a dependency injection library designed for Android app development. If the <code>navigation</code> library is not present in the project, then using the <code>viewModel</code> function described previously should be enough to obtain a reference to your <code>ViewModel</code>; however, if the <code>navigation</code> library is present, then a library that makes <code>hilt</code> and <code>navigation</code> work together also needs to be included:<pre class="source code">
implementation 'androidx.hilt:hilt-navigation-compose:1.0.0'</pre></li>
			</ul>
			<p>To obtain references to <code>ViewModel</code> objects in the Compose code, we will need to replace the invocation to <code>viewModel</code> with an invocation to <code>hiltViewModel</code>.</p>
			<p>You can find more information<a id="_idIndexMarker781"/> about integrating Jetpack Compose into your Android application at <a href="https://developer.android.com/jetpack/compose">https://developer.android.com/jetpack/compose</a>, and about compatibility with other libraries here: <a href="https://developer.android.com/jetpack/compose/libraries">https://developer.android.com/jetpack/compose/libraries</a>.</p>
			<p>In this section, we have looked at how we can integrate the Jetpack Compose library and make it work with existing <code>View</code> objects and existing libraries in the project.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor509"/>Activity 9.01 – first Compose app</h2>
			<p>Create a new app using Jetpack Compose, which will have three screens:</p>
			<ul>
				<li>The <strong class="bold">insert rows</strong> screen will have <a id="_idIndexMarker782"/>a title, a text field, and a button where a number can be inserted. When the button is clicked, then the user navigates to the next screen.</li>
				<li>The <strong class="bold">insert columns</strong> screen will have a title, a text field where a number can be inserted, and a button. When the button is clicked, then the user navigates to the next screen.</li>
				<li>A grid screen will display a grid with the number of rows and the number of columns inserted above. Each row will independently scroll using <code>LazyRow</code>, and for the columns, <code>LazyColumn</code> will be used. Each grid item will display the text <code>"</code><code>Item [row][column]"</code>.</li>
			</ul>
			<p>The first two screens will have their user interface elements using the same styling for the titles, text fields, and buttons, and the third screen will have a style for displaying the text in the grid.</p>
			<p>To complete this activity, you need to take the following steps:</p>
			<ol>
				<li>Create a new Android Studio project using an empty Compose Activity.</li>
				<li>Add the <code>navigation</code> library dependency to the <code>app/build.gradle</code> file.</li>
				<li>In the <code>ui.theme</code> package, create a new Kotlin file called <code>Elements</code>.</li>
				<li>In that file, create <code>@Composable</code> functions for the titles used in the application.</li>
				<li>In the same file, create <code>@Composable</code> functions for the text fields used in the application.</li>
				<li>In the same file, create <code>@Composable</code> functions for the grid items.</li>
				<li>In the same file, create <code>@Composable</code> functions for the buttons.</li>
				<li>Create a new Kotlin file called <code>InsertRowsScreen</code>.</li>
				<li>Create <code>InsertRowsScreenState</code>, <code>InsertRowsScreenContent</code>, and <code>InsertRowsScreen</code>, which will be responsible for holding the screen state and the screen<a id="_idIndexMarker783"/> content and for managing the screen state.</li>
				<li>Create a new Kotlin file called <code>InsertColumnsScreen</code>.</li>
				<li>Create <code>InsertColumnsScreenState</code>, <code>InsertColumnsScreenContent</code>, and <code>InsertColumnsScreen</code>, which will be responsible for holding the screen state and the screen content and for managing the screen state.</li>
				<li>Create a new Kotlin file called <code>GridScreen</code>.</li>
				<li>Create <code>GridScreenState</code>, <code>GridScreenContent</code>, and <code>GridScreen</code>, which will be responsible for holding the screen state and the screen content and for managing the screen state.</li>
				<li>In <code>MainActivity</code>, create <a id="_idIndexMarker784"/>a new function that will set up the navigation between your screens.</li>
				<li>In <code>MainActivity</code>, modify the <code>setContent</code> method block to invoke the function created previously.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="https://packt.link/Le1jE">https://packt.link/Le1jE</a>.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor510"/>Summary</h1>
			<p>In this chapter, we looked at how we can build user interfaces using Jetpack Compose. We started by creating simple user interface elements, and we looked at how we can make an entire screen using <code>@Composable</code> functions without any XML code.</p>
			<p>Then, we analyzed state management and how we can handle user input, and looked at patterns such as state hoisting, in which we keep our functions as stateless as possible to increase reusability. We then looked at how we can define our own user interface elements and apply themes and styles to them, which allows us to change the entire look of an application without modifying the screens that use the changed elements.</p>
			<p>Finally, we looked at how we can add Compose to an existing project and how Compose interacts with popular libraries used for app development. In the chapter’s activity, we applied all these concepts and created an application with a consistent user interface definition with multiple screens defined in Compose.</p>
			<p>In the next chapter, we will analyze how we can test our code on Android and look at some popular libraries we can use to achieve this.</p>
		</div>
		<div><div></div>
		</div>
	

		<div><h1 id="_idParaDest-153"><a id="_idTextAnchor511"/>Part 3: Testing and Code Structure</h1>
			<p>In this part, we will look at how we can structure our code to make it testable and the types of testing we can do in the code base. The Android Architecture Components will be used to assist in code structuring by separating code that performs tasks that can be tested from code that interacts with the user interface, which is harder to test.</p>
			<p>We will then look at the available options we have with regard to saving data on the device. Finally, we will explore how we can manage the dependencies inside the application with the help of dependency injection.</p>
			<p>We will cover the following chapters in this section:</p>
			<ul>
				<li><a href="B19411_10.xhtml#_idTextAnchor512"><em class="italic">Chapter 10</em></a>, <em class="italic">Unit Tests and Integration Tests with JUnit, Mockito, and Espresso</em></li>
				<li><a href="B19411_11.xhtml#_idTextAnchor582"><em class="italic">Chapter 11</em></a>, <em class="italic">Android Architecture Components</em></li>
				<li><a href="B19411_12.xhtml#_idTextAnchor638"><em class="italic">Chapter 12</em></a>, <em class="italic">Persisting Data</em></li>
				<li><a href="B19411_13.xhtml#_idTextAnchor695"><em class="italic">Chapter 13</em></a>, <em class="italic">Dependency Injection with Dagger, Hilt, and Koin</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>