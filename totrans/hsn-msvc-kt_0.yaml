- en: Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this book, we have learned a vast set of technologies and
    tools that allowed us to create microservices with Kotlin using the Spring Framework;
    however, this is not a simple task. When we apply what we have learned in our
    own project, there will always be an infinite amount of approaches that we could
    choose, and some may work better than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will try to learn industry best practices, which will allow
    us to improve the overall quality of our microservices. In this chapter, you will
    learn more about:'
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin idioms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kotlin idioms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin provides a set of idioms that allows us to drastically reduce the amount
    of boilerplate code. Boilerplate refers to sections of code that have to be included
    in many places with little or no alteration. In this section, we will learn some
    of the most used idioms.
  prefs: []
  type: TYPE_NORMAL
- en: Inferred types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may have a function written that returns a value, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are explicitly indicating the type of the result of the function and
    the internal variable that we use inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, we could infer the type of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And even the return type of our function could be inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be extremely useful as the code that we created with the inferred
    type did not need to change if we change the type it uses. Let''s clarify this
    with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change our `foo` method to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `bar` method needs to be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if our methods were declared like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we could simply change the result of `foo` without affecting `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering that we have a simple function to return some value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be used as an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, we could infer the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Other statements could be used as an expression, for example, if we have this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We could convert it into an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But Kotlin has the `when` expression that could be used in the same way as
    Java `switch`/`case`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be applied to other expressions such as `try`/`catch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin allows us to specify default parameters when declaring functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be used as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering that we just use a range of numbers that we cycle in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use a lambda to access them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'But lambda could be easily shortened with the inferred `it` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And we don''t really need a variable for `it`, so we could simplify it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But since we just print the elements of `forEach`, we could just use a method
    reference instead of the lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These were just some examples of some of the Kotlin idioms, but there are dozens
    more, and we strongly recommend you check the official Kotlin documentation to
    review them all to keep you up to date with new additions that appear as the language
    evolves: [https://kotlinlang.org/docs/reference/idioms.html](https://kotlinlang.org/docs/reference/idioms.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Spring context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring application context is where our beans are referenced to be used
    in our application, and managing it correctly is not a simple task. When we have
    dozens of beans created, where and how we access them is important, and we could
    end up in a situation that we refer to as an incorrect bean.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss ways to handle this complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have used `@Autowired` in our examples to illustrate how we
    ask Spring to inject a bean into our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example of two services and a controller that uses them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`CustomerController` injects the `CustomerService` bean using the `@AutoWired`
    annotation, and `CustomerService` injects the `AccountService` using the `@Autowired`
    annotation as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These services use a couple of data classes that we created for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `@AutoWired`, we could inject our services as part of the
    constructor of the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When Spring is creating our `CustomerController`, it will detect that the parameter
    in the constructor, `CustomerService`, is actually a bean that exists in the context
    so it will inject while creating the `CustomerController`. Exactly the same will
    happen when the `CustomerService` is created with the `AccountService` being injected.
  prefs: []
  type: TYPE_NORMAL
- en: This will improve a couple of things; first, it will become clearer what is
    required in our components just by looking at the constructor, the second autowired
    required a `var`, a mutable object, with constructor injection we could use `val`,
    an immutable object that could not be changed later on.
  prefs: []
  type: TYPE_NORMAL
- en: Having our objects as immutable allows us to prevent problems when creating
    concurrent applications such as microservices. They could also have a positive
    impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit context configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have used `@Component` or `@Service` to declare our beans that later
    on, when the SpringBoot application starts, will add to the Spring context by
    the component scan. However, we may want to explicitly declare our beans using
    a `Configuration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we now have a constructor injection, we need to specify our bean declaration
    to receive as a parameter the bean that we need, so we could send it to the constructor
    of the method. Then, we could remove the `@Service` from our service since we
    don''t need the component scan created then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we could move the `application` class and the `ContextConfiguration`
    class to a separate package, which will prevent the component scan from picking
    any other annotated class and adding it as a bean, and to do this, we have an
    explicit context configuration that tells us exactly what we need in our context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.gif)'
  prefs: []
  type: TYPE_IMG
- en: Application package
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the component scan loads our `ContextConfiguration` class when
    the application is launched and then we will create our beans.
  prefs: []
  type: TYPE_NORMAL
- en: Having an explicit context allows us to avoid situations that could be very
    complicated to handle, such as getting the right bean when we have a large number
    of classes. We are not saying that we need to avoid the component scan completely,
    but we need to use it cautiously.
  prefs: []
  type: TYPE_NORMAL
- en: Decouple services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that we may overlook is that our controller and service have a dependency
    on the actual implementation. This means that if we have an implementation change
    tomorrow, for example, moving from a database into a different mechanism, we need
    to change who uses it, so to avoid that, we will create interfaces for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will rename our `CustomerService` to `CustomerServiceImpl`, and our
    `AccountService` to `AccountServiceImpl`; then, we will create our interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to change our `CustomerController` and `ContextConfiguration`
    to refer to the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we need to change our implementation of the services, we only need to
    change our context configuration; the rest of the application will be unchanged.
    Another effect on this change is that now our services may not have any Spring
    dependent code, and this could be great as if tomorrow we need to move them to
    a different framework, we may do it seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that avoiding coupling should be one of our principles when we create
    microservices, as it is in any software that we build.
  prefs: []
  type: TYPE_NORMAL
- en: Layering the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our application grows, it is going to be more complex to manage the large
    number of classes that we may end up with. And if we haven't taken care of our
    application structure, we may end in a situation that may not find the class that
    we need when we are looking for it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will propose a structure for layering our application and
    packaging the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding our classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first look at our current classes in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.gif)'
  prefs: []
  type: TYPE_IMG
- en: Current application structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, if we look at the preceding image of our classes to understand what
    domain they may refer to, we could divide them into two domains:'
  prefs: []
  type: TYPE_NORMAL
- en: Customer-related classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account-related classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But if we look at the same image to understand what our classes are, we can
    classify them into various groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Application classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context configuration classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services implementation classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controllers classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's think how we can arrange them using those groups and domains.
  prefs: []
  type: TYPE_NORMAL
- en: Domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create two domains and place our classes inside, and we already have
    an `application` package that we could use to store our application classes that
    don''t belong to a particular domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.gif)'
  prefs: []
  type: TYPE_IMG
- en: This does look better, however, we may not need to have a `domains` package,
    though it may be handy if we have more things to add to our structure.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we could split them into the domain based on what they are used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.gif)'
  prefs: []
  type: TYPE_IMG
- en: final packages
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created separate packages for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: Our domain model objects such as our data classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services`: Our services with the business logic on that domain, we may want
    to split the implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controllers`: Our controllers that expose our model and use the services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these packages could grow if there are more model, services, or controllers
    classes to add.
  prefs: []
  type: TYPE_NORMAL
- en: Having our application layered in a way that we can understand is key for our
    microservice, however, no structure is perfect and you should decide which way
    you want to structure yours. It may differ from this structure, but remember that
    it is not only for you, anyone in your project should understand the used structure
    and if you are thinking about making your project or application **Open Source
    Software** (**OSS**), you may want to add this to your contributing documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is one of the most important elements of modern software development,
    and you should take care of it right at the beginning when you start to design
    your microservice. In this section, we will try to guide you with some suggestions
    on how to effectively test your microservice, however, really understanding testing
    requires a deeper look that you should cover eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several kinds of tests that you can carry out on microservices, but
    here are some of the most common ones that you should understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is important to us because we should name our test according to what they
    are, either by naming the test class with the name of the type of test or classifying
    the package that refers to that type of test.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have one Integration test for our controller that is named
    `CustomerControllerTest`, we could name it `CustomerControlIntegrationTest`, `CustomerControllerIT`,
    or leave it in the package `com.microservices.test.integration`.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying our test correctly allows us to easily understand what kind of test
    it is when a test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review the different types of test so we have a clear understanding of
    how to name or place ours.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: They should focus on testing small units (typically a class or a complex algorithm).
    They should be tested in isolation and independent of other units. They should
    be fast, not more than a few seconds to provide immediate feedback. With these
    tests, we could refactor our code with confidence, making small changes and running
    the tests constantly.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests test different components of our software to test if they
    work correctly in combination. Our classes may work in isolation, but they may
    fail when tested together.
  prefs: []
  type: TYPE_NORMAL
- en: E2E tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**End-to-End** (**E2E**) tests try to prove that each complete functionality
    works, from an end-user perspective. If we are running a microservice that exposes
    an API, we may test the different methods as we would do with an external application
    that was invoking us.'
  prefs: []
  type: TYPE_NORMAL
- en: Other tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many other types of tests, but they maybe be a subcategorization
    of the previously defined types. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System test**: An Integration test that tries to check if the integration
    with another system actually works'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance or functional test**: These are usually E2E tests that we use
    to validate that our software is working as the user specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoke or sanity test**: Usually an Integration or E2E test, created to verify
    that the most important parts of our application are still working before releasing
    the software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security tests**: Usually an E2E or Integration test that tries to prove
    how secure our software is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we test our microservices, we may choose to use a different kind of test,
    but many parts of the software could be tested in different kinds of tests. For
    example, when we create a customer, we may test this using a **Unit** test on
    the service that creates them, however, we could also test it using an **Integration**
    test or even an **E2E** test. It is a common understanding in the industry that
    we should approach testing using the test pyramid that indicates how many tests
    of each type we should have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test pyramid
  prefs: []
  type: TYPE_NORMAL
- en: The overall idea is that we should do as much testing as we can using a Unit
    test, this will provide more immediate feedback. Unit tests are easy to develop
    and maintain and we can go there with all different kinds of conditions and scenarios
    that our unit allows us. However, we may also need to test how our units are integrated,
    so we need an Integration test that only tests that integration, and all the logic
    that is already tested in the unit should be retested.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you do a Unit test for a service covering all the different
    business rules that return just a result of an error, in an Integration test,
    for a component that uses the service, you should only test that result or error
    from the service and not duplicate all the tests done previously in the Unit tests.
    Finally, we should carry out our E2E test covering the complete scenarios, not
    just those defined in our requirements, regardless of how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Google Testing blog suggests a 70/20/10 split: 70% Unit tests, 20% Integration
    tests, and 10% End-to-End tests, you may consider these numbers when doing testing
    for your microservices. Refer to the following site for more details: [https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html.](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should try to do **Test Driven Development** (**TDD**) when we create our
    microservices. TDD will not only help us to ensure that our microservices are
    tested correctly, it will guide the design of our microservices to a better implementation.
    The overall idea for doing TDD is that you start writing a test first that will
    fail since there is no code for it yet, this test will be red. Then you move to
    implement just the minimum code to make the test pass, the test will be green.
    Then you refactor your code to improve it and rerun the test to check that it
    is working again, and if not, fix it. You then write another test, for example,
    to make another change in your code and repeat the cycle as before. These short
    cycles of red-green-refactor are what makes a TDD great.
  prefs: []
  type: TYPE_NORMAL
- en: For a microservice, you may start doing a test for a controller that may not
    exist, then implement the controller to return just the data, then you may create
    a test for a service that will do what the controller needs, and implement the
    service. Next, you could move to modify your controller and you would still have
    the test originally created to verify that everything works as defined.
  prefs: []
  type: TYPE_NORMAL
- en: Other great advantages of this are that whatever you need in your application,
    it will become apparent when you need it rather than creating a service (and related
    components) before they are required; this is a great way to do lean software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we could not cover the full scope of TDD during this book, but
    we encourage you to find out more about it and try to bring this discipline when
    you write your own microservices. You could look at this small article from Martin
    Fowler's blog to get you started, [https://martinfowler.com/bliki/TestDrivenDevelopment.html](https://martinfowler.com/bliki/TestDrivenDevelopment.html),
    but we really recommend that you read Kent Beck's book, *Test-Driven Development*.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use **Behavior-Driven Development** (**BDD**) when you carry out
    tests on your microservices. BDD is a software development process that emerged
    from TDD, with ideas from domain-driven design and object-oriented analysis and
    design to provide software development and management teams with shared tools
    and a shared process to collaborate on software development.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that the requirements from your software are created by the team,
    including the domain experts defining how the application should behave. This
    is done using a behavioral specification that uses the ubiquitous language from
    our domain model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of such a specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This describes our requirements that it will be written before we build our
    microservices, and since we will use our ubiquitous language, the whole team could
    work together defining the specification. Then, we can use tools such as **Cucumber**
    to literally read that specification and create a test that validates it. Finally,
    we can use TDD for the code that makes those test pass and do our red-green-refactor
    cycles. Making tests like this will be great as we will have tests that everyone
    can contribute to, including our domain experts and the team as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cucumberâ€“JVM provides an excellent framework for doing BDD tests, and since
    they run in the JVM, we could create them in Kotlin. Refer to the following website
    for more details: [https://cucumber.io/docs/reference/jvm.](https://cucumber.io/docs/reference/jvm)'
  prefs: []
  type: TYPE_NORMAL
- en: Handling CI and CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Continuous Integration and Continuous Delivery to our microservice will
    allow us to deliver our application at the fastest pace with great quality and
    is something that we should look for when we create our microservices. In this
    section, we will discuss some practices that you should consider when doing Continuous
    Integration and Continuous Delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining your software working is not always easy, especially when you have
    several developers working on the same code base. **Continuous Integration** (**CI**)
    allows us to minimize the problems when working with our software. The main idea
    behind CI is that every single time that we push code to our repository, our tests
    runs, and this allows us to know if the change that we just made has broken our
    application, even if what is broken was not actually in the code that was modified.
  prefs: []
  type: TYPE_NORMAL
- en: This minimizes the problems of integrating software in a code base if someone
    pushes a piece of software that is faulty, we can fix it and get it back working.
    And this is something that we should target to do all the time, as having a working
    software on our repository allows us to release as often as we can to get feedback,
    and feedback is what makes software better.
  prefs: []
  type: TYPE_NORMAL
- en: We may think that we shouldn't commit software until everything is ready, and
    that has been proved to be a painful approach which pushes dozen of changes to
    our code base to find out that it could not integrate with the rest. This is something
    that we should avoid. CI allows us to integrate the software while we are writing
    it, so we never end up in the situation where we have software completed that
    actually is not, because it is not working with the rest of our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Try to commit small, and try to commit often; this allows you to go back and
    fix things until they are integrated without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we have CI working, we are only one step away from **Continuous Delivery**
    (**CD**), but sometimes that step is not a short step. However, we should always
    try to move in that direction regardless. We could have a working software in
    our integration environment, but if it takes weeks to be available at our end,
    we are not giving the users the value that our application should give.
  prefs: []
  type: TYPE_NORMAL
- en: In CD, we will try to automate the whole process to get our software from our
    code base into a live application, with all the steps that we could need. This
    could go from having our infrastructure created and configured, to our application
    being tested, deployed, or even verified and a range of things in-between, with
    the minimum, or non-manual intervention. The goal is simple from a developer pushing
    a change in our repository to getting the application live to end users.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing is really done until it is available to end users. This is how we give
    value to our applications, and we like to do it often, and for the best quality,
    we must do CD.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To do proper CI and CD, we need a pipeline tool that allows us to handle this
    process, something that enables us to pick up our changes, build our software,
    run the test, deploy the application, or any steps that we require in-between.
    And if something fails, our pipeline could notify us, so we can react and correct
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: There is a huge range of tools to do pipelines, but we recommend you look at
    tools such as Jenkins (probably the most popular tool), or others such as Concourse,
    Bamboo Gitlab CI, Travis CI, Drone, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Do not just go to Jenkins because it is what everyone else does. There are many
    tools and many of them as good or even better than Jenkins; try some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a pipeline running is great, but if our build is not working, or our
    tests aren't running, we need to know about it and react. Most pipelines provide
    systems which give notifications, for example, sending emails or posting in programs
    like Slack, but most of them provide tools to create a dashboard as well.
  prefs: []
  type: TYPE_NORMAL
- en: A dashboard from a pipeline should visualize the different stages that we do,
    from building our software to launching our test or deployments, and usually are
    color coded with the standard work green, broken red. If we have a dashboard,
    we could just display it somewhere that the team could use to see if the pipeline
    is working and fix it where needed. Our pipeline dashboard could also be easily
    integrated with our application monitoring to have a centralized view of what
    is going on with our application.
  prefs: []
  type: TYPE_NORMAL
- en: It is a whole team responsibility to fix broken builds, and we need to encourage
    them to understand why. It is in our application's best interest to have a pipeline
    working so that we can deliver often and with confidence to our end users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this book, we have covered what microservices are, and
    the benefits that they bring to our applications. Now we can design them with
    the best principles in the industry that allow us to have an architecture that
    evolves as our products do. We learned how the Spring Framework could easily be
    integrated with Kotlin, providing excellent tools to build microservices. During
    this process, we realized the advantages of using a modern programming language
    such as Kotlin to deliver high-quality software. And remember that we have just
    started creating some RESTFul APIs that eventually can become reactive microservices
    used in a NoSQL database such as MongoDB with the best performance of non-blocking
    operations. Then, we learned how to create containers and clouds, and how we can
    scale our applications when required.
  prefs: []
  type: TYPE_NORMAL
- en: But we need software that gives us confidence, so we learned how our tests not
    only give a guarantee that our requirements are met, but they act as a live documentation
    that anyone in our team can use to understand our applications. And when our application
    reaches production, we can use what we have learned to have production-ready alerts
    and monitoring that could be used to control and manage our microservices, even
    in the worst scenarios. Finally, we learned how we can use industry best practices
    when creating microservices in Kotlin to provide the best value to our end users.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be more than ready to start building your own microservices
    with Kotlin and the Spring Framework with the best techniques available to you.
  prefs: []
  type: TYPE_NORMAL
