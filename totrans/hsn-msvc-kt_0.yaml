- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: During the course of this book, we have learned a vast set of technologies and
    tools that allowed us to create microservices with Kotlin using the Spring Framework;
    however, this is not a simple task. When we apply what we have learned in our
    own project, there will always be an infinite amount of approaches that we could
    choose, and some may work better than others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们学习了许多技术和工具，这些技术和工具使我们能够使用Spring框架用Kotlin创建微服务；然而，这并不是一个简单的任务。当我们将所学应用于自己的项目时，我们总会有一系列无限多的方法可以选择，其中一些可能比其他方法更有效。
- en: 'In this chapter, we will try to learn industry best practices, which will allow
    us to improve the overall quality of our microservices. In this chapter, you will
    learn more about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试学习行业最佳实践，这将使我们能够提高微服务的整体质量。在本章中，你将了解更多关于：
- en: Kotlin idioms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin惯用法
- en: Spring Context
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring上下文
- en: Layering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层
- en: Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Continuous Integration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous Delivery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付
- en: Using Kotlin idioms
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin惯用法
- en: Kotlin provides a set of idioms that allows us to drastically reduce the amount
    of boilerplate code. Boilerplate refers to sections of code that have to be included
    in many places with little or no alteration. In this section, we will learn some
    of the most used idioms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin提供了一套惯用法，使我们能够大幅减少样板代码的数量。样板代码指的是那些需要在多个地方包含且几乎不需要修改的代码段。在本节中，我们将学习一些最常用的惯用法。
- en: Inferred types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推断类型
- en: 'We may have a function written that returns a value, such as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个返回值的函数，例如：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we are explicitly indicating the type of the result of the function and
    the internal variable that we use inside.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确指出了函数的结果类型以及我们内部使用的变量类型。
- en: 'In Kotlin, we could infer the type of the variable:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以推断变量的类型：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And even the return type of our function could be inferred:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至我们函数的返回类型也可以被推断出来：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will be extremely useful as the code that we created with the inferred
    type did not need to change if we change the type it uses. Let''s clarify this
    with an example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将非常有用，因为我们用推断类型创建的代码在改变其使用的类型时不需要更改。让我们用一个例子来澄清这一点：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we change our `foo` method to:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的`foo`方法改为：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our `bar` method needs to be changed to:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`bar`方法需要更改：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, if our methods were declared like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的方法声明如下：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we could simply change the result of `foo` without affecting `bar`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地更改`foo`的结果而不影响`bar`：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Expressions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Considering that we have a simple function to return some value:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们有一个简单的函数用于返回某个值：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It could be used as an expression:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用作表达式：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And, of course, we could infer the type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以推断类型：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Other statements could be used as an expression, for example, if we have this
    function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语句也可以用作表达式，例如，如果我们有这个函数：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We could convert it into an expression:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其转换为表达式：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But Kotlin has the `when` expression that could be used in the same way as
    Java `switch`/`case`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但Kotlin有`when`表达式，它可以像Java的`switch`/`case`一样使用：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This could be applied to other expressions such as `try`/`catch`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以应用于其他表达式，例如`try`/`catch`：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Default parameters
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'Kotlin allows us to specify default parameters when declaring functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin允许我们在声明函数时指定默认参数：
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This could be used as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来：
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lambda
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda
- en: 'Considering that we just use a range of numbers that we cycle in a loop:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们只是使用循环中循环的数字范围：
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We could use a lambda to access them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用lambda来访问它们：
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But lambda could be easily shortened with the inferred `it` object:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但lambda可以用推断的`it`对象轻松缩短：
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And we don''t really need a variable for `it`, so we could simplify it with:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们实际上不需要`it`变量，所以我们可以简化它：
- en: '[PRE20]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But since we just print the elements of `forEach`, we could just use a method
    reference instead of the lambda:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我们只是打印`forEach`的元素，我们可以直接使用方法引用而不是lambda：
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These were just some examples of some of the Kotlin idioms, but there are dozens
    more, and we strongly recommend you check the official Kotlin documentation to
    review them all to keep you up to date with new additions that appear as the language
    evolves: [https://kotlinlang.org/docs/reference/idioms.html](https://kotlinlang.org/docs/reference/idioms.html).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是Kotlin惯用法的几个例子，但还有更多，我们强烈建议你查看官方Kotlin文档以查看所有内容，并保持与语言演变中出现的新增功能同步：[https://kotlinlang.org/docs/reference/idioms.html](https://kotlinlang.org/docs/reference/idioms.html)。
- en: Managing the Spring context
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Spring上下文
- en: The Spring application context is where our beans are referenced to be used
    in our application, and managing it correctly is not a simple task. When we have
    dozens of beans created, where and how we access them is important, and we could
    end up in a situation that we refer to as an incorrect bean.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序上下文是我们bean被引用以在应用程序中使用的地方，正确管理它不是一项简单的任务。当我们有数十个bean被创建时，我们如何访问它们以及在哪里访问它们很重要，我们可能会陷入我们称之为不正确bean的情况。
- en: In this section, we will discuss ways to handle this complexity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论处理这种复杂性的方法。
- en: Constructor injection
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: In this book, we have used `@Autowired` in our examples to illustrate how we
    ask Spring to inject a bean into our application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经在示例中使用了`@Autowired`来展示我们如何请求Spring将bean注入到我们的应用程序中。
- en: 'Consider this example of two services and a controller that uses them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个服务和使用它们的控制器的示例：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`CustomerController` injects the `CustomerService` bean using the `@AutoWired`
    annotation, and `CustomerService` injects the `AccountService` using the `@Autowired`
    annotation as well.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController`使用`@AutoWired`注解注入`CustomerService` bean，而`CustomerService`也使用`@Autowired`注解注入`AccountService`。'
- en: 'These services use a couple of data classes that we created for this example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务使用了一些我们为这个示例创建的数据类：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Instead of using `@AutoWired`, we could inject our services as part of the
    constructor of the classes:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用`@AutoWired`，而是将我们的服务作为类构造函数的一部分进行注入：
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When Spring is creating our `CustomerController`, it will detect that the parameter
    in the constructor, `CustomerService`, is actually a bean that exists in the context
    so it will inject while creating the `CustomerController`. Exactly the same will
    happen when the `CustomerService` is created with the `AccountService` being injected.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring创建我们的`CustomerController`时，它会检测到构造函数中的参数`CustomerService`实际上是一个存在于上下文中的bean，因此它会在创建`CustomerController`时进行注入。当使用`AccountService`进行注入创建`CustomerService`时，也会发生完全相同的情况。
- en: This will improve a couple of things; first, it will become clearer what is
    required in our components just by looking at the constructor, the second autowired
    required a `var`, a mutable object, with constructor injection we could use `val`,
    an immutable object that could not be changed later on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改善几个方面；首先，通过查看构造函数，我们可以更清楚地了解我们的组件需要什么，第二个自动注入需要一个`var`，一个可变对象，使用构造函数注入，我们可以使用`val`，一个不可变对象，之后不能被更改。
- en: Having our objects as immutable allows us to prevent problems when creating
    concurrent applications such as microservices. They could also have a positive
    impact on performance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的对象作为不可变对象，可以防止在创建并发应用程序（如微服务）时出现问题时。它们也可能对性能产生积极影响。
- en: Explicit context configuration
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确上下文配置
- en: 'So far, we have used `@Component` or `@Service` to declare our beans that later
    on, when the SpringBoot application starts, will add to the Spring context by
    the component scan. However, we may want to explicitly declare our beans using
    a `Configuration` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用`@Component`或`@Service`来声明我们的bean，然后在SpringBoot应用程序启动时，通过组件扫描将它们添加到Spring上下文中。然而，我们可能希望显式地使用`Configuration`类来声明我们的bean：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we now have a constructor injection, we need to specify our bean declaration
    to receive as a parameter the bean that we need, so we could send it to the constructor
    of the method. Then, we could remove the `@Service` from our service since we
    don''t need the component scan created then:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了构造函数注入，我们需要指定我们的bean声明以接收我们需要的bean作为参数，然后我们可以将其发送到方法的构造函数中。然后，我们可以从我们的服务中移除`@Service`，因为我们不需要创建时的组件扫描：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we could move the `application` class and the `ContextConfiguration`
    class to a separate package, which will prevent the component scan from picking
    any other annotated class and adding it as a bean, and to do this, we have an
    explicit context configuration that tells us exactly what we need in our context:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将`application`类和`ContextConfiguration`类移动到单独的包中，这将防止组件扫描选择任何其他注解类并将其添加为bean，为此，我们有一个显式的上下文配置，它确切地告诉我们上下文中需要什么：
- en: '![](img/00069.gif)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.gif)'
- en: Application package
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包
- en: In this example, the component scan loads our `ContextConfiguration` class when
    the application is launched and then we will create our beans.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，组件扫描在应用程序启动时加载我们的`ContextConfiguration`类，然后我们将创建我们的bean。
- en: Having an explicit context allows us to avoid situations that could be very
    complicated to handle, such as getting the right bean when we have a large number
    of classes. We are not saying that we need to avoid the component scan completely,
    but we need to use it cautiously.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的上下文允许我们避免一些可能非常复杂的情况，例如在有许多类的情况下获取正确的bean。我们并不是说我们需要完全避免组件扫描，但我们需要谨慎使用它。
- en: Decouple services
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦服务
- en: One thing that we may overlook is that our controller and service have a dependency
    on the actual implementation. This means that if we have an implementation change
    tomorrow, for example, moving from a database into a different mechanism, we need
    to change who uses it, so to avoid that, we will create interfaces for them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能忽视的一点是，我们的控制器和服务依赖于实际实现。这意味着如果我们明天有实现上的变化，例如，从数据库迁移到不同的机制，我们需要改变使用它们的人，为了避免这种情况，我们将为它们创建接口。
- en: 'First, we will rename our `CustomerService` to `CustomerServiceImpl`, and our
    `AccountService` to `AccountServiceImpl`; then, we will create our interfaces:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重命名我们的`CustomerService`为`CustomerServiceImpl`，将`AccountService`重命名为`AccountServiceImpl`；然后，我们将创建我们的接口：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have to change our `CustomerController` and `ContextConfiguration`
    to refer to the interfaces:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须更改我们的`CustomerController`和`ContextConfiguration`以引用接口：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if we need to change our implementation of the services, we only need to
    change our context configuration; the rest of the application will be unchanged.
    Another effect on this change is that now our services may not have any Spring
    dependent code, and this could be great as if tomorrow we need to move them to
    a different framework, we may do it seamlessly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要更改服务的实现，我们只需要更改我们的上下文配置；应用程序的其他部分将保持不变。这种变化的影响还包括，现在我们的服务可能不再有任何Spring依赖代码，如果明天我们需要将它们迁移到不同的框架，我们可能可以无缝地进行。
- en: Remember that avoiding coupling should be one of our principles when we create
    microservices, as it is in any software that we build.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在创建微服务时，避免耦合应该成为我们的原则之一，就像在任何我们构建的软件中一样。
- en: Layering the application
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序分层
- en: When our application grows, it is going to be more complex to manage the large
    number of classes that we may end up with. And if we haven't taken care of our
    application structure, we may end in a situation that may not find the class that
    we need when we are looking for it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序增长时，管理大量类将变得更加复杂。如果我们没有注意我们的应用程序结构，我们可能会陷入一种情况，当我们寻找它时可能找不到所需的类。
- en: In this section, we will propose a structure for layering our application and
    packaging the classes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提出一个结构来分层我们的应用程序和打包类。
- en: Understanding our classes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解我们的类
- en: 'Let''s first look at our current classes in our project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们项目中的当前类：
- en: '![](img/00070.gif)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00070.gif)'
- en: Current application structure
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当前应用程序结构
- en: 'Currently, if we look at the preceding image of our classes to understand what
    domain they may refer to, we could divide them into two domains:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果我们查看我们类的先前图像以了解它们可能引用的领域，我们可以将它们分为两个领域：
- en: Customer-related classes
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户相关类
- en: Account-related classes
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户相关类
- en: 'But if we look at the same image to understand what our classes are, we can
    classify them into various groups:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们查看相同的图像来了解我们的类，我们可以将它们分类到不同的组：
- en: Application classes
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用类
- en: Context configuration classes
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文配置类
- en: Data classes
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类
- en: Services interfaces
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务接口
- en: Services implementation classes
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务实现类
- en: Controllers classes
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器类
- en: Let's think how we can arrange them using those groups and domains.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下如何使用这些组和领域来安排它们。
- en: Domains
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域
- en: 'We can create two domains and place our classes inside, and we already have
    an `application` package that we could use to store our application classes that
    don''t belong to a particular domain:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建两个领域并将我们的类放入其中，我们已经有了一个`application`包，我们可以用它来存储不属于特定领域的应用程序类：
- en: '![](img/00071.gif)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00071.gif)'
- en: This does look better, however, we may not need to have a `domains` package,
    though it may be handy if we have more things to add to our structure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样看起来更好，但我们可能不需要有`domains`包，尽管如果我们需要向我们的结构中添加更多内容，它可能很有用。
- en: Splitting
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割
- en: 'Now, we could split them into the domain based on what they are used for:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据它们的使用情况将它们分成基于领域的部分：
- en: '![](img/00072.gif)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00072.gif)'
- en: final packages
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最终包
- en: 'We have created separate packages for:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为以下内容创建了单独的包：
- en: '`model`: Our domain model objects such as our data classes'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`：我们的领域模型对象，例如我们的数据类'
- en: '`services`: Our services with the business logic on that domain, we may want
    to split the implementation'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`：我们的服务，该领域具有业务逻辑，我们可能想要将其实现拆分'
- en: '`controllers`: Our controllers that expose our model and use the services'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`：我们暴露模型并使用服务的控制器'
- en: Each of these packages could grow if there are more model, services, or controllers
    classes to add.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多的模型、服务或控制器类要添加，这些包中的每一个都可能增长。
- en: Having our application layered in a way that we can understand is key for our
    microservice, however, no structure is perfect and you should decide which way
    you want to structure yours. It may differ from this structure, but remember that
    it is not only for you, anyone in your project should understand the used structure
    and if you are thinking about making your project or application **Open Source
    Software** (**OSS**), you may want to add this to your contributing documentation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序分层，以便我们能够理解，对于我们的微服务至关重要，然而，没有结构是完美的，你应该决定你想要的结构方式。它可能与此结构不同，但请记住，它不仅是为了你，你的项目中的任何人都应该理解所使用的结构，如果你正在考虑将你的项目或应用程序作为**开源软件**（**OSS**）发布，你可能想在贡献文档中添加这一点。
- en: Testing effectively
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效地进行测试
- en: Testing is one of the most important elements of modern software development,
    and you should take care of it right at the beginning when you start to design
    your microservice. In this section, we will try to guide you with some suggestions
    on how to effectively test your microservice, however, really understanding testing
    requires a deeper look that you should cover eventually.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是现代软件开发最重要的元素之一，你应该在开始设计你的微服务时就注意它。在本节中，我们将尝试通过一些建议来指导你如何有效地测试你的微服务，然而，真正理解测试需要更深入的研究，这是你应该最终覆盖的。
- en: Understanding type of tests
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试类型
- en: 'There are several kinds of tests that you can carry out on microservices, but
    here are some of the most common ones that you should understand:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在微服务上执行多种测试，但以下是一些你应该了解的最常见的测试类型：
- en: Unit tests
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: E2E tests
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E2E测试
- en: This is important to us because we should name our test according to what they
    are, either by naming the test class with the name of the type of test or classifying
    the package that refers to that type of test.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们很重要，因为我们应该根据它们的本质来命名我们的测试，无论是通过使用测试类名来命名测试类型，还是将引用该类型测试的包进行分类。
- en: For example, if we have one Integration test for our controller that is named
    `CustomerControllerTest`, we could name it `CustomerControlIntegrationTest`, `CustomerControllerIT`,
    or leave it in the package `com.microservices.test.integration`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个名为`CustomerControllerTest`的控制器集成测试，我们可以将其命名为`CustomerControlIntegrationTest`、`CustomerControllerIT`，或者将其留在`com.microservices.test.integration`包中。
- en: Classifying our test correctly allows us to easily understand what kind of test
    it is when a test fails.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正确分类我们的测试使我们能够轻松理解测试失败时它是哪种类型的测试。
- en: Let's review the different types of test so we have a clear understanding of
    how to name or place ours.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下不同的测试类型，以便我们清楚地了解如何命名或放置我们的测试。
- en: Unit tests
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: They should focus on testing small units (typically a class or a complex algorithm).
    They should be tested in isolation and independent of other units. They should
    be fast, not more than a few seconds to provide immediate feedback. With these
    tests, we could refactor our code with confidence, making small changes and running
    the tests constantly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它们应该专注于测试小的单元（通常是类或复杂的算法）。它们应该在隔离和独立于其他单元的情况下进行测试。它们应该快速，不超过几秒钟，以提供即时反馈。有了这些测试，我们可以有信心重构代码，进行小改动并持续运行测试。
- en: Integration tests
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests test different components of our software to test if they
    work correctly in combination. Our classes may work in isolation, but they may
    fail when tested together.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试测试我们软件的不同组件，以测试它们是否在组合中正确工作。我们的类可能单独工作，但在一起测试时可能会失败。
- en: E2E tests
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: E2E测试
- en: '**End-to-End** (**E2E**) tests try to prove that each complete functionality
    works, from an end-user perspective. If we are running a microservice that exposes
    an API, we may test the different methods as we would do with an external application
    that was invoking us.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端**（**E2E**）测试试图从最终用户的角度证明每个完整的功能都正常工作。如果我们正在运行一个暴露API的微服务，我们可能会像测试调用我们的外部应用程序一样测试不同的方法。'
- en: Other tests
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他测试
- en: 'There are many other types of tests, but they maybe be a subcategorization
    of the previously defined types. Here are some examples:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的测试，但它们可能是之前定义的类型的一个子分类。以下是一些例子：
- en: '**System test**: An Integration test that tries to check if the integration
    with another system actually works'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：一个集成测试，试图检查与其他系统的集成是否真正有效'
- en: '**Acceptance or functional test**: These are usually E2E tests that we use
    to validate that our software is working as the user specified'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收或功能测试**：这些通常是端到端测试，我们用它来验证我们的软件是否按用户指定的那样工作'
- en: '**Smoke or sanity test**: Usually an Integration or E2E test, created to verify
    that the most important parts of our application are still working before releasing
    the software'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟或健全性测试**：通常是一个集成或端到端测试，创建用来在发布软件之前验证我们应用最重要的部分是否仍然在正常工作'
- en: '**Security tests**: Usually an E2E or Integration test that tries to prove
    how secure our software is'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全测试**：通常是一个端到端或集成测试，试图证明我们的软件有多安全'
- en: Testing pyramid
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: 'When we test our microservices, we may choose to use a different kind of test,
    but many parts of the software could be tested in different kinds of tests. For
    example, when we create a customer, we may test this using a **Unit** test on
    the service that creates them, however, we could also test it using an **Integration**
    test or even an **E2E** test. It is a common understanding in the industry that
    we should approach testing using the test pyramid that indicates how many tests
    of each type we should have:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试我们的微服务时，我们可能会选择使用不同类型的测试，但软件的许多部分可以在不同类型的测试中进行测试。例如，当我们创建一个客户时，我们可能会使用创建客户的服务的**单元测试**来测试这个操作，然而，我们也可以使用**集成测试**或甚至**端到端测试**。在业界，这是一个普遍的理解，我们应该使用测试金字塔来接近测试，这个金字塔指示了我们应该有多少种类型的测试：
- en: '![](img/00073.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00073.jpeg)'
- en: Test pyramid
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: The overall idea is that we should do as much testing as we can using a Unit
    test, this will provide more immediate feedback. Unit tests are easy to develop
    and maintain and we can go there with all different kinds of conditions and scenarios
    that our unit allows us. However, we may also need to test how our units are integrated,
    so we need an Integration test that only tests that integration, and all the logic
    that is already tested in the unit should be retested.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 整体思路是我们应该尽可能多地使用单元测试来进行测试，这将提供更及时的反馈。单元测试易于开发和维护，我们可以用所有不同类型的条件和场景去测试我们的单元。然而，我们也可能需要测试我们的单元是如何集成的，因此我们需要一个只测试该集成以及所有在单元中已经测试过的逻辑的集成测试。
- en: For example, if you do a Unit test for a service covering all the different
    business rules that return just a result of an error, in an Integration test,
    for a component that uses the service, you should only test that result or error
    from the service and not duplicate all the tests done previously in the Unit tests.
    Finally, we should carry out our E2E test covering the complete scenarios, not
    just those defined in our requirements, regardless of how they are implemented.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你对一个服务进行单元测试，覆盖所有不同的业务规则，只返回一个错误结果，在集成测试中，对于一个使用该服务的组件，你应该只测试该服务的结果或错误，而不是重复之前在单元测试中做的所有测试。最后，我们应该执行我们的端到端测试，覆盖完整的场景，而不仅仅是我们在需求中定义的场景，无论它们是如何实现的。
- en: 'The Google Testing blog suggests a 70/20/10 split: 70% Unit tests, 20% Integration
    tests, and 10% End-to-End tests, you may consider these numbers when doing testing
    for your microservices. Refer to the following site for more details: [https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html.](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Google 测试博客建议采用 70/20/10 的分割：70% 单元测试，20% 集成测试，10% 端到端测试，你在为你的微服务进行测试时可以考虑这些数字。更多详情请参考以下网站：[https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)
- en: Test Driven Development
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: We should try to do **Test Driven Development** (**TDD**) when we create our
    microservices. TDD will not only help us to ensure that our microservices are
    tested correctly, it will guide the design of our microservices to a better implementation.
    The overall idea for doing TDD is that you start writing a test first that will
    fail since there is no code for it yet, this test will be red. Then you move to
    implement just the minimum code to make the test pass, the test will be green.
    Then you refactor your code to improve it and rerun the test to check that it
    is working again, and if not, fix it. You then write another test, for example,
    to make another change in your code and repeat the cycle as before. These short
    cycles of red-green-refactor are what makes a TDD great.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建微服务时，应该尝试进行**测试驱动开发**（**TDD**）。TDD不仅能帮助我们确保微服务得到正确测试，还能指导我们更好地实现微服务的设计。进行TDD的整体思路是，首先编写一个测试，由于还没有相应的代码，这个测试将会失败，这个测试将会是红色的。然后，你只需实现最少的代码来使测试通过，测试将会变成绿色。然后，你重构代码以改进它，并重新运行测试以检查它是否仍然工作，如果不工作，就修复它。然后，你编写另一个测试，例如，为了在代码中做出另一个更改，并像之前一样重复这个循环。这些红色-绿色-重构的短周期是TDD之所以出色的原因。
- en: For a microservice, you may start doing a test for a controller that may not
    exist, then implement the controller to return just the data, then you may create
    a test for a service that will do what the controller needs, and implement the
    service. Next, you could move to modify your controller and you would still have
    the test originally created to verify that everything works as defined.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务，你可能开始对一个可能不存在的控制器进行测试，然后实现控制器以返回数据，然后你可能为将执行控制器所需操作的服务创建一个测试，并实现该服务。接下来，你可以修改控制器，而你最初创建的测试仍然存在，以验证一切是否按定义工作。
- en: Other great advantages of this are that whatever you need in your application,
    it will become apparent when you need it rather than creating a service (and related
    components) before they are required; this is a great way to do lean software
    development.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的其它显著优势在于，无论你在应用中需要什么，它都会在你需要时变得明显，而不是在需要之前就创建服务（及相关组件）；这是一种做精益软件开发的好方法。
- en: Unfortunately, we could not cover the full scope of TDD during this book, but
    we encourage you to find out more about it and try to bring this discipline when
    you write your own microservices. You could look at this small article from Martin
    Fowler's blog to get you started, [https://martinfowler.com/bliki/TestDrivenDevelopment.html](https://martinfowler.com/bliki/TestDrivenDevelopment.html),
    but we really recommend that you read Kent Beck's book, *Test-Driven Development*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在这本书中，我们无法涵盖TDD的全部范围，但我们鼓励你了解更多关于它的信息，并在编写自己的微服务时尝试引入这种纪律。你可以查看Martin Fowler博客中的这篇文章以开始了解，[https://martinfowler.com/bliki/TestDrivenDevelopment.html](https://martinfowler.com/bliki/TestDrivenDevelopment.html)，但我们真的建议你阅读Kent
    Beck的书籍，《*测试驱动开发*》。
- en: Behavior-Driven Development
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: You can also use **Behavior-Driven Development** (**BDD**) when you carry out
    tests on your microservices. BDD is a software development process that emerged
    from TDD, with ideas from domain-driven design and object-oriented analysis and
    design to provide software development and management teams with shared tools
    and a shared process to collaborate on software development.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在微服务上进行测试时，也可以使用**行为驱动开发**（**BDD**）。BDD是一种从TDD中出现的软件开发过程，它结合了领域驱动设计和面向对象分析与设计的思想，为软件开发和管理团队提供共享工具和共享流程，以便在软件开发上进行协作。
- en: The idea is that the requirements from your software are created by the team,
    including the domain experts defining how the application should behave. This
    is done using a behavioral specification that uses the ubiquitous language from
    our domain model.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是，你的软件需求由团队创建，包括领域专家定义应用程序应该如何行为。这是通过使用来自我们的领域模型中的通用语言的行为规范来完成的。
- en: 'This is an example of such a specification:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个此类规范的示例：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This describes our requirements that it will be written before we build our
    microservices, and since we will use our ubiquitous language, the whole team could
    work together defining the specification. Then, we can use tools such as **Cucumber**
    to literally read that specification and create a test that validates it. Finally,
    we can use TDD for the code that makes those test pass and do our red-green-refactor
    cycles. Making tests like this will be great as we will have tests that everyone
    can contribute to, including our domain experts and the team as a whole.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了我们的需求，它将在我们构建微服务之前编写，并且由于我们将使用无处不在的语言，整个团队可以一起定义规范。然后，我们可以使用像**Cucumber**这样的工具来实际读取该规范并创建一个验证它的测试。最后，我们可以使用测试驱动开发（TDD）来编写使这些测试通过的代码，并执行我们的红-绿-重构周期。创建这样的测试将非常棒，因为我们会有每个人都可以贡献的测试，包括我们的领域专家和整个团队。
- en: 'Cucumber–JVM provides an excellent framework for doing BDD tests, and since
    they run in the JVM, we could create them in Kotlin. Refer to the following website
    for more details: [https://cucumber.io/docs/reference/jvm.](https://cucumber.io/docs/reference/jvm)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber–JVM提供了一个用于执行行为驱动开发（BDD）测试的优秀框架，并且由于它们在JVM上运行，我们可以用Kotlin创建它们。有关更多详细信息，请参阅以下网站：[https://cucumber.io/docs/reference/jvm.](https://cucumber.io/docs/reference/jvm)
- en: Handling CI and CD
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理持续集成和持续交付
- en: Adding Continuous Integration and Continuous Delivery to our microservice will
    allow us to deliver our application at the fastest pace with great quality and
    is something that we should look for when we create our microservices. In this
    section, we will discuss some practices that you should consider when doing Continuous
    Integration and Continuous Delivery.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将持续集成和持续交付添加到我们的微服务中，将使我们能够以最快的速度以高质量交付我们的应用程序，这是我们创建微服务时应寻找的东西。在本节中，我们将讨论你在进行持续集成和持续交付时应考虑的一些实践。
- en: Continuous Integration
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Maintaining your software working is not always easy, especially when you have
    several developers working on the same code base. **Continuous Integration** (**CI**)
    allows us to minimize the problems when working with our software. The main idea
    behind CI is that every single time that we push code to our repository, our tests
    runs, and this allows us to know if the change that we just made has broken our
    application, even if what is broken was not actually in the code that was modified.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 维护软件的正常运行并不总是容易，尤其是当你有多个开发者在同一个代码库上工作时。**持续集成**（**CI**）允许我们在使用我们的软件时最小化问题。CI背后的主要思想是，每次我们将代码推送到我们的仓库时，我们的测试都会运行，这使我们能够知道我们刚刚做出的更改是否破坏了我们的应用程序，即使破坏的部分实际上不在我们修改的代码中。
- en: This minimizes the problems of integrating software in a code base if someone
    pushes a piece of software that is faulty, we can fix it and get it back working.
    And this is something that we should target to do all the time, as having a working
    software on our repository allows us to release as often as we can to get feedback,
    and feedback is what makes software better.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人推送了一个有缺陷的软件，这将最小化在代码库中集成软件的问题，我们可以修复它并使其恢复正常工作。这是我们应始终努力实现的目标，因为在我们仓库中有可工作的软件允许我们尽可能频繁地发布以获取反馈，而反馈正是使软件变得更好的关键。
- en: We may think that we shouldn't commit software until everything is ready, and
    that has been proved to be a painful approach which pushes dozen of changes to
    our code base to find out that it could not integrate with the rest. This is something
    that we should avoid. CI allows us to integrate the software while we are writing
    it, so we never end up in the situation where we have software completed that
    actually is not, because it is not working with the rest of our code base.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为不应该在一切准备就绪之前提交软件，而这种做法已被证明是一种痛苦的方法，它将数十个更改推送到我们的代码库，以发现它们无法与其他部分集成。这是我们应避免的事情。持续集成（CI）允许我们在编写软件的同时集成软件，因此我们永远不会陷入软件已完成但实际上并未完成的情况，因为它无法与我们的代码库的其他部分一起工作。
- en: Try to commit small, and try to commit often; this allows you to go back and
    fix things until they are integrated without too much effort.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试提交小的更改，并尽量频繁地提交；这允许你在不需要太多努力的情况下回退并修复直到它们集成。
- en: Continuous Delivery
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付
- en: If we have CI working, we are only one step away from **Continuous Delivery**
    (**CD**), but sometimes that step is not a short step. However, we should always
    try to move in that direction regardless. We could have a working software in
    our integration environment, but if it takes weeks to be available at our end,
    we are not giving the users the value that our application should give.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的持续集成（CI）已经运行良好，我们离**持续交付**（**CD**）就只差一步之遥，但有时这一步并不短。然而，我们无论如何都应该努力朝这个方向前进。我们可以在集成环境中拥有一个可工作的软件，但如果它需要几周时间才能在我们的终端可用，我们就无法为用户提供我们的应用程序应该提供的价值。
- en: In CD, we will try to automate the whole process to get our software from our
    code base into a live application, with all the steps that we could need. This
    could go from having our infrastructure created and configured, to our application
    being tested, deployed, or even verified and a range of things in-between, with
    the minimum, or non-manual intervention. The goal is simple from a developer pushing
    a change in our repository to getting the application live to end users.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在CD中，我们将尝试自动化整个过程，将我们的软件从代码库中转换成实际应用，包括我们可能需要的所有步骤。这可以从创建和配置我们的基础设施开始，到我们的应用程序被测试、部署，甚至验证，以及介于这些步骤之间的一系列事情，以最少的，或非手动干预的方式进行。从开发者在我们仓库中推送更改到应用程序对最终用户可用，目标很简单。
- en: Nothing is really done until it is available to end users. This is how we give
    value to our applications, and we like to do it often, and for the best quality,
    we must do CD.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除非对最终用户可用，否则实际上什么都没有完成。这是我们为我们的应用程序提供价值的方式，我们喜欢经常这样做，为了最佳质量，我们必须进行CD。
- en: Pipeline
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: To do proper CI and CD, we need a pipeline tool that allows us to handle this
    process, something that enables us to pick up our changes, build our software,
    run the test, deploy the application, or any steps that we require in-between.
    And if something fails, our pipeline could notify us, so we can react and correct
    the problem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行适当的CI和CD，我们需要一个管道工具来处理这个过程，某种能够让我们拾取我们的更改、构建我们的软件、运行测试、部署应用程序，或我们需要的任何中间步骤的工具。如果出现问题，我们的管道可以通知我们，这样我们就可以做出反应并纠正问题。
- en: There is a huge range of tools to do pipelines, but we recommend you look at
    tools such as Jenkins (probably the most popular tool), or others such as Concourse,
    Bamboo Gitlab CI, Travis CI, Drone, and many more.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的工具可以用来做管道，但我们建议您查看像Jenkins（可能是最受欢迎的工具）这样的工具，或者像Concourse、Bamboo Gitlab CI、Travis
    CI、Drone等其他工具。
- en: Do not just go to Jenkins because it is what everyone else does. There are many
    tools and many of them as good or even better than Jenkins; try some of them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不要仅仅因为大家都这么做就去使用Jenkins。有许多工具，其中许多工具甚至比Jenkins更好；尝试一些其他的工具。
- en: Dashboard
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板
- en: Having a pipeline running is great, but if our build is not working, or our
    tests aren't running, we need to know about it and react. Most pipelines provide
    systems which give notifications, for example, sending emails or posting in programs
    like Slack, but most of them provide tools to create a dashboard as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 管道运行得很好是件好事，但如果我们的构建不工作，或者我们的测试没有运行，我们需要知道并做出反应。大多数管道提供系统来发送通知，例如发送电子邮件或在Slack等程序中发布，但大多数它们还提供创建仪表板的工具。
- en: A dashboard from a pipeline should visualize the different stages that we do,
    from building our software to launching our test or deployments, and usually are
    color coded with the standard work green, broken red. If we have a dashboard,
    we could just display it somewhere that the team could use to see if the pipeline
    is working and fix it where needed. Our pipeline dashboard could also be easily
    integrated with our application monitoring to have a centralized view of what
    is going on with our application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从管道中来的仪表板应该可视化我们所做的不同阶段，从构建我们的软件到启动我们的测试或部署，通常用标准工作的绿色和故障的红色进行颜色编码。如果我们有一个仪表板，我们就可以将其显示在团队可以使用的某个地方，以查看管道是否在正常工作，并在需要的地方进行修复。我们的管道仪表板也可以轻松集成到我们的应用程序监控中，以便有一个集中查看应用程序状态的全景视图。
- en: It is a whole team responsibility to fix broken builds, and we need to encourage
    them to understand why. It is in our application's best interest to have a pipeline
    working so that we can deliver often and with confidence to our end users.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 修复损坏的构建是整个团队的责任，我们需要鼓励他们理解原因。让管道工作以使我们能够频繁且自信地向最终用户提供价值，这是我们应用程序的最佳利益。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: During the course of this book, we have covered what microservices are, and
    the benefits that they bring to our applications. Now we can design them with
    the best principles in the industry that allow us to have an architecture that
    evolves as our products do. We learned how the Spring Framework could easily be
    integrated with Kotlin, providing excellent tools to build microservices. During
    this process, we realized the advantages of using a modern programming language
    such as Kotlin to deliver high-quality software. And remember that we have just
    started creating some RESTFul APIs that eventually can become reactive microservices
    used in a NoSQL database such as MongoDB with the best performance of non-blocking
    operations. Then, we learned how to create containers and clouds, and how we can
    scale our applications when required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们介绍了微服务是什么，以及它们给我们的应用程序带来的好处。现在我们可以使用行业最佳原则来设计它们，这些原则允许我们的架构随着我们的产品的发展而发展。我们学习了
    Spring 框架如何轻松地与 Kotlin 集成，提供了构建微服务的优秀工具。在这个过程中，我们意识到使用像 Kotlin 这样的现代编程语言来交付高质量软件的优势。记住，我们刚刚开始创建一些
    RESTful API，这些 API 最终可以成为在 NoSQL 数据库（如 MongoDB）中使用，并具有最佳非阻塞操作性能的反应式微服务。然后，我们学习了如何创建容器和云，以及我们如何在需要时扩展我们的应用程序。
- en: But we need software that gives us confidence, so we learned how our tests not
    only give a guarantee that our requirements are met, but they act as a live documentation
    that anyone in our team can use to understand our applications. And when our application
    reaches production, we can use what we have learned to have production-ready alerts
    and monitoring that could be used to control and manage our microservices, even
    in the worst scenarios. Finally, we learned how we can use industry best practices
    when creating microservices in Kotlin to provide the best value to our end users.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们需要能够给我们信心的软件，因此我们学习了我们的测试不仅保证了我们的需求得到满足，而且它们充当了任何我们团队的人都可以使用的活文档，以理解我们的应用程序。当我们的应用程序达到生产阶段时，我们可以利用我们所学的知识来拥有生产就绪的警报和监控，这些可以用来控制和管理工作负载，即使在最糟糕的情况下。最后，我们学习了如何在创建
    Kotlin 中的微服务时使用行业最佳实践，以向我们的最终用户提供最佳价值。
- en: At this point, you should be more than ready to start building your own microservices
    with Kotlin and the Spring Framework with the best techniques available to you.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经准备好使用 Kotlin 和 Spring 框架以及你所能获得的最佳技术来开始构建自己的微服务了。
