["```swift\n let urlString =\n  \"https://jsonplaceholder.typicode.com/posts\"\nif let url = URL(string: urlString) {\n    var request = <st c=\"6245\">URLRequest</st>(url: url)\n    request.httpMethod = \"GET\"\n <st c=\"6294\">let session = URLSession(configuration: .default)</st> let task = session.dataTask(with: request) { (data,\n      response, error) in\n      }\n    task.resume()\n}\n```", "```swift\n     let session = URLSession.shared\n    ```", "```swift\n let configuration = URLSessionConfiguration.default\n    configuration.timeoutIntervalForRequest = 10\n    configuration.requestCachePolicy =\n      .reloadIgnoringLocalCacheData\n    let session = <st c=\"8024\">timeoutIntervalForRequest</st> value to <st c=\"8059\">10</st>, and defined the cache policy to be ignored.\n\t\t\t<st c=\"8106\">When we work</st> <st c=\"8119\">with a shared</st> `<st c=\"8134\">URLSession</st>` <st c=\"8144\">object, there’s no way to customize</st> <st c=\"8180\">its configuration, and it will use the</st> <st c=\"8220\">default one.</st>\n\t\t\t<st c=\"8232\">Now that we know how to perform a basic</st> `<st c=\"8273\">GET</st>` <st c=\"8276\">or</st> `<st c=\"8280\">POST</st>` <st c=\"8284\">request, let’s see what we can do with</st> <st c=\"8324\">the response.</st>\n\t\t\t<st c=\"8337\">Handling the response</st>\n\t\t\t<st c=\"8359\">The request response</st> <st c=\"8380\">is handled</st> <st c=\"8391\">using three stages: error handling, serialization, and data storage.</st> <st c=\"8461\">We need to handle each one of the stages carefully and even consider having a dedicated class or function to simplify the process and separate</st> <st c=\"8604\">the concerns.</st>\n\t\t\t<st c=\"8617\">As mentioned, the first stage is error handling.</st> <st c=\"8667\">Let’s discuss it, as it is a crucial part</st> <st c=\"8709\">of networking.</st>\n\t\t\t<st c=\"8723\">Implementing error handling</st>\n\t\t\t<st c=\"8751\">I believe error handling</st> <st c=\"8776\">wouldn’t get a whole section</st> <st c=\"8805\">in many frameworks.</st> <st c=\"8826\">It is usually a straightforward topic: we perform a task, something goes wrong, and we receive</st> <st c=\"8921\">an error.</st>\n\t\t\t<st c=\"8930\">However, with networking, we are working in a volatile environment where many things have the potential to fail</st> <st c=\"9043\">the process.</st>\n\t\t\t<st c=\"9055\">Here’s a partial list of things that can</st> <st c=\"9097\">go wrong:</st>\n\n\t\t\t\t*   <st c=\"9106\">There is</st> <st c=\"9116\">no network</st>\n\t\t\t\t*   <st c=\"9126\">There’s a network, but the device cannot reach</st> <st c=\"9174\">the internet</st>\n\t\t\t\t*   <st c=\"9186\">The device can reach the internet but with a very</st> <st c=\"9237\">slow connection</st>\n\t\t\t\t*   <st c=\"9252\">We have a stable connection, but the request cannot reach</st> <st c=\"9311\">the backend</st>\n\t\t\t\t*   <st c=\"9322\">The request found the backend, but it</st> <st c=\"9361\">didn’t respond</st>\n\n\t\t\t<st c=\"9375\">The error list can go on and on, ranging from network issues to security to</st> <st c=\"9452\">server errors.</st>\n\t\t\t<st c=\"9466\">To simplify the idea, we can divide the errors into two main groups: network-related issues and</st> <st c=\"9563\">server-side problems.</st>\n\t\t\t<st c=\"9584\">To understand the difference between network and server-related issues, let’s have another look at how we created a</st> <st c=\"9701\">data task:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"9780\">We can see that the data task response</st> <st c=\"9819\">contains three</st> <st c=\"9834\">parameters –</st> `<st c=\"9848\">data</st>`<st c=\"9852\">,</st> `<st c=\"9854\">response</st>`<st c=\"9862\">,</st> <st c=\"9864\">and</st> `<st c=\"9868\">error</st>`<st c=\"9873\">.</st>\n\t\t\t<st c=\"9874\">Network-related errors are part of the</st> `<st c=\"9914\">error</st>` <st c=\"9919\">object, and server-related errors are mostly part of the</st> `<st c=\"9977\">response</st>` <st c=\"9985\">object and sometimes even part of the</st> `<st c=\"10024\">data</st>` <st c=\"10028\">object.</st>\n\t\t\t<st c=\"10036\">To handle a network error, we should look</st> <st c=\"10079\">into</st> `<st c=\"10084\">URLError</st>`<st c=\"10092\">:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"10237\">In this code example, we performed a switch statement to understand our network error.</st> <st c=\"10325\">In this case, we decided to handle one use case of</st> `<st c=\"10376\">cannotFindHost</st>`<st c=\"10390\">. However, there are at least 20 different error codes we can handle.</st> <st c=\"10460\">To read the full and updated list, we should look at Apple documentation</st> <st c=\"10533\">at</st> [<st c=\"10536\">https://developer.apple.com/documentation/foundation/urlerror</st>](https://developer.apple.com/documentation/foundation/urlerror)<st c=\"10597\">.</st>\n\t\t\t<st c=\"10598\">Unlike network-related errors, server-related errors are more complex.</st> <st c=\"10670\">First, we are dependent on another partner—our server.</st> <st c=\"10725\">How the server implements its error-handling logic significantly influences how we handle it in</st> <st c=\"10821\">our app.</st>\n\t\t\t<st c=\"10829\">Let’s understand that by examining the</st> <st c=\"10869\">server response:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"11272\">We first cast the response</st> <st c=\"11299\">into the</st> `<st c=\"11309\">HTTPURLResponse</st>` <st c=\"11324\">type, representing</st> <st c=\"11343\">a general</st> <st c=\"11354\">URL response.</st>\n\t\t\t<st c=\"11367\">The response includes a status code, which the server sends back to us.</st> <st c=\"11440\">In most cases, the code will be part of the following</st> <st c=\"11494\">three groups:</st>\n\n\t\t\t\t*   `<st c=\"11507\">200..299</st>`<st c=\"11516\">: The server successfully responded to</st> <st c=\"11556\">our request</st>\n\t\t\t\t*   `<st c=\"11567\">400..499</st>`<st c=\"11576\">: The server returns an error due to a bad</st> <st c=\"11620\">client request</st>\n\t\t\t\t*   `<st c=\"11634\">500..599</st>`<st c=\"11643\">: The server returned an error due to an internal</st> <st c=\"11694\">server error</st>\n\n\t\t\t<st c=\"11706\">In short, there are three cases – everything went well, it is the client’s fault, or it is the</st> <st c=\"11802\">server’s fault.</st>\n\t\t\t<st c=\"11817\">However, in real life, things</st> <st c=\"11847\">are more complex.</st> <st c=\"11866\">Sometimes, the server</st> <st c=\"11887\">returns a response code of</st> `<st c=\"11915\">200</st>` <st c=\"11918\">(success) but includes an error in the response data.</st> <st c=\"11973\">There is nothing wrong with doing that – the server can choose how to handle problems.</st> <st c=\"12060\">It’s our responsibility to parse the</st> <st c=\"12097\">response correctly.</st>\n\t\t\t<st c=\"12116\">If we need to parse the response ourselves to extract the error, it is better to create a function that receives the data, response, and error parameters and throws an error in case it</st> <st c=\"12302\">finds one:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"12952\">This long</st> `<st c=\"12963\">handleResponse</st>` <st c=\"12977\">function</st> <st c=\"12986\">does precisely</st> <st c=\"13001\">what we’ve discussed.</st> <st c=\"13024\">In case of a successful response, it checks the error object, the response code, and the</st> <st c=\"13113\">data itself.</st>\n\t\t\t<st c=\"13125\">To use that function, we need to call it within the</st> <st c=\"13178\">response closure:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"13386\">The great thing about the</st> `<st c=\"13413\">handleResponse</st>` <st c=\"13427\">function is that we can ensure that we can continue handling the response data after the</st> `<st c=\"13517\">try</st>` <st c=\"13520\">statement because we have dealt with</st> <st c=\"13558\">any error.</st>\n\t\t\t<st c=\"13568\">If you look again</st> <st c=\"13586\">at the</st> `<st c=\"13594\">handleResponse</st>` <st c=\"13608\">function, you’ll see that we decode</st> <st c=\"13644\">the response to look for</st> <st c=\"13670\">an error.</st>\n\t\t\t<st c=\"13679\">Deserializing the response is a major step in handling a network response.</st> <st c=\"13755\">Let’s discuss it a little</st> <st c=\"13781\">bit further.</st>\n\t\t\t<st c=\"13793\">Deserializing a network response</st>\n\t\t\t<st c=\"13826\">In most apps, the response</st> <st c=\"13853\">we get from the server is based on JSON data</st> <st c=\"13898\">structure.</st> <st c=\"13910\">JSON is an industry standard for delivering network responses along</st> <st c=\"13978\">with XML.</st>\n\t\t\t<st c=\"13987\">Swift has built-in support for parsing JSON structures into Swift structures, using tools such as the</st> `<st c=\"14090\">Codable</st>` <st c=\"14097\">protocol and</st> `<st c=\"14111\">JSONDecoder</st>` <st c=\"14122\">classes.</st>\n\t\t\t<st c=\"14131\">In theory, it sounds perfect—all we need to do is decode our response to a data model.</st> <st c=\"14219\">However, there are more factors we need</st> <st c=\"14259\">to consider:</st>\n\n\t\t\t\t*   `<st c=\"14413\">handleResponse</st>` <st c=\"14427\">function example, we saw a response that may have contained an error message.</st> <st c=\"14506\">This means that when we think about our data models, general network responses should be</st> <st c=\"14595\">among them.</st>\n\t\t\t\t*   **<st c=\"14606\">Assuming there’s always an object array</st>**<st c=\"14646\">: Decoding a single object is straightforward, but in many cases, we also need to handle decoding an array of objects.</st> <st c=\"14766\">That sounds trivial, but supporting both formats can be a hassle.</st> <st c=\"14832\">To simplify the decoding process, it is better to always support an array of objects, which is a decision that we need to coordinate with our</st> <st c=\"14974\">backend developers.</st>\n\t\t\t\t*   **<st c=\"14993\">Mixed structures</st>**<st c=\"15010\">: A response can contain different model types and even nested data structures.</st> <st c=\"15091\">This is not always trivial, so our data structures must be more dynamic and modular to support</st> <st c=\"15186\">various responses.</st>\n\t\t\t\t*   **<st c=\"15204\">Model transformations</st>**<st c=\"15226\">: Our local app models are structured to be efficient and convenient to use with the business logic and UI layers.</st> <st c=\"15342\">However, who said that the backend response structure is aligned with what is suitable for our app?</st> <st c=\"15442\">This means we must transform the response data model to our local</st> <st c=\"15508\">data model.</st>\n\n\t\t\t<st c=\"15519\">Deserializing data models</st> <st c=\"15545\">is indeed a complex task, and trying to match our data models</st> <st c=\"15607\">to the response structure we receive from our backend is only sometimes the best idea.</st> <st c=\"15695\">Remember that our data models must suit our app needs and not necessarily follow the</st> <st c=\"15780\">backend methodology.</st>\n\t\t\t<st c=\"15800\">Let’s take a simple JSON received from</st> <st c=\"15840\">the server:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"15912\">That’s a contact structure.</st> <st c=\"15941\">However, we want to use different names in our app so we can use the</st> `<st c=\"16010\">CodingKey</st>` <st c=\"16019\">protocol to ensure we perform the</st> <st c=\"16054\">transformation correctly:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"16313\">Decoding the server response using the</st> `<st c=\"16353\">Contact</st>` <st c=\"16360\">structure now becomes</st> <st c=\"16383\">much simpler:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"16472\">In this example, we map the</st> `<st c=\"16501\">name</st>` <st c=\"16505\">value to</st> `<st c=\"16515\">fullName</st>` <st c=\"16523\">and</st> `<st c=\"16528\">email</st>` <st c=\"16533\">to</st> `<st c=\"16537\">userEmail</st>`<st c=\"16546\">. We decode it using the</st> `<st c=\"16571\">JSONDecoder</st>` <st c=\"16582\">class.</st> <st c=\"16590\">Understanding the</st> `<st c=\"16608\">CodingKey</st>` <st c=\"16617\">protocol is a crucial key to decoding</st> <st c=\"16656\">server responses.</st>\n\t\t\t<st c=\"16673\">There are cases where the whole structure</st> <st c=\"16715\">of the server response</st> <st c=\"16738\">is entirely different than our data models, and in those cases, we need to create a dedicated structure to parse the response.</st> <st c=\"16866\">However, sometimes, we can still use our data model as part of the structure.</st> <st c=\"16944\">Let’s look at the</st> <st c=\"16962\">following example:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"17408\">In this code example, the server returns additional information besides the contact object.</st> <st c=\"17501\">So, we can create a dedicated data structure for the response—</st>`<st c=\"17563\">ServerResponse</st>` <st c=\"17578\">(in this case).</st> <st c=\"17595\">In addition to general information, the</st> `<st c=\"17635\">ServerResponse</st>` <st c=\"17649\">struct contains the</st> `<st c=\"17670\">Contact</st>` <st c=\"17677\">struct.</st> <st c=\"17686\">So, we can see a modular approach here—we can parse our server response</st> <st c=\"17757\">using</st> `<st c=\"17764\">Codable</st>` <st c=\"17771\">and still use our data model objects</st> <st c=\"17808\">to receive</st> <st c=\"17820\">the information.</st>\n\t\t\t<st c=\"17836\">The next step is to store our data model in our</st> <st c=\"17885\">data store.</st>\n\t\t\t<st c=\"17896\">Building a data store</st>\n\t\t\t<st c=\"17918\">A disclaimer: not every network</st> <st c=\"17950\">call requires</st> <st c=\"17964\">us to store the results in a data store.</st> <st c=\"18006\">For instance, authentication and logic calls have different goals.</st> <st c=\"18073\">However, this chapter will focus mainly on data-related calls responsible for building our local</st> <st c=\"18170\">data store.</st>\n\t\t\t<st c=\"18181\">That leads us to our next point: what is the role of the</st> <st c=\"18239\">data store?</st>\n\t\t\t<st c=\"18250\">So, a data store is a structured mechanism for managing and storing data that serves the application’s main business logic</st> <st c=\"18374\">and UI.</st>\n\t\t\t<st c=\"18381\">Unlike many online examples, the application business logic usually doesn’t work directly with the network responses – these need to be adjusted and saved in our store, which acts as the UI</st> <st c=\"18572\">data source.</st>\n\t\t\t<st c=\"18584\">Let’s look at</st> *<st c=\"18599\">Figure 8</st>**<st c=\"18607\">.2</st>*<st c=\"18609\">:</st>\n\t\t\t![Figure 8.2: Working with the datastore](img/B21795_08_2.jpg)\n\n\t\t\t<st c=\"18682\">Figure 8.2: Working with the datastore</st>\n\t\t\t*<st c=\"18720\">Figure 8</st>**<st c=\"18729\">.2</st>* <st c=\"18731\">shows how the data layer works directly with the data store, as the network layer fills the data store with</st> <st c=\"18840\">more information.</st>\n\t\t\t<st c=\"18857\">The data store</st> <st c=\"18872\">doesn’t have to be persistent—that’s an engineering</st> <st c=\"18925\">decision.</st> <st c=\"18935\">However, in most cases, it is a structured store.</st> <st c=\"18985\">A structured store has pre-defined models, relations between entities, and often even query capabilities.</st> <st c=\"19091\">These characteristics distinguish the data store from simply caching the</st> <st c=\"19164\">network responses.</st>\n\t\t\t<st c=\"19182\">To follow the separation of concerns principle, it is better to have dedicated classes to handle each step of</st> <st c=\"19293\">the process.</st>\n\t\t\t<st c=\"19305\">First, we’ll create a</st> `<st c=\"19328\">DataStore</st>` <st c=\"19337\">class:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"19532\">The</st> `<st c=\"19537\">DataStore</st>` <st c=\"19546\">class not only stores the data but also has methods that help store and</st> <st c=\"19619\">retrieve entities.</st>\n\t\t\t<st c=\"19637\">Assuming we already have a network</st> <st c=\"19672\">handler from the previous</st> <st c=\"19698\">examples, we are now going to create a sync class that coordinates the process of fetching the data and</st> <st c=\"19803\">storing it:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"20294\">The</st> `<st c=\"20299\">SyncManager</st>` <st c=\"20310\">class uses the</st> `<st c=\"20326\">NetworkHandler</st>` <st c=\"20340\">class to fetch the information from our backend, parses the results into</st> `<st c=\"20414\">Contact</st>` <st c=\"20421\">entities, and stores them in our data store.</st> <st c=\"20467\">Using this design</st> <st c=\"20484\">pattern, we can easily replace the data store implementation</st> <st c=\"20545\">to be persistent without modifying the</st> <st c=\"20585\">other classes.</st>\n\t\t\t<st c=\"20599\">Now that we have a data store, let’s try to understand how to make our app</st> <st c=\"20675\">more efficient.</st>\n\t\t\t<st c=\"20690\">Integrating network calls within app flows</st>\n\t\t\t<st c=\"20733\">We already know how to perform</st> <st c=\"20764\">a network call, parse</st> <st c=\"20786\">it to data objects, and create a data store.</st> <st c=\"20832\">We also know how to handle errors, and we learned that it’s important to separate the concerns into different classes</st> <st c=\"20950\">and components.</st>\n\t\t\t<st c=\"20965\">However, it feels like a technical discussion.</st> <st c=\"21013\">Performing a URL connection in iOS is one of the most basic tasks.</st> <st c=\"21080\">Let’s try to upgrade our discussion and</st> <st c=\"21120\">discuss methodology.</st>\n\t\t\t<st c=\"21140\">First, we should think of streaming data from the network as an atomic task in our app’s data synchronization mechanism.</st> <st c=\"21262\">It’s up to us to decide when to call our server for more data.</st> <st c=\"21325\">From our discussions, it looks like we need to contact the server just before we want to display the information, but it doesn’t have to be</st> <st c=\"21465\">like that.</st>\n\t\t\t<st c=\"21475\">Let’s discuss the different strategies we can use when working with our backend.</st> <st c=\"21557\">We’ll start with the</st> **<st c=\"21578\">just-in-time</st>** <st c=\"21590\">fetching technique.</st>\n\t\t\t<st c=\"21610\">Just-in-time fetching</st>\n\t\t\t<st c=\"21632\">The just-in-time fetching technique</st> <st c=\"21668\">is very common and also the simplest one.</st> <st c=\"21711\">With it, we don’t present anything on the screen before we get a response from the server.</st> <st c=\"21802\">Instead, we show a loader indicating that we are</st> <st c=\"21851\">fetching data.</st>\n\t\t\t<st c=\"21865\">In just-in-time fetching, we don’t preserve the information in a data store; instead, we store the information in the view state or the view model.</st> <st c=\"22014\">Here’s a simple example of</st> <st c=\"22041\">just-in-time fetching:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"22635\">In this code example, we have a list that is based on the state variable of contacts.</st> <st c=\"22722\">When the view appears, we call the</st> `<st c=\"22757\">fetchContacts</st>` <st c=\"22770\">method to fetch the list of contacts and, in the meantime, show a</st> <st c=\"22837\">loading message.</st>\n\t\t\t<st c=\"22853\">Besides its simplicity, the just-in-time technique is great for apps that must ensure that the data they display is up to date, such as financial apps or live sports scores.</st> <st c=\"23028\">The downside here is that we provide a poor user experience</st> <st c=\"23087\">and depend on the</st> <st c=\"23106\">network state.</st>\n\t\t\t<st c=\"23120\">If possible, we should pick a slightly better technique, often called</st> **<st c=\"23191\">read-through cache</st>**<st c=\"23209\">.</st>\n\t\t\t<st c=\"23210\">Read-through cache</st>\n\t\t\t<st c=\"23229\">The read-through cache technique</st> <st c=\"23262\">is also a popular way to present data to the user, even though most developers are unaware of</st> <st c=\"23357\">its name.</st>\n\t\t\t<st c=\"23366\">Using the read-through cache approach, we display our local data to the user while going to our backend to refresh</st> <st c=\"23482\">our data.</st>\n\t\t\t<st c=\"23491\">Let’s see a code example</st> <st c=\"23517\">for that:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"24033\">In this code example, we load the contacts from the cache (or from the local store) when the screen appears and then go to the network to refresh our data set.</st> <st c=\"24194\">The read-through cache technique is great when quick access to data is crucial because it is not up-to-date, for example, in news or</st> <st c=\"24327\">e-commerce apps.</st>\n\t\t\t<st c=\"24343\">You’ve probably noticed that both the just-in-time and read-through cache techniques require us to load the page information fully from the backend, regardless of the amount of information</st> <st c=\"24533\">we have.</st>\n\t\t\t<st c=\"24541\">Now, what if we know upfront</st> <st c=\"24570\">that we have a huge number of records to fetch, so big that it can even cause our request to time out?</st> <st c=\"24674\">In this case, we can choose the</st> **<st c=\"24706\">incremental</st>** **<st c=\"24718\">loading</st>** <st c=\"24725\">technique.</st>\n\t\t\t<st c=\"24736\">Incremental loading</st>\n\t\t\t<st c=\"24756\">There are cases wherein</st> <st c=\"24780\">we can expect to fetch a vast number of records.</st> <st c=\"24830\">A social feed, for instance, can have an infinite number of posts.</st> <st c=\"24897\">Well, it’s not really infinite, but we can relate to that number</st> <st c=\"24962\">as infinity.</st>\n\t\t\t<st c=\"24974\">When the number is too big to fetch in one request, we can use</st> <st c=\"25038\">incremental loading.</st>\n\t\t\t<st c=\"25058\">With incremental loading, we fetch a set of records each time with each request and store the last record index for the</st> <st c=\"25179\">next time.</st>\n\t\t\t<st c=\"25189\">Here’s an example of</st> <st c=\"25211\">incremental loading:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"25905\">In this example, we have a class named</st> `<st c=\"25945\">IncrementalLoading</st>`<st c=\"25963\">, which is responsible for loading the next set of records with the function named</st> `<st c=\"26046\">loadNextPage</st>`<st c=\"26058\">. Incremental loading is also called</st> `<st c=\"26177\">IncrementalLoading</st>` <st c=\"26195\">example, we have an index that points to the last record index fetched, and a variable named</st> `<st c=\"26289\">itemsPerPage</st>` <st c=\"26301\">that defines how many items to fetch on</st> <st c=\"26342\">each page.</st>\n\t\t\t<st c=\"26352\">While incremental loading solves handling a large amount of data, there are several factors</st> <st c=\"26444\">we need</st> <st c=\"26453\">to consider:</st>\n\n\t\t\t\t*   `<st c=\"26720\">List</st>` <st c=\"26724\">view or a UIKit</st> `<st c=\"26741\">TableView</st>` <st c=\"26750\">view.</st> <st c=\"26757\">In these cases, we would like to fetch the next set of records when the user reaches the bottom of the list.</st> <st c=\"26866\">However, things can become complex when we allow the user to edit or delete records since that can affect the</st> <st c=\"26976\">index variable.</st>\n\t\t\t\t*   **<st c=\"26991\">Memory consumption</st>**<st c=\"27010\">: It’s true that incremental loading is optimized to handle a significant amount of information.</st> <st c=\"27108\">However, we are still talking about storing a large amount of information in our memory.</st> <st c=\"27197\">While the user is paging through our data, our local data store can become bigger, mainly if it contains rich media such as images and videos.</st> <st c=\"27340\">It is essential to have a mechanism that can release records in case of high</st> <st c=\"27417\">memory usage.</st>\n\t\t\t\t*   **<st c=\"27430\">Contextual relevance</st>**<st c=\"27451\">: We need to remember that our chosen design pattern needs to support a specific product need.</st> <st c=\"27547\">Incremental loading is relevant in cases wherein we don’t need all the data at once.</st> <st c=\"27632\">Social feeds or search results are great examples of data that can be browsed chunk by chunk.</st> <st c=\"27726\">However, in cases where the user requires immediate access to all the data, such as in data analysis, incremental loading</st> <st c=\"27847\">might not</st> <st c=\"27858\">be suitable.</st>\n\n\t\t\t<st c=\"27870\">Considering the different factors mentioned, we understand that, similar to many design patterns in computer science, incremental loading presents a tradeoff between different aspects such as performance, complexity, experience, and more.</st> <st c=\"28110\">It’s up to us to choose the right design pattern that fits</st> <st c=\"28169\">our needs.</st>\n\t\t\t<st c=\"28179\">The three design patterns we discussed now require different endpoints for different types of data and other screens, which sounds logical.</st> <st c=\"28320\">However, there’s another way to handle data that changes over time and still provides an amazing experience to the user –</st> <st c=\"28442\">delta updates.</st>\n\t\t\t<st c=\"28456\">Full data sync with delta updates</st>\n\t\t\t<st c=\"28490\">Before we discuss full data sync with the delta updates method, let’s talk about problems that we have with</st> <st c=\"28598\">multiple endpoints:</st>\n\n\t\t\t\t*   **<st c=\"28618\">Efficient network calls</st>**<st c=\"28642\">: The need to request the same data repeatedly, even if nothing has changed, seems inefficient.</st> <st c=\"28739\">We can use the cache to present previous results, but that only solves performance issues.</st> <st c=\"28830\">We still need to perform the same request to understand whether there</st> <st c=\"28900\">are updates.</st>\n\t\t\t\t*   **<st c=\"28912\">Incomplete database</st>**<st c=\"28932\">: Each endpoint retrieves different data and sometimes different entities.</st> <st c=\"29008\">We know that in many cases, the entities are related (such as to-one and to-many relationships), and having multiple endpoints to fetch them probably means our data won’t be complete.</st> <st c=\"29192\">That seems acceptable – we’re focused on a mobile app and not a server.</st> <st c=\"29264\">However, having an incomplete data store can result in a poor experience.</st> <st c=\"29338\">Users may encounter updated information on one screen, navigate to another, and view outdated data while waiting for the screen to refresh from the server.</st> <st c=\"29494\">If both screens contain related data, it can result in a</st> <st c=\"29551\">poor experience.</st>\n\t\t\t\t*   **<st c=\"29567\">App performance</st>**<st c=\"29583\">: We often believe that performance is only about CPU and Swift code efficiency.</st> <st c=\"29665\">However, our devices are strong enough to handle most tasks without a hiccup.</st> <st c=\"29743\">In contrast, network requests</st> <st c=\"29772\">cause users to wait even if they have the latest hardware.</st> <st c=\"29832\">Having a network call on each screen greatly impacts the</st> <st c=\"29889\">user experience.</st>\n\n\t\t\t<st c=\"29905\">Delta updates</st> <st c=\"29919\">are a solution that can handle some of the problems we described with endpoints in the previous section.</st> <st c=\"30025\">With delta updates, we fetch all the information at the app’s initial launch and, from this point, retrieve only</st> <st c=\"30138\">the changes.</st>\n\t\t\t<st c=\"30150\">We do that by storing a bookmark representing our data’s last updated timestamp.</st> <st c=\"30232\">When we ask the server, “Do you have any updates for me?”, we send this bookmark, get the new changes (if any), receive a new bookmark, and</st> <st c=\"30372\">store it.</st>\n\t\t\t<st c=\"30381\">Here’s a code example for contacts</st> <st c=\"30416\">delta sync.</st> <st c=\"30429\">We start with the</st> `<st c=\"30447\">syncContacts</st>` <st c=\"30459\">function:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"31154\">The code example does exactly</st> <st c=\"31184\">what we described earlier—it saves a bookmark called</st> `<st c=\"31238\">lastUpdatedDate</st>`<st c=\"31253\">. Initially, we fetch all the data and save the new</st> `<st c=\"31305\">lastUpdatedDate</st>` <st c=\"31320\">value we get from the server.</st> <st c=\"31351\">The next time we perform the sync operation, we get only the changes.</st> <st c=\"31421\">Now, let’s implement the</st> `<st c=\"31446\">processDeltaUpdates</st>` <st c=\"31465\">function:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"31863\">The</st> `<st c=\"31868\">processDeltaUpdates</st>` <st c=\"31887\">function receives a response that contains only the changes that have occurred in the server since the</st> <st c=\"31991\">last sync.</st>\n\t\t\t<st c=\"32001\">That’s why the response</st> <st c=\"32025\">is structured into three groups: deleted, new, and updated.</st> <st c=\"32086\">With each one, we need to handle the</st> <st c=\"32123\">data differently.</st>\n\t\t\t<st c=\"32140\">Some critical notes we need to consider</st> <st c=\"32180\">here are</st> <st c=\"32190\">as follows:</st>\n\n\t\t\t\t*   **<st c=\"32201\">Extremally large data sets</st>**<st c=\"32228\">: The delta updates pattern is not relevant for very large data sets.</st> <st c=\"32299\">For example, a social app feed can have millions of records, and fetching all of them from the start is impossible.</st> <st c=\"32415\">For that issue, we can</st> <st c=\"32438\">use pagination.</st>\n\t\t\t\t*   **<st c=\"32453\">The initial loading can be long</st>**<st c=\"32485\">: Since we fetch all the data at the beginning, we need to deliver a corresponding</st> <st c=\"32569\">user experience.</st>\n\t\t\t\t*   **<st c=\"32585\">Deleted items</st>**<st c=\"32599\">: Syncing deleted items is always a crucial topic.</st> <st c=\"32651\">We need to actively delete items that no longer exist, so the response from the server should contain items we need</st> <st c=\"32767\">to delete.</st>\n\t\t\t\t*   **<st c=\"32777\">Sync triggers</st>**<st c=\"32791\">: Since we perform the sync operation at the beginning, it looks like it’s the only time we should do that.</st> <st c=\"32900\">However, there are more occasions when we need to refresh our data.</st> <st c=\"32968\">For example, when we perform data changes such as calling the server to add a new item or receiving a push notification, we should think about the different cases when something can change in our server during the app runtime</st> <st c=\"33193\">and try to refresh</st> <st c=\"33213\">our data.</st>\n\n\t\t\t<st c=\"33222\">It’s important to understand that none of the solutions are perfect.</st> <st c=\"33292\">Sometimes, it is a good idea to combine different approaches—for example, use delta sync in general, but maybe use pagination for a</st> <st c=\"33424\">specific screen.</st>\n\t\t\t<st c=\"33440\">We should consider the different approaches as a toolbox with several tools, each suitable for various problems or</st> <st c=\"33556\">data structures.</st>\n\t\t\t<st c=\"33572\">Now that we understand how to handle requests and use different patterns to incorporate the calls in our app flows, let’s see another way to handle networking</st> <st c=\"33732\">in iOS.</st>\n\t\t\t<st c=\"33739\">Exploring Networking and Combine</st>\n\t\t\t<st c=\"33772\">Networking is a great place</st> <st c=\"33800\">to start if you</st> <st c=\"33816\">haven’t worked with Combine.</st> <st c=\"33846\">Combine is a framework that declaratively handles a stream of values over time while supporting</st> <st c=\"33942\">asynchronous operations.</st>\n\t\t\t<st c=\"33966\">Based on that description, it looks like Combine was made for</st> <st c=\"34029\">networking operations!</st>\n\t\t\t<st c=\"34051\">In this chapter, we are not going to discuss what Combine is – for that, we’ve got</st> [*<st c=\"34135\">Chapter 11</st>*](B21795_11.xhtml#_idTextAnchor346)<st c=\"34145\">. However, we are going to discuss it now because Combine is a great way to solve many networking</st> <st c=\"34243\">operations problems.</st>\n\t\t\t<st c=\"34263\">Since Combine is built upon publishers and operators, it is simple to create new publishers that stream data from</st> <st c=\"34378\">the network.</st>\n\t\t\t<st c=\"34390\">Let’s try to request the list of contacts from previous examples using a Combine stream.</st> <st c=\"34480\">We’ll start with creating a publisher that performs data fetching from the network and publish a list</st> <st c=\"34582\">of contacts:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"34880\">The publisher utilizes</st> <st c=\"34903\">URLSession’s</st> `<st c=\"34917\">dataTaskPublisher</st>` <st c=\"34934\">method</st> <st c=\"34941\">to execute the network request and publish the retrieved data.</st> <st c=\"35005\">We then extract the data using the map operation and decode it into a list of</st> `<st c=\"35083\">Contact</st>` <st c=\"35090\">items.</st> <st c=\"35098\">If something goes wrong, the publisher will report an Error.</st> <st c=\"35159\">We wrap this function in a class named</st> `<st c=\"35198\">ContactRequest</st>` <st c=\"35212\">to</st> <st c=\"35216\">maintain separation.</st>\n\t\t\t<st c=\"35236\">Now, let’s create a small</st> `<st c=\"35263\">DataStore</st>` <st c=\"35272\">class so we can store the results and</st> <st c=\"35311\">publish them:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"35384\">The</st> `<st c=\"35389\">@Published</st>` <st c=\"35399\">property wrapper creates a publisher for contacts so that we can observe the</st> <st c=\"35477\">changes easily.</st>\n\t\t\t<st c=\"35492\">Now, we can use the</st> `<st c=\"35513\">fetchData()</st>` <st c=\"35524\">function</st> <st c=\"35533\">to read the results</st> <st c=\"35553\">and</st> <st c=\"35558\">store them:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"36114\">The</st> `<st c=\"36119\">ContactsSync</st>` <st c=\"36131\">job is to fetch</st> <st c=\"36147\">contacts using the</st> `<st c=\"36167\">ContactRequest</st>` <st c=\"36181\">class and to store</st> <st c=\"36200\">them in the data store using the</st> `<st c=\"36234\">DataStore</st>` <st c=\"36243\">class.</st>\n\t\t\t<st c=\"36250\">The Combine example has</st> <st c=\"36274\">several advantages:</st>\n\n\t\t\t\t*   **<st c=\"36294\">Clear and consistent interface</st>**<st c=\"36325\">: The publisher interface is consistent and known.</st> <st c=\"36377\">It is always built from data/void and an optional error.</st> <st c=\"36434\">New developers don’t need to learn and understand how to</st> <st c=\"36491\">read/use it.</st>\n\t\t\t\t*   **<st c=\"36503\">Built-in error handling</st>**<st c=\"36527\">: Not only do we have a consistent interface that also contains errors, but also, when one of the stages encounters an error, it interrupts the flow and channels it downstream.</st> <st c=\"36705\">We have already seen that error handling is a critical topic in networking in</st> <st c=\"36783\">many cases.</st>\n\t\t\t\t*   **<st c=\"36794\">Asynchronous operations support</st>**<st c=\"36826\">: We often think that a network operation contains one asynchronous operation: the request itself.</st> <st c=\"36926\">However, many steps in the stream can be asynchronous – including preparing the request by reading local data, processing the response, and storing the data at the end of the stream.</st> <st c=\"37109\">Combine streams are perfect for performing all those</st> <st c=\"37162\">steps asynchronously.</st>\n\t\t\t\t*   **<st c=\"37183\">Modularity</st>**<st c=\"37194\">: The capability of building</st> <st c=\"37223\">a modular code is reserved not only for the Combine framework, but the custom publishers and the different operators make Combine streams a joyful framework to implement when dealing with networking.</st> <st c=\"37424\">Remember that we said that networking is like a production line (under the</st> *<st c=\"37499\">Understanding mobile networking</st>* <st c=\"37530\">section)?</st> <st c=\"37541\">So, Combine makes it easier to insert more steps into the stream; some of them are even built into</st> <st c=\"37640\">the framework.</st>\n\n\t\t\t<st c=\"37654\">Adding reactive methods</st> <st c=\"37678\">to our code doesn’t mean we need to discard all the design patterns and principles we discussed when we covered networking—it’s just another</st> <st c=\"37819\">way to</st> <st c=\"37827\">implement them.</st>\n\t\t\t<st c=\"37842\">For example, let’s try to implement the delta updates design pattern using the</st> <st c=\"37922\">Combine framework:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"38552\">Looking at the code</st> <st c=\"38572\">example, we can</st> <st c=\"38588\">see that it looks pretty much like the previous Combine code—that’s part of the idea of consistent interface and modular code.</st> <st c=\"38716\">We perform the request, check the response code, decode it, change it to the main thread, and process the</st> <st c=\"38822\">response data.</st>\n\t\t\t<st c=\"38836\">Summary</st>\n\t\t\t<st c=\"38844\">Connecting to our backend and retrieving data is a basic task in most mobile apps.</st> <st c=\"38928\">Doing so lets us present valuable and interesting information to</st> <st c=\"38993\">our users.</st>\n\t\t\t<st c=\"39003\">Performing a simple request is easy – however, there are many other factors to bear in mind, and doing that properly is crucial to having an</st> <st c=\"39145\">efficient app.</st>\n\t\t\t<st c=\"39159\">This chapter reviewed the different network components, such as the request itself, error handling, and data storage.</st> <st c=\"39278\">We also discussed our different design patterns to work with our backend.</st> <st c=\"39352\">We ended up incorporating Combine into our flows.</st> <st c=\"39402\">We should now be perfectly able to set up a fantastic network infrastructure for</st> <st c=\"39483\">our app.</st>\n\t\t\t<st c=\"39491\">Now, let’s flip to the other side of our architecture, the UI, and discuss a library that can enrich our app easily –</st> **<st c=\"39610\">Charts</st>**<st c=\"39616\">!</st>\n\n```"]