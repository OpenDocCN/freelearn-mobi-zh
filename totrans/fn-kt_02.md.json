["```kt\nfun f(x: Long) : Long { \n   return x * x // no access to external state\n}\n```", "```kt\nfun main(args: Array<String>) {\n    var i = 0\n\n    fun g(x: Long): Long {\n       return x * i // accessing mutable state\n    }\n\n    println(g(1)) //0\n    i++\n    println(g(1)) //1\n    i++\n    println(g(1)) //2\n}\n```", "```kt\nval capitalize = { str: String -> str.capitalize() }\n\nfun main(args: Array<String>) {\n   println(capitalize(\"hello world!\"))\n}\n```", "```kt\nval capitalize = { str: String -> str.capitalize() }\n```", "```kt\nval capitalize = object : Function1<String, String> {\n   override fun invoke(p1: String): String {\n      return p1.capitalize()\n   }\n}\n```", "```kt\nfun transform(str:String, fn: (String) -> String): String {\n   return fn(str)\n}\n```", "```kt\nfun <T> transform(t: T, fn: (T) -> T): T {\n   return fn(t)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    println(transform(\"kotlin\", capitalize))\n}\n```", "```kt\nfun reverse(str: String): String {\n   return str.reversed()\n}\n\nfun main(args: Array<String>) {\n    println(transform(\"kotlin\", ::reverse))\n}\n```", "```kt\nobject MyUtils {\n   fun doNothing(str: String): String {\n      return str\n   }\n}\n\nfun main(args: Array<String>) {\n    println(transform(\"kotlin\", MyUtils::doNothing))\n}\n```", "```kt\nclass Transformer {\n   fun upperCased(str: String): String {\n      return str.toUpperCase()\n   }\n\n   companion object {\n      fun lowerCased(str: String): String {\n         return str.toLowerCase()\n      }\n   }\n}\n\nfun main(args: Array<String>) {\n    val transformer = Transformer()\n\n    println(transform(\"kotlin\", transformer::upperCased))\n\n    println(transform(\"kotlin\", Transformer.Companion::lowerCased))\n}\n```", "```kt\nfun main(args: Array<String>) {\n    println(transform(\"kotlin\", { str -> str.substring(0..1) }))\n}\n```", "```kt\nfun main(args: Array<String>) {\n    println(transform(\"kotlin\", { it.substring(0..1) }))\n}\n```", "```kt\nfun main(args: Array<String>) {\n    println(transform(\"kotlin\") { str -> str.substring(0..1) })\n}\n```", "```kt\nfun unless(condition: Boolean, block: () -> Unit){\n   if (!condition) block()\n}\n\nfun main(args: Array<String>) {\n    val securityCheck = false // some interesting code here\n\n    unless(securityCheck) {\n        println(\"You can't access this website\")\n    }\n}\n\n```", "```kt\ninterface Machine<T> {\n   fun process(product: T)\n}\n\nfun <T> useMachine(t: T, machine: Machine<T>) {\n   machine.process(t)\n}\n\nclass PrintMachine<T> : Machine<T> {\n   override fun process(t: T) {\n      println(t)\n   }\n}\n\nfun main(args: Array<String>) {\n    useMachine(5, PrintMachine())\n\n    useMachine(5, object : Machine<Int> {\n       override fun process(t: Int) {\n          println(t)\n       }\n    })\n}\n```", "```kt\ntypealias Machine<T> = (T) -> Unit\n\nfun <T> useMachine(t: T, machine: Machine<T>) {\n   machine(t)\n}\n\nclass PrintMachine<T>: Machine<T> {\n   override fun invoke(p1: T) {\n      println(p1)\n   }\n} \n\nfun main(args: Array<String>) {\n    useMachine(5, PrintMachine())\n\n    useMachine(5, ::println)\n\n    useMachine(5) { i ->\n        println(i)\n    }\n}\n```", "```kt\nfun factorial(n: Long): Long {\n   var result = 1L\n   for (i in 1..n) {\n      result *= i\n   }\n   return result\n}\n```", "```kt\nfun functionalFactorial(n: Long): Long {\n   fun go(n: Long, acc: Long): Long {\n      return if (n <= 0) {\n         acc\n      } else {\n         go(n - 1, n * acc)\n      }\n   }\n\n   return go(n, 1)\n} \n```", "```kt\nfun tailrecFactorial(n: Long): Long {\n   tailrec fun go(n: Long, acc: Long): Long {\n      return if (n <= 0) {\n         acc\n      } else {\n         go(n - 1, n * acc)\n      }\n   }\n\n   return go(n, 1)\n}\n```", "```kt\nfun executionTime(body: () -> Unit): Long {\n   val startTime = System.nanoTime()\n   body()\n   val endTime = System.nanoTime()\n   return endTime - startTime\n}\n```", "```kt\nfun main(args: Array<String>) {\n    println(\"factorial :\" + executionTime { factorial(20) })\n    println(\"functionalFactorial :\" + executionTime { functionalFactorial(20) })\n    println(\"tailrecFactorial :\" + executionTime { tailrecFactorial(20) })\n}\n```", "```kt\nfun fib(n: Long): Long {\n   return when (n) {\n      0L -> 0\n      1L -> 1\n      else -> {\n         var a = 0L\n         var b = 1L\n         var c = 0L\n         for (i in 2..n) {\n            c = a + b\n            a = b\n            b = c\n         }\n         c\n      }\n   }\n}\n```", "```kt\nfun functionalFib(n: Long): Long {\n   fun go(n: Long, prev: Long, cur: Long): Long {\n      return if (n == 0L) {\n         prev\n      } else {\n         go(n - 1, cur, prev + cur)\n      }\n   }\n\n   return go(n, 0, 1)\n}\n```", "```kt\nfun tailrecFib(n: Long): Long {\n   tailrec fun go(n: Long, prev: Long, cur: Long): Long {\n      return if (n == 0L) {\n         prev\n      } else {\n         go(n - 1, cur, prev + cur)\n      }\n   }\n\n   return go(n, 0, 1)\n}\n\n```", "```kt\nfun main(args: Array<String>) {\n    println(\"fib :\" + executionTime { fib(93) })\n    println(\"functionalFib :\" + executionTime { functionalFib(93) })\n    println(\"tailrecFib :\" + executionTime { tailrecFib(93) })\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val i by lazy {\n        println(\"Lazy evaluation\")\n        1\n    }\n\n    println(\"before using i\")\n    println(i)\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val size = listOf(2 + 1, 3 * 2, 1 / 0, 5 - 4).size\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val size = listOf({ 2 + 1 }, { 3 * 2 }, { 1 / 0 }, { 5 - 4 }).size\n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n```", "```kt\nfun main(args: Array<String>) {\n    for(i in numbers) {\n       println(\"i = $i\")\n    }\n}\n```", "```kt\nfun main(args: Array<String>) {\n    numbers.forEach { i -> println(\"i = $i\") }\n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    val numbersTwice: List<Int> = listOf()\n\n    for (i in numbers) {\n       numbersTwice.add(i * 2) //Compilation error: Unresolved reference: add \n    }\n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    val numbersTwice: MutableList<Int> = mutableListOf()\n\n    for (i in numbers) {\n        numbersTwice.add(i * 2) //Nice!\n    }\n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    val numbersTwice: List<Int> = numbers.map { i -> i * 2 }\n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    var sum = 0\n\n    for (i in numbers) {\n       sum += i\n    }\n\n    println(sum)    \n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    val sum = numbers.sum()\n\n    println(sum)    \n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    val sum = numbers.fold(0) { acc, i -> acc + i }\n\n    println(sum)\n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    val sum = numbers.fold(0) { acc, i ->\n        println(\"acc, i = $acc, $i\")\n        acc + i\n    }\n\n    println(sum)\n}\n```", "```kt\nval numbers: List<Int> = listOf(1, 2, 3, 4)\n\nfun main(args: Array<String>) {\n    val sum = numbers.reduce { acc, i ->\n        println(\"acc, i = $acc, $i\")\n        acc + i\n    }\n\n    println(sum)\n}\n```", "```kt\nsealed class FunList<out T> {\n   object Nil : FunList<Nothing>()\n\n   data class Cons<out T>(val head: T, val tail: FunList<T>) : FunList<T>()\n}\n```", "```kt\nimport com.packtpub.functionalkotlin.chapter02.FunList.Cons\nimport com.packtpub.functionalkotlin.chapter02.FunList.Nil\n\nfun main(args: Array<String>) {\n    val numbers = Cons(1, Cons(2, Cons(3, Cons(4, Nil))))\n}\n```", "```kt\nimport com.packtpub.functionalkotlin.chapter02.FunList.Cons\nimport com.packtpub.functionalkotlin.chapter02.FunList.Nil\n\nfun intListOf(vararg numbers: Int): FunList<Int> {\n   return if (numbers.isEmpty()) {\n      Nil\n   } else {\n      Cons(numbers.first(), intListOf(*numbers.drop(1).toTypedArray().toIntArray()))\n   }\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val numbers = intListOf(1, 2, 3, 4)    \n}\n```", "```kt\nsealed class FunList<out T> {\n   object Nil : FunList<Nothing>()\n\n   data class Cons<out T>(val head: T, val tail: FunList<T>) : FunList<T>()\n\n   fun forEach(f: (T) -> Unit) {\n      tailrec fun go(list: FunList<T>, f: (T) -> Unit) {\n         when (list) {\n            is Cons -> {\n               f(list.head)\n               go(list.tail, f)\n            }\n            is Nil -> Unit//Do nothing\n         }\n      }\n\n      go(this, f)\n   }\n\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val numbers = intListOf(1, 2, 3, 4)\n\n    numbers.forEach { i -> println(\"i = $i\") }\n}\n```", "```kt\nsealed class FunList<out T> {\n\n  /*Previous code here*/\n\n   fun <R> fold(init: R, f: (R, T) -> R): R {\n      tailrec fun go(list: FunList<T>, init: R, f: (R, T) -> R): R = when (list) {\n         is Cons -> go(list.tail, f(init, list.head), f)\n         is Nil -> init\n      }\n\n      return go(this, init, f)\n   }\n}\n\n```", "```kt\nfun main(args: Array<String>) {\n    val numbers = intListOf(1, 2, 3, 4)\n\n    val sum = numbers.fold(0) { acc, i -> acc + i}\n}\n```", "```kt\nfun main(args: Array<String>) {\n    val funList = intListOf(1, 2, 3, 4)\n    val list = listOf(1, 2, 3, 4)\n\n    println(\"fold on funList : ${executionTime { funList.fold(0) { acc, i -> acc + i } }}\")\n    println(\"fold on list : ${executionTime { list.fold(0) { acc, i -> acc + i } }}\")\n}\n```", "```kt\nsealed class FunList<out T> {\n\n    /*previous code*/\n\n    fun reverse(): FunList<T> = fold(Nil as FunList<T>) { acc, i -> Cons(i, acc) }\n}\n\n```", "```kt\nsealed class FunList<out T> {\n\n    /*previous code*/\n\n  fun <R> foldRight(init: R, f: (R, T) -> R): R {\n   return this.reverse().fold(init, f)\n  }\n}\n```", "```kt\nsealed class FunList<out T> {\n\n /*previous code*\n\n fun <R> map(f:(T) -> R): FunList<R> {\n   return foldRight(Nil as FunList<R>){ tail, head -> Cons(f(head), tail) }\n }\n}\n```"]