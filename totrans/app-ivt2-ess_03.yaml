- en: Chapter 3. Navigating the App Inventor Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have created a new project and set up connectivity, you are ready
    to begin learning how to make mobile apps! This chapter will provide a step-by-step
    guide to navigate the App Inventor web application through the process of building
    a game app called Fling. You will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: The Projects View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Designer (a graphical user interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palette
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Blocks Editor (a visual programming language)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Integrated Development Environment (IDE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The projects view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0017_split_000.html#G6PI2-9c0b907946184095a315b26c8a9b12bc
    "Chapter 2. Setting Up MIT App Inventor 2"), *Setting Up MIT App Inventor 2*,
    you logged into App Inventor for the first time, created a new project, and named
    it, so at the moment, you only have one App Inventor project. Once you start building
    more apps, all of the projects associated with your Google Account will be listed
    under My Projects. Every time you log into App Inventor, the platform will automatically
    open the most recent project that you worked on. To pick a different project,
    click on **My Projects** in the top menu bar, or to start a new project, click
    on **Start new project** in the upper left corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![The projects view](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to build a game in this chapter. It will be similar to Pong, but
    instead of a paddle, you will use your finger to fling the ball. Let's create
    a new project called `Fling`. Note that project names containing no spaces must
    start with a letter. Use only letters, underscores, and numbers. Click on **Start
    new project** in the upper-left corner of the screen. A pop-up window will appear,
    as shown in the following screenshot. Type in the word **Fling**. Once you click
    on **OK**, you will be taken into the Designer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you happen to have a previous project open in the Designer, you can still
    start a new project in this view by clicking on **Start new project** listed under
    **Projects** in the top menu bar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you open a project or start a new project, App Inventor will take you
    to the Designer. This window is a graphical editor where you can create the look
    and feel of your mobile app by choosing components (buttons, labels, images, and
    so on), layouts (horizontal/vertical alignments), colors, fonts, and more. The
    next screenshot is a layout of the Designer (with some helpful navigation hints):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Designer](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The name of the open project is displayed in the upper-left corner. In the upper-right
    corner, you will see toggle buttons for the **Designer** and **Blocks** Editor
    (the **Designer** button is disabled at the moment, since we are currently in
    the Designer view). The Designer consists of five panels, which are explained
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Palette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Palette** (found in the left-hand column of the previous Designer image)
    contains drawers that hold sets of tools called **Components**. Drawers group
    **Components** by type such as **User Interface**, **Layout**, **Media**, **Drawing
    and Animation**, **Sensors**, **Social**, **Storage**, **Connectivity**, and **LEGO
    MINDSTORMS**. It will take a little bit of time to remember which drawer houses
    which Components and what functions they have. More on Components later!
  prefs: []
  type: TYPE_NORMAL
- en: Viewer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Viewer** (found in the middle of the preceding Designer image) is the
    white workspace in the middle of the Designer window. When you first create a
    project, the default workspace name is **Screen1**. You cannot change the name
    of Screen1, although you can change the title of the screen name. This can be
    done in the **Properties** panel (as follows). The new screen name will be displayed
    in the Viewer and be seen by app users. Later, you may want to add more screens
    to your app and you can rename the subsequent screens. To build your app, you
    will drag Components from the Palette drawers onto the Viewer. We will be using
    visual components in our Fling app, so these will remain visible when dragged
    into the Viewer. In the subsequent chapters, we will demonstrate the use of non-visible
    components, which will not remain in the Viewer when added. Instead, they will
    be housed underneath the Viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components are the tools located in the **Palette** drawers on the left-hand
    side of the Designer window (we will demonstrate what different components do
    once we start building apps). Once Components are dragged into the Viewer, they
    will also appear in the Components panel (found in the middle right of the Designer
    image). The Components panel lists Components and organizes them by screens. You
    can collapse and expand the screen Component contents for convenience. Components
    are listed in columns so that it is easy to see whether they exist on their own
    or within other Components.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate that some Components are inside other Components, the Components
    panel will display them in a nested (indented) list. Note that when you click
    on a Component in the Viewer, it will be highlighted in both the Viewer and the
    Components panel and display editable options in the **Properties** panel (described
    in the following section). And conversely, if you click on a Component in the
    Components panel, it will also be highlighted in the Viewer. Once a Component
    is clicked and it becomes active, you can either rename or delete it by clicking
    the **Rename** or **Delete** button or you can view or edit its settings in the
    Properties panel.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Properties** panel (found in the right-hand side column of the preceding
    Designer image) displays a set of configurable settings (such as size, color,
    and alignments) for each **Screen** and **Component** added to the **Viewer**.
    In the subsequent chapters, you will be adding more and more Components (and Screens),
    so make certain that the correct item is highlighted before you change its settings.
    The name of the active Component (or Screen) appears at the top of the Properties
    pane (in the earlier Designer screenshot, the active **Property** is **Screen1**
    as indicated at the top of the **Properties** panel).
  prefs: []
  type: TYPE_NORMAL
- en: Media
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Media** panel is located underneath the Components panel (see the Designer
    screenshot). This feature enables you to upload images, sound files, or other
    media files from your computer to your project. If you find a *creative commons*
    (freely shared, uncopyrighted) photo online that you'd like to use in your app,
    you must first download it and then click on the **Upload** File button in the
    media panel (you cannot download an image from the Internet directly into the
    App Inventor). Once the file is uploaded, it will be listed in both the **Media**
    panel and the Properties panel (to delete media files, click on the media file
    name and a popup will appear to delete the file). Note that even though the media
    files can also be added to the Properties panel, they cannot be deleted from the
    Properties panel. How to use an image, sound, or video file in your app will be
    explained in the future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've already logged into App Inventor with your Google Account, created a
    new project, named it Fling, and learned how to navigate the Designer screen.
    It's time to create your first mobile app!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since this is a tutorial, we will explain the way to play our game. But, if
    you were starting from scratch to create your own game, you would want to make
    sure that you've put in the time, effort, and energy to figure out what you want
    it to do and what you want it to look like. We outlined the design process for
    mobile app creation in [Chapter 1](part0014_split_000.html#DB7S2-9c0b907946184095a315b26c8a9b12bc
    "Chapter 1. Unleashing Creativity with MIT App Inventor 2"), *Unleashing Creativity
    with MIT App Inventor 2*. This may be a good time to review it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object of the Fling game app is to fling a moving ball with your finger
    to prevent it from hitting the bottom edge of the screen and ending the game.
    When the Play button is clicked, the ball will start moving from top to bottom.
    If it hits the bottom edge of the screen before the user flings it away, the game
    will stop and a **Game Over** notice will appear on the screen. The **Reset**
    button resets the ball to the top of the screen and the **Play** button starts
    another round. In this game, you will learn to design the user interface using
    these Components: a ball, a canvas (the game board), a horizontal layout, buttons,
    and a label. You will learn to program:'
  prefs: []
  type: TYPE_NORMAL
- en: An animated object (ball) that moves randomly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions where the ball will respond to a screen touch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An end-game mechanism when the ball touches the bottom of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A game over display when the game ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button that starts the game by moving the ball downward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button that resets the game by repositioning the ball at the top of the screen
    and erases the "game over" display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you build your app, you will see your progress unfold on your mobile device
    or emulator in real time using the **IDE** (**Integrated Development Environment**).
    Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI in designer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you will notice in a new project is that Screen1 automatically
    exists in the Viewer. As shown in the following screenshot, the name Screen1 appears
    in three places: in the **Viewer**, the **Components** panel, and the Properties
    panel. Note that this is also true for any component added to the Viewer. When
    a component is highlighted (as shown with a light green box) in the Components
    panel, you will see the corresponding properties for it in the Properties panel.
    While the name Screen1 is not editable, the properties associated with Screen1
    are such as the title, although we won''t be changing the Screen1 Properties in
    Fling.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a game interface for the Fling app, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the canvas Component to **Screen1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Palette drawer: **Drawing and Animation**. It will open to reveal
    three components: **Canvas**, **ImageSprite**, and **Ball**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Canvas** and drag it to the **Viewer**, as shown in the following
    screenshot:![Creating the UI in designer](img/00052.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your Designer window will look like the following screenshot. The Canvas component
    will automatically be named **Canvas1** in the Components panel. If you were to
    add another Canvas, it would automatically be named Canvas2\. It is possible to
    rename Canvas1, although we are not going to for this tutorial, since it is aptly
    named. You can see that it is active (as it is highlighted with a light green
    box) in both the **Viewer** and the **Components** panel. Being active means that
    you are able to see and edit its properties in the **Properties** panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Canvas is going to hold our Ball component, so we need to make it fill the
    whole screen not just a tiny part of the screen like it is now. To change the
    size of the Canvas, go to the **Properties** panel and click on the white text
    box below the **Height** element (currently filled with the word Automatic). A
    pop-up box will offer choices with radio buttons, as shown in the following screenshot.
    Click on the radio button next to **Fill Parent**. Click on the **OK** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Repeat these steps for the **Width**. You will see that the Canvas now fills
    the entire Viewer. Next we will change the color. At the top of the **Properties**
    panel, click on the word **White** underneath **BackgroundColor**. A drop-down
    list of colors will appear (not shown); select **Gray**. The Designer window should
    now look like the following screenshot with the gray canvas filling up the entire
    Viewer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will add a ball. Go back to the **Drawing and Animation** Capitalize
    Palette drawer, click on **Ball**, and drag it to the **Canvas** in the Viewer,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Ball will end up on the Canvas wherever you drop it. It is named Ball1 in
    the Components panel. Notice how Ball1 appears nested (indented) in the Components
    panel list. This is because you placed it within another component, the Canvas1.
  prefs: []
  type: TYPE_NORMAL
- en: You can position the ball's starting location, size, and color in the Properties
    panel. Since **Ball1** is already active, you can begin editing the options in
    the **Properties** panel. Change the settings to match those shown in the following
    screenshot. We will actually end up changing the ball's starting position once
    we start programming, but this is just to get you familiar with the features available
    in the Properties panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will create a menu bar at the bottom of the screen. Since we want
    the buttons to be horizontal across the bottom of the screen, we will open the
    **Layout** palette drawer. Drag **HorizontalArrangement** to the bottom of the
    **Viewer** so that it sits underneath the **Canvas** and not inside the **Canvas**.
    It should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will know you did this correctly by looking at the Components panel. HorizontalArrangement
    should be listed in the same column under Canvas1 and not be indented like Ball1\.
    If it is indented, it means that the HorizontalArrangement Component is inside
    the Canvas. We don't want that so, if it is, go to the **Viewer** and drag the
    **HorizontalArrangement** component out of the **Canvas** and position it below
    the **Canvas**. To shrink the size of **HorizontalArrangement**, edit the **Height**
    and **Width** options in the **Properties** panel to match the ones below. There
    are two ways to check whether you did this correctly. In the Viewer, HorizontalArrangement
    will create white space below the gray Canvas, as shown in the preceding screenshot.
    And, in the Components panel, HorizontalArrangement will align with Canvas1, as
    shown in the following screenshot. If you accidentally did this incorrectly and
    dropped HorizontalArrangement inside the Canvas, there would be no white space
    below the gray Canvas in the Viewer and the HorizontalArrangement component would
    be indented and aligned directly under Ball1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resize **HorizontalArrangement**, edit the **Height** and **Width** options
    in the **Properties** panel to match the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, drag a **Button** from the **User Interface** palette drawer into the
    **HorizontalArrangement** component at the bottom of **Screen1**. The button will
    say **Text for Button1**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI in designer](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can verify that you did this correctly by seeing whether your screen matches
    the **Viewer** in the preceding screenshot. Also, in the **Components** panel,
    you will see that **Button1** will be nested underneath **HorizontalArrangement**
    and will therefore be indented.
  prefs: []
  type: TYPE_NORMAL
- en: IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At any point during the app building process, you can see your progress live
    on your mobile device or on the emulator. You'll want to use this feature while
    building your app, so you can see updates as soon as you make changes in the Designer
    to track your progress, and see how your app looks on your device. Since we've
    made some changes, let's connect now, so you can get familiar with the process.
    As you've already done the technical setup in [Chapter 2](part0017_split_000.html#G6PI2-9c0b907946184095a315b26c8a9b12bc
    "Chapter 2. Setting Up MIT App Inventor 2"), *Setting Up MIT App Inventor 2*,
    you can easily start using the Integrated Development Environment (IDE).
  prefs: []
  type: TYPE_NORMAL
- en: '**For users with mobile devices**: on your computer in the Designer window,
    go to the top menu bar, click on Connect, and from the drop-down menu, select
    **AI Companion**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A pop-up window will appear on your computer screen with a QR code and a six-character
    code. Launch the AI2 Companion app on your mobile device and either scan the QR
    code or type in the six-character code. Note that to scan the QR code, you need
    to press the blue button on your mobile device that says **scan QR code** and
    then hold the mobile device up to the computer screen to capture the image. Scanning
    the QR code with your mobile device will automatically launch your Fling app after
    a few moments. To connect with the code, type the six-character code shown on
    your computer screen into the white text box on your mobile device and then click
    on the orange button **Connect with code** to display the Fling app on your mobile
    device.
  prefs: []
  type: TYPE_NORMAL
- en: '**For users** **without mobile devices**: On your computer in the Designer
    window, go to the top menu bar, click on **Connect** and, from the drop-down menu,
    select **Emulator**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The emulator will take a few minutes to launch. You will see pop-up messages
    about the progress and the status of the emulator (to review connecting with the
    emulator, please see [Chapter 2](part0017_split_000.html#G6PI2-9c0b907946184095a315b26c8a9b12bc
    "Chapter 2. Setting Up MIT App Inventor 2"), *Setting Up MIT App Inventor 2*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that at any point throughout the app building process, if you have trouble
    connecting or if the modes of connection are grayed out, you may need to choose
    **Reset Connection** from the drop-down menu, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on Reset Connection, the choices for connecting will become
    clickable again. Choose the method you previously used: **AI Companion** or **Emulator**
    (remember, for WiFi connection to work, your computer and mobile device must be
    on the same WiFi network). For connecting via USB, please review the instructions
    in [Chapter 2](part0017_split_000.html#G6PI2-9c0b907946184095a315b26c8a9b12bc
    "Chapter 2. Setting Up MIT App Inventor 2"), *Setting Up MIT App Inventor 2*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait a few seconds after connecting and you will see one of the following images
    (the screenshot of a mobile device on the left-hand side and an emulator on the
    right-hand side):'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you've connected your project to your mobile device or emulator, all
    the changes you make on your computer will automatically be updated on your device
    or emulator. This is particularly helpful because a component on your computer
    screen could be displayed somewhat differently on your mobile device or emulator.
    It is always a good idea to check periodically to see how your app is taking shape
    on your mobile device or emulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Designer. You can change the look and the text of **Button1**
    by editing the **Properties**. Change the options to reflect the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how your mobile device or emulator also updates in real time and displays
    the changes you just made to Button1, as shown in the following images (the screenshot
    of a mobile device on the left-hand side and an emulator on the right-hand side):'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You are now going to add another **Button** to the **HorizontalArrangement**
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you drag the Button from the **User Interface** palette drawer, App Inventor
    will name this button as **Button2**, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how your mobile device or emulator also updates in real time, as shown
    in the next images (the screenshot of a mobile device on the left-hand side and
    an emulator on the right-hand side):'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is always a good practice to rename your components when you have more than
    one of a kind, or to reflect what they will do. Soon your apps will have multiple
    buttons, screens, and more. So, it''s helpful to use specific names. **Button1**
    is the **Play** button, so let''s rename it accordingly. Click on **Button1**,
    so it is highlighted in the **Components** panel. Then, click on **Rename** at
    the bottom of the panel. A pop-up window will give you the option to type in a
    new name, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will see the new name listed in the Components panel. Note that App Inventor
    converted the space between the two words into an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that if we had changed the name of Button1 to Play_Button before adding
    the second button, when you dragged out the second button, it would've been named
    as Button1\. This can be confusing, so it's always a good idea to rename your
    components rather than keeping track of the order you added them, especially because
    in this case, Button1 would not have been the first button you added, but the
    second one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the steps listed earlier to rename **Button2** to **Reset** button.
    Then, edit the **Properties** of **Reset_Button** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that while we changed the names of the **Button** components to **Play_Button**
    and **Reset_Button**, the text on the buttons remains what we typed in the text
    fields: **Play** and **Reset**, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how your mobile device or emulator also updates in real time. Here is
    a good example of why you would want to take advantage of the Integrated Development
    Environment. As you can see in the previous screenshot, a space appears between
    the two buttons in the designer, but on the mobile device (in this case, a tablet)
    and on the emulator, there is no space, as shown in the following screenshot.
    By continuously monitoring how your app looks (and later functions) on your device
    as you build it, you are ensuring at each step of the way that your app will appear
    and work as you intended.
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are going to add a Label to display some text (and ultimately the score).
    Go to the Palette **User** **Interface** drawer and drag out a **Label** onto
    **HorizontalArrangement**. You can place it anywhere you want in the menu bar,
    but for the purpose of this tutorial, we will drag it in between the **Play**
    and **Replay** buttons. Adjust the label properties to reflect this in the next
    screenshot and rename the Label Component to **Score** (note that underneath the
    **Text** property, we have deleted **Text for Label1**, so it appears empty).
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have completed designing the UI of the Fling app! Notice
    how nothing happens to the ball when either of the buttons is pushed. This is
    because we haven't programmed the behavior of the Components yet. Next, we will
    switch to the Blocks Editor to start coding.
  prefs: []
  type: TYPE_NORMAL
- en: The Blocks editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To switch to the Blocks editor, click on the **Blocks** button in the upper-right
    corner of the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Blocks editor](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Blocks window has a Blocks panel (left), a Viewer (the large white workspace),
    and a Media panel (in the lower-left corner). The Media panel operates in the
    same manner as the designer, although we won't be using it for this app.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Blocks editor](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All the tools you need to program your app are in the Blocks panel on the left-hand
    side of the window. The first set of Blocks shown with small colored boxes is
    called Built-in (you will learn about these as we build our app). Below the Built-in
    blocks are the blocks relating to the Components you just added in the Designer.
    Below the Component blocks is a list of Any Component blocks. We will not be using
    these in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the Blocks editor is similar to the Designer. When you click on a
    block in the Blocks panel, a pop-up drawer will appear to reveal many colored
    puzzle-like blocks. The block you click on will automatically appear in the white
    workspace called the Viewer. To program your app, you need to drag one block into
    another, and hear and see it snap into place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you start filling up the Viewer with blocks, it can get crowded. There
    are two ways to use more of the workspace: by using the bottom and side gray scroll
    bars or by clicking and dragging on the white space itself. This will become evident
    once the blocks are in place.'
  prefs: []
  type: TYPE_NORMAL
- en: The Blocks drawer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you click on any of the blocks'' categories in the Blocks panel, a pop-up
    drawer of available blocks will appear. The following screenshot shows some of
    the available blocks for the Play_Button component (the gray scroll bar indicates
    that there are more blocks than what is shown on the screen. You can see the rest
    of the blocks by scrolling down):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Blocks drawer](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Types of Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Component Blocks are made up of different kinds of blocks. For this app, we
    will be using three kinds of blocks: **event**, **setters**, and **getters**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Blocks**: They are gold, and if they exist for a certain component,
    they will appear at the top of any pop-up Blocks drawer. They launch an event,
    such as **when Play_Button.Click**. To program what happens when the **Play**
    button is clicked, you can snap together other puzzle piece blocks called setters
    and getters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setters**: They are dark green or orange puzzle piece blocks that say set
    because they set a property''s value. Notice that setters have an opening at the
    end. Another type of block, a getter, fits into that space and so the setter can
    get a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getters**: They are colored puzzle piece blocks that fit at the end of the
    setters. They give a property value to the setters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in** blocks have a variety of different colors and purposes. We will
    explain them as we use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Blocks to program Fling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now begin using blocks to code our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Play button
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Click on **Play_Button** in the **Blocks** panel to open its drawer. Then, click
    on the top gold **when Play_Button.Click** event block as shown in the next screenshot.
    It will now appear in the **Viewer**.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When a user clicks on the app's **Play** button, we want the game to begin and
    the ball to start moving. So, we need to program these steps.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we are going to position the ball at the top of the screen and
    have it move down toward the bottom of the screen. But we don't want to set it
    all the way at the top of the screen because, in the next chapter, we are going
    to program our app, so that, every time the ball hits the top edge, the user will
    score a point. To avoid scoring points by merely pressing Play or Reset, we must
    position the ball a little below the top edge. To do this, we need to set a pair
    of the (x, y) values for the Canvas. The x value is where the ball will be horizontally
    on the screen and the y value will be the ball's vertical position. The x value
    is defined as the number of pixels from the left edge of the Canvas and y is defined
    as the number of pixels from the top edge of the Canvas. We decided that we don't
    want y to be 0, as the ball would be touching the edge, so we can set the y value
    to something close to 0, such as 2\. We can set the x value to any value along
    the width of the Canvas. To make the game more unpredictable, we will program
    the app to pick a random value for x. Then, each time the user hits Play or Reset,
    the ball will start at a different location horizontally on the screen (although
    it will always start 2 pixels from the top, since we are setting y = 2). To set
    the ball's starting location, we will select a block from the Ball1 drawer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Ball1** in the **Blocks** panel. A drawer will open with all the
    available blocks for **Ball1**. Use the gray scroll bar to the right of the pop-up
    drawer to scroll down past the gold event blocks. Click on the purple procedure
    block: **call Ball1.MoveTo x, y**, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The purple procedure block will now appear next to the **when Play_Button.Click**
    gold event block in the **Viewer**. Notice how the shape of this purple block
    fits inside the gold block. Go ahead and place it into the gold block (by clicking
    on it with your mouse and dragging it). The gold block will expand to accommodate
    the purple block. You will hear and see it snap into place, as shown in the following
    screenshot on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that we want the value of **y** to be equal to 2, so we will find a
    block (a getter) to get this value. Click on the **Math** block in the **Built-in**
    section. The **Built-in Math** blocks have a little blue box next to it. A drawer
    will open up with the available blue **Math** getter blocks. Click on the first
    one with the value of **0**, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **0** block will appear in the **Viewer**, and you can drag it and snap
    it to the *y* value. Click on **0** to highlight it. You can type in the number
    `2` to change the value to `2`, as shown in the following screenshot. Next, we
    are going to set the *x* value to a random integer. Go back to the **Math** blocks
    and click on the last block shown in the preceding screenshot: **random integer
    from 1 to 100**. Drag this block to the *x* value, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since users will have mobile devices with different screen sizes, we won''t
    know whether the width will be 100 pixels or 350 pixels. So, to enable the game
    to be played on different size screens, we can remove the **Math** block with
    the value of **100** and insert a getter block instead that will get the screen
    width of the mobile device the user is using. To delete the blue **100** block,
    click on it to outline it in yellow. A little hand icon will appear. This indicates
    that you can drag the block out of the slot, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that if you don't see the hand icon, it just means that you clicked on
    the actual number instead of the block. This will be indicated by a cursor and
    a little bit of white space to the right of the number. Click again on the actual
    blue part of the number puzzle piece and you will see the hand icon, which will
    allow you to drag the block out.
  prefs: []
  type: TYPE_NORMAL
- en: To delete this block (or any unwanted block), click on it (if it is not already
    highlighted in yellow) and hit *Delete* on your computer's keyboard. Or, you can
    drag the block to the lower-right corner of the Viewer to throw it in the trash.
    Hover the block over the trash can and the lid will open. When you release the
    block, it will disappear. You will see it fade away and hear a crumple sound.
  prefs: []
  type: TYPE_NORMAL
- en: To add the a block indicating the user's screen width block, click on **Screen1**
    in the **Blocks** palette and choose **Screen1.Width** from the drawer. It will
    be near the bottom, so you can use the gray scroll bar to scroll down and find
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that to drop this block inside another block (whether an equation or a
    single block), align the little puzzle piece nib on the left-hand side of the
    block with the nib space on the left-hand side of the block''s opening and it
    will easily snap into place. Your blocks should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Play button](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Every time a user presses **Play**, the ball will be positioned at a different
    place along the width of the screen and **2** pixels from the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have positioned the ball, we will now program it to move.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the ball
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we've programmed the ball to start at the top of the screen, we want the
    ball to move downward. Instead of it just dropping straight down or at the same
    angle each time, we can set the degrees to be random. There are 360 degrees in
    a circle, but we only want the ball to fall between certain degrees, those represented
    as downward that fit between the width of the screen, but not along the edges
    of the screen. The figure below shows that the right edge is **0** degrees and
    the left edge is **180** degrees. The actual space that we are interested in is
    the lower half or the degrees between **180** and **360**. Since we don't want
    the ball to just travel down the edges, we will eliminate the two extremes when
    choosing some numbers. We decided to choose degrees between **200** and **340**.
    We will code the app so that the program will choose a random number between those
    degrees for the angle at which the ball will move.
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the ball](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You already learned how to program a random integer from our previous blocks,
    so let''s repeat those steps. Go to the **Math** blocks and choose the blue **random
    integer from to** block. You also know how to fill in these numbers. To review,
    choose the topmost blue block in the **Math** blocks: the one with **0**. You
    can enter **200** in it and then copy and paste the block by clicking on it to
    highlight it (make sure it has a yellow outline). If you don''t want to copy and
    paste, you can always drag out another **Math 0** block. Click on the number in
    the copied block and type **340**. Then, place the **200** block into the **from**
    spot and the 340 block into the **to** spot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our **random integer from to** block needs to fit someplace, to which block
    will it be giving this information? Another way to ask this question is: which
    block will be getting this information? If you guessed Ball, you are correct!
    The ball will need this information to know the angle at which it has to move.
    So, we need to find the ball block that represents the ball''s direction. This
    block is called **Ball1.Heading**, and it represents the degrees the ball will
    move. Click on the **Ball1** Blocks drawer to find the dark green **Ball1.Heading**
    block (you will need to scroll down past the gold and purple blocks to find it).
    Once this is on your **Viewer**, snap it together with the blue **random integer
    from to** block that you just created. Then, take these connected pieces and insert
    them at the bottom of the gold **when Play_Button.Click**. Your blocks should
    now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the ball](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the location of the ball and the direction it is heading in
    degrees, we need to program it to actually move. To do this, we will first set
    the ball to enabled. From the **Ball1** blocks drawer, choose the dark green **set
    Ball1.Enabled to** block. Then, from the **Logic** blocks drawer, choose the lime
    green **true** block at the top, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the ball](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Insert the **true** block into the **set Ball1.Enabled to** block and add them
    to the bottom of the **when Play_Button.Click** event, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the ball](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that the ball is ready to move, we can actually move it by setting the speed
    and the interval. Go back to the **Ball1** Blocks drawer and select the dark green
    setter block, **set Ball1.Speed**. Next, from the same drawer, select **set Ball1.Interval**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interval is the amount of time, in milliseconds (*1000 milliseconds = 1
    second*), the ball will travel, and the speed is the number of pixels the ball
    will move in that timeframe. It''s fun to play around with these numbers to see
    how fast or slow you can make the ball move. We''ve decided to have the ball move
    **10** pixels every **50** milliseconds, so we will program our blocks to look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the ball](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Insert these blocks at the bottom of the **when Play_Button.Click** event.
    Your blocks will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the ball](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, this is what our app does: when the **Play** button is clicked, it
    will move the ball to position it **2** pixels away from the top edge of the screen
    and to a random number between **1** pixel from the left edge of the screen and
    the right edge of the screen. It will set the ball rolling downward in a random
    direction (between the degrees **200** to **340**) at a speed of **10** pixels
    every **50** milliseconds!'
  prefs: []
  type: TYPE_NORMAL
- en: Flinging the ball
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The object of the game is to fling the downward moving ball away from the bottom
    edge, because if the ball drops down to the bottom edge of the screen, the game
    will end. Next, we need to code these events.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's program the app to fling the ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'How will the ball know when a finger touches it and how to move in another
    direction (not downward)? We can program these events by using a block from the
    **Ball1** Blocks drawer called **when Ball1.Flung**. Click on this gold event
    block to add it to the Viewer. You can make the ball move at any speed you like,
    but we are going to keep it going at the same speed, just in a different direction.
    To do this, you can copy and paste the **set Ball1.Speed to** and **set Ball1.Interval
    to** blocks from the **when Play_Button.Click** event (note that when you click
    on the dark green set block and copy and paste it, the blue getter block attached
    to it will also copy and paste). Add these blocks to the **when Ball1.Flung**
    event to resemble the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flinging the ball](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will reposition the direction of the ball to go upward (when it is
    flung by a finger). We could set the heading to a degree between 10 and 170 (see
    *image #39*) or we could make the ball go in the upward direction with an equation.
    Let''s practice equations more. Copy and paste the **set Ball1.Heading** block
    from the **when Play_Button.Click** event (remember the heading block determines
    the angle at which the ball will move). Drag it to the bottom of the **when Ball1.Flung**
    event. We want the ball to go in the opposite direction than the direction in
    which it was heading, not to a random integer, so you can delete the attached
    blue block by highlighting it and pressing **delete** on your keyboard or by clicking
    on the blue block and dragging it to trash. To get the ball to go in the opposite
    direction, we are going to subtract the current ball''s heading (direction) from
    360 degrees (the total number of degrees possible). To code this, choose the minus
    block from the **Math Blocks** drawer. In the first open space, add the number
    **360**. Copy and paste the **50** blue block from the **when Ball1.Flung** event
    and change the number to **360**. Insert it into the open space to the left of
    the minus sign.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, from the **Ball1** Blocks drawer, select the light green getter block,
    **Ball1.Heading**. Insert it in the open space to the right of the minus sign
    (line up the block nib with the open nib). Here is what we have coded: when the
    ball is touched and flung, the program will move the ball''s direction (or heading)
    to 360 degrees minus the old direction (or heading). Your blocks will look like
    the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flinging the ball](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Ending the game or bouncing the ball
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that the Play Button starts the ball moving downward and the user can fling
    it in a different direction, we want to program the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game when the ball touches the bottom edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bouncing the ball off the left, top, and right edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can program these actions with the **if**/**then** blocks. **If** the ball
    touches the bottom edge, **then** the ball will stop and the game will end. **If**
    the ball touches the other edges, **then** the ball will bounce back and the game
    will continue.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first program the app to stop and end the game when the ball hits the
    bottom edge. App Inventor makes this easy. Go to the **Ball1** Blocks drawer and
    click on the **when Ball1.EdgeReached** event. Once the event block is in the
    Viewer, hover (don't click) on the light orange word **edge** on the left-hand
    side of the block and you will get a popup, as shown in the next screenshot. Choose
    the top dark orange **get edge** block. This is a variable. Set it aside; we will
    use it in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will add an **if then** event to the inside of the when **Ball1.EdgeReached**
    event. But first we will configure it. Go to the topmost **Blocks** drawer called
    **Control** and click on the first gold **if then** block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the block first appears on your **Viewer**, it will look like *Step 1*
    in the following image. If you click on the blue color square in the upper-left
    corner, a popup will appear. Move your cursor over the bottom **else** block on
    the left-hand side of the popup, click on it, and drag it into the **if** opening
    on the right-hand side of the popup, as shown in *Step 2* and *Step 3*. Once the
    **else** block is in place, you will see the original **if then** event block
    change into an **if then else** block. You will see that **else** is now added
    to the bottom of the block, as shown in *Step 3* and *Step 4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add this **if then else** block to the inside of the when **Ball1.EdgeReached**
    block, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how the get edge block that we set aside has an exclamation point with
    a triangle around it. This is an error message alerting you that the block is
    unattached and is in need of a setter block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To program, **if** the ball touches the bottom edge, **then** the ball will
    stop and the game will end. We will use a **math equals** block. It is the second
    one from the top in the **Math Blocks** drawer, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inside the first opening to the left of the equal sign, add the dark orange
    **get edge** block that we had set aside. You will notice that the alert will
    remain on this block until we snap the math block in place with the **if** block,
    which we will do shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next image, you will see that each edge is represented by a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since the bottom edge is equal to **-1**, add a number Math block to this equal
    block and enter the number **-1**. Snap the blue math block into the **if** block,
    as shown below (and you will see the alert disappear).
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the bottom edge is reached, we want the ball to stop, the game to end,
    and the app to display the text **Game Over**. We already know how to enable the
    ball to move: we set the property enabled to **true**. So, now that we want the
    ball to stop or not move, we must set the enabled property to **false**. In the
    **Ball1** blocks drawer, select **set Ball1.Enabled to** and then in the **Logic**
    blocks drawer select the **false** block. Slide that set of blocks into the **then**
    space of the **if then else** block, as shown below.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will program the app to display some text indicating that the game
    is over. We will use the Label that we named **Score** (in the next chapter, we
    will also use this Label to display the score). Go to the **Score** blocks drawer
    and select the dark green **set Score.Text to** block, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This setter block needs to get some text, so we will add a getter text block.
    Go to the pink **Text** block drawer and choose the first block, which is an empty
    space with quotes around it, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will add this pink text block to the **set** **Score.Text to** block and
    insert it below the **set Ball1.Enabled to** block in the **then** event. Click
    on the pink text block and type the words **Game Over**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have programmed the app so that if the ball hits the bottom edge, it will
    stop moving and the Label will display the text: **Game Over**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step, the **else** block, is for when the ball hits an edge other
    than **-1** (the bottom). If the ball hits any of the other edges, we want the
    ball to bounce off them and the gameplay to continue. To program this, we''ll
    use the purple **call Ball1.Bounce** block. We will attach the same orange **get
    edge** block we used previously, but this time, we won''t specify a certain edge.
    Any edge that the ball touches, other than the bottom edge, will cause the ball
    to bounce. Copy and paste the **get edge block**, add it to the purple **call
    Ball1.Bounce** block, and insert the blocks into the **else** slot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Think of **else** as meaning *otherwise*. If the ball hits an edge equal to
    **-1**, then execute the **then** code, otherwise execute the **else** code. In
    other words, if the **if** option is not met (if the ball doesn't hit the **-1**
    edge), then the program will skip **then** and jump to **else**.
  prefs: []
  type: TYPE_NORMAL
- en: Following is a screenshot of our app when the ball hits the bottom edge, stops,
    and displays **Game Over**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game or bouncing the ball](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Reset button
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last thing we will do in this chapter is configure the **Reset** button.
    The **Reset** button gets pressed after the game has ended due to the ball hitting
    the bottom edge. It doesn't start the gameplay like the **Play** button does;
    it merely repositions the ball back at the top of the screen and makes the **Game
    Over** text disappear from the screen (Label).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the **Reset Button** Blocks and choose the gold event **when Reset_Button.Click**.
    We want to move the ball from the bottom of the screen to the top of the screen.
    We already know how to do this because we did it for the Play Button. You can
    copy and paste the call **Ball1.MoveTo** purple block (when you click on the purple
    block and copy and paste it, it will automatically copy and paste the blue *x*,
    *y*, getter blocks attached to it). Add your blocks to the **when Reset_Button.Click**
    event, and your blocks will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Reset button](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These blocks reposition the ball back up to the top of the screen (to a random
    **x** location), but the **Game Over** text will still be displayed. To have the
    Reset Button erase this, we will simply set the **Score Text** to blank text instead
    of **Game Over**. Copy and paste the dark green **set Score.Text to** block from
    the **when Ball1.EdgeReached** event block (copying and pasting the green Setter
    block will also copy and paste the pink text block). Click on the **Game Over**
    text and press *Delete*, so the text area is empty. Add this set of blocks to
    the bottom of the **when Reset_Button.Click** event block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Reset button](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following is a screenshot of our app after the **Reset** button is pressed.
    It shows the ball up at the top of the screen and a blank area where the **Game
    Over** text previously appeared.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Reset button](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our first version of the Fling app is now complete! We have designed and coded
    the Fling app, so when the Play Button is clicked, it will randomly position the
    ball at the top of the screen and start the ball rolling downward. Flinging the
    ball with a finger causes the ball to move in the opposite direction to than was
    going. The ball bounces of all the edges, except for the bottom one. When the
    ball hits the bottom edge, it stops and the app displays **Game Over**. The **Reset**
    button repositions the ball to a random position at the top of the screen. At
    this point, you may or may not have discovered that we have a bug! It has something
    to do with the Play and Reset buttons. We will reveal and fix this bug in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! You have learned a great deal about the App Inventor platform in this chapter
    and you have built and programmed your first app! This is a huge accomplishment!
    But, as you may have noticed, we have an issue to fix. We will demonstrate not
    only how to debug your first bug, but also how to add more features. Really, this
    is just the beginning of your mobile computing adventure. There is much more to
    learn and create! Our Fling app is functional and simple, but I'm sure you can
    think of countless more features to enhance it. In the next chapter, you will
    learn how to expand the app's complexity by creating a scoring mechanism that
    is displayed when the ball touches the top edge, by allowing the ball to be flung
    only from the lower half of the screen, and by creating levels and increasing
    the speed of the ball
  prefs: []
  type: TYPE_NORMAL
- en: By learning how to add more functionality to an existing app, you will gain
    experience developing multiple versions. This process of building an app with
    added features is what developers regularly do. Ultimately, once you post your
    app in an app market like Google Play, the new versions would be released as updates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take our game to the next level!
  prefs: []
  type: TYPE_NORMAL
