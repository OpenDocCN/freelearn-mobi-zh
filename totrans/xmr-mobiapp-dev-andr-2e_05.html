<html><head></head><body><h1 id="e-sGcD">Chapter 5. Adding a Details View</h1>
<p id="e-dRMr">In this chapter, we will walk you through the process of creating a new activity to display the details of the selected POI. This activity also allows the user to create, update, and delete POIs from the server. The following topics will be covered in this chapter:</p>
<ul id="e-eYng">
<li id="e-ElPJ">Creating the layout and activity for displaying POI details</li>
<li id="e-Ltya">Using <code>LinearLayout</code>, <code>TableLayout</code>, and <code>ScrollView</code> to lay out the activity</li>
<li id="e-WQJO">Passing data between the activities using Intent bundles</li>
<li id="e-CbOA">Consuming web services to perform the HTTP <code>POST</code> and <code>DELETE</code> operations</li>
<li id="e-BBGE">Performing the <code>EditText</code> validation using the <code>EditText.Error</code> property</li>
<li id="e-XWms">Displaying confirmation prompts</li>
</ul>
<h1 id="e-YS1T">Creating the POIDetail layout</h1>
<p id="e-y5gW">So far, we have built the <code>POIApp</code> to display the list of POIs fetched from the server. Currently, the list view displays limited information about POIs such as name, address, image, and distance. Let's now extend the <code>POIApp</code> by adding another activity that displays detailed information of the selected POI. The POI details activity will be revealed only when the user taps on any of the POI item from the list or when the user selects the <strong>New</strong> (<strong>+</strong>) action from the navigation bar. Additionally, the details activity will allow the user to create a new POI, update, or delete the existing POI.</p>
<p id="e-v6cz">Keeping all the preceding use cases in mind, let's create a new layout for POI details:</p>
<ol id="e-lmFj">
<li id="e-Hhk7">Select the <code>Resources/layout</code> folder in the <strong>Solution</strong> pad.</li>
<li id="e-QaeQ">Right-click on <strong>Add</strong> and select <strong>New File</strong>.</li>
<li id="e-fINX">In the <strong>New File</strong> dialog box, click on <strong>Android</strong> and select <strong>Layout</strong>, enter POI detail in the <strong>Name</strong> field, and select <strong>New</strong>.</li>
</ol>
<p id="e-tKF7">Notice that a new file is created with <code>LinearLayout</code> as the top-level container. The <code>POIDetail</code> view will have a number of fields and will likely require scrolling on devices with a smaller screen size. The default Android layout managers, such as <code>LinearLayout</code>, <code>RelativeLayout</code>, <code>FrameLayout</code>, or <code>TableLayout</code>, do not provide automatic scrolling when the content grows and the data goes beyond its actual screen size.</p>
<p id="e-BzfK">In our previous chapter, for displaying the POI list, the layout gave us scrolling for free because we were using <code>ListView</code>; however, in the case of the POI detail activity, we need to use <code>ScrollView</code> for making the items scrollable.</p>
<h2 id="e-g0og">Understanding ScrollView</h2>
<p id="e-Fywa"><code>ScrollView</code> is a special kind of layout designed to hold a view larger than its actual size. When the child's Views size grows beyond the <code>ScrollView</code> size, it automatically adds the scroll bar and can scroll vertically. The following are some of the key things you must to know before using ScrollView:</p>
<ul id="e-CYep">
<li id="e-H4PJ">
<code>ScrollView</code> can hold at most one direct child. This means that if you have a complex layout with multiple children, then you must enclose them inside another standard layout, such as LinearLayout, TableLayout, or RelativeLayout.</li>
<li id="e-rxVX">Like any other standard layout manager, the <code>layout_height</code> and <code>layout_width</code> attributes can be used to adjust the height and width of <code>ScrollView</code>.</li>
<li id="e-i9ox">
<code>ScrollView</code> is ideal for screens where scrolling is required, but it is an overhead when scroll view is used to render a larger collection of data. For such instances, you should consider using specialized adapter views, such as <code>ListView</code> and <code>GridView</code>.</li>
<li id="e-xHR4">Never place a <code>ListView</code> or <code>GridView</code> inside <code>ScrollView</code> because they both take care of their own vertical scrolling. By doing so, the <code>ListView</code> child will never receive gestures because it will be handled by the parent <code>ScrollView</code>.</li>
<li id="e-y9hL">
<code>ScrollView</code> only supports vertical scrolling. For horizontal scrolling, you can use <code>HorizontalScrollView</code>.</li>
<li id="e-R5O8">The <code>android:fillViewport</code> property defines whether the <code>ScrollView</code> should stretch its content to fill the viewport. You can set the same property by calling the <code>setFillViewport(true)</code> method on <code>ScrollView</code>.</li>
</ul>
<p id="e-iF18">Now that we understand <code>ScrollView</code>, let's jump back to the <code>POIDetail</code> layout and add a <code>ScrollView</code> to support vertical scrolling of content for devices of smaller screen size:</p>
<ol id="e-JG1C">
<li id="e-NvjE">With the <code>POIDetail.xaml</code> file opened in the <code>Content</code> view, select the top-level <code>LinearLayout</code> and press the <em>Delete</em> key.</li>
<li id="e-MlpJ">In the <strong>Toolbox</strong> pad, locate the <strong>ScrollView</strong> widget and drag it onto the Content view.</li>
<li id="e-hj7g">In the <strong>Toolbox</strong> pad, locate the <strong>LinearLayout</strong> (vertical) widget and drag it onto the Content view inside <code>ScrollView</code>.</li>
<li id="e-K8sw">With <code>LinearLayout</code> selected, set <strong>Padding</strong> in the Layout section of the <strong>Properties</strong> pad to <code>5dp</code>.</li>
</ol>
<p id="e-MpYf">We are now ready to add labels and edit controls to the layout. The following screenshot depicts the layout we are trying to achieve:</p>
<img data-width="600" data-height="548" src="img/PIsRjcV4.jpg"/><p id="e-jZlD">We will use simple <code>TextView</code> widgets to serve as labels and <code>EditText</code> widgets to serve as input controls. The <code>EditText</code> widget contains a number of properties that can be used to customize its behavior. One of these properties is named <code>InputType</code>, and it controls aspects such as which type of keyboard to use for inputs (alpha, numeric, and so on) and how many lines of text are allowed. The <strong>Toolbox</strong> pad presents a number of templates or preconfigured <code>EditText</code> widgets in the list under the group name <strong>Text Fields</strong>.</p>
<p id="e-Gu1H">The following screenshot depicts the list:</p>
<img data-width="324" data-height="478" src="img/FJbX9Qgz.jpg"/><p id="e-bQSP">Add a series of <code>TextView</code> and <code>EditText</code> controls to the <strong>Name</strong>, <strong>Description</strong>, and <strong>Address</strong> fields. Name the <code>EditText</code> widgets according to the following table and use the corresponding Toolbox widget so that the appropriate editing characteristics are applied:</p>
<p id="e-pezG">Name</p>
<p id="e-sVjl">Widget toolbox name</p>
<p id="e-CMHn"><code>nameEditText</code></p>
<p id="e-mCAQ"><strong>Plain Text</strong></p>
<p id="e-cegW"><code>descrEditText</code></p>
<p id="e-phjN"><strong>Multiline Text</strong></p>
<p id="e-XFLn"><code>addrEditText</code></p>
<p id="e-Y0ky"><strong>Multiline Text</strong></p>
<p id="e-ykt6">We are now ready to address the <strong>Latitude</strong> and <strong>Longitude</strong> fields, and we will employ a new layout manager, <code>TableLayout</code>.</p>
<h2 id="e-TbE3">Using the TableLayout manager</h2>
<p id="e-z5S3">The <code>TableLayout</code> manager is an extension of <code>LinearLayout</code>. As the name indicates, <code>TableLayout</code> is used to align a child's View elements in rows and columns format.</p>
<p id="e-qBLd">The concept of <code>TableLayout</code> works something similar to an HTML table. <code>TableLayout</code> consists of the <code>&amp;lt;table&amp;gt;</code> tag and <code>TableRow</code> is like a <code>&amp;lt;tr&amp;gt;</code> element. You can add any view or view group inside a table cell.</p>
<p id="e-F2Lu">We would like to add the <strong>Latitude</strong> and <strong>Longitude</strong> fields in a table. Let's add a <code>TableLayout</code> with two rows and two columns with the top row being used for the labels and the bottom row being used for the edit fields. In order to do so, perform the following steps:</p>
<ol id="e-orzL">
<li id="e-l0AR">Locate <code>TableLayout</code> in the <strong>Toolbox</strong> pad, drag it onto the Content view below the <code>addrEditText</code> widget and drop it. A <code>TableLayout</code> will be created with three rows and three columns.</li>
<li id="e-k4Te">Select one of the rows in <code>TableLayout</code>, right-click on it and select <strong>Delete Row</strong>.</li>
<li id="e-DoDU">Select one of the columns in the <code>TableLayout</code>, right-click on it and select <strong>Delete Column</strong>.</li>
<li id="e-vjGF">Select the first column, right-click on and select <strong>Stretch Column</strong>. Similarly, do it for the second column.</li>
</ol>
<p id="e-FiWP">You should now have a <code>TableLayout</code> with a visible outline of two rows, each having two columns like what is depicted in the following screenshot:</p>
<img data-width="452" data-height="140" src="img/hGGSLbu3.jpg"/><p id="e-Up10">We now need to add the <code>TextView</code> widgets for the two labels in the first row and number (decimal) widgets for the <strong>Latitude</strong> and <strong>Longitude</strong> edit controls, naming them <code>latEditText</code> and <code>longEditText</code>.</p>
<p id="e-RyK6">We have now completed the <code>POIDetail</code> layout, and the Content view you see should look the same as the preceding screenshot.</p>
<h2 id="e-g43F">Working with EditText's InputType</h2>
<p id="e-TWmW">The <code>EditText</code> element provides a property named <code>InputType</code> that checks the behavior of the control when data is being entered. When the description and address widgets were added, we selected <strong>Multiline Text</strong> from the <strong>Toolbox</strong> pad. The following code shows that in this case the <code>inputType</code> was automatically set:</p>
<pre id="e-FjGF">&amp;lt;EditText
     android:inputType="textMultiLine"
     android:layout_width="fill_parent"
     android:layout_height="wrap_content"
     android:id="@+id/descrEditText" /&amp;gt;</pre>
<p id="e-XnNU">The <code>InputType</code> property can also be set or changed from within the <strong>Properties</strong> pad under the <strong>Widget</strong> tab in the <strong>Input Format</strong> section. What may not be obvious is that <code>inputType</code> can combine values, which come in handy in our situation. The following table shows a reasonable set of values for <code>inputType</code>; feel free to experiment:</p>
<p id="e-BflN">Widget</p>
<p id="e-O6fC">Input type</p>
<p id="e-JWLs"><code>nameEditText</code></p>
<p id="e-W9tF"><code>inputType="textCapWords"</code></p>
<p id="e-kEqx"><code>descrEditText</code></p>
<p id="e-Plph"><code>inputType="textMultiLine|textCapSentences"</code></p>
<p id="e-qNwr"><code>addrEditText</code></p>
<p id="e-yWR6"><code>inputType="textMultiLine"</code></p>
<p id="e-hC0R"><code>latEditText</code></p>
<p id="e-zpZb"><code>inputType="numberDecimal|numberSigned"</code></p>
<p id="e-vSLq"><code>longEditText</code></p>
<p id="e-mz3L"><code>inputType="numberDecimal|numberSigned"</code></p>
<p id="e-oQNW">Switch to the Code view to see what has been added to the layout:</p>
<pre id="e-SEeb">&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;ScrollView 
    p1:minWidth="25px"
    p1:minHeight="25px"
    p1:layout_width="match_parent"
    p1:layout_height="match_parent"
    p1:id="@+id/scrollView1"&amp;gt;
    &amp;lt;LinearLayout
        p1:orientation="vertical"
        p1:minWidth="25px"
        p1:minHeight="25px"
        p1:layout_width="fill_parent"
        p1:layout_height="fill_parent"
        p1:id="@+id/linearLayout1"
        p1:padding="5dp"&amp;gt;
        &amp;lt;TextView
            p1:text="Name"
            p1:layout_width="fill_parent"
            p1:layout_height="wrap_content"
            p1:id="@+id/textView10" /&amp;gt;
        &amp;lt;EditText
            p1:layout_width="fill_parent"
            p1:layout_height="wrap_content"
            p1:id="@+id/nameEditText"
            p1:inputType="textCapWords" /&amp;gt;
        &amp;lt;TextView
            p1:text="Description"
            p1:layout_width="fill_parent"
            p1:layout_height="wrap_content"
            p1:id="@+id/textView11" /&amp;gt;
        &amp;lt;EditText
            p1:inputType="textMultiLine|textCapSentences"
            p1:layout_width="fill_parent"
            p1:layout_height="wrap_content"
            p1:id="@+id/descrEditText" /&amp;gt;
        &amp;lt;TextView
            p1:text="Address"
            p1:layout_width="fill_parent"
            p1:layout_height="wrap_content"
            p1:id="@+id/textView12" /&amp;gt;
        &amp;lt;EditText
            p1:inputType="textMultiLine"
            p1:layout_width="fill_parent"
            p1:layout_height="wrap_content"
            p1:id="@+id/addrEditText" /&amp;gt;
        &amp;lt;TableLayout
            p1:minWidth="25px"
            p1:minHeight="25px"
            p1:layout_width="fill_parent"
            p1:layout_height="wrap_content"
            p1:id="@+id/tableLayout1"
            p1:stretchColumns="*"&amp;gt;
            &amp;lt;TableRow
                p1:id="@+id/tableRow2"&amp;gt;
                &amp;lt;TextView
                    p1:text="Latitude"
                    p1:layout_column="0"
                    p1:id="@+id/textView21" /&amp;gt;
                &amp;lt;TextView
                    p1:text="Longitude"
                    p1:layout_column="1"
                    p1:id="@+id/textView22" /&amp;gt;
            &amp;lt;/TableRow&amp;gt;
            &amp;lt;TableRow
                p1:id="@+id/tableRow3"&amp;gt;
                &amp;lt;EditText
                    p1:inputType="numberDecimal|numberSigned"
                    p1:layout_column="0"
                    p1:id="@+id/latEditText" /&amp;gt;
                &amp;lt;EditText
                    p1:inputType="numberDecimal|numberSigned"
                    p1:layout_column="1"
                    p1:id="@+id/longEditText" /&amp;gt;
            &amp;lt;/TableRow&amp;gt;
        &amp;lt;/TableLayout&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
&amp;lt;/ScrollView&amp;gt;</pre>

<h1 id="e-nGIa">Creating POIDetailActivity</h1>
<p id="e-jMox">Now that we have the <code>POIDetail</code> layout ready, we need a corresponding activity. Perform the following steps to create a new activity for the POI details:</p>
<ol id="e-cxK3">
<li id="e-EVuG">With the <code>POIApp</code> project selected in the <strong>Solution</strong> pad, right-click on it and navigate to <strong>Add</strong> | <strong>New File</strong>.</li>
<li id="e-Bai4">In the <strong>New File</strong> dialog, click on <strong>Android</strong> and select <strong>Activity</strong>, enter <code>POIDetailActivity</code> as <strong>Name</strong>, and click on <strong>New</strong>.</li>
</ol>
<p id="e-pWtX">As you may recall from Chapter 3, <em>Creating the Points Of Interest App</em>, one of the first things that needs to be done when an activity is created is to set the layout content, which is accomplished by calling <code>SetContentView(layoutId)</code>. Add the following line of code to the <code>OnCreate()</code> method of the <code>POIDetailActivity</code>:</p>
<pre id="e-O8YU">SetContentView (Resource.Layout.POIDetail);</pre>

<h1 id="e-z3Rj">Adding navigation to POIDetailActivity</h1>
<p id="e-lksR">There are two scenarios where we need to navigate from <code>POIListActivity</code> to <code>POIDetailActivity</code>, either by selecting the <strong>New</strong> action on the navigation bar or by selecting any of the POIs from the list. The main difference between the two scenarios is that when selecting an existing POI from the list, we will have to pass the details of the selected POI to the <code>POIDetailActivity</code> so that the user can edit and update the POI record. When creating a new POI, we don't pass any data. Let's first choose the simplest one, and add the navigation to the <strong>New</strong> action.</p>
<p id="e-yZYV">The <code>Activity</code> class provides a method named <code>StartActivity()</code> that is used to start a new activity. The <code>StartActivity()</code> method can also be used in a number of different scenarios. In case of the <strong>New</strong> action, we will be using it in its most basic form. For starting an activity, all that we need to do is to invoke <code>StartActivity()</code> by passing the type for the activity we want to start.</p>
<p id="e-vKwC">The following code snippet demonstrates the code that needs to be added to the placeholder that we added to <code>POIListActivity</code> in the <code>OnOptionsItemSelected()</code> method:</p>
<pre id="e-N3aV">case Resource.Id.actionNew:
  StartActivity (typeof(POIDetailActivity));
return true;</pre>
<p id="e-mYhD">Let's now run the app on the Android device or simulator and see what we have built so far. In <code>POIListActivity</code>, click on the <strong>New</strong> button on the navigation bar, and notice that the newly created <code>POIDetailActivity</code> is opened:</p>
<img data-width="450" data-height="800" src="img/LSCs9ILv.jpg"/><h2 id="e-MCQP">Navigation on the POIList item click</h2>
<p id="e-QsZr">In the second scenario, we need to pass the details of the POI to display <code>POIDetailActivity</code>. To accomplish this, we will use the <code>Intent</code> class. The <code>Intent</code> class can be used in conjunction with <code>StartActivity()</code> in order to launch a new activity and pass information about the activity to be launched. We will use the <code>Intent</code> class to launch <code>POIDetailActivity</code> and pass the details of the selected POI.</p>
<p id="e-h5SC">First, we need to construct an instance of <code>Intent</code> by providing the current activity context and the type of target activity that will receive the intent; in our case, <code>POIDetailActivity</code>. The following code demonstrates how to properly construct the intent:</p>
<pre id="e-ShXB">Intent poiDetailIntent = new Intent (this, typeof(POIDetailActivity));</pre>
<p id="e-AiVE">The <code>Intent</code> object has an <code>Extras</code> property that is used to send extra data as a bundle from one activity to another. The <code>Intent</code> class provides a series of overloaded versions of the <code>PutExtra()</code> method, which allows you to add various types of <strong>key/value</strong> pairs to the <code>Extras</code> property. The values can be of any primitive types such as <code>int</code>, <code>boolean</code>, <code>char</code>, <code>string</code>, <code>double</code>, <code>float</code>, <code>long</code>, and so on. For example, to add the string data type, you can use the following syntax:</p>
<pre id="e-XKNp">intent.PutExtra ("YOUR_KEY", "SOME STRING VALUE HERE");</pre>
<p id="e-NUFq">For <code>POIApp</code>, we need to add all of the properties of the selected <code>PointOfInterest</code> object. Instead of passing each property with a distinct key, we can further simplify this process using the <strong>Json.NET</strong> component. It serializes the <code>PointOfInterest</code> .NET object into a JSON string that can be passed to <code>POIDetailActivity</code> with the distinct key <code>poi</code>, and at the receiver end, we will deserialize it back to the <code>PointOfInterest</code> object.</p>
<p id="e-FAYp">Apart from using the <code>Intent</code> bundle, there are various other options to pass data between activities. For complex objects, serializing using the Json.NET component and passing data bundles using Internet is not a recommended option. The size limit for the Android intent bundle is limited to somewhere around 1 MB, so you should always be cautioned about your data limits. You may consider using any of the other alternatives for better performance.</p>
<p id="e-r4zz">Some of my recommendations are as follows:</p>
<ul id="e-CkcY">
<li id="e-wnY5">Write the data to a file and pass only the file path to the second activity. The second activity can access the content using the same file path.</li>
<li id="e-UTEn">Use SQLite to store the object in a table. Pass only the unique ID or query a parameter to the second activity. The second activity can access the data by reading from the database.</li>
<li id="e-Ligs">Create a singleton class to hold the data. The second activity can directly access the data using a singleton instance.</li>
</ul>
<p id="e-BJPY">In our case, the POI object is tiny. We are happy to go with the <code>Intent</code> bundle approach. The following code syntax converts the selected <code>PointOfInterest</code> object to a JSON string using the <code>SerializeObject()</code> method of the <code>JsonConvert</code> class and adds it to <code>Intent</code> using the <code>PutExtra()</code> method:</p>
<pre id="e-o8Ap">string poiJson = JsonConvert.SerializeObject (poi);
poiDetailIntent.PutExtra("poi", poiJson);</pre>
<p id="e-s5ng">The last step is a call to <code>StartActivity()</code>, passing in the <code>Intent</code> class we created in the earlier step:</p>
<pre id="e-RITn">StartActivity (poiDetailIntent);</pre>
<p id="e-JZfM">With this, your POIListActivity <code>OnListItemClick</code> should have the following code:</p>
<pre id="e-wObX">protected void POIClicked(object sender, ListView.ItemClickEventArgs e)
{
  PointOfInterest poi = poiListData[(int)e.Id];
   Intent poiDetailIntent = new Intent(this, typeof(POIDetailActivity));
   string poiJson = JsonConvert.SerializeObject(poi); 
  poiDetailIntent.PutExtra("poi", poiJson);
  StartActivity(poiDetailIntent);
}</pre>
<p id="e-C3AX">Now that we have passed the data from <code>POIListActivity</code>, let's now access the POI object from the <code>POIDetailActivity</code> class.</p>

<h1 id="e-CsHW">Receiving the data in POIDetailActivity</h1>
<p id="e-HQx4">When we get to the <code>OnCreate()</code> method of the <code>POIDetailActivity</code>, we need to access the <code>PointOfInterest</code> object sent from <code>POIListActivity</code>. This object will be used to display the details of the selected POI. The following section will walk you through the process of retrieving the extra bundle metadata from <code>Intent</code>.</p>
<p id="e-sxS0">Each activity has an <code>Intent</code> property that contains the intent and the corresponding information that was passed while starting the activity. The <code>Intent</code> class provides a number of methods to access any of the <code>Extras</code> bundle data by providing the corresponding keys. Before we retrieve the data, we can confirm whether the value for the specified key is available by calling the <code>HasExtra ("poi")</code> method. The <code>HasExtra</code> method returns a <code>boolean</code> value; if it returns <code>false</code>, we can assume that we are creating a new POI; otherwise, we need to retrieve the value of the extra.</p>
<p id="e-OqTY">The <code>Intent</code> class has a series of <code>GetXXExtra()</code> methods, where <code>XX</code> represents the type for the value of a key/value pair. In our case, we can use the <code>GetStringExtra()</code> method on the intent to get the <code>poiJson</code> string passed in from <code>POIListActivity</code>. The <code>GetStringExtra()</code> method accepts a string (which is the key from the key/value pair originally set on the intent) and returns the value associated with the key.</p>
<p id="e-kve6">Let's declare a <code>PointOfIntrest</code> variable to hold the POI object received from <code>POIListActivity</code>:</p>
<pre id="e-e660">private PointOfInterest _poi;</pre>
<p id="e-KfYP">Add the following listing to the <code>OnCreate()</code> method of <code>POIDetailActivity</code>:</p>
<pre id="e-mzrN">if (Intent.HasExtra ("poi")) {
  string poiJson = Intent.GetStringExtra ("poi");
  _poi = JsonConvert.DeserializeObject&amp;lt;PointOfInterest&amp;gt;(poiJson);
} else {
  _poi = new PointOfInterest ();
}</pre>
<h2 id="e-VGrT">Binding variables to controls</h2>
<p id="e-PTET">As we learned in the previous chapter, we need to manually bind user interface widgets to internal program references in order to manipulate their content, assign event handlers, and so on. Declare a set of private variables for each of the input widgets we created in the layout. The following listing is from the source folder:</p>
<pre id="e-W9EA">private EditText _nameEditText;
private EditText _descrEditText;
private EditText _addrEditText;
private EditText _latEditText;
private EditText _longEditText;</pre>
<p id="e-aZGp">A call to <code>FindViewById&amp;lt;T&amp;gt;</code> is required to bind each variable to its corresponding user interface widget. The following listing depicts what should be added to the <code>OnCreate()</code> method somewhere after the call to <code>SetContentView()</code>:</p>
<pre id="e-fZd7">SetContentView (Resource.Layout.POIDetail);
_nameEditText = FindViewById&amp;lt;EditText&amp;gt; (Resource.Id.nameEditText);
_descrEditText = FindViewById&amp;lt;EditText&amp;gt; (Resource.Id.descrEditText);
_addrEditText = FindViewById&amp;lt;EditText&amp;gt; (Resource.Id.addrEditText);
_latEditText = FindViewById&amp;lt;EditText&amp;gt; (Resource.Id.latEditText);
_longEditText = FindViewById&amp;lt;EditText&amp;gt; (Resource.Id.longEditText);</pre>

<h1 id="e-g0FE">Populating user interface widgets</h1>
<p id="e-zGay">At this point, we have a reference to the <code>PointOfInterest</code> object, but we have not taken any action to populate the content on UI. Populating the POI details on UI is a pretty straightforward process.</p>
<p id="e-NMSR">The <code>EditText</code> widget has a property named <code>Text</code>, which we can set to initialize the content for the widget. Let's create a simple method named <code>UpdateUI()</code>, which takes care of populating the POI details on the user interface widgets.</p>
<p id="e-is2D">The following listing shows what is needed for <code>UpdateUI()</code>:</p>
<pre id="e-UfM1">protected void UpdateUI()
{
     _nameEditText.Text = _poi.Name;
     _descrEditText.Text = _poi.Description;
     _addrEditText.Text = _poi.Address;
     _latEditText.Text = _poi.Latitude.ToString ();
     _longEditText.Text = _poi.Longitude.ToString ();
}</pre>
<p id="e-PYI5">Call the <code>UpdateUI()</code> method at the end of the <code>OnCreate()</code> callback.</p>
<p id="e-mqta">You should be able to run <code>POIApp</code> now, and test the navigation by clicking on any one of the list rows in <code>POIListActivity</code>. Notice that the <code>POIDetailActivity</code> will display the details of the selected POI object:</p>
<img data-width="450" data-height="800" src="img/V733e2Kh.jpg"/>
<h1 id="e-iuhu">Adding the save and delete actions</h1>
<p id="e-F9hk">Using <code>POIDetailActivity</code>, users can choose to save or delete POIs. The same Save button works for two scenarios: when the POI details are passed from <code>POIListActivity</code>, it will update the POI details; otherwise, it will create a new record.</p>
<p id="e-nWX7">We need a way to accomplish these tasks from the user interface. Let's use <code>ActionBar</code> and add two actions: <code>Save</code> and <code>Delete</code>. Create a new file named <code>POIDetailMenu.xml</code> under the <code>Resources/menu</code> directory to declare the menu layout. The following listing shows what is needed for <code>POIDetailMenu.xml</code>:</p>
<pre id="e-GrdZ">&amp;lt;menu &amp;gt;
&amp;lt;item android:id="@+id/actionSave"
     android:icon="@drawable/ic_save"
     android:title="Save"
     android:showAsAction="ifRoom" /&amp;gt;
&amp;lt;item android:id="@+id/actionDelete"
     android:icon="@drawable/ic_delete"
     android:title="Delete"
     android:showAsAction="ifRoom" /&amp;gt;
&amp;lt;/menu&amp;gt;</pre>
<p id="e-y8fg">Note that each menu item has an icon specified. These icons can be found in the code bundle <code>Assets</code> folder.</p>
<p id="e-B6gT">We need to override both the <code>OnCreateOptionsMenu()</code> and <code>OnOptionsItemSelected()</code> methods. This is very similar to what we created in Chapter 4, <em>Adding a ListView</em>. Add the following code snippets to the <code>POIDetailActivity</code> class:</p>
<pre id="e-RSD1">public override bool OnCreateOptionsMenu(IMenu menu)
{
   MenuInflater.Inflate(Resource.Menu.POIDetailMenu, menu);
   return base.OnCreateOptionsMenu(menu);
}
 public override bool OnOptionsItemSelected (IMenuItem item)
{
     switch (item.ItemId)
     {
       case Resource.Id.actionSave:
         SavePOI ();
      return true;
       case Resource.Id.actionDelete:
         DeletePOI ();
         return true;
default :
         return base.OnOptionsItemSelected(item);
     }
}</pre>
<p id="e-dcbj">You may notice that, in the previous code snippets, we introduced two new methods: <code>SavePOI()</code> and <code>DeletePOI()</code>. Both of these methods are used to keep the <code>OnOptionsItemSelected()</code> method clean and concise. The <code>SavePOI()</code> and <code>DeletePOI()</code> methods encapsulate the logic required to save or delete the POI object.</p>
<h2 id="e-GNRg">Disabling the delete action</h2>
<p id="e-Lsfk">One thing that's different in <code>POIDetailView</code> is that we have a scenario where we need to disable the <code>Delete</code> action. If a new POI is being created, the <code>Delete</code> action should not be allowed. First, we need to get the reference of the menu item inside the <code>OnPrepareOptionsMenu()</code> method, and then we can call the <code>SetEnabled(bool)</code> method by passing your preference to enable or disable the menu action.</p>
<p id="e-sIHl">The <code>IMenu</code> class provides a <code>FindItem()</code> method that can be used to obtain a reference to a specific IMenuItem, which in turn provides the <code>SetEnabled()</code> method for enabling and disabling actions. Disabling a menu item makes the button nonfunctional; however, it will still be visible on the screen. For better user experience, let's hide the <code>Delete</code> action completely by calling the <code>SetVisible(false)</code> method.</p>
<p id="e-XgrN">The following listing shows how to disable the <code>Delete</code> action when a new POI is being entered:</p>
<pre id="e-FkhB">public override bool OnPrepareOptionsMenu (IMenu menu)
{
     base.OnPrepareOptionsMenu (menu);
     // Disable delete for a new POI
     if (_poi.Id&amp;lt;=0) {
        IMenuItem item = menu.FindItem (Resource.Id.actionDelete);
        item.SetEnabled (false);
  item.SetVisible(false);
     }
     return true;
}</pre>

<h1 id="e-bGFt">Adding the save and delete actions in POIService</h1>
<p id="e-z7vd">In  Chapter 4, <em>Adding a ListView</em>, we created the specialized <code>POIService</code> class that handles the logic for downloading data using the <code>async</code> and <code>await</code> keywords in conjunction with <code>HttpClient</code>. For now, the <code>POIService</code> class has only one method <code>GetPoisListAsync()</code>, that deals with fetching the list of records from the REST web service. Let's extend its functionality to create a new or update and delete a POI. Let's first start with creating a POI.</p>
<h2 id="e-qfNR">Consuming the web service to create or update a POI</h2>
<p id="e-loXf">At this point, we have already deployed the web service provided in the book code bundle, and <code>POIApp</code> is already consuming the same web services to fetch the list of POIs. In this section, we will use the same web service to create a new or update an existing POI.</p>
<p id="e-AWKL">The following API specification is used to create a new or update an existing POI:</p>
<pre id="e-PN6A">Request Method: POST
Resource Endpoint: /com.packet.poiapp/api/poi/pois
Content-type: application/json
Request Body: 
{
  "description": "The London Eye is a giant Ferris wheel on the South Bank &amp;#x2026;.",
  "latitude": "50.59938",
  "longitude": "80.8897",
  "address": "London SE17PB, UK",
  "name": "London Eye"
}
Response: Success/Failed</pre>
<p id="e-OwYP">Notice some of the key points in the preceding API specification: the request method is <code>POST</code>, Content-type is <code>application/json</code>, and the POI JSON object is sent as part of the request body. The <code>POST</code> method is an indication for the server application to lookup for the attached request content body, and the Content-Type describes the MIME type of the data the server is about to receive. In this case, the content type is <code>application/json</code>, which means that the server is expecting the POI details to be sent in the form of a JSON string.</p>
<p id="e-NTFZ">To create a new POI, we need to send the POI details such as name, description, latitude, longitude, and address while creating a new POI record. Once the POI is created, a unique ID will be created and assigned for each POI record. To update the existing POI record, we must send the POI ID along with the updated POI details as part of the request body.</p>
<h2 id="e-KT0X">Adding the CreateOrUpdatePOIAsync method to POIService</h2>
<p id="e-RMwi">Now that we understand that the details of the web service can be used to create or update a POI record, let's create a new <code>async</code> method named <code>CreateOrUpdatePOIAsync()</code> in the <code>POIService</code> class, and perform the following steps:</p>
<ol id="e-gFDT">
<li id="e-WWcX">Create a new <code>async</code> method <code>CreateOrUpdatePOIAsync()</code> that accepts the <code>PointOfInterest</code> instance. This holds the details of the POI that you need to send to the server in order to create or update the operation. This method returns <code>Task&amp;lt;String&amp;gt;</code> because the result of the create/update request is returned as a string:<pre id="e-lUSk">public async Task&amp;lt;String&amp;gt; CreateOrUpdatePOIAsync (PointOfInterest poi, Activity activity)
{
 }</pre>
</li>
<li id="e-nSXT">Declare a string constant that represents the web service endpoint in order to create a new or update an existing POI:<pre id="e-swpr">private const string CREATE_POI = "http://&amp;lt;YOUR_SERVER_IP&amp;gt;:8080/com.packt.poiapp/api/poi/create";</pre>
<p id="e-qIPd">Alternatively, you can use the following Apiary mock API URL, if you have not set up the web server code already:</p>
<pre id="e-DiI0">private const string CREATE_POI = "http://private-e451d-poilist.apiary-mock.com/com.packt.poiapp/api/poi/create";</pre>
</li>
<li id="e-EJat">As you might have noticed in the web service API specification, the server expects the POI details in a JSON string format. Hence, we need to serialize the POI object to a JSON using the Json.NET component:<pre id="e-eRFl">var poiJson = JsonConvert.SerializeObject(poi, Formatting.Indented);</pre>
<p id="e-yRsJ">The preceding code will convert the POI object to the following JSON format:</p>
<pre id="e-nVIm">{
  "Name": "Googleplex "
  "Description": "Google HQ",
  "Latitude": "37.423441",
  "Longitude": "-102.083962",
  "Address": "1600 Amphitheater Parkway Mountain View, CA 94044",
  
}</pre>
<p id="e-t8gf">The preceding JSON string contains the uppercase keys, such as <code>Name</code>, <code>Address</code>, which are incompatible for a given web service API specification. For this, we can use the <code>ContractResolver</code> class from Json.NET to provide custom settings while serializing the POI object.</p>
</li>
<li id="e-DUZ5">Declare an inner class named <code>POIContractResolver</code> inside <code>POIService</code> and extend it from <code>DefaultContractResolver</code>. Override the <code>ResolvePropertyName</code> method. You need to include the <code>Newtonsoft.Json.Serialization</code> namespace directive in the <code>POIService</code> class:<pre id="e-PVqi">public class POIContractResolver : DefaultContractResolver
{
    protected override string ResolvePropertyName(string key)
    {
      return key.ToLower();
    }
}</pre>
<p id="e-eAva">The preceding code snippet is self-explanatory. It resolves all the <code>PointOfInterest</code> object properties to lowercase JSON keys.</p>
</li>
<li id="e-d410">Now we can use the following code snippet to serialize the POI object into a JSON string with lowercase keys. Add the following listing to the <code>CreateOrUpdatePOIAsync</code> method:<pre id="e-i0PJ">var settings = new JsonSerializerSettings();
settings.ContractResolver = new POIContractResolver();
var poiJson = JsonConvert.SerializeObject(poi, Formatting.Indented, settings);</pre>
</li>
<li id="e-qVlf">Let us now asynchronously send the POI details JSON data using <code>HttpClient</code> class. The <code>HttpClient</code> class provides <code>PostAsync()</code> method that is used to sends a POST request to the specified URI as an asynchronous operation. The following code snippet demonstrates posting data to the server using the <code>HttpClient</code> class:<pre id="e-MGln">HttpClient httpClient = new HttpClient ();
StringContent jsonContent = new StringContent (poiJson, Encoding.UTF8, "application/json");
HttpResponseMessage response = await httpClient.PostAsync (CREATE_POI, jsonContent);
 if (response != null || response.IsSuccessStatusCode) {
  string content = await response.Content.ReadAsStringAsync ();
  Console.Out.WriteLine ("{0} saved.", poi.Name); 
  return content;
}
return null;</pre>
</li>
</ol>
<p id="e-Cimb">The preceding code block looks familiar to the <code>GetPoisListAsync</code> method but with some obvious differences. Here, we are calling <code>PostAsync</code> instead of the <code>GetAsync</code> method to send an asynchronous POST request. The <code>PostAsync</code> method accepts two parameters: a string representing a web service URL and an instance of <code>HttpContent</code> for the HTTP entity body. The <code>PostAsync</code> method accepts the different HTTP entity body formats such as <code>ByteArrayContent</code>, <code>MultipartContent</code>, <code>StreamContent</code>, and <code>StringContent</code>, representing the request body and content header. Here, in our case, we are sending the POI JSON as <code>StringContent</code>.</p>
<p id="e-L8kH">Currently, the <code>CreateOrUpdatePOIAsync()</code> method prints the result of this operation on the console. Later in this chapter, we will see how to use the <code>CreateOrUpdatePOIAsync ()</code> method from <code>POIDetailActivity</code> to complete the save operation.</p>
<h2 id="e-lfbm">Consuming the web service to delete the POI</h2>
<p id="e-MZA0">To delete the POI from the server, the client needs to send the information about the POI to be deleted. As all the POI records are uniquely assigned with a unique ID property, we just need to pass the ID of the POI to be deleted. Let's understand the following API specification used to delete the POI:</p>
<pre id="e-CroS">Request Method: DELETE
Resource Endpoint: /com.packet.poiapp/api/poi/delete/{POI_ID}
Response: Success/Failed</pre>
<p id="e-bDO0">From the preceding API specification, the request method is <code>DELETE</code> and the web service requires the POI ID to be passed to the end of the URL for the server to know which POI to be deleted. As we are not sending any data to the request body, we don't need to specify the <code>Content-Type</code> request header. The result of the operation is that this API responds back with a <code>Success</code> or <code>Failure</code> plain text message.</p>
<h2 id="e-XaRq">Adding the DeletePOIAsync method to POIService</h2>
<p id="e-M0B4">Consuming the web service to delete a POI is similar to the <code>GetPoisListAsync()</code> method implementation. The following steps will help you create a new <code>async</code> method and consume the web service to delete the POI:</p>
<ol id="e-sArO">
<li id="e-SWca">Create a new <code>async</code> method <code>DeletePOIAsync()</code> that accepts an integer value <code>poiId</code> that represents a unique <code>PointOfInterest</code> object:<pre id="e-Snop">public async Task&amp;lt;String&amp;gt; DeletePOIAsync (int poiId)
{
}</pre>
</li>
<li id="e-UUws">Declare a string constant that represents the URL to web service API for the delete action:<pre id="e-QdPD">private const string DELETE_POI = "http://localhost:8080/com.packt.poiapp/api/poi/delete/{0}";</pre>
<p id="e-uhRD">Notice that the <code>DELETE_POI</code> string expects the <code>poiId</code> parameter to end of the URL. This is the ID of the POI to be deleted from the server.</p>
<p id="e-yWA7">Alternatively, you can use the following Apiary test URL:</p>
<pre id="e-qtaE">private const string DELETE_POI = "http://private-e451d-poilist.apiary-mock.com/com.packt.poiapp/api/poi/delete";</pre>
</li>
<li id="e-TH75">Let's now proceed to create an instance of <code>HttpClient</code> and to delete the POI from the server. Add the following code snippets to the <code>DeletePOIAsync()</code> method:<pre id="e-bqTF">public async Task&amp;lt;String&amp;gt; DeletePOIAsync (int poiId)
{
  HttpClient httpClient = new HttpClient ();
  String url = String.Format (DELETE_POI, poiId);
  HttpResponseMessage response = await httpClient.DeleteAsync (url);
  if (response != null || response.IsSuccessStatusCode) {
    string content = await response.Content.ReadAsStringAsync();
    Console.Out.WriteLine ("One record deleted.");
    return content;
  }
  return null;
}</pre>
</li>
</ol>
<p id="e-Yixj">In the preceding code snippet, the <code>DeleteAsync()</code> method sends a delete request asynchronously to the specified <strong>Uniform Resource Identifier</strong> (<strong>URI</strong>), and the result of this operation is printed on the console.</p>

<h1 id="e-UYsm">Creating SavePOI()</h1>
<p id="e-kHRz">Notice that in the previous step, in the <em>Adding Save and Delete action</em> section, we are calling the <code>SavePOI()</code> and <code>DeletePOI()</code> actions from the <code>OnOptionsItemSelected()</code> method, but we haven't declared them at all. These two methods will deal with consuming web services to create, update, and delete the POI. The following sections will take you through both the <code>SavePOI()</code> and <code>DeletePOI()</code> actions.</p>
<p id="e-wNwQ">Let's now declare a new method <code>SavePOI()</code> in the <code>POIDetailActivity</code> class. The <code>SavePOI()</code> method could avoid placing a lot of logic in the <code>OnOptionsItemSelected()</code> method. This method will validate the user input and initiate the server request to create or update the POI.</p>
<p id="e-AwMD">We will cover the field validation in an upcoming section and now focus on getting the user data from the screen and initiate a create/update request. The following listing shows what should be present in <code>SavePOI()</code>:</p>
<pre id="e-wHu3">protected void SavePOI()
{
    _poi.Name = _nameEditText.Text;
    _poi.Description = _descrEditText.Text;
    _poi.Address = _addrEditText.Text;
    _poi.Latitude = tempLatitude;
    _poi.Longitude = tempLongitude;
     CreateOrUpdatePOIAsync (_poi);
}</pre>
<p id="e-hbNf">Notice that we are calling a new method, that is, <code>CreateOrUpdatePOIAsync()</code> from <code>SavePOI()</code>. We need to add the <code>CreateOrUpdatePOIAsync()</code> to <code>POIDetailActivity</code>. It is an <code>async</code> method, which will take care of initializing the <code>POIService</code> class and initiating the web service request to save the POI.</p>
<p id="e-RuxJ">The following code snippet listing shows what should be present in the <code>CreateOrUpdatePOIAsync()</code> method:</p>
<pre id="e-rVt0">private async void CreateOrUpdatePOIAsync(PointOfInterest poi){
  POIService service = new POIService ();
  if (!service.isConnected(this)) {
    Toast toast = Toast.MakeText (this, "Not conntected to internet. Please check your device network settings.", ToastLength.Short);
    toast.Show ();
    return;
  }
   string response = await service.CreateOrUpdatePOIAsync (_poi);
  if (!string.IsNullOrEmpty (response)) {
    Toast toast = Toast.MakeText (this, String.Format ("{0} saved.", _poi.Name), ToastLength.Short);
    toast.Show();
    Finish ();
  } else {
    Toast toast = Toast.MakeText (this, "Something went Wrong!", ToastLength.Short);
    toast.Show();
  }
}</pre>
<p id="e-r80Q">Notice that the preceding method does the following tasks:</p>
<ul id="e-bNQf">
<li id="e-KYWl">First, it creates an instance of the <code>POIService</code> class and confirms the network availability by calling the <code>isConnected()</code> method.</li>
<li id="e-bCnb">If a device is not connected to the Internet, it shows an appropriate <code>Toast</code> message to the user.</li>
<li id="e-nXkq">If the network is available, it calls the <code>CreateOrUpdatePOIAsync()</code> method, which is defined in the <code>POIService</code> class. The web service request can be a long-running blocking operation, and hence, we are using <strong>async await</strong> to make the request asynchronous.</li>
<li id="e-QHwj">A toast message is displayed to notify the user about the result of the save/update operation.</li>
<li id="e-rawF">Once the save request is successful, it displays a toast message and calls the activity <code>Finish()</code> method. The <code>Finish()</code> method causes the <code>POIDetailActivity</code> activity to be closed, and the previous activity on the stack will be brought back to the foreground; in our case, <code>POIListActivity</code>.</li>
</ul>

<h1 id="e-yXah">Creating DeletePOI()</h1>
<p id="e-FNFX">Like <code>SavePOI()</code>, the <code>DeletePOI()</code> method was created to simplify the logic in <code>OnOptionsItemSelected()</code>. Before deleting the POI, we must ask the user to reconfirm by showing a dialog. Later in this chapter, we will show you how to display a confirmation prompt before initiating the deleted request.</p>
<p id="e-JWSu">We created the <code>CreateOrUpdatePOIAsync()</code> method in <code>POIDetailActivity</code>, let's now add another new method named <code>DeletePOIAsync()</code>. This method performs pretty much the same task as the <code>CreateOrUpdatePOIAsync()</code> method does in <code>POIDetailActivity</code>. It checks for the Internet connection availability, initiates the delete operation asynchronously, and finally, notifies the user with a toast message.</p>
<p id="e-yrma">Add the following <code>DeletePOIAsync</code> method to your <code>POIDetailActivity</code> class:</p>
<pre id="e-uNvb">public async void DeletePOIAsync(){
  POIService service = new POIService ();
  if (!service.isConnected(this)) {
    Toast toast = Toast.MakeText (this, "Not conntected to internet. Please check your device network settings.", ToastLength.Short);
    toast.Show ();
    return;
  }
   string response = await service.DeletePOIAsync (_poi.id);
  if (!string.IsNullOrEmpty (response)) {
    Toast toast = Toast.MakeText (this, String.Format ("{0} deleted.", _poi.Name), ToastLength.Short);
    toast.Show();
     Finish ();
  } else {
    Toast toast = Toast.MakeText (this, "Something went Wrong!", ToastLength.Short);
    toast.Show();
  }
}</pre>
<p id="e-DAdj">The following listing shows what should be present in the <code>DeletePOI()</code> method:</p>
<pre id="e-rA0o">protected void DeletePOI()
{
DeletePOIAsync(); 
}</pre>
<p id="e-iqy2">Let's now build and run the app. You should now be able to perform the add, update, and delete operations:</p>
<img data-width="800" data-height="451" src="img/JAsfJjf8.jpg"/><h3 id="e-KruO">Note</h3>
<p id="e-e1mT">If you're using the Apiary mock feed URL for the save and delete operation, no POI will be deleted or saved. Apiary is just used for testing purpose only. You must deploy the web service code bundle provided in this book for the <code>Save</code> and <code>Delete</code> action to take effect on the server data.</p>

<h1 id="e-HOnU">Adding validation</h1>
<p id="e-D3Uh">Any nontrivial app will have some level of the validation required. The <code>POIApp</code> app is somewhat trivial, but we have a small set of rules we need to enforce that will facilitate the discussion:</p>
<p id="e-T1aR">Property</p>
<p id="e-vMoX">Rule</p>
<p id="e-YTLd"><code>Name</code></p>
<p id="e-hNf9">This cannot be empty or null</p>
<p id="e-IyKp"><code>Latitude</code></p>
<p id="e-RwOy">This contains a valid decimal number between <code>-90</code> and <code>90</code></p>
<p id="e-WhhX"><code>Longitude</code></p>
<p id="e-aAQC">This contains a valid decimal number between <code>-180</code> and <code>180</code></p>
<h2 id="e-GuzT">Using the EditText.Error property</h2>
<p id="e-Pmzw">The <code>EditText</code> widget has a string property named <code>Error</code>, which simplifies the effort of displaying errors to the user, particularly if you want to be able to show all the fields with errors at once. The following screenshot displays the error received for leaving the <strong>Name</strong> field empty:</p>
<img data-width="500" data-height="446" src="img/TAoykf1S.jpg"/><p id="e-xToS">To use this facility, simply set the property to an error message and clear the property when no errors exist. The following example demonstrates implementing the rule for the <strong>Name</strong> property:</p>
<pre id="e-mRD1">bool errors = false;
   if (String.IsNullOrEmpty (_nameEditText.Text)) {
   _nameEditText.Error = "Name cannot be empty";
     errors = true;
   }
   else
     _nameEditText.Error = null;</pre>
<p id="e-h04P">Notice the local Boolean variable named <code>errors</code>, which is used to keep track of whether any errors have been found. Edits for <strong>Latitude</strong> and <strong>Longitude</strong> are a little more involved, as you need to account for converting text to a <code>double</code> value and allow a <code>null</code> value to be specified.</p>
<p id="e-TT3Q">The following code demonstrates one of the approaches to implement the edits:</p>
<pre id="e-XbqD">double? tempLatitude = null;
if (!String.IsNullOrEmpty(_latEditText.Text)) {
try {
    tempLatitude = Double.Parse(_latEditText.Text);
    if ((tempLatitude &amp;gt; 90) | (tempLatitude &amp;lt; -90)) {
         _latEditText.Error = "Latitude must be a decimal value between -90 and 90";
         errors = true;
    }
    else
         _latEditText.Error = null;
    }
    catch 
    {
       _latEditText.Error = "Latitude must be valid decimal number";
     errors = true;
  } 
}</pre>
<p id="e-iniw">Implement the rules identified at the start of this section in the <code>SavePOI()</code> method using the <code>EditText.Error</code> property.</p>
<p id="e-y6k6">You can update and save the POI properties only if all of the edits are passed. The following listing shows one of the ways to structure the logic:</p>
<pre id="e-fzae">if (errors) {
return;
}
 _poi.Name = _nameEditText.Text;
_poi.Description = _descrEditText.Text;
_poi.Address = _addrEditText.Text;
_poi.Latitude = tempLatitude;
_poi.Longitude = tempLongitude;
CreateOrUpdatePOIAsync ();</pre>
<p id="e-LzGw">Run <code>POIApp</code> and confirm that the validations are working correctly.</p>
<h2 id="e-JRpq">Adding a delete confirmation prompt</h2>
<p id="e-QPCi">It's a best practice for apps to provide a confirmation before performing any type of destructive update, particularly if it cannot be undone. As such we need to provide a confirmation for the <code>Delete</code> action. Fortunately, Android makes this relatively easy with the <code>AlertDialog</code> and <code>AlertDialog.Builder</code> classes.</p>
<p id="e-eulD">The <code>AlertDialog</code> class allows you to display a modal confirmation dialog. The <code>AlertDialog.Builder</code> class is an embedded class that helps you construct an instance of an <code>AlertDialog</code> method; you can think of it as a factory class. The steps are as follows:</p>
<ol id="e-yFi0">
<li id="e-r6wJ">Create an instance of <code>AlertDialog.Builder</code>.</li>
<li id="e-yKlk">Set various properties on the builder instance, such as the message, the button text, the calling of event handlers when a button is clicked, and so on.</li>
<li id="e-mNWg">Call <code>Show()</code> on the instance of <code>AlertDialog.Builder</code> to create and display an instance of <code>AlertDialog</code>.<p id="e-NVIT">In our case, we want an <code>AlertDialog</code> class with a simple message and an <strong>OK</strong> and <strong>Cancel</strong> button. When we click on <strong>Cancel</strong>, we simply need to close the dialog and do nothing. When the user selects <strong>OK</strong>, we need to initiate the delete POI operation.</p>
</li>
<li id="e-tlsS">Create an event handler that will be called when you click on the <strong>OK</strong> button. This method will now call <code>DeletePOIAsync()</code> to perform the delete operation. The following listing depicts these changes:<pre id="e-Lzhr">protected void ConfirmDelete(object sender, EventArgs e)
{
     DeletePOIAsync ();
}</pre>
</li>
<li id="e-iNYZ">Add the logic that constructs the <code>AlertDialog</code> class into the existing <code>DeletePOI()</code> method. The following listing depicts this logic:<pre id="e-FhLG">protected void DeletePOI()
{
    AlertDialog.Builder alertConfirm = new AlertDialog.Builder(this);
alertConfirm.SetTitle("Confirm delete");
    alertConfirm.SetCancelable(false);
    alertConfirm.SetPositiveButton("OK", ConfirmDelete);
    alertConfirm.SetNegativeButton("Cancel", delegate {});
    alertConfirm.SetMessage(String.Format("Are you sure you want to delete {0}?", _poi.Name));
    alertConfirm.Show();
}</pre>
</li>
</ol>
<p id="e-cTER">The <code>SetPositiveButton()</code> and <code>SetNegativeButton()</code> methods allow button captions and event handlers to be specified. In the case of the <em>negative</em> button <strong>Cancel</strong>, we provide an empty event handler because there is nothing to do; Android will take care of closing the dialog. <code>AlertDialog</code> also provides a <em>neutral</em> button.</p>
<h3 id="e-an0b">Tip</h3>
<p id="e-ie8E">On devices prior to Honeycomb, the button order (left to right) was <em>positive</em> - <em>neutral</em> - <em>negative</em>. On newer devices, using the Holo theme, the button order (left to right) is <em>negative</em> - <em>neutral</em> - <em>positive</em>.</p>
<p id="e-AibV">Run <code>POIApp</code> and verify that the delete confirmation is working correctly. The following screenshot shows the delete confirmation dialog when the user clicks on the delete action:</p>
<img data-width="800" data-height="448" src="img/vkmgTyjW.jpg"/>
<h1 id="e-jJvI">Refreshing POIListActivity</h1>
<p id="e-qn7h">Actions we take on <code>POIDetailActivity</code>, such as <code>Save</code> and <code>Delete</code>, have an effect on the data displayed in <code>POIListActivity</code>. We need to ensure that <code>ListView</code> in <code>POIListActivity</code> is refreshed and displays the updated POI list when it becomes active again. To achieve this, we have to depend on the activity life cycle callback methods.</p>
<p id="e-QXxP">As you may recall from Chapter 1, <em>The Anatomy of an Android App</em>, when an activity is moved to the background due to the start of a new activity, the <code>OnPause()</code> method is called. This would have happened for <code>POIListActivity</code> when <code>POIDetailActivity</code> was started. Once <code>POIDetailActivity</code> is completed by either calling the <code>Finish()</code> method or by pressing the device back button, the <code>POIListActivity</code> will be brought back to the foreground and the <code>OnResume()</code> method will be called.</p>
<p id="e-wMqZ">Let's remove the call to <code>DownloadPoisListAsync()</code> in the <code>OnCreate()</code> method and add the following snippets to refresh <code>POIListActivity</code>:</p>
<pre id="e-jctu">protected override void OnResume (){
base.OnResume ();
DownloadPoisListAsync ();
}</pre>
<p id="e-tIwi">We have covered a lot of ground in this chapter. We have completed the POI details activity to perform add, update, or delete POIs. If you have any unintended deviations, you can refer to the code bundle.</p>

<h1 id="e-TceA">Summary</h1>
<p id="e-W4FN">In this chapter, we covered a lot of ground creating complex layouts using different layout managers such as <code>LinearLayout</code>, <code>TableLayout</code>, and <code>ScrollView</code> and using <code>EditText</code> to validate the form data.</p>
<p id="e-Cmq9">Now a new activity is added to <code>POIApp</code> that displays the details of the POI and allows the user to perform add, update, or delete POI operations. The <code>StartActivity</code> method is used in combination with <code>Intent</code> for passing the data bundle between activities.</p>
<p id="e-AuFR">We also extended the <code>POIService</code> class by adding additional methods to perform the web service <code>POST</code> and <code>DELETE</code> operations.</p>
<p id="e-Wrpl">The next chapter will guide you to deal with the application behavior when a device orientation changes.</p>
</body></html>