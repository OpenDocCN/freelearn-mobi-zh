- en: Building on the Swift Foundation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we went through the basics of understanding data types
    and how to create variables and constants. Now that we are comfortable with those
    topics, let's look at adding more building blocks. This chapter will build on
    what we learned in the last chapter and get a bit closer to better understanding
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Type safety and type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations with Integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionals and optional bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types are good, but we will need to add some logic to our app. For example,
    we want to be able to control whether someone should see a login screen when they
    launch the app or if they should go right into the app. You will use logic a lot,
    so let's look at what an `if` statement is and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Playground project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you learned earlier, launch Xcode and click on Get started with a playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10e726df-ec5e-4fee-9f85-aae4267c1206.png)'
  prefs: []
  type: TYPE_IMG
- en: The Playground template screen will appear. Make sure that you select iOS and
    then choose Blank and hit Next. You will be asked to give your project a name
    and a location to save the file; name your new Playground `iOS11-Programming-for-Beginners-Ch3`.
    You can save the file anywhere that you like. Now, with the project saved, we
    can explore Playgrounds a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The if statements – having fun with logic statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add our first piece of logic using an `if` statement. An `if` statement
    is a simple statement to determine whether or not a statement is true. Input the
    following into Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aaccd7a-41ae-4f3f-aa46-bbe702bcb1e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first line of the preceding code, we created a constant named, `isPictureVisible`,
    and we set it to `true`. The next line starts our `if` statement and is read as
    follows: if `isPictureVisible` is `true`, then print `Picture is visible`. When
    we write `if` statements, we must use the curly braces to enclose our logic. It
    is good practice to put the opening curly brace (`{`) on the same line as the
    `if` and the closing curly brace (`}`) on the line immediately after your logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing `if` statements using a `bool`, you are always checking for `true`;
    however, if you wanted to check for `false`, you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da505b5-89ac-4290-ba5d-a7c57852e606.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Bools work great with `if` statements, but we also can use them with other
    data types. Let''s try an `if` statement with an `Int` next. Write the following
    into Playgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8112d3b-7dae-4167-a501-520c5789b361.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we first created another constant with our `Int` set
    to `19`. The next line says—if `drinkingAgeLimit` is less than `21`, then print
    `Since we cannot offer you an adult beverage - would you like a water or soda
    to drink?` When you are using `Int` within `if` statements, you will use the comparison
    operators (`<`, `>`, `<=`, `>=`, `==`, or `!=`). However, our last `if` statement
    feels incomplete, because we are not doing anything for someone over `21`. This
    is where you will utilize an `if...else` statement. You enter an `if...else` statement
    exactly as you did an `if` statement, but, at the end, you add the word else.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add else to both of the `if` statements we have inputted so far, but,
    for now, just add it to the end of our last `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b698287d-0910-43ef-b95b-8621a055e07d.png)'
  prefs: []
  type: TYPE_IMG
- en: With else added onto the end of our `if` statement, it turns into an `if...else`
    statement, which now reads—if `drinkingAgeLimit` is less than `21`, then print
    `Since we cannot offer you an adult beverage - would you like a water or soda
    to drink?` Otherwise (or `else`), print `What type of beverage would you like?
    We have adult beverages along with water or soda to drink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our `if...else` statement can handle both conditions. Based on the value
    `19` for our `drinkingAgeLimit`, we can see in the Debug panel: `Since we cannot
    offer you an adult beverage - would you like a water or soda to drink?` If we
    change `drinkingAgeLimit` to `30`, our Debug panel says, `What type of beverage
    would you like? We have adult beverages along with water or soda to drink`. Go
    ahead and change `19` to `30` in Playgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79573220-3eb7-4b7e-a904-885ffdb0c735.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we got the behavior we wanted in the Debug panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have covered using an `if` statement with a `bool` and an `Int`.
    Let''s take a look at one more example using a string. Add this next bit of code
    into Playgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76afaef3-8ba1-4ae5-92bd-aeb37059bc43.png)'
  prefs: []
  type: TYPE_IMG
- en: In programming, we use equals (`=`) when setting data to variables. However,
    in order to compare two data types, we must use the double equals (`==`). Therefore,
    when we write an `if` statement that compares two strings we must use double equals
    (`==`) instead of just equals (`=`) to determine equality.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `if...else` statement only lets us check two conditions, whether they are
    `true` or `not`. If we wanted to add more conditions, we would not be able to
    simply use an `if...else` statement. In order to accomplish this, we would use
    what is called an `if...else...if...else`. This statement gives us the ability
    to add any number of `else-if`s inside of our `if...else` statement. We will not
    go overboard, so let''s just add one. Update your last `if...else` statement to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d34e93e-47be-475e-864e-7142a51abd98.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example of an `if...else...if...else` statement, we are checking whether `restaurantName`
    equals `La Bamba`, print `I've only been to La Bamba II!` else, if `restaurantName`
    equals `This restaurant is excellent! else print Oh! I've never heard of that
    restaurant`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `if`, `if...else` and `if...else if...else` statements really helps you
    create simple or complex logic for your app. Being able to use them with `Strings`,
    `bools`, `Ints`, and floating-point numbers gives you more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals and optional bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Optionals are used when a value cannot be set. Think of optionals as a container
    that can take either a value or nil. This gives us the ability to check whether
    the value is nil or not. In order to create an optional value, you will have to
    give it a data type followed by a question mark (`?`). Before we do that, let''s
    create a string that is not an optional. Add the following to Playgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed31aef8-ae52-4799-8244-2661f3462c52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add an optional to Playgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2af14328-97f5-49d5-980a-91ee6b453472.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we created a string optional, and, if you notice in the Results
    panel, it is nil. But for our `notAnOptional`, we see `This is not an optional`.
    Now, on the next line, let''s set `optional` equal to `This is an optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d30a51c3-e5fa-4ad8-adb9-ec282253ef12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our Results panel, we see `This is an optional`. Let''s now print both `strNotAnOptional`
    and `strOptional`, as you will see a difference between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8e086aa-241c-4f20-9509-029c86b032dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that our `notAnOptional` variable looks fine, but `optional` has an optional
    wrapped (`""`) around the `String`. This means that, in order for us to access
    the value, we must unwrap the optional. One way we could do this is by force-unwrapping
    the optional using an (`!`). Let''s update our `print` statement and change it
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bd5377f-de1c-4b37-81d7-d2894b028da6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We just force-unwrapped our optional, but this method is not recommended. We
    should use what is called **optional binding**, which is the safe way to access
    the value using an `if...let` statement. Remove the (`!`) from the `print` statement
    and instead write the following optional binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d9dfc16-b027-474f-9898-3bad16ebcfd3.png)'
  prefs: []
  type: TYPE_IMG
- en: This `if...let` statement is saying that if the optional is not nil, set it
    to `strValue`—but, if this optional is nil, ignore it and do nothing. We now do
    not have to worry about anything setting our value and causing our app to crash.
  prefs: []
  type: TYPE_NORMAL
- en: Why optionals?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now you are probably asking: Why do you have to do this? Trust me, when
    I first learned about optionals, I felt the same way. Optionals were actually
    made for your protection. For now, just understand that, when you see a data type
    followed by a question mark, this variable is an optional. As we work with optionals
    more and more throughout the book, it will become clearer to you.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time to get into a really fun part of programming and learn how
    to write functions. Functions are self-contained pieces of code that you want
    to run on something. In Swift 3, Apple has made a change to how you should write
    functions. All of the functions we will write in this chapter will perform an
    action (think of verbs). Let''s create a simple function called `greet()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bc6f7b8-d786-41ac-ae1c-77065c7b9c27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This example is a basic function with a `print` statement in it. In programming,
    functions do not actually run until you call them. We call a function simply by
    calling its name. So, let''s call greet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we add this to the code, this is what we''ll see on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4cff64e-3f9d-417d-902d-ac1c713e26eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s it! We just created our first function and called it. However, functions
    can do so much more. We can add what is called a parameter to a function. A parameter
    allows us to accept data types inside our parentheses. Doing this allows us to
    build more reusable chunks of code. So, let''s update our `greet()` function to
    accept a parameter called `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After you update the function, you will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/086d4cf0-3239-4202-ab8d-70d0465d32b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We received this error because we updated our function, but we did not update
    the line where we called it. Let''s update where we call `greet()` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3bd342cf-538c-4074-a8b2-e542b9cdd337.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This looks good; however, the Debug panel shows us that we are not using the
    name in our greeting. Earlier, you learned how to create a string interpolation.
    So, we just need to append our variable name inside of our `print` statement,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how your code will now look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4553f86e-d5e6-4861-a1cf-54278a0af278.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Functions can take multiple parameters, so let''s create another `greet()`
    function that takes two parameters, a first name and a last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your code and its output should look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca98edf9-3d67-4761-861c-6452b9b15d88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to update where we called `greet()` to accept multiple parameters
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your code and output screen should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/804a1db9-3e9b-4916-8e05-867da5c73673.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a function that accepts multiple parameters.
  prefs: []
  type: TYPE_NORMAL
- en: What would be great is if we could make a function that return the greeting
    to us. Well, we can! Whenever we want our function to return something, we need
    to use a noun as a way to describe what our function will do. We just created
    a function called `greet()` that takes a first and last name and creates a full
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another function called `greeting()`, which will return
    a full name back with a greeting. Let''s see what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how your code and output screen should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02543775-e32b-4802-bafd-496820b31576.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This function is almost the same as the previous one, but with a couple of
    new things. First `-> String` tells the function that we want to return a string.
    Inside of our function, we return `"Hello \(first) \(last)"`. Since we said that
    we want to return something after our parentheses, then we have to do just that.
    Now, let''s see how we do this. Enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is how your code and output screen should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b016fa1c-4709-4ae6-9a12-325bdf6c498d.png)'
  prefs: []
  type: TYPE_IMG
- en: If you notice, in the Debug panel we now have our full name with `Hello` added
    to the beginning. As you start to build on functions, you really start to see
    the power.
  prefs: []
  type: TYPE_NORMAL
- en: These are just the basics of functions. We will cover more advanced functions
    throughout our *Let's Eat* app. The main thing beginning programmers forget is
    that functions should be small. Your function should do one thing and one thing
    only. If your function is too long, then you need to break it up into smaller
    chunks. Sometimes longer functions are unavoidable, but you should always be mindful
    of keeping them as small as possible. Nice work!
  prefs: []
  type: TYPE_NORMAL
- en: '**Let''s work**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered a lot in this chapter, and now it is time to put everything we covered
    into practice. Here are two challenges. If you are comfortable with them, then
    work on them on your own. Otherwise, go back into this chapter and you can follow
    along with me and see how to do each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge 1**: Write a function that accepts and returns a custom greeting
    (other than `Hello`, which we addressed earlier in this chapter) along with your
    first and last name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenge 2**: Write a function that will take two numbers and add, subtract,
    multiply, or divide those two numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what type safety is, as well as type inference.
    We also learned about operations with integers as well as working our way through
    `if` statements. Finally, we discussed the power of optionals and learned about
    what functions are and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to some more Swift basics by digging into
    Swift collections. Learning these well will really help you progress in Swift,
    because you will use them all the time.
  prefs: []
  type: TYPE_NORMAL
