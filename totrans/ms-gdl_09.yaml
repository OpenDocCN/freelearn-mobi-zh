- en: Chapter 9. Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 部署
- en: 'A Gradle book will be incomplete, unless we talk about the deployment aspect
    of a software component. In my opinion, in software engineering the most logical
    step after build automation is deployment. Deployment itself is a different domain
    and this has very little to do with Gradle. But still I think it makes sense to
    discuss build and deployment tools together, so that the reader gets an overview
    of **Build**, **Deploy**, and **Test** workflow. In this chapter, we will discuss
    some basics of deployment to give a flavor of the build and deployment process.
    We will learn how to use tools such as Gradle, Jenkins, and Docker together to
    create a build, deployment, and test workflow. Before we start, we have to understand,
    what deployment is. Deployment is as important as the build process in the software
    life cycle. You can write and build great software, but unless the application
    is deployed, it does not produce much value. Deployment of software is not just
    about installing software and starting it. It varies from application to application,
    operating system to operating system. Some application can be deployed just by
    copying a JAR file to a particular location; some applications require deployment
    in a web container, or in external containers and so on. We can generalize the
    deployment process of software as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不谈论软件组件的部署方面，那么一本Gradle书籍将是不完整的。在我看来，在软件工程中，在构建自动化之后的下一个最合逻辑的步骤就是部署。部署本身是一个不同的领域，这与Gradle关系不大。但仍然我认为讨论构建和部署工具是有意义的，这样读者就可以对**构建**、**部署**和**测试**工作流程有一个概述。在本章中，我们将讨论部署的一些基础知识，以了解构建和部署过程。我们将学习如何使用Gradle、Jenkins和Docker等工具一起创建构建、部署和测试工作流程。在我们开始之前，我们必须理解什么是部署。部署与构建过程在软件生命周期中同样重要。你可以编写和构建出色的软件，但如果应用程序没有部署，它就不会产生太多价值。软件的部署不仅仅是安装软件并启动它。它因应用程序而异，因操作系统而异。某些应用程序只需将JAR文件复制到特定位置即可部署；某些应用程序需要在Web容器或外部容器中部署等。我们可以将软件的部署过程概括如下：
- en: Prepare the prerequisite hardware and software environment where you want to
    deploy the application.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备你想要部署应用程序的先决硬件和软件环境。
- en: Copy project assets on the prepared environment.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在准备好的环境中复制项目资产。
- en: Configure assets based on the environment.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据环境配置资产。
- en: Prepare a life cycle of the application such as start, stop, restart, and so
    on.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备应用程序的生命周期，如启动、停止、重启等。
- en: Do a sanity check of the application to verify its functionality.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应用程序进行合理性检查，以验证其功能。
- en: So deployment is not just copying the assets and notifying everyone that the
    application is ready to use. It also involves a lot of other pre and post steps.
    Deployment process has also been evolved along with the development processes
    and is still evolving with newer technologies. There was a time when the operation
    team used to deploy the application manually on specified nodes, configure load
    balancing mechanism and routing from box to box to effectively handle client requests.
    Now, with the help of new cloud infrastructures, such as **Infrastructure as a
    Service** (**IaaS**) or with various automation tools, with just one click or
    with some commands, developer can deploy application on one box, cluster environment,
    cloud-based environment or containerized environment. In this chapter, we will
    focus on the deployment process with Docker, an application containerization technology.
    We will have a detailed look into different aspects of Docker such as installation,
    configuration; benefits of Docker over virtual server node deployment; deploy
    application inside Docker; and how to make it available to the outside world.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，部署不仅仅是复制资产并通知每个人应用程序已准备好使用。它还涉及许多其他的前置和后置步骤。部署过程也随着开发过程的发展而发展，并且仍在随着新技术的发展而演变。曾经有一段时间，运维团队会在指定的节点上手动部署应用程序，配置负载均衡机制和从盒子到盒子的路由，以有效地处理客户端请求。现在，借助新的云基础设施，例如**基础设施即服务**（**IaaS**）或各种自动化工具，只需一键或一些命令，开发者就可以在一个盒子、集群环境、基于云的环境或容器化环境中部署应用程序。在本章中，我们将重点关注使用Docker（一种应用程序容器化技术）的部署过程。我们将详细探讨Docker的不同方面，如安装、配置；Docker相对于虚拟服务器节点部署的优势；在Docker内部部署应用程序；以及如何使其对外界可用。
- en: Role of Gradle in deployment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle在部署中的作用
- en: 'Gradle plays one of the major roles in the build and deployment process. Developer
    can use a combination of different tools based on the requirement to automate
    the complete build and deployment process. Tools such as Jenkins, Puppet, Chef,
    and Docker help to create the build and deployment infrastructure. But for very
    simple deployments, some of the Gradle features can be useful. Gradle provides
    a variety of tasks that can automate some of deployment tasks as mentioned previously.
    Few useful tasks are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle在构建和部署过程中扮演着重要的角色。开发者可以根据需求组合使用不同的工具来自动化整个构建和部署过程。例如，Jenkins、Puppet、Chef和Docker等工具有助于创建构建和部署基础设施。但对于非常简单的部署，Gradle的一些功能可能很有用。Gradle提供了一系列任务，可以自动化一些之前提到的部署任务。以下是一些有用的任务：
- en: Download task to downloading the artifacts (ZIP, WAR, EAR, and so on) and its
    dependencies.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载任务用于下载工件（ZIP、WAR、EAR等）及其依赖项。
- en: You can download artifacts by just adding the list in the dependencies closure.
    In a similar fashion, you can download all the other dependencies needed to run
    the software. It is not needed to bundle the software with all the dependencies
    and make it heavy. It is good to download dependencies at the time of the installing
    the software to make it lightweight.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过仅将列表添加到依赖项闭包中来下载工件。以类似的方式，您可以下载运行软件所需的所有其他依赖项。不需要将软件及其所有依赖项捆绑在一起，使其变得笨重。在安装软件时下载依赖项以使其轻量级是很好的。
- en: Unzip or untar tasks to unzip the artifacts.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压或解tar任务以解压工件。
- en: Once artifacts and their dependencies are downloaded, next step is to unzip
    or untar the artifact if required.
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦下载了工件及其依赖项，下一步（如果需要）就是解压或解tar工件。
- en: Configure the application.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置应用程序。
- en: Configuration or localization of the application can be done in Gradle by adding
    custom tasks.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过添加自定义任务在Gradle中完成应用程序的配置或本地化。
- en: Start/stop the application.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动/停止应用程序。
- en: Start/Stop of the application can be performed using existing Gradle tasks,
    such as JavaExec or any other custom task.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用现有的Gradle任务（如JavaExec或任何其他自定义任务）来启动/停止应用程序。
- en: In my opinion, though these tasks can be automated in Gradle, a better alternative
    would be a scripting language such as Shell script or Perl. Later in this chapter
    when we create an example of build and deployment pipeline, the role of Gradle
    will be a pure build and test tool. We will not explore any task or plugin specific
    to deployment. Now we will move on to the next topic, Docker, that has become
    very popular in recent years with the emergence of micro-service architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，尽管这些任务可以在Gradle中自动化，但更好的替代方案可能是Shell脚本或Perl等脚本语言。在本章的后面部分，当我们创建构建和部署管道的示例时，Gradle将仅作为纯构建和测试工具。我们不会探索任何特定于部署的任务或插件。现在，我们将继续讨论下一个主题，Docker，它在近年来随着微服务架构的出现而变得非常流行。
- en: Docker overview
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker概述
- en: Docker is an open source container-based virtualization technology that helps
    to automate the deployment of an application inside a container. Docker uses resource
    isolation features of the Linux kernel such as cgroups and kernel namespaces and
    it allows the running of multiple containers independently and isolated from each
    other on a host machine. The benefit of Docker over virtual machine is that Docker
    is a light-weight process compared to a virtual machine and it provides resource
    isolation when sharing the same kernel including drivers of the host machine.
    Docker is open source technology and supported on different platforms. As Docker
    is built on top of Linux kernel, it supports Windows and Mac using **Boot2Docker**
    application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一种开源的基于容器的虚拟化技术，有助于在容器内自动化应用程序的部署。Docker使用Linux内核的资源隔离功能，如cgroups和内核命名空间，并允许在主机机器上独立且相互隔离地运行多个容器。与虚拟机相比，Docker的优势在于它是一个轻量级的过程，与虚拟机相比，它提供了资源共享同一内核时的资源隔离，包括主机机的驱动程序。Docker是开源技术，支持不同的平台。由于Docker建立在Linux内核之上，它通过**Boot2Docker**应用程序支持Windows和Mac。
- en: 'Some of the main features of Docker are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的一些主要特性包括：
- en: 'Docker Engine: The light-weight container to create, manage and containerize
    the application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker引擎：轻量级容器，用于创建、管理和容器化应用程序。
- en: 'Portability: One of the important features is container-reuse. You can prepare
    one Tomcat image and use this image as a base image for all other web applications.
    This image can be deployed in any system like desktop, physical servers, virtual
    machines, and even in cloud.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性：其中一个重要特性是容器重用。您可以准备一个Tomcat镜像，并将此镜像用作所有其他Web应用程序的基础镜像。此镜像可以部署在任何系统上，如桌面、物理服务器、虚拟机，甚至云平台。
- en: 'Docker Hub: Docker also has its own SaaS-based public registry shared with
    developers across the globe. You can fid different kinds of images like MySQL,
    Tomcat, Java, Redis, and other technologies. Users can create and upload images
    to this repository.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub：Docker还有一个基于SaaS的全球共享公共注册表。您可以找到不同种类的镜像，如MySQL、Tomcat、Java、Redis和其他技术。用户可以创建和上传镜像到这个存储库。
- en: 'Faster delivery: Docker containers are very fast compared to virtual machines.
    This feature helps in reducing the time for development, testing and deployment.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的交付：与虚拟机相比，Docker容器非常快。这个特性有助于减少开发、测试和部署的时间。
- en: 'API: Docker supports a user friendly API to manage Docker containers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API：Docker支持一个用户友好的API来管理Docker容器。
- en: You might be using virtual machine in an organization infrastructure. Docker
    is very different from a virtual machine. A virtual machine has its own operating
    system with device drivers, memory, CPU shares, and son on. On the other hand,
    a container shares the host operating system and most of these resources with
    other container on the same host.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在组织的基础设施中使用虚拟机。Docker与虚拟机非常不同。虚拟机有自己的操作系统和设备驱动程序、内存、CPU份额等。另一方面，容器与宿主操作系统共享，并且与其他宿主上的容器共享大部分这些资源。
- en: 'Let''s look at some differences between Docker and virtual machines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Docker和虚拟机之间的一些区别：
- en: Docker uses Linux containers, which share the same operating system, whereas
    each virtual machine has its own operating system thus increasing the overhead
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker使用Linux容器，这些容器共享相同的操作系统，而每个虚拟机都有自己的操作系统，这增加了开销
- en: Docker uses **Another Union File System** (**AUFS**) that is a layered file
    system. It has a read-only part that is shared by all containers and write part
    that is unique for each container to write its own data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker使用**另一个联合文件系统（AUFS**），这是一个分层文件系统。它有一个所有容器共享的只读部分，以及每个容器独有的写入部分，用于写入自己的数据
- en: Docker is a light weight technology that requires minimum resources of its own
    as it shares the maximum resources, whereas a full VM system shares minimum resources
    and gets most of resources of its own
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker是一种轻量级技术，它自己需要的资源最少，因为它共享了最多的资源，而完整的虚拟机系统共享最少的资源，并获取大部分自己的资源
- en: Docker startup time is very less as compared to VM
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与虚拟机相比，Docker的启动时间非常短。
- en: Docker is mostly suitable for small applications (Micro Services) that can share
    the common resources and just isolate itself with some processes, whereas VM is
    suitable for heavier applications that need full isolation of resources
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker主要适用于小型应用程序（微服务），这些应用程序可以共享公共资源，并通过一些进程进行隔离，而虚拟机则适用于需要完全隔离资源的重型应用程序
- en: Now in the next two sections, we will work with Docker installation and then
    we will learn some of the most used Docker commands.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将处理Docker安装，然后我们将学习一些最常用的Docker命令。
- en: Installing Docker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'To install Docker in Ubuntu Trusty 14.04 LTS, following commands can be used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu Trusty 14.04 LTS上安装Docker，可以使用以下命令：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, to get the latest version of Docker you can use this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要获取Docker的最新版本，可以使用以下方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To know the installed version, you have to run the `docker version` command,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解安装的版本，您需要运行`docker version`命令，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Docker is also supported on Mac OS X, Windows, or cloud platforms. Docker installation
    guide for these platforms is available at [https://docs.docker.com/](https://docs.docker.com/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker也支持在Mac OS X、Windows或云平台上运行。这些平台的Docker安装指南可在[https://docs.docker.com/](https://docs.docker.com/)找到。
- en: 'To verify the installation, you can execute the `docker run hello-world` command.
    This command downloads a test image and runs the command in a container:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证安装，您可以执行`docker run hello-world`命令。此命令下载一个测试镜像并在容器中运行命令：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the preceding message is displayed on the console, it means the installation
    is successful. In the next section, we will learn some of the useful Docker commands.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在控制台上显示先前的消息，则表示安装成功。在下一节中，我们将学习一些有用的Docker命令。
- en: Docker commands
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker命令
- en: Once Docker is installed on the host machine, it runs as a daemon process. The
    interface given to users is a Docker client. Communication between Docker daemon
    and users happens through Docker client. Docker provides a variety of commands
    for different needs, which helps to automate the deployment process very easily.
    Now we will learn different Docker commands. As this is not a Docker book, the
    discussion will be limited to some basic commands. You can refer to the following
    Docker website for the complete reference guide at [https://docs.docker.com/reference/](https://docs.docker.com/reference/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Help command
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once Docker is installed, to see the list of all the commands supported you
    can type `docker help`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: This command lists all the available Docker commands. The basic syntax of a
    Docker command is `docker <options> command <argument>`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Download image
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, Docker provides its own public repository from where
    you can download the images to get started with Docker. You do not need to reinvent
    the wheel by creating the image, unless needed. In the repository, you can find
    lots of images varying from plain vanilla OS to images embedded with Java, Tomcat,
    MySQL, and so on. To download an image from the repository, you can use the `docker
    pull <image name>` command, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, this command pulls images from the public Docker registry, but you
    can configure private registry as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The list of images
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the image is downloaded, you can find the list of images using the `docker
    images` command, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It will list all the downloaded images available in the filesystem. You can
    create one or many containers using images.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Creating a container
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once image is downloaded, you can create a container using the Docker `run`
    command, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command creates a container named `testUbuntu1` from the image Ubuntu and
    the command we have mentioned is `/bin/bash`, to just execute a shell or command-line
    interface. The output of this command is the container ID. You can access the
    container by its name `tesUbuntu1` or by the container ID.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the `-d` option will start it as a daemon process, the `-i` option is
    for interactive, and the `-t` option is to allocate a pseudo`-TTY`. Let''s create
    another container as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It will create another container with the name `testUbuntu2`. You can create
    many containers with the same image by giving different names. If you do not specify
    any name, Docker assigns some default name. The syntax of the run command is `$
    docker run <options> <imagename> <command>`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The container list
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find the list of running containers use the Docker `ps` command, as shown
    here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we have created two containers but the output shows only one container
    `testUbuntu1` that is running. Run the same command now with the `–a` option,
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output lists all the containers with individual status. Notice that the
    `testUbuntu2` container is exited, that is, stopped, whereas `testUbuntu1` is
    still running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列出了所有容器及其各自的状态。注意`testUbuntu2`容器已退出，即已停止，而`testUbuntu1`仍在运行。
- en: Start/stop container
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动/停止容器
- en: 'Once the container is created from the image, it can be started/stopped using
    the following commands:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从图像创建容器，可以使用以下命令启动/停止容器：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Following is an example of the preceding command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个前述命令的示例：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Connecting to a container
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到容器
- en: 'If you have started a container and then you want to connect to the running
    container console, the Docker `attach` command can be used as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已启动容器，然后想要连接到正在运行的容器控制台，可以使用Docker的`attach`命令，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use *Ctrl* + *P* + *Q* to exit the container. The `exit` or `^C` command will
    take you out of the container and additionally, it will stop the running container
    by killing all the running processes. If you want to just move out of the container
    without stopping, use *Ctrl* + *P* + *Q*. These commands could be different based
    on operating systems. Refer to the Docker documentation for more details.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *P* + *Q*退出容器。`exit`或`^C`命令将带您退出容器，并且还会通过杀死所有运行进程来停止正在运行的容器。如果您只想退出容器而不停止，请使用*Ctrl*
    + *P* + *Q*。这些命令可能因操作系统而异。有关更多详细信息，请参阅Docker文档。
- en: Deleting a container
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'The Docker `rm` command deletes or removes a container from the machine, as
    follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的`rm`命令从机器中删除或移除容器，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can check whether it is deleted properly by running the `docker ps -a`
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`docker ps -a`命令来检查是否已正确删除：
- en: Removing an image
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除图像
- en: 'To remove an image from the system, use the `docker rmi` command. This command
    will remove the image from the machine. You need to stop any running container
    before removing the image. This is done as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要从系统中删除图像，请使用`docker rmi`命令。此命令将从机器中删除图像。在删除图像之前，您需要停止任何正在运行的容器。操作如下：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Copying files to the container
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文件复制到容器
- en: 'With the UNIX `cp` command, a file can be copied from the host to the container.
    For example, the following command copies the `dir1` folder from the host system
    to the container''s `/home/mycontents` directory. Here we have to provide the
    absolute path of the container installed in the host machine:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UNIX的`cp`命令，可以从主机复制文件到容器。例如，以下命令将主机系统中的`dir1`文件夹复制到容器的`/home/mycontents`目录。在这里，我们必须提供主机机器上安装的容器的绝对路径：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But this is not a good practice. Alternative solution is to mount the directories
    when creating the container with the `–v` option:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是一个好的做法。替代方案是在创建容器时使用`–v`选项挂载目录：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding command will create a container named `testUbuntu`. The command
    also maps the `/home/user1/dir1` directory of host machine to the `/home/dir1`
    directory of the container.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令将创建一个名为`testUbuntu`的容器。该命令还将主机机器的`/home/user1/dir1`目录映射到容器的`/home/dir1`目录。
- en: 'To copy the contents from the container to host machine, the `docker cp` command
    can be used, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要将容器中的内容复制到主机机器，可以使用`docker cp`命令，如下所示：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Container details
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器详情
- en: 'The Docker `inspect` command helps to find the complete details of container
    run as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的`inspect`命令有助于找到容器运行的完整详情，如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It will provide the complete detail of the container such as name, path, network
    settings, IP address, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提供容器的完整详情，例如名称、路径、网络设置、IP地址等。
- en: Updating DNS settings
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新DNS设置
- en: 'To update DNS settings, you can edit the `/etc/default/docker` file. You can
    change proxy setting and DNS setting in this file. The content of the file is
    shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更新DNS设置，您可以编辑`/etc/default/docker`文件。您可以在该文件中更改代理设置和DNS设置。文件内容如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Networking in an important concept and you should spend more time reading about
    it. More details can be found at [https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个重要的概念，您应该花更多时间阅读有关它的内容。更多详细信息可以在[https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/)找到。
- en: Creating an image from a container
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从容器创建图像
- en: 'You might be interested in creating new images from the base container with
    additional software. Consider an example where you have created the `testUbuntu1`
    container from the base Ubuntu image. Then you have installed Tomcat server, deployed
    web application, and maybe you have installed some other required software like
    Ant, Git, and so on. You might want to save all the changes for future. The following
    `docker commit` command is useful in this scenario:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能对从基础容器创建带有额外软件的新镜像感兴趣。考虑一个例子，您已经从基础Ubuntu镜像创建了`testUbuntu1`容器。然后您安装了Tomcat服务器，部署了Web应用程序，也许您还安装了一些其他必需的软件，如Ant、Git等。您可能希望保存所有更改以备将来使用。以下`docker
    commit`命令在这种情况下很有用：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command will create a new image `user1/ubuntu_1` that will comprise a basic
    Ubuntu image and all the applications installed by you on that container. This
    command will commit the new image to the local repository. Next time, you can
    start a container from the new image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个新镜像`user1/ubuntu_1`，它将包含基本Ubuntu镜像和您在该容器上安装的所有应用程序。此命令将新镜像提交到本地仓库。下次，您可以从新镜像启动容器。
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command will create the `testUbuntu_1` container using the new image committed
    earlier. If you have created an account in the Docker repository ([https://registry.hub.docker.com](https://registry.hub.docker.com)),
    you can even push the new images to the public repository.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用之前提交的新镜像创建名为`testUbuntu_1`的容器。如果您在Docker仓库中创建了账户([https://registry.hub.docker.com](https://registry.hub.docker.com))，您甚至可以将新镜像推送到公共仓库。
- en: Running an application in Docker
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行应用程序
- en: So far, we have learnt what is Docker and the different commands to work with
    Docker. In this section, we will develop a web application and we will deploy
    the web application in a Docker container. For simplicity, we will download a
    Tomcat image from the Docker repository. Then the Docker container will be started
    with proper port mapping, so that it can be accessed from the host machine. Finally,
    a web application will be deployed in the running container.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了什么是Docker以及如何使用不同的命令来操作Docker。在本节中，我们将开发一个Web应用程序，并将该Web应用程序部署到Docker容器中。为了简化，我们将从Docker仓库下载一个Tomcat镜像。然后，通过适当的端口映射启动Docker容器，以便可以从主机机器访问它。最后，将在运行的容器中部署一个Web应用程序。
- en: To create a Tomcat container, we will pull an image from the central repository
    [https://registry.hub.docker.com/_/tomcat/](https://registry.hub.docker.com/_/tomcat/).
    The repository provides support for different versions of Tomcat such as 6, 7,
    and 8\. For this application, we will use Tomcat 7.0.57 version. This version
    can be downloaded from the registry by running the `docker pull tomcat:7.0.57-jre7`
    command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Tomcat容器，我们将从中央仓库[https://registry.hub.docker.com/_/tomcat/](https://registry.hub.docker.com/_/tomcat/)拉取一个镜像。该仓库支持Tomcat的不同版本，如6、7和8。对于此应用程序，我们将使用Tomcat
    7.0.57版本。此版本可以通过运行`docker pull tomcat:7.0.57-jre7`命令从注册表中下载。
- en: 'After the image is downloaded, we have to create the container using the downloaded
    image and then start it. The container is created and started with the `docker
    run` command with one of the options `-p <host_port>:<container_port>`. This option
    enables to access the running Tomcat container by routing the host port to the
    container port. The following command starts the container with the name as `userdetailsservice`.
    Additionally, the `–rm` option is used to remove the filesystem when the container
    exits. This is required for the cleanup process:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下载镜像后，我们必须使用下载的镜像创建容器并启动它。使用带有选项`-p <host_port>:<container_port>`的`docker run`命令创建并启动容器。此选项可以通过将主机端口路由到容器端口来访问正在运行的Tomcat容器。以下命令以`userdetailsservice`为名启动容器。此外，使用`–rm`选项在容器退出时删除文件系统。这对于清理过程是必需的：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After running the command, the Tomcat server is accessible from the host machine
    at `http://localhost:8181`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，Tomcat服务器可以通过主机机器上的`http://localhost:8181`访问：
- en: '![Running an application in Docker](img/B02000_09_01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![在Docker中运行应用程序](img/B02000_09_01.jpg)'
- en: Figure 9.1
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1
- en: Tomcat server is up and running; and the next task is to deploy the web application
    in the running container. Deploying the web application can be done in multiple
    ways. Here we will discuss three different approaches to deploy the web application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat服务器正在运行；下一个任务是部署Web应用程序到运行的容器中。部署Web应用程序可以通过多种方式完成。在这里，我们将讨论三种不同的部署Web应用程序的方法。
- en: 'Adding web application as a data volume: Already we have learnt how to mount
    a data volume with the container using the -v option. This approach can be applied
    even to deploy a web application. If we have the file structure of the web application
    on the host machine, it can be mounted to the webapps directory of Tomcat.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Web应用程序作为数据卷添加：我们已经学习了如何使用`-v`选项将数据卷挂载到容器中。这种方法甚至可以应用于部署Web应用程序。如果我们有主机机器上的Web应用程序的文件结构，它可以挂载到Tomcat的webapps目录中。
- en: 'The following command shows an example of deploying an application named `userdetailsservice`
    in the `/usr/local/tomcat/webapps/` directory of the Tomcat container:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下命令显示了在Tomcat容器的`/usr/local/tomcat/webapps/`目录中部署名为`userdetailsservice`的应用程序的示例：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Copying WAR file from host to container: Another approach is to copy the application
    WAR file directly from the host machine to the container. To achieve this, first
    we have to start the container with the run command as explained previously:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机复制WAR文件到容器：另一种方法是直接从主机机器复制应用程序WAR文件到容器。为了实现这一点，首先我们必须使用之前解释的run命令启动容器：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the container is running, we have to find the long container ID. This
    can be done as follows using the `docker ps` command with the `--no-trunc` option:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当容器运行时，我们必须找到长的容器ID。这可以通过使用带有`--no-trunc`选项的`docker ps`命令来完成：
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we can use the simple UNIX `cp` command to copy the `.war` file to the
    Docker file system as shown here:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们可以使用简单的UNIX `cp`命令将`.war`文件复制到Docker文件系统，如下所示：
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, this approach is not recommended as copying file from host to container
    is not a good option. Rather we should use the data mount option.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这种方法并不推荐，因为从主机复制文件到容器不是一个好的选择。相反，我们应该使用数据挂载选项。
- en: 'Tomcat Admin: Tomcat admin tool can be used to deploy web application from
    a web-based user interface. To deploy a web app from Tomcat admin, you need to
    have the proper access privilege to the Tomcat manager GUI. The Tomcat image that
    we downloaded for this example does not allow us to access the Tomcat admin page.
    So first, we have to enable access for a user by modifying the `tomcat-users.xml`
    file. We can simply use the `-v` option to bind an existing `tomcat-users.xml`
    file to the container as follows:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat管理员：Tomcat管理员工具可以从基于Web的用户界面部署Web应用程序。要从Tomcat管理员部署Web应用程序，您需要具有对Tomcat管理GUI的正确访问权限。我们为这个示例下载的Tomcat镜像不允许我们访问Tomcat管理员页面。因此，首先，我们必须通过修改`tomcat-users.xml`文件来为用户启用访问权限。我们可以简单地使用`-v`选项将现有的`tomcat-users.xml`文件绑定到容器，如下所示：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This approach works well. But if you want to modify the `tomcat-users.xml`
    file of the container permanently, a different approach can be taken. First, we
    have to start the Tomcat container with the following command:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法效果很好。但如果您想永久修改容器的`tomcat-users.xml`文件，可以采取不同的方法。首先，我们必须使用以下命令启动Tomcat容器：
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then from another terminal, enter the bash of the container using the Docker
    `exec` command. as shown here:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中，使用Docker的`exec`命令进入容器的bash，如下所示：
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next step is to modify the `/usr/local/tomcat/conf/tomcat-users.xml` file from
    a text editor. To do this, we might need to install vim with the `apt-get` install
    `vim` command. You are free to use any text editor of your choice:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从文本编辑器修改`/usr/local/tomcat/conf/tomcat-users.xml`文件。为此，我们可能需要使用`apt-get
    install vim`命令安装vim。您可以使用任何您选择的文本编辑器：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After vim is installed successfully, we have to add the following lines at
    the end of the `tomcat-users.xml` file (before `</tomcat-users>`), to enable access
    to Tomcat-admin GUI for the admin user:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装vim之后，我们必须在`tomcat-users.xml`文件的末尾添加以下行（在`</tomcat-users>`之前），以启用管理员用户对Tomcat-admin
    GUI的访问：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, changes have been applied to the container and we have to save the new
    changes by creating a new image using the `docker commit` command as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更改已经应用到容器中，我们必须通过使用以下`docker commit`命令创建一个新的镜像来保存新的更改：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The new image was saved as `usedetailsimage` with the `v1` tag. This can be
    verified by listing all the `docker images`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 新镜像已保存为带有`v1`标签的`usedetailsimage`。这可以通过列出所有`docker images`来验证：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This newly created image can be used to start the Tomcat server as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新创建的镜像可以用来启动Tomcat服务器，如下所示：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After Tomcat is started successfully, we will be able to log in to the Tomcat
    administrator page at `http://localhost:8181/manager/` with the `admin/admin`
    credentials. The web application can be deployed by selecting the WAR file to
    deploy option. Application `userdetailsservice` takes few seconds to start up
    and it will be visible on the Tomcat admin page as shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tomcat 成功启动后，我们将能够使用 `admin/admin` 凭据登录到 Tomcat 管理员页面 `http://localhost:8181/manager/`。可以通过选择部署
    WAR 文件选项来部署 Web 应用程序。应用程序 `userdetailsservice` 启动需要几秒钟，它将在 Tomcat 管理员页面上显示，如下面的截图所示：
- en: '![Running an application in Docker](img/B02000_09_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![在 Docker 中运行应用程序](img/B02000_09_02.jpg)'
- en: Figure 9.2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2
- en: Build, Deployment, and Test pipeline
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建、部署和测试管道
- en: 'In the last section, we have learned how to create a container like Apache
    Tomcat with Docker and how to deploy an application in the running container.
    Once the application is up and running, we can run some automated tests to verify
    the functionality. That should be easy! What else can be done? Well, throughout
    this book we have learned how to automate the build process with Gradle; also
    in [Chapter 7](ch07.html "Chapter 7. Continuous Integration"), *Continuous Integration*,
    we discussed continuous integration tools, such as Jenkins. Now we should be able
    to apply all these knowledge to create a simple build, deploy, and test workflow
    to automate the complete process from build to deployment. Do not get confused
    with the continuous delivery pipeline. This is just a simple example to automate
    the build, deployment, and test together with tools, such as Gradle, Docker, and
    Jenkins. We can set up the pipeline with three simple steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 Docker 创建一个类似于 Apache Tomcat 的容器，以及如何在运行中的容器中部署应用程序。一旦应用程序启动并运行，我们就可以运行一些自动化测试来验证其功能。这应该很简单！还能做些什么呢？嗯，在这本书的整个过程中，我们学习了如何使用
    Gradle 自动化构建过程；在[第 7 章](ch07.html "第 7 章。持续集成")“持续集成”中，我们讨论了持续集成工具，例如 Jenkins。现在，我们应该能够应用所有这些知识来创建一个简单的构建、部署和测试工作流程，以自动化从构建到部署的整个过程。不要与持续交付管道混淆。这只是一个简单的示例，用于使用
    Gradle、Docker 和 Jenkins 等工具一起自动化构建、部署和测试。我们可以通过以下三个简单步骤设置管道：
- en: Automate the process of creating or building the artifacts with Gradle.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Gradle 自动化创建或构建工件的过程。
- en: Deploy the newly created libraries in a running container. The container is
    created and started with Docker.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行中的容器中部署新创建的库。该容器是通过 Docker 创建并启动的。
- en: Run automated tests to verify the functionalities of the deployed application.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行自动化测试以验证已部署应用程序的功能。
- en: 'These steps can be sequentially configured and executed with the help of Jenkins.
    All we need to do is to create a new Freestyle project, say `build_deployment_pipeline`.
    Then, add the Source Code Management configuration such as Git (Git URL is [https://github.com/mitramkm/mastering-gradle.git](https://github.com/mitramkm/mastering-gradle.git))
    as shown in the following screenshot. For more details please refer [Chapter 7](ch07.html
    "Chapter 7. Continuous Integration"), *Continuous Integration*. After the basic
    Jenkins job configuration, we have to configure three build steps to automate
    the build, deployment, and test execution:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以通过 Jenkins 的帮助按顺序配置和执行。我们所需做的只是创建一个新的 Freestyle 项目，例如 `build_deployment_pipeline`。然后，添加源代码管理配置，如
    Git（Git URL 为 [https://github.com/mitramkm/mastering-gradle.git](https://github.com/mitramkm/mastering-gradle.git)），如下面的截图所示。有关更多详细信息，请参阅[第
    7 章](ch07.html "第 7 章。持续集成")“持续集成”。在完成基本的 Jenkins 作业配置后，我们必须配置三个构建步骤来自动化构建、部署和测试执行：
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![构建、部署和测试管道](img/B02000_09_03.jpg)'
- en: Figure 9.3
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3
- en: 'After the source code management configuration, we have to add a build step
    in Jenkins to build the web application. In this step, we will execute the `clean
    war` task on a Gradle project named `UserDetailsService`. This is a simple web
    application to expose a RESTful service. The Gradle task will create a WAR file
    in the `build/libs` directory of the project. In the build step configuration,
    we have specified the `Root Build script` as `${workspace}/Chapter9/UserDetailsService`.
    So, the WAR file will be created in the `%JENKINS_HOME%/jobs/build_deployment_pipeline/workspace/Chapter9/UserDetailsService/build/libs/`
    directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码管理配置之后，我们必须在Jenkins中添加一个构建步骤来构建Web应用程序。在这个步骤中，我们将对名为`UserDetailsService`的Gradle项目执行`clean
    war`任务。这是一个简单的Web应用程序，用于公开RESTful服务。Gradle任务将在项目的`build/libs`目录中创建一个WAR文件。在构建步骤配置中，我们指定了`Root
    Build script`为`${workspace}/Chapter9/UserDetailsService`。因此，WAR文件将在`%JENKINS_HOME%/jobs/build_deployment_pipeline/workspace/Chapter9/UserDetailsService/build/libs/`目录中创建：
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_04.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![构建、部署和测试流水线](img/B02000_09_04.jpg)'
- en: Figure 9.4
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4
- en: 'We are done with the first step. Next step is to create a Tomcat container
    and deploy the WAR file. This can be done by running a shell script that automates
    the following tasks:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第一步。下一步是创建一个Tomcat容器并部署WAR文件。这可以通过运行一个自动化以下任务的shell脚本来完成：
- en: Pull Tomcat container from the repository.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从仓库中拉取Tomcat容器。
- en: Check whether any existing container is running. If any container is running,
    stop and remove that container.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有任何现有的容器正在运行。如果有任何容器正在运行，请停止并删除该容器。
- en: Start the container with the required configuration such as port, name, memory,
    and CPU.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所需的配置（如端口、名称、内存和CPU）启动容器。
- en: Finally, deploy the application.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，部署应用程序。
- en: 'The following shell script automates all the operations mentioned previously:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本自动化了之前提到的所有操作：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The script is ready. We will configure and execute the script as the second
    build step in the deployment pipeline job. Though we are using shell script to
    control docker commands, even this can be done using Gradle tasks (such as Exec)
    or Gradle plugin for Docker. Some Docker plugins are available at [https://plugins.gradle.org/](https://plugins.gradle.org/).
    You can also explore these plugins, if you want to do everything in Gradle way:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已准备就绪。我们将配置并执行脚本，作为部署管道作业的第二步构建步骤。尽管我们使用shell脚本控制docker命令，但即使这样也可以使用Gradle任务（如Exec）或Gradle
    Docker插件来完成。一些Docker插件可在[https://plugins.gradle.org/](https://plugins.gradle.org/)找到。如果您想以Gradle的方式完成所有操作，也可以探索这些插件：
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_05.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![构建、部署和测试流水线](img/B02000_09_05.jpg)'
- en: Figure 9.5
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5
- en: 'After the execution of the second build step, the web application is up and
    running in the Tomcat container. Finally, we have to verify the functionality
    of the application by running an automated test suite. The sample web application
    is a RESTful service, which exposes the `getUsers()` and `createUser()` type functionalities
    as HTTP GET and POST methods. The following code snippet is an example of `TestNG`
    cases that can be executed as sanity checks. It makes HTTP GET and HTTP POST calls
    at `http://localhost:8080/userdetailsservice/userdetails`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行第二步构建步骤后，Web应用程序在Tomcat容器中运行并启动。最后，我们必须通过运行自动化测试套件来验证应用程序的功能。示例Web应用程序是一个RESTful服务，它通过HTTP
    GET和POST方法公开`getUsers()`和`createUser()`类型的功能。以下代码片段是`TestNG`测试用例的示例，可以作为健全性检查执行。它对`http://localhost:8080/userdetailsservice/userdetails`执行HTTP
    GET和HTTP POST调用：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To execute the test case, we will create a third build step in the Jenkins
    pipeline with the task as gradle test. In this example, for simplicity we have
    created integration test code in the `src/test` folder. Ideally, in the `src/test`
    directory, we should keep only unit test code. If you are writing any integration
    or regression test, it should be done in a separate Java project. Another point
    to remember is that, test task is primarily used to execute unit test code. If
    you are writing some integration test code, consider creating a new Gradle task
    (such as `integrationTest`) that runs JUnit, TestNG or any other test suite:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试用例，我们将在Jenkins管道中创建一个第三步构建步骤，任务为gradle test。在这个例子中，为了简单起见，我们在`src/test`文件夹中创建了集成测试代码。理想情况下，在`src/test`目录中，我们应该只保留单元测试代码。如果您正在编写任何集成或回归测试，它应该在单独的Java项目中完成。另一个需要记住的是，测试任务主要用于执行单元测试代码。如果您正在编写一些集成测试代码，请考虑创建一个新的Gradle任务（如`integrationTest`），该任务运行JUnit、TestNG或任何其他测试套件：
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_06.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![构建、部署和测试流水线](img/B02000_09_06.jpg)'
- en: Figure 9.6
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6
- en: 'Now we are ready to run the job in Jenkins. The job executes three tasks sequentially—building
    a web application, deploying the application in a newly created container, and
    finally performing some integration tests. The console output of the complete
    job is displayed in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在 Jenkins 中运行作业。作业依次执行三个任务——构建一个网络应用程序，在新创建的容器中部署应用程序，并最终执行一些集成测试。完整作业的控制台输出显示在下述屏幕截图中：
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_07.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![构建、部署和测试流水线](img/B02000_09_07.jpg)'
- en: Figure 9.7
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed about application deployment and how to containerize
    an application with the help of Docker. We learned how to automate build, deploy,
    and test workflow with Gradle, Docker, and Jenkins.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了应用程序部署以及如何借助 Docker 容器化应用程序。我们学习了如何使用 Gradle、Docker 和 Jenkins 自动化构建、部署和测试工作流程。
- en: In the next chapter, we will cover Android application development and its build
    process using Gradle.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Android 应用程序开发及其使用 Gradle 的构建过程。
