- en: Chapter 9. Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Gradle book will be incomplete, unless we talk about the deployment aspect
    of a software component. In my opinion, in software engineering the most logical
    step after build automation is deployment. Deployment itself is a different domain
    and this has very little to do with Gradle. But still I think it makes sense to
    discuss build and deployment tools together, so that the reader gets an overview
    of **Build**, **Deploy**, and **Test** workflow. In this chapter, we will discuss
    some basics of deployment to give a flavor of the build and deployment process.
    We will learn how to use tools such as Gradle, Jenkins, and Docker together to
    create a build, deployment, and test workflow. Before we start, we have to understand,
    what deployment is. Deployment is as important as the build process in the software
    life cycle. You can write and build great software, but unless the application
    is deployed, it does not produce much value. Deployment of software is not just
    about installing software and starting it. It varies from application to application,
    operating system to operating system. Some application can be deployed just by
    copying a JAR file to a particular location; some applications require deployment
    in a web container, or in external containers and so on. We can generalize the
    deployment process of software as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the prerequisite hardware and software environment where you want to
    deploy the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy project assets on the prepared environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure assets based on the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare a life cycle of the application such as start, stop, restart, and so
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do a sanity check of the application to verify its functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So deployment is not just copying the assets and notifying everyone that the
    application is ready to use. It also involves a lot of other pre and post steps.
    Deployment process has also been evolved along with the development processes
    and is still evolving with newer technologies. There was a time when the operation
    team used to deploy the application manually on specified nodes, configure load
    balancing mechanism and routing from box to box to effectively handle client requests.
    Now, with the help of new cloud infrastructures, such as **Infrastructure as a
    Service** (**IaaS**) or with various automation tools, with just one click or
    with some commands, developer can deploy application on one box, cluster environment,
    cloud-based environment or containerized environment. In this chapter, we will
    focus on the deployment process with Docker, an application containerization technology.
    We will have a detailed look into different aspects of Docker such as installation,
    configuration; benefits of Docker over virtual server node deployment; deploy
    application inside Docker; and how to make it available to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: Role of Gradle in deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gradle plays one of the major roles in the build and deployment process. Developer
    can use a combination of different tools based on the requirement to automate
    the complete build and deployment process. Tools such as Jenkins, Puppet, Chef,
    and Docker help to create the build and deployment infrastructure. But for very
    simple deployments, some of the Gradle features can be useful. Gradle provides
    a variety of tasks that can automate some of deployment tasks as mentioned previously.
    Few useful tasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download task to downloading the artifacts (ZIP, WAR, EAR, and so on) and its
    dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can download artifacts by just adding the list in the dependencies closure.
    In a similar fashion, you can download all the other dependencies needed to run
    the software. It is not needed to bundle the software with all the dependencies
    and make it heavy. It is good to download dependencies at the time of the installing
    the software to make it lightweight.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unzip or untar tasks to unzip the artifacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once artifacts and their dependencies are downloaded, next step is to unzip
    or untar the artifact if required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configure the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuration or localization of the application can be done in Gradle by adding
    custom tasks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start/stop the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start/Stop of the application can be performed using existing Gradle tasks,
    such as JavaExec or any other custom task.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In my opinion, though these tasks can be automated in Gradle, a better alternative
    would be a scripting language such as Shell script or Perl. Later in this chapter
    when we create an example of build and deployment pipeline, the role of Gradle
    will be a pure build and test tool. We will not explore any task or plugin specific
    to deployment. Now we will move on to the next topic, Docker, that has become
    very popular in recent years with the emergence of micro-service architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Docker overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is an open source container-based virtualization technology that helps
    to automate the deployment of an application inside a container. Docker uses resource
    isolation features of the Linux kernel such as cgroups and kernel namespaces and
    it allows the running of multiple containers independently and isolated from each
    other on a host machine. The benefit of Docker over virtual machine is that Docker
    is a light-weight process compared to a virtual machine and it provides resource
    isolation when sharing the same kernel including drivers of the host machine.
    Docker is open source technology and supported on different platforms. As Docker
    is built on top of Linux kernel, it supports Windows and Mac using **Boot2Docker**
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the main features of Docker are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Engine: The light-weight container to create, manage and containerize
    the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Portability: One of the important features is container-reuse. You can prepare
    one Tomcat image and use this image as a base image for all other web applications.
    This image can be deployed in any system like desktop, physical servers, virtual
    machines, and even in cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Hub: Docker also has its own SaaS-based public registry shared with
    developers across the globe. You can fid different kinds of images like MySQL,
    Tomcat, Java, Redis, and other technologies. Users can create and upload images
    to this repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Faster delivery: Docker containers are very fast compared to virtual machines.
    This feature helps in reducing the time for development, testing and deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API: Docker supports a user friendly API to manage Docker containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be using virtual machine in an organization infrastructure. Docker
    is very different from a virtual machine. A virtual machine has its own operating
    system with device drivers, memory, CPU shares, and son on. On the other hand,
    a container shares the host operating system and most of these resources with
    other container on the same host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some differences between Docker and virtual machines:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker uses Linux containers, which share the same operating system, whereas
    each virtual machine has its own operating system thus increasing the overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker uses **Another Union File System** (**AUFS**) that is a layered file
    system. It has a read-only part that is shared by all containers and write part
    that is unique for each container to write its own data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker is a light weight technology that requires minimum resources of its own
    as it shares the maximum resources, whereas a full VM system shares minimum resources
    and gets most of resources of its own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker startup time is very less as compared to VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker is mostly suitable for small applications (Micro Services) that can share
    the common resources and just isolate itself with some processes, whereas VM is
    suitable for heavier applications that need full isolation of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now in the next two sections, we will work with Docker installation and then
    we will learn some of the most used Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Docker in Ubuntu Trusty 14.04 LTS, following commands can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, to get the latest version of Docker you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To know the installed version, you have to run the `docker version` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Docker is also supported on Mac OS X, Windows, or cloud platforms. Docker installation
    guide for these platforms is available at [https://docs.docker.com/](https://docs.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the installation, you can execute the `docker run hello-world` command.
    This command downloads a test image and runs the command in a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding message is displayed on the console, it means the installation
    is successful. In the next section, we will learn some of the useful Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once Docker is installed on the host machine, it runs as a daemon process. The
    interface given to users is a Docker client. Communication between Docker daemon
    and users happens through Docker client. Docker provides a variety of commands
    for different needs, which helps to automate the deployment process very easily.
    Now we will learn different Docker commands. As this is not a Docker book, the
    discussion will be limited to some basic commands. You can refer to the following
    Docker website for the complete reference guide at [https://docs.docker.com/reference/](https://docs.docker.com/reference/).
  prefs: []
  type: TYPE_NORMAL
- en: Help command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once Docker is installed, to see the list of all the commands supported you
    can type `docker help`.
  prefs: []
  type: TYPE_NORMAL
- en: This command lists all the available Docker commands. The basic syntax of a
    Docker command is `docker <options> command <argument>`.
  prefs: []
  type: TYPE_NORMAL
- en: Download image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, Docker provides its own public repository from where
    you can download the images to get started with Docker. You do not need to reinvent
    the wheel by creating the image, unless needed. In the repository, you can find
    lots of images varying from plain vanilla OS to images embedded with Java, Tomcat,
    MySQL, and so on. To download an image from the repository, you can use the `docker
    pull <image name>` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By default, this command pulls images from the public Docker registry, but you
    can configure private registry as well.
  prefs: []
  type: TYPE_NORMAL
- en: The list of images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the image is downloaded, you can find the list of images using the `docker
    images` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It will list all the downloaded images available in the filesystem. You can
    create one or many containers using images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once image is downloaded, you can create a container using the Docker `run`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a container named `testUbuntu1` from the image Ubuntu and
    the command we have mentioned is `/bin/bash`, to just execute a shell or command-line
    interface. The output of this command is the container ID. You can access the
    container by its name `tesUbuntu1` or by the container ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the `-d` option will start it as a daemon process, the `-i` option is
    for interactive, and the `-t` option is to allocate a pseudo`-TTY`. Let''s create
    another container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It will create another container with the name `testUbuntu2`. You can create
    many containers with the same image by giving different names. If you do not specify
    any name, Docker assigns some default name. The syntax of the run command is `$
    docker run <options> <imagename> <command>`.
  prefs: []
  type: TYPE_NORMAL
- en: The container list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find the list of running containers use the Docker `ps` command, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created two containers but the output shows only one container
    `testUbuntu1` that is running. Run the same command now with the `–a` option,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output lists all the containers with individual status. Notice that the
    `testUbuntu2` container is exited, that is, stopped, whereas `testUbuntu1` is
    still running.
  prefs: []
  type: TYPE_NORMAL
- en: Start/stop container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the container is created from the image, it can be started/stopped using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is an example of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have started a container and then you want to connect to the running
    container console, the Docker `attach` command can be used as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use *Ctrl* + *P* + *Q* to exit the container. The `exit` or `^C` command will
    take you out of the container and additionally, it will stop the running container
    by killing all the running processes. If you want to just move out of the container
    without stopping, use *Ctrl* + *P* + *Q*. These commands could be different based
    on operating systems. Refer to the Docker documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker `rm` command deletes or removes a container from the machine, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check whether it is deleted properly by running the `docker ps -a`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing an image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove an image from the system, use the `docker rmi` command. This command
    will remove the image from the machine. You need to stop any running container
    before removing the image. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Copying files to the container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the UNIX `cp` command, a file can be copied from the host to the container.
    For example, the following command copies the `dir1` folder from the host system
    to the container''s `/home/mycontents` directory. Here we have to provide the
    absolute path of the container installed in the host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is not a good practice. Alternative solution is to mount the directories
    when creating the container with the `–v` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create a container named `testUbuntu`. The command
    also maps the `/home/user1/dir1` directory of host machine to the `/home/dir1`
    directory of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy the contents from the container to host machine, the `docker cp` command
    can be used, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Container details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Docker `inspect` command helps to find the complete details of container
    run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It will provide the complete detail of the container such as name, path, network
    settings, IP address, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Updating DNS settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update DNS settings, you can edit the `/etc/default/docker` file. You can
    change proxy setting and DNS setting in this file. The content of the file is
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Networking in an important concept and you should spend more time reading about
    it. More details can be found at [https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an image from a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might be interested in creating new images from the base container with
    additional software. Consider an example where you have created the `testUbuntu1`
    container from the base Ubuntu image. Then you have installed Tomcat server, deployed
    web application, and maybe you have installed some other required software like
    Ant, Git, and so on. You might want to save all the changes for future. The following
    `docker commit` command is useful in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a new image `user1/ubuntu_1` that will comprise a basic
    Ubuntu image and all the applications installed by you on that container. This
    command will commit the new image to the local repository. Next time, you can
    start a container from the new image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command will create the `testUbuntu_1` container using the new image committed
    earlier. If you have created an account in the Docker repository ([https://registry.hub.docker.com](https://registry.hub.docker.com)),
    you can even push the new images to the public repository.
  prefs: []
  type: TYPE_NORMAL
- en: Running an application in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learnt what is Docker and the different commands to work with
    Docker. In this section, we will develop a web application and we will deploy
    the web application in a Docker container. For simplicity, we will download a
    Tomcat image from the Docker repository. Then the Docker container will be started
    with proper port mapping, so that it can be accessed from the host machine. Finally,
    a web application will be deployed in the running container.
  prefs: []
  type: TYPE_NORMAL
- en: To create a Tomcat container, we will pull an image from the central repository
    [https://registry.hub.docker.com/_/tomcat/](https://registry.hub.docker.com/_/tomcat/).
    The repository provides support for different versions of Tomcat such as 6, 7,
    and 8\. For this application, we will use Tomcat 7.0.57 version. This version
    can be downloaded from the registry by running the `docker pull tomcat:7.0.57-jre7`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the image is downloaded, we have to create the container using the downloaded
    image and then start it. The container is created and started with the `docker
    run` command with one of the options `-p <host_port>:<container_port>`. This option
    enables to access the running Tomcat container by routing the host port to the
    container port. The following command starts the container with the name as `userdetailsservice`.
    Additionally, the `–rm` option is used to remove the filesystem when the container
    exits. This is required for the cleanup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the command, the Tomcat server is accessible from the host machine
    at `http://localhost:8181`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running an application in Docker](img/B02000_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1
  prefs: []
  type: TYPE_NORMAL
- en: Tomcat server is up and running; and the next task is to deploy the web application
    in the running container. Deploying the web application can be done in multiple
    ways. Here we will discuss three different approaches to deploy the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding web application as a data volume: Already we have learnt how to mount
    a data volume with the container using the -v option. This approach can be applied
    even to deploy a web application. If we have the file structure of the web application
    on the host machine, it can be mounted to the webapps directory of Tomcat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following command shows an example of deploying an application named `userdetailsservice`
    in the `/usr/local/tomcat/webapps/` directory of the Tomcat container:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copying WAR file from host to container: Another approach is to copy the application
    WAR file directly from the host machine to the container. To achieve this, first
    we have to start the container with the run command as explained previously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the container is running, we have to find the long container ID. This
    can be done as follows using the `docker ps` command with the `--no-trunc` option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can use the simple UNIX `cp` command to copy the `.war` file to the
    Docker file system as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this approach is not recommended as copying file from host to container
    is not a good option. Rather we should use the data mount option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Tomcat Admin: Tomcat admin tool can be used to deploy web application from
    a web-based user interface. To deploy a web app from Tomcat admin, you need to
    have the proper access privilege to the Tomcat manager GUI. The Tomcat image that
    we downloaded for this example does not allow us to access the Tomcat admin page.
    So first, we have to enable access for a user by modifying the `tomcat-users.xml`
    file. We can simply use the `-v` option to bind an existing `tomcat-users.xml`
    file to the container as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This approach works well. But if you want to modify the `tomcat-users.xml`
    file of the container permanently, a different approach can be taken. First, we
    have to start the Tomcat container with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then from another terminal, enter the bash of the container using the Docker
    `exec` command. as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next step is to modify the `/usr/local/tomcat/conf/tomcat-users.xml` file from
    a text editor. To do this, we might need to install vim with the `apt-get` install
    `vim` command. You are free to use any text editor of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After vim is installed successfully, we have to add the following lines at
    the end of the `tomcat-users.xml` file (before `</tomcat-users>`), to enable access
    to Tomcat-admin GUI for the admin user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, changes have been applied to the container and we have to save the new
    changes by creating a new image using the `docker commit` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The new image was saved as `usedetailsimage` with the `v1` tag. This can be
    verified by listing all the `docker images`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This newly created image can be used to start the Tomcat server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After Tomcat is started successfully, we will be able to log in to the Tomcat
    administrator page at `http://localhost:8181/manager/` with the `admin/admin`
    credentials. The web application can be deployed by selecting the WAR file to
    deploy option. Application `userdetailsservice` takes few seconds to start up
    and it will be visible on the Tomcat admin page as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running an application in Docker](img/B02000_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2
  prefs: []
  type: TYPE_NORMAL
- en: Build, Deployment, and Test pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section, we have learned how to create a container like Apache
    Tomcat with Docker and how to deploy an application in the running container.
    Once the application is up and running, we can run some automated tests to verify
    the functionality. That should be easy! What else can be done? Well, throughout
    this book we have learned how to automate the build process with Gradle; also
    in [Chapter 7](ch07.html "Chapter 7. Continuous Integration"), *Continuous Integration*,
    we discussed continuous integration tools, such as Jenkins. Now we should be able
    to apply all these knowledge to create a simple build, deploy, and test workflow
    to automate the complete process from build to deployment. Do not get confused
    with the continuous delivery pipeline. This is just a simple example to automate
    the build, deployment, and test together with tools, such as Gradle, Docker, and
    Jenkins. We can set up the pipeline with three simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Automate the process of creating or building the artifacts with Gradle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the newly created libraries in a running container. The container is
    created and started with Docker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run automated tests to verify the functionalities of the deployed application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps can be sequentially configured and executed with the help of Jenkins.
    All we need to do is to create a new Freestyle project, say `build_deployment_pipeline`.
    Then, add the Source Code Management configuration such as Git (Git URL is [https://github.com/mitramkm/mastering-gradle.git](https://github.com/mitramkm/mastering-gradle.git))
    as shown in the following screenshot. For more details please refer [Chapter 7](ch07.html
    "Chapter 7. Continuous Integration"), *Continuous Integration*. After the basic
    Jenkins job configuration, we have to configure three build steps to automate
    the build, deployment, and test execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3
  prefs: []
  type: TYPE_NORMAL
- en: 'After the source code management configuration, we have to add a build step
    in Jenkins to build the web application. In this step, we will execute the `clean
    war` task on a Gradle project named `UserDetailsService`. This is a simple web
    application to expose a RESTful service. The Gradle task will create a WAR file
    in the `build/libs` directory of the project. In the build step configuration,
    we have specified the `Root Build script` as `${workspace}/Chapter9/UserDetailsService`.
    So, the WAR file will be created in the `%JENKINS_HOME%/jobs/build_deployment_pipeline/workspace/Chapter9/UserDetailsService/build/libs/`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with the first step. Next step is to create a Tomcat container
    and deploy the WAR file. This can be done by running a shell script that automates
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull Tomcat container from the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether any existing container is running. If any container is running,
    stop and remove that container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the container with the required configuration such as port, name, memory,
    and CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, deploy the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following shell script automates all the operations mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is ready. We will configure and execute the script as the second
    build step in the deployment pipeline job. Though we are using shell script to
    control docker commands, even this can be done using Gradle tasks (such as Exec)
    or Gradle plugin for Docker. Some Docker plugins are available at [https://plugins.gradle.org/](https://plugins.gradle.org/).
    You can also explore these plugins, if you want to do everything in Gradle way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5
  prefs: []
  type: TYPE_NORMAL
- en: 'After the execution of the second build step, the web application is up and
    running in the Tomcat container. Finally, we have to verify the functionality
    of the application by running an automated test suite. The sample web application
    is a RESTful service, which exposes the `getUsers()` and `createUser()` type functionalities
    as HTTP GET and POST methods. The following code snippet is an example of `TestNG`
    cases that can be executed as sanity checks. It makes HTTP GET and HTTP POST calls
    at `http://localhost:8080/userdetailsservice/userdetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the test case, we will create a third build step in the Jenkins
    pipeline with the task as gradle test. In this example, for simplicity we have
    created integration test code in the `src/test` folder. Ideally, in the `src/test`
    directory, we should keep only unit test code. If you are writing any integration
    or regression test, it should be done in a separate Java project. Another point
    to remember is that, test task is primarily used to execute unit test code. If
    you are writing some integration test code, consider creating a new Gradle task
    (such as `integrationTest`) that runs JUnit, TestNG or any other test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to run the job in Jenkins. The job executes three tasks sequentially—building
    a web application, deploying the application in a newly created container, and
    finally performing some integration tests. The console output of the complete
    job is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build, Deployment, and Test pipeline](img/B02000_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed about application deployment and how to containerize
    an application with the help of Docker. We learned how to automate build, deploy,
    and test workflow with Gradle, Docker, and Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover Android application development and its build
    process using Gradle.
  prefs: []
  type: TYPE_NORMAL
