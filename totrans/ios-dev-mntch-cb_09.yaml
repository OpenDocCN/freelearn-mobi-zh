- en: Chapter 9. Interacting with Device Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting device orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting UI orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proximity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving battery information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling motion events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the gyroscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's mobile devices are equipped with very advanced hardware. Be it accelerometers
    to detect motion and orientation, proximity sensors, GPS modules, and among many
    other components, quite sophisticated multi-touch screens.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be focusing on how to use this hardware within our
    applications to provide the user with an experience that extends into the 3D world.
    Specifically, we will discuss how to adjust the user interface orientation according
    to the position of the device, how to use the proximity sensor, and read battery
    information. In a series of four tasks, we will learn how to capture user touches
    on the screen and recognize gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we will create advanced applications that read the raw data
    from the accelerometer and gyroscope sensors to detect device motion and rotation,
    with detailed and simple guides.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting device orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make an application that is aware of device
    orientation changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `DeviceOrientationApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rotate the simulator by holding the **Command** key on your Mac and pressing
    the left or right arrow keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the simulator lacks accelerometer hardware, it supports notifications
    for orientation changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The device orientation notification mechanism can be accessed through the `UIDevice.CurrentDevice`
    singleton object. To receive notifications, we first need to instruct the runtime
    to issue them. We do this with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This method turns the accelerometer on and starts generating orientation notifications.
    We then need to start observing for the notifications, in order to respond to
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each time the device orientation changes, the observer triggers the anonymous
    method. In it, we output the orientation, which we get from the `Orientation`
    property, to the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewDidUnload` method is the method that is being called when the view
    controller unloads its view. Inside it, we make sure to remove the orientation
    observer, and we instruct the runtime to stop generating orientation notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Orientation` property returns an enumeration of the type `UIDeviceOrientation`.
    Its values are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Unknown:` This value specifies that the device orientation is unknown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Portrait:` This value specifies that the device is in its normal portrait
    orientation, with the **home** button on the bottom side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PortraitUpsideDown:` This value specifies that the device is in upside-down
    portrait orientation, with the **home** button on the top side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LandscapeLeft:` This value specifies that the device is in landscape orientation,
    with the **home** button on the left side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LandscapeRight:` This value specifies that the device is in landscape orientation,
    with the **home** button on the right side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FaceUp:` This value specifies that the device is parallel to the ground, with
    the screen facing up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FaceDown:` This value specifies that the device is parallel to the ground,
    with the screen facing down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FaceUp` and `FaceDown` are two values that cannot be reproduced on the simulator.'
  prefs: []
  type: TYPE_NORMAL
- en: Device orientation and user interface orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What can be clearly noticed in this example is that there is a difference between
    a device's orientation and that of the user interface. If the device is rotated,
    the label gets updated with the new orientation value, but the user interface
    does not respond to changes. In the next recipe, we will discuss how to rotate
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adjusting UI orientation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using the accelerometer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting UI orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to rotate the **User Interface (UI)** according
    to the screen orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `UIOrientationApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use *Command* + arrow keys to rotate the simulator. The **LandscapeRight**
    orientation is shown in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make our UI adjust to device orientations, all we need to do is override
    the view controller''s `ShouldAutorotateToInterfaceOrientation` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When the view controller loads, it checks the outcome of the method for each
    of the available orientations. The first time it receives `true` from it, it will
    automatically rotate the interface to that orientation. After loading, whenever
    the device rotates, the same process gets repeated.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter of the method is an enumeration of the type `UIInterfaceOrientation`,
    and each time the method gets called, it contains the value of the orientation
    the interface checks for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DidRotate` method is called after the interface orientation completes.
    We use the `UIViewController.InterfaceOrientation` property, which holds the information
    on the view controller''s current orientation, to update the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Returning `true` from the `ShouldAutorotateToInterfaceOrientation` method means
    that the interface will rotate on all device orientations. In most cases, this
    is not necessary and should even be avoided, depending on our application design.
    To make our interface rotate to landscape orientations only, the method should
    be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that this implementation will force the UI to load at landscape mode.
  prefs: []
  type: TYPE_NORMAL
- en: User interface orientation on the simulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you implement the `ShouldAutorotateToInterfaceOrientation` method to only
    support landscape orientations, then the controller that loads the simulator "device"
    will also rotate at landscape orientation. However, this is for convenience only,
    since if you check the `UIDevice.CurrentDevice.Orientation` property, its value
    will be `UIDeviceOrientation.Portrait`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Detecting device orientation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using the accelerometer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proximity sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss using the proximity sensor to disable the device
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `ProximitySensorApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simulator does not support the proximity sensor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this task, no controls are needed, besides the `MainController` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare an `NSObject` field that will hold the notification observer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code in the `ViewDidLoad` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, enter the following code in the `ViewDidUnload` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put your finger over the proximity sensor, or just hold it next to your ear
    as you would do when on a call. Watch the **Application Output** pad in MonoDevelop
    display the state of the sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the functionality of the proximity sensor is quite simple, it provides
    a very important feature. iOS devices have only one button on the front, which
    is the **home** button. Almost every user-device interaction is based on the touch-sensitive
    screen. This poses a problem on the iPhone: apart from its multiple features,
    it is also a phone. This means that it will most likely spend some time on the
    side of the user''s face for making calls.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid accidental virtual buttons being tapped, the proximity sensor gets
    activated when the phone application is running, to disable the screen when the
    device is near the user's ear, or whatever is over the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the proximity sensor, set the property of the `UIDevice.CurrentDevice.ProximityMonitoringEnabled`
    to `true:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the device does not support the proximity sensor, this property will return
    `false`, even after it has been set to `true`. So, after setting it to `true`,
    we can check it to see if the device supports the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking, we can add an observer for getting notified of the sensor''s
    state with the `UIDevice.ProximityStateDidChangeNotification` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `ProximityState` property returns `true` if the sensor has turned the screen
    off and `false` if it has turned it back on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proximity sensor usage is not limited to phone call functionality. For example,
    if you are developing an application that could do some work while the device
    is in the user's pocket or purse, enabling the proximity sensor would make sure
    that no accidental controls are tapped. Or even save battery power, by just turning
    the screen off.
  prefs: []
  type: TYPE_NORMAL
- en: Sensor support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all devices support a proximity sensor. If you are targeting various iOS
    devices, consider that the sensor will not be available on all of them.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Retrieving battery information*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving battery information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to read the charging states of the device
    and its battery usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `BatteryInfoApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the application loads, disconnect and/or connect the USB cable of the
    device. Watch the battery state on the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can retrieve battery information through the `UIDevice` class. The first
    thing we have to do is to enable battery monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: On the simulator, which does not support battery monitoring, this property will
    return false, even after we have set it to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then add an observer for battery state change notifications through
    the `UIDevice.BatteryStateDidChangeNotification` key, as indicated in the highlighted
    code previously. The battery state can be retrieved through the `BatteryState`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Possible values of the `BatteryState` property are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Unknown:` This value specifies that the battery state cannot be determined,
    or battery monitoring is disabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unplugged:` This value specifies that the device is running on battery power'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Charging:` This value specifies that the device battery is charging, and the
    USB cable is connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Full:` This value specifies that the device battery is full, and the USB cable
    is connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the battery state, we can get information on its power level. To
    do this, we need to add an observer for the `UIDevice.BatteryLevelDidChangeNotification`
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `BatteryLevel` property returns a float value in the range from `0.0` (battery
    empty) to `1.0` (battery full at 100 percent). If battery monitoring is disabled,
    it will return a value of `-1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling battery monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always disable battery monitoring when not needed. The actual monitoring mechanism
    itself consumes battery power.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Proximity sensor*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling motion events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to intercept and respond to shake gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `MotionEventsApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a label on the view of `MainController`. Enter the following code in the
    `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shake the device and watch the output on the label. You can also test this application
    on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After it loads, click on **Hardware | Shake Gesture** on the menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By overriding the motion methods of the `UIViewController` class, we can intercept
    and respond to the motion events sent by the system. Just overriding these methods
    is not enough, though. For a controller to receive motion events, it needs to
    be the first responder. To make sure of this, we first override the `CanBecomeFirstResponder`
    property and return `true` from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we make sure our controller becomes the first responder when its view
    has appeared by calling the `BecomeFirstResponder` method in the `ViewDidAppear`
    override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ViewDidAppear` method gets called after the view has appeared on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system determines if a motion is a shake gesture and calls the appropriate
    methods. We can use the following three methods to override and capture shake
    gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MotionBegan:` This method specifies that shaking motion started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MotionEnded:` This method specifies that shaking motion ended'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MotionCancelled:` This method specifies that shaking motion cancelled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the device starts moving, the `MotionBegan` method is called. If the motion
    lasts for about a second or less, the `MotionEnded` method is called. If it lasts
    longer, the system classifies it as not being a shake gesture and calls the `MotionCancelled`
    method. It is advisable to override all three methods and react accordingly when
    we want to implement shake gestures in an application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Motion events are only sent to objects inheriting the `UIResponder` class. This
    includes the `UIView` and `UIViewController` classes.
  prefs: []
  type: TYPE_NORMAL
- en: More info motion events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The motion event mechanism is fairly simple. It merely detects near-instant
    device shakes, without providing any information on their direction or rate. To
    handle motion events based on different characteristics, the accelerometer can
    be used in combination.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the accelerometer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to intercept and respond to user touches.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `TouchEventsApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a label on the view of `MainController`, and enter the following code in
    the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click-and-drag sideways with the cursor on the simulator's screen, and watch
    the view's background color gradually change from white to black. Note that clicking
    with the cursor on the simulator screen is the equivalent of touching the device's
    screen with a finger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To respond to user touches, the object that acts as a touch receiver must have
    its `UserInteractionEnabled` property set to `true`. Almost every object is enabled
    for user interaction by default, except for those whose primary usage is not intended
    for direct user interaction, for example, the `UILabel` and the `UIImageView`.
    We need to set the `UserInteractionEnabled` to these objects explicitly. Apart
    from this, the objects that can handle touch events must inherit from the `UIResponder`
    class. Note that although the `UIViewController` class inherits from `UIResponder`
    and therefore can capture touch events, it does not have a `UserInteractionEnabled`
    property, and it is its main property of `UIView` that controls the delivery of
    touch events. What this means is that if you override the touch methods of a `UIViewController`
    but its view's `UserInteractionEnabled` property is set to `false`, these methods
    will not respond to user touches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods responsible for handling the touch events are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TouchesBegan:` This method is called when the user touches the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchesMoved:` This method is called when the user drags the finger on the
    screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchesEnded:` This method is called when the user lifts the finger from the
    screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchesCancelled:` This method is called when the touch event has been cancelled
    by a system event, for example, when a notification alert is displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full project can be found in the downloaded source code. The `TouchesMoved`
    method implementation is explained here.
  prefs: []
  type: TYPE_NORMAL
- en: Every touch method has two parameters. The first parameter is of the type `NSSet`
    and contains the `UITouch` objects. The `NSSet` class represents a collection
    of objects, while the `UITouch` class holds the information for each user touch.
    The second parameter is of the type `UIEvent` and holds the information of the
    actual event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the `UITouch` object related to the actual touch through the
    `NSSet.AnyObject` return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns an object of type `NSObject`, which we convert to a `UITouch`. We
    can get the previous and current locations of the touch through the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Both of them return a `PointF struct` containing the location of the touch in
    the receiver's coordinate system. After receiving the location of the touch, we
    adjust the background color accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example is based on single user touches. To enable a view to respond to
    multiple touches, we have to set its `MultipleTouchEnabled` property to `true`.
    We can then get all the `UITouch` objects in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Getting the tap count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can determine the number of consecutive user taps through the `UITouch.TapCount`
    property inside the `ToucheEnded` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MotionEvents*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Recognizing gestures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Custom gestures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to recognize touch gestures and respond
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `GestureApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a label on the view of `MainController`. Enter the following `using` directive
    in the `MainController` class source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hold down the **Option** key and click-drag with the mouse to perform the equivalent
    of a pinch on the simulator screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the iOS 3.2 version was released along with the iPad, Apple introduced
    the `UIGestureRecognizer` class and its derivatives. The gesture recognizers make
    use of the multiple touch screens on iOS devices. **Gestures** are basically touch
    combinations, which can be performed for specific actions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, pinching on a full-screen image in the native **Photos** application
    will zoom out. The action of pinching is the gesture the user performs, while
    the gesture recognizer is responsible for recognizing and delivering the gesture
    event to its receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create a `UIPinchGestureRecognizer`, which will recognize
    pinches performed on the screen. Its instance is created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The constructor that initializes the instance takes two parameters. The first
    one is of type `NSObject`, and it is the target object that will receive the gesture.
    In this case, it is the `MainController` instance, which we pass with the `this`
    keyword. The second parameter is of the type `Selector`, contained in the `MonoTouch.ObjCRuntime`
    namespace that we added, and it represents the method that will be called when
    the recognizer receives a gesture. In simple words, a `Selector` in Objective-C
    is basically a method signature. The string we pass to its constructor represents
    the Objective-C method that will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using C#, we can easily expose a method as an Objective-C `Selector`.
    We just create the method we want and decorate it with the `ExportAttribute`,
    making sure the string we pass to it is the same that we have passed to the `Selector`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside the method, we read the `State` property of the gesture recognizer object
    and respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The state of each gesture recognizer is represented by an enumeration of the
    type `UIGestureRecognizerState`. Its values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Possible:` This value specifies that the gesture has not yet been recognized
    and is the default value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Began:` This value specifies that the gesture has started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Changed:` This value specifies that the gesture has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ended:` This value specifies that the gesture has ended'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cancelled:` This value specifies that the gesture has been cancelled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failed:` This value specifies that the gesture cannot be recognized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Recognized:` This value specifies that the gesture has been recognized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantage of gesture recognizers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of gesture recognizers is that they save developers the time to
    create their own gesture recognition mechanisms, through the touch events. Furthermore,
    they are based on the gestures that users are accustomed to using on iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Touch events*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Custom gestures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a custom gesture recognizer to create
    our own gesture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `CustomGestureApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a label on the view of `MainController`. Create the following nested class
    in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the custom gesture recognizer as shown in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a gesture recognizer, declare a class that inherits from the `UIGestureRecognizer`
    class. In this example, we are creating a gesture that will be recognized by dragging
    the finger on the screen towards a `50x50` point rectangle in the lower-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `UIGestureRecognizer` class contains the same touch methods that we use
    to intercept touches in views. We also have access to the view it was added to
    through its `View` property. Inside the `TouchesBegan` method, we determine the
    initial touch location. If it is outside the lower-left portion of the view, we
    set the `State` property to `Began`. If it is inside the lower-left portion, we
    set the `State` property to `Failed` so that the selector will not be called.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `TouchesEnded` method, we consider the gesture as `Ended` if the
    touch's location was inside the lower-left portion of the view. If it was not,
    the gesture recognition is considered as `Failed`.
  prefs: []
  type: TYPE_NORMAL
- en: The `TouchesMoved` method is where the `Changed` state will be set. For this
    simple gesture recognizer that we are creating, no other logic is needed in it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a simple gesture recognizer that depends on a single touch. With the
    information provided in the touch methods, we can create more complex gestures
    that will support multiple touches.
  prefs: []
  type: TYPE_NORMAL
- en: Another usage of custom gesture recognizers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some views that inherit from the `UIView` class, which according to
    Apple Developer Documentation should not be sub-classed. The `MKMapView` is one
    of these views, which is used to display maps. This poses a problem if we want
    to intercept the touch events from these views. Although we could use another
    view over it and intercept its touch events, it is a bit complex. A more simple
    approach is to create a simple custom gesture recognizer and add it to the view
    that we cannot sub-class. This way, we can intercept its touches without having
    to sub-class it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recognizing gestures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Touch events*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the accelerometer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to receive accelerometer events to create
    an application that is aware of device movement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `AccelerometerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simulator does not support the accelerometer hardware. The project in this
    example will work correctly on a device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add two buttons and a label on the view of `MainController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the `ViewDidLoad` method, and implement it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Start accelerometer** button, and watch the values display on the
    label while moving or shaking the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIAccelerometer` class provides access to the accelerometer hardware through
    its `SharedAccelerometer` static property. To activate it, all we need to do is
    to assign a handler to its `Acceleration` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the handler, we receive the accelerometer values through the `UIAccelerometerEventArgs.Acceleration`
    property. The property returns an object of the type `UIAcceleration`, which contains
    the accelerometer amount in three properties: `X, Y`, and `Z`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties represent motion in the `X, Y`, and `Z` axes. Consider the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1468EXP_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of these values measures the amount of gravitational force by which the
    device moved on each axis. For example, if `X` has a value of `1`, then the device
    is moving on the `X-axis` to the right, with an acceleration of `1g`. If `X` has
    a value of `-1`, then the device is moving on the `X-axis` to the left, with an
    acceleration of `1g`. When the device is placed on a table with its back facing
    the floor and is not moving, the normal values of the acceleration should be close
    or equal to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`X: 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Y: 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z: -1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the device is not moving, `Z` will be `-1`, because the device measures
    the Earth's gravity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the interval by which the accelerometer will issue acceleration
    events by setting its `UpdateInterval` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It accepts a `double`, which represents the interval by which the accelerometer
    will issue its acceleration events in seconds. Care must be taken when setting
    the update interval, because the more events the accelerometer has to issue for
    a specific period of time, the more battery power it consumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop using the accelerometer, all we need to do is to unhook the handler
    from the `Acceleration` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIAcceleration` class contains another useful property, named `Time`. It
    is a double representing the relative time on which the acceleration event occurred.
    It is relative to CPU time, and it is not suggested to use this value to calculate
    the exact timestamp of the event.
  prefs: []
  type: TYPE_NORMAL
- en: Consideration using the accelerometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the iPhone's accelerometer is a very accurate and sensitive sensor,
    it should not be used for precise measurements. Also, the results it produces
    may vary among different iOS devices, even if those devices are of the same model.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the gyroscope*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the gyroscope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the built-in gyroscope.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `GyroscopeApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simulator does not support the gyroscope hardware. Also, only newer devices
    contain a gyroscope. If this application is executed on a device without a gyroscope,
    or on the simulator, no error will occur, but no data will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add two buttons and a label on the view of `MainController`. Add the namespace
    `MonoTouch.CoreMotion` in the `MainController.cs` file. Enter the following private
    field in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `ViewDidLoad` method, and implement it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Start gyroscope** button and rotate the device in all axes. Watch
    the values displayed in the **Application Output**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The gyroscope is a mechanism that measures orientation. Newer iOS devices support
    gyroscope hardware, along with the accelerometer, to give even more accurate measurements
    of device motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MonoTouch.CoreMotion` namespace wraps the objects contained in the native
    **CoreMotion Framework**. The process of using the gyroscope hardware in-code
    is similar to the one used for the accelerometer. The first difference is that
    there is no singleton object for the gyroscope in the `UIApplication` class. So,
    we need to create an instance of the `CMMotionManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like using the accelerometer, we can set the interval by which we will
    be receiving gyroscope events, in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To start receiving gyroscope events, we call the object''s `StartGyroUpdates`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method is overloaded; the first overload is parameterless and when called,
    the values of gyroscopic measurements are set to the `GyroData` property. Using
    this overload is quite simple and easy, but there no events are triggered, and
    we have to provide a mechanism for reading the measurements from the property.
  prefs: []
  type: TYPE_NORMAL
- en: The second overload, which is used in this example, accepts two parameters.
    The first parameter is the `NSOperationQueue`, on which the updates will occur,
    and the second parameter is the handler that will be executed when an update occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `NSOperationQueue` class represents an iOS mechanism for managing `NSOperation`
    objects execution. We access the runtime's main operation queue through the static
    `NSOperationQueue.MainQueue` property. Basically, this way, we instruct the runtime
    to manage the delivery of the handler in a more effective manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter is a delegate of the type `CMGyroHandler`. Its signature,
    represented by the method we created, is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMGyroData` object contains the actual measurement values received from
    the gyroscope through its `RotationRate` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The rotation rate is reflected on the `X, Y`, and `Z` axes, represented by the
    corresponding `X, Y`, and `Z` properties. Each value is the amount of rotation-angle-per-second
    that occurred on that axis, in radians.
  prefs: []
  type: TYPE_NORMAL
- en: Although it might seem a bit complicated at first, it is actually simple. For
    example, a value of `0.5` in the `Z-axis` means that the device rotated with a
    rate of `0.5` radians/sec to the left. A value of `-0.5` in the `Z-axis` means
    that the device rotated with a rate of `0.5` radians/sec to the right. The pattern
    for determining the rotation direction is based on the *right-hand rule*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want your application to be available only for devices that support the
    gyroscope, then add the key `UIRequiredDeviceCapabilities` in your project's `Info.plist`
    file, with the value `gyroscope`. If your application's functionality is based
    fully on the gyroscope, adding this key must be considered essential to avoid
    the application being downloaded by users with older devices, ending up with an
    application that does not work.
  prefs: []
  type: TYPE_NORMAL
- en: Determining gyroscope availability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To determine if the device the application is running on supports gyroscope
    hardware, check the value of the `GyroAvailable` property of the `CMMotionManager`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Converting radians to degrees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A radian is an angle measurement unit. To convert an angle measurement from
    radians to degrees, consider the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the accelerometer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
