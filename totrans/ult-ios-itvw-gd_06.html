<html><head></head><body>
		<div id="_idContainer018" class="calibre2">
			<h1 id="_idParaDest-75" class="chapter-number"><a id="_idTextAnchor097" class="calibre6 pcalibre pcalibre1"/>4</h1>
			<h1 id="_idParaDest-76" class="calibre5"><a id="_idTextAnchor098" class="calibre6 pcalibre pcalibre1"/>Data Structures and Algorithms</h1>
			<p class="calibre3">We spent time and effort on our resume, performing company research and building our developer brand. But what for? To start an interview process at a company we want to work for, and <span><em class="italic">get hired</em></span><span>!</span></p>
			<p class="calibre3">So, now that the first step has been achieved, we will turn to our next challenge, passing the iOS <span>technical interview.</span></p>
			<p class="calibre3">The first topic to pass the iOS technical interview will cover data structures such as classes, structs, dictionaries, and arrays. While we could begin with the fundamental principles of the Swift language, that could be considered a more technical subject. In contrast, <em class="italic">data structures involve more abstract concepts</em>. Therefore, we will leave the Swift language for <a href="B18653_05.xhtml#_idTextAnchor163" class="calibre6 pcalibre pcalibre1"><span><em class="italic">Chapter 5</em></span></a><span>.</span></p>
			<p class="calibre3">This chapter will cover the basic data structures often asked about in iOS technical interviews. To that end, we will cover the following topics in <span>this chapter:</span></p>
			<ul class="calibre10">
				<li class="calibre11">Learning the importance of <span>data structures</span></li>
				<li class="calibre11"><a id="_idTextAnchor099" class="calibre6 pcalibre pcalibre1"/>Answering classes and <span>struct questions</span></li>
				<li class="calibre11">Answering questions about <span>Swift array</span></li>
				<li class="calibre11">Covering the <span>Codable protocol</span></li>
				<li class="calibre11">Preparing for dictionary- and set-related <span>interview questions</span></li>
			</ul>
			<p class="calibre3">Before we begin, let’s take a moment to understand the significance of data structures and why I have chosen to start our technical discussion on <span>this topic.</span></p>
			<h1 id="_idParaDest-77" class="calibre5"><a id="_idTextAnchor100" class="calibre6 pcalibre pcalibre1"/>Learning the importance of data structures</h1>
			<p class="calibre3">Data structures<a id="_idIndexMarker172" class="calibre6 pcalibre pcalibre1"/> are the building blocks of our iOS development. In fact, data structures are the building blocks of many programming languages, and having a deep understanding in that area is the key to success in development and, therefore, passing an <span>iOS interview.</span></p>
			<p class="calibre3">What are considered to be data structures? Well, classes, structs, arrays, dictionaries, and sets are all examples of <span>data structures.</span></p>
			<p class="calibre3">But what precisely makes data structures so important? Here are a couple of reasons why data structures are an integral part of an iOS interview. Let’s list them before we go over some <a id="_idIndexMarker173" class="calibre6 pcalibre pcalibre1"/><span>interview questions.</span></p>
			<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor101" class="calibre6 pcalibre pcalibre1"/>Increasing efficiency</h2>
			<p class="calibre3">We always have <a id="_idIndexMarker174" class="calibre6 pcalibre pcalibre1"/>shortages and constraints when we discuss resources. Even though iOS devices have become much more powerful in the last few years, iOS development is no exception to the need <span>for efficiency.</span></p>
			<p class="calibre3">Each data structure has its own strength in terms of time and space complexity; therefore, it will have a different usage in our code. Sometimes, the difference in performance can be so significant that it can cause our app to run much slower on even the most <span>powerful iPhone.</span></p>
			<p class="callout-heading">What is “space and time complexity?”</p>
			<p class="callout">Time complexity<a id="_idIndexMarker175" class="calibre6 pcalibre pcalibre1"/> refers to the amount of time required to execute an algorithm or solve a problem as a function of the input size. It is usually measured in terms of the number of basic operations performed by <span>the algorithm.</span></p>
			<p class="callout">Space complexity, on the other hand, refers to the amount of memory required to execute an algorithm or solve a problem as a function of the input size. It is usually measured in terms of the amount of memory used by the algorithm to store data and <span>intermediate results.</span></p>
			<p class="calibre3">Showing a drastic knowledge gap in an interview will raise a big red flag, and having basic knowledge is a minimum requirement for an iOS developer, <span>even juniors.</span></p>
			<p class="calibre3">Nevertheless, let’s try to change the book atmosphere – not everything is red flags, and we can even earn points in an interview. Modularity is <span>one example.</span></p>
			<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor102" class="calibre6 pcalibre pcalibre1"/>Making our code modular</h2>
			<p class="calibre3">Call me a “super-geek,” but I think <a id="_idIndexMarker176" class="calibre6 pcalibre pcalibre1"/>a great use of data structures is making our code look like a piece of art. Modularity is perhaps the best example of an <span>artistic code.</span></p>
			<p class="calibre3">Data structures provide a way to organize and encapsulate our code, making it easier to read <span>and maintain.</span></p>
			<p class="calibre3">Developers who follow my online content already know that I’m a big fan of the <strong class="bold">single responsibility principle</strong>, which<a id="_idIndexMarker177" class="calibre6 pcalibre pcalibre1"/> is part of SOLID set of principles. This principle states that each module, function, class, or even variable should have its one and only <span>one responsibility.</span></p>
			<p class="callout-heading">About SOLID principles</p>
			<p class="callout">SOLID is an acronym for a set of principles in object-oriented programming that help to design more maintainable, scalable, and reusable code. The SOLID principles were introduced by Robert C. Martin in his paper <em class="italic">Design Principles and Design Patterns</em> in the <span>early 2000s.</span></p>
			<p class="callout">The five SOLID principles<a id="_idIndexMarker178" class="calibre6 pcalibre pcalibre1"/> are <span>as follows:</span></p>
			<p class="callout">- <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP</strong>): A class<a id="_idIndexMarker179" class="calibre6 pcalibre pcalibre1"/> should have only one reason <span>to change</span></p>
			<p class="callout">- <strong class="bold">Open-Closed Principle</strong> (<strong class="bold">OCP</strong>): Software entities<a id="_idIndexMarker180" class="calibre6 pcalibre pcalibre1"/> should be open for extension but closed <span>for modification</span></p>
			<p class="callout">- <strong class="bold">Liskov Substitution Principle</strong> (<strong class="bold">LSP</strong>): Subtypes<a id="_idIndexMarker181" class="calibre6 pcalibre pcalibre1"/> should be substitutable for their <span>base types</span></p>
			<p class="callout">- <strong class="bold">Interface Segregation Principle</strong> (<strong class="bold">ISP</strong>): Clients <a id="_idIndexMarker182" class="calibre6 pcalibre pcalibre1"/>should not be forced to depend on interfaces they do <span>not use</span></p>
			<p class="callout">- <strong class="bold">Dependency Inversion Principle</strong> (<strong class="bold">DIP</strong>): High-level <a id="_idIndexMarker183" class="calibre6 pcalibre pcalibre1"/>modules should not depend on low-level modules; both should depend <span>on abstractions</span></p>
			<p class="calibre3">Let’s look at the <span>following code:</span></p>
			<pre class="source-code">
class Employee {  var name: String
  var salary: Double
  // responsibility 1: store employee data
  init(name: String, salary: Double{
    self.name = name
    self.salary = salary
  }
  // responsibility 2: calculate payroll
  func calculatePayroll() -&gt; Double {
  }
}</pre>
			<p class="calibre3">We’ve got an <strong class="source-inline">Employee</strong> class <a id="_idIndexMarker184" class="calibre6 pcalibre pcalibre1"/>with two responsibilities – the first is to <em class="italic">store</em> the employee’s personal data, and the second is to <em class="italic">calculate</em> <span>the payroll.</span></p>
			<p class="calibre3">I’ll start with the basics – this is not a piece of code you want your interviewer to see, as it mixes two responsibilities in one class. It is much better to take the <strong class="source-inline">calculatePayroll()</strong> function and move it to a separate class named <strong class="source-inline">Payroll</strong> (<span>for example).</span></p>
			<p class="calibre3">The reason why code separation is essential is that we understand that having control of what’s happening in our code is crucial. If a class or a struct has more responsibilities, it can create a side effect that may lead to <span>other issues.</span></p>
			<p class="calibre3">We always need to explain (to the interviewer and ourselves) the goal of the class or the function we just wrote, what its role is in the design pattern we chose, and do the same thing for methods <span>and variables.</span></p>
			<p class="calibre3">Modular code is not only for logic separation – it also plays a significant role in my next point, which <a id="_idIndexMarker185" class="calibre6 pcalibre pcalibre1"/><span>is reusability.</span></p>
			<h2 id="_idParaDest-80" class="calibre7">Reu<a id="_idTextAnchor103" class="calibre6 pcalibre pcalibre1"/>sing our code</h2>
			<p class="calibre3">Do I need to<a id="_idIndexMarker186" class="calibre6 pcalibre pcalibre1"/> explain the importance of <span>code reuse?</span></p>
			<p class="calibre3">But just in case, when writing code that can be used in different places, code reuse can prevent bugs and <span>inconsistent behavior.</span></p>
			<p class="calibre3">Code reuse in data structures refers to the reuse of both logic and data. This can include using classes and structs to reuse logic and data structures, such as arrays and dictionaries, to store and access data in a <span>reusable manner.</span></p>
			<p class="calibre3">And that’s where code reusability relates to the previous point of modularity – if a data structure has one responsibility, it is easier to reuse, as there are no side effects that can prevent us from using that code in <span>other places.</span></p>
			<p class="calibre3">Another example of code reuse in data structures is <em class="italic">class inheritance</em>. When we create a subclass, we can use all the <span>superclass code.</span></p>
			<p class="calibre3">In general, interviewers love to see reusable code, as it makes our code more effective and less error-prone. A data structure can also make our code less error-prone in another way, which is an API <span>and interfaces.</span></p>
			<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor104" class="calibre6 pcalibre pcalibre1"/>Using data structures for an API</h2>
			<p class="calibre3">Another excellent<a id="_idIndexMarker187" class="calibre6 pcalibre pcalibre1"/> usage for the data structure is for <a id="_idIndexMarker188" class="calibre6 pcalibre pcalibre1"/>an <strong class="bold">API</strong> and interfaces. We should think of a data structure as a way to represent an entity or some other complex data collection. Creating API interfaces between the different components in our code is much easier if you think of it <span>that way.</span></p>
			<p class="calibre3">Let’s have a look at what it means in code by writing a <span><strong class="source-inline">sendPersonToServer()</strong></span><span> function:</span></p>
			<pre class="source-code">
func sendPersonToServer(name: String, age: Int, email:     String, phone: String, address: String) {
}</pre>
			<p class="calibre3">The <strong class="source-inline">sendPersonToServer()</strong> function’s goal is to send a person’s details to the server, but we can easily see the main problem here. First, we need to provide a long list of parameters, which is very inconvenient. But, much more importantly, it looks like all the parameters together <em class="italic">can be encapsulated</em> into a data structure that we can call – <span><strong class="source-inline">Person</strong></span><span>.</span></p>
			<p class="calibre3">Let’s see how the<a id="_idIndexMarker189" class="calibre6 pcalibre pcalibre1"/> function interface looks once<a id="_idIndexMarker190" class="calibre6 pcalibre pcalibre1"/> we extract it to a <span><strong class="source-inline">Person</strong></span><span> struct:</span></p>
			<pre class="source-code">
struct Person {    let name: String
    let age: Int
    let email: String
    let phone: String
    let address: String
}
func sendPersonToServer(person: Person) {
}</pre>
			<p class="calibre3">It’s much more elegant, <span>isn’t it?</span></p>
			<p class="calibre3">It looks like the interface for <strong class="source-inline">sendPersonToServer()</strong> function is much clearer now but also more consistent. Whenever we add a new variable to <strong class="source-inline">Person</strong>, we won’t have to update our functions header anymore because it is now capsulated within the <span>struct definition.</span></p>
			<p class="calibre3">That’s why interviewers often appreciate seeing solutions that involve the reuse of functions and API interfaces when discussing <span>potential strategies.</span></p>
			<p class="calibre3">We discussed the importance of data structures – we mentioned efficiency, modularity, reusable code, and interfaces. My main goal was to provide you with a knowledge infrastructure to help you build your answers during <span>the interview.</span></p>
			<p class="calibre3">Now, let’s review some<a id="_idIndexMarker191" class="calibre6 pcalibre pcalibre1"/> interview<a id="_idIndexMarker192" class="calibre6 pcalibre pcalibre1"/> questions about data structure, starting with <em class="italic">classes</em> <span>and </span><span><em class="italic">structs</em></span><span>!</span></p>
			<h1 id="_idParaDest-82" class="calibre5"><a id="_idTextAnchor105" class="calibre6 pcalibre pcalibre1"/>Answering classes and struct questions</h1>
			<p class="calibre3">Under the<a id="_idIndexMarker193" class="calibre6 pcalibre pcalibre1"/> umbrella <a id="_idIndexMarker194" class="calibre6 pcalibre pcalibre1"/>of data structures, classes, and struct questions are probably the most basic forms w<a id="_idTextAnchor106" class="calibre6 pcalibre pcalibre1"/>e use in our projects. The reason is that not only do classes and structs contain data, but they also provide the main logic of the app and the objects <span>they represent.</span></p>
			<p class="calibre3">When Apple announced Swift, they constantly pushed using structs over classes in many cases. The trend became even more extreme<a id="_idIndexMarker195" class="calibre6 pcalibre pcalibre1"/> when <strong class="bold">SwiftUI</strong> was announced, which was based solely on structs over classes. So, it goes without saying why classes and struct questions play a significant role in <span>iOS interviews.</span></p>
			<p class="calibre3">Let’s move to the first and the most popular question – classes <span>versus structs.</span></p>
			<h2 id="_idParaDest-83" class="calibre7">“What’s the difference between<a id="_idTextAnchor107" class="calibre6 pcalibre pcalibre1"/> a class and a struct?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">A class and a <a id="_idIndexMarker196" class="calibre6 pcalibre pcalibre1"/>struct have <a id="_idIndexMarker197" class="calibre6 pcalibre pcalibre1"/>many features in common – they are both used to define complex data types, <strong class="bold">methods</strong>, <span>and </span><span><strong class="bold">properties</strong></span><span>.</span></p>
			<p class="callout-heading">“Functions” or “methods?”</p>
			<p class="callout">Having a job interview in iOS development means that we need to be professional. As part of being professional, terminology is crucial, so it is important to distinguish between a function and a method. A function is a code block that performs a specific task and can be called from anywhere in the program. In contrast, a “method” is a function that is associated with a class or <span>a struct.</span></p>
			<p class="calibre3">However, classes and structs also have some significant differences that influence our choice when approaching a <a id="_idTextAnchor108" class="calibre6 pcalibre pcalibre1"/>problem we want <span>to solve.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">There are three main differences between classes <span>and structs:</span></p>
			<ul class="calibre10">
				<li class="calibre11">The first difference is that <em class="italic">classes are reference types</em>, while structs are <em class="italic">value types</em>. This means that when we pass an object that is based on a class to a function or another instance, we are actually working and modifying the original instance because the object we passed is just a reference. That’s not the case with structs – whenever we pass a struct to a function, we work with a copy of that struct, not the <span>original one.</span></li>
			</ul>
			<p class="calibre3">Have <a id="_idIndexMarker198" class="calibre6 pcalibre pcalibre1"/>a look <a id="_idIndexMarker199" class="calibre6 pcalibre pcalibre1"/>at the <span>following code:</span></p>
			<pre class="source-code">
struct A {    var name: String
}
var a = A(name: "Avi")
let b = a
a.name = "John"
print(b)
      print(a)</pre>
			<p class="calibre3">The result of the code will be <strong class="source-inline">Avi</strong>, and then <strong class="source-inline">John</strong>. However, if we declare <strong class="source-inline">A</strong> as a class, the results would be <strong class="source-inline">John</strong> and <strong class="source-inline">John</strong> because it’s a reference to the <span>original variable.</span></p>
			<ul class="calibre10">
				<li class="calibre11">Another difference is the fact that <em class="italic">we can inherit classes</em>, and by that, we mean we can derive a class from another class, including properties and methods. Structs cannot be derived from another struct (or class, for <span>that matter).</span></li>
				<li class="calibre11">The last<a id="_idIndexMarker200" class="calibre6 pcalibre pcalibre1"/> difference is <strong class="bold">mutability</strong>. Because a struct is a value type, we cannot change its properties if we mark it as <strong class="source-inline1">let</strong>. That’s not the case with a class – if a class is marked as <strong class="source-inline1">let</strong>, we can still mutate <span>its properties.</span></li>
			</ul>
			<p class="calibre3">The following <a id="_idIndexMarker201" class="calibre6 pcalibre pcalibre1"/>code<a id="_idIndexMarker202" class="calibre6 pcalibre pcalibre1"/> will raise <span>an error:</span></p>
			<pre class="source-code">
struct A {    var name: String
}
let a = A(name: "Avi")
a.name = "John"</pre>
			<p class="calibre3">However, if we change <strong class="source-inline">A</strong> to a class, that <span>will work:</span></p>
			<pre class="source-code">
class A {    var name: String
    init(name: String) {
        self.name = name
    }
}
let a = A(name: "Avi")
a.name = "John"</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Before we continue, let’s clear up something – there’s no such thing as “better” in topics such as data structures. There’s always a trade-off; we should emphasize that fact in <span>our interviews.</span></p>
			<p class="calibre3">Let’s now<a id="_idTextAnchor109" class="calibre6 pcalibre pcalibre1"/> move on to the <span>next question.</span></p>
			<h2 id="_idParaDest-84" class="calibre7">“Which is<a id="_idTextAnchor110" class="calibre6 pcalibre pcalibre1"/> better, a class or a struct?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">To thoroughly impress the interviewer, it is essential to not only be able to distinguish between a struct and a class, but also to demonstrate an understanding of when it is appropriate to use each data structure in <span>different situations.</span></p>
			<p class="calibre3">As we discussed earlier in this chapter, structs and classes have different features, so their use cases are<a id="_idIndexMarker203" class="calibre6 pcalibre pcalibre1"/> also <a id="_idIndexMarker204" class="calibre6 pcalibre pcalibre1"/>different. This is a more practical question th<a id="_idTextAnchor111" class="calibre6 pcalibre pcalibre1"/>an just knowing <span>the differences.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">Both are great data structures for different purposes. It’s a good idea to start with a struct and see whether it meets our needs. If we need additional capabilities, we can change it to <span>a class.</span></p>
			<p class="calibre3">We should use a class if we need to do <span>the following:</span></p>
			<ul class="calibre10">
				<li class="calibre11">Use it as a <span><em class="italic">reference</em></span><span> type</span></li>
				<li class="calibre11"><em class="italic">Inherit</em> from another class (such as <a id="_idIndexMarker205" class="calibre6 pcalibre pcalibre1"/>subclassing <strong class="bold">UIViewController</strong>, <span>for example)</span></li>
			</ul>
			<p class="calibre3">We should use a struct if need to do <span>the following:</span></p>
			<ul class="calibre10">
				<li class="calibre11">Pass it <span>between </span><span><em class="italic">threads</em></span></li>
				<li class="calibre11"><span>Optimize </span><span><em class="italic">performance</em></span></li>
			</ul>
			<p class="calibre3">It is important to state that there’s no such thing as “better” without context. It is all based on the use c<a id="_idTextAnchor112" class="calibre6 pcalibre pcalibre1"/>ases and the requirements of <span>our code.</span></p>
			<h2 id="_idParaDest-85" class="calibre7">“Why <a id="_idTextAnchor113" class="calibre6 pcalibre pcalibre1"/>are structs faster than classes?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">This question may not be meaningful on its own, but interviewers like to ask it because they want to check how deeply the candidate understands how structs and classes are stored in a device’s memory. Knowing the answer to that question or even explaining the difference in other cases can give us po<a id="_idTextAnchor114" class="calibre6 pcalibre pcalibre1"/>ints on our <span>interview scoreboard.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">Structs are faster than classes because of the way <em class="italic">they are stored in memory</em>. Structs are value types; therefore, they are stored<a id="_idIndexMarker206" class="calibre6 pcalibre pcalibre1"/> in the <strong class="bold">stack</strong>, which also stores local variables and <span>function parameters.</span></p>
			<p class="calibre3">On the other hand, classes are reference types, and they are stored indirectly in the <strong class="bold">heap</strong>. The<a id="_idIndexMarker207" class="calibre6 pcalibre pcalibre1"/> heap is used to store dynamically <span>allocated objects.</span></p>
			<p class="calibre3">The stack is faster than the heap because it is organized more predictably, and I/O operations are <span>performed faster.</span></p>
			<p class="calibre3">It is important to say that the performance difference is not significant. We should first choose the proper data structure according to our needs. Only if we encounter performance issues should we consider <span>optimizing it.</span></p>
			<p class="calibre3">Classes and structs are extremely important topics in iOS development. We meet these data structures daily, and knowing them well is crucial to writing compelling and <span>great code.</span></p>
			<p class="calibre3">But in coding, data<a id="_idIndexMarker208" class="calibre6 pcalibre pcalibre1"/> structures<a id="_idIndexMarker209" class="calibre6 pcalibre pcalibre1"/> are often created upon other data structures. That’s the case <span>with arrays.</span></p>
			<p class="calibre3">Let’s make sure we have a complete understanding of how arrays work <span>in Swift.</span></p>
			<h1 id="_idParaDest-86" class="calibre5"><a id="_idTextAnchor115" class="calibre6 pcalibre pcalibre1"/>Answering questions about Swift array</h1>
			<p class="calibre3">Unlike many other <a id="_idIndexMarker210" class="calibre6 pcalibre pcalibre1"/>data structures, arrays are considered tricky. On the one hand, arrays are great to store a collection of data and are valuable in many widespread use cases, such as managing lists of objects and entities. On the other hand, we need to know their strengths and weakness to use <span>them effectively.</span></p>
			<p class="calibre3">Interviewers like to ask questions about arrays that check our more profound knowledge about how they <span>work internally.</span></p>
			<p class="calibre3">Questions such as, “<em class="italic">How do you declare an array?</em>” are not that common because it is given that an iOS developer knows how to create <span>an array.</span></p>
			<p class="calibre3">So, what are exciting interview questions <span>about arrays?</span></p>
			<p class="calibre3">Usually, questions about arrays focus on pros and cons, memory management, and <span>data manipulation.</span></p>
			<p class="calibre3">Let’s start with <span>the advantages<a id="_idTextAnchor116" class="calibre6 pcalibre pcalibre1"/>.</span></p>
			<h2 id="_idParaDest-87" class="calibre7">“Please li<a id="_idTextAnchor117" class="calibre6 pcalibre pcalibre1"/>st the Swift array advantages”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">Swift arrays have s<a id="_idIndexMarker211" class="calibre6 pcalibre pcalibre1"/>everal advantages that make them useful. If a developer is unaware of these advantages, an array might not be the correct data structure to use. It’s essential to remember that for every advan<a id="_idTextAnchor118" class="calibre6 pcalibre pcalibre1"/>tage, there may also be <span>a disadvantage.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">There are several advantages <span>to arrays:</span></p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Easy element access by index</strong>: Elements can be retrieved or modified quickly by providing the index number of the <span>desired element</span></li>
				<li class="calibre11"><strong class="bold">Type-safety</strong>: An array can hold only an element from a <span>pre-defined type</span></li>
				<li class="calibre11"><strong class="bold">Built-in operations</strong>: Arrays have many actions, such as adding, removing, filtering, sorting, <span>and more</span></li>
			</ul>
			<p class="calibre3">Remember, questions such as these are the foundation for many more to follow, such as “<em class="italic">What are the use cases for arrays?</em>” or “<em class="italic">List the disadvantages of arrays.</em>” Diving into the material <a id="_idIndexMarker212" class="calibre6 pcalibre pcalibre1"/>can help prepare you for any <span>unexpected surprises.</span></p>
			<h2 id="_idParaDest-88" class="calibre7">“<a id="_idTextAnchor119" class="calibre6 pcalibre pcalibre1"/>How to remove duplicates from an array?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">Unlike the <strong class="source-inline">Set</strong> data structure, a Swift array can contain duplicate items. The question tests our ability to <a id="_idIndexMarker213" class="calibre6 pcalibre pcalibre1"/>manipulate an array of data and discuss the solution with the interviewer. There are several ways to solve that, and showing some of them will give the interviewer the feeling that we can manip<a id="_idTextAnchor120" class="calibre6 pcalibre pcalibre1"/>ulate the data from <span>different directions.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">Let’s see the <span>possible solutions.</span></p>
			<h3 class="calibre9">Solution #1</h3>
			<p class="calibre3">The simplest way to remove <a id="_idIndexMarker214" class="calibre6 pcalibre pcalibre1"/>duplicate elements is to convert the array to <strong class="source-inline">Set</strong> and then back to the array. <strong class="source-inline">Set</strong> is a data structure that cannot contain duplicates, and converting the array to <strong class="source-inline">Set</strong> removes these <a id="_idTextAnchor121" class="calibre6 pcalibre pcalibre1"/>duplicates. Let’s see that <span>in action:</span></p>
			<pre class="source-code">
let arrayWithDuplicates = [1, 2, 3, 3, 4, 5, 5]let arrayWithNoDuplicates = Array(Set(arrayWithDuplicates))</pre>
			<p class="calibre3">This simple and elegant code snippet will work great! But for some interviewers, doing that may seem <span>like “cheating.”</span></p>
			<p class="calibre3">Remember that converting to a <strong class="source-inline">Set</strong> may <em class="italic">disrupt the order</em> of the items, so if the order is important, this may not be the <span>best solution.</span></p>
			<p class="calibre3">So, it is better to make clear that we have additional solutions to <span>the problem.</span></p>
			<h3 class="calibre9">Solution #2</h3>
			<p class="calibre3">Another solution would be to build a new array<a id="_idTextAnchor122" class="calibre6 pcalibre pcalibre1"/> and<a id="_idTextAnchor123" class="calibre6 pcalibre pcalibre1"/> add items only if they do <span>not exist:</span></p>
			<pre class="source-code">
var newArray: [Int] = []for number in array {
    if ! newArray.contains(number) {
        newArray.append(number)
   }
}</pre>
			<p class="calibre3">While this solution will work, it is<a id="_idIndexMarker215" class="calibre6 pcalibre pcalibre1"/> considered a <span><strong class="bold">brute-force</strong></span><span> solution.</span></p>
			<p class="callout-heading">What is a “brute force” solution?</p>
			<p class="callout">A brute-force solution is an algorithm that relies on sheer computational power to solve a problem rather than using a cleverer approach. This can often be a simple and straightforward approach, but it can also be very time-consuming and may not be the most efficient solution for more <span>significant problems.</span></p>
			<p class="calibre3">One way to make the <a id="_idIndexMarker216" class="calibre6 pcalibre pcalibre1"/>loop more efficient is to use <strong class="source-inline">Set</strong> to check whether the item already exists, instead of <span>using </span><span><strong class="source-inline">arr<a id="_idTextAnchor124" class="calibre6 pcalibre pcalibre1"/>ay.contains()</strong></span><span>:</span></p>
			<pre class="source-code">
var newArray: [Int] = []var newAddedItems = Set&lt;Int&gt;()
for number in array {
    if ! newAddedItems.contains(number) {
        newArray.append(number)
        newAddedItems.insert(number)
    }
}</pre>
			<p class="calibre3">Unlike the array’s <strong class="source-inline">contains</strong> method, the <strong class="source-inline">contains</strong> method of <strong class="source-inline">Set</strong> has an average time complexity of <strong class="source-inline">O(1)</strong>, which would improve <span>our answer.</span></p>
			<h3 class="calibre9">Solution #3</h3>
			<p class="calibre3">A more elegant way is to use the <a id="_idIndexMarker217" class="calibre6 pcalibre pcalibre1"/>array’s <span><strong class="bold">filter</strong></span><span> method:</span></p>
			<pre class="source-code">
let numbers = [1, 2, 3, 3, 4, 5, 5]let uniqueNumbers = numbers.filter { number in
    numbers.firstIndex(of: number) == numbers.lastIndex
        (of: number)
}</pre>
			<p class="calibre3">Generally, we should always prefer the filter method over looping elements. The filter method is easier to read and more efficient because of native optimizations of the Swift language (we don’t need <a id="_idIndexMarker218" class="calibre6 pcalibre pcalibre1"/>to get into details during the interview, even though I admit it <span>is fascinating).</span></p>
			<h2 id="_idParaDest-89" class="calibre7"><a id="_idTextAnchor125" class="calibre6 pcalibre pcalibre1"/>“How do you implement a queue us<a id="_idTextAnchor126" class="calibre6 pcalibre pcalibre1"/>ing an array?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">This is a simple<a id="_idIndexMarker219" class="calibre6 pcalibre pcalibre1"/> question if we know what a <strong class="bold">queue</strong> means in <a id="_idIndexMarker220" class="calibre6 pcalibre pcalibre1"/>computer science and the basic array <span>manipulation methods.</span></p>
			<p class="calibre3">These are the reasons why this question is relatively popular. It demonstrates our understanding of the basic concepts of a queue and the gener<a id="_idTextAnchor127" class="calibre6 pcalibre pcalibre1"/>al trade-off<a id="_idTextAnchor128" class="calibre6 pcalibre pcalibre1"/>s when using an array for <span>that task.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">To create a queue using an array, we should start by creating a <strong class="source-inline">Queue</strong> struct with basic methods, such as <strong class="source-inline">isEmpty</strong>, <strong class="source-inline">count</strong>, <strong class="source-inline">enqueue</strong>, <span>and </span><span><strong class="source-inline">dequeue</strong></span><span>.</span></p>
			<p class="calibre3">The <strong class="source-inline">Queue</strong> struct contains an underline array, and we can use the <strong class="source-inline">append</strong> and <strong class="source-inline">removeFirst</strong> array methods to execute the queue’s basic functionality. Let’s see an example <span>of that:</span></p>
			<pre class="source-code">
struct Queue&lt;Element&gt; {    private var array: [Element] = []
    var isEmpty: Bool {
        return array.isEmpty
    }
    var count: Int {
        return array.count
    }
    mutating func enqueue(_ element: Element) {
        array.append(element)
    }
    mutating func dequeue() -&gt; Element? {
        return array.isEmpty ? nil : array.removeFirst()
    }
}</pre>
			<p class="calibre3">Don’t be scared. There’s no need to memorize <span>that solution!</span></p>
			<p class="calibre3">The best thing to<a id="_idIndexMarker221" class="calibre6 pcalibre pcalibre1"/> do is improve our understanding of queues and remem<a id="_idTextAnchor129" class="calibre6 pcalibre pcalibre1"/>ber the <strong class="source-inline">append()</strong> and <strong class="source-inline">removeFirst()</strong> <span>array methods.</span></p>
			<p class="calibre3">It is better to practice once or twice to ensure we nail this question the <span>first time.</span></p>
			<h2 id="_idParaDest-90" class="calibre7">“How do you create a new array by map<a id="_idTextAnchor130" class="calibre6 pcalibre pcalibre1"/>ping the elements of an existing<a id="_idTextAnchor131" class="calibre6 pcalibre pcalibre1"/> array in Swift?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">Aside from<a id="_idIndexMarker222" class="calibre6 pcalibre pcalibre1"/> searching arrays, an iOS developer also needs to know how to manipulate and transform data from one data structure to another. This capability is not only for arrays but also dictionaries <span>and sets.</span></p>
			<p class="calibre3">Transforming or<a id="_idIndexMarker223" class="calibre6 pcalibre pcalibre1"/> mapping data is a common practice in development, especiall<a id="_idTextAnchor132" class="calibre6 pcalibre pcalibre1"/>y in the world of <strong class="bold">combine</strong> and <span><strong class="bold">reactive programming</strong></span><span>.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">We can use the <strong class="source-inline">map</strong> method to map an array to a new one. The map method takes a closure as an argument and, for each element, returns a new value. That way, the map method produces a new array with <span>new values.</span></p>
			<p class="calibre3">Let’s see a basic map method that takes an array of integers and returns a new array by doubling <span>its values:</span></p>
			<pre class="source-code">
let array = [1, 2, 3, 4, 5]let doubledArray = array.map { element in return element * 2
}</pre>
			<p class="calibre3">After the loop has<a id="_idIndexMarker224" class="calibre6 pcalibre pcalibre1"/> ended,  the array contains the [2, 4, 6, 8, <span>10] values.</span></p>
			<p class="calibre3">An even more elegant way to use a map is with a Swift feature called <strong class="bold">implicit closure parameter syntax</strong>. Using <a id="_idIndexMarker225" class="calibre6 pcalibre pcalibre1"/>that feature, we can create even shorter and more <span>readable code:</span></p>
			<pre class="source-code">
let doubledArray = array.map { $0 * 2 }</pre>			<p class="calibre3"><strong class="source-inline">$0</strong> represents the first argument in the closure, and there’s no need for the <strong class="source-inline">return</strong> keyword, making the statement look <span>even shorter!</span></p>
			<p class="calibre3">We can see that arrays are fundamental in Swift and iOS development, playing a major in data storage, states, API interfaces, and many more cases where we need to handle collections. Manipulating arrays elegantly and efficiently is something that interviewers like <span>to test!</span></p>
			<p class="calibre3">Now, we are <a id="_idIndexMarker226" class="calibre6 pcalibre pcalibre1"/>done with simple data structures and will move on to serialize them <span>with Codable.</span></p>
			<h1 id="_idParaDest-91" class="calibre5"><a id="_idTextAnchor133" class="calibre6 pcalibre pcalibre1"/>Covering the Codable protocol</h1>
			<p class="calibre3">The <strong class="bold">Codable</strong> protocol is an <a id="_idIndexMarker227" class="calibre6 pcalibre pcalibre1"/>important Swift feature that allows us to <em class="italic">convert serialized data such as a string to a data structure</em> we can <span>work with.</span></p>
			<p class="calibre3">The first thing to know about the Codable protocol is that it combines two other protocols – “Encodable” and “Decodable.” These two protocols help us to convert data <span>both ways.</span></p>
			<p class="calibre3">Data objects (such as structs) need to conform to the Codable protocol so that we can convert them back <span>and forth.</span></p>
			<p class="calibre3">Here’s a simple <span>code snippet:</span></p>
			<pre class="source-code">
struct Person: Codable {    var name: String
    var age: Int
    var address: String
}
let person = Person(name: "John", age: 30, address: "123 Main St.")
let encoder = JSONEncoder()
let data = try encoder.encode(person)
let decoder = JSONDecoder()
let person = try decoder.decode(Person.self, from: data)</pre>
			<p class="calibre3">As we can see in the preceding code block, <strong class="source-inline">Person</strong> conforms to Codable, and t<a id="_idTextAnchor134" class="calibre6 pcalibre pcalibre1"/>herefore, we can convert it to data in <span>both directions.</span></p>
			<p class="calibre3">The second thing we need to know about Codable is that all struct properties must conform <span>to it.</span></p>
			<p class="calibre3">In the preceding code snippet, we can see that <strong class="source-inline">Person</strong> has three properties from the <strong class="source-inline">String</strong> and <strong class="source-inline">Int</strong> types. <strong class="source-inline">String</strong> and <strong class="source-inline">Int</strong> already conform to Codable, so we don’t need to do anything else. However, if we want to add additional custom properties, we need to make <a id="_idIndexMarker228" class="calibre6 pcalibre pcalibre1"/>sure they conform to Codable <span>as well.</span></p>
			<p class="calibre3">The following example adds the <strong class="source-inline">Child</strong> property <span>to </span><span><strong class="source-inline">Person</strong></span><span>:</span></p>
			<pre class="source-code">
struct Person: Codable {    var name: String
    var age: Int
    var address: String
    var children: [Child]
}
struct Child: Codable {
    var name: String
    var age: Int
}</pre>
			<p class="calibre3">The fact that the <strong class="source-inline">Child</strong> struct conforms to Codable makes the <strong class="source-inline">Person</strong> struct also conform <span>to Codable.</span></p>
			<p class="calibre3">Let’s go over <a id="_idIndexMarker229" class="calibre6 pcalibre pcalibre1"/>some questions about the <span>Codable protocol!</span></p>
			<h2 id="_idParaDest-92" class="calibre7">“How do you han<a id="_idTextAnchor135" class="calibre6 pcalibre pcalibre1"/>dle optional properties when using the Codable protocol?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">Optional properties <a id="_idIndexMarker230" class="calibre6 pcalibre pcalibre1"/>are essential when working with Codable because it is helpful in cases where we need to work with APIs. Sometimes (or should I say, often), the returned data may not include all the properties we define in <span>our struct.</span></p>
			<p class="calibre3">Being familiar with how Codable work<a id="_idTextAnchor136" class="calibre6 pcalibre pcalibre1"/>s in common API use cases demonstrates <span>your understanding.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">To handle optional properties, we simply need to declare them as optional using the <strong class="source-inline">?</strong> <span>parameter.</span></p>
			<p class="calibre3">Let’s take the <strong class="source-inline">Person</strong> struct from the <span>previous example:</span></p>
			<pre class="source-code">
struct Person: Codable {    var name: String
    var age: Int?
    var address: String?
}</pre>
			<p class="calibre3">We can see that both the <strong class="source-inline">address</strong> and <strong class="source-inline">age</strong> properties are optional. If we don’t rece<a id="_idTextAnchor137" class="calibre6 pcalibre pcalibre1"/>ive these values in an API response, they will <span>remain nil.</span></p>
			<p class="calibre3">On the other hand, if a value is not marked as optional and no default value is set, an exception will be thrown if the corresponding key is not present in the <span>JSON response.</span></p>
			<h2 id="_idParaDest-93" class="calibre7">“How do you use CodingKeys enumeration to map the keys <a id="_idTextAnchor138" class="calibre6 pcalibre pcalibre1"/>in a JSON object to the properties of a custom data type?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3"><strong class="bold">CodingKeys</strong> enumeration<a id="_idIndexMarker231" class="calibre6 pcalibre pcalibre1"/> allows us to customize the keys <a id="_idIndexMarker232" class="calibre6 pcalibre pcalibre1"/>used <a id="_idIndexMarker233" class="calibre6 pcalibre pcalibre1"/>in the <span><strong class="bold">encoding/decoding</strong></span><span> process.</span></p>
			<p class="calibre3">A good answer about CodingKey shows us that we fully understand how Codable pr<a id="_idTextAnchor139" class="calibre6 pcalibre pcalibre1"/>otocols work and can handle more complex parsing <span>when needed.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">The way Codable maps keys to properties is by using their names. If we take the <strong class="source-inline">Person</strong> struct example, the <strong class="source-inline">name</strong> property will be mapped to the <strong class="source-inline">name</strong> key in the JSON structure because they have an identical <span>key name.</span></p>
			<p class="calibre3">However, we can customize that easily using CodingKey enumeration by defining a <span>custom mapping.</span></p>
			<p class="calibre3">We need to create <strong class="source-inline">enum</strong> under the struct that conforms to CodingKey and define a new <span>mapping value.</span></p>
			<p class="calibre3">Look at the <span>following example:</span></p>
			<pre class="source-code">
struct Person: Codable {    var name: String
    var age: Int
    var address: String
    enum CodingKeys: String, CodingKey {
        case name = "full_name"
        case age
        case address
    }
}</pre>
			<p class="calibre3">According to our code snippet, the <strong class="source-inline">Person</strong> struct has a <strong class="source-inline">name</strong> property, but that property is now mapped to a <strong class="source-inline">full_name</strong> key that will appear in <span>the JSON.</span></p>
			<p class="calibre3">Here’s the JSON with the <span><strong class="source-inline">full_name</strong></span><span> key:</span></p>
			<pre class="source-code">
{  "full_name": "Avi Tsadok",
  "age": 42,
  "address": "Hamargalit Street
}</pre>
			<p class="calibre3">Using CodingKeys helps us go through different naming between our structs and the data we need to parse. However, CodingKeys doesn’t help when converting one data type to<a id="_idIndexMarker234" class="calibre6 pcalibre pcalibre1"/> another. In that case, we have a decoder. Let’s see an<a id="_idIndexMarker235" class="calibre6 pcalibre pcalibre1"/> interview question explicitly related <span>to that.</span></p>
			<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor140" class="calibre6 pcalibre pcalibre1"/>“How can you convert a formatted date string to a date object in Codable?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">When working<a id="_idIndexMarker236" class="calibre6 pcalibre pcalibre1"/> with APIs, there’s no way of representing a date value other than with <strong class="source-inline">String</strong> <span>or </span><span><strong class="source-inline">Double</strong></span><span>.</span></p>
			<p class="calibre3">If we want a struct that contains a date value, we need a way to convert the <strong class="source-inline">Double</strong> or <strong class="source-inline">String</strong> value to a <span>date object.</span></p>
			<p class="calibre3">We need to understand that these kinds of use cases are <span>not rare.</span></p>
			<p class="calibre3">There are more examples where we need to convert a value we have in a JSON object to another type we have in our struct. Here are some of <span>these examples:</span></p>
			<ul class="calibre10">
				<li class="calibre11">Converting a JSON value <span>to enum.</span></li>
				<li class="calibre11">Creating <span>nested objects</span></li>
				<li class="calibre11">Handling default values in the case of <span>optional properties</span></li>
			</ul>
			<p class="calibre3">Ultimately, parsing API responses is a common and important responsibilit<a id="_idTextAnchor141" class="calibre6 pcalibre pcalibre1"/>y for iOS developers, and proficiency in this area <span>is essential.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">We use several features to convert a string-based date to a date object. The first is CodingKey to map the keys and properties, as we learned in our previous question. Second, initialize the <strong class="source-inline">using init(from decoder: Decoder)</strong> struct, and finally, use <strong class="source-inline">DateFormatter</strong> to convert the string to a <span>date object.</span></p>
			<p class="calibre3">Let’s see an <a id="_idIndexMarker237" class="calibre6 pcalibre pcalibre1"/>example. This is the <strong class="source-inline">Person</strong> <span>properties list:</span></p>
			<pre class="source-code">
struct Person: Codable {    var name: String
    var age: Int
    var address: Address
    var birthday: Date
    enum CodingKeys: String, CodingKey {
        case name
        case age
        case address
        case birthday
    }
    enum Address: String, Codable {
        case home
        case work
    }</pre>
			<p class="calibre3">And this is the <strong class="source-inline">init(from decoder: </strong><span><strong class="source-inline">Decoder)</strong></span><span> function:</span></p>
			<pre class="source-code">
init(from decoder: Decoder) throws {    let container = try decoder.container(keyedBy:CodingKeys.self)
    name = try container.decode(String.self,forKey: .name)
    age = try container.decode(Int.self, forKey: .age)
    address = try container.decode(Address.self,forKey: .address)
    // Decode birthday using a custom date formatter
    let dateFormatter = DateFormatter()dateFormatter.dateFormat = 
    "yyyy-MM-dd"
    if let birthdayString = try? container.decode(String.self, forKey: 
    .birthday) {
        birthday = dateFormatter.date(from:birthdayString) ?? Date()
        } else {
        birthday = Date</pre>
			<p class="calibre3">This is a lengthy<a id="_idIndexMarker238" class="calibre6 pcalibre pcalibre1"/> piece of code <span>worth mentioning!</span></p>
			<p class="calibre3">During an interview, it’s important to provide a detailed explanation of how to implement the features that were mentioned earlier in <span>this section.</span></p>
			<p class="calibre3"><strong class="source-inline">init(from:)</strong> is called when we want to create a struct based on <span>serialized data.</span></p>
			<p class="calibre3">With this method, we can enter the keys container of the received data and map them to the struct properties. This provides us complete flexibility when parsing more complex <span>data structures.</span></p>
			<p class="calibre3">One important note about Codable before we move one is that, technically, we don’t “have” to use Codable in our projects. There are other solutions to parse and serialize objects and structs. But in modern Swift development, Codable is a major player in API management and data storage; therefore, it is a must topic for interviews, and we need to ensure we are <span>fully prepared.</span></p>
			<p class="calibre3">The Codable protocol is a great match for structs, yet it’s not the only option to manage complex data<a id="_idIndexMarker239" class="calibre6 pcalibre pcalibre1"/> structures. Dictionaries are a flexible method of organizing data of diverse types and structures, and they are often utilized <span>in interviews.</span></p>
			<h1 id="_idParaDest-95" class="calibre5"><a id="_idTextAnchor142" class="calibre6 pcalibre pcalibre1"/>Preparing for dictionary- and set-related interview questions</h1>
			<p class="calibre3">Dictionaries and sets <a id="_idIndexMarker240" class="calibre6 pcalibre pcalibre1"/>are both highly effective data structures that enable fast storage, retrieval, and data manipulation. In particular, dictionaries offer the ability to store data using a key-value format, and they also serve as the foundation to encode and decode complex <span>data structures.</span></p>
			<p class="calibre3">As an iOS developer, there are some use cases where we can use dictionaries in <span>our projects:</span></p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Quick lookup</strong>: Dictionaries <a id="_idIndexMarker241" class="calibre6 pcalibre pcalibre1"/>are excellent to save and retrieve data quickly, since they use key-value to store data. This makes dictionaries ideal to save user accounts, lists<a id="_idTextAnchor143" class="calibre6 pcalibre pcalibre1"/> of settings, cache data, and <span>so on.</span></li>
				<li class="calibre11"><strong class="bold">Counting and frequency tracking</strong>: When the dictionary key represents the item’s type, and the value is the number of instances of that type, we can use it to track the frequency of wo<a id="_idTextAnchor144" class="calibre6 pcalibre pcalibre1"/>rds, items, and <span>so on.</span></li>
				<li class="calibre11"><strong class="bold">Encoding and decoding complex data structures</strong>: Dictionaries are so flexible that we can store almost any data structure. Moreover, dictionaries are in the form of JSON, so they are suitable to encode and decode API requests <span>and responses.</span></li>
				<li class="calibre11"><strong class="bold">Configuration data</strong>: The key-value<a id="_idTextAnchor145" class="calibre6 pcalibre pcalibre1"/> nature of dictionaries makes them ideal to store <span>configuration </span><span><a id="_idIndexMarker242" class="calibre6 pcalibre pcalibre1"/></span><span>data.</span></li>
			</ul>
			<p class="calibre3">Try to think of these use cases as a basis for interview questions about dictionaries. Knowing the primary dictionary’s advantages and usage can easily help us pass <span>dictionary-related questions.</span></p>
			<p class="calibre3">Sets are similar to dictionaries in the sense that they are both effective ways to store and retrieve data quickly. However, sets do not use the key-value structure as dictionaries do. Instead, they are lists of unique values that can be accessed with a time complexity of <strong class="source-inline">O(1)</strong>, which makes them very efficient data structures in so many <span>use cases.</span></p>
			<p class="calibre3">In fact, it is more appropriate to compare sets to arrays. If we do not need our list of items to be sorted or include duplicates, sets are a superior choice to arrays in <span>most cases.</span></p>
			<p class="calibre3">Just like dictionaries, let’s look at some set <span>use cases:</span></p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Removing duplicates from an array</strong>: Do you remember the example of using sets to r<a id="_idTextAnchor146" class="calibre6 pcalibre pcalibre1"/>emove duplicates from an <a id="_idTextAnchor147" class="calibre6 pcalibre pcalibre1"/>array? This is a classic application <span>of sets.</span></li>
				<li class="calibre11"><strong class="bold">Fast membership testing</strong>: Sets help determine whether a particular value has already been used. The <strong class="source-inline1">contains</strong> function in sets is much more efficient than an array and can be helpful in <span>many situations.</span></li>
				<li class="calibre11"><strong class="bold">Relationships between entities</strong>: Sets are an ideal data structure to create relationships between two entities, such as <strong class="source-inline1">User</strong> and <strong class="source-inline1">Product</strong>, because they do not require<a id="_idIndexMarker243" class="calibre6 pcalibre pcalibre1"/> sorting or duplicates. This is why sets are the default choice for “to-many” relationships in <span>core data.</span></li>
			</ul>
			<p class="calibre3">Now,<a id="_idTextAnchor148" class="calibre6 pcalibre pcalibre1"/> we look at some interview questions related to sets <span>an<a id="_idTextAnchor149" class="calibre6 pcalibre pcalibre1"/>d dictionaries.</span></p>
			<h2 id="_idParaDest-96" class="calibre7"><a id="_idTextAnchor150" class="calibre6 pcalibre pcalibre1"/>“Can you use a dictionary to store configuration data?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">As previously<a id="_idIndexMarker244" class="calibre6 pcalibre pcalibre1"/> mentioned, dictionaries are a valuable tool to store key-value pairs of data, and configuration data is a common use case for this data structure. This question involves creating a “configuration manager” class that utilizes a dictionary as its primary data structure and designing an interface to store and retrieve values from the dictionary. The task combines multiple coding skills, including creating a class and implementing a dictionary <span>data structure.</span></p>
			<p class="callout-heading">And here’s a great tip!</p>
			<p class="callout">Generally speaking, as an iOS developer, this is a pattern we meet in our day-to-day work and, therefore, <span>in interviews.</span></p>
			<p class="callout">Let’s go over the <span>pattern again:</span></p>
			<p class="callout">- Decide the data structure suitable for <span>the task</span></p>
			<p class="callout">- Encapsulate the data structure within <span>a class</span><a id="_idTextAnchor151" class="calibre6 pcalibre pcalibre1"/></p>
			<p class="callout">- Design and create a simple interface to work with th<a id="_idTextAnchor152" class="calibre6 pcalibre pcalibre1"/>at <span>data structure</span></p>
			<p class="callout">Following these guidelines is t<a id="_idTextAnchor153" class="calibre6 pcalibre pcalibre1"/>he key to <span>many answers!</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">Here is a great code<a id="_idIndexMarker245" class="calibre6 pcalibre pcalibre1"/> example to store configuration data in <span>a dictionary:</span></p>
			<pre class="source-code">
class Configuration {    static let shared = Configuration()
    private var values: [String: Any] = [:]
    func setValue(_ value: Any, forKey key: String) {
        values[key] = value
    }
    func value(forKey key: String) -&gt; Any? {
        return values[key]
    }
}
// Setting configuration values
Configuration.shared.setValue("Dark", forKey: "theme")
Configuration.shared.setValue(true, forKey: "enable_notifications")</pre>
			<p class="calibre3">Looking at the code, we can see the three principles I mentioned – a data structure (dictionary), a<a id="_idIndexMarker246" class="calibre6 pcalibre pcalibre1"/> wrapping class (<strong class="source-inline">Configuration</strong>), and an interface (<strong class="source-inline">setValue()</strong> and <strong class="source-inline">value()</strong>). That would be a <span>perfect answer.</span></p>
			<h2 id="_idParaDest-97" class="calibre7">“How do you use the filter method to s<a id="_idTextAnchor154" class="calibre6 pcalibre pcalibre1"/>elect a subs<a id="_idTextAnchor155" class="calibre6 pcalibre pcalibre1"/>et of key-value pairs from a dictionary based on a condition?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">This question <a id="_idIndexMarker247" class="calibre6 pcalibre pcalibre1"/>tests our ability to manipulate dictionary data. To do that, we need to accomplish two tasks – <em class="italic">iterate</em> the dictionary values and create a <em class="italic">new dictionary</em> for some of the values according to <span>a condition.</span></p>
			<p class="calibre3">This operation is helpful in many different types of programs, as it allows you to focus only on the key-value pairs relevant to a particular task. For instance, you might use it to select only the key-value pairs for students who received an “A” grade o<a id="_idTextAnchor156" class="calibre6 pcalibre pcalibre1"/>n a test, or only the key-value pairs for words used frequently in <span>a text.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">There are several ways to tackle this question – the <strong class="source-inline">for</strong> loop, filte<a id="_idTextAnchor157" class="calibre6 pcalibre pcalibre1"/>ring, and iterating the <span>dictionary keys.</span></p>
			<h3 class="calibre9">Solution number one – the for loop</h3>
			<p class="calibre3">The for-loop solution iterates the dictionary keys and values and performs a simple <strong class="source-inline">if-then</strong> check to<a id="_idIndexMarker248" class="calibre6 pcalibre pcalibre1"/> fill up a new filtered dictionary, as <span>shown here:</span></p>
			<pre class="source-code">
var wordFrequencies: [String: Int] = ["apple": 4,     "banana": 3, "cherry": 2, "date": 1]
var highFrequencyWords: [String: Int] = [:]
for (word, frequency) in wordFrequencies {
    if frequency &gt;= 3 {
        highFrequencyWords[word] = frequency
    }
}
print(highFrequencyWords)  // prints ["apple": 4, "banana": 3]</pre>
			<p class="calibre3">Remember the syntax to iterate a dictionary using the <span><strong class="source-inline">for</strong></span><span> loop:</span></p>
			<pre class="source-code">
for (key, value) in dictionary {  // code to be executed for each key-value pair
}</pre>
			<p class="calibre3">That will be useful in other questions <span>as well.</span></p>
			<h3 class="calibre9">Solution number two – using the filter() method</h3>
			<p class="calibre3">The <strong class="source-inline">filter</strong> method<a id="_idIndexMarker249" class="calibre6 pcalibre pcalibre1"/> solution is considered much <em class="italic">more elegant</em> than the <strong class="source-inline">for</strong> loop because it is more readable and optimized. Moreover, it combines the two operations (iterating and filtering) into <span>one method.</span></p>
			<p class="calibre3">Let’s see how to perform the same task with a <span>filter method:</span></p>
			<pre class="source-code">
let wordFrequencies: [String: Int] = ["apple": 4,    "banana": 3, "cherry": 2, "date": 1]
let highFrequencyWords = wordFrequencies.filter { $0.value &gt;= 3 }
print(highFrequencyWords)  // prints ["apple": 4, "banana": 3]</pre>
			<p class="calibre3">Look at how much less code we used here. This is how the professionals <span>do it!</span></p>
			<h3 class="calibre9">Solution number three – looping the keys</h3>
			<p class="calibre3">It is not necessary for the condition in the filter to be based on the dictionary’s values; it could also be found <a id="_idIndexMarker250" class="calibre6 pcalibre pcalibre1"/>in the keys. In this case, we would need to iterate through the keys and apply the filter <span>to them.</span></p>
			<p class="calibre3">The following code filters the same dictionary, but this time, it creates a dictionary subset of fruits whose name starts <span>with </span><span><strong class="source-inline">a</strong></span><span>:</span></p>
			<pre class="source-code">
var wordFrequencies: [String: Int] = ["apple": 4,    "banana": 3, "cherry": 2, "date": 1]
var highFrequencyWords: [String: Int] = [:]
for (word, frequency) in wordFrequencies {
    if frequency &gt;= 3 {
        highFrequencyWords[word] = frequency
    }
}
print(aWords)  // prints ["apple": 4]</pre>
			<p class="calibre3">This solution allows us to perform more powerful dictionary filtering for more potential use cases <span>and questions.</span></p>
			<h2 id="_idParaDest-98" class="calibre7">“What is the time complexity of co<a id="_idTextAnchor158" class="calibre6 pcalibre pcalibre1"/>mmon set operations, such as inserting an element or checking for membership?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">The <strong class="bold">time complexity</strong> for<a id="_idIndexMarker251" class="calibre6 pcalibre pcalibre1"/> operations is a popular topic in data <a id="_idIndexMarker252" class="calibre6 pcalibre pcalibre1"/>structures questions, mainly when we <span>discuss sets.</span></p>
			<p class="calibre3">If you are unfamiliar with this term, it’s time to catch up! One of the decisions we make as iOS developers is choosing the proper data structure for the <span>right task.</span></p>
			<p class="calibre3">One of the key advantages of using a set over an array is its operation efficiency, such as inserting an element and checking for membership. Therefore, <a id="_idTextAnchor159" class="calibre6 pcalibre pcalibre1"/>we will choose a set when handling caching, avoiding duplicate items, and <span>so on.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">The time complexity of common set operations is <span>as follows:</span></p>
			<ul class="calibre10">
				<li class="calibre11">Inserting an item into a set has an average time complexity of O(1) and a worst-case time complexity <span>of O(n)</span></li>
				<li class="calibre11">The same goes for checking for membership – the average time complexity of O(1) and the worst-case time complexity <span>of O(n)</span></li>
			</ul>
			<p class="calibre3">Sets can have an average time complexity of O(n) in common operations because there are cases where a set can be clustered, and the time complexity depends on the size of <span>the set.</span></p>
			<p class="calibre3">Ei<a id="_idTextAnchor160" class="calibre6 pcalibre pcalibre1"/>ther way, a set is much more efficient than an array in inserting <span>and checking.</span></p>
			<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor161" class="calibre6 pcalibre pcalibre1"/>“Is it possible to store any type of data in a set collection in Swift?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><span><em class="italic">question important?</em></span></p>
			<p class="calibre3">This question<a id="_idIndexMarker253" class="calibre6 pcalibre pcalibre1"/> evaluates our comprehension <a id="_idIndexMarker254" class="calibre6 pcalibre pcalibre1"/>of Swift’s set data structure and the process of hashing <span>data types.</span></p>
			<p class="calibre3">Working with primitive data types such as <strong class="source-inline">Int</strong> or <strong class="source-inline">Double</strong> is straightforward. But that’s not the case with other types, especially those we define ourselves, such as structs <span>or classes.</span></p>
			<p class="calibre3">As a result, understanding how to <a id="_idIndexMarker255" class="calibre6 pcalibre pcalibre1"/>use the <strong class="bold">Hashable</strong> protocol with a set data structure is crucial for <span>iOS developers.</span></p>
			<p class="calibre3"><em class="italic">What is </em><span><em class="italic">the answer?</em></span></p>
			<p class="calibre3">It is possible to store any type of data in a set collection <em class="italic">as long as it conforms to the Hashable protocol</em>. The Hashable protocol allows custom types to generate a unique value that needs to be stored in set and dictionary <span>data structures.</span></p>
			<p class="calibre3">Let’s see an <a id="_idIndexMarker256" class="calibre6 pcalibre pcalibre1"/>example <a id="_idIndexMarker257" class="calibre6 pcalibre pcalibre1"/>of how to store a struct named <strong class="source-inline">Person</strong> in <span>a set:</span></p>
			<pre class="source-code">
struct Person: Hashable {    var age: Int
    func hash(into hasher: inout Hasher) {
        hasher.combine(age)
    }
}
let newSet: Set&lt;Person&gt; = [Person(age: 21),
    Person(age: 35), Person(age: 49)]</pre>
			<p class="calibre3">It’s crucial to understand the <strong class="source-inline">Hashable</strong> protocol when working with sets and dictionaries in<a id="_idIndexMarker258" class="calibre6 pcalibre pcalibre1"/> Swift, as<a id="_idIndexMarker259" class="calibre6 pcalibre pcalibre1"/> it determines how values and keys are stored in <span>these collections.</span></p>
			<h1 id="_idParaDest-100" class="calibre5"><a id="_idTextAnchor162" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we discussed the importance of data structures and why they are so important in interviews. We covered structs and classes, arrays, the Codable protocol, sets, <span>and dictionaries.</span></p>
			<p class="calibre3">This was a crucial chapter, and we now know so much more about <span>data structures!</span></p>
			<p class="calibre3"> However, that was just a warmup because, in the next chapter, we will go over another critical topic in iOS interviews – nothing less than the Swift <span>language itself.</span></p>
		</div>
	</body></html>