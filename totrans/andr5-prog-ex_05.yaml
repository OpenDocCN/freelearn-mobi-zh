- en: Chapter 5. Detecting Touchscreen Gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the apps we created have used `OnClickListeners` to detect user input.
    However, Android handsets are capable of handling sophisticated touchscreen gestures.
    These inputs are picked up with an `OnTouchListener` and then managed with a `GestureDetector`.
    These detectors and their own listeners are capable of recognizing several of
    the simplest and most commonly used gestures, such as **long presses**, **double-taps**,
    and **flings**. At the heart of all touchscreen events is the `MotionEvent` class,
    which handles the individual elements of a gesture, such as when and where a finger
    is placed or removed from the screen or view. This class provides numerous classes
    for querying these events and, thus, for constructing custom gestures of our own.
  prefs: []
  type: TYPE_NORMAL
- en: To see how to implement gestures in our Ancient Britain app, we will add a feature
    that allows the user to view a small gallery of images within the same `ImageView`
    by swiping the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `GestureDetector` to a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an `OnTouchListener` and an `OnGestureListener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect and refine fling gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the DDMS Logcat to observe the `MotionEvent` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the Logcat filter configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify code with a `SimpleOnGestureListener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `GestureDetector` to an Activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the Manifest to control launch behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide UI elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a splash screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock screen orientation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a GestureDetector to a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Together, `view.GestureDetector` and `view.View.OnTouchListener` are all that
    are required to provide our `ImageView` with gesture functionality. The listener
    contains an `onTouch()` callback that relays each `MotionEvent` to the detector.
    We are going to program the large `ImageView` so that it can display a small gallery
    of related pictures that can be accessed by swiping left or right on the image.
  prefs: []
  type: TYPE_NORMAL
- en: There are two steps to this task as, before we implement our gesture detector,
    we need to provide the data for it to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the gallery data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As this app is for demonstration and learning purposes, and so we can progress
    as quickly as possible, we will only provide extra images for one or two of the
    ancient sites in the project. Here is how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Ancient Britain project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainData.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Either download the project files from the Packt website or find four of your
    own images (around 640 x 480 px). Name them `henge_2`, `henge_3`, `henge_4,` and
    `wall_2` and place them in your `res/drawable` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is all very straightforward, and the code that will accompany it allows
    you to have individual arrays of any length. This is all we need to add to our
    gallery data. Now, we need to code our `GestureDetector` and `OnTouchListener`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GestureDetector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with the `OnTouchListener` that we will define for our `ImageView`, the
    GestureDetector has its own listeners. Here we will use `GestureDetector.OnGestureListener`
    to detect a fling gesture and collect the `MotionEvent` that describe it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to program your `ImageView` to respond to fling gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `DetailActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the following class fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onCreate()` method assigns both the `detector` and `listener` like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beneath this, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beneath the line `detailImage = (ImageView) findViewById(R.id.detail_image);`,
    add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following inner class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before dealing with the errors this generates, add the following field to the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click anywhere on the line registering the error and press *Alt* + *Enter*.
    Then select **Implement Methods**, making sure that you have the **Copy JavaDoc**
    and **Insert @Override** boxes checked.![Adding the GestureDetector](img/B04321_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the `onDown()` method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fill in the `onShowPress()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then fill in the `onFling()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test the project on an emulator or handset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process of gesture detection in the preceding code begins when the `OnTouchListener`
    listener's `onTouch()` method is called. It then passes that `MotionEvent` to
    our gesture detector class, `GalleryGestureDetector`, which monitors motion events,
    sometimes stringing them together and timing them until one of the recognized
    gestures is detected. At this point, we can enter our own code to control how
    our app responds as we did here with the `onDown()`, `onShowPress()`, and `onFling()`
    callbacks. It is worth taking a quick look at these methods in turn.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem, at the first glance, that the `onDown()` method is redundant; after
    all, it's the fling gesture that we are trying to catch. In fact, overriding the
    `onDown()` method and returning `true` from it is essential in all gesture detections
    as all the gestures begin with an `onDown()` event.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the `onShowPress()` method may also appear unclear as it seems
    to do a little more than `onDown()`. As the **JavaDoc** states, this method is
    handy for adding some form of feedback to the user, acknowledging that their touch
    has been received. The Material Design guidelines strongly recommend such feedback
    and here we have raised the view's elevation slightly.
  prefs: []
  type: TYPE_NORMAL
- en: Without including our own code, the `onFling()` method will recognize almost
    any movement across the bounding view that ends in the user's finger being raised,
    regardless of direction or speed. We do not want very small or very slow motions
    to result in action; furthermore, we want to be able to differentiate between
    vertical and horizontal movement as well as left and right swipes. The `MIN_DISTANCE`
    and `OFF_PATH` constants are in pixels and `VELOCITY_THRESHOLD` is in pixels per
    second. These values will need tweaking according to the target device and personal
    preference. The first MotionEvent argument in `onFling()` refers to the preceding
    `onDown()` event and, like any `MotionEvent`, its coordinates are available through
    its `getX()` and `getY()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MotionEvent class contains dozens of useful classes for querying various
    event properties—for example, `getDownTime()`, which returns the time in milliseconds
    since the current `onDown()` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we used `GestureDetector.OnGestureListener` to capture our
    gesture. However, the GestureDetector has three such nested classes, the other
    two being `SimpleOnGestureListener` and `OnDoubleTapListener`. `SimpleOnGestureListener`
    provides a more convenient way to detect gestures as we only need to implement
    those methods that relate to the gestures we are interested in capturing. We will
    shortly edit our Activity so that it implements the `SimpleOnGestureListener`
    instead, allowing us to tidy our code and remove the four callbacks that we do
    not need. The reason for taking this detour, rather than applying the simple listener
    to begin with, was to get to see all of the gestures available to us through a
    gesture listener and demonstrate how useful JavaDoc comments can be, particularly
    if we are new to the framework. For example, take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the GestureDetector](img/B04321_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another very handy tool is the **Dalvik Debug Monitor Server** (**DDMS**), which
    allows us to see what is going on inside our apps while they are running. The
    workings of our gesture listener are a good place to do this as most of its methods
    operate invisibly.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing gesture activity with DDMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To view the workings of our `OnGestureListener` with DDMS, we need to first
    create a tag to identify our messages and then a filter to view them. The following
    steps demonstrate how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `DetailActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the following constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line inside the `onDown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the line `Log.d(DEBUG_TAG, "onShowPress");` to the `onShowPress()` method
    and do the same for each of our `OnGestureDetector` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines to the appropriate clauses in `onFling()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **Android DDMS** pane from the **Android** tab at the bottom of the
    window or by pressing *Alt* + *6*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Viewing gesture activity with DDMS](img/B04321_05_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If **logcat** is not visible, it can be opened with the icon to the right of
    the top-right drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on this drop-down menu and select **Edit Filter Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the dialog as shown in the following screenshot:![Viewing gesture activity
    with DDMS](img/B04321_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now run the project on a handset or emulator and view, in the Logcat,
    which gestures are being triggered and how. Your output should resemble the one
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**DDMS** is an invaluable tool when it comes to debugging our apps and seeing
    what is going on beneath the hood. Once a **Log Tag** has been defined in the
    code, we can then create a **filter** for it so that we see only the messages
    we are interested in. The `Log` class contains several methods to report information
    based on its level of importance. We used `Log.d`, which stands for *debug*. All
    these methods work with the same two parameters: `Log.[method](String tag, String
    message)`. The full list of these methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Log.v`: Verbose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log.d`: Debug'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log.i`: Information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log.w`: Warning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log.e`: Error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log.wtf`: Unexpected error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth noting that most debug messages will be ignored during the packaging
    for distribution except for the verbose messages; thus, it is essential to remove
    them before your final build.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen a little more of the inner workings of our gesture detector and
    listener, we can now strip our code of unused methods by implementing `GestureDetector.SimpleOnGestureListener`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a SimpleOnGestureListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very simple to convert our gesture detector from one class of listener
    to another. All we need to do is change the class declaration and delete the unwanted
    methods. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `DetailActivity` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the class declaration for our gesture detector class to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the `onShowPress()`, `onSingleTapUp()`, `onScroll()`, and `onLongPress()`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is all you need to do to switch to the `SimpleOnGestureListener`. We have
    now successfully constructed and edited a gesture detector to allow the user to
    browse a series of images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will have noticed that there is no `onDoubleTap()` method in the gesture
    listener. Double-taps can, in fact, be handled with the third `GestureDetector`
    listener, `OnDoubleTapListener`, which operates in a very similar way to the other
    two. However, Google, in its UI guidelines, recommends that a long press should
    be used instead, whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to multitouch events, we will take a look at how to attach
    a `GestureDetector` listener to an entire Activity by adding a splash screen to
    our project. In the process, we will also see how to create a Full-Screen Activity
    and how to edit the `Maniftest` file so that our app launches with the splash
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a GestureDetector to an Activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method we have employed so far allows us to attach a `GestureDetector` listener
    to any view or views and this, of course, applies to `ViewGroups` such as `Layouts`.
    There are times when we may want to detect gestures to be applied to the whole
    screen. For this purpose, we will create a splash screen that can be dismissed
    with a long press.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things we need to do before implementing the gesture detector:
    creating a layout and editing the Manifest file so that the app launches with
    our splash screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the splash screen layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main difference between processing gestures for a whole Activity and an
    individual widget, is that we do not need an `OnTouchListener` as we can override
    the Activity''s own `onTouchEvent()`. Here is how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blank Activity from the Project Explorer context menu called `SplashActivity.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Activity wizard should have created an associated XML layout called `activity_splash.xml`.
    Open this and view it using the **Text** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove all the padding properties from the root layout so that it looks similar
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we will need an image to act as the background for our splash screen. If
    you have not downloaded the project files from the Packt website, find an image,
    roughly of the size and aspect of your target device's screen, upload it to the
    project drawable folder, and call it `splash`. The file I used is 480 x 800 px.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ':'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Designing the splash screen layout](img/B04321_05_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Remove the `TextView` that the wizard placed inside the layout and replace
    it with this `ImageView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `TextView` beneath this, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following text property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To save time adding string resources to the `strings.xml` file, enter a hardcoded
    string such as the preceding one and heed the warning from the editor to have
    the string extracted for you like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Designing the splash screen layout](img/B04321_05_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There is nothing in this layout that we have not encountered before. We removed
    all the padding so that our splash image will fill the layout; however, you will
    see from the preview that this does not appear to be the case. We will deal with
    this next in our Java code, but we need to edit our **Manifest** first so that
    the app gets launched with our `SplashActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the Manifest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very simple to configure the `AndroidManifest` file so that an app will
    get launched with whichever Activity we choose; the way it does so is with an
    intent. While we are editing the Manifest, we will also configure the display
    to fill the screen. Simply follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `res/values-v21/styles.xml` file and add the following style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `AndroidManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut-and-paste the `<intent-filter>` element from `MainActivity` to `SplashActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the following properties so that the entire `<activity>` node looks
    similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have encountered **themes** and **styles** before and, here, we took advantage
    of a built-in theme designed for **full screen activities**. In many cases, we
    might have designed a landscape layout here but, as is often the case with splash
    screens, we locked the orientation with the `android:screenOrientation` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `android:configChanges` line is not actually needed here, but is included
    as it is useful to know about it. Configuring any attribute such as this prevents
    the system from automatically reloading the Activity whenever the device is rotated
    or the screen size changed. Instead of the Activity restarting, the `onConfigurationChanged()`
    method is called. This was not needed here as the screen size and orientation
    were taken care of in the previous lines of code and this line was only included
    as a point of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we changed the value of `android:label`. You may have noticed that,
    depending on the screen size of the device you are using, the name of our app
    is not displayed in full on the home screen or apps drawer. In such cases, when
    you want to use a shortened name for your app, it can be inserted here.
  prefs: []
  type: TYPE_NORMAL
- en: With everything else in place, we can get on with adding our gesture detector.
    This is not dissimilar to the way we did this before but, this time, we will apply
    the detector to the whole screen and will be listening for a long press, rather
    than a fling.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GestureDetector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with implementing a gesture detector for the entire Activity here, we
    will also take the final step in configuring our splash screen so that the image
    fills the screen, but maintains its aspect ratio. Follow these steps to complete
    the app splash screen.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SplashActivity` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a `GestureDetector` as we did in the earlier exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onCreate()` method, assign and configure our splash image and gesture
    detector like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, override the Activity''s `onTouchEvent()` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following `SimpleOnGestureListener` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the app on your phone or an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The way a gesture detector is implemented across an entire Activity should be
    familiar by this point, as should the capturing of the long press event. The `ImageView.setScaleType(ImageView.ScaleType)`
    method is essential here; it is a very useful method in general. The `CENTER_CROP`
    constant scales the image to fill the view while maintaining the aspect ratio,
    cropping the edges when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the GestureDetector](img/B04321_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are several similar `ScaleTypes`, such as `CENTER_INSIDE`, which scales
    the image to the maximum size possible without cropping it, and `CENTER`, which
    does not scale the image at all. The beauty of `CENTER_CROP` is that it means
    that we don't have to design a separate image for every possible aspect ratio
    on the numerous devices our apps will end up running on. Provided that we make
    allowances for very wide or very narrow screens by not including essential information
    too close to the edges, we only need to provide a handful of images of varying
    pixel densities to maintain the image quality on large, high-resolution devices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scale type of `ImageView` can be set from within XML with `android:scaleType="centerCrop"`,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: You may have wondered why we did not use the built-in **Full-Screen Activity**
    from the wizard; we could easily have done so. The template code the wizard creates
    for a Full-Screen Activity provides far more features than we needed for this
    exercise. Nevertheless, the template is worth taking a look at, especially if
    you want a fullscreen that brings the status bar and other components into view
    when the user interacts with the Activity.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of this chapter. Not only have we seen how to make
    our apps interact with touch events and gestures, but also how to send debug messages
    to the IDE and make a Full-Screen Activity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter by adding a `GestureDetector` to our project. We then
    edited it so that we could filter out meaningful touch events (swipe right and
    left, in this case). We went on to see how the `SimpleOnGestureListener` can save
    us a lot of time when we are only interested in catching a subset of the recognized
    gestures. We also saw how to use DDMS to pass debug messages during runtime and
    how, through a combination of XML and Java, the status and action bars can be
    hidden and the entire screen be filled with a single view or view group.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how our apps can communicate with the user through the
    various forms of notification the framework provides. We will also see how to
    allow the user to add their own data to the app and configure some settings.
  prefs: []
  type: TYPE_NORMAL
