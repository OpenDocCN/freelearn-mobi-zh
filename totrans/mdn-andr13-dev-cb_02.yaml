- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Creating Screens Using a Declarative UI and Exploring Compose Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用声明式UI创建屏幕并探索Compose原则
- en: Mobile applications require a **User Interface** (**UI**) for user interactions.
    For instance, the old way of creating the UI was imperative in Android. This meant
    having a separate prototype of the application’s UI using unique **Extensible
    Markup Language** (**XML**) layouts and not the same language used to build your
    logic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序需要用户界面（UI）以供用户交互。例如，在安卓中创建UI的旧方式是命令式的。这意味着使用独特的**可扩展标记语言**（XML）布局来创建应用程序UI的单独原型，而不是构建逻辑所使用的相同语言。
- en: However, with Modern Android Development, there is a push to stop using imperative
    programming and start using a declarative way of making the UI, which means developers
    design the UI based on the data received. This design paradigm uses one programming
    language to create an entire application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着现代安卓开发，有一种趋势是停止使用命令式编程，开始使用声明式的方式来制作用户界面，这意味着开发者根据接收到的数据来设计用户界面。这种设计范式使用一种编程语言来创建整个应用程序。
- en: 'It is fair to acknowledge it may seem difficult for new developers to decide
    what to learn when building a UI: the old way of creating views or opting for
    the new Jetpack Compose. However, suppose you’ve built an Android application
    before the Jetpack Compose era.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，对于新开发者来说，在构建用户界面时决定学习什么可能看起来有些困难：是采用旧的方式创建视图，还是选择新的Jetpack Compose。然而，如果你在Jetpack
    Compose时代之前已经构建了一个安卓应用程序。
- en: In such a case, you may already know using XML is a bit tedious, especially
    if your code base is complex. However, utilizing Jetpack Compose as your first
    choice makes work easier. In addition, it simplifies UI development by ensuring
    developers use less code, as they take advantage of the intuitive Kotlin APIs.
    Hence, there is a logical push by new developers when creating views to use Jetpack
    Compose instead of XML.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能已经知道使用XML有点繁琐，尤其是如果你的代码库很复杂。然而，将Jetpack Compose作为首选选择可以使工作变得更简单。此外，它通过确保开发者使用更少的代码来简化UI开发，因为他们利用了直观的Kotlin
    API。因此，新开发者创建视图时倾向于使用Jetpack Compose而不是XML。
- en: However, knowing both can be beneficial since many applications still use XML
    layouts, and you might have to maintain the view but build new ones using Jetpack
    Compose. In this chapter, we will look at Jetpack Compose basics by trying to
    implement small examples using columns, rows, boxes, lazy columns, and more.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解两者可能是有益的，因为许多应用程序仍然使用XML布局，你可能会需要维护视图，但使用Jetpack Compose来构建新的。在本章中，我们将通过尝试使用列、行、盒子、懒列等来实现小型示例来查看Jetpack
    Compose的基础知识。
- en: 'In this chapter, we’ll be covering the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Implementing Android views in Jetpack Compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中实现Android视图
- en: Implementing a scrollable list in Jetpack Compose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中实现可滚动列表
- en: Implementing your first tab layout with a view pager using Jetpack Compose
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jetpack Compose和视图页实现第一个标签布局
- en: Implementing animations in Compose
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Compose中实现动画
- en: Implementing accessibility in Jetpack Compose
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中实现无障碍功能
- en: Implementing declarative graphics using Jetpack Compose
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jetpack Compose实现声明式图形
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two).
    To be able to view all the recipes, you will need to run all the preview functions
    separately. Hence, look for the `@Preview` composable function to view the UI
    created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two)找到。要查看所有食谱，你需要分别运行所有预览函数。因此，寻找`@Preview`可组合函数来查看创建的UI。
- en: Implementing Android views in Jetpack Compose
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中实现Android视图
- en: In every Android application, having a UI element is very crucial. A view in
    Android is a simple building block for a UI. A view ensures users can interact
    with your application through a tap or other motion. This recipe will look at
    different Compose UI elements and see how we can build them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个安卓应用程序中，拥有UI元素非常关键。安卓中的视图是UI的简单构建块。视图确保用户可以通过点击或其他动作与你的应用程序交互。这个食谱将探讨不同的Compose
    UI元素，并查看我们如何构建它们。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create one project that we will re-use for the entire
    chapter, so let’s go ahead and follow the steps in [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014),
    *Getting Started with Modern Android Development Skills*, on how to create your
    first Android project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个项目，我们将在整个章节中重复使用它，所以让我们继续按照[*第 1 章*](B18827_01.xhtml#_idTextAnchor014)，“现代
    Android 开发技能入门”，中的步骤创建你的第一个 Android 项目。
- en: Create a project and call it `Compose Basics`. In addition, we will mostly use
    the **Preview** section to view the UI element we create.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Compose Basics`的项目。此外，我们将主要使用**预览**部分来查看我们创建的 UI 元素。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once you have created the project, follow these steps to build several Compose
    UI elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了项目，请按照以下步骤构建几个 Compose UI 元素：
- en: Inside our project, let us go ahead and create a new package and call it components.
    This is where we will add all the components we create.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目中，让我们继续创建一个新的包，命名为 components。这是我们添加所有创建的组件的地方。
- en: 'Create a Kotlin file and call it `UIComponents.kt`; inside `UIComponent`, go
    ahead and create a composable function, call it `EditTextExample()`, and call
    the `OutlinedTextField()` function; this will prompt you to import the required
    import, which is `androidx.Compose.material.OutlinedTextField`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UIComponents.kt`的 Kotlin 文件；在`UIComponent`内部，继续创建一个可组合函数，命名为`EditTextExample()`，并调用`OutlinedTextField()`函数；这将提示你导入所需的导入，即`androidx.Compose.material.OutlinedTextField`：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you look deep into `OutlineTextField` (see *Figure 2**.1*), you will notice
    the function accepts several inputs, and this is very useful when you need to
    customize your own composable functions.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你深入查看`OutlineTextField`（见*图 2.1*），你会注意到该函数接受几个输入，当你需要自定义自己的可组合函数时，这非常有用。
- en: '![Figure 2.1 – The OutlinedTextField input](img/Figure_2.1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – The OutlinedTextField 输入](img/Figure_2.1.jpg)'
- en: Figure 2.1 – The OutlinedTextField input
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – The OutlinedTextField 输入
- en: For our example, we will not do much with the UI we create and will rather just
    look at how we create them.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们不会对创建的 UI 做太多处理，而是仅仅看看我们是如何创建它们的。
- en: Now, to fully create our `OutlinedTextField()` based on the types of input we
    see it accepts, we can give it a text and color and we can decorate it using a
    `Modifier()`; that is, by giving it specific instructions such as `fillMaxWidth()`,
    which sets the max width. When we say fill, we are simply specifying it should
    be fully filled. We set `.padding(top)` to `16.dp`, which applies additional space
    along each edge of the content in `dp`. It also has a value, which is the value
    to be entered in the `OutlinedTextField`, and an `onValueChange` lambda that listens
    to the input change.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了完全创建基于我们看到的输入类型的`OutlinedTextField()`，我们可以给它一个文本和颜色，并使用`Modifier()`对其进行装饰；也就是说，通过给它特定的指令，例如`fillMaxWidth()`，这设置了最大宽度。当我们说填充时，我们只是指定它应该完全填充。我们将`.padding(top)`设置为`16.dp`，这会在`dp`中为内容的每一边应用额外的空间。它还有一个值，即要输入到`OutlinedTextField`中的值，以及一个`onValueChange`
    lambda，它监听输入变化。
- en: 'We also give our `OutlinedText` some border colors when focused and when not
    focused to reflect the different states. Hence, if you start entering input, the
    box will change color to blue, as specified in the code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为我们的一些`OutlinedText`在聚焦和未聚焦时设置了边框颜色，以反映不同的状态。因此，如果你开始输入，框会变成蓝色，如代码中指定的：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also have another type of `TextField`, which is not outlined, and if you
    compare what `OutlinedTextField` takes in as input, you will notice they are fairly
    similar:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一种类型的`TextField`，它不是轮廓式的，如果你比较`OutlinedTextField`接受的输入，你会注意到它们相当相似：
- en: '[PRE21]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can run the application by adding the Compose functions inside the `@Preview`
    composable function. In our example, we can create `UIElementPreview()`, which
    is a preview function for displaying our UI. In *Figure 2**.2*, the top view is
    `OutlinedTextField`, whereas the second one is a normal `TextField`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在`@Preview`可组合函数内添加 Compose 函数来运行应用程序。在我们的例子中，我们可以创建`UIElementPreview()`，这是一个用于显示我们
    UI 的预览函数。在*图 2.2*中，顶部视图是`OutlinedTextField`，而第二个是普通的`TextField`。
- en: '![Figure 2.2 – OutlinedTextField and TextField](img/Figure_2.2.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – OutlinedTextField 和 TextField](img/Figure_2.2.jpg)'
- en: Figure 2.2 – OutlinedTextField and TextField
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – OutlinedTextField 和 TextField
- en: Now, let’s go ahead and look at button examples. We will look at different ways
    to create buttons with different shapes. If you hover over the `Button()` composable
    function, you will see what it accepts as input, as shown in *Figure 2**.3*.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看按钮的例子。我们将探讨以不同形状创建按钮的不同方法。如果你悬停在 `Button()` 组合函数上，你会看到它接受什么作为输入，如图
    *图 2**.3* 所示。
- en: '![Figure 2.3 – Button input](img/Figure_2.3.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 按钮输入](img/Figure_2.3.jpg)'
- en: Figure 2.3 – Button input
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 按钮输入
- en: In our second example, we will try to create a button with an icon on it. In
    addition, we will add text, which is crucial when creating buttons since we need
    to specify to users what action or what the button will be doing once it is clicked
    on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个例子中，我们将尝试创建一个带有图标按钮。此外，我们还将添加文本，这在创建按钮时至关重要，因为我们需要指定给用户什么动作或按钮在被点击后将执行什么操作。
- en: So, go ahead and create a Compose function in the same Kotlin file and call
    it `ButtonWithIcon()`, and then import the `Button()` composable function.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，请继续在同一个 Kotlin 文件中创建一个名为 `ButtonWithIcon()` 的 Compose 函数，然后导入 `Button()`
    组合函数。
- en: 'Inside it, you will need to import an `Icon()` with `painterResource` input,
    a content description, `Modifier`, and `tint`. We will also need `Text()`, which
    will give our button a name. For our example, we will not use `tint`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，你需要导入一个带有 `painterResource` 输入的 `Icon()`，一个内容描述，`Modifier` 和 `tint`。我们还需要
    `Text()`，这将给我们的按钮一个名字。在我们的例子中，我们不会使用 `tint`：
- en: '[PRE38]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let us also go ahead and create a new composable function and call it `CornerCutShapeButton()`;
    in this example, we will try to create a button with cut corners:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的组合函数，并将其命名为 `CornerCutShapeButton()`；在这个例子中，我们将尝试创建一个带有切角的按钮：
- en: '[PRE52]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let us also go ahead and create a new composable function and call it `RoundCornerShapeButton()`;
    in this example, we will try to create a button with round corners:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的组合函数，并将其命名为 `RoundCornerShapeButton()`；在这个例子中，我们将尝试创建一个带有圆角的按钮：
- en: '[PRE57]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let us also go ahead and create a new composable function and call it `ElevatedButtonExample()`;
    in this example, we will try to create a button with elevation:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的组合函数，并将其命名为 `ElevatedButtonExample()`；在这个例子中，我们将尝试创建一个带有凸起的按钮：
- en: '[PRE65]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When you run the application, you should have an image similar to *Figure 2**.4*;
    the first button after `TextField` is `ButtonWithIcon()`, the second one is `CornerCutShapeButton()`,
    the third is `RoundCornerShapeButton()`, and, lastly, we have `ElevatedButtonExample()`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你应该会有一个类似于 *图 2**.4* 的图像；在 `TextField` 之后的第一按钮是 `ButtonWithIcon()`，第二个是
    `CornerCutShapeButton()`，第三个是 `RoundCornerShapeButton()`，最后一个是 `ElevatedButtonExample()`。
- en: '![Figure 2.4 – The different button types and other UI elements](img/Figure_2.4.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 不同的按钮类型和其他 UI 元素](img/Figure_2.4.jpg)'
- en: Figure 2.4 – The different button types and other UI elements
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 不同的按钮类型和其他 UI 元素
- en: Now, let us look at one last example since we will be using different views
    and styles throughout the book and will learn more in the process. Now, let us
    look at an image view; the `Image()` composable function takes in several inputs,
    as shown in *Figure 2**.5*.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看最后一个例子，因为我们在整本书中将会使用不同的视图和样式，并且在这个过程中我们会学到更多。现在，让我们来看一个图像视图；`Image()`
    组合函数接受几个输入，如图 *图 2**.5* 所示。
- en: '![Figure 2.5 – Different ImageView input types](img/Figure_2.5.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 不同的 ImageView 输入类型](img/Figure_2.5.jpg)'
- en: Figure 2.5 – Different ImageView input types
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 不同的 ImageView 输入类型
- en: 'In our example, `Image()` will only have a painter, which is not nullable,
    meaning you need to provide an image for this composable function, a content description
    for accessibility, and a modifier:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，`Image()` 将只有一个画家，它不是可空的，这意味着你需要为这个组合函数提供一个图像，一个用于辅助功能的文本描述和一个修改器：
- en: '[PRE79]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You can also try to play around with others things, such as adding `RadioButton()`
    and `CheckBox()` elements and customizing them. When you run your application,
    you should have something similar to *Figure 2**.6*.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以尝试玩弄其他东西，比如添加 `RadioButton()` 和 `CheckBox()` 元素并自定义它们。当你运行你的应用程序时，你应该会有类似于
    *图 2**.6* 的东西。
- en: "![Figure 2.6 – Se\uFEFFveral UI components](img/Figure_2.6.jpg)"
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 几个 UI 组件](img/Figure_2.6.jpg)'
- en: Figure 2.6 – Several UI components
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 几个 UI 组件
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Every composable function is annotated with the `@Composable` annotation. This
    annotation tells the Compose compiler that the provided compiler is intended to
    convert the provided data into a UI. It is also important to note each composable
    function name needs to be a noun and not a verb or an adjective, and Google provides
    these guidelines. Any composable function you create can accept parameters that
    enable the app logic to describe or modify your UI.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可组合函数都使用`@Composable`注解。这个注解告诉Compose编译器，提供的编译器旨在将提供的数据转换为UI。同时，需要注意的是，每个可组合函数的名称需要是名词，而不是动词或形容词，谷歌提供了这些指南。您创建的任何可组合函数都可以接受参数，使应用逻辑能够描述或修改您的UI。
- en: We mention the Compose compiler, which means that a compiler is any special
    program that takes the code we wrote, examines it, and translates it into something
    the computer can understand – or machine language.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到Compose编译器，这意味着编译器是任何特殊的程序，它接受我们编写的代码，检查它，并将其转换为计算机可以理解的东西——或者机器语言。
- en: In `Icon()`, `painterResouce` specifies the icon we will be adding to the button,
    the content description helps with accessibility, and the modifier is used to
    decorate our icon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Icon()`中，`painterResouce`指定我们将添加到按钮中的图标，内容描述有助于辅助功能，而修饰符用于装饰我们的图标。
- en: 'We can preview the UI elements we build by adding the `@Preview` annotation
    and adding `showBackground =` `true`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`@Preview`注解并设置`showBackground = true`来预览我们构建的UI元素：
- en: '[PRE88]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`@Preview` is powerful, and we will look at how you can utilize it better in
    future chapters.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Preview`功能强大，我们将在未来的章节中探讨如何更好地利用它。'
- en: Implementing a scrollable list in Jetpack Compose
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中实现可滚动列表
- en: When building Android applications, one thing that we can all agree on is you
    must know how to build a `RecyclerView` to display your data. With our new, modern
    way of building Android applications, if we need to use `RecyclerView`, we can
    use `LazyColumn`, which is similar. In this recipe, we will look at rows, columns,
    and `LazyColumn`, and build a scrollable list using our dummy data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建Android应用程序时，我们都可以同意的一件事是，您必须知道如何构建`RecyclerView`来显示您的数据。使用我们新的现代构建Android应用程序的方式，如果我们需要使用`RecyclerView`，我们可以使用`LazyColumn`，它类似。在这个食谱中，我们将查看行、列和`LazyColumn`，并使用我们的模拟数据构建一个可滚动列表。
- en: In addition, we will be learning some Kotlin in the process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在过程中学习一些Kotlin。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `Compose Basics` project to build a scrollable list;
    hence, to get started, you need to have done the previous recipe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用`Compose Basics`项目来构建一个可滚动列表；因此，要开始，您需要完成之前的食谱。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to build your first scrollable list:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建您的第一个可滚动列表：
- en: Let us go ahead and build our first scrollable list, but first, we need to create
    our dummy data, and this is the item we want to be displayed on our list. Hence,
    create a package called `favoritecity` where our scrollable example will live.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的第一个可滚动列表，但首先，我们需要创建我们的模拟数据，这是我们希望在列表中显示的项目。因此，创建一个名为`favoritecity`的包，我们的可滚动示例将驻留其中。
- en: Inside the `favoritecity` package, create a new data class and call it `City`;
    this will be our dummy data source – `data class` `City ()`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`favoritecity`包内部，创建一个新的数据类，并将其命名为`City`；这将是我们模拟数据源的数据类`data class City()`。
- en: 'Let us model our `City` data class. Make sure you add the necessary imports
    once you have added the annotated values:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的`City`数据类建模。确保您在添加注解值后添加必要的导入：
- en: '[PRE89]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, in our dummy data, we need to create a Kotlin class and call this class
    `CityDataSource`. In this class, we will create a function called `loadCities()`,
    which will return our list of `List<City>`, which we will display in our scrollable
    list. Check the *Technical requirements* section for all the required imports
    to get all the code and images:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的模拟数据中，我们需要创建一个Kotlin类，并将其命名为`CityDataSource`。在这个类中，我们将创建一个名为`loadCities()`的函数，它将返回我们的`List<City>`列表，我们将在可滚动列表中显示它。请查看*技术要求*部分，以获取所有必需的导入以获取所有代码和图像：
- en: '[PRE94]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, we have our dummy data, and it is time to display this on our scrollable
    list. Let’s create a new Kotlin file in our `components` package and call it `CityComponents`.
    In `CityComponents`, we will create our `@``Preview` function:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经有了我们的模拟数据，是时候将其显示在我们的可滚动列表上了。让我们在我们的`components`包中创建一个新的Kotlin文件，并将其命名为`CityComponents`。在`CityComponents`中，我们将创建一个名为`@Preview`的函数：
- en: '[PRE109]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Inside our `@Preview` function, we have another composable function, `CityApp()`;
    inside this function, we will call our `CityList` composable function, which has
    the list as a parameter. In addition, in this composable function, we will call
    `LazyColumn`, and `items` will be `CityCard(cities)`. See the *How it works* section
    for further explanation about `LazyColumn` and `items`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`@Preview`函数内部，我们还有一个组合函数`CityApp()`；在这个函数内部，我们将调用我们的`CityList`组合函数，该函数有一个列表作为参数。此外，在这个组合函数中，我们将调用`LazyColumn`，`items`将是`CityCard(cities)`。请参阅*如何工作*部分以获取关于`LazyColumn`和`items`的进一步解释：
- en: '[PRE114]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Finally, let us construct our `CityCard(city)` composable function:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们构建我们的`CityCard(city)`组合函数：
- en: '[PRE122]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: When you run the `CityCardPreview` composable function, you should have a scrollable
    list, as seen in *Figure 2**.6*.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行`CityCardPreview`组合函数时，你应该有一个可滚动的列表，如图*图2.6*所示。
- en: "![Figure 2.7\uFEFF – A scrollable list of cities](img/Figure_2.7.jpg)"
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 可滚动的城市列表](img/Figure_2.7.jpg)'
- en: Figure 2.7 – A scrollable list of cities
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 可滚动的城市列表
- en: How it works…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In Kotlin, a list has two types, **immutable** and **mutable**. Immutable lists
    are items that cannot be modified, whereas mutable lists are items in the list
    that can be modified. To define a list, we can say a list is a generic ordered
    collection of elements, and these elements can be in the form of integers, strings,
    images, and so on, which is mostly informed by the type of data we want our lists
    to contain. For instance, in our example, we have a string and image helping identify
    our favorite cities by name and image.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，列表有两种类型，**不可变**和**可变**。不可变列表是无法修改的项目，而可变列表是可以修改的列表中的项目。为了定义列表，我们可以说列表是一个泛型有序元素集合，这些元素可以是整数、字符串、图像等，这主要取决于我们希望列表包含的数据类型。例如，在我们的例子中，我们有一个字符串和图像，通过名称和图像帮助我们识别我们最喜欢的城市。
- en: In our `City` data class, we use `@StringRes`, and `@DrawableRes` in order to
    just pull this directly from the `res` folders for `Drawable` and `String` easily,
    and they also represent the ID for the images and string.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`City`数据类中，我们使用`@StringRes`和`@DrawableRes`来直接从`res`文件夹中轻松获取`Drawable`和`String`，它们也代表了图像和字符串的ID。
- en: We created `CityList` and annotated it with the composable function and declared
    the list of city objects as our parameter in the function. A scrollable list in
    Jetpack Compose is made using `LazyColumn`. The main difference between `LazyColumn`
    and `Column` is that when using `Column`, you can only display small items, as
    Compose loads all items at once.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`CityList`，并使用组合函数进行注释，声明城市对象列表作为函数的参数。在Jetpack Compose中，可滚动的列表是通过`LazyColumn`实现的。`LazyColumn`与`Column`的主要区别在于，使用`Column`时，你只能显示少量项目，因为Compose一次加载所有项目。
- en: In addition, a column can only hold fixed composable functions, whereas `LazyColumn`,
    as the name suggests, loads the content as required on demand, making it good
    for loading more items when needed. In addition, `LazyColumn` comes with a scrolling
    ability inbuilt, which makes work easier for developers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，列只能持有固定的组合函数，而`LazyColumn`，正如其名所示，按需加载内容，这使得在需要时加载更多项目变得很好。此外，`LazyColumn`内置了滚动功能，这使得开发者的工作更加容易。
- en: 'We also created a composable function, `CityCard`, where we import the `Card()`
    element from Compose. A card contains content and actions about a single object;
    in our example, for instance, our card has an image and the name of the city.
    A `Card()` element in Compose has the following inputs in its parameter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个组合函数`CityCard`，其中我们导入了来自Compose的`Card()`元素。卡片包含关于单个对象的内容和操作；在我们的例子中，例如，我们的卡片有一个图像和城市的名称。Compose中的`Card()`元素在其参数中有以下输入：
- en: '[PRE146]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This means you can easily model your card to the best fitting; our card has
    padding and elevation, and the scope has a column. In this column, we have an
    image and text, which helps describe the image for more context.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以轻松地将卡片模型调整为最佳匹配；我们的卡片有填充和提升，范围有一个列。在这个列中，我们有一个图像和文本，这有助于描述图像以提供更多上下文。
- en: See also
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There is more to learn about lists and grids in Compose; you can use this link
    to learn more: [https://developer.android.com/jetpack/compose/lists](https://developer.android.com/jetpack/compose/lists).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在Compose中还有更多关于列表和网格要学习的内容；你可以使用此链接了解更多信息：[https://developer.android.com/jetpack/compose/lists](https://developer.android.com/jetpack/compose/lists)。
- en: Implementing your first tab layout with a view pager using Jetpack Compose
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jetpack Compose和视图页实现第一个标签布局
- en: In Android development, having a slide between pages is very common, with a
    significant use case being onboarding or even when you are trying to display specific
    data in a tabbed, carousel way. In this recipe, we will build a simple horizontal
    pager in Compose and see how we can utilize the new knowledge to build better
    and more modern Android apps.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 开发中，页面之间有滑动是非常常见的，一个重要的用例是在引导页或甚至当你尝试以标签页、轮播的方式显示特定数据时。在这个菜谱中，我们将构建一个简单的水平分页器在
    Compose 中，并看看我们如何利用新知识来构建更好、更现代的 Android 应用。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we will build a horizontal pager that changes colors when selected
    to show the state is selected. We will look into states in [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and Using Hilt*, for better understanding.
    Open the `Compose Basics` project to get started.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建一个水平分页器，当被选中时改变颜色以显示选中状态。我们将深入研究状态，在 [*第 3 章*](B18827_03.xhtml#_idTextAnchor137)，*在
    Jetpack Compose 中处理 UI 状态和使用 Hilt*，以获得更好的理解。打开 `Compose Basics` 项目开始。
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to build your tab carousel:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建你的标签页轮播：
- en: 'Add the following pager dependencies to `build.gradle(Module:app)`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下分页器依赖项添加到 `build.gradle(Module:app)`：
- en: '[PRE147]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Jetpack Compose offers **Accompanist**, a group of libraries that aims to support
    it with commonly required features by developers – for instance, in our case,
    the pager.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 提供了 **Accompanist**，这是一组旨在通过开发者常用的功能来支持它的库 – 例如，在我们的案例中，就是分页器。
- en: 'In the same project from previous recipes, let’s create a package and call
    it `pagerexample`; inside it, create a Kotlin file and call it `CityTabExample`;
    inside this file, create a composable function and call it `CityTabCarousel`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前菜谱的相同项目中，让我们创建一个包并命名为 `pagerexample`；在其内部，创建一个 Kotlin 文件并命名为 `CityTabExample`；在这个文件中，创建一个可组合函数并命名为
    `CityTabCarousel`：
- en: '[PRE150]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now, let us go ahead and build our `CityTabCarousel`; for our example, we will
    create a dummy list of pages with our cities from the previous project:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续构建我们的 `CityTabCarousel`；在我们的例子中，我们将创建一个包含来自先前项目的城市的模拟页面列表：
- en: '[PRE152]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'We will need to change the color of the button based on the state, and to do
    this; we need to use `LocalContext`, which provides the context we can use. We
    will also need to create a `var pagerState = rememberPagerState()`, which will
    remember our pager state, and finally, when clicked, we will need to move to the
    next city in our pager, which will be very helpful. Hence, go ahead and add the
    following to the `CityTabCarousel` composable function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要根据状态改变按钮的颜色，为此，我们需要使用 `LocalContext`，它提供了我们可以使用的上下文。我们还需要创建一个 `var pagerState
    = rememberPagerState()`，这将记住我们的分页器状态，最后，当点击时，我们需要将分页器移动到下一个城市，这将非常有帮助。因此，继续向 `CityTabCarousel`
    可组合函数中添加以下内容：
- en: '[PRE161]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Now, let’s create the `Column` element and add our `ScrollableTabRow()` composable
    function:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `Column` 元素并添加我们的 `ScrollableTabRow()` 可组合函数：
- en: '[PRE164]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Add `Text()` and `TabHeader()` for `HorizontalPager`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `HorizontalPager` 添加 `Text()` 和 `TabHeader()`：
- en: '[PRE187]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Please download the entire code for this recipe by following the link provided
    in the *Technical requirements* section to add all the required code. Finally,
    run the `@Preview` function, and your app should look like *Figure 2**.8*.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请通过在 *技术要求* 部分提供的链接下载此菜谱的完整代码，以添加所有必需的代码。最后，运行 `@Preview` 函数，你的应用应该看起来像 *图 2**.8*。
- en: '![Figure 2.8 – Tabs with cities](img/Figure_2.8.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 城市标签页](img/Figure_2.8.jpg)'
- en: Figure 2.8 – Tabs with cities
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 城市标签页
- en: How it works…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用原理…
- en: Accompanist comes with some significant libraries – for example, System UI Controller,
    AppCompact Compose Theme Adapter, Material Theme Adapter, Pager, Drawable Painter,
    and Flow Layouts, just to mention a few.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Accompanist 包含一些重要的库 – 例如，系统 UI 控制器、AppCompact Compose 主题适配器、Material 主题适配器、分页器、Drawable
    绘画器和流布局，仅举几例。
- en: The `ScrollableTabRow()` that we use inside `Column` in the `CityTabCarousel`
    function contains a row of tabs and helps display an indicator underneath the
    currently focused or selected tab. In addition, as the name suggests, it enables
    scrolling and you do not have to implement further scrolling tooling. It also
    places its tab offsets at the starting edge, and you can quickly scroll tabs that
    are off-screen, as you will see when you run the `@Preview` function and play
    around with it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `CityTabCarousel` 函数中的 `Column` 内部使用的 `ScrollableTabRow()` 包含一排标签，并有助于显示当前聚焦或选中的标签下的指示器。此外，正如其名称所暗示的，它允许滚动，你不需要实现额外的滚动工具。它还将其标签偏移放置在起始边缘，你可以快速滚动屏幕外的标签，正如你在运行
    `@Preview` 函数并与之互动时所看到的那样。
- en: When we invoke `remember()`, in Compose, this means we keep any value consistent
    across recomposition. Compose provides this function to help us store single objects
    in memory. When we trigger our application to run, `remember()` stores the initial
    value. As the word means, it simply retains the value and returns the stored value
    so that the composable function can use it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Compose 中调用 `remember()` 时，这意味着我们保持任何值在重新组合时的一致性。Compose 提供这个函数来帮助我们存储单个对象到内存中。当我们触发应用程序运行时，`remember()`
    存储初始值。正如其词义，它只是保留值并返回存储的值，以便可组合函数可以使用它。
- en: Furthermore, whenever the stored value changes, you can update it, and the `remember()`
    function will keep it. The next time we trigger another run in our app and recomposition
    occurs, the `remember()` function will provide the latest stored value.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每当存储的值发生变化时，你可以更新它，而 `remember()` 函数将保持它。下次我们在应用程序中触发另一个运行并发生重新组合时，`remember()`
    函数将提供最新的存储值。
- en: 'You will also notice our `MutableList<String>` is indexed at each position,
    and we do this to check which is selected. It is within this Lambda that we call
    `TabHeader` and showcase the selected tab pages. `forEachIndexed` performs the
    given action on each element, providing a sequential index of elements. We also
    ensure when a user clicks on a specific tab, we are on the right page:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到我们的 `MutableList<String>` 在每个位置都有索引，我们这样做是为了检查哪个被选中了。正是在这个 Lambda 中，我们调用
    `TabHeader` 并展示选中的标签页。`forEachIndexed` 对每个元素执行给定的操作，并提供元素的顺序索引。我们还确保当用户点击特定的标签时，我们处于正确的页面：
- en: '[PRE204]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '`HorizontalPager` is a horizontally scrolling layout that allows our users
    to flip between items from left to right. It takes in several inputs, but we supply
    it with the count, state, and modifier to decorate it in our use case. In the
    Lambda, we display text – in our example, showing which page we are on, which
    helps when navigating, as shown in *Figure 2**.9*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalPager` 是一个水平滚动的布局，允许我们的用户从左到右翻动项目。它接受几个输入，但我们根据我们的用例提供计数、状态和修饰符。在
    Lambda 中，我们显示文本 – 在我们的例子中，显示我们所在的页面，这有助于导航，如 *图 2**.9* 所示：'
- en: '![Figure 2.9 – HorizontalPager](img/Figure_2.9.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – HorizontalPager](img/Figure_2.9.jpg)'
- en: Figure 2.9 – HorizontalPager
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – HorizontalPager
- en: Our `TabHeader` composable function has a `Box()`; a box in Jetpack Compose
    will always size itself to fit the content, and this is subject to the specified
    constraints. In our example, we decorate our `Box` with the selectable modifier,
    which configures components to be selectable as part of a mutually exclusive group,
    allowing each item to be selected only once at any given time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `TabHeader` 可组合函数有一个 `Box()`；在 Jetpack Compose 中，一个盒子将始终根据内容大小调整自身，并且这受指定约束的限制。在我们的例子中，我们用可选择的修饰符装饰我们的
    `Box`，这配置组件作为互斥组的一部分可被选择，允许在任何给定时间只选择每个项目一次。
- en: Important note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Ensure your target and compile SDK targets 33\. In addition, you will notice
    that most Accompanist’s libraries are experimental, which means they can change.
    There is debate on whether to use this in your production, so you should always
    consult your team on these APIs. To see the entire list of libraries supported
    by Accompanist, you can follow this link: [https://github.com/google/accompanist](https://github.com/google/accompanist).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的目标和编译 SDK 目标为 33。此外，你会注意到 Accompanist 的大多数库都是实验性的，这意味着它们可能会改变。关于是否在生产中使用这些库存在争议，因此你应该始终咨询你的团队关于这些
    API。要查看 Accompanist 支持的库的完整列表，你可以点击以下链接：[https://github.com/google/accompanist](https://github.com/google/accompanist)。
- en: Implementing animations in Compose
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Compose 中实现动画
- en: Animation in Android is the process of adding motion effects to views. This
    can be achieved using images, text, or even starting a new screen where the transition
    is noticeable using motion effects. Animations are vital in Modern Android Development
    since modern UIs are more interactive and adaptive to smoother experiences, and
    users like them.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的动画是将运动效果添加到视图的过程。这可以通过使用图像、文本，甚至启动一个新的屏幕来实现，在那里使用运动效果可以明显地注意到过渡。在现代Android开发中，动画至关重要，因为现代UI更加交互式，更能适应更平滑的体验，用户也喜欢它们。
- en: Furthermore, applications these days are rated based on how great their UI and
    user experiences are, hence the need to ensure your application is modern and
    robust. In this example, we will build a collapsing toolbar, an animation that
    is widely used in the Android world.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如今的应用程序评分是基于它们的UI和用户体验有多好，因此确保你的应用程序现代化且稳健是必要的。在这个例子中，我们将构建一个可折叠的工具栏，这是一种在Android世界中广泛使用的动画。
- en: Getting ready
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `Compose` `Basics` project.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 `Compose` `基础` 项目。
- en: How to do it…
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will be building a collapsing toolbar in this recipe; there are other great
    animations you can now build utilizing the power of Compose. The power is in your
    hands:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将构建一个可折叠的工具栏；现在你可以利用Compose的力量构建其他出色的动画。力量在你手中：
- en: We will not need to add any dependency to this recipe. We already have everything
    in place. So, let us go ahead and create a new package and add a Kotlin file,
    `collapsingtoolbar`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要为此食谱添加任何依赖项。我们已经有了一切所需。因此，让我们继续创建一个新的包并添加一个Kotlin文件，名为`collapsingtoolbar`。
- en: 'Inside the Kotlin file, go ahead and create a new composable function, `CollapsingTool``BarExample()`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kotlin文件中，继续创建一个新的可组合函数，`CollapsingTool``BarExample()`：
- en: '[PRE205]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'We will have all our needed composable functions in a box; you can refer to
    the previous recipe to refresh your memory on that. We will also need to define
    the height at which we will start to collapse our view, and this can be based
    on preference; for our example, we can set `height` to `260.dp`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要的所有可组合函数都将放在一个框中；你可以参考之前的食谱来刷新你的记忆。我们还需要定义我们将开始折叠视图的高度，这可以基于个人喜好；在我们的例子中，我们可以将`height`设置为`260.dp`：
- en: '[PRE207]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Let us go ahead and add more composable functions with dummy text data to display
    once we scroll our content. We can assume this app is used for reading information
    about the cities we display:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续添加更多的可组合函数，并使用虚拟文本数据来显示，一旦我们滚动内容。我们可以假设这个应用程序用于阅读我们显示的城市的信息：
- en: '[PRE209]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: In our `CollapsingHeader` function, we pass in the scroll state and the `headerHeight`
    a float. We decorate Box with a `Modifier.graphicLayer`, where we set a parallax
    effect to make it look good and presentable.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`CollapsingHeader`函数中，我们传递滚动状态和`headerHeight`一个浮点数。我们用`Modifier.graphicLayer`装饰Box，其中我们设置了一个视差效果，使其看起来很好，并且易于展示。
- en: 'We also ensure we add a `Brush()` and set the colors we need, and specify where
    it should start:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还确保添加了一个`Brush()`并设置了所需的颜色，并指定了它应该开始的位置：
- en: '[PRE227]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '`FactsAboutNewYork` is not a complex composable function, just dummy text;
    then, finally, in `ToolBar`, we utilize `AnimatedVisibility` and declare our `enter`
    and `exit` transition:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FactsAboutNewYork`不是一个复杂的可组合函数，只是虚拟文本；然后，最后，在`ToolBar`中，我们利用`AnimatedVisibility`并声明我们的`enter`和`exit`过渡：'
- en: '[PRE239]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Finally, run the `@Preview` function, and you will have a collapsible toolbar,
    which brings a smooth experience to your UI. In addition, get the entire code
    in the *Technical* *requirements* section.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行`@Preview`函数，你将得到一个可折叠的工具栏，这将为你的UI带来平滑的体验。此外，在*技术要求*部分获取完整的代码。
- en: '![Figure 2.10 – A collapsible toolbar](img/Figure_2.10.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 一个可折叠的工具栏](img/Figure_2.10.jpg)'
- en: Figure 2.10 – A collapsible toolbar
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 一个可折叠的工具栏
- en: How it works…
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In Modern Android Development, the Jetpack Compose library has many animation
    APIs that are available as composable functions. For example, you might want your
    image or text to fade in and fade out.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Android开发中，Jetpack Compose库提供了许多作为可组合函数可用的动画API。例如，你可能希望你的图片或文本淡入淡出。
- en: Hence, if you are animating appearance and disappearance, which can be for an
    image, a text, a radio group, a button, and so on, you can use `AnimatedVisibility`
    to achieve this. Otherwise, if you are swapping content based on the state and
    want your content to crossfade, you can use `CrossFade`, or `AnimatedContent`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你正在动画化出现和消失，这可以是一个图像、文本、单选组、按钮等等，你可以使用`AnimatedVisibility`来实现这一点。否则，如果你正在根据状态交换内容，并希望你的内容交叉淡入淡出，你可以使用`CrossFade`或`AnimatedContent`。
- en: '`val headerHeight = with(LocalDensity.current) { height.toPx() }` provides
    density, which will be used to transform the DP and SP units, and we can use this
    when we provide the DP, which we will do and later convert into the body of our
    layout.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`val headerHeight = with(LocalDensity.current) { height.toPx() }` 提供密度，该密度将用于转换
    DP 和 SP 单位，当我们在提供 DP 时可以使用它，我们将在稍后将其转换为布局的主体。'
- en: You can call the modifier and use `graphicsLayer` to update any of the content
    above it independently to minimize invalidated content. In addition, `graphicsLayer`
    can be used to apply effects such as scaling, rotation, opacity, shadow, or even
    clipping.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用修饰符并使用 `graphicsLayer` 独立更新其上方的任何内容，以最小化无效内容。此外，`graphicsLayer` 可以用于应用缩放、旋转、不透明度、阴影或甚至裁剪等效果。
- en: '`translationY = -scroll.value.toFloat() / 2f` basically sets the vertical pixel
    offset of the layer relative to its top bound. The default value is always zero,
    but you can customize this to fit your needs. We also ensure the gradient is only
    applied to wrapping the title in `startY = 1 * headerHeight /` `5`.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`translationY = -scroll.value.toFloat() / 2f`基本上设置了层相对于其顶部边界的垂直像素偏移。默认值始终为零，但您可以自定义以适应您的需求。我们还确保渐变只应用于包裹标题，`startY
    = 1 * headerHeight /` `5`。'
- en: '`EnterTransition` defines how the target content should appear; a target here
    can be an image, a text, or even a radio group. On the other hand, `ExitTransition`
    defines how the initial target content should disappear when exiting the app or
    navigating away.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnterTransition` 定义目标内容应该如何出现；这里的“目标”可以是图像、文本，甚至是单选组。另一方面，`ExitTransition`
    定义当退出应用程序或导航离开时，初始目标内容应该如何消失。'
- en: '`AnimatedContent` offers `slideIntoContainer` and `slideOutOfContainer`, and
    it animates its content as it changes based on the target state, which is remarkable.
    In addition, you can also encapsulate a transition and make it reusable by creating
    a class that holds all your animation values and an `Update()`function, which
    returns an instance of that class.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimatedContent` 提供 `slideIntoContainer` 和 `slideOutOfContainer`，并根据目标状态的变化动画化其内容，这是非常出色的。此外，您还可以通过创建一个包含所有动画值和
    `Update()` 函数的类来封装转换并使其可重用，该函数返回该类的实例。'
- en: 'It is also fair to mention that, as with the old ways of doing animation in
    Android using `MotionLayout`, there are many ways to do transitions in Jetpack
    Compose. For instance, in *Table 2.1*, you will see the different types of transitions:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，值得一提的是，与使用 `MotionLayout` 在 Android 中进行动画的旧方法一样，在 Jetpack Compose 中有许多进行转换的方法。例如，在
    *表 2.1* 中，您将看到不同类型的转换：
- en: '| **EnterTransition** | **ExitTransition** |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| **EnterTransition** | **ExitTransition** |'
- en: '| `SlideIn` | `SlideOut` |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `SlideIn` | `SlideOut` |'
- en: '| `FadeIn` | `FadeOut` |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `FadeIn` | `FadeOut` |'
- en: '| `SlideInHorizontally` | `SlideOutHorizontally` |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `SlideInHorizontally` | `SlideOutHorizontally` |'
- en: '| `SlideInVertically` | `SlideOutVertically` |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `SlideInVertically` | `SlideOutVertically` |'
- en: '| `ScaleIn` | `SlaceOut` |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `ScaleIn` | `SlaceOut` |'
- en: '| `ExpandIn` | `ShrinkOut` |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `ExpandIn` | `ShrinkOut` |'
- en: '| `ExpandHorizontally` | `ShinkHorizontally` |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `ExpandHorizontally` | `ShinkHorizontally` |'
- en: '| `ExpandVertically` | `ShrinkVertically` |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `ExpandVertically` | `ShrinkVertically` |'
- en: Table 2.1 – A table showing different types of transitions
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1 – 一个显示不同类型转换的表格
- en: In addition, you can add your own custom animation effects in Jetpack Compose
    beyond the already built-in enter and exit animations by simply accessing the
    elemental transition instance via the `transition` property inside the content
    lambda for `AnimatedVisibility`. You will also notice any animation states that
    have been added.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过通过 `AnimatedVisibility` 内容 lambda 中的 `transition` 属性访问基本转换实例，在 Jetpack
    Compose 中添加您自己的自定义动画效果，而无需超出已内置的进入和退出动画。您还会注意到已添加的任何动画状态。
- en: Implementing accessibility in Jetpack Compose
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 中实现可访问性
- en: As we build Android applications, we need to always have accessibility in the
    back of our minds because this makes technology inclusive and ensures all people
    with special needs are considered as we build applications.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建 Android 应用程序时，我们需要始终牢记可访问性，因为这使技术更具包容性，并确保在构建应用程序时考虑到所有有特殊需求的人。
- en: Accessibility should be a team effort. If well handled, the advantages include
    having more people using your application. An accessible application is better
    for everyone. You also reduce the risk of being sued.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性应该是团队的努力。如果处理得当，优势包括有更多人使用您的应用程序。可访问的应用程序对每个人来说都更好。您还可以降低被起诉的风险。
- en: There are different types of disabilities, such as visual, aural, and motor
    impairments. If you open your **Accessibility** settings, you will see the different
    options that people with disabilities use on their devices.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的残疾类型，如视觉、听觉和运动障碍。如果你打开你的 **无障碍** 设置，你会看到残疾人士在其设备上使用的不同选项。
- en: Getting ready
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Like previous recipes, we will continue using our sample project from previous
    recipes; you do not need to install anything.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前的食谱，我们将继续使用之前食谱中的示例项目；你不需要安装任何东西。
- en: How to do it…
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For this recipe, we will describe the visual elements, which are very vital:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将描述视觉元素，这些元素非常重要：
- en: 'By default, when we add an `Image` function, you might notice that it has two
    parameters, a painter for the image and a content description to visually describe
    the element:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，当我们添加一个 `Image` 函数时，你可能会注意到它有两个参数，一个是用于图像的绘制器，另一个是用于视觉描述元素的文本描述：
- en: '[PRE245]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'When you set the content description to `null`, you indicate to the Android
    framework that this element does not have an associated action or state. So, let’s
    go ahead and update all our content descriptions:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将内容描述设置为 `null` 时，你向 Android 框架表明此元素没有关联的动作或状态。所以，让我们继续更新我们所有的内容描述：
- en: '[PRE246]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Make sure you add the string to the `string` `res` folder:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将字符串添加到 `string` `res` 文件夹：
- en: '[PRE252]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: So, go ahead and ensure you add a content description for every image that requires
    it.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，请确保为需要它的每个图像添加内容描述。
- en: 'In Compose, you can easily indicate whether a text is a heading by specifying
    this in the modifier and using semantics to show that that is a heading. Let’s
    add that in our decorated text:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Compose 中，你可以通过在修饰符中指定并使用语义来显示这是一个标题，轻松地指示一个文本是否是标题。让我们在我们的装饰文本中添加这个：
- en: '[PRE253]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Finally, we can go ahead and compile, run, and test whether our application
    is accessible by following this link on how to manually test using talkback or
    using automated testing: [https://developer.android.com/guide/topics/ui/accessibility/testing](https://developer.android.com/guide/topics/ui/accessibility/testing).'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以继续编译、运行并测试我们的应用程序是否可以通过以下链接手动测试（使用 talkback 或使用自动化测试）来验证无障碍性：[https://developer.android.com/guide/topics/ui/accessibility/testing](https://developer.android.com/guide/topics/ui/accessibility/testing)。
- en: How it works…
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Jetpack Compose is built with accessibility in mind; that is to say, material
    components such as `RadioButton`, `Switch`, and so on have their size internally
    set, but only when these components can receive user interactions.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 是考虑到无障碍性构建的；也就是说，如 `RadioButton`、`Switch` 等材料组件在内部设置了大小，但仅当这些组件可以接收用户交互时。
- en: Furthermore, any screen element that users can click on or interact with should
    be large enough for reliable interaction. A standard format sets these elements
    to a size of at least `48dp` for `width` and `height`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何用户可以点击或与之交互的屏幕元素应该足够大，以便可靠地交互。标准格式将这些元素设置为至少 `48dp` 的宽度和高度。
- en: 'For example, `Switch` has its `onCheckChanged` parameter set to a non-null
    value, including width and height of at least `48dp`; we would have `CheckableSwitch()`,
    and `NonCheckableSwitch()`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Switch` 的 `onCheckChanged` 参数被设置为非空值，包括至少 `48dp` 的宽度和高度；我们将有 `CheckableSwitch()`
    和 `NonCheckableSwitch()`：
- en: '[PRE258]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Once you have implemented accessibility in your applications, you can easily
    test it by installing analysis tools from the Play Store – `uiautomatorviewer`
    and `lint`. You can also automate your tests using Espresso or Roboelectric to
    check for accessibility support.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的应用程序中实现了无障碍功能，你可以通过从 Play Store 安装分析工具（`uiautomatorviewer` 和 `lint`）来轻松测试它。你也可以使用
    Espresso 或 Roboelectric 自动化你的测试，以检查无障碍支持。
- en: Finally, you can manually test your application for accessibility support by
    going to **Settings**, then to **Accessibility**, and selecting **talkback**.
    This is found at the top of the screen; then press **On** or **Off** to turn the
    talkback functionality on or off. Then, navigate to the dialog confirmation, and
    click **OK** to confirm permission.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过转到 **设置**，然后转到 **无障碍**，并选择 **talkback** 来手动测试你的应用程序的无障碍支持。这位于屏幕顶部；然后按
    **开启** 或 **关闭** 来打开或关闭 talkback 功能。然后，导航到对话框确认，点击 **确定** 以确认权限。
- en: There’s more…
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多…
- en: There is more regarding accessibility that developers should consider as they
    build their applications, including a state with which they should be able to
    notify their users on whether a `Switch` button has been selected. This ensures
    their applications support accessibility and are up to standard.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者构建应用程序时，他们应该考虑更多关于可访问性的问题，包括一个状态，使他们能够通知用户是否已选择`Switch`按钮。这确保了他们的应用程序支持可访问性并符合标准。
- en: Implementing declarative graphics using Jetpack Compose
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jetpack Compose实现声明式图形
- en: In Android development, your application might have a different need, and this
    need might be building your own custom graphics for an intended purpose. This
    is very common in many stable and large Android code bases. The essential part
    of any custom view is its appearance. Furthermore, custom drawing can be a very
    easy or complex task based on the needs of your application. In Modern Android
    Development, Jetpack Compose makes it easier to work with custom graphics simply
    because the demand is immense. For example, many applications may need to control
    what happens on their screen accurately; the use case might be as simple as putting
    a circle on the screen or building more complex graphics to handle known use cases.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，你的应用程序可能有不同的需求，这种需求可能是为了特定目的而构建自己的自定义图形。这在许多稳定的大型Android代码库中非常常见。任何自定义视图的关键部分是其外观。此外，自定义绘图可能是一个非常简单或复杂的任务，这取决于应用程序的需求。在现代Android开发中，Jetpack
    Compose使得处理自定义图形变得更加容易，因为需求巨大。例如，许多应用程序可能需要精确控制屏幕上发生的事情；用例可能简单到在屏幕上放置一个圆，或者构建更复杂的图形来处理已知用例。
- en: Getting ready
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open the `Compose Basics` project to get started with this recipe. You can find
    the entire code in the *Technical* *requirements* section.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Compose Basics`项目开始这个菜谱。你可以在*技术要求*部分找到完整的代码。
- en: How to do it…
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In our project, let us create a new package and call it `circularexample`;
    inside this package, create a Kotlin file and call it `DrawCircleCompose`; inside
    the file, create a `CircleProgressIndicatorExample` composable function. You will
    not need to import anything for now:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，让我们创建一个新的包，命名为`circularexample`；在这个包内部，创建一个Kotlin文件，命名为`DrawCircleCompose`；在文件内部，创建一个`CircleProgressIndicatorExample`可组合函数。目前你不需要导入任何内容：
- en: 'Let us now go ahead and define our composable function. Since, in our example,
    we want to display a tracker in a circle, we need to float to fill in our circle.
    We will also define the colors to help us identify the progress:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续定义我们的可组合函数。由于在我们的例子中，我们想在圆中显示一个跟踪器，我们需要浮动以填充我们的圆。我们还将定义颜色，以帮助我们识别进度：
- en: '[PRE259]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Now, let’s call `Canvas` to draw our arc. We give our circle the size of `200.dp`
    with `8.dp` padding. Where it gets interesting is in `onDraw`. `startAngle` is
    set at `-90`; the start angle is set in degrees to understand it better.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用`Canvas`来绘制我们的弧线。我们给我们的圆设置大小为`200.dp`，并添加`8.dp`的内边距。有趣的部分在于`onDraw`。`startAngle`设置为`-90`；起始角度以度为单位设置，以便更好地理解。
- en: 'The zero represents 3 o’clock, and you can also play around with your start
    angle to see how `-90` translates. The `useCenter` Boolean indicates whether arc
    is to close the center of the bounds. Hence, in our case, we set it to `false`.
    Then, finally, we set the `style`, which can be anything based on our preference:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 零代表3点钟方向，你也可以调整你的起始角度来观察`-90`是如何转换的。`useCenter`布尔值表示是否将弧线闭合到边界中心。因此，在我们的例子中，我们将它设置为`false`。然后，最后，我们设置`style`，这可以根据我们的喜好设置为任何内容：
- en: '[PRE265]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'We have just drawn the first part of the circle; now, we need to draw the progress
    with a `Brush`, which utilizes `linearGradient`:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚画出了圆的第一部分；现在，我们需要用`Brush`绘制进度，它使用`linearGradient`：
- en: '[PRE266]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Finally, our `progress` function tells `sweepAngle` where our progress should
    be based on our tracking abilities:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的`progress`函数告诉`sweepAngle`我们的进度应该基于我们的跟踪能力：
- en: '[PRE277]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Run the `preview` function, and you should see a circular progress indicator
    as in *Figure 2**.11*.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`preview`函数，你应该会看到一个与*图2.11*相同的圆形进度指示器。
- en: '![Figure 2.11 – Showing a circular progress image](img/Figure_2.11.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 显示圆形进度图像](img/Figure_2.11.jpg)'
- en: Figure 2.11 – Showing a circular progress image
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 显示圆形进度图像
- en: Important note
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `Canvas` composable function uses `Canvas` to Compose an object, which,
    in turn, creates and helps manage a view-base Canvas. It is also important to
    mention that Compose makes it easier for developers by maintaining the state and
    creating and freeing any necessary helper objects.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`组合函数使用`Canvas`来组合一个对象，该对象反过来创建并帮助管理基于视图的Canvas。同时，重要的是要提到，Compose通过维护状态和创建及释放任何必要的辅助对象，使开发者更容易使用。'
- en: How it works…
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Generally, `Canvas` allows you to specify an area on the screen where you want
    to draw. In the old way of building Android applications, we also utilized `Canvas`,
    and now in Compose, it is more powerful and valuable.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Canvas`允许你指定屏幕上你想要绘制区域的区域。在旧的Android应用程序构建方式中，我们也使用了`Canvas`，而现在在Compose中，它更加强大和有价值。
- en: '`linearGradient` create a linear gradient with the specified colors along the
    provided start and end coordinates. For our example, we give it simple colors
    that come with the project.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`linearGradient`使用指定的颜色和提供的起始和结束坐标创建一个线性渐变。在我们的示例中，我们提供了项目自带的基本颜色。'
- en: 'The drawing functions have instrumental default parameters that you can use.
    For instance, by default, `drawArc`, as you can see, takes in several inputs:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图函数有一些默认的参数，你可以使用。例如，默认情况下，`drawArc`，如你所见，接受几个输入：
- en: '![Figure 2.12 – Showing what drawArc takes as input](img/Figure_2.12.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 展示drawArc函数的输入](img/Figure_2.12.jpg)'
- en: Figure 2.12 – Showing what drawArc takes as input
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 展示drawArc函数的输入
- en: '`sweepAngle` in our example, which is the size of the arc in the degree that
    is drawn clockwise relative to `startAngle`, returns a function that calculates
    progress. This function can be customized to fit your needs. In our example, we
    pass in a tracker and progress and return a float.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`sweepAngle`，它表示相对于`startAngle`按顺时针方向绘制的弧度大小，返回一个计算进度的函数。这个函数可以根据你的需求进行定制。在我们的示例中，我们传递了一个跟踪器和进度，并返回一个浮点数。
- en: Since we want to fill the circle, we create `cal totalProgress`, which checks
    *progress * 100* divided by the tracker, and we return *360 (circle) * our progress
    divided by 100*. You can customize this function to fit your needs. You can also
    write code to listen to where you are and make the progress move based on your
    input value from a listener you create.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要填充圆形，我们创建`cal totalProgress`，它检查*progress * 100*除以跟踪器，并返回*360 (circle)
    *我们的进度除以100*。你可以根据你的需求定制这个函数。你还可以编写代码来监听你的位置，并根据你创建的监听器的输入值移动进度。
- en: There’s more…
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is more you can do with `Canvas` and custom drawing. One amazing way to
    enhance your knowledge on the topic is to look into old solutions posted on Stack
    Overflow, such as drawing a heart or any other shape, and see whether you can
    do the same in Compose.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用`Canvas`和自定义绘图做更多的事情。一个增强你对这个主题知识的好方法是查看Stack Overflow上发布的旧解决方案，例如绘制一个心形或任何其他形状，并看看你能否在Compose中做到同样的效果。
