- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Screens Using a Declarative UI and Exploring Compose Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile applications require a **User Interface** (**UI**) for user interactions.
    For instance, the old way of creating the UI was imperative in Android. This meant
    having a separate prototype of the application’s UI using unique **Extensible
    Markup Language** (**XML**) layouts and not the same language used to build your
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: However, with Modern Android Development, there is a push to stop using imperative
    programming and start using a declarative way of making the UI, which means developers
    design the UI based on the data received. This design paradigm uses one programming
    language to create an entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is fair to acknowledge it may seem difficult for new developers to decide
    what to learn when building a UI: the old way of creating views or opting for
    the new Jetpack Compose. However, suppose you’ve built an Android application
    before the Jetpack Compose era.'
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, you may already know using XML is a bit tedious, especially
    if your code base is complex. However, utilizing Jetpack Compose as your first
    choice makes work easier. In addition, it simplifies UI development by ensuring
    developers use less code, as they take advantage of the intuitive Kotlin APIs.
    Hence, there is a logical push by new developers when creating views to use Jetpack
    Compose instead of XML.
  prefs: []
  type: TYPE_NORMAL
- en: However, knowing both can be beneficial since many applications still use XML
    layouts, and you might have to maintain the view but build new ones using Jetpack
    Compose. In this chapter, we will look at Jetpack Compose basics by trying to
    implement small examples using columns, rows, boxes, lazy columns, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Android views in Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a scrollable list in Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your first tab layout with a view pager using Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing animations in Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing accessibility in Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing declarative graphics using Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter-two).
    To be able to view all the recipes, you will need to run all the preview functions
    separately. Hence, look for the `@Preview` composable function to view the UI
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Android views in Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every Android application, having a UI element is very crucial. A view in
    Android is a simple building block for a UI. A view ensures users can interact
    with your application through a tap or other motion. This recipe will look at
    different Compose UI elements and see how we can build them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create one project that we will re-use for the entire
    chapter, so let’s go ahead and follow the steps in [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014),
    *Getting Started with Modern Android Development Skills*, on how to create your
    first Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Create a project and call it `Compose Basics`. In addition, we will mostly use
    the **Preview** section to view the UI element we create.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have created the project, follow these steps to build several Compose
    UI elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside our project, let us go ahead and create a new package and call it components.
    This is where we will add all the components we create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Kotlin file and call it `UIComponents.kt`; inside `UIComponent`, go
    ahead and create a composable function, call it `EditTextExample()`, and call
    the `OutlinedTextField()` function; this will prompt you to import the required
    import, which is `androidx.Compose.material.OutlinedTextField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you look deep into `OutlineTextField` (see *Figure 2**.1*), you will notice
    the function accepts several inputs, and this is very useful when you need to
    customize your own composable functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The OutlinedTextField input](img/Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The OutlinedTextField input
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will not do much with the UI we create and will rather just
    look at how we create them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to fully create our `OutlinedTextField()` based on the types of input we
    see it accepts, we can give it a text and color and we can decorate it using a
    `Modifier()`; that is, by giving it specific instructions such as `fillMaxWidth()`,
    which sets the max width. When we say fill, we are simply specifying it should
    be fully filled. We set `.padding(top)` to `16.dp`, which applies additional space
    along each edge of the content in `dp`. It also has a value, which is the value
    to be entered in the `OutlinedTextField`, and an `onValueChange` lambda that listens
    to the input change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also give our `OutlinedText` some border colors when focused and when not
    focused to reflect the different states. Hence, if you start entering input, the
    box will change color to blue, as specified in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have another type of `TextField`, which is not outlined, and if you
    compare what `OutlinedTextField` takes in as input, you will notice they are fairly
    similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can run the application by adding the Compose functions inside the `@Preview`
    composable function. In our example, we can create `UIElementPreview()`, which
    is a preview function for displaying our UI. In *Figure 2**.2*, the top view is
    `OutlinedTextField`, whereas the second one is a normal `TextField`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – OutlinedTextField and TextField](img/Figure_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – OutlinedTextField and TextField
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead and look at button examples. We will look at different ways
    to create buttons with different shapes. If you hover over the `Button()` composable
    function, you will see what it accepts as input, as shown in *Figure 2**.3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Button input](img/Figure_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Button input
  prefs: []
  type: TYPE_NORMAL
- en: In our second example, we will try to create a button with an icon on it. In
    addition, we will add text, which is crucial when creating buttons since we need
    to specify to users what action or what the button will be doing once it is clicked
    on.
  prefs: []
  type: TYPE_NORMAL
- en: So, go ahead and create a Compose function in the same Kotlin file and call
    it `ButtonWithIcon()`, and then import the `Button()` composable function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, you will need to import an `Icon()` with `painterResource` input,
    a content description, `Modifier`, and `tint`. We will also need `Text()`, which
    will give our button a name. For our example, we will not use `tint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us also go ahead and create a new composable function and call it `CornerCutShapeButton()`;
    in this example, we will try to create a button with cut corners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us also go ahead and create a new composable function and call it `RoundCornerShapeButton()`;
    in this example, we will try to create a button with round corners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us also go ahead and create a new composable function and call it `ElevatedButtonExample()`;
    in this example, we will try to create a button with elevation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run the application, you should have an image similar to *Figure 2**.4*;
    the first button after `TextField` is `ButtonWithIcon()`, the second one is `CornerCutShapeButton()`,
    the third is `RoundCornerShapeButton()`, and, lastly, we have `ElevatedButtonExample()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The different button types and other UI elements](img/Figure_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The different button types and other UI elements
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at one last example since we will be using different views
    and styles throughout the book and will learn more in the process. Now, let us
    look at an image view; the `Image()` composable function takes in several inputs,
    as shown in *Figure 2**.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Different ImageView input types](img/Figure_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Different ImageView input types
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, `Image()` will only have a painter, which is not nullable,
    meaning you need to provide an image for this composable function, a content description
    for accessibility, and a modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also try to play around with others things, such as adding `RadioButton()`
    and `CheckBox()` elements and customizing them. When you run your application,
    you should have something similar to *Figure 2**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 2.6 – Se\uFEFFveral UI components](img/Figure_2.6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Several UI components
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every composable function is annotated with the `@Composable` annotation. This
    annotation tells the Compose compiler that the provided compiler is intended to
    convert the provided data into a UI. It is also important to note each composable
    function name needs to be a noun and not a verb or an adjective, and Google provides
    these guidelines. Any composable function you create can accept parameters that
    enable the app logic to describe or modify your UI.
  prefs: []
  type: TYPE_NORMAL
- en: We mention the Compose compiler, which means that a compiler is any special
    program that takes the code we wrote, examines it, and translates it into something
    the computer can understand – or machine language.
  prefs: []
  type: TYPE_NORMAL
- en: In `Icon()`, `painterResouce` specifies the icon we will be adding to the button,
    the content description helps with accessibility, and the modifier is used to
    decorate our icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can preview the UI elements we build by adding the `@Preview` annotation
    and adding `showBackground =` `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`@Preview` is powerful, and we will look at how you can utilize it better in
    future chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a scrollable list in Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building Android applications, one thing that we can all agree on is you
    must know how to build a `RecyclerView` to display your data. With our new, modern
    way of building Android applications, if we need to use `RecyclerView`, we can
    use `LazyColumn`, which is similar. In this recipe, we will look at rows, columns,
    and `LazyColumn`, and build a scrollable list using our dummy data.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will be learning some Kotlin in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `Compose Basics` project to build a scrollable list;
    hence, to get started, you need to have done the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build your first scrollable list:'
  prefs: []
  type: TYPE_NORMAL
- en: Let us go ahead and build our first scrollable list, but first, we need to create
    our dummy data, and this is the item we want to be displayed on our list. Hence,
    create a package called `favoritecity` where our scrollable example will live.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `favoritecity` package, create a new data class and call it `City`;
    this will be our dummy data source – `data class` `City ()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us model our `City` data class. Make sure you add the necessary imports
    once you have added the annotated values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in our dummy data, we need to create a Kotlin class and call this class
    `CityDataSource`. In this class, we will create a function called `loadCities()`,
    which will return our list of `List<City>`, which we will display in our scrollable
    list. Check the *Technical requirements* section for all the required imports
    to get all the code and images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have our dummy data, and it is time to display this on our scrollable
    list. Let’s create a new Kotlin file in our `components` package and call it `CityComponents`.
    In `CityComponents`, we will create our `@``Preview` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside our `@Preview` function, we have another composable function, `CityApp()`;
    inside this function, we will call our `CityList` composable function, which has
    the list as a parameter. In addition, in this composable function, we will call
    `LazyColumn`, and `items` will be `CityCard(cities)`. See the *How it works* section
    for further explanation about `LazyColumn` and `items`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let us construct our `CityCard(city)` composable function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run the `CityCardPreview` composable function, you should have a scrollable
    list, as seen in *Figure 2**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 2.7\uFEFF – A scrollable list of cities](img/Figure_2.7.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – A scrollable list of cities
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kotlin, a list has two types, **immutable** and **mutable**. Immutable lists
    are items that cannot be modified, whereas mutable lists are items in the list
    that can be modified. To define a list, we can say a list is a generic ordered
    collection of elements, and these elements can be in the form of integers, strings,
    images, and so on, which is mostly informed by the type of data we want our lists
    to contain. For instance, in our example, we have a string and image helping identify
    our favorite cities by name and image.
  prefs: []
  type: TYPE_NORMAL
- en: In our `City` data class, we use `@StringRes`, and `@DrawableRes` in order to
    just pull this directly from the `res` folders for `Drawable` and `String` easily,
    and they also represent the ID for the images and string.
  prefs: []
  type: TYPE_NORMAL
- en: We created `CityList` and annotated it with the composable function and declared
    the list of city objects as our parameter in the function. A scrollable list in
    Jetpack Compose is made using `LazyColumn`. The main difference between `LazyColumn`
    and `Column` is that when using `Column`, you can only display small items, as
    Compose loads all items at once.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, a column can only hold fixed composable functions, whereas `LazyColumn`,
    as the name suggests, loads the content as required on demand, making it good
    for loading more items when needed. In addition, `LazyColumn` comes with a scrolling
    ability inbuilt, which makes work easier for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also created a composable function, `CityCard`, where we import the `Card()`
    element from Compose. A card contains content and actions about a single object;
    in our example, for instance, our card has an image and the name of the city.
    A `Card()` element in Compose has the following inputs in its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: This means you can easily model your card to the best fitting; our card has
    padding and elevation, and the scope has a column. In this column, we have an
    image and text, which helps describe the image for more context.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is more to learn about lists and grids in Compose; you can use this link
    to learn more: [https://developer.android.com/jetpack/compose/lists](https://developer.android.com/jetpack/compose/lists).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your first tab layout with a view pager using Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android development, having a slide between pages is very common, with a
    significant use case being onboarding or even when you are trying to display specific
    data in a tabbed, carousel way. In this recipe, we will build a simple horizontal
    pager in Compose and see how we can utilize the new knowledge to build better
    and more modern Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will build a horizontal pager that changes colors when selected
    to show the state is selected. We will look into states in [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and Using Hilt*, for better understanding.
    Open the `Compose Basics` project to get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to build your tab carousel:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following pager dependencies to `build.gradle(Module:app)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Jetpack Compose offers **Accompanist**, a group of libraries that aims to support
    it with commonly required features by developers – for instance, in our case,
    the pager.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same project from previous recipes, let’s create a package and call
    it `pagerexample`; inside it, create a Kotlin file and call it `CityTabExample`;
    inside this file, create a composable function and call it `CityTabCarousel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let us go ahead and build our `CityTabCarousel`; for our example, we will
    create a dummy list of pages with our cities from the previous project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to change the color of the button based on the state, and to do
    this; we need to use `LocalContext`, which provides the context we can use. We
    will also need to create a `var pagerState = rememberPagerState()`, which will
    remember our pager state, and finally, when clicked, we will need to move to the
    next city in our pager, which will be very helpful. Hence, go ahead and add the
    following to the `CityTabCarousel` composable function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create the `Column` element and add our `ScrollableTabRow()` composable
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `Text()` and `TabHeader()` for `HorizontalPager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please download the entire code for this recipe by following the link provided
    in the *Technical requirements* section to add all the required code. Finally,
    run the `@Preview` function, and your app should look like *Figure 2**.8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Tabs with cities](img/Figure_2.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Tabs with cities
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accompanist comes with some significant libraries – for example, System UI Controller,
    AppCompact Compose Theme Adapter, Material Theme Adapter, Pager, Drawable Painter,
    and Flow Layouts, just to mention a few.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScrollableTabRow()` that we use inside `Column` in the `CityTabCarousel`
    function contains a row of tabs and helps display an indicator underneath the
    currently focused or selected tab. In addition, as the name suggests, it enables
    scrolling and you do not have to implement further scrolling tooling. It also
    places its tab offsets at the starting edge, and you can quickly scroll tabs that
    are off-screen, as you will see when you run the `@Preview` function and play
    around with it.
  prefs: []
  type: TYPE_NORMAL
- en: When we invoke `remember()`, in Compose, this means we keep any value consistent
    across recomposition. Compose provides this function to help us store single objects
    in memory. When we trigger our application to run, `remember()` stores the initial
    value. As the word means, it simply retains the value and returns the stored value
    so that the composable function can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, whenever the stored value changes, you can update it, and the `remember()`
    function will keep it. The next time we trigger another run in our app and recomposition
    occurs, the `remember()` function will provide the latest stored value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice our `MutableList<String>` is indexed at each position,
    and we do this to check which is selected. It is within this Lambda that we call
    `TabHeader` and showcase the selected tab pages. `forEachIndexed` performs the
    given action on each element, providing a sequential index of elements. We also
    ensure when a user clicks on a specific tab, we are on the right page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '`HorizontalPager` is a horizontally scrolling layout that allows our users
    to flip between items from left to right. It takes in several inputs, but we supply
    it with the count, state, and modifier to decorate it in our use case. In the
    Lambda, we display text – in our example, showing which page we are on, which
    helps when navigating, as shown in *Figure 2**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – HorizontalPager](img/Figure_2.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – HorizontalPager
  prefs: []
  type: TYPE_NORMAL
- en: Our `TabHeader` composable function has a `Box()`; a box in Jetpack Compose
    will always size itself to fit the content, and this is subject to the specified
    constraints. In our example, we decorate our `Box` with the selectable modifier,
    which configures components to be selectable as part of a mutually exclusive group,
    allowing each item to be selected only once at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure your target and compile SDK targets 33\. In addition, you will notice
    that most Accompanist’s libraries are experimental, which means they can change.
    There is debate on whether to use this in your production, so you should always
    consult your team on these APIs. To see the entire list of libraries supported
    by Accompanist, you can follow this link: [https://github.com/google/accompanist](https://github.com/google/accompanist).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing animations in Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation in Android is the process of adding motion effects to views. This
    can be achieved using images, text, or even starting a new screen where the transition
    is noticeable using motion effects. Animations are vital in Modern Android Development
    since modern UIs are more interactive and adaptive to smoother experiences, and
    users like them.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, applications these days are rated based on how great their UI and
    user experiences are, hence the need to ensure your application is modern and
    robust. In this example, we will build a collapsing toolbar, an animation that
    is widely used in the Android world.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue using the `Compose` `Basics` project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be building a collapsing toolbar in this recipe; there are other great
    animations you can now build utilizing the power of Compose. The power is in your
    hands:'
  prefs: []
  type: TYPE_NORMAL
- en: We will not need to add any dependency to this recipe. We already have everything
    in place. So, let us go ahead and create a new package and add a Kotlin file,
    `collapsingtoolbar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the Kotlin file, go ahead and create a new composable function, `CollapsingTool``BarExample()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will have all our needed composable functions in a box; you can refer to
    the previous recipe to refresh your memory on that. We will also need to define
    the height at which we will start to collapse our view, and this can be based
    on preference; for our example, we can set `height` to `260.dp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us go ahead and add more composable functions with dummy text data to display
    once we scroll our content. We can assume this app is used for reading information
    about the cities we display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our `CollapsingHeader` function, we pass in the scroll state and the `headerHeight`
    a float. We decorate Box with a `Modifier.graphicLayer`, where we set a parallax
    effect to make it look good and presentable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also ensure we add a `Brush()` and set the colors we need, and specify where
    it should start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FactsAboutNewYork` is not a complex composable function, just dummy text;
    then, finally, in `ToolBar`, we utilize `AnimatedVisibility` and declare our `enter`
    and `exit` transition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run the `@Preview` function, and you will have a collapsible toolbar,
    which brings a smooth experience to your UI. In addition, get the entire code
    in the *Technical* *requirements* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.10 – A collapsible toolbar](img/Figure_2.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – A collapsible toolbar
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Modern Android Development, the Jetpack Compose library has many animation
    APIs that are available as composable functions. For example, you might want your
    image or text to fade in and fade out.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, if you are animating appearance and disappearance, which can be for an
    image, a text, a radio group, a button, and so on, you can use `AnimatedVisibility`
    to achieve this. Otherwise, if you are swapping content based on the state and
    want your content to crossfade, you can use `CrossFade`, or `AnimatedContent`.
  prefs: []
  type: TYPE_NORMAL
- en: '`val headerHeight = with(LocalDensity.current) { height.toPx() }` provides
    density, which will be used to transform the DP and SP units, and we can use this
    when we provide the DP, which we will do and later convert into the body of our
    layout.'
  prefs: []
  type: TYPE_NORMAL
- en: You can call the modifier and use `graphicsLayer` to update any of the content
    above it independently to minimize invalidated content. In addition, `graphicsLayer`
    can be used to apply effects such as scaling, rotation, opacity, shadow, or even
    clipping.
  prefs: []
  type: TYPE_NORMAL
- en: '`translationY = -scroll.value.toFloat() / 2f` basically sets the vertical pixel
    offset of the layer relative to its top bound. The default value is always zero,
    but you can customize this to fit your needs. We also ensure the gradient is only
    applied to wrapping the title in `startY = 1 * headerHeight /` `5`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EnterTransition` defines how the target content should appear; a target here
    can be an image, a text, or even a radio group. On the other hand, `ExitTransition`
    defines how the initial target content should disappear when exiting the app or
    navigating away.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnimatedContent` offers `slideIntoContainer` and `slideOutOfContainer`, and
    it animates its content as it changes based on the target state, which is remarkable.
    In addition, you can also encapsulate a transition and make it reusable by creating
    a class that holds all your animation values and an `Update()`function, which
    returns an instance of that class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also fair to mention that, as with the old ways of doing animation in
    Android using `MotionLayout`, there are many ways to do transitions in Jetpack
    Compose. For instance, in *Table 2.1*, you will see the different types of transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **EnterTransition** | **ExitTransition** |'
  prefs: []
  type: TYPE_TB
- en: '| `SlideIn` | `SlideOut` |'
  prefs: []
  type: TYPE_TB
- en: '| `FadeIn` | `FadeOut` |'
  prefs: []
  type: TYPE_TB
- en: '| `SlideInHorizontally` | `SlideOutHorizontally` |'
  prefs: []
  type: TYPE_TB
- en: '| `SlideInVertically` | `SlideOutVertically` |'
  prefs: []
  type: TYPE_TB
- en: '| `ScaleIn` | `SlaceOut` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExpandIn` | `ShrinkOut` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExpandHorizontally` | `ShinkHorizontally` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExpandVertically` | `ShrinkVertically` |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – A table showing different types of transitions
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can add your own custom animation effects in Jetpack Compose
    beyond the already built-in enter and exit animations by simply accessing the
    elemental transition instance via the `transition` property inside the content
    lambda for `AnimatedVisibility`. You will also notice any animation states that
    have been added.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing accessibility in Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we build Android applications, we need to always have accessibility in the
    back of our minds because this makes technology inclusive and ensures all people
    with special needs are considered as we build applications.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility should be a team effort. If well handled, the advantages include
    having more people using your application. An accessible application is better
    for everyone. You also reduce the risk of being sued.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of disabilities, such as visual, aural, and motor
    impairments. If you open your **Accessibility** settings, you will see the different
    options that people with disabilities use on their devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like previous recipes, we will continue using our sample project from previous
    recipes; you do not need to install anything.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will describe the visual elements, which are very vital:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when we add an `Image` function, you might notice that it has two
    parameters, a painter for the image and a content description to visually describe
    the element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you set the content description to `null`, you indicate to the Android
    framework that this element does not have an associated action or state. So, let’s
    go ahead and update all our content descriptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you add the string to the `string` `res` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, go ahead and ensure you add a content description for every image that requires
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Compose, you can easily indicate whether a text is a heading by specifying
    this in the modifier and using semantics to show that that is a heading. Let’s
    add that in our decorated text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can go ahead and compile, run, and test whether our application
    is accessible by following this link on how to manually test using talkback or
    using automated testing: [https://developer.android.com/guide/topics/ui/accessibility/testing](https://developer.android.com/guide/topics/ui/accessibility/testing).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jetpack Compose is built with accessibility in mind; that is to say, material
    components such as `RadioButton`, `Switch`, and so on have their size internally
    set, but only when these components can receive user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, any screen element that users can click on or interact with should
    be large enough for reliable interaction. A standard format sets these elements
    to a size of at least `48dp` for `width` and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `Switch` has its `onCheckChanged` parameter set to a non-null
    value, including width and height of at least `48dp`; we would have `CheckableSwitch()`,
    and `NonCheckableSwitch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Once you have implemented accessibility in your applications, you can easily
    test it by installing analysis tools from the Play Store – `uiautomatorviewer`
    and `lint`. You can also automate your tests using Espresso or Roboelectric to
    check for accessibility support.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can manually test your application for accessibility support by
    going to **Settings**, then to **Accessibility**, and selecting **talkback**.
    This is found at the top of the screen; then press **On** or **Off** to turn the
    talkback functionality on or off. Then, navigate to the dialog confirmation, and
    click **OK** to confirm permission.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more regarding accessibility that developers should consider as they
    build their applications, including a state with which they should be able to
    notify their users on whether a `Switch` button has been selected. This ensures
    their applications support accessibility and are up to standard.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing declarative graphics using Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android development, your application might have a different need, and this
    need might be building your own custom graphics for an intended purpose. This
    is very common in many stable and large Android code bases. The essential part
    of any custom view is its appearance. Furthermore, custom drawing can be a very
    easy or complex task based on the needs of your application. In Modern Android
    Development, Jetpack Compose makes it easier to work with custom graphics simply
    because the demand is immense. For example, many applications may need to control
    what happens on their screen accurately; the use case might be as simple as putting
    a circle on the screen or building more complex graphics to handle known use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `Compose Basics` project to get started with this recipe. You can find
    the entire code in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our project, let us create a new package and call it `circularexample`;
    inside this package, create a Kotlin file and call it `DrawCircleCompose`; inside
    the file, create a `CircleProgressIndicatorExample` composable function. You will
    not need to import anything for now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now go ahead and define our composable function. Since, in our example,
    we want to display a tracker in a circle, we need to float to fill in our circle.
    We will also define the colors to help us identify the progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s call `Canvas` to draw our arc. We give our circle the size of `200.dp`
    with `8.dp` padding. Where it gets interesting is in `onDraw`. `startAngle` is
    set at `-90`; the start angle is set in degrees to understand it better.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The zero represents 3 o’clock, and you can also play around with your start
    angle to see how `-90` translates. The `useCenter` Boolean indicates whether arc
    is to close the center of the bounds. Hence, in our case, we set it to `false`.
    Then, finally, we set the `style`, which can be anything based on our preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just drawn the first part of the circle; now, we need to draw the progress
    with a `Brush`, which utilizes `linearGradient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, our `progress` function tells `sweepAngle` where our progress should
    be based on our tracking abilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `preview` function, and you should see a circular progress indicator
    as in *Figure 2**.11*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Showing a circular progress image](img/Figure_2.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Showing a circular progress image
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `Canvas` composable function uses `Canvas` to Compose an object, which,
    in turn, creates and helps manage a view-base Canvas. It is also important to
    mention that Compose makes it easier for developers by maintaining the state and
    creating and freeing any necessary helper objects.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, `Canvas` allows you to specify an area on the screen where you want
    to draw. In the old way of building Android applications, we also utilized `Canvas`,
    and now in Compose, it is more powerful and valuable.
  prefs: []
  type: TYPE_NORMAL
- en: '`linearGradient` create a linear gradient with the specified colors along the
    provided start and end coordinates. For our example, we give it simple colors
    that come with the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The drawing functions have instrumental default parameters that you can use.
    For instance, by default, `drawArc`, as you can see, takes in several inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Showing what drawArc takes as input](img/Figure_2.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Showing what drawArc takes as input
  prefs: []
  type: TYPE_NORMAL
- en: '`sweepAngle` in our example, which is the size of the arc in the degree that
    is drawn clockwise relative to `startAngle`, returns a function that calculates
    progress. This function can be customized to fit your needs. In our example, we
    pass in a tracker and progress and return a float.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to fill the circle, we create `cal totalProgress`, which checks
    *progress * 100* divided by the tracker, and we return *360 (circle) * our progress
    divided by 100*. You can customize this function to fit your needs. You can also
    write code to listen to where you are and make the progress move based on your
    input value from a listener you create.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more you can do with `Canvas` and custom drawing. One amazing way to
    enhance your knowledge on the topic is to look into old solutions posted on Stack
    Overflow, such as drawing a heart or any other shape, and see whether you can
    do the same in Compose.
  prefs: []
  type: TYPE_NORMAL
