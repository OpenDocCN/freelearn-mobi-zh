<html><head></head><body>
		<div><h1 id="_idParaDest-136" class="chapter-number"><a id="_idTextAnchor219" class="calibre6 pcalibre pcalibre1"/>7</h1>
			<h1 id="_idParaDest-137" class="calibre5"><a id="_idTextAnchor220" class="calibre6 pcalibre pcalibre1"/>Building Great User Experiences with UIKit</h1>
			<p class="calibre3">In <a href="B18653_06.xhtml#_idTextAnchor196" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 6</em></a>, we took a break from coding and discussed topics that evolve our code, such as testing, debugging, and more. Now, it’s time to go back to what we love to do, and what is more loveable in iOS development than building a great UI experience?</p>
			<p class="calibre3">For most iOS developers, UIKit is considered to be the most critical framework right after Foundation, and in iOS interviews, it’s a mandatory topic.</p>
			<p class="calibre3">Even though UIKit is a huge framework, this chapter will cover the essential topics required for iOS developers:</p>
			<ul class="calibre10">
				<li class="calibre11">We will go over the <strong class="bold">Auto </strong><strong class="bold">Layout</strong> system</li>
				<li class="calibre11">We will discuss the different <strong class="source-inline1">UIView</strong> features</li>
				<li class="calibre11">We will ensure a deep understanding of <strong class="source-inline1">UITableViews</strong></li>
				<li class="calibre11">We will talk about <strong class="source-inline1">UIViewController</strong> and its role in our app</li>
				<li class="calibre11">We will dive into the navigation world</li>
				<li class="calibre11">We will learn the basic concepts of animations</li>
			</ul>
			<p class="calibre3">As I said – UIKit is an enormous topic, and there are many more, but we are focusing on the mandatory interview issues.</p>
			<p class="calibre3">We will start with what is driving our layout, and that’s the Auto Layout system.</p>
			<h1 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor221" class="calibre6 pcalibre pcalibre1"/>Answering questions about Auto Layout</h1>
			<p class="calibre3">UIKit is a vast topic, and <a id="_idIndexMarker435" class="calibre6 pcalibre pcalibre1"/>over the years, it has become even more significant, gaining more and more capabilities.</p>
			<p class="calibre3">The engine that drives how things are placed on the screen is what Apple calls Auto Layout, which is why I chose to start the UIKit chapter with that topic in mind.</p>
			<p class="calibre3">Auto Layout is Apple technology that defines the <em class="italic">relationships between the different elements</em> on the screen and tremendously influences our ability to move fast with UI development. We can say that mastering Auto Layout sets us up with the ability to provide a great UI in a decent amount of time.</p>
			<p class="calibre3">But there is more than <a id="_idIndexMarker436" class="calibre6 pcalibre pcalibre1"/>just time efficiency – Auto Layout can help us <em class="italic">adapt our app to different screen sizes</em> or even platforms (<strong class="bold">iPad</strong> versus <strong class="bold">iPhone</strong>). It can also help us automatically set the UI direction according to the current localization.</p>
			<p class="calibre3">We’ll go over some of the most common Auto Layout questions now. Isn’t it an excellent start for a UIKit chapter?</p>
			<h2 id="_idParaDest-139" class="calibre7"><a id="_idTextAnchor222" class="calibre6 pcalibre pcalibre1"/>“Can you explain what content hugging and compression resistance are in Auto Layout and how they are used to control the layout of UI elements?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3"><strong class="bold">Compression resistance</strong> and <strong class="bold">content hugging</strong> are two essential concepts in Auto Layout that define <a id="_idIndexMarker437" class="calibre6 pcalibre pcalibre1"/>views' behavior when their size and layout change. At this <a id="_idIndexMarker438" class="calibre6 pcalibre pcalibre1"/>stage, the interviewer assumes <a id="_idIndexMarker439" class="calibre6 pcalibre pcalibre1"/>we already know the basics of Auto Layout and wants to <a id="_idIndexMarker440" class="calibre6 pcalibre pcalibre1"/>see how we handle more complex situations where two different views are “fighting” over limited space to satisfy all their constraints.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Compression resistance and content hugging are two of UIView’s properties that define the layout behavior when there isn’t enough space to satisfy all the constraints.</p>
			<p class="calibre3">Let’s go over what these terms mean for constraints:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Content hugging</strong>: When <a id="_idIndexMarker441" class="calibre6 pcalibre pcalibre1"/>content hugging is set to high priority, the view wants to become <em class="italic">as small as possible</em> with a specific axe</li>
				<li class="calibre11"><strong class="bold">Compression resistance</strong>: When the compression resistance property is set to high, the view <a id="_idIndexMarker442" class="calibre6 pcalibre pcalibre1"/>wants to become <em class="italic">as big as possible</em> with a specific axe</li>
			</ul>
			<p class="calibre3">One great example to demonstrate a possible conflict between two views is a UIView (let’s say <code>UITableViewCell</code>) with two subviews – a leading label and a button (see <em class="italic">Figure 7</em><em class="italic">.1</em>):</p>
			<div><div><img src="img/Figure_7.1_B18653.jpg" alt="Figure 7.1 – A view with a label and a button" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A view with a label and a button</p>
			<p class="calibre3">Looking at <em class="italic">Figure 7</em><em class="italic">.1</em>, we can see a possible use case – both the label and button can have a short <a id="_idIndexMarker443" class="calibre6 pcalibre pcalibre1"/>text, and as <a id="_idIndexMarker444" class="calibre6 pcalibre pcalibre1"/>a result, their intrinsic content size is small. If these two views try to set their width according <a id="_idIndexMarker445" class="calibre6 pcalibre pcalibre1"/>to their content, one <a id="_idIndexMarker446" class="calibre6 pcalibre pcalibre1"/>will have to “give up” and fill the remaining space. To ensure that the button will try to become as small as possible and the label will fill the remaining space, we need to set their content hugging and compression resistance accordingly. Let’s see how to do that in code:</p>
			<pre class="source-code">
class MyTableViewCell: UITableViewCell {    @IBOutlet weak var label: UILabel!
    @IBOutlet weak var button: UIButton!
    override func awakeFromNib() {
        super.awakeFromNib()
        label.setCompressionResistancePriority (.defaultHigh, for: .horizontal)
        button.setContentHuggingPriority (.defaultHigh, for: .horizontal)
    }
}</pre>
			<p class="calibre3">Calling <code>setcompressionResistencePriority</code> for <code>label</code> means that when the cell is <a id="_idIndexMarker447" class="calibre6 pcalibre pcalibre1"/>resized horizontally, the <a id="_idIndexMarker448" class="calibre6 pcalibre pcalibre1"/>auto-layout system <a id="_idIndexMarker449" class="calibre6 pcalibre pcalibre1"/>will try to maintain <a id="_idIndexMarker450" class="calibre6 pcalibre pcalibre1"/>the intrinsic content size of the label and <em class="italic">prevent it from </em><em class="italic">being compressed</em>.</p>
			<p class="calibre3">However, calling <code>setContentHuggingPrioirty</code> for button means that when the cell is resized horizontally, and there is extra space available, the auto-layout system will <em class="italic">try to expand</em> <code>button</code> to fill the available space and prevent it from being stretched too much.</p>
			<p class="calibre3">We can set these priorities in the code and Interface Builder quite easily.</p>
			<p class="calibre3">There are many other examples where this settlement is needed, such as a page title’s width that conflicts with its alignment or complex screens with dynamic font size.</p>
			<h2 id="_idParaDest-140" class="calibre7"><a id="_idTextAnchor223" class="calibre6 pcalibre pcalibre1"/>“Can you explain how to use size classes in Interface Builder to adapt layouts for different screen sizes and orientations?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This question <a id="_idIndexMarker451" class="calibre6 pcalibre pcalibre1"/>is important because it tests our understanding <a id="_idIndexMarker452" class="calibre6 pcalibre pcalibre1"/>by taking Auto Layout and trying to adapt our layout to <em class="italic">different sizes </em><em class="italic">and orientations</em>.</p>
			<p class="calibre3">Notice I didn’t mention iPad or iPhone – these terms are irrelevant when discussing Auto Layout. We must consider our layout fully responsive according to different size levels, aka, size classes.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3"><strong class="bold">Size classes</strong> are a feature that allows us to create one UI for various screen sizes. A screen size can <a id="_idIndexMarker453" class="calibre6 pcalibre pcalibre1"/>be an iPhone or an iPad, but it can also be an iPad app being presented on a split screen and therefore needs to change its layout to an iPhone app.</p>
			<p class="calibre3">The classes we have today are <strong class="bold">Compact</strong> and <strong class="bold">Regular</strong>. Compact usually means an iPhone or an iPad app <a id="_idIndexMarker454" class="calibre6 pcalibre pcalibre1"/>in a split screen, and Regular means an iPad app. As mentioned, we <a id="_idIndexMarker455" class="calibre6 pcalibre pcalibre1"/>shouldn’t think of these classes as iPhone versus iPad. Size classes allow us to think responsively regardless of our app’s device.</p>
			<p class="calibre3">To use size classes in Interface Builder, we first need to open the storyboard we want to work on. Then, in the bottom right corner of the <code>w Any h Any</code> class, which means the layout will <a id="_idIndexMarker456" class="calibre6 pcalibre pcalibre1"/>be the same for all devices and orientations. We can select <a id="_idIndexMarker457" class="calibre6 pcalibre pcalibre1"/>another size class from the control to create a different layout for a specific screen size or orientation. For example, we can choose the <code>w Compact h Regular</code> class to create a layout for iPhones in portrait orientation.</p>
			<p class="calibre3">One good use case is a login screen, where on a small screen, we want the username and password text fields to be laid out vertically, and on a bigger screen, we may want them to be laid out horizontally. The layout of the text fields according to size can be managed using size classes.</p>
			<p class="calibre3">More examples of different values in different size classes are fonts, Auto Layout, and constant size.</p>
			<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor224" class="calibre6 pcalibre pcalibre1"/>“What is the purpose of the safe area in Auto Layout, and how do you ensure that your views are properly positioned within the safe area?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">The <strong class="bold">safe area</strong> is an important topic when working with layouts across different devices. Every iOS developer <a id="_idIndexMarker458" class="calibre6 pcalibre pcalibre1"/>must know how to handle the safe area, which contains the <a id="_idIndexMarker459" class="calibre6 pcalibre pcalibre1"/>status bar, sensors, and round corners of modern iPhones. This question tests our experience working with different devices and creating a layout agnostic to the device type we work on.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The safe area is a feature in Auto Layout that provides a <strong class="bold">layout guide</strong> that helps us position elements above <a id="_idIndexMarker460" class="calibre6 pcalibre pcalibre1"/>and below areas on the screen reserved for sensors, round corners, and generally areas the user isn’t supposed to touch.</p>
			<p class="calibre3">However, we can position non-interactive views in the safe area zone, such as videos or backgrounds. Still, we must consider that iOS elements, sensors, and screen round corners may partially cover these views.</p>
			<p class="calibre3">To ensure we position a view outside the safe area, we can use a property named <code>safeAreaLayoutGuide</code>. Here’s an example of positioning a label below the top safe area using <code>safeAreaLayoutGuide</code>:</p>
			<pre class="source-code">
    NSLayoutConstraint.activate([      myLabel.leadingAnchor.constraint(equalTo:
          view.<strong class="bold1">safeAreaLayoutGuide</strong>.leadingAnchor),
      myLabel.trailingAnchor.constraint(equalTo:
          view.<strong class="bold1">safeAreaLayoutGuide</strong>.trailingAnchor),
      myLabel.topAnchor.constraint(equalTo:
         view.<strong class="bold1">safeAreaLayoutGuide</strong>.topAnchor, constant: 30),
      myLabel.heightAnchor.constraint(equalToConstant: 20)</pre>
			<p class="calibre3">We can see that <code>view</code>, the UIViewController main view, has a property named <code>safeAreaLayoutGuide</code>, and that guide represents the end of the safe area zone. This guide is equivalent to the screen edges in older devices, but in modern devices, it means the interactive part of the display.</p>
			<p class="calibre3">It is best practice to check your layout with different devices to ensure it is usable in all displays.</p>
			<p class="calibre3">Auto Layout is a fundamental topic in UIKit and iOS development. There’s no way to get into UI development <a id="_idIndexMarker461" class="calibre6 pcalibre pcalibre1"/>without working closely with <a id="_idIndexMarker462" class="calibre6 pcalibre pcalibre1"/>Auto Layout, and the UI is an important topic in iOS. If you started your iOS development career with SwiftUI, ensure you are familiar with Auto Layout, at least for the basic terms.</p>
			<h1 id="_idParaDest-142" class="calibre5"><a id="_idTextAnchor225" class="calibre6 pcalibre pcalibre1"/>Solving UIView questions</h1>
			<p class="calibre3">UIView is the basic building <a id="_idIndexMarker463" class="calibre6 pcalibre pcalibre1"/>block for user interaction in iOS UIKit. At its roots, it represents a rectangle on the screen that can display graphics and handle user interactions and animations.</p>
			<p class="calibre3">Before we go over any interview questions, it is crucial to understand the roles of UIView in UIKit, and its relationship with CALayer.</p>
			<p class="calibre3">Let’s go over the main features of UIView:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Manage subviews</strong>: UIView can <a id="_idIndexMarker464" class="calibre6 pcalibre pcalibre1"/>contain additional UIViews called <strong class="bold">subviews</strong>, which can <a id="_idIndexMarker465" class="calibre6 pcalibre pcalibre1"/>include their own subviews. This capability allows us to build complex UIs and reusable components. UIView is also responsible for handling the layout of its subviews using the Auto Layout system we discussed in the previous chapter.</li>
				<li class="calibre11"><strong class="bold">Respond to user interaction</strong>: Another important role UIView has is to respond <a id="_idIndexMarker466" class="calibre6 pcalibre pcalibre1"/>to user interaction, which is <a id="_idIndexMarker467" class="calibre6 pcalibre pcalibre1"/>not a minor topic. Preparing for the interview involves learning about the <strong class="bold">responder chain</strong>, which handles user interactions with UIView’s hierarchy.</li>
				<li class="calibre11"><strong class="bold">Draw graphics</strong>: UIView can draw graphics: lines, shapes, images, and texts. UIView <a id="_idIndexMarker468" class="calibre6 pcalibre pcalibre1"/>does that using another framework called <strong class="bold">Core Graphics</strong>, which is <a id="_idIndexMarker469" class="calibre6 pcalibre pcalibre1"/>responsible for drawing <a id="_idIndexMarker470" class="calibre6 pcalibre pcalibre1"/>basic graphics using the <strong class="bold">CPU</strong>.</li>
			</ul>
			<p class="calibre3">So, what about CALayer? Well, we already know the UIView can draw using Core Graphics, but that’s not <a id="_idIndexMarker471" class="calibre6 pcalibre pcalibre1"/>an efficient way. Therefore, it has a CALayer. The CALayer is responsible for drawing the content inside UIView, which uses <strong class="bold">Core Animation</strong> and the device’s <strong class="bold">GPU</strong>. Each UIView <a id="_idIndexMarker472" class="calibre6 pcalibre pcalibre1"/>has a primary CALayer that can have sublayers of its own.</p>
			<p class="calibre3">The CALayer is responsible for <a id="_idIndexMarker473" class="calibre6 pcalibre pcalibre1"/>the content drawing, and UIView is accountable for the layout and user interaction.</p>
			<h2 id="_idParaDest-143" class="calibre7"><a id="_idTextAnchor226" class="calibre6 pcalibre pcalibre1"/>“Can you explain how the responder chain works in iOS?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">The responder chain is <a id="_idIndexMarker474" class="calibre6 pcalibre pcalibre1"/>a key concept in iOS UI development. The idea <a id="_idIndexMarker475" class="calibre6 pcalibre pcalibre1"/>discusses the management of user <a id="_idIndexMarker476" class="calibre6 pcalibre pcalibre1"/>interaction in multi-layer screens.</p>
			<p class="calibre3">The question is vital because user interaction is a critical topic in UI development, and the responder chain is not a simple concept to understand at first glance.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The term “responder chain” refers to a mechanism in which the user touches the screen, and each UIView passes the <a id="_idIndexMarker477" class="calibre6 pcalibre pcalibre1"/>touch forward to its corresponding subviews until one of the views responds.</p>
			<p class="calibre3">Let us explore this in <em class="italic">Figure 7</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/Figure_7.2_B18653.jpg" alt="Figure 7.2 – Example of a responder chain in iOS" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Example of a responder chain in iOS</p>
			<p class="calibre3">As shown in <em class="italic">Figure 7</em><em class="italic">.2</em>, the touch starts with <code>UIApplication</code> and goes down until it reaches the first view that responds to the touch, in this case, <code>UITextField</code>. The respond chain “asks” each <a id="_idIndexMarker478" class="calibre6 pcalibre pcalibre1"/>of the views if it is the first responder <a id="_idIndexMarker479" class="calibre6 pcalibre pcalibre1"/>by calling the <code>becomeFirstResponder()</code> function. That’s why calling directly to <code>become FirstResponder()</code> on <a id="_idIndexMarker480" class="calibre6 pcalibre pcalibre1"/>a text field brings up the keyboard and makes the text field the currently active input field.</p>
			<p class="calibre3">In short, a responder chain is our ability to control which view catches the user interaction while views are placed on top of each other. There are more cases where this comes in handy, such as transparent views or scrolls.</p>
			<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor227" class="calibre6 pcalibre pcalibre1"/>“How can you respond to device orientation changes in UIView?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">In many apps, responding to device orientation is crucial because it provides the user with an <a id="_idIndexMarker481" class="calibre6 pcalibre pcalibre1"/>optional layout for the app just by rotating the device.</p>
			<p class="calibre3">But that’s not the real reason why it’s essential to understand that question correctly. We should know how to structure our UI to support different screen proportions and adjust the layout and the controls according to the new orientation.</p>
			<p class="calibre3">The question tests our flexibility and readiness for a radical layout change.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Handling device orientation changes requires tackling that problem from different angles. Let’s list some of the things we can do:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Verify our Auto Layout constraints</strong>: Auto Layout is a great technique to ensure our layout <a id="_idIndexMarker482" class="calibre6 pcalibre pcalibre1"/>will stay usable after changing the screen bounds. We can define constraint relationships and limit view size or margins to ensure our layout is updated correctly with changing orientation.</li>
				<li class="calibre11"><strong class="bold">Animate changes</strong>: If possible, we should animate changes to our views to provide our users with a seamless and smooth change experience.</li>
				<li class="calibre11"><strong class="bold">Override the willTransition(to:with) method</strong>: The<strong class="bold"> </strong><strong class="source-inline1">willTransition(to:with)</strong> method gets called just before the view transitions to <a id="_idIndexMarker483" class="calibre6 pcalibre pcalibre1"/>a new size or a trait collection. That’s where we can modify the view appearance in addition to what Auto Layout already changed. For example, we can show or hide subviews, change texts, or modify constraint values.</li>
				<li class="calibre11"><strong class="bold">Update layout</strong>: Position or rearrange views, and in general, make changes to our layout to fit the new orientation. That, of course, is according to our design and product requirements.</li>
			</ul>
			<p class="calibre3">Not all app <a id="_idIndexMarker484" class="calibre6 pcalibre pcalibre1"/>makers support landscape and portrait states in their products, as this is more a design decision than an engineering one. But building our views with orientation change in mind is a good practice.</p>
			<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor228" class="calibre6 pcalibre pcalibre1"/>“Why does UIView not have a ‘viewDidAppear’ method as UIViewController does?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">We haven’t discussed view controllers just yet, but that’s a question many candidates struggle to answer. This question aims to see whether we understand the relationship UIViews have with <a id="_idIndexMarker485" class="calibre6 pcalibre pcalibre1"/>their view controller. Many junior developers ask themselves that question because understanding the UIView role isn’t intuitive. More experienced developers should answer that question more easily.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">UIView doesn’t have a <code>viewDidAppear</code> method like <strong class="bold">UIViewController</strong> because the primary role of UIView is to be <a id="_idIndexMarker486" class="calibre6 pcalibre pcalibre1"/>a visual component and not handle life cycle events.</p>
			<p class="calibre3">When we look back to the <code>viewDidLoad</code>, <code>viewWillAppear</code>, and <code>viewDidAppear</code>. If we need to perform tasks in the life cycle events such as performing network requests, loading data, or setting a state, we should do it in <a id="_idIndexMarker487" class="calibre6 pcalibre pcalibre1"/>the view controller and update the view accordingly. Doing any of these is not part of the UIView’s role.</p>
			<p class="calibre3">MVC will be discussed in detail in <a href="B18653_11.xhtml#_idTextAnchor329" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 11</em></a>.</p>
			<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor229" class="calibre6 pcalibre pcalibre1"/>“Can you explain the difference between setNeedsLayout, layoutSubviews, and layoutIfNeeded in UIView? When would you use each of these methods, and how do they impact the layout process?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">These three UIView methods (<code>setNeedsLayout</code>, <code>layoutSubviews</code>, and <code>layoutIfNeeded</code>) tell <a id="_idIndexMarker488" class="calibre6 pcalibre pcalibre1"/>the story of UIView rendering cycle optimization. This is not a go/no-go <a id="_idIndexMarker489" class="calibre6 pcalibre pcalibre1"/>question but more like a bonus question. I have <a id="_idIndexMarker490" class="calibre6 pcalibre pcalibre1"/>interviewed <a id="_idIndexMarker491" class="calibre6 pcalibre pcalibre1"/>hundreds of iOS developers in my career, and <a id="_idIndexMarker492" class="calibre6 pcalibre pcalibre1"/>most of them can’t fully answer this question <a id="_idIndexMarker493" class="calibre6 pcalibre pcalibre1"/>as they don’t understand <a id="_idIndexMarker494" class="calibre6 pcalibre pcalibre1"/>how the layout system works precisely.</p>
			<p class="calibre3">Answering this question correctly will benefit us in an interview situation.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">First, let’s understand how the layout system works – UIView refreshes the layout of its subviews once every screen refresh rate (in 60Hz, it’s once every 16.67 milliseconds), only if it needs to. What does that mean? For example, if the view changes its frame, it must refresh the layout of its subviews. The reason it happens every 16.67 milliseconds is because of efficiency. If we change the UIView’s frame multiple times within these 16.67 milliseconds, it will refresh the layout of its subviews only once.</p>
			<p class="calibre3">Now, what does it mean “refresh the layout of its subviews”? It means that the system runs the <code>layoutSubiews()</code> method, which we can override and perform additional changes if we like.</p>
			<p class="calibre3">We understand now that changing the UIView frame marks the view as “dirty,” so in the next run loop, it will run <code>layoutSubviews()</code>. But we don’t have to change its frame or one of the related constraints to mark the view as dirty. We can just call <code>setNeedsLayout()</code> to ensure that the view will update its subviews in the next run loop.</p>
			<p class="calibre3">Sometimes, we need the view to run <code>layoutSubviews</code> immediately without waiting for the next run loop. One good example is animations and constraint changes. In this case, we can call <code>layoutIfNeeded()</code>, which will call <code>layoutSubviews()</code> only if UIView is marked as dirty.</p>
			<p class="calibre3">It is now clear <a id="_idIndexMarker495" class="calibre6 pcalibre pcalibre1"/>why we never call <code>layoutSubviews()</code> directly – the <a id="_idIndexMarker496" class="calibre6 pcalibre pcalibre1"/>system does that <a id="_idIndexMarker497" class="calibre6 pcalibre pcalibre1"/>for us much more efficiently, and it is better to stick with the natural process.</p>
			<p class="calibre3">As I said at <a id="_idIndexMarker498" class="calibre6 pcalibre pcalibre1"/>the beginning of this section – UIView is our UI <a id="_idIndexMarker499" class="calibre6 pcalibre pcalibre1"/>building block and one of the fundamental <a id="_idIndexMarker500" class="calibre6 pcalibre pcalibre1"/>parts of MVC and <strong class="bold">MVVM</strong>. Understanding <a id="_idIndexMarker501" class="calibre6 pcalibre pcalibre1"/>how it works beyond adding and removing subviews is <a id="_idIndexMarker502" class="calibre6 pcalibre pcalibre1"/>essential to us as iOS developers and can help us influence our app performance and experience. Additionally, some of the discussed questions in this section will be asked in an interview.</p>
			<p class="calibre3">Now let’s move on to another important side of the MVC pattern: UIViewController.</p>
			<h2 id="_idParaDest-147" class="calibre7"><a id="_idTextAnchor230" class="calibre6 pcalibre pcalibre1"/>“What is the difference between the frame and bounds properties?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Even though <code>bounds</code> and <code>frame</code> are quite similar, the difference between them is crucial to <a id="_idIndexMarker503" class="calibre6 pcalibre pcalibre1"/>understand how the layout system <a id="_idIndexMarker504" class="calibre6 pcalibre pcalibre1"/>works. The difference is important, especially <a id="_idIndexMarker505" class="calibre6 pcalibre pcalibre1"/>when dealing with animations, positioning, and transitions.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">In short, the <code>frame</code> property represents the position and size of a UIView relative to its superview’s coordinate system, while the <code>bounds</code> property represents the position and size of a UIView relative to its own coordinate system.</p>
			<p class="calibre3">Here’s an example of the <code>bounds</code> and <code>frame</code> properties for the same view, positioned in <em class="italic">x</em>:50 and <em class="italic">y</em>:100:</p>
			<ul class="calibre10">
				<li class="calibre11">Frame:<ul class="calibre18"><li class="calibre11">Origin: (<em class="italic">x</em>: 50, <em class="italic">y</em>: 100)</li><li class="calibre11">Size: (width: 200, height: 150)</li></ul></li>
				<li class="calibre11">Bounds:<ul class="calibre18"><li class="calibre11">Origin: (<em class="italic">x</em>: 0, <em class="italic">y</em>: 0)</li><li class="calibre11">Size: (width: 200, height: 150)</li></ul></li>
			</ul>
			<p class="calibre3">We can see that the origin is different, but the size is the same. That’s because the origin in the frame is relative to its superview.</p>
			<p class="calibre3">However, it’s important to note that there are cases where the frame and bounds sizes can differ. Unlike <a id="_idIndexMarker506" class="calibre6 pcalibre pcalibre1"/>the <code>bounds</code> property, which <a id="_idIndexMarker507" class="calibre6 pcalibre pcalibre1"/>represents the view’s size in its own <a id="_idIndexMarker508" class="calibre6 pcalibre pcalibre1"/>coordinate system, the frame size is calculated and can change during animations. Therefore, it is possible to observe different size values between the <code>frame</code> and <code>bounds</code> properties. While the bounds size property remains constant, the frame size property can reflect the current size values during animations or transformations.</p>
			<h1 id="_idParaDest-148" class="calibre5"><a id="_idTextAnchor231" class="calibre6 pcalibre pcalibre1"/>Understanding everything about UIViewController</h1>
			<p class="calibre3">UIViewController is a <a id="_idIndexMarker509" class="calibre6 pcalibre pcalibre1"/>core class in iOS development and behaves as a building block for most iOS apps that use UIKit.</p>
			<p class="calibre3">UIViewController has multiple roles in iOS development:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">It is the C in the MVC pattern</strong>: If the UIView is the V (View) and our model is the M, the <a id="_idIndexMarker510" class="calibre6 pcalibre pcalibre1"/>UIViewController is the one that coordinates between the presentation layer and the business layer. That role affects many of the features UIViewController has, such as life cycle events and memory management functions.</li>
				<li class="calibre11"><strong class="bold">Handling life cycle events</strong>: We explained this role of UIViewController in the previous section. UIViewController has another function: to manage the various life cycle events on the screen. By creating subclasses of UIViewController, we can take advantage of its different methods to handle all stages of a screen’s life cycle.</li>
				<li class="calibre11"><strong class="bold">Leading player in the navigation system</strong>: We can present UIViewController above another UIViewController or push and pop it into and from a navigation stack. As such, UIViewController plays a significant role in iOS app navigation by representing a “screen” in our project (note – a UIViewController isn’t equivalent to a “screen,” but a screen always has a root view controller).</li>
				<li class="calibre11"><strong class="bold">Loading and unloading views</strong>: Usually, we don’t present views on the screen without a UIViewController that handles them. We can indeed add a UIView to the app window, but that’s an edge case. Adding a view to the window <a id="_idIndexMarker511" class="calibre6 pcalibre pcalibre1"/>brings with it issues such as life cycle management, model and data linking, and many more, and they are considered not ideal.</li>
			</ul>
			<p class="calibre3">I’m not sure that, as iOS candidates, we will encounter an interview without a question about UIViewController.</p>
			<h2 id="_idParaDest-149" class="calibre7"><a id="_idTextAnchor232" class="calibre6 pcalibre pcalibre1"/>“Can you list all the life cycle events or methods of a UIViewController, in the order in which they occur?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">That is probably <a id="_idIndexMarker512" class="calibre6 pcalibre pcalibre1"/>one of the most common questions interviewers ask. It isn’t a difficult question and is also easy to learn and complete.</p>
			<p class="calibre3">This question is usually considered a critical factor in the interview process, as not doing well can lead to concerns for most interviewers.</p>
			<p class="calibre3">Let’s understand why – our understanding of UIViewController life cycle events influences the decisions of where to load and release data, how to build our UI, perform animation, and provide a good user experience to the user.</p>
			<p class="calibre3">It is also important <a id="_idIndexMarker513" class="calibre6 pcalibre pcalibre1"/>to be familiar with the UIViewController life cycle to handle user interaction and view updates.</p>
			<p class="calibre3">We need to ensure we don’t have any gaps in our answer to this question.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Let’s list the life cycle events, ordered by their call timing:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">loadView()</strong>: This is called before the view hierarchy is created. UIKit doesn’t create the view before <strong class="source-inline1">loadView()</strong> is called, so we’ll get nil when accessing the UIViewController <strong class="source-inline1">view</strong> property.</li>
				<li class="calibre11"><strong class="source-inline1">viewDidLoad()</strong>: This is called after the view is loaded. That’s where we can perform additional setups <a id="_idIndexMarker514" class="calibre6 pcalibre pcalibre1"/>to the view, such as adding subviews and observers. Unlike many other life cycle methods, <strong class="source-inline1">viewDidLoad</strong> is called only once.</li>
				<li class="calibre11"><strong class="source-inline1">viewWillLayoutSubviews()</strong>: This is called just before the view lays out its subviews. We can make additional changes to constraints at this time.</li>
				<li class="calibre11"><strong class="source-inline1">viewDidLayoutSubviews()</strong>: This is called after the view lays out its subviews. We can do tasks that require a final layout. For example, position views, scroll view content size, and animations.</li>
				<li class="calibre11"><strong class="source-inline1">viewWillAppear()</strong>: This is called before the view is presented on the screen. UIKit calls that method one or more times. That’s the place to load data if needed.</li>
				<li class="calibre11"><strong class="source-inline1">viewDidAppear()</strong>: This is called after the view is already presented on the screen. UIKit calls that method one or more times. Generally, that’s an excellent place to show start animations.</li>
				<li class="calibre11"><strong class="source-inline1">viewWillDisappear()</strong>: This is called just before the view is removed from the parent view controller or is hidden by a modal view controller. We can do some cleanup tasks here, such as stop timers and animations, perform savings, or stop media playback.</li>
				<li class="calibre11"><strong class="source-inline1">viewDidDisapper()</strong>: This is called after the view is removed from the parent view controller. We <a id="_idIndexMarker515" class="calibre6 pcalibre pcalibre1"/>usually perform tasks that do not influence the user experience – for example, logging, states, cleaning temporary files, and resetting data.</li>
			</ul>
			<p class="calibre3">It is imperative to mention that some of the methods in the list <em class="italic">can be called multiple times</em> in different use cases. For example, <code>viewWillLayoutSubviews</code> can be called when the main view changes its size, such as an orientation change. The <code>viewWillDisappear</code> method might be called when a model is presented above the view controller. We should provide examples of each one of the life cycle events to show our understanding.</p>
			<h2 id="_idParaDest-150" class="calibre7"><a id="_idTextAnchor233" class="calibre6 pcalibre pcalibre1"/>“Can you explain the concept of UIViewController containment? How would you implement it in your app?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Compared to the previous question, this question is more advanced and requires knowledge of design patterns and architecture.</p>
			<p class="calibre3"><strong class="bold">UIViewController containment</strong> creates modular and reusable UI interfaces and increases <a id="_idIndexMarker516" class="calibre6 pcalibre pcalibre1"/>our project flexibility.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">With <a id="_idIndexMarker517" class="calibre6 pcalibre pcalibre1"/>UIViewController containment, we can add a view controller to another view controller and make it a child view controller. This differs from adding a subview because UIViewController represents an independent MVC unit and has its own responsibility.</p>
			<p class="calibre3">Take a look at <em class="italic">Figure 7</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_7.3_B18653.jpg" alt="Figure 7.3 – Divide our screen into different view controllers" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Divide our screen into different view controllers</p>
			<p class="calibre3"><em class="italic">Figure 7</em><em class="italic">.3</em> shows <a id="_idIndexMarker518" class="calibre6 pcalibre pcalibre1"/>that a screen represented by a UIViewContoller is divided into two additional view controllers.</p>
			<p class="calibre3">There are two main ways of adding a view controller child:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Drag a new view controller in the storyboard</strong>: We can use Xcode <strong class="bold">Storyboard</strong> to drag <a id="_idIndexMarker519" class="calibre6 pcalibre pcalibre1"/>a new view controller to an existing view controller. That creates a container view that is linked to another view controller. Because a single <strong class="bold">XIB file</strong> represents a single view controller or a view, we can do that only in storyboards and not in standard XIB files.</li>
				<li class="calibre11"><strong class="bold">Adding a child controller using code</strong>: We can easily add a new child view controller in code using the <strong class="source-inline1">addChild(UIViewController:)</strong> method. Let’s see an example of that:<pre class="source-code">
// Add child view controllerparentViewController.addChild(childViewController)parentViewController.view.addSubview (childViewController.view)childViewController.view.frame = parentViewController.view.boundschildViewController.didMove(toParent: parentViewController)</pre></li>			</ul>
			<p class="calibre3">There are four steps we need to do:</p>
			<ol class="calibre15">
				<li class="calibre11">Call the <strong class="source-inline1">addChild</strong> method to ensure the new UIViewController is added as a child in the view controller hierarchy.</li>
				<li class="calibre11">Add the <a id="_idIndexMarker520" class="calibre6 pcalibre pcalibre1"/>new view controller main view <em class="italic">as a subview</em> to the parent view controller. The views hierarchy needs to correspond to the view controller hierarchy.</li>
				<li class="calibre11">Set the child view controller <em class="italic">view frame or constraints</em>. It can be whatever we need.</li>
				<li class="calibre11"><em class="italic">Notify the system</em> that the child view controller has been moved to the parent.</li>
			</ol>
			<p class="calibre3">One of the advantages of adding the new view controller “according to the guidelines” is that we can sync <a id="_idIndexMarker521" class="calibre6 pcalibre pcalibre1"/>the life cycle events we discussed in the previous question. A <code>viewWillAppear</code> method being called on the parent view controller is also called on its child view controller, as long as they are added correctly. The life cycle events sync is critical when reusing the view controller as a child view controller on different screens.</p>
			<p class="callout-heading">We are already using UIViewController containment in our apps!</p>
			<p class="callout">You may feel that UIViewController containment is strange to you if you haven’t tried that before. But – most likely, you already used some kind of child view controller implementation in your apps. Let’s see two good examples:</p>
			<p class="callout"><strong class="bold">UINavigationController</strong>: Navigating in UIKit is done with a parent view controller (UINavigationController) and a child view controller, the top view controller. Imagine yourself implementing <a id="_idIndexMarker522" class="calibre6 pcalibre pcalibre1"/>your own navigation controller – how would you do that? How will you implement the push and pop view controllers’ actions? This is a great thinking exercise that can prepare you for the question.</p>
			<p class="callout"><strong class="bold">UISplitViewController</strong>: Apple provides a split view controller for apps that run on iPads. In UISplitViewController, we <a id="_idIndexMarker523" class="calibre6 pcalibre pcalibre1"/>have two additional child view controllers – master and detail view controllers. Both divide the screen into two different areas, each of which is a separate view controller. Now that you know how to add a child view controller, that’s easy.</p>
			<h2 id="_idParaDest-151" class="calibre7"><a id="_idTextAnchor234" class="calibre6 pcalibre pcalibre1"/>“How do you pass data between view controllers in iOS?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Passing data between view controllers is an important task in iOS development. The dynamic nature <a id="_idIndexMarker524" class="calibre6 pcalibre pcalibre1"/>of apps presenting <a id="_idIndexMarker525" class="calibre6 pcalibre pcalibre1"/>the same UI with different information requires us to update a view controller with new information constantly. The question tests our knowledge of the various design patterns of passing data between objects in general and between view controllers explicitly.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There are many ways of passing data between view controllers! The problem is that all those ways make it extremely easy to answer the question. And therefore, we need to explain the use case and reason for each one of the ways we present to the interviewer. Let’s see some examples:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Using a delegate</strong>: If we have <a id="_idIndexMarker526" class="calibre6 pcalibre pcalibre1"/>a child-parent relationship, we use a delegate to notify of events and data between the child and the parent view controller. A delegate is a simple pattern based on a protocol used when we want to implement a simple update with a well-defined interface. However, the <a id="_idIndexMarker527" class="calibre6 pcalibre pcalibre1"/>delegate pattern is considered a bit outdated as we have more advanced patterns today.</li>
				<li class="calibre11"><strong class="bold">Using dependency injection</strong>: One way to pass data to a new view controller when presenting <a id="_idIndexMarker528" class="calibre6 pcalibre pcalibre1"/>or pushing it into the stack is to use dependency injection. This can be achieved using the <strong class="source-inline1">init</strong> function or setting one of its properties. One example can be a screen that displays contact information. In the <strong class="source-inline1">init</strong> function, we can pass the contact entity that needs to be displayed. It’s important to note that this approach creates a one-way data stream and can be used whenever a new view controller needs to be displayed.</li>
				<li class="calibre11"><strong class="bold">Using a closure</strong>: If we pass the information in one direction only, closure is a great way to do <a id="_idIndexMarker529" class="calibre6 pcalibre pcalibre1"/>that. We can define a closure on the destination view controller and set it on the source view controller. Whenever we want to pass information from the source to its parent, the source just needs to run the closure with the relevant parameters. That’s a simple way to pass data with minimal coupling.</li>
				<li class="calibre11"><strong class="bold">Using Combine</strong>: Combine is an advanced and reactive version of closure. It lets us stream data <a id="_idIndexMarker530" class="calibre6 pcalibre pcalibre1"/>updates, including error handling, async operations, and data manipulation from one object to another.</li>
				<li class="calibre11"><strong class="bold">Post notification</strong>: If the two view controllers have no reference to each other, a notification may <a id="_idIndexMarker531" class="calibre6 pcalibre pcalibre1"/>be a good solution. Even though we can attach data to the notification, posting a notification is considered to be an anti-pattern by many developers. A notification doesn’t have a straightforward interface; all living objects can observe it and respond. These two reasons alone make it less recommended than the other methods.</li>
			</ul>
			<p class="calibre3">You are already <a id="_idIndexMarker532" class="calibre6 pcalibre pcalibre1"/>aware of all the methods <a id="_idIndexMarker533" class="calibre6 pcalibre pcalibre1"/>I just presented, but listing them can help you answer that question and help you with design-pattern tasks and home assessments. That is one of my goals in this book – to organize your thoughts.</p>
			<h1 id="_idParaDest-152" class="calibre5"><a id="_idTextAnchor235" class="calibre6 pcalibre pcalibre1"/>Making sure we are ready with UITableView</h1>
			<p class="calibre3">UITableView, followed by UICollectionView, is one of the oldest UI components in UIKit. In fact, UITableView <a id="_idIndexMarker534" class="calibre6 pcalibre pcalibre1"/>was there from the start, and UICollectionView was added four years later.</p>
			<p class="calibre3">Why is UITableView considered to be a fundamental component? The reason is apparent.</p>
			<p class="calibre3">Both UITableView and UICollectionView are specialized in displaying a significant<em class="italic"> amount of data</em> efficiently and straightforwardly.</p>
			<p class="calibre3">UITableView does more than that – it provides an interface for displaying items in a way suitable for <em class="italic">small screens</em>, including features like multi-selection, editing, headers, and footers. It became the primary way of displaying menus and data in many apps.</p>
			<p class="calibre3">Apple ensured a component style, UITableView, was carried over to SwiftUI from day one to keep this capability with us.</p>
			<h2 id="_idParaDest-153" class="calibre7"><a id="_idTextAnchor236" class="calibre6 pcalibre pcalibre1"/>“How does the queuing mechanism work in a UITableView, and what are some best practices for optimizing its performance?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Like several other questions we discussed earlier (for example – UIViewController life cycle), that’s <a id="_idIndexMarker535" class="calibre6 pcalibre pcalibre1"/>another go-no-go question you probably want <a id="_idIndexMarker536" class="calibre6 pcalibre pcalibre1"/>to make sure you are ready for. This question tests our understanding of the primary mechanism of UITableView that enables its efficiency and performance.</p>
			<p class="calibre3">The UITableView queuing mechanism is the foundation for many on-top features and issues we may encounter, such as async operations during scroll, optimizations, and state management.</p>
			<p class="calibre3">That mechanism is also the basis for additional controls such as UICollectionView and MKMapView.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The UITableView mechanism ensures efficiency and high performance when scrolling with a large amount of data.</p>
			<p class="calibre3">The main problem with displaying a large number of items is <em class="italic">memory</em>. Allocating so many views, most off-screen, creates a memory overload, eventually leading to app termination.</p>
			<p class="calibre3">What we want to do is to allocate only the views we see on the screen and release off-screen views while we are scrolling the list.</p>
			<p class="calibre3">But allocating new <a id="_idIndexMarker537" class="calibre6 pcalibre pcalibre1"/>views each time raises a <a id="_idIndexMarker538" class="calibre6 pcalibre pcalibre1"/>performance issue. If the user scrolls fast, allocating and creating new views takes a few milliseconds, which causes lags even when running on powerful devices.</p>
			<p class="calibre3">This lag is where the queuing solution comes into practice. Instead of deallocating the view when it goes off-screen, UITableView puts it in a deque pool and pulls it from where it needs to display a new view in the list.</p>
			<p class="calibre3">The queuing mechanism makes the UITableView scrolling fast and smooth. But dequeuing cells also creates <a id="_idIndexMarker539" class="calibre6 pcalibre pcalibre1"/>new problems, some of which are detailed here:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Working on an existing cell</strong>: Before we display the cell, we must remember it might already have existing information. We need to clear the cell after it moves out of the pool by calling the <strong class="source-inline1">prepareForReuse</strong> method or overriding its properties before we display it.</li>
				<li class="calibre11"><strong class="bold">Verify responses from async operations</strong>: A common issue in UITableViews is loading images async from a backend service. We start the request when the cell is being displayed, but when we get the response, the cell is already dequeued and connected to another entity. In this case, we need to ensure that the data we get in the response matches the current entity the cell is supposed to represent.</li>
				<li class="calibre11"><strong class="bold">Working with multiple pools</strong>: There are cases where we have numerous types of cells, probably based on different classes and UI. In this case, we need to create multiple deque pools, which we also need to handle and ensure.</li>
			</ul>
			<p class="calibre3">To summarize, UITableView provides an excellent mechanism to display big chunks of information but also brings us new issues we must handle.</p>
			<h2 id="_idParaDest-154" class="calibre7"><a id="_idTextAnchor237" class="calibre6 pcalibre pcalibre1"/>“What is pagination in UITableView, and how would you implement it to efficiently load and display large amounts of data while maintaining good performance and user experience?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">When we think of a UITableView, we imagine a contacts list or pizza recipes. But there are cases when it <a id="_idIndexMarker540" class="calibre6 pcalibre pcalibre1"/>either takes time to load the data or the list is so big that it creates a memory overload. For example – social media posts, images, and data from the backend. From our point of view – an infinite number of items.</p>
			<p class="calibre3">The interviewer wants to see how we handle a more complex situation than just displaying a closed list of items.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3"><strong class="bold">Pagination</strong> in a UITableView is a technique that involves loading and displaying data in small batches based on the table view scroll position.</p>
			<p class="calibre3">We use <a id="_idIndexMarker541" class="calibre6 pcalibre pcalibre1"/>pagination when we have a large amount of data, and loading everything simultaneously is inefficient. For example, if we have data from our backend or large images and videos stored in our persistent store.</p>
			<p class="calibre3">With pagination, we load the data we want to display on the screen (and a little bit more), and when the user keeps scrolling, we load “another page” of data. This technique of loading data on demand is much faster for initial loading, doesn’t create memory overload, and is much more efficient overall.</p>
			<p class="calibre3">However, pagination creates some other challenges we need to tackle, which are detailed here:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Decide the page loading trigger</strong>: To perform the additional loading operation, we need <a id="_idIndexMarker542" class="calibre6 pcalibre pcalibre1"/>to decide the loading trigger. For example, load more data when the user reaches the last visible row or a scrolling offset. Also, we need to ensure we are not sending multiple requests simultaneously since the trigger might be happening multiple times during that scroll.</li>
				<li class="calibre11"><strong class="bold">Showing a loading indicator</strong>: It is important to provide the user an indication there’s more data to view and is currently being loaded. It is common practice to show the indication in the last row at the bottom of the list.</li>
				<li class="calibre11"><strong class="bold">Load data in the background</strong>: To provide smooth scrolling without blocking the UI and creating lagging, we should load the data in a background thread using async functions, GCD, or <strong class="source-inline1">NSOperation</strong>.</li>
				<li class="calibre11"><strong class="bold">Handle the “no more data” use case</strong>: That may sound like a weird issue, but developers sometimes forget to handle it. When the user scrolls to the last item on the list, the trigger for loading more is activated. If the request returns empty, the trigger might be activated again because our list meets the trigger condition. In this case, the list will enter an infinite loop of trying to fetch data without a result. The <a id="_idIndexMarker543" class="calibre6 pcalibre pcalibre1"/>solution might be to use some temporary flag to avoid ongoing fetching.</li>
			</ul>
			<p class="calibre3">Pagination is a technique that has pros and cons and should be considered carefully. It involves both the backend and client and can provide high performance and good user experience but requires us to deal with more complex fetching patterns.</p>
			<h2 id="_idParaDest-155" class="calibre7"><a id="_idTextAnchor238" class="calibre6 pcalibre pcalibre1"/>“What are the different approaches for adjusting cell size in a UITableView, and how do you determine the optimal size for cells based on the content they will display?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Cell size in UITableView was always an issue for iOS developers, mainly when the need for accessibility and dynamic font size evolved over the years.</p>
			<p class="calibre3">This question <a id="_idIndexMarker544" class="calibre6 pcalibre pcalibre1"/>tests our knowledge of UITableView delegate, our ability to use Auto Layout with cells, and the tradeoffs we need to make between performance and simplicity.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There are <a id="_idIndexMarker545" class="calibre6 pcalibre pcalibre1"/>two ways to adjust a cell size:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Set a custom height for each row</strong>: Implement the <strong class="source-inline1">tableView(_:heightForRowAt:)</strong> delegate method that returns a different height for each row. In this way, we need to calculate the size of each row ourselves. It can be a constant size or according to the cell content. Calculating the cell size ourselves can be inaccurate if not done right, but it can be faster and more efficient in terms of performance when dealing with large datasets. Here’s an example of such an implementation:<pre class="source-code">
func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {    let cellData = dataSource[indexPath.row]    let height = cellData.text.height        (withConstrainedWidth:         tableView.frame.width - 32, font:          UIFont.systemFont(ofSize: 14))    return height + 16}</pre></li>			</ul>
			<p class="calibre3">In this code example, we pull the cell data according to its row index and calculate the size based on the UITableView size. We can see how error-prone this code snippet is, as it needs to be very accurate. But – since we are not using the Auto Layout system, it is much faster.</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Using self-size cells</strong>: The other option is to use self-size cells. In self-size cells, the cell’s height is <a id="_idIndexMarker546" class="calibre6 pcalibre pcalibre1"/>set automatically by its content, using Auto Layout constraints. Some things to notice here are as follows:<ul class="calibre18"><li class="calibre11">We must ensure a <em class="italic">continuous sequence of constraints</em> from top to bottom for the cell to get a valid intrinsic content size.</li><li class="calibre11">We need to ensure that the UITableView <strong class="source-inline1">rowHeight</strong> property is set to <strong class="source-inline1">automaticDimension</strong>.</li><li class="calibre11">We said that self-size cells are less efficient in terms of performance. To “help” UITableView measure its size, we can use the <strong class="source-inline1">estimatedRowHeight</strong> property or implement the corresponding <strong class="source-inline1">tableView(_:estimatedHeightForRow:)</strong> delegate method to provide a row <a id="_idIndexMarker547" class="calibre6 pcalibre pcalibre1"/>height estimation until the cell is shown on the screen.</li></ul></li>
			</ul>
			<p class="calibre3">The self-size cells <a id="_idIndexMarker548" class="calibre6 pcalibre pcalibre1"/>should be good enough for most cases, and it needs to be our go-to approach unless we encounter performance issues that will require us to set custom heights for cells.</p>
			<p class="calibre3">UITableView is a central topic in iOS development and interviews. The coding or the home assessment will probably include UITableView as a primary component. Make sure there are no mistakes with this control!</p>
			<h1 id="_idParaDest-156" class="calibre5"><a id="_idTextAnchor239" class="calibre6 pcalibre pcalibre1"/>Performing navigation well</h1>
			<p class="calibre3">Navigation is a <a id="_idIndexMarker549" class="calibre6 pcalibre pcalibre1"/>critical component in UIKit and iOS development. Navigation allows us to move the user from one UIViewController to another intuitively and simply.</p>
			<p class="calibre3">There are two ways of navigating the user to another screen:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Present a modal view controller</strong>: If we need to present a screen with a task to complete or to <a id="_idIndexMarker550" class="calibre6 pcalibre pcalibre1"/>make a decision, a view controller can present another view controller on top of it.</li>
				<li class="calibre11"><strong class="bold">Push another view controller</strong>: If we want to navigate the user down the app hierarchy to the next stage, we can push a new view controller to the stack. This technique requires a UINavigationController to handle the push and pop operations and provide a navigation bar to ease the transitions.</li>
			</ul>
			<p class="calibre3">Interviewers do not generally ask questions about the push and present, as these actions are fairly simple to understand and implement. Most questions and challenges are related to transitions, navigation bars, life cycle methods, and design patterns.</p>
			<h2 id="_idParaDest-157" class="calibre7"><a id="_idTextAnchor240" class="calibre6 pcalibre pcalibre1"/>“What is the purpose of the navigationItem property in a view controller, and how can you use it to customize the behavior and appearance of a navigation bar in iOS development?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">The <code>navigationItem</code> property is just that, a property. Why on earth is there a question about <a id="_idIndexMarker551" class="calibre6 pcalibre pcalibre1"/>a specific property?</p>
			<p class="calibre3">Well, that’s <a id="_idIndexMarker552" class="calibre6 pcalibre pcalibre1"/>because <code>navigationItem</code> holds an entire concept behind it. This question tests our ability to understand how the navigation controller works and the design concept of empowering view controllers to impact the navigation bar’s appearance, despite it being a component of the navigation controller.</p>
			<p class="calibre3">Generally, the way <code>navigationItem</code> and view controllers work is an interesting design pattern that can be used in other cases and is worth learning.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Every UIViewController has a property named <code>navigationItem</code>. That property contains several properties and methods used to customize the navigation bar’s behavior with data associated with the view controller itself.</p>
			<p class="calibre3">For example, <code>navigationItem</code> contains the <code>title</code> property, which is used to set the <em class="italic">current title</em> value displayed in the navigation bar.</p>
			<p class="calibre3">Other important items of information that can be set in <code>navigationItem</code> are the <em class="italic">left and right buttons</em>. Let’s see an example of how the view controller modifies the navigation bar using the <code>navigationItem</code> property:</p>
			<pre class="source-code">
class MyViewController: UIViewController {    override func viewDidLoad(_ animated: Bool) {
        super. viewDidLoad (animated)
        navigationItem.title = "My Title"
        let button = UIBarButtonItem(title: "Button", style: .plain, 
            target: self, action:#selector(buttonTapped))
            navigationItem.rightBarButtonItem = button
    }
    @objc func buttonTapped() {}
}</pre>
			<p class="calibre3">In our code example, the <code>navigationItem</code> property contains a title and a right bar button with the <code>"Button"</code> title. When the user navigates from that screen, the navigation <a id="_idIndexMarker553" class="calibre6 pcalibre pcalibre1"/>controller will get a new <code>navigationItem</code> property<a id="_idIndexMarker554" class="calibre6 pcalibre pcalibre1"/> from the next controller and update its navigation bar properties.</p>
			<p class="calibre3">It’s a technique that empowers the navigation controller to update its navigation bar based on the context of the visible view controller. Thinking further, we can use this technique in other cases as well.</p>
			<h2 id="_idParaDest-158" class="calibre7"><a id="_idTextAnchor241" class="calibre6 pcalibre pcalibre1"/>“What are some of the preset options for presenting a UIViewController in iOS, and why is it important to understand these options?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Presenting <a id="_idIndexMarker555" class="calibre6 pcalibre pcalibre1"/>a view controller <a id="_idIndexMarker556" class="calibre6 pcalibre pcalibre1"/>with another view controller is a familiar and straightforward task iOS developers do all the time.</p>
			<p class="calibre3">However, there are several ways of presenting a view controller. Each one of the options is suitable for a different use case and can influence the presenter’s view controller life cycle events.</p>
			<p class="calibre3">Our job is to explain the different options to the product team and select the one that fits our use case.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There are several preset options available to us. Each one influences the look and feel of the presented view controller.</p>
			<p class="calibre3">Let’s name some of them:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">Fullscreen</strong>: The presented view controller takes up the entire screen.</li>
				<li class="calibre11"><strong class="source-inline1">PageSheet</strong>: The presented view controller doesn’t fill the whole screen, and the screen can be pulled down using a simple swipe gesture.</li>
				<li class="calibre11"><strong class="source-inline1">overCurrentContext</strong>: The view controller is presented and hides the current view controller context.</li>
			</ul>
			<p class="calibre3">Obviously, the different types of presentations need to be suitable for the user experience we want to provide to our users. But we also must consider the influence of these types on the different life cycle events being fired.</p>
			<p class="calibre3">For example – if we use <code>viewWillDisappear</code> and <code>viewDidDisappear</code> of the presenting view controller <em class="italic">are not being called</em>. In Page Sheet, we assume the underlying view controller is still visible. Therefore, some life cycle events related to appearance are also not being called.</p>
			<p class="calibre3">In this case, we must <a id="_idIndexMarker557" class="calibre6 pcalibre pcalibre1"/>change how we <a id="_idIndexMarker558" class="calibre6 pcalibre pcalibre1"/>present the modal view controllers or communicate any changes or updates using a delegate pattern or Combine.</p>
			<p class="calibre3">The rule is simple – we need to adjust the preset option to the user experience we want to provide to our users. Do we hide the underlying screen? That’s a good starting question.</p>
			<h2 id="_idParaDest-159" class="calibre7"><a id="_idTextAnchor242" class="calibre6 pcalibre pcalibre1"/>“How would you design a navigation system for an iOS app using the coordinator pattern, where view controllers don’t decide where to go next, and a coordinator object is responsible for managing the navigation flow?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">That’s an <a id="_idIndexMarker559" class="calibre6 pcalibre pcalibre1"/>advanced question about navigation in iOS apps, and it’s not related directly to how to technically implement UINavigationController or present a view controller modally.</p>
			<p class="calibre3">This question deals with the separation of concerns principle and design patterns we can use in our <a id="_idIndexMarker560" class="calibre6 pcalibre pcalibre1"/>project to provide more flexibility and modularity.</p>
			<p class="calibre3">That’s one of the questions that doesn’t come with a school-ready answer, and you can think about your answer during your interview and discuss it with your interviewer. More important is to develop a set of principles and ideas for how to nail this challenge.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">A <strong class="bold">coordinator pattern</strong> is a <a id="_idIndexMarker561" class="calibre6 pcalibre pcalibre1"/>popular design pattern that separates the navigation logic from the UI.</p>
			<p class="calibre3">So, let’s discuss how to approach this question and decide on the basic principles we want to keep:</p>
			<ul class="calibre10">
				<li class="calibre11">The view controller (or its view model, for that matter) <em class="italic">doesn’t decide where to navigate</em> but only sends touch events</li>
				<li class="calibre11">We keep the navigation <em class="italic">logic in another class</em> called <strong class="source-inline1">Coordinator</strong></li>
				<li class="calibre11">We can create one <strong class="source-inline1">Coordinator</strong> for each view controller or a <strong class="source-inline1">Coordinator</strong> for a single flow</li>
				<li class="calibre11">The <strong class="source-inline1">Coordinator</strong> has a reference to the navigation controller and <em class="italic">can push or pop view</em> controllers as needed</li>
				<li class="calibre11">The <strong class="source-inline1">Coordinator</strong> needs to <em class="italic">observe events</em> that happen in the currently displayed view controller</li>
			</ul>
			<p class="calibre3">Based on these assumptions, we can imagine the following pattern (<em class="italic">Figure 7</em><em class="italic">.4</em>):</p>
			<div><div><img src="img/Figure_7.4_B18653.jpg" alt="Figure 7.4 – A coordinator pattern (suggestion)" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.4 – A coordinator pattern (suggestion)</p>
			<p class="calibre3">Notice this is just a suggestion, as this pattern is not set in stone.</p>
			<p class="calibre3">Here are some modifications we can suggest according to different project’s needs:</p>
			<ul class="calibre10">
				<li class="calibre11">If the <a id="_idIndexMarker562" class="calibre6 pcalibre pcalibre1"/>project becomes <a id="_idIndexMarker563" class="calibre6 pcalibre pcalibre1"/>more prominent, we can have <em class="italic">several coordinators</em> and sometimes even a hierarchy of coordinators.</li>
				<li class="calibre11">We can decide that the coordinator <em class="italic">observes state change</em> in the view model.</li>
				<li class="calibre11">We also don’t have to use observers for navigating but provide the view controller a <em class="italic">reference to the coordinator</em>. The view controller can send the coordinator what happened, and the coordinator can decide what to do next.</li>
			</ul>
			<p class="calibre3">We can play with the pattern if we keep the basic design principles and explain what we do well.</p>
			<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor243" class="calibre6 pcalibre pcalibre1"/>Empowering user experience with animations</h1>
			<p class="calibre3">Unlike what <a id="_idIndexMarker564" class="calibre6 pcalibre pcalibre1"/>many think, animations <a id="_idIndexMarker565" class="calibre6 pcalibre pcalibre1"/>in iOS are not for “fun”- they play a significant role in providing our app with a sleek and smooth experience. As a result, they are part of our developer’s tools set.</p>
			<p class="calibre3">Animation in <a id="_idIndexMarker566" class="calibre6 pcalibre pcalibre1"/>iOS relies on a framework called <strong class="bold">Core Animation</strong>, which is one of UIKit's dependencies. So, even <a id="_idIndexMarker567" class="calibre6 pcalibre pcalibre1"/>though this chapter <a id="_idIndexMarker568" class="calibre6 pcalibre pcalibre1"/>discusses UIKit, we can find Core Animation in many classes and methods in UIKit.</p>
			<h2 id="_idParaDest-161" class="calibre7"><a id="_idTextAnchor244" class="calibre6 pcalibre pcalibre1"/>Going over the core concepts of animation in UIKit</h2>
			<p class="calibre3">So, what do we <a id="_idIndexMarker569" class="calibre6 pcalibre pcalibre1"/>need to know about animations when practicing for an interview?</p>
			<p class="calibre3">We need to know several classes, terms, methods, and techniques. Let’s go over them before we move on to an advanced interview question.</p>
			<h3 class="calibre9">Performing UIView animations</h3>
			<p class="calibre3">UIView animations are <a id="_idIndexMarker570" class="calibre6 pcalibre pcalibre1"/>probably the <a id="_idIndexMarker571" class="calibre6 pcalibre pcalibre1"/>simplest animations we have in UIKit. In a UIView animation, we provide a closure with our final state, and UIKit runs the animation automatically. Let’s see a code example that takes a view and fades it out by changing its <code>alpha</code> value:</p>
			<pre class="source-code">
UIView.animate(withDuration: 0.3) {    myView.alpha = 0.0
}</pre>
			<p class="calibre3">We see a simple code that receives a duration and a closure and animates the changes inside the closure, in this case, changing the <code>myView</code> alpha property to <code>0.0</code>. Notice that Core Animation doesn’t animate all UIView properties. Here is the list of UIView animatable properties: <code>frame</code>, <code>bounds</code>, <code>center</code>, <code>transform</code>, <code>alpha</code>, <code>backgroundColor</code>, and <code>tintcolor</code>.</p>
			<h3 class="calibre9">Animating Auto Layout constraints changes</h3>
			<p class="calibre3">We need to <a id="_idIndexMarker572" class="calibre6 pcalibre pcalibre1"/>understand how to <a id="_idIndexMarker573" class="calibre6 pcalibre pcalibre1"/>animate constraints changes because it is not as straightforward as the other properties we modify. Constraints are part of the Auto Layout, and UIKit performs Auto Layout changes every run loop (every 16.67 milliseconds). This means we need to “force” Auto Layout to perform the changes inside the animation closure by calling the <code>layoutIfNeeded</code> method. Here’s an example of a constraints change of a view:</p>
			<pre class="source-code">
UIView.animate(withDuration: 0.5) {    myView.topAnchor.constraint(equalTo: superview.
        topAnchor, constant: 100).isActive = true
    superview?.layoutIfNeeded()
}</pre>
			<p class="calibre3">We can see that it’s <a id="_idIndexMarker574" class="calibre6 pcalibre pcalibre1"/>not enough to create <a id="_idIndexMarker575" class="calibre6 pcalibre pcalibre1"/>or modify the constraint within the animation closure. We also need to “force” the changes to happen on time; therefore, we call the <code>layoutIfNeeded</code> method.</p>
			<h3 class="calibre9">Playing with timing and easing</h3>
			<p class="calibre3">We can adjust the <a id="_idIndexMarker576" class="calibre6 pcalibre pcalibre1"/>animations to create what we want the user to <a id="_idIndexMarker577" class="calibre6 pcalibre pcalibre1"/>perceive using timing and easing. Timing means different <a id="_idIndexMarker578" class="calibre6 pcalibre pcalibre1"/>duration and delays, so we can have a longer or shorter animation. <code>springWithDamping</code> and <code>initialSpringVelocity</code> that can help us achieve even more customized animation easing. Let’s see an example of that:</p>
			<pre class="source-code">
UIView.animate(withDuration: 1.0,               delay: 0.0,
               usingSpringWithDamping: 0.5,
               initialSpringVelocity: 10.0,
               options: .curveEaseInOut,
               animations: {
                myView.transform = CGAffineTransform
                    (scaleX: 1.5, y: 1.5)
               },
               completion: nil)</pre>
			<p class="calibre3">We scale the <code>myView</code> size by modifying its <code>transform</code> property and doing that animatedly. We <a id="_idIndexMarker580" class="calibre6 pcalibre pcalibre1"/>can also see that we pass these two <a id="_idIndexMarker581" class="calibre6 pcalibre pcalibre1"/>important parameters:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">usingSpringWithDamping</strong>: This controls how much the spring effect is damped, with higher values resulting in less oscillation and a quick settling time</li>
				<li class="calibre11"><strong class="source-inline1">initialSpringVelocity</strong>: This controls the initial velocity of the animation, with higher values resulting in a faster start and a more substantial effect</li>
			</ul>
			<p class="calibre3">It’s important to play with these values to achieve the desired result.</p>
			<h3 class="calibre9">Building keyframe animations</h3>
			<p class="calibre3">For more <a id="_idIndexMarker582" class="calibre6 pcalibre pcalibre1"/>complex animations, we can use keyframe<a id="_idIndexMarker583" class="calibre6 pcalibre pcalibre1"/> animation. Keyframe animation allows us to create animations in stages or sequences. We can define the different stages and provide a relative duration and start time for each one of them. Here’s an example of a keyframe animation:</p>
			<pre class="source-code">
UIView.animateKeyframes(withDuration: 3.0, delay: 0.0,    options: [], animations: {
    UIView.addKeyframe(withRelativeStartTime: 0.0,
        relativeDuration: 0.5, animations: {
        view.transform = CGAffineTransform (rotationAngle: .pi / 2)
    })
    UIView.addKeyframe(withRelativeStartTime: 0.5,
        relativeDuration: 0.5, animations: {
        view.transform = CGAffineTransform.identity
    })
}, completion: nil)</pre>
			<p class="calibre3">How do we read this code block? It’s easy. The total animation duration is 3 seconds and is split into two sequences.</p>
			<p class="calibre3">The first sequence starts at the beginning (relative time 0) and takes half the total time (relative duration 0.5, meaning 1.5 seconds).</p>
			<p class="calibre3">The second sequence <a id="_idIndexMarker584" class="calibre6 pcalibre pcalibre1"/>starts in the middle of the <a id="_idIndexMarker585" class="calibre6 pcalibre pcalibre1"/>total animation time (relative time 0.5, meaning 1.5 seconds) and takes half of the animation time (relative duration 0.5, implying 1.5 seconds).</p>
			<p class="calibre3">The sequences don’t have to sync with each other, and it’s up to us to sync them if we need.</p>
			<h3 class="calibre9">Performing transitions between screens</h3>
			<p class="calibre3">UIKit allows <a id="_idIndexMarker586" class="calibre6 pcalibre pcalibre1"/>us to perform transitions <a id="_idIndexMarker587" class="calibre6 pcalibre pcalibre1"/>between screens, or to be precise, between UIViewControllers. We can pick one of the built-in transitions or even create our own transition.</p>
			<p class="calibre3">This is how we present a UIViewController with a dissolve animation:</p>
			<pre class="source-code">
let viewController = MyViewController()viewController.modalTransitionStyle = .crossDissolve
present(viewController, animated: true, completion: nil)</pre>
			<p class="calibre3">UIKit provides a short list of built-in animations that, in many cases, are not sufficient. Therefore, we have the option to create a custom animation and even an interactive animation.</p>
			<p class="calibre3">Now, in the context of an interview – just like many other topics, it is important to understand how the custom transition works. We are not required to remember every API’s detail, but <a id="_idIndexMarker588" class="calibre6 pcalibre pcalibre1"/>we need to know what we are capable of, what possibilities it opens up, and how to build it so it can be reused across our project.</p>
			<h3 class="calibre9">Manipulating CALayers</h3>
			<p class="calibre3">We touched <a id="_idIndexMarker589" class="calibre6 pcalibre pcalibre1"/>on CALayer earlier when we discussed UIView <a id="_idIndexMarker590" class="calibre6 pcalibre pcalibre1"/>but haven’t discussed its importance for us as iOS developers.</p>
			<p class="calibre3">We already know that iOS graphics is built with layers – UIViews (backed up with CALayers) and underneath we have Core Animation, which is built upon <strong class="bold">Metal</strong>.</p>
			<p class="calibre3">CALayers provides hardware-accelerated rendering components, which lets us manipulate graphics and perform sophisticated animations and image processing. We can also blend layers and add visual effects. Overall, CALayers help us to go down the graphics architecture and get closer to the hardware and the GPU to achieve more power and efficiency.</p>
			<p class="calibre3">Understanding the core concepts of animation techniques can help us achieve a better user experience. As iOS developers, we are expected to be familiar with the essential tools and classes to provide the desired animations our product team requires.</p>
			<p class="calibre3">Now let’s review an interesting interview question related to animation in UIKit.</p>
			<h2 id="_idParaDest-162" class="calibre7"><a id="_idTextAnchor245" class="calibre6 pcalibre pcalibre1"/>“How can you create custom transitions between UIViewControllers in an iOS app?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">We discussed <a id="_idIndexMarker591" class="calibre6 pcalibre pcalibre1"/>custom transitions a little earlier when we went over the animation core concepts, and this question tests our experience with the custom transition API. The Custom UIViewController transition API requires us to handle reusability, a deep understanding of how animations work, how view controllers work with each other, how to perform advanced techniques such as snapshotting, and how to implement a relatively complex UIKit API.</p>
			<p class="calibre3">Custom animation is considered an advanced topic<a id="_idTextAnchor246" class="calibre6 pcalibre pcalibre1"/>, and we should at least understand the basics of it.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">To create a custom transition between UIViewContr<a id="_idTextAnchor247" class="calibre6 pcalibre pcalibre1"/>ollers, we must implement the <code>UIViewControllerAnimatedTransitioning</code> protocol (any object can conform to that protocol).</p>
			<p class="calibre3">This protocol has two functions: <code>animateTransition(using:)</code> and <code>transitionDuration(using:)</code>.</p>
			<p class="calibre3">In <code>animateTransition(using:)</code>, we handle the view hierarchy, constraints changes, and animations.</p>
			<p class="calibre3">In <code>transitioDuration(using:)</code>, we return the duration in <code>TimeInterval</code>.</p>
			<p class="calibre3"><code>UIViewControllerAnimatedTransitioning</code> defines a transition, present or dismiss. To determine precisely what happens in each scenario, we must implement <code>UIViewControllerTransitionDelegate</code> to specify which object handles each use case.</p>
			<p class="calibre3">Once we do that, to <a id="_idIndexMarker592" class="calibre6 pcalibre pcalibre1"/>use our custom transition, we need to set the UIViewController <code>modalPresentationStyle</code> property to custom and the <code>transitionDelegate</code> property to the object that conforms to <code>UIViewControllerAnimatedTransitioning</code>.</p>
			<p class="calibre3">Since we have two different protocols to implement and things get a little complex here, let’s look at <em class="italic">Figure 7</em><em class="italic">.5</em> to understand how everything is related to each other:</p>
			<p class="calibre3"> </p>
			<div><div><img src="img/Figure_7.5_B18653.jpg" alt="Figure 7.5 – Custom UIViewController transition delegate" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Custom UIViewController transition delegate</p>
			<p class="calibre3">We can see that the leading role of <code>UIViewControllerTransitionDelegate</code> is to decide which object will handle the animation when presenting or dismissing the presented view controller. It’s worth saying that all three components can be the same object, and this is where the reusability concept comes in. If we want to be able to reuse our transitions across the project, we need to do two things:</p>
			<ol class="calibre15">
				<li class="calibre11">Separate the <em class="italic">different components</em> of different objects.</li>
				<li class="calibre11">When animating, reduce coupling between the presented/presenting view controller and the transitioning object <em class="italic">using protocols</em> and not explicitly the original view controller class. For example, suppose we are animating a view from one controller <a id="_idIndexMarker593" class="calibre6 pcalibre pcalibre1"/>to another. In that case, we shouldn’t use a direct reference to the view but rather a protocol with a <strong class="source-inline1">getView()</strong> method so that we can reuse that with another view controller.</li>
			</ol>
			<p class="calibre3">As we can see, transitioning between view controllers is a task that involves different techniques expected from a senior iOS developer. However, the concept needs to be done at least once to understand it fully.</p>
			<h1 id="_idParaDest-163" class="calibre5"><a id="_idTextAnchor248" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we discussed many crucial topics related to UIKit, such as UIView, UIViewController, UITableView, navigation, and animations. UIKit has a massive presence in iOS developers’ day-to-day work and significantly influences the user experience.</p>
			<p class="calibre3">But – UIKit is also considered the “old” UI framework. The iOS development world is transitioning to a new, more modern era of declarative programming.</p>
			<p class="calibre3">Our next chapter will handle just that – SwiftUI and declarative programming.</p>
		</div>
	</body></html>