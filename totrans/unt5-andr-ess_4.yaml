- en: Chapter 4. Animation, Audio, Physics, and Particle Systems in Unity 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn new Mecanim animation features and awesome new
    audio features in Unity 5\. At the end of this chapter, you will explore physics
    and particle systems in Unity 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in the chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: New Mecanim animation features in Unity 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New audio features in Unity 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics and particle system effects in Unity 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Mecanim animation features in Unity 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity 5 contains some new awesome possibilities for the Mecanim animation system.
    Let's look at the new shiny features known in Unity 5.
  prefs: []
  type: TYPE_NORMAL
- en: State machine behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you can inherit your classes from `StateMachineBehaviour` in order to
    be able to attach them to your Mecanim animation states. This class has the following
    very important callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStateEnter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStateUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStateExit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStateMove`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStateIK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StateMachineBehaviour` scripts behave like `MonoBehaviour` scripts, which
    you can attach on as many objects as you wish; the same is true for `StateMachineBehaviour`.
    You can use this solution with or without any animation at all.
  prefs: []
  type: TYPE_NORMAL
- en: State machine transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity 5 introduced a new awesome feature for Mecanim animation systems known
    as state machine transitions in order to construct a higher abstraction level.
    In addition, entry and exit nodes were created. By these two additional nodes
    to `StateMachine`, you can now branch your start or finish state depending on
    your special conditions and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These mixes of transitions are possible: `StateMachine` | `StateMachine`, `State`
    | `StateMachine`, `State` | `State`.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you also can reorder your layers or parameters. This is the new
    UI that allows it by a very simple and useful drag-n-drop method.
  prefs: []
  type: TYPE_NORMAL
- en: Asset creation API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more awesome possibility in Unity 5 was introduced using scripts in Unity
    Editor in order to programmatically create assets, such as layers, controllers,
    states, `StateMachine`, and blend trees. You can use different solutions with
    a high-level API provided by Unity engine maintenance and a low-level API, where
    you should manage all your assets manually. You can find more about both API versions
    on Unity documentation pages.
  prefs: []
  type: TYPE_NORMAL
- en: Direct blend tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another new feature that was introduced with the new `BlendTree` type is known
    as direct. It provides direct mapping and animator parameters to the weight of
    `BlendTree` children.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Possibilities with Unity 5 have been enhanced with two useful features for
    Mecanim animation system:'
  prefs: []
  type: TYPE_NORMAL
- en: Camera can scale, orbit, and pan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access your parameters in runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically creating assets by Unity 5 API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code snippets are self-explanatory, pretty simple, and straightforward.
    I list them just as a very useful reminder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a controller you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adding parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add parameters to the controller, you can use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Adding state machines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add state machines, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add states, you can use the code given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add transitions, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Going deeper into new audio features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with new amazing Audio Mixer possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can do true submixing of audio in Unity 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see a very simple example with different sound
    categories required in a game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Going deeper into new audio features](img/9191OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now in Unity 5, you can mix different sound collections within categories and
    tune up volume control and effects only once in a single place so that you can
    save a lot of time and effort. This new awesome audio feature in Unity 5 allows
    you to create a fantastic mood and atmosphere for your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Audio Mixer can have a hierarchy of AudioGroups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Going deeper into new audio features](img/9191OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Audio Mixer can not only do a lot of useful things, but also mix different
    sound groups in one place. Different audio effects are applied sequentially in
    each AudioGroup.
  prefs: []
  type: TYPE_NORMAL
- en: Now you're getting closer to the amazing, awesome, and shiny new features in
    Unity 5 for audio system! A callback script `OnAudioFilterRead`, which made possible
    the processing of samples directly into their scripts, previously was handled
    exclusively by the code.
  prefs: []
  type: TYPE_NORMAL
- en: Unity now also supports custom plugins to create different effects. With these
    innovations, Unity 5 for audio system now has its own applications synthesizer,
    which has become much easier and more flexible than possible.
  prefs: []
  type: TYPE_NORMAL
- en: Mood transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the mood of the game can be controlled with a mix of sound.
    This can be achieved with the involvement of new stems and music or ambient sounds.
    Another common way to accomplish this is to move the state of the mixture. A very
    effective way of taking mood where you want to go is by changing the volume section's
    mixture and transferring it to the different states of effect parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Inside, everything is the Audio Mixer's ability to identify pictures. Pictures
    capture the status of all parameters in Audio Mixer. Everything from investigative
    wet levels to AudioGroup tone levels can be captured and moved between the various
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mood transitions](img/9191OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can even create a complex mixture of states between a whole bunch of pictures
    in your game, creating all kinds of possibilities and goals.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine installing all these things without having to write a line of code to
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: Physics and particle system effects in Unity 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physics for 2D and 3D in Unity are very similar, because they use the same concepts
    like Ias rigidbodies, joints, and colliders. However, Box2D has more features
    than Unity's 2D physics engine. It is not a problem to mix 2D and 3D physics engines
    (built-in, custom, third-party) in Unity. So, Unity provides an easy development
    way for your innovative games and applications.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to develop some real-life physics in your project, then you should
    not write your own library, framework, or engine, except specific requirements.
    However, you should try existing physics engines, libraries, or frameworks with
    many features already made.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start our introduction into Unity's built-in physics engine. In the case
    that you need to set your object under Unity's built-in physics management, you
    just need to attach the Rigidbody component to this object. After that, your object
    can collide with other entities in its world and gravity will have an affect on
    it. In other words, Rigidbody will be simulated physically. In your scripts, you
    can move any of your Rigidbodies by adding vector forces to them.
  prefs: []
  type: TYPE_NORMAL
- en: It is not recommended to move the Transform component of a non-kinematic Rigidbody,
    because it will not collide correctly with other items. Instead, you can apply
    forces and torque to your Rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: A Rigidbody can be used also to develop cars with wheel colliders and with some
    of your scripts to apply forces to it. Furthermore, a Rigidbody is used not *only*
    for vehicles, but also you can use it for any other physics issues such as airplanes,
    robots with various scripts for applying forces, and with joints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful way to utilize a Rigidbody is to use it in collaboration with
    some primitive colliders (built-in in Unity) such as `BoxCollider` and `SphereCollider`.
    Next, we will show you two things to remember about Rigidbody:'
  prefs: []
  type: TYPE_NORMAL
- en: In your object's hierarchy, you must never have a child and its parent with
    the Rigidbody component together at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not recommended to scale Rigidbody's parent object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most important and fundamental components of physics in Unity is
    a Rigidbody component. This component activates physics calculations on the attached
    object. If you need your object to react to collisions( for example, while playing
    billiards, balls collide with each other and scatter in different directions)
    then you must also attach a `Collider` component on your GameObject. If you have
    attached a Rigidbody component to your object, then your object will move through
    the physics engine, and I recommend that you do not move your object by changing
    its position or rotation in the `Transform` component. If you need some way to
    move your object, you should apply the various forces acting on the object so
    that the Unity physics engine assumes all obligations for the calculation of collisions
    and moving dynamic objects. Also, in some situations, there is a need for a Rigidbody
    component, but your object must be moved only by changing its position or rotation
    properties in the `Transform` component. It is sometimes necessary to use components
    without Rigidbody calculating collisions of the object and its motion physics.
    That is, your object will move by your script or, for example, by running your
    animation. In order to solve this problem, you should just activate its `IsKinematic`
    property. Sometimes, it is required to use a combination of these two modes when
    `IsKinematic` is turned on and when it is turned off. You can create a symbiosis
    of these two modes, changing the `IsKinematic` parameter directly in your code
    or in your animation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing the `IsKinematic` property very often from your code or from your animation
    can be the cause of overhead in your performance. Therefore, you should use it
    very carefully and only when you really need it.
  prefs: []
  type: TYPE_NORMAL
- en: A kinematic Rigidbody object is defined by the `IsKinematic` toggle option.
    If a Rigidbody is `Kinematic`, this object will not be affected by collisions,
    gravity, or forces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a Rigidbody component for 3D physics engine and an analogous Rigidbody2D
    for 2D physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: A kinematic Rigidbody can interact with other non-kinematic Rigidbodies. In
    the event of using kinematic Rigidbodies, you should translate their positions
    and rotation values of the `Transform` component by your scripts or animations.
    When there is a collision between Kinematic and non-kinematic Rigidbodies, then
    the Kinematic object will properly wake up non-kinematic Rigidbody. Furthermore,
    the first Rigidbody will apply friction to the second Rigidbody if the second
    object is on top of the first object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list some possible usage examples of kinematic Rigidbodies:'
  prefs: []
  type: TYPE_NORMAL
- en: There are situations when you need your objects to be under physics management,
    but sometimes to be controlled explicitly from your scripts or animations. As
    an example, you can attach Rigidbodies to the bones of your animated personage
    and connect them with joints in order to utilize your entity as a ragdoll. If
    you are controlling your character by Unity's animation system, you should enable
    the `IsKinematic` checkbox. Sometimes you may require your hero to be affected
    by Unity's built-in physics engine if you are hitting the hero. In this case you
    should disable the `IsKinematic` checkbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a moving item that can push different items, yet not by itself.
    In case you have a moving platform and you need to place some Rigidbody objects
    on top, you ought to enable the `IsKinematic` checkbox rather than simply attaching
    a collider without a Rigidbody.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to enable the `IsKinematic` property of your Rigidbody object that
    is animated and has a genuine Rigidbody follower by utilizing one of the accessible
    joints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Earlier, I mentioned the collider, but now is the time to discuss this component
    in more detail. In the case of Unity, the physics engine can calculate collisions.
    You must specify geometric shapes for your object by attaching the `Collider`
    component. In most cases, the collider does not have to be the same shape as your
    mesh with many polygons. Therefore, it is desirable to use simple colliders, which
    will significantly improve your performance, otherwise with more complex geometric
    shapes you risk significantly increasing the computing time for physics collisions.
    Simple colliders in Unity are known as primitive colliders: `BoxCollider`, `BoxCollider2D`,
    `SphereCollider`, `CircleCollider2D`, and `CapsuleCollider`. Also, no one forbids
    you to combine different primitive colliders to create a more realistic geometric
    shape that the physics engine can handle very fast compared to `MeshCollider`.
    Therefore, to accelerate your performance, you should use primitive colliders
    wherever possible. You can also hang on to the child objects of different primitive
    colliders, which will change its position and rotation, depending on the parent
    `Transform` component. The Rigidbody component must be attached only to the GameObject
    root in the hierarchy of your entity.'
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides a `MeshCollider` component for 3D physics and a `PolygonCollider2D`
    component for 2D physics. The `MeshCollider` component will use your object's
    mesh for its geometric shape. In `PolygonCollider2D`, you can edit directly in
    Unity and create any 2D geometry for your 2D physical computations. In order to
    react in collisions between different mesh colliders, you must enable a `Convex`
    property. You will certainly sacrifice performance for more accurate physics calculations,
    but if you have the right balance between quality and performance, then you can
    achieve good performance only through a proper approach.
  prefs: []
  type: TYPE_NORMAL
- en: Objects are static when they have a `Collider` component without a Rigidbody
    component. Therefore, you should not move or rotate them by changing properties
    in their `Transform` component, because it will leave a heavy imprint on your
    performance as a physics engine should recalculate many polygons of various objects
    for right collisions and ray casts. Dynamic objects are those that have a Rigidbody
    component. Static objects (attached with the `Collider` component and without
    Rigidbody components) can interact with dynamic objects (attached with `Collider`
    and Rigidbody components). Furthermore, static objects will not be moved by collisions
    like dynamic objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, Rigidbodies can sleep in order to increase performance. Unity provides
    the ability to control sleep in a Rigidbodies component directly in the code using
    following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rigidbody.IsSleeping()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rigidbody.Sleep()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rigidbody.WakeUp()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two variables characterized in the physics manager. You can open
    physics manager right from Unity menu here: **Edit** | **Project Settings** |
    **Physics**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rigidbody.sleepVelocity`: The default value is `0.14`. This indicates lower
    limitations for linear velocity (from zero to infinity) below which objects will
    sleep.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rigidbody.sleepAngularVelocity`: The default value is `0.14`. This indicates
    lower limitations for angular velocity (from zero to infinity) below which objects
    will sleep.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rigidbodies awaken when:'
  prefs: []
  type: TYPE_NORMAL
- en: An alternate Rigidbody impacts the resting Rigidbody
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternate Rigidbody was joined through a joint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the point of adjusting a property of the Rigidbody
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the point of adding force vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A kinematic Rigidbody can wake the other sleeping Rigidbodies while static objects
    (attached with a `Collider` component and without a Rigidbody component) can't
    wake your sleeping Rigidbodies.
  prefs: []
  type: TYPE_NORMAL
- en: The PhysX physics engine which is integrated into Unity works well on mobile
    devices, but mobile devices certainly have far fewer resources than powerful desktops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few points to optimize the physics engine in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, note that you can adjust the `Fixed Timestep` parameter in the
    time manager in order to reduce costs for the physical execution time updates.
    If you increase the value, you can increase the quality and accuracy of physics
    in your game or in your application, but you will lose the time to process. This
    can greatly reduce your productivity, or in other words, it can increase CPU overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum allowed timestep indicates how much time will be spent in the worst
    case for physical treatment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total processing time for physics depends on the awake rigidbodies and colliders
    in the scene, as well as the level of complexity of the colliders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity provides the ability to use physical materials for setting various properties
    such as friction and elasticity. For example, a piece of ice in your game may
    have very low friction or equal to zero (minimum value), while a jumping ball
    may have a very high friction force or equal to one (maximum value) and also very
    high elasticity. You should play with the settings of your physical materials
    for different objects and choose the most suitable solution for you and the best
    solution for your performance.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers do not require a lot of processing costs by the physics engine and
    can greatly help in improving your performance. Triggers are useful in situations
    where, for example, in your game you need to identify areas near all lights that
    are automatically turned on in the evening or night if the player is in its trigger
    zone or in other words within the geometric shape of its collider, which you can
    design as you wish. Unity triggers allow writing the three callbacks, which will
    be called when your object enters the trigger, while your object is staying in
    trigger, and when this object leaves the trigger. Thus, you can register any of
    these functions, the necessary instructions, for example, turn on the flashlight
    when entering the trigger zone or turn it off when exiting the trigger zone. It
    is important to know that in Unity, static objects (objects without a Rigidbody
    component) will not cause your callbacks to get into the zone trigger if your
    trigger does not contain a Rigidbody component; that is, in other words at least
    one of these objects must have a Rigidbody component in order to not ignore your
    callbacks. In the case of two triggers, there should be at least one object attached
    with a Rigidbody component to your callbacks were not ignored. Remember that when
    two objects are attached with Rigidbody and `Collider` components and if at least
    one of them is the trigger, then the trigger callbacks will be called and not
    the collision callbacks. I would also like to point out that your callbacks will
    be called for each object included in the collision or trigger zone. Also, you
    can directly control whether your collider is a trigger or not by setting the
    flag `isTrigger` value to `true` or `false` in your code. Of course, you can mix
    both options in order to obtain the best performance. All collision callbacks
    will be called only if at least one of two interacted rigidbodies is not kinematic.
    I suggest you consider code samples for collision callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example callback, which will be called at the start of the collision
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example callback, which will be called while staying in the collision
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The third example callback, which will be called at the end of the collision
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth example callback, which will be called at the start of the collision
    event is much more optimized because it avoids a collision input parameter and
    thus avoids extra calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The fifth example callback, which will be called while staying in the collision
    state is much more optimized because it avoids a collision input parameter and
    thus avoids extra calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The sixth example callback, which will be called at the end of the collision
    event is more optimized because it avoids the collision input parameter and thus
    avoids extra calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The seventh example callback, which will be called on entering the trigger
    collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The eighth example callback, which will be called while staying in the trigger
    collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The ninth example callback, which will be called on exiting the trigger collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The tenth example callback, which will be called on entering the trigger without
    the collider input parameter. This callback will be faster than with the collider
    input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The eleventh example callback, which will be called on the enter trigger without
    the collider input parameter. This callback will be faster than with the collider
    input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The twelfth example callback, which will be called on exiting the trigger without
    the collider input parameter. This callback will be faster than with the collider
    input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's talk about joints. If you need to attach one Rigidbody to another
    Rigidbody in order to rotate it around a specific point and axis, for example
    a hinged door, then you should use HingeJoint (for 2D appropriate name is HingeJoint2D).
    Unity also provides other types of joints; for example, spring joint is suitable
    in cases when you need to develop a trampoline or something similar. However,
    I strongly advise you not to use joints everywhere because that can ruin your
    performance. Use only what is truly necessary and as often as is really required.
    The most important thing to improve your performance is to remove all unnecessary
    things.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use a `CharacterController` component for creating a first person
    game. The `CharacterController` component uses its own physics calculations separately
    from Rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are very convenient for walking on different surfaces around the *y*
    axis without rotation and maintaining the necessary balance in the case of a Rigidbody
    component. The `CharacterController` component also requires much less processing
    time compared to a Rigidbody. That''s why you should try to use `CharacterController`
    whenever possible instead of Rigidbody, but try to make as few as possible like
    everything else. The `CharacterController` component has `CapsuleCollider`, which
    contains upwards along the *y* axis. Next, you will research the `CharacterController`
    properties as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics and particle system effects in Unity 5](img/9191OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Particle system performance tips and tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A particle system uses a large number of small particles or, in other words,
    a huge amount of graphical objects in order to create different effects such as
    dust, rain, snow, fire, explosions, smoke, a waterfall, falling leaves, fog, stars,
    galaxies, fireworks, various magic effects, and so on. Usually a particle system
    emits a plurality of particles, which have their own life-time, after which they
    disappear gradually and are re-emitted. There are also different techniques of
    using a particle system to create fur, hair, grass, where the particles do not
    disappear, but they live for a very long time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Particle systems may be 2D or 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, each particle is represented as a point mass with additional
    attributes, such as appearance, speed, orientation in space, angular velocity,
    and so on. In the course of the program, each particle changes its state with
    a specific formula, common to all particles in the system. For example, the particle
    may be exposed to gravity, to change its size, color, speed, and so on. After
    all calculations, the particle will be visualized. A particle can be visualized
    by point, triangle, sprite, or even a full three-dimensional model.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there is no uniform implementation of particle systems. In different
    games and apps, 3D modeling properties, behavior, and appearance of the particles
    may be fundamentally different.
  prefs: []
  type: TYPE_NORMAL
- en: In most implementations, new particles are emitted by a so-called **emitter**.
    If the emitter is a point, the new particles will then occur in the same place.
    Therefore, it is possible to simulate, for example, an explosion—the emitter is
    its center. An emitter can be a line, segment, or a plane; for example rain or
    snow particles should occur at high horizontal planes. The emitter may have an
    arbitrary geometrical object, and in this case, the new particles will emerge
    on the entire surface thereof.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the lifetime of the particle, the particle is rarely static. Particles
    can move, rotate, change color and/or transparency, and may deal with three-dimensional
    objects. Often, particles set the maximum life span, after which the particle
    disappears.
  prefs: []
  type: TYPE_NORMAL
- en: In three-dimensional, real-time applications or computer games it is generally
    considered that the particles do not cast shadows on one another and on the geometry
    of the environment and they do not absorb and emit light. Without these, the simplified
    particle system will require more resources; in the case of absorption of light,
    the particles need to be sorted by distance from the camera, and in the case of
    each particle shadows have to paint several times.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy versus Shuriken Unity's built-in particle systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of Shuriken's module's properties cannot be achieved in your scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the same time, the Legacy particle system's properties can be achieved in
    your scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can turn `emission` on and off as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In event of emitting particles in explosions, you should use the `Emit` function
    as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of activating and deactivating the `emission` property, you can also
    control the particles in your emitter as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s list obtainable properties of the `Particle` class ([http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html](http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`lifetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startLifetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`position`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`velocity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`randomValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angularVelocity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating the Shuriken particle system in Unity is very simple. You just need
    to navigate to **GameObject** | **Create Other** | **Particle Systems**. This
    will create an instance of the Shuriken Particle System for you to play with.
  prefs: []
  type: TYPE_NORMAL
- en: To make a Legacy particle system, you have to make a `void` GameObject or join
    the Legacy particle system to an accessible GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Particle system tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are numerous things that can kill the frame rate in an up-to-date game,
    and particles are up close to the highest on the rundown of reasons. A key component
    is that particles are liable to a great deal of overdraw that is not displayed
    in your opaque geometry.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose behind the increment in overdraw is that for particles, we have
    a tendency to have heaps of distinctive primitives (typically quads) that are
    covered, maybe to copy impacts like flame or smoke. Regularly, every particle
    primitive is translucent (alpha-mixed), so the z-buffer is not overhauled as pixels
    are composed and we wind up rendering to pixels at different times. (Interestingly,
    for hazy geometry, we do keep in touch with the z-buffer, so between a conceivable
    z-prepass, sorting items front-to-back, progressive z-culling on the GPU, and
    ordinary profundity testing, the effect is that we have almost no overdraw.)
  prefs: []
  type: TYPE_NORMAL
- en: Overdraw, thus, prompts expanded employments of both `fillrate` (how many pixels
    the fittings can render to for every second) and `bandwidth` (how much information
    you can exchange to/from the GPU for every second), both of which may be rare
    assets.
  prefs: []
  type: TYPE_NORMAL
- en: We concur that particles can result in a considerable measure of issues. Luckily,
    there are heaps of things that are able to improve the rendering side of a particle
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use opaque particles**: For example, make smoke effects truly thick so that
    (some or the sum of) the molecule boards will be obscure, with set pattern alpha.
    For a few particles, in the same way as shrapnel, rocks, or comparable objects,
    use lightweight geometry particles rather than sprites with alpha borders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use wealthier particles**: Put more oomph in a solitary molecule sprite so
    that you require fewer of them. Use flip book surfaces to make surging in for
    example fire and smoke, instead of stacking sprites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Top aggregate sum of particles**: Use fittings counters on the graphics card
    to obtain the number of particle pixels that have been rendered, and quit discharging
    or drawing particles when passing a certain breaking point (which may be set dynamically).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decrease state changes**: Share shaders between particles. You can get this
    by, for example, dropping characteristics for far off particles (for example,
    dropping the normal map at the earliest opportunity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make particles front-to-back premultiplied-alpha style**: Using premultiplied
    alpha (which is cooperative), you can mix particles front-to-back rather than
    the ordinary back-to-front requesting. The thought here is to utilize the front-to-back
    attracting to fill a stencil buffer when alpha gets (close) strong and at last,
    quit drawing particles all together (when they generally won''t help the visual
    scene much).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bunch particles together into one molecule entity**: Instead of drawing two
    covering particles separately, you can structure a solitary (bigger) molecule
    that incorporates the two particles and performs the mixing of the two particles
    in a staightforward manner in the shader. This has a tendency to decrease the
    measure of the frame buffer understands we do, as we just need to mix one molecule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered new Mecanim animation features in Unity 5\. You were introduced
    to the new awesome audio features in Unity 5\. At the end of this chapter, you
    explored physics and particle systems in Unity 5\. In this chapter, you covered
    many useful details for your performance within Unity built-in physics and particle
    systems. You explored Rigidbodies and different tips and tricks tied with it.
    You learned about kinematic and sleeping Rigidbodies, colliders, static colliders,
    primitive colliders, physics materials, triggers, joints, character controller,
    interactive cloth, and a lot of other useful physics definitions, details, notes,
    tips, and tricks. You also learned a lot about the particle system tips and tricks
    and how to create a simple pooling system for any of your objects.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will include an overview about asset bundles in Unity 5\. You
    will also learn how to download new code and data in real-time for Android devices.
    At the end of this chapter, you will discover the safeness technique of the asset
    bundles in practice.
  prefs: []
  type: TYPE_NORMAL
