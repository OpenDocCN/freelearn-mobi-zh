- en: Chapter 9. Real-world Physics with Box2D
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've already worked on games before, you should be familiar with Box2D.
    It's a multiplatform physics library that is broadly used across the gaming community.
    You'll find it really easy to work with it and get nice-looking physics pretty
    quickly, but this doesn't mean you have to create another *Angry Birds* clone,
    hint hint.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating the world
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create the world that will be in charge of the physics
    simulation by following the given steps:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `physics_manager.lua` and `require` it from `game.lua`.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's build the `PhysicsManager` module.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first step is to create the `MOAIBox2DWorld`object. This will take care
    of talking to Box2D from Moai SDK.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, we need to set up our scale. What we're doing here is saying that one
    meter on the simulation is equivalent to 38 points in our world coordinates. Since
    we're using a main character sprite that is 64 points tall, we can say that our
    character could be about 1.67 meters tall. So, 65 / 1.67 is about 38\. That's
    the calculation needed in order to find that scale.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Box2D works better on simulations that contain bodies that go from 0.1 to 10
    meters, so take that into account when setting this scale.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Here we're setting the gravity. The parameter is how many meters per second
    in `x` and `y` our objects get affected. So, for this example, we're using a gravity
    that is similar to the one on Earth (which is -9.8 mts / (s * s), so we can safely
    use -10).
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally we start the simulation:'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Normally, we don't want to see the objects that Box2D creates on our screen;
    we just want them to be connected to our own rendered objects and make them behave
    according to the simulation. But, for debugging purposes, having the physics objects
    displayed on screen can be pretty handy. If you pass a layer to the `initialize`
    method, it will use it as a debug layer to display the objects you create on Box2D.
    You'll see the actual shapes of the physics objects, and their colors will change
    when they collide with each other.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it. We have our world working! Now it's time to have a little talk about
    bodies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Box2D body types
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole point of using a physics engine is to create a world where you put
    objects (bodies) that behave according to physics laws. The term `body` is highly
    based on physics literature, where all the objects that interact are called bodies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of bodies in Box2D: static, kinematic, and dynamic. They
    are explained as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Static bodies**: You can think of these as bodies that are fixed to the world.
    They don''t move on their own, and they are not affected by gravity or collisions.
    Keep in mind that static bodies are able to collide with other objects, but they
    will not move or change as a result of the collision, just as the other objects
    (if they''re not static). We''ll use static bodies as platforms in our game, for
    our player to stand on.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kinematic bodies**: These bodies are not affected by collisions or gravity
    either, but they can move on their own. They can affect other objects during collisions,
    as statics bodies do. A simple moving platform hazard should probably be implemented
    using a kinematic body.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic bodies**: These are affected by gravity, collisions, and can move
    on their own. We''ll be using these to make our character and enemies move and
    collide. You can always set these bodies to ignore some force effects.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know a little bit more about bodies, let's add the floor to our
    game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, append the following code to `World:initialize()`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we create a static body using `addBody` from `MOAIBox2DWorld`. We then
    use the method `setTransform` to place it. We center it in the `X` axis and place
    it at the bottom of the screen in the `Y` axis.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After this we need to define the shape of the object (called fixture in the
    context of Box2D). We can use multiple kinds of shapes, and even combine them
    to create objects that are more complex. In this example, we're creating a rectangular
    object that has a width equal to the screen size and height equal to 100\. The
    way we define these rectangles follows the convention of the rectangles on images,
    with the center at `(0,0)` on model coordinates.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then we define that we don't want friction on the floor. This will stop our
    player from slowing down when running.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need to initialize our world in `game.lua` in order to render something
    to the screen. Just copy the following code below the call to `loadBackground`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What we're doing here is using the `walkBehind` layer as a parameter for debugging
    purposes. If you don't want to see the objects that are created, just avoid passing
    the layer and you won't see them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now run the game and you should see a box in the bottom. That's our floor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Character versus the world
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we want to make the main character interact with our world.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add some new methods to the `Character` module as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'First we create an object to store our body and shapes as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we add a dynamic body to the physics simulation. This will be the body
    of our character as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we position the body using the same initial position that we used for our
    rendered character as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we add a shape. We'll use a square that's the same size as the sprite (64
    x 64 ). This is obviously far from ideal, because collisions may seem strange
    in some cases (it will feel like there was a transparent box around him), but
    in order to keep it simple, we can live with that.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Character versus the world](img/5064_09_01.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the preceding image, we see the character and a platform with the Box2D debug
    on them. We can see that the player should be falling, but it doesn't because
    its box is too big.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You may want to create a better shape in your final game, in order to have better
    collision detection, but keep in mind that if the collision shape is more complex,
    it'll need more calculations when colliding. Always try to minimize the amount
    of vertices and edges of your fixtures.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last step is to bind our `prop` with our `body`. To do so, we'll use the
    `setParent` method, which tells the Action Tree that the physics body affects
    the `prop` when moving. This is a great example demonstrating the power of the
    Action Tree.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you hit play now, the character should be falling due to gravity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Movement
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's get right into the important stuff. First we'll define a couple of
    methods on `Character`. Then we'll rebuild `InputManager` to handle key events
    instead of mouse events and integrate that with our game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The first method we're going to use will make our character run. It will be
    called when we press the *A* or *D* keys, moving left or right respectively. We'll
    pass it two parameters, `direction` (`-1` for left, `1` for right) and `keyDown`,
    which is a Boolean value that tells us if the player is pressing the key.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we do is use the `direction` parameter in combination with `setScl`
    (used to scale objects). The idea is that if you scale a sprite by a negative
    factor, it flips in the direction of the scaled component, so what we're doing
    here is telling our sprite to face left or right according to what key the player
    pressed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we force the linear velocity by 100 in the specified direction and keep
    the velocity on the vertical axis, since we want to be able to jump and move while
    jumping:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then if we''re not already running and we''re not jumping, we start the run
    animation as following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If this event was `keyUp` and we were not jumping, then stop moving. This is
    buggy, you should have a better logic here that keeps the state of the different
    keys, but to keep it simple we can live with it. And that''s it, our `Character`
    can now run:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The two methods are really simple. If we move left, we call run with `-1` as
    the direction; if we move right, we call run with `1` as the direction. In either
    case, we pass the `keyDown` we receive. This `keyDown` will be obtained from the
    `InputManager` later.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What we do to stop moving is (after checking that we''re not jumping) stop
    all the movement, setting the linear velocity to 0 in both directions and start
    the idle animation. This is pretty simple:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the jump, we're going to do something different. Instead of forcing the
    linear velocity, we'll apply a force. We could do this in the same way, but just
    in order to illustrate how to apply forces, we'll use it here. Then we set a variable
    called jumping to true; this will allow us to know that we're jumping, and finally
    start the jump animation. This is easy as well.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we''ll implement the `stopJumping` method. We basically set jumping
    to false and stop moving as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our last method will be the one used to handle collisions with the floor. In
    order to use it, we need to add a line to `initializePhysics`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What we''re doing now is setting up a `callback` method that will be executed
    when Box2D detects a collision with the player''s shape. The parameters are the
    method itself, and which phase of the collision it should be called in is defined
    as following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To check all the collision phases, take a look at the `setCollisionHandler`
    definition at [http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20](http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to create the `callback` method:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'What we do now is check that the shape that we''re colliding with is the floor,
    if it is, then we stop jumping as follow:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Keyboard input
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll have to change a couple of things in order to start using the keyboard:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to remove our `processInput` method and the call to on
    `Game:start` in `game.lua`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we need to create a method that will be in charge of managing the key input
    from `InputManager`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method maps some key presses with the methods we created on `Character`.
    This should be enough to handle the movement of our character.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we''ll have to remove all the code (except the module definition) from
    `input_manager.lua` and rewrite it using the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`onKeyboardEvent` will be our keyboard callback. What we do here is just use
    the key code of *A*, *D*, and *W*, replace them with a readable string, and pass
    them as parameters to `keyPressed`, the method we implemented previously.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now it's only a matter of setting the callback and we're done.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try running the game now. You should be able to move the character around and
    jump using *A*, *D*, and *W*.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the scene
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll now create the necessary code to define a level. We won't be messing with
    sprites for it; instead we'll just use the default debug shapes from Box2D. We'll
    create the entire physical world, and you should now be able to assign sprites
    to it (it's the same as what we did with the player).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to remove all the code that relates to the floor definition
    in `physics_manager.lua`, since now we'll be creating the floor with the rest
    of the platforms.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, on `game.lua`, just below the `background_objects` definitions, we''ll
    create a definition for the scene:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you may see in the given code, we're defining two objects, namely, a floor
    and a platform. To each object we define its body type, its position, and size.
    Note that the floor is now just another scene object.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re now going to iterate through that table and create all the objects in
    one single piece of code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We start iterating through all the `scene_objects`:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here we create the Box2D body, using the type in the definition:'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then we set the size and position.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And finally the friction.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then we store the object under the defined name and we're done.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wish to add more stuff to the definitions (such as the vertices for a
    polygon shape, or something like that), it should be only a matter of deciding
    how to represent that in the definition and adding the necessary method calls
    to meet that definition inside `loadScene`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, only eight vertices are supported. You can modify Moai SDK's source
    code to add more.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Below the `PhysicsManager` initialization on `Game:initialize`, you should add
    a call to `loadScene`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is one more thing that we need to do now and that's fix our `collision`
    method that was using the hardcoded floor.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First we need another auxiliary method in `game.lua`:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this method, we iterate through all the scene objects and see if the one
    passed as a parameter is one of them.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `character.lua` and replace `onCollide` with the new version:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What we do here is call the auxiliary method when a collision occurs in order
    to see if we're colliding with an object from the scene. In that case, we stop
    jumping. This will make a funny mechanic; run the game and you'll see why (Super
    Meat Boy? Anybody? Ok, when you collide with a vertical edge of a box, the player
    stops, allowing you to jump again!).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The way we created this scene is decoupled from the code that actually loads
    it. In the real world, you will want to be able to edit your levels externally
    and then load them in code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The loading code will behave mostly in the same way as in this case, but you'll
    probably use another language (XML, JSON, and so on) to store your levels. Level
    Editors are your friends.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do you know **Inkscape**? It's a vector graphics editor that uses SVG as the
    main format. SVG is XML! So it is highly parsable. By the way, it's open source
    and free. Another useful open source tool if you're working with tiles is **Tiled**,
    which will be really useful to create your maps, as it includes layers, tilemap
    support, and exports to Lua.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding enemies to this scene should be familiar to you by now. You'll need to
    think about the artificial intelligence for the movement, but other than that,
    everything else has have already been seen. You should create it as a dynamic
    body, and modify the player collision handler in order to react properly (killing
    the player for example, or taking life from it).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Another great idea would be to implement Mario-style platforms where you can
    jump up through the bottom of a platform and then collide and stay on top. (You'll
    have to use Box2D's sensors and check the normal of collision in the collision
    handler. Then, based on the collision normal, only stop movement at the appropriate
    time).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Play around a bit with this, since playing is a big part of the learning process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you might have felt like Newton. We did some experiments with
    Box2D in order to build the physics of our platformer prototype. We saw how to
    use the keyboard and make our character animate and move using the input from
    the user and collisions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take care of showing some debug data to illustrate how
    to create HUDs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将负责展示一些调试数据，以说明如何创建HUD。
