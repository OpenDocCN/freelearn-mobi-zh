- en: Chapter 9. Real-world Physics with Box2D
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 使用 Box2D 的现实世界物理
- en: If you've already worked on games before, you should be familiar with Box2D.
    It's a multiplatform physics library that is broadly used across the gaming community.
    You'll find it really easy to work with it and get nice-looking physics pretty
    quickly, but this doesn't mean you have to create another *Angry Birds* clone,
    hint hint.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前已经参与过游戏开发，你应该熟悉 Box2D。它是一个跨平台的物理库，在游戏社区中得到广泛使用。你会发现它与它一起工作非常容易，并且可以快速创建出看起来很棒的物理效果，但这并不意味着你必须创建另一个
    *愤怒的小鸟* 克隆，提示提示。
- en: Creating the world
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建世界
- en: 'The first step is to create the world that will be in charge of the physics
    simulation by following the given steps:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是按照给定的步骤创建负责物理模拟的世界：
- en: Create a file called `physics_manager.lua` and `require` it from `game.lua`.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `physics_manager.lua` 的文件，并从 `game.lua` 中 `require` 它。
- en: Now let's build the `PhysicsManager` module.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们构建 `PhysicsManager` 模块。
- en: '[PRE0]'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first step is to create the `MOAIBox2DWorld`object. This will take care
    of talking to Box2D from Moai SDK.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建 `MOAIBox2DWorld` 对象。这将负责从 Moai SDK 与 Box2D 通信。
- en: '[PRE1]'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, we need to set up our scale. What we're doing here is saying that one
    meter on the simulation is equivalent to 38 points in our world coordinates. Since
    we're using a main character sprite that is 64 points tall, we can say that our
    character could be about 1.67 meters tall. So, 65 / 1.67 is about 38\. That's
    the calculation needed in order to find that scale.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要设置我们的比例。我们在这里做的是说，模拟中的 1 米相当于我们世界坐标中的 38 个点。由于我们使用的是一个高 64 个点的角色精灵，我们可以说我们的角色大约有
    1.67 米高。所以，65 / 1.67 大约是 38。这就是找到这个比例所需的计算。
- en: '[PRE2]'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Box2D works better on simulations that contain bodies that go from 0.1 to 10
    meters, so take that into account when setting this scale.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Box2D 在包含从 0.1 到 10 米的物体的模拟上工作得更好，所以在设置这个比例时要考虑这一点。
- en: Here we're setting the gravity. The parameter is how many meters per second
    in `x` and `y` our objects get affected. So, for this example, we're using a gravity
    that is similar to the one on Earth (which is -9.8 mts / (s * s), so we can safely
    use -10).
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里我们设置重力。参数是每秒在 `x` 和 `y` 方向上我们的对象受到影响的米数。所以，在这个例子中，我们使用与地球相似的重力（地球的重力是 -9.8
    mts / (s * s)，所以我们可以安全地使用 -10）。
- en: '[PRE3]'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally we start the simulation:'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们开始模拟：
- en: '[PRE4]'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Normally, we don't want to see the objects that Box2D creates on our screen;
    we just want them to be connected to our own rendered objects and make them behave
    according to the simulation. But, for debugging purposes, having the physics objects
    displayed on screen can be pretty handy. If you pass a layer to the `initialize`
    method, it will use it as a debug layer to display the objects you create on Box2D.
    You'll see the actual shapes of the physics objects, and their colors will change
    when they collide with each other.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们不想在屏幕上看到 Box2D 创建的对象；我们只想让它们连接到我们自己的渲染对象，并使它们根据模拟行为。但是，出于调试目的，在屏幕上显示物理对象可以非常方便。如果你将一个层传递给
    `initialize` 方法，它将使用它作为调试层来显示你在 Box2D 中创建的对象。你会看到物理对象的实际形状，并且当它们相互碰撞时，它们的颜色会改变。
- en: '[PRE5]'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's it. We have our world working! Now it's time to have a little talk about
    bodies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们的世界正在运行！现在该谈谈物体了。
- en: Box2D body types
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Box2D 物体类型
- en: The whole point of using a physics engine is to create a world where you put
    objects (bodies) that behave according to physics laws. The term `body` is highly
    based on physics literature, where all the objects that interact are called bodies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用物理引擎的全部目的是创建一个世界，你可以在这里放置（物体）根据物理定律行为的对象。术语 `body` 在物理学文献中有着很高的基础，其中所有相互作用的物体都被称为
    `body`。
- en: 'There are three types of bodies in Box2D: static, kinematic, and dynamic. They
    are explained as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 中有三种类型的物体：静态、运动学和动态。它们如下所述：
- en: '**Static bodies**: You can think of these as bodies that are fixed to the world.
    They don''t move on their own, and they are not affected by gravity or collisions.
    Keep in mind that static bodies are able to collide with other objects, but they
    will not move or change as a result of the collision, just as the other objects
    (if they''re not static). We''ll use static bodies as platforms in our game, for
    our player to stand on.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态物体**：你可以把它们想象成固定在世界上。它们不会自己移动，也不会受到重力或碰撞的影响。记住，静态物体可以与其他对象碰撞，但它们不会因为碰撞而移动或改变，就像其他对象（如果它们不是静态的）一样。我们将使用静态物体作为游戏中的平台，让玩家站立。'
- en: '**Kinematic bodies**: These bodies are not affected by collisions or gravity
    either, but they can move on their own. They can affect other objects during collisions,
    as statics bodies do. A simple moving platform hazard should probably be implemented
    using a kinematic body.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动学体**: 这些体不受碰撞或重力的影响，但它们可以自行移动。它们在碰撞期间可以影响其他对象，就像静力学体一样。一个简单的移动平台危险可能应该使用运动学体来实现。'
- en: '**Dynamic bodies**: These are affected by gravity, collisions, and can move
    on their own. We''ll be using these to make our character and enemies move and
    collide. You can always set these bodies to ignore some force effects.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态体**: 这些体受重力、碰撞的影响，并且可以自行移动。我们将使用这些体来让我们的角色和敌人移动和碰撞。你总是可以将这些体设置为忽略某些力效果。'
- en: Now that we know a little bit more about bodies, let's add the floor to our
    game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对体有了更多了解，让我们将地板添加到我们的游戏中。
- en: In order to do this, append the following code to `World:initialize()`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，请将以下代码追加到`World:initialize()`。
- en: Here we create a static body using `addBody` from `MOAIBox2DWorld`. We then
    use the method `setTransform` to place it. We center it in the `X` axis and place
    it at the bottom of the screen in the `Y` axis.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用`MOAIBox2DWorld`的`addBody`创建一个静态体。然后我们使用`setTransform`方法来放置它。我们在`X`轴上居中，并在`Y`轴上将它在屏幕底部放置。
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After this we need to define the shape of the object (called fixture in the
    context of Box2D). We can use multiple kinds of shapes, and even combine them
    to create objects that are more complex. In this example, we're creating a rectangular
    object that has a width equal to the screen size and height equal to 100\. The
    way we define these rectangles follows the convention of the rectangles on images,
    with the center at `(0,0)` on model coordinates.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们需要定义物体的形状（在Box2D的上下文中称为夹具）。我们可以使用多种形状，甚至将它们组合起来创建更复杂的物体。在这个例子中，我们创建了一个矩形物体，其宽度等于屏幕大小，高度等于100。我们定义这些矩形的方式遵循图像中矩形的惯例，以模型坐标中的`(0,0)`为中心。
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then we define that we don't want friction on the floor. This will stop our
    player from slowing down when running.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义我们不想在地板上有摩擦。这将阻止我们的玩家在跑步时减速。
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need to initialize our world in `game.lua` in order to render something
    to the screen. Just copy the following code below the call to `loadBackground`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`game.lua`中初始化我们的世界，以便在屏幕上渲染一些内容。只需将以下代码复制到`loadBackground`调用下方：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What we're doing here is using the `walkBehind` layer as a parameter for debugging
    purposes. If you don't want to see the objects that are created, just avoid passing
    the layer and you won't see them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是使用`walkBehind`层作为调试参数。如果你不想看到创建的对象，只需避免传递层，你就不会看到它们。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now run the game and you should see a box in the bottom. That's our floor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏，你应该在底部看到一个盒子。那就是我们的地板。
- en: Character versus the world
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色与世界对比
- en: Now we want to make the main character interact with our world.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要让主要角色与我们的世界进行交互。
- en: 'We''ll add some new methods to the `Character` module as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`Character`模块添加一些新方法，如下所示：
- en: 'First we create an object to store our body and shapes as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个对象来存储我们的身体和形状，如下所示：
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we add a dynamic body to the physics simulation. This will be the body
    of our character as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们向物理模拟添加一个动态体。这将是我们角色的主体，如下所示：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we position the body using the same initial position that we used for our
    rendered character as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用与我们的渲染角色相同的初始位置来定位身体，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we add a shape. We'll use a square that's the same size as the sprite (64
    x 64 ). This is obviously far from ideal, because collisions may seem strange
    in some cases (it will feel like there was a transparent box around him), but
    in order to keep it simple, we can live with that.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加一个形状。我们将使用与精灵大小相同的正方形（64 x 64）。这显然远非理想，因为在某些情况下碰撞可能看起来很奇怪（它将感觉像他周围有一个透明的盒子），但为了保持简单，我们可以忍受这一点。
- en: '[PRE13]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Character versus the world](img/5064_09_01.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![角色与世界对比](img/5064_09_01.jpg)'
- en: In the preceding image, we see the character and a platform with the Box2D debug
    on them. We can see that the player should be falling, but it doesn't because
    its box is too big.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们看到角色和一个带有Box2D调试的平台。我们可以看到玩家应该会掉落，但不会掉落，因为它的盒子太大。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may want to create a better shape in your final game, in order to have better
    collision detection, but keep in mind that if the collision shape is more complex,
    it'll need more calculations when colliding. Always try to minimize the amount
    of vertices and edges of your fixtures.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能想在最终游戏中创建一个更好的形状，以便有更好的碰撞检测，但请记住，如果碰撞形状更复杂，则在碰撞时需要更多的计算。始终尝试最小化你的固定装置的顶点和边数。
- en: The last step is to bind our `prop` with our `body`. To do so, we'll use the
    `setParent` method, which tells the Action Tree that the physics body affects
    the `prop` when moving. This is a great example demonstrating the power of the
    Action Tree.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将我们的`prop`与我们的`body`绑定。为此，我们将使用`setParent`方法，它告诉Action Tree当物理体移动时会影响`prop`。这是一个展示Action
    Tree强大功能的绝佳例子。
- en: '[PRE14]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you hit play now, the character should be falling due to gravity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在按播放，由于重力作用，角色应该会下落。
- en: Movement
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动
- en: Now let's get right into the important stuff. First we'll define a couple of
    methods on `Character`. Then we'll rebuild `InputManager` to handle key events
    instead of mouse events and integrate that with our game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们直接进入重要的事情。首先，我们将在`Character`上定义几个方法。然后我们将重新构建`InputManager`来处理按键事件而不是鼠标事件，并将其与我们的游戏集成。
- en: The first method we're going to use will make our character run. It will be
    called when we press the *A* or *D* keys, moving left or right respectively. We'll
    pass it two parameters, `direction` (`-1` for left, `1` for right) and `keyDown`,
    which is a Boolean value that tells us if the player is pressing the key.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要使用的第一个方法将使我们的角色跑步。它将在我们按下*A*或*D*键时被调用，分别向左或向右移动。我们将传递两个参数，`direction`（左为`-1`，右为`1`）和`keyDown`，这是一个布尔值，告诉我们玩家是否在按键。
- en: The first thing we do is use the `direction` parameter in combination with `setScl`
    (used to scale objects). The idea is that if you scale a sprite by a negative
    factor, it flips in the direction of the scaled component, so what we're doing
    here is telling our sprite to face left or right according to what key the player
    pressed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用`direction`参数与`setScl`（用于缩放对象）结合。想法是，如果你通过一个负因子缩放精灵，它将在缩放组件的方向上翻转，所以我们在做的是告诉我们的精灵根据玩家按下的哪个键来面向左或右。
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we force the linear velocity by 100 in the specified direction and keep
    the velocity on the vertical axis, since we want to be able to jump and move while
    jumping:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过100在指定方向上强制线性速度，并保持垂直轴上的速度，因为我们希望在跳跃时能够跳跃和移动：
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then if we''re not already running and we''re not jumping, we start the run
    animation as following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果我们没有在跑步并且没有在跳跃，我们就开始以下跑步动画：
- en: '[PRE17]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If this event was `keyUp` and we were not jumping, then stop moving. This is
    buggy, you should have a better logic here that keeps the state of the different
    keys, but to keep it simple we can live with it. And that''s it, our `Character`
    can now run:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个事件是`keyUp`并且我们没有在跳跃，那么停止移动。这是有问题的，你应该在这里有一个更好的逻辑来保持不同键的状态，但为了简单起见，我们可以忍受它。就这样，我们的`Character`现在可以跑了：
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The two methods are really simple. If we move left, we call run with `-1` as
    the direction; if we move right, we call run with `1` as the direction. In either
    case, we pass the `keyDown` we receive. This `keyDown` will be obtained from the
    `InputManager` later.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两种方法都非常简单。如果我们向左移动，我们用`-1`作为方向调用`run`；如果我们向右移动，我们用`1`作为方向调用`run`。在两种情况下，我们都传递接收到的`keyDown`。这个`keyDown`将稍后从`InputManager`获取。
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What we do to stop moving is (after checking that we''re not jumping) stop
    all the movement, setting the linear velocity to 0 in both directions and start
    the idle animation. This is pretty simple:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要停止移动的操作是（在确认我们不是在跳跃之后）停止所有移动，将线性速度在两个方向上设置为0，并开始空闲动画。这很简单：
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the jump, we're going to do something different. Instead of forcing the
    linear velocity, we'll apply a force. We could do this in the same way, but just
    in order to illustrate how to apply forces, we'll use it here. Then we set a variable
    called jumping to true; this will allow us to know that we're jumping, and finally
    start the jump animation. This is easy as well.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于跳跃，我们将做一些不同的事情。我们不会强制线性速度，而是应用一个力。我们可以用同样的方式做，但只是为了说明如何应用力，我们在这里使用它。然后我们设置一个名为`jumping`的变量为true；这将允许我们知道我们在跳跃，最后开始跳跃动画。这也很容易。
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we''ll implement the `stopJumping` method. We basically set jumping
    to false and stop moving as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现`stopJumping`方法。我们基本上将跳跃设置为false并停止移动如下：
- en: '[PRE22]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our last method will be the one used to handle collisions with the floor. In
    order to use it, we need to add a line to `initializePhysics`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后的方法将用于处理与地板的碰撞。为了使用它，我们需要在`initializePhysics`中添加一行。
- en: 'What we''re doing now is setting up a `callback` method that will be executed
    when Box2D detects a collision with the player''s shape. The parameters are the
    method itself, and which phase of the collision it should be called in is defined
    as following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在正在设置一个`callback`方法，当Box2D检测到与玩家形状的碰撞时将执行。参数是方法本身，以及它应该在碰撞的哪个阶段被调用，定义如下：
- en: '[PRE23]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To check all the collision phases, take a look at the `setCollisionHandler`
    definition at [http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20](http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检查所有碰撞阶段，请查看`setCollisionHandler`定义在[http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20](http://getmoai.com/docs/class_m_o_a_i_box2_d_fixture.html#a693a608fc6645b170d067845dd1a9c20)。
- en: 'Now we need to create the `callback` method:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们需要创建`callback`方法：
- en: 'What we do now is check that the shape that we''re colliding with is the floor,
    if it is, then we stop jumping as follow:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在要检查我们与之碰撞的形状是否是地板，如果是，我们就停止跳跃，如下所示：
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Keyboard input
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘输入
- en: 'We''ll have to change a couple of things in order to start using the keyboard:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用键盘，我们需要更改一些内容：
- en: First of all, we need to remove our `processInput` method and the call to on
    `Game:start` in `game.lua`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从`game.lua`中删除我们的`processInput`方法和对`Game:start`的调用。
- en: Then we need to create a method that will be in charge of managing the key input
    from `InputManager`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要创建一个负责管理`InputManager`按键输入的方法。
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method maps some key presses with the methods we created on `Character`.
    This should be enough to handle the movement of our character.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将一些按键与我们在`Character`上创建的方法关联起来。这应该足以处理我们角色的移动。
- en: 'Now, we''ll have to remove all the code (except the module definition) from
    `input_manager.lua` and rewrite it using the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须从`input_manager.lua`中删除所有代码（除了模块定义），并使用以下代码重新编写：
- en: '[PRE26]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`onKeyboardEvent` will be our keyboard callback. What we do here is just use
    the key code of *A*, *D*, and *W*, replace them with a readable string, and pass
    them as parameters to `keyPressed`, the method we implemented previously.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onKeyboardEvent`将是我们的键盘回调。我们在这里所做的只是使用*A*、*D*和*W*的键码，将它们替换为可读的字符串，并将它们作为参数传递给之前实现的`keyPressed`方法。'
- en: '[PRE27]'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now it's only a matter of setting the callback and we're done.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只需设置回调，我们就算完成了。
- en: Try running the game now. You should be able to move the character around and
    jump using *A*, *D*, and *W*.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试运行游戏。你应该能够使用*A*、*D*和*W*移动角色并跳跃。
- en: Creating the scene
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景
- en: We'll now create the necessary code to define a level. We won't be messing with
    sprites for it; instead we'll just use the default debug shapes from Box2D. We'll
    create the entire physical world, and you should now be able to assign sprites
    to it (it's the same as what we did with the player).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建定义级别的必要代码。我们不会对精灵进行操作；相反，我们只需使用Box2D的默认调试形状。我们将创建整个物理世界，你现在应该能够将精灵分配给它（这与我们对玩家所做的是一样的）。
- en: First of all, we need to remove all the code that relates to the floor definition
    in `physics_manager.lua`, since now we'll be creating the floor with the rest
    of the platforms.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要删除`physics_manager.lua`中与地板定义相关的所有代码，因为现在我们将使用其他平台一起创建地板。
- en: 'Now, on `game.lua`, just below the `background_objects` definitions, we''ll
    create a definition for the scene:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`game.lua`文件中，在`background_objects`定义下方，我们将创建场景的定义：
- en: '[PRE28]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you may see in the given code, we're defining two objects, namely, a floor
    and a platform. To each object we define its body type, its position, and size.
    Note that the floor is now just another scene object.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您在给出的代码中所见，我们定义了两个对象，即地板和平台。我们为每个对象定义其身体类型、位置和大小。请注意，地板现在只是另一个场景对象。
- en: 'We''re now going to iterate through that table and create all the objects in
    one single piece of code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将遍历这个表，并使用一段代码创建所有对象：
- en: '[PRE29]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We start iterating through all the `scene_objects`:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始遍历所有的`scene_objects`：
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here we create the Box2D body, using the type in the definition:'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建Box2D身体，使用定义中的类型：
- en: '[PRE31]'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then we set the size and position.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们设置大小和位置。
- en: '[PRE32]'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And finally the friction.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后是摩擦力。
- en: '[PRE33]'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then we store the object under the defined name and we're done.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将对象存储在定义的名称下，我们就完成了。
- en: If you wish to add more stuff to the definitions (such as the vertices for a
    polygon shape, or something like that), it should be only a matter of deciding
    how to represent that in the definition and adding the necessary method calls
    to meet that definition inside `loadScene`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望向定义中添加更多内容（例如多边形的顶点，或者类似的东西），这仅仅是一个决定如何在定义中表示它，并在`loadScene`内部添加必要的调用方法来满足那个定义的问题。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Currently, only eight vertices are supported. You can modify Moai SDK's source
    code to add more.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只支持八个顶点。你可以修改Moai SDK的源代码来添加更多。
- en: Below the `PhysicsManager` initialization on `Game:initialize`, you should add
    a call to `loadScene`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Game:initialize`中的`PhysicsManager`初始化下面，你应该添加一个对`loadScene`的调用。
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is one more thing that we need to do now and that's fix our `collision`
    method that was using the hardcoded floor.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要做的一件事是修复我们的`collision`方法，它使用了硬编码的地板。
- en: 'First we need another auxiliary method in `game.lua`:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`game.lua`中添加另一个辅助方法：
- en: '[PRE35]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this method, we iterate through all the scene objects and see if the one
    passed as a parameter is one of them.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们遍历所有场景对象，查看传递的参数是否是其中之一。
- en: 'Open `character.lua` and replace `onCollide` with the new version:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`character.lua`，将`onCollide`替换为新版本：
- en: '[PRE36]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What we do here is call the auxiliary method when a collision occurs in order
    to see if we're colliding with an object from the scene. In that case, we stop
    jumping. This will make a funny mechanic; run the game and you'll see why (Super
    Meat Boy? Anybody? Ok, when you collide with a vertical edge of a box, the player
    stops, allowing you to jump again!).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里做的是，当发生碰撞时调用辅助方法，以查看我们是否与场景中的某个对象发生碰撞。在这种情况下，我们停止跳跃。这将产生一个有趣的机制；运行游戏，你就会明白为什么（超级肉男孩？有人吗？好吧，当你与一个盒子的垂直边缘碰撞时，玩家会停止，这样你就可以再次跳跃了！）。
- en: The way we created this scene is decoupled from the code that actually loads
    it. In the real world, you will want to be able to edit your levels externally
    and then load them in code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建这个场景的方式与实际加载它的代码是解耦的。在现实世界中，你将希望能够在代码外部编辑你的关卡，然后加载它们。
- en: The loading code will behave mostly in the same way as in this case, but you'll
    probably use another language (XML, JSON, and so on) to store your levels. Level
    Editors are your friends.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 加载代码将主要以这种方式运行，但你可能会使用另一种语言（XML、JSON等）来存储你的关卡。关卡编辑器是你的朋友。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do you know **Inkscape**? It's a vector graphics editor that uses SVG as the
    main format. SVG is XML! So it is highly parsable. By the way, it's open source
    and free. Another useful open source tool if you're working with tiles is **Tiled**,
    which will be really useful to create your maps, as it includes layers, tilemap
    support, and exports to Lua.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道**Inkscape**吗？它是一个使用SVG作为主要格式的矢量图形编辑器。SVG是XML！所以它非常易于解析。顺便说一句，它是开源的，免费的。如果你在处理瓦片，另一个有用的开源工具是**Tiled**，它将非常有用，因为它包括图层、瓦片地图支持，并导出为Lua。
- en: Exercises
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Adding enemies to this scene should be familiar to you by now. You'll need to
    think about the artificial intelligence for the movement, but other than that,
    everything else has have already been seen. You should create it as a dynamic
    body, and modify the player collision handler in order to react properly (killing
    the player for example, or taking life from it).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，添加敌人到这个场景应该对你来说很熟悉了。你需要考虑移动的人工智能，但除此之外，其他所有内容都已经见过。你应该将其创建为一个动态体，并修改玩家碰撞处理器以正确反应（例如杀死玩家，或者从玩家那里扣除生命）。
- en: Another great idea would be to implement Mario-style platforms where you can
    jump up through the bottom of a platform and then collide and stay on top. (You'll
    have to use Box2D's sensors and check the normal of collision in the collision
    handler. Then, based on the collision normal, only stop movement at the appropriate
    time).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的想法是实现马里奥风格的平台，你可以从平台的底部跳起，然后碰撞并停留在顶部。（你将不得不使用Box2D的传感器，并在碰撞处理器中检查碰撞的法线。然后，根据碰撞的法线，在适当的时间停止移动）。
- en: Play around a bit with this, since playing is a big part of the learning process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 试着玩一玩，因为玩耍是学习过程中的重要部分。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you might have felt like Newton. We did some experiments with
    Box2D in order to build the physics of our platformer prototype. We saw how to
    use the keyboard and make our character animate and move using the input from
    the user and collisions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你可能感觉自己像是牛顿。我们用Box2D做了一些实验，以构建我们的平台游戏原型的物理系统。我们看到了如何使用键盘，并通过用户的输入和碰撞使我们的角色进行动画和移动。
- en: The next chapter will take care of showing some debug data to illustrate how
    to create HUDs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将负责展示一些调试数据，以说明如何创建HUD。
