- en: Chapter 5. Multitasking in Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 在你的应用中进行并行处理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Word counting using threads
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程进行单词计数
- en: Creating an SEO app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个SEO应用
- en: Creating a CycloneChecker app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建CycloneChecker应用
- en: Checking links of our website
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们网站的链接
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Nowadays, multitasking is very common, as an application can do lots of things
    at the same time. If we have a multicore processor such as an iPhone 4S or newer,
    or an iPad 2 or newer, you can even improve the performance. Of course you shouldn't
    use multitasking for everything because commuting from one task to another countlessly
    can harm the performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，并行处理非常普遍，因为一个应用程序可以同时做很多事情。如果我们有一个多核处理器，比如iPhone 4S或更新的型号，或者iPad 2或更新的型号，你甚至可以提高性能。当然，你不应该为所有事情都使用并行处理，因为不断地从一个任务切换到另一个任务可能会损害性能。
- en: In this chapter, we are going to learn different types of multitasking and when
    you should use each of them. First, we will start with threads, then we are going
    to see NSOperations, and at last, how to use the GCD.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习不同类型的并行处理以及何时应该使用每种类型。首先，我们将从线程开始，然后我们将看到NSOperations，最后我们将了解如何使用GCD。
- en: Word counting using threads
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程进行单词计数
- en: Sometimes, if you don't pay attention to multitasking, it might result in a
    frozen screen. As a developer and knowing what is going on in the application,
    we can wait, but as a user who doesn't know anything about the application operation,
    they may think that their app has hanged and that it is necessary to restart.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，如果你不关注并行处理，可能会导致屏幕冻结。作为一个开发者，了解应用程序中发生的事情，我们可以等待，但作为一个对应用程序操作一无所知的用户，他们可能会认为他们的应用已经挂起，需要重新启动。
- en: In this recipe, we are going to create another thread to prevent this situation.
    Creating threads can also be some kind of mechanism of dividing tasks in different
    tracks, making debugging easier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建另一个线程来防止这种情况。创建线程也可以是一种在不同轨道上划分任务的机制，使得调试更容易。
- en: Let's pretend that we need to count the number of words of a document. We will
    have two buttons, one that is going to do this task without using a thread and
    another one that will do the same task using a thread.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要计算一个文档中的单词数量。我们将有两个按钮，一个将不使用线程来完成这个任务，另一个将使用线程来完成相同的任务。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you start, you must have a text file. You can use any text file you want
    but to get a good result, you should have something big, like more than 30K. A
    suggestion is downloading an RFC of any protocol.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，你必须有一个文本文件。你可以使用任何你想要的文本文件，但要得到一个好的结果，你应该有一个很大的文件，比如超过30K。一个建议是下载任何协议的RFC。
- en: So, create a new project called `Chapter 5 Thread`, add a file named `WordCounter.swift`,
    and let's start coding.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个名为`Chapter 5 Thread`的新项目，添加一个名为`WordCounter.swift`的文件，然后让我们开始编码。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we are going to start by downloading a file from the Internet
    and then we are going to work with it by following these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将首先从互联网上下载一个文件，然后我们将按照以下步骤处理它：
- en: 'Open your favorite web browser on your computer and download this text document:
    [https://www.ietf.org/rfc/rfc2821.txt](https://www.ietf.org/rfc/rfc2821.txt).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电脑上打开你喜欢的网页浏览器，下载这个文本文件：[https://www.ietf.org/rfc/rfc2821.txt](https://www.ietf.org/rfc/rfc2821.txt)。
- en: Drag the document into your project, preferably into your **Supporting files**
    group.![How to do it…](img/00043.jpeg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文档拖入你的项目，最好是拖入你的**支持文件**组。![如何做到这一点…](img/00043.jpeg)
- en: 'Now click on the `WordCounter.swift` file and create a class with the same
    name:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击`WordCounter.swift`文件，创建一个具有相同名称的类：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s create an initializer; as you can see, the only attribute we need
    to initialize is the file attribute:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个初始化器；正如你所见，我们唯一需要初始化的属性是文件属性：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is typing the execute method. Here we are going to open our file
    and count the number of words. Of course you can improve this method, but for
    now it should be enough for us:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编写执行方法。在这里，我们将打开我们的文件并计算单词数量。当然，你可以改进这个方法，但对我们来说现在应该足够了：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have the model part done, we can do the view and the controller
    part. Open your storyboard and add three buttons: one for counting the file words
    without using a thread, another one for using a thread, and another one for going
    to the website that is typed on the text field.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模型部分，我们可以进行视图和控制器部分。打开你的Storyboard，添加三个按钮：一个用于不使用线程计算文件单词，另一个用于使用线程，还有一个用于跳转到在文本字段中输入的网站。
- en: Note
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With iOS9, Apple introduced a new security feature called **App Transport Security**
    (**ATP**). This blocks all non-secure (HTTPS) URL requests, including with `UIWebView`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在iOS9中，苹果引入了一个名为**App Transport Security**（**ATP**）的新安全功能。这阻止了所有非安全（HTTPS）URL请求，包括`UIWebView`。
- en: For this recipe we will disable ATP; however, it is recommended that you follow
    the proper ATS procedures for any production applications. In your `info.plist`
    file, add a new key `NSAppTransportSecurity` and set its value to `NSAllowsArbitraryLoads`.
    This will allow all URLs to load without error. As you can imagine, you have to
    add a text field and also a web view. You should have a layout similar to this
    one:![How to do it…](img/00044.jpeg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将禁用ATP；然而，对于任何生产应用程序，建议你遵循适当的ATS程序。在你的`info.plist`文件中，添加一个新的键`NSAppTransportSecurity`并将其值设置为`NSAllowsArbitraryLoads`。这将允许所有URL无错误地加载。正如你可以想象的那样，你必须添加一个文本字段和一个网页视图。你应该有一个类似于这样的布局：![如何做…](img/00044.jpeg)
- en: 'Now let''s link the text field and the web view with the corresponding attributes.
    We also need to create two attributes to know the time when we started counting
    the words and the time we finished doing it. So, let''s complete our view controller
    with this code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将文本字段和网页视图与相应的属性链接起来。我们还需要创建两个属性来知道我们开始计数单词的时间和完成操作的时间。所以，让我们用以下代码完成我们的视图控制器：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have these attributes done, we can start with the easiest method. In
    this case, this method is the `go` button event, which loads the web page on the
    web view:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成了这些属性，我们就可以从最简单的方法开始。在这种情况下，这个方法是`go`按钮事件，它在网页视图中加载网页：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we have to create a method that will call the word counter. This method
    should be common to both buttons, to the one that processes with a thread, and
    the other that processes without a thread, so let''s do a method now that is not
    bound by any button:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须创建一个方法来调用单词计数器。这个方法应该是两个按钮共有的，无论是使用线程处理的按钮还是不使用线程处理的按钮，所以让我们现在创建一个不受任何按钮限制的方法：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To finish the application, we have to create the click event for each button:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成应用程序，我们必须为每个按钮创建点击事件：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now it's time to test the application; pay attention to the different behaviors.
    First, press the button that processes the words without a thread and after that,
    try to type anything on the text field. Until the word counter finishes, you won't
    be able to type anything. Once the operation has finished, press the button that
    works with a thread and try to type a URL and navigate through it. Now you are
    able to navigate while the program is processing something else.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候测试应用程序了；注意不同的行为。首先，按下处理单词而不使用线程的按钮，然后尝试在文本字段中输入任何内容。直到单词计数器完成，你将无法输入任何内容。一旦操作完成，按下使用线程工作的按钮，并尝试输入一个URL并导航。现在你可以在程序处理其他事情的同时进行导航。
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Threads are like tracks of a program; even if you have lots of threads, you
    still share global variables or attributes like we did with the `start` attribute.
    People used to relate threads with earning on performance; that's not exactly
    true.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 线程就像程序的轨道；即使你有大量的线程，你仍然共享全局变量或属性，就像我们与`start`属性所做的那样。人们过去常常将线程与性能提升联系起来；这并不完全正确。
- en: If you have an operation with IO, such as reading a file, or using a sensor
    like Bluetooth, you can earn a good performance due to the fact that a processor
    can work while the I/O doesn't send a reply.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个I/O操作，比如读取文件，或者使用类似蓝牙的传感器，你可以因为处理器可以在I/O不发送回复时工作而获得良好的性能。
- en: Although you can earn on performance when using I/O on our application, you
    will probably have a lower performance using threads. Why? This is because the
    program needs to waste time creating the thread and commuting between threads.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在使用我们的应用程序的I/O时获得性能上的收益，但你可能会因为使用线程而降低性能。为什么？这是因为程序需要浪费时间创建线程并在线程之间切换。
- en: Why did we have better usability when we created a thread on this app? The reason
    is that anything that you do with the user interface is done on the main thread.
    If you have a large operation on this thread, as we had counting the words, it
    will prevent the program from rendering or answering an event until your operation
    is done.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在这个应用程序上创建线程时用户体验更好？原因是任何与用户界面相关的操作都是在主线程上完成的。如果你在这个线程上有大型的操作，就像我们处理单词计数一样，它将阻止程序渲染或回答事件，直到你的操作完成。
- en: Creating a new thread will make your application answer to the user interface
    while you are counting the words on another thread. In this case, we didn't earn
    or lose performance, but the user got a much better usability.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的线程可以在你计数另一个线程上的单词时让应用程序响应用户界面。在这种情况下，我们没有获得或失去性能，但用户得到了更好的可用性。
- en: We could also see in this recipe the usage of regular expressions, which is
    a feature that made a computer language called Perl very famous, and other languages
    such as JavaScript also have this feature incorporated as part of their language.
    Unfortunately, that's not the case with Swift (or at least for this version).
    Regular expressions are very useful to find patterns and also to create some filters,
    such as validating e-mails, product codes, or URLs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们还可以看到正则表达式的使用，这是使一种叫做Perl的计算机语言变得非常著名的特性，其他语言如JavaScript也将此特性作为其语言的一部分。不幸的是，Swift（至少是这个版本）的情况并非如此。正则表达式对于查找模式和创建一些过滤器非常有用，例如验证电子邮件、产品代码或URL。
- en: There's more…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Unfortunately, the NSThread is not as complete as the `posix` thread functions,
    as we don't have, for example, the join method. If your thread function is a C
    function, you can still use functions such as `pthread_create` and `pthread_join`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`NSThread`并不像`posix`线程函数那样完整，因为我们没有例如`join`方法。如果你的线程函数是一个C函数，你仍然可以使用`pthread_create`和`pthread_join`等函数。
- en: In the next recipe, we are going to learn about NSOperation, which is recommended
    by Apple.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将学习关于NSOperation的内容，这是苹果推荐的。
- en: Creating an SEO app
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个SEO应用程序
- en: As you might know, nowadays it's very common to analyze a website to get a better
    result on search engines. Counting the words of a website is a common task to
    know how search engines retrieve information from our website. As we already have
    a `WordCounter` class from the previous recipe, we are going to recycle it and
    create a new program that is to count the words of a website.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，如今分析一个网站以在搜索引擎上获得更好的结果是非常常见的。统计网站上的单词是一个常见的任务，以了解搜索引擎如何从我们的网站上检索信息。因为我们已经从之前的菜谱中有了`WordCounter`类，我们将重用它并创建一个新的程序来统计网站的单词。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First of all, check some URLs from a website that you would like to count the
    words of. It can be any website, but the idea is to have a few URLs to check that
    use a lot of words.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查一些你想要统计单词的网站的URL。可以是任何网站，但想法是检查使用很多单词的几个URL。
- en: To know that the task has finished, we are going to show an icon, so you can
    download it from the book resources or you can download your own icon.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道任务已完成，我们将显示一个图标，你可以从书籍资源中下载它，或者你可以下载你自己的图标。
- en: Once you have your URL list and your icon ready, let's create a project called
    `Chapter 5 SEO`, add your icon, and let's code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了你的URL列表和你的图标准备就绪，让我们创建一个名为`Chapter 5 SEO`的项目，添加你的图标，然后开始编码。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create an SEO app:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个SEO应用程序：
- en: First, copy the `WordCounter.swift` from the other previous recipe. To do it,
    just drag the file from a finder window to your project. Of course, it would be
    better if this file could be located in a common directory.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从其他之前的菜谱中复制`WordCounter.swift`。为此，只需将文件从查找窗口拖到你的项目中。当然，如果这个文件可以位于一个公共目录中会更好。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you have files that could be used in other projects, it's a good idea to
    store them in a common directory.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你有可用于其他项目的文件时，将它们存储在公共目录中是个好主意。
- en: Now, click on this file and let's improve this code. First, let's remove the
    file attribute because we are going to read the file contents into the initializer.
    Second, let's create a new string attribute called `content`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击这个文件，让我们改进这段代码。首先，让我们删除文件属性，因为我们将在初始化器中读取文件内容。其次，让我们创建一个新的字符串属性，称为`content`。
- en: 'The next step is modifying the current initializer, just transferring the code
    that opens and reads the file to the initializer. You also need to create a new
    initializer that receives the contents instead of a file name. To summarize, now
    your `WordCounter` may have a code like this one:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是修改当前的初始化器，只需将打开和读取文件的代码转移到初始化器中。你还需要创建一个新的初始化器，它接收内容而不是文件名。总结一下，现在你的`WordCounter`可能看起来像这样：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's time to create the application interface. In this case, we will need a
    text field to let the user enter a URL, a label to show a message, a button to
    indicate that the user has finished writing a URL, and a table view, something
    similar to the following screenshot:![How to do it…](img/00045.jpeg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建应用程序界面了。在这种情况下，我们需要一个文本框让用户输入URL，一个标签来显示消息，一个按钮来指示用户已完成URL的编写，以及一个表格视图，类似于以下截图：![如何操作…](img/00045.jpeg)
- en: Inherit the view controller from `UITableViewDataSource` and from `UITableViewDelegate`
    after that. Link the table view datasource and delegate with the view controller.
    Don't worry if the compiler complains about some missing functions; we are going
    to implement them in a while.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继承`UITableViewDataSource`和`UITableViewDelegate`之后，将表格视图的数据源和委托与视图控制器链接。如果编译器抱怨一些缺失的函数，不要担心；我们将在稍后实现它们。
- en: 'Now, go to the view controller and let''s create an auxiliary struct. This
    struct will help us to know whether the evaluation of the requested website is
    done and also the result. So, add the following code inside the view controller
    class:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，前往视图控制器并创建一个辅助结构体。这个结构体会帮助我们了解请求的网站评估是否完成以及结果。因此，在视图控制器类中添加以下代码：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is adding some attributes; in this case, we will need a text
    field for entering the URL, a table view, an array of `UrlInfo`, and a queue for
    our operations:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加一些属性；在这种情况下，我们需要一个文本框来输入URL，一个表格视图，一个`UrlInfo`数组，以及一个用于我们操作的对列：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can implement the button event, so link the button with a method called
    `analyze` and type its code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以实现按钮事件，所以将按钮与名为`analyze`的方法链接，并编写其代码：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While this code was written, my Xcode was updated and also the Swift API, so
    it was necessary to fix some parts of it. Consider this kind of change when you
    are coding with Swift.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当编写这段代码时，我的Xcode已经更新，Swift API也进行了更新，因此有必要修复其中的一些部分。当你在Swift中编码时，请考虑这种类型的变更。
- en: 'The last step is implementing the corresponding part of the table view. First,
    let''s indicate the current number of cells of the table view:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是实现表格视图的相应部分。首先，让我们标示当前表格视图的单元格数量：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let''s create a cell for the URL. In this case, when the URL has been
    computed, we are going to add an `OK` icon:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为URL创建一个单元格。在这种情况下，当URL被计算后，我们将添加一个`OK`图标：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, of course, we need to show the result when the user selects a cell from
    the table view. This result is going to be shown only if the URL analysis has
    finished:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，我们还需要在用户从表格视图中选择单元格时显示结果。这个结果只有在URL分析完成后才会显示：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the application is done. Try to check a URL and see its results.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用已经完成。尝试检查一个URL并查看其结果。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: NSOperation is something built on the top level of the **GCD (Grand Central
    Dispatch)**, which is the way Apple does multitasking. The NSOperation needs a
    queue, which can be a new queue created by the programmer, or it could be an existing
    one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: NSOperation是建立在**GCD（Grand Central Dispatch）**之上的，这是苹果实现多任务的方式。NSOperation需要一个队列，这可以是由程序员创建的新队列，或者它可以是现有的一个。
- en: As mentioned before, you have to consider that operations related to the user
    interface, such as refreshing the table view content, must be done on the main
    thread. Speaking in NSOperation terms, it should be done on the main queue. You
    can also have a low priority queue for those tasks that don't need to finish as
    soon as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你必须考虑到与用户界面相关的操作，例如刷新表格视图内容，必须在主线程上完成。用NSOperation的话来说，它应该在主队列上完成。你也可以为那些不需要立即完成的任务创建一个低优先级队列。
- en: One advantage about NSOperation over threads is that it is more optimized for
    multicore devices, meaning a better performance on Mac computers and new iPhones
    and iPads.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于NSOperation相对于线程的一个优点是它更优化于多核设备，这意味着在Mac电脑、新iPhone和iPad上能提供更好的性能。
- en: There's more…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Of course, you can use threads and NSOperation together but you have to take
    care with it. Avoid using NSOperation with fork on OS X, for example. In the next
    recipe, we are going to use the GCD directly, which could give us more flexibility.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以同时使用线程和NSOperation，但必须小心使用。例如，避免在OS X上使用NSOperation与fork。在下一个菜谱中，我们将直接使用GCD，这可能会给我们更多的灵活性。
- en: Creating a CycloneChecker app
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CycloneChecker应用
- en: Sometimes it's good that our mobile phone, or even our computer, can tell us
    weather predictions, mainly when some kind of disaster is going to come, such
    as a storm, an earthquake, or a cyclone. To do this, the application must be continuously
    asking for weather predictions on the Internet but it shouldn't block the application
    operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们的手机，甚至我们的电脑，能告诉我们天气预报是件好事，尤其是在某种灾害即将来临的时候，比如风暴、地震或飓风。为了做到这一点，应用程序必须持续在互联网上请求天气预报，但它不应该阻塞应用程序的操作。
- en: In this recipe, we are going to develop an application that will ask every five
    minutes for cyclone predictions; in the case of finding one cyclone, it will write
    down the URL where the user can retrieve information about the found cyclone.
    If the application is on in the background, it will throw a notification.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开发一个每五分钟请求飓风预测的应用程序；如果找到飓风，它将记录用户可以检索有关找到的飓风信息的URL。如果应用程序在后台运行，它将抛出一个通知。
- en: Here we are going to create a multitask using the **Grand Central Dispatch**,
    which is the method Apple recommends.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 **Grand Central Dispatch** 创建一个多任务，这是苹果推荐的方法。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create an application called `Chapter 5 Cyclones` and add a file called `CycloneChecker.swift`,
    also check whether you have an Internet connection on your computer or device.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `第5章 飓风` 的应用程序，并添加一个名为 `CycloneChecker.swift` 的文件，同时检查您的电脑或设备上是否有互联网连接。
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps for creating the CycloneChecker app:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建 CycloneChecker 应用程序：
- en: 'First, we need to specify that this class (`CycloneChecker`) is a `XMLParserDelegate`,
    which forces us to inherit from `NSObject`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要指定这个类（`CycloneChecker`）是 `XMLParserDelegate`，这迫使我们从 `NSObject` 继承：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now add its attribute. We will need a constant that will represent the frequency
    that the app is going to check about cyclones, another constant that contains
    the URLs where the application can check the cyclone predictions, an attribute
    that indicates the current website we are visiting, a queue to add our operation,
    an attribute to indicate whether the object is working or not, and a closure to
    run every time we find a cyclone:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加其属性。我们需要一个常量来表示应用程序将要检查飓风的频率，另一个常量包含应用程序可以检查飓风预测的URL，一个属性来指示我们正在访问的当前网站，一个队列来添加我们的操作，一个属性来指示对象是否在工作，以及一个闭包，每次我们找到飓风时都会运行：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first two methods that we are going to implement are the methods that make
    the object work or stop working:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要实现的第一个两个方法是使对象工作或停止工作的方法：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, we need a method called `initQueue,` which will add the tasks
    to the object queue:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们需要一个名为 `initQueue,` 的方法，该方法将任务添加到对象队列中：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the object finds a cyclone, it needs to notify the user about it:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦对象找到飓风，它需要通知用户：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To finish this class, we need to mark that the current XML has been parsed;
    next time, we will need to parse the next one:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个类，我们需要标记当前XML已被解析；下次，我们将需要解析下一个：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The CycloneChecker is done; the next step is creating the view, so click on
    the storyboard, add two buttons on it (one to start checking and another one to
    stop checking), a label to indicate the object status (running or stopped), and
    a text field to display a text that a cyclone is coming.![How to do it…](img/00046.jpeg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 飓风检查器已完成；下一步是创建视图，因此点击故事板，添加两个按钮（一个用于开始检查，另一个用于停止检查），一个标签来指示对象状态（运行或停止），以及一个文本框来显示即将到来的飓风文本。![如何做到这一点…](img/00046.jpeg)
- en: 'As you might imagine, now we are going to code the attributes, start linking
    the views we''ve added on the storyboard, and create an object of `CycloneChecker`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所想象，现在我们将编写属性，开始链接我们在故事板中添加的视图，并创建一个 `CycloneChecker` 对象：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s initialize the application on the `viewDidLoad` method, adding an action
    to the `CycloneChecker`. In this case, we are going to add it to the text view
    and send a user notification if the application is on in the background:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `viewDidLoad` 方法中初始化应用程序，向 `CycloneChecker` 添加一个动作。在这种情况下，我们将将其添加到文本视图，并在应用程序在后台运行时发送用户通知：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can finish the view controller, adding the `start` and `stop` events:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以完成视图控制器，添加 `start` 和 `stop` 事件：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To finish the application, you need to add on the app delegate, preferably
    on the method `didFinishLauchingWithOptions`. Use the following code to use notifications:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成应用程序，您需要在应用程序代理中添加，最好是在 `didFinishLauchingWithOptions` 方法中。使用以下代码来使用通知：
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lastly, you need to test the app, so press the play button and check whether
    there is a cyclone near you. Hope not.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要测试应用程序，所以按播放按钮检查你附近是否有旋风。希望没有。
- en: Note
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to allow notifications if you are using iOS 8 or above.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用iOS 8或更高版本，别忘了允许通知。
- en: Once the application launches, you should see something similar to the following
    screenshot. Tap **OK** to allow notifications, as shown:![How to do it…](img/00047.jpeg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序启动，你应该会看到以下截图类似的内容。点击**确定**以允许通知，如图所示：![如何操作……](img/00047.jpeg)
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: This app works using the Grand Central Dispatch, which will create a thread
    and a queue for running the assigned tasks. As it creates a separated thread,
    it doesn't block the user interface, and as it is not creating a thread for each
    task, the application doesn't lose performance due to thread commuting.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序使用Grand Central Dispatch，它将为运行分配的任务创建一个线程和一个队列。因为它创建了一个分离的线程，所以它不会阻塞用户界面，并且因为它不是为每个任务创建一个线程，所以应用程序不会因为线程切换而损失性能。
- en: As you could see when the queue was created, we had to specify that we would
    like a serial queue, meaning that a task doesn't start until the previous one
    finishes. We also used a function called dispatch async, meaning that the caller
    isn't going to wait to finish the task, so the code can continue running concurrently
    to the queue tasks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在创建队列时看到的，我们必须指定我们想要一个串行队列，这意味着任务不会在之前的任务完成之前开始。我们还使用了一个名为dispatch async的函数，这意味着调用者不会等待任务完成，因此代码可以与队列任务并发运行。
- en: Of course, when we find a cyclone, we need to write this information on the
    text view, which is required on the main thread, so that's the reason that we
    had to create another task adding it to the main queue.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们找到旋风时，我们需要在文本视图中写下这些信息，这是在主线程上必需的，所以这就是为什么我们必须创建另一个任务将其添加到主队列中的原因。
- en: Another interesting part is that one task added to our queue had a call to the
    `sleep` function. As you know, the new queue is executed on a separated thread
    and the next task isn't going to run until the current one finishes, so it's perfectly
    allowed to use this function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的部分是，添加到我们的队列中的一个任务调用了`sleep`函数。正如你所知，新的队列在分离的线程上执行，下一个任务不会在当前任务完成之前运行，所以使用这个函数是完全可以的。
- en: If you haven't worked with notifications before on the view controller, here
    you have a sample of it. Don't forget that notifications work only with iOS 7
    or higher, and on iOS 8, the user must accept the permission to send notifications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有在视图控制器上使用过通知，这里有一个示例。别忘了通知只能在iOS 7或更高版本上使用，并且在iOS 8上，用户必须接受发送通知的权限。
- en: There's more…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We still have two pending topics: the first one is using concurrent queues
    and the other one is preventing two tasks changing the same object at the same
    time. Both topics are going to be revealed in the next recipe.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有两个悬而未决的主题：第一个是使用并发队列，另一个是防止两个任务同时更改相同的对象。这两个主题都将在下一个菜谱中揭晓。
- en: Checking links of our website
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们网站的链接
- en: In this chapter, we created an application that could help us position our website
    by checking its word frequencies, but as you might know, SEO is not only about
    counting words, it's also about website links.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个应用程序，可以帮助我们通过检查其单词频率来定位我们的网站，但正如你可能知道的，SEO不仅仅是关于计数单词，它还涉及到网站链接。
- en: In this recipe, we are going to check the links of a website; in this case,
    as we are using the networks, so we can do tasks in parallel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将检查网站的链接；在这种情况下，因为我们正在使用网络，所以我们可以并行执行任务。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a project called `Chapter 5 weblinks` and add a file called `LinkChecker.swift`.
    Check whether you have an Internet connection on your simulator or device.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter 5 weblinks`的项目，并添加一个名为`LinkChecker.swift`的文件。检查你的模拟器或设备上是否有互联网连接。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Once you have checked that your device or simulator has an Internet connection,
    follow these steps for creating the Link Checker app:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认你的设备或模拟器有互联网连接，请按照以下步骤创建Link Checker应用程序：
- en: 'Before we start creating the `LinkChecker` class, we will need to create an
    auxiliary class, which is going to store the common information between objects
    of type `LinkChecker`. This class is going to be called `UrlManager` and it needs
    to store the queue, a file handler to log the found URLs, an array with the URLs,
    and a constant to indicate the maximum number of links we want (some websites
    have a lot of links):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始创建 `LinkChecker` 类之前，我们需要创建一个辅助类，它将存储 `LinkChecker` 类型对象之间的公共信息。这个类将被命名为
    `UrlManager`，它需要存储队列、一个用于记录找到的 URL 的文件处理器、一个包含 URL 的数组以及一个表示我们想要的最大链接数量的常量（一些网站有很多链接）：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s create some auxiliary functions to help this object know whether
    a URL should be stored or not. One of them will tell it whether a URL is already
    stored on our list, the other one is going to tell whether the list is full, the
    third one will check whether the URL is valid or not, and the last one will log
    the URL on a file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些辅助函数来帮助这个对象知道一个 URL 是否应该被存储。其中之一将告诉它我们的列表中是否已经存储了该 URL，另一个将告诉我们列表是否已满，第三个将检查
    URL 是否有效，最后一个将记录 URL 到文件中：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s code the initializer; in this case, we only need to open the log
    file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写初始化器；在这种情况下，我们只需要打开日志文件：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To finish this class, we have to create the main method, which is `addUrl`.
    This function will return if it was possible to add the URL or not:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个类，我们必须创建主方法，即 `addUrl`。这个函数将返回是否能够添加 URL：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On the same file, we are going to create a class called `LinkChecker`. To do
    it, we are again going to use the `XMLParser`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，我们将创建一个名为 `LinkChecker` 的类。为了做到这一点，我们再次将使用 `XMLParser`。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this recipe, we are using the `XMLParser` because it's built on the Swift
    standard libraries, but if you would like a better HTML parser, you can search
    on the Internet for a specific library, such as NDHpple, [https://github.com/ndavidsson/NDHpple/](https://github.com/ndavidsson/NDHpple/).
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `XMLParser` 是因为它建立在 Swift 标准库之上，但如果你想要一个更好的 HTML 解析器，你可以在互联网上搜索一个特定的库，例如
    NDHpple，[https://github.com/ndavidsson/NDHpple/](https://github.com/ndavidsson/NDHpple/)。
- en: 'Let''s start with the attributes. For the implementation of this class, we
    will need an `NSXMlParser`, a `UrlManager`, and a closure to execute every time
    we find a URL:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从属性开始。对于这个类的实现，我们需要一个 `NSXMlParser`，一个 `UrlManager`，以及一个闭包，每次我们找到 URL 时都会执行：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is creating the initializers. In this case, we are going to develop
    two of them. The first one is the one that is going to be called from outside
    (view controller) and the other one is going to be created by the same `LinkChecker`,
    receiving as an argument the same `UrlManager`, and that''s the reason why it
    is a private initializer:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建初始化器。在这种情况下，我们将开发两个初始化器。第一个是从外部（视图控制器）调用的那个，另一个是由同一个 `LinkChecker` 创建的，它接收作为参数的同一个
    `UrlManager`，这就是为什么它是一个私有初始化器的原因：
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next function is the `start` method, which will create the first task:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数是 `start` 方法，它将创建第一个任务：
- en: '[PRE30]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last method of this `LinkChecker` class is the parser function of the `NSXMLParserDelegate`
    protocol. Here we are going to check whether we''ve found a link, represented
    by the `a` HTML tag:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `LinkChecker` 类的最后一个方法是 `NSXMLParserDelegate` 协议的解析函数。在这里，我们将检查是否找到了一个由 `a`
    HTML 标签表示的链接：
- en: '[PRE31]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, click on the storyboard and let's create a screen with a text field to
    write a URL, a button to start analyzing it, and a table view to display the result.![How
    to do it…](img/00048.jpeg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 storyboard 并创建一个带有文本字段来写入 URL、一个用于开始分析它的按钮以及一个用于显示结果的表格视图的屏幕。![如何操作…](img/00048.jpeg)
- en: 'Now inherit the `ViewController` from the `UITableViewDataSource` beside the
    `UIViewController` and add the text field, the `tableview`, an array of strings
    to store the URLs, and a `LinkChecker` as attributes:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从 `UIViewController` 继承 `UITableViewDataSource` 并添加文本字段、`tableview`、一个用于存储
    URL 的字符串数组和一个 `LinkChecker` 作为属性：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once it is done, we can add an event to our button to start analyzing the URL:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以在按钮上添加一个事件来开始分析 URL：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To finish this class, let''s implement the `tableview` methods, which will
    display the content of the `_urls` attribute:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个类，让我们实现 `tableview` 方法，这些方法将显示 `_urls` 属性的内容：
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now the application is done, test your website and see how many links you get
    from it. You should see results similar to the following:![How to do it…](img/00049.jpeg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用程序已经完成，测试你的网站并看看你能从中获得多少链接。你应该看到类似以下的结果：![如何操作…](img/00049.jpeg)
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Requesting something from the network is something that will take time. However,
    in the meantime, the application can work with the next task, so, in this case,
    we need to create a concurrent queue instead of a serial queue.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络上请求某些东西将需要时间。然而，在此期间，应用程序可以处理下一个任务，因此在这种情况下，我们需要创建一个并发队列而不是串行队列。
- en: With this in mind, we have to take care when working with some variables, mainly
    because the application can commute from one task to another when it hasn't finished
    working with a variable. To prevent tasks overlapping the same attribute or variable,
    we should control it using `objc_sync_enter` and `objc_sync_exit`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们在处理一些变量时必须小心，主要是因为当应用程序尚未完成对一个变量的处理时，它可以从一个任务切换到另一个任务。为了防止任务重叠相同的属性或变量，我们应该使用`objc_sync_enter`和`objc_sync_exit`来控制它。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, Swift doesn't have some kind of mutex yet, so it needs to use
    the Objective-C `@synchronize`, and that's the reason for these functions' prefixes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Swift 还没有某种互斥锁，因此它需要使用 Objective-C 的`@synchronize`，这也是这些函数前缀的原因。
- en: There's more…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, sometimes it's hard to work with concurrent tasks and the developer
    needs to think about a lot of detail; fixing issues can also be very difficult
    because sometimes it's hard to reproduce it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有时与并发任务一起工作很困难，开发者需要考虑很多细节；修复问题也可能非常困难，因为有时很难重现它。
- en: In the next chapter, we are going to learn how to test our code without the
    need for running the whole application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在不需要运行整个应用程序的情况下测试我们的代码。
