- en: Chapter 5. Multitasking in Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Word counting using threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SEO app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CycloneChecker app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking links of our website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, multitasking is very common, as an application can do lots of things
    at the same time. If we have a multicore processor such as an iPhone 4S or newer,
    or an iPad 2 or newer, you can even improve the performance. Of course you shouldn't
    use multitasking for everything because commuting from one task to another countlessly
    can harm the performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn different types of multitasking and when
    you should use each of them. First, we will start with threads, then we are going
    to see NSOperations, and at last, how to use the GCD.
  prefs: []
  type: TYPE_NORMAL
- en: Word counting using threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, if you don't pay attention to multitasking, it might result in a
    frozen screen. As a developer and knowing what is going on in the application,
    we can wait, but as a user who doesn't know anything about the application operation,
    they may think that their app has hanged and that it is necessary to restart.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create another thread to prevent this situation.
    Creating threads can also be some kind of mechanism of dividing tasks in different
    tracks, making debugging easier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that we need to count the number of words of a document. We will
    have two buttons, one that is going to do this task without using a thread and
    another one that will do the same task using a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start, you must have a text file. You can use any text file you want
    but to get a good result, you should have something big, like more than 30K. A
    suggestion is downloading an RFC of any protocol.
  prefs: []
  type: TYPE_NORMAL
- en: So, create a new project called `Chapter 5 Thread`, add a file named `WordCounter.swift`,
    and let's start coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to start by downloading a file from the Internet
    and then we are going to work with it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite web browser on your computer and download this text document:
    [https://www.ietf.org/rfc/rfc2821.txt](https://www.ietf.org/rfc/rfc2821.txt).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the document into your project, preferably into your **Supporting files**
    group.![How to do it…](img/00043.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on the `WordCounter.swift` file and create a class with the same
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create an initializer; as you can see, the only attribute we need
    to initialize is the file attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is typing the execute method. Here we are going to open our file
    and count the number of words. Of course you can improve this method, but for
    now it should be enough for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the model part done, we can do the view and the controller
    part. Open your storyboard and add three buttons: one for counting the file words
    without using a thread, another one for using a thread, and another one for going
    to the website that is typed on the text field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: With iOS9, Apple introduced a new security feature called **App Transport Security**
    (**ATP**). This blocks all non-secure (HTTPS) URL requests, including with `UIWebView`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this recipe we will disable ATP; however, it is recommended that you follow
    the proper ATS procedures for any production applications. In your `info.plist`
    file, add a new key `NSAppTransportSecurity` and set its value to `NSAllowsArbitraryLoads`.
    This will allow all URLs to load without error. As you can imagine, you have to
    add a text field and also a web view. You should have a layout similar to this
    one:![How to do it…](img/00044.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s link the text field and the web view with the corresponding attributes.
    We also need to create two attributes to know the time when we started counting
    the words and the time we finished doing it. So, let''s complete our view controller
    with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have these attributes done, we can start with the easiest method. In
    this case, this method is the `go` button event, which loads the web page on the
    web view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have to create a method that will call the word counter. This method
    should be common to both buttons, to the one that processes with a thread, and
    the other that processes without a thread, so let''s do a method now that is not
    bound by any button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish the application, we have to create the click event for each button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now it's time to test the application; pay attention to the different behaviors.
    First, press the button that processes the words without a thread and after that,
    try to type anything on the text field. Until the word counter finishes, you won't
    be able to type anything. Once the operation has finished, press the button that
    works with a thread and try to type a URL and navigate through it. Now you are
    able to navigate while the program is processing something else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Threads are like tracks of a program; even if you have lots of threads, you
    still share global variables or attributes like we did with the `start` attribute.
    People used to relate threads with earning on performance; that's not exactly
    true.
  prefs: []
  type: TYPE_NORMAL
- en: If you have an operation with IO, such as reading a file, or using a sensor
    like Bluetooth, you can earn a good performance due to the fact that a processor
    can work while the I/O doesn't send a reply.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can earn on performance when using I/O on our application, you
    will probably have a lower performance using threads. Why? This is because the
    program needs to waste time creating the thread and commuting between threads.
  prefs: []
  type: TYPE_NORMAL
- en: Why did we have better usability when we created a thread on this app? The reason
    is that anything that you do with the user interface is done on the main thread.
    If you have a large operation on this thread, as we had counting the words, it
    will prevent the program from rendering or answering an event until your operation
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new thread will make your application answer to the user interface
    while you are counting the words on another thread. In this case, we didn't earn
    or lose performance, but the user got a much better usability.
  prefs: []
  type: TYPE_NORMAL
- en: We could also see in this recipe the usage of regular expressions, which is
    a feature that made a computer language called Perl very famous, and other languages
    such as JavaScript also have this feature incorporated as part of their language.
    Unfortunately, that's not the case with Swift (or at least for this version).
    Regular expressions are very useful to find patterns and also to create some filters,
    such as validating e-mails, product codes, or URLs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, the NSThread is not as complete as the `posix` thread functions,
    as we don't have, for example, the join method. If your thread function is a C
    function, you can still use functions such as `pthread_create` and `pthread_join`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we are going to learn about NSOperation, which is recommended
    by Apple.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SEO app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might know, nowadays it's very common to analyze a website to get a better
    result on search engines. Counting the words of a website is a common task to
    know how search engines retrieve information from our website. As we already have
    a `WordCounter` class from the previous recipe, we are going to recycle it and
    create a new program that is to count the words of a website.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, check some URLs from a website that you would like to count the
    words of. It can be any website, but the idea is to have a few URLs to check that
    use a lot of words.
  prefs: []
  type: TYPE_NORMAL
- en: To know that the task has finished, we are going to show an icon, so you can
    download it from the book resources or you can download your own icon.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your URL list and your icon ready, let's create a project called
    `Chapter 5 SEO`, add your icon, and let's code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an SEO app:'
  prefs: []
  type: TYPE_NORMAL
- en: First, copy the `WordCounter.swift` from the other previous recipe. To do it,
    just drag the file from a finder window to your project. Of course, it would be
    better if this file could be located in a common directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have files that could be used in other projects, it's a good idea to
    store them in a common directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, click on this file and let's improve this code. First, let's remove the
    file attribute because we are going to read the file contents into the initializer.
    Second, let's create a new string attribute called `content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is modifying the current initializer, just transferring the code
    that opens and reads the file to the initializer. You also need to create a new
    initializer that receives the contents instead of a file name. To summarize, now
    your `WordCounter` may have a code like this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's time to create the application interface. In this case, we will need a
    text field to let the user enter a URL, a label to show a message, a button to
    indicate that the user has finished writing a URL, and a table view, something
    similar to the following screenshot:![How to do it…](img/00045.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherit the view controller from `UITableViewDataSource` and from `UITableViewDelegate`
    after that. Link the table view datasource and delegate with the view controller.
    Don't worry if the compiler complains about some missing functions; we are going
    to implement them in a while.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go to the view controller and let''s create an auxiliary struct. This
    struct will help us to know whether the evaluation of the requested website is
    done and also the result. So, add the following code inside the view controller
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is adding some attributes; in this case, we will need a text
    field for entering the URL, a table view, an array of `UrlInfo`, and a queue for
    our operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can implement the button event, so link the button with a method called
    `analyze` and type its code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: While this code was written, my Xcode was updated and also the Swift API, so
    it was necessary to fix some parts of it. Consider this kind of change when you
    are coding with Swift.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is implementing the corresponding part of the table view. First,
    let''s indicate the current number of cells of the table view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create a cell for the URL. In this case, when the URL has been
    computed, we are going to add an `OK` icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, of course, we need to show the result when the user selects a cell from
    the table view. This result is going to be shown only if the URL analysis has
    finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the application is done. Try to check a URL and see its results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NSOperation is something built on the top level of the **GCD (Grand Central
    Dispatch)**, which is the way Apple does multitasking. The NSOperation needs a
    queue, which can be a new queue created by the programmer, or it could be an existing
    one.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, you have to consider that operations related to the user
    interface, such as refreshing the table view content, must be done on the main
    thread. Speaking in NSOperation terms, it should be done on the main queue. You
    can also have a low priority queue for those tasks that don't need to finish as
    soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage about NSOperation over threads is that it is more optimized for
    multicore devices, meaning a better performance on Mac computers and new iPhones
    and iPads.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, you can use threads and NSOperation together but you have to take
    care with it. Avoid using NSOperation with fork on OS X, for example. In the next
    recipe, we are going to use the GCD directly, which could give us more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CycloneChecker app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it's good that our mobile phone, or even our computer, can tell us
    weather predictions, mainly when some kind of disaster is going to come, such
    as a storm, an earthquake, or a cyclone. To do this, the application must be continuously
    asking for weather predictions on the Internet but it shouldn't block the application
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to develop an application that will ask every five
    minutes for cyclone predictions; in the case of finding one cyclone, it will write
    down the URL where the user can retrieve information about the found cyclone.
    If the application is on in the background, it will throw a notification.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are going to create a multitask using the **Grand Central Dispatch**,
    which is the method Apple recommends.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an application called `Chapter 5 Cyclones` and add a file called `CycloneChecker.swift`,
    also check whether you have an Internet connection on your computer or device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps for creating the CycloneChecker app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to specify that this class (`CycloneChecker`) is a `XMLParserDelegate`,
    which forces us to inherit from `NSObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add its attribute. We will need a constant that will represent the frequency
    that the app is going to check about cyclones, another constant that contains
    the URLs where the application can check the cyclone predictions, an attribute
    that indicates the current website we are visiting, a queue to add our operation,
    an attribute to indicate whether the object is working or not, and a closure to
    run every time we find a cyclone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first two methods that we are going to implement are the methods that make
    the object work or stop working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, we need a method called `initQueue,` which will add the tasks
    to the object queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the object finds a cyclone, it needs to notify the user about it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish this class, we need to mark that the current XML has been parsed;
    next time, we will need to parse the next one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The CycloneChecker is done; the next step is creating the view, so click on
    the storyboard, add two buttons on it (one to start checking and another one to
    stop checking), a label to indicate the object status (running or stopped), and
    a text field to display a text that a cyclone is coming.![How to do it…](img/00046.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you might imagine, now we are going to code the attributes, start linking
    the views we''ve added on the storyboard, and create an object of `CycloneChecker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s initialize the application on the `viewDidLoad` method, adding an action
    to the `CycloneChecker`. In this case, we are going to add it to the text view
    and send a user notification if the application is on in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can finish the view controller, adding the `start` and `stop` events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish the application, you need to add on the app delegate, preferably
    on the method `didFinishLauchingWithOptions`. Use the following code to use notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, you need to test the app, so press the play button and check whether
    there is a cyclone near you. Hope not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to allow notifications if you are using iOS 8 or above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the application launches, you should see something similar to the following
    screenshot. Tap **OK** to allow notifications, as shown:![How to do it…](img/00047.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This app works using the Grand Central Dispatch, which will create a thread
    and a queue for running the assigned tasks. As it creates a separated thread,
    it doesn't block the user interface, and as it is not creating a thread for each
    task, the application doesn't lose performance due to thread commuting.
  prefs: []
  type: TYPE_NORMAL
- en: As you could see when the queue was created, we had to specify that we would
    like a serial queue, meaning that a task doesn't start until the previous one
    finishes. We also used a function called dispatch async, meaning that the caller
    isn't going to wait to finish the task, so the code can continue running concurrently
    to the queue tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, when we find a cyclone, we need to write this information on the
    text view, which is required on the main thread, so that's the reason that we
    had to create another task adding it to the main queue.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting part is that one task added to our queue had a call to the
    `sleep` function. As you know, the new queue is executed on a separated thread
    and the next task isn't going to run until the current one finishes, so it's perfectly
    allowed to use this function.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't worked with notifications before on the view controller, here
    you have a sample of it. Don't forget that notifications work only with iOS 7
    or higher, and on iOS 8, the user must accept the permission to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We still have two pending topics: the first one is using concurrent queues
    and the other one is preventing two tasks changing the same object at the same
    time. Both topics are going to be revealed in the next recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking links of our website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created an application that could help us position our website
    by checking its word frequencies, but as you might know, SEO is not only about
    counting words, it's also about website links.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to check the links of a website; in this case,
    as we are using the networks, so we can do tasks in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a project called `Chapter 5 weblinks` and add a file called `LinkChecker.swift`.
    Check whether you have an Internet connection on your simulator or device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have checked that your device or simulator has an Internet connection,
    follow these steps for creating the Link Checker app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start creating the `LinkChecker` class, we will need to create an
    auxiliary class, which is going to store the common information between objects
    of type `LinkChecker`. This class is going to be called `UrlManager` and it needs
    to store the queue, a file handler to log the found URLs, an array with the URLs,
    and a constant to indicate the maximum number of links we want (some websites
    have a lot of links):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create some auxiliary functions to help this object know whether
    a URL should be stored or not. One of them will tell it whether a URL is already
    stored on our list, the other one is going to tell whether the list is full, the
    third one will check whether the URL is valid or not, and the last one will log
    the URL on a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s code the initializer; in this case, we only need to open the log
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish this class, we have to create the main method, which is `addUrl`.
    This function will return if it was possible to add the URL or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the same file, we are going to create a class called `LinkChecker`. To do
    it, we are again going to use the `XMLParser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, we are using the `XMLParser` because it's built on the Swift
    standard libraries, but if you would like a better HTML parser, you can search
    on the Internet for a specific library, such as NDHpple, [https://github.com/ndavidsson/NDHpple/](https://github.com/ndavidsson/NDHpple/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s start with the attributes. For the implementation of this class, we
    will need an `NSXMlParser`, a `UrlManager`, and a closure to execute every time
    we find a URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is creating the initializers. In this case, we are going to develop
    two of them. The first one is the one that is going to be called from outside
    (view controller) and the other one is going to be created by the same `LinkChecker`,
    receiving as an argument the same `UrlManager`, and that''s the reason why it
    is a private initializer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next function is the `start` method, which will create the first task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last method of this `LinkChecker` class is the parser function of the `NSXMLParserDelegate`
    protocol. Here we are going to check whether we''ve found a link, represented
    by the `a` HTML tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, click on the storyboard and let's create a screen with a text field to
    write a URL, a button to start analyzing it, and a table view to display the result.![How
    to do it…](img/00048.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now inherit the `ViewController` from the `UITableViewDataSource` beside the
    `UIViewController` and add the text field, the `tableview`, an array of strings
    to store the URLs, and a `LinkChecker` as attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once it is done, we can add an event to our button to start analyzing the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish this class, let''s implement the `tableview` methods, which will
    display the content of the `_urls` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the application is done, test your website and see how many links you get
    from it. You should see results similar to the following:![How to do it…](img/00049.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Requesting something from the network is something that will take time. However,
    in the meantime, the application can work with the next task, so, in this case,
    we need to create a concurrent queue instead of a serial queue.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we have to take care when working with some variables, mainly
    because the application can commute from one task to another when it hasn't finished
    working with a variable. To prevent tasks overlapping the same attribute or variable,
    we should control it using `objc_sync_enter` and `objc_sync_exit`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, Swift doesn't have some kind of mutex yet, so it needs to use
    the Objective-C `@synchronize`, and that's the reason for these functions' prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, sometimes it's hard to work with concurrent tasks and the developer
    needs to think about a lot of detail; fixing issues can also be very difficult
    because sometimes it's hard to reproduce it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to test our code without the
    need for running the whole application.
  prefs: []
  type: TYPE_NORMAL
