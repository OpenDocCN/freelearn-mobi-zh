- en: Chapter 4. Using Kismet and Matinee
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 使用 Kismet 和 Matinee
- en: In the previous chapters, we have learned how the basic interface of UDK works
    and how to build a basic environment. This is all well and good, but at the moment,
    all we can do is walk in the world while looking around. Don't we wish we could
    do something there?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经学习了 UDK 的基本界面如何工作以及如何构建基本环境。这些都是很好的，但到目前为止，我们只能在这个世界中四处走动并四处张望。难道我们不想在那里做些什么吗？
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a look at **Kismet** and **Matinee**,
    two of the most popular ways to create motion in our otherwise static world. This
    should help breathe life into the world of our game. After all, actions do speak
    louder than words.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**Kismet**和**Matinee**，这两种在静态世界中创建动作最流行的方法之一。这应该有助于让我们的游戏世界充满活力。毕竟，行动比言语更有说服力。
- en: 'In this chapter we shall:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn what Kismet is and what we can do with it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Kismet 是什么以及我们可以用它做什么
- en: Use Kismet to change our project's viewpoint to a third-person perspective
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kismet 将我们的项目视角更改为第三人称视角
- en: Discuss Kismet and the benefits and drawbacks of its usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论 Kismet 及其使用的好处和坏处
- en: Learn about the Matinee editor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Matinee 编辑器
- en: Create a cinematic using Matinee
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Matinee 创建电影
- en: Use both Kismet and Matinee to create an automatic door
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kismet 和 Matinee 创建自动门
- en: Learn about sequence objects specifically made for mobile devices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解专为移动设备设计的序列对象
- en: Learn about Mobile Input and add functionality to our iOS game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解移动输入并为我们 iOS 游戏添加功能
- en: But before we dive into creating new things for our game, first let's get an
    understanding for what Kismet actually is and what it can be used for.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为游戏创建新事物之前，首先让我们了解 Kismet 究竟是什么以及它可以用于什么。
- en: Defining Kismet
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Kismet
- en: '**Kismet?** is a system of visual scripting in UDK that makes it possible for
    people to affect the game world and design gameplay events. For teams without
    a programmer, Kismet can be a Godsend; it makes it possible for someone without
    any coding knowledge to do things that would otherwise require the use of **UnrealScript**,
    a programming language that the Unreal Engine uses.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kismet**？是 UDK 中的视觉脚本系统，它使得人们能够影响游戏世界并设计游戏事件。对于没有程序员的团队来说，Kismet 可以是上帝的恩赐；它使得没有编程知识的人也能完成原本需要使用**UnrealScript**（Unreal
    引擎使用的编程语言）才能完成的事情。'
- en: In order to create a? sequence of events, you have to connect a series of sequence
    objects together. This, in turn, generates code when the game is run, which causes
    it to do the things that you said it should do. It would be easy for me to write
    a book entirely about things that can be done in Kismet, but as we are planning
    on creating a third person shooter for the iOS, I will refrain from straying too
    far from that. However, we will be discussing the creation of more and more complex
    sequences as the book progresses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一系列事件，你必须将一系列序列对象连接起来。这样，当游戏运行时，就会生成代码，使其执行你所说的事情。我本可以写一本完全关于 Kismet 可以做什么的书，但鉴于我们计划为
    iOS 创建第三人称射击游戏，我将避免偏离这个主题太远。然而，随着本书的进展，我们将讨论创建越来越复杂的序列。
- en: Creating your first Kismet sequence
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个 Kismet 序列
- en: Now that we've learned what Kismet is and what it can do for us, let's see it
    used in action and see how easy it is to get results!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Kismet 是什么以及它能为我们做什么，让我们看看它是如何在实际中使用的，以及获得结果有多容易！
- en: Time for action—changing the level to a third-person perspective
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——将级别更改为第三人称视角
- en: The? default perspective given to players in UDK is first-person. Let's say
    we want it to be in third-person instead. It will be quite easy to do so due to
    Epic's console command which does just that. However, in order to first simplify
    learning Kismet as much as possible and practice what we've learned in previous
    chapters, we are going to be starting from scratch with a new level.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: UDK 给玩家的默认视角是第一人称。假设我们想将其更改为第三人称。由于 Epic 的控制台命令正好可以做到这一点，所以这将会非常容易。然而，为了尽可能简化
    Kismet 的学习并练习我们在前面章节中学到的知识，我们将从一个全新的级别开始。
- en: First, create a new map by selecting **File** | **New...** and then choose one
    of the four options at the top. I personally chose **Midday Lighting**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过选择**文件** | **新建...**来创建一个新的地图，然后在顶部选择四个选项之一。我个人选择了**正午光照**。
- en: Bring up the **World Properties** menu by selecting **View** | **World Properties**
    from the menu bar at the top of the UDK interface. Type `Game Type` in the **Search**
    bar at the top of the **World Properties** menu, which will bring up the **Game
    Type** menu and the options relevant to us. From there, change the drop-down menus
    on both **Default Game Type** and **Game Type for PIE** to **UTDeathmatch**. While
    we are there in the **Zone Info** section, under **KillZ**, set the value to `-1000`.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过从UDK界面顶部的菜单栏选择**View** | **World Properties**来打开**World Properties**菜单。在**World
    Properties**菜单顶部的**Search**栏中输入`Game Type`，这将弹出**Game Type**菜单以及与我们相关的选项。从那里，将**Default
    Game Type**和**Game Type for PIE**的下拉菜单都更改为**UTDeathmatch**。当我们处于**Zone Info**部分时，在**KillZ**下设置值为`-1000`。
- en: '![Time for action—changing the level to a third-person perspective](img/image_1901_04_01.jpg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动作时间——将级别改为第三人称视角](img/image_1901_04_01.jpg)'
- en: 'Now, before we get into Kismet, I want to explain what it is exactly that we
    are doing. Start up your game using the **Play** | **InEditor** option?. This
    starts up your game as it would be seen on the PC, so it is not representative
    of how the project will look on an iOS? device, but it will be easier to demonstrate
    the following change. When the game appears, press the *Tab* key and you will
    see a black bar appear on the screen. This is the console window, which can be
    used to execute different commands that Unreal has built in. The one we are going
    to be using right now, will toggle first and third person modes. With the console
    open, type in `behindview 1` and press *Enter*:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们进入Kismet之前，我想解释一下我们具体在做什么。使用**Play** | **InEditor**选项启动你的游戏。这样启动的游戏就像在PC上看到的那样，所以它不能代表项目在iOS设备上的外观，但它将更容易展示以下更改。当游戏出现时，按*Tab*键，你会在屏幕上看到一个黑色条出现。这是控制台窗口，可以用来执行Unreal内置的不同命令。我们现在要使用的是切换第一人称和第三人称模式的命令。控制台打开后，输入`behindview
    1`并按*Enter*键：
- en: Tip
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also press the tilde (`~`) key to access the console window which will
    show all things logged during play as well as commands you've previously entered.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以按tilde (`~`)键来访问控制台窗口，它将显示游戏过程中记录的所有内容以及你之前输入的命令。
- en: '![Time for action—changing the level to a third-person perspective](img/image_1901_04_02(2).jpg)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动作时间——将级别改为第三人称视角](img/image_1901_04_02(2).jpg)'
- en: As you can see, the game switches your character to a third person mode. One
    of the? cool things about Kismet is we can, in fact, call these commands for the
    player, which is what we'll be doing in this demonstration.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，游戏将你的角色切换到第三人称模式。Kismet的一个酷特点是我们可以为玩家调用这些命令，这正是我们在这次演示中要做的。
- en: Open up the Kismet interface by clicking on the **K** icon at the top of the
    UDK interface on the main toolbar. You should see a new window pop up that may
    look a bit daunting, but it's not too bad once you know what everything is.![Time
    for action—changing the level to a third-person perspective](img/image_1901_04_02.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击UDK界面主工具栏顶部的**K**图标打开Kismet界面。你应该会看到一个新窗口弹出，可能看起来有点令人畏惧，但一旦你知道了所有内容，它就不会太糟糕。![动作时间——将级别改为第三人称视角](img/image_1901_04_02.jpg)
- en: Underneath the menu bars, you will see a large area with a lot of 1s and 0s
    on it. This is our workspace and where we will be placing all of the Sequence
    Objects that we create.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单栏下方，你会看到一个带有许多1和0的大区域。这是我们的工作区，我们将在这里放置我们创建的所有序列对象。
- en: The bottom two bars are the **Properties** and **Sequences** windows. The **Properties**
    window will hold all of the data that we will want to set within the sequence
    objects, that we will be creating which can be accessed when we left-click on
    them. All of our work in this chapter will be in the same sequence, so we will
    not need to use the **Sequences** window, but we will be going over it in [Chapter
    5](ch05.html "Chapter 5. Action Sequences for Urban Warrior"), *Acti on Sequences
    for Urban Warrior*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 底部两个栏是**Properties**和**Sequences**窗口。**Properties**窗口将保存我们将在创建的序列对象中设置的所有数据，可以通过左键单击它们来访问。我们这一章的所有工作都在同一个序列中，所以我们不需要使用**Sequences**窗口，但我们将会在[第5章](ch05.html
    "第5章。城市战士的动作序列") *城市战士的动作序列*中介绍它。
- en: Right-click anywhere inside the large area in the upper portion of the interface.
    Choose to create a **Player Spawned** event by choosing **New Event** | **Player**
    | **Player Spawned** from the menu that pops up.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在界面上半部分的大区域中右键单击。从弹出的菜单中选择创建一个**Player Spawned**事件，选择**New Event** | **Player**
    | **Player Spawned**。
- en: Left-click? on the **Player Spawned Event Sequence** object so that the **Properties**
    window comes up and change the value of **Max Trigger Count** from `1` to `0`.![Time
    for action—changing the level to a third-person perspective](img/image_1901_04_03.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击 **玩家生成事件序列** 对象，以便弹出 **属性** 窗口，并将 **最大触发次数** 的值从 `1` 更改为 `0`。![操作时间——将视角更改为第三人称视角](img/image_1901_04_03.jpg)
- en: Having a value of 0 means that it can be triggered an infinite number of times.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值为 0 表示它可以被触发无限次。
- en: Right-click under the instigator connection (the purple/pink arrow) and select
    **Create New Object Variable**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击在触发器连接（紫色/粉色箭头）下，并选择 **创建新对象变量**。
- en: Right-click and create a **Console Command** action by choosing **New Action**
    | **Misc** | **Console Command** from the menus.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击，通过从菜单中选择 **新建动作** | **杂项** | **控制台命令** 来创建一个 **控制台命令** 动作。
- en: Inside the properties, type `behindview 1` as the value for **Commands[0]**.![Time
    for action—changing the level to a third-person perspective](img/image_1901_04_04.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性中，将 `behindview 1` 作为 **Commands[0]** 的值输入。![操作时间——将视角更改为第三人称视角](img/image_1901_04_04.jpg)
- en: Connect the output from the **Player Spawned** event to the input of the **Console
    Command** action by clicking on the square on the right-hand side of the **Out**
    text on the **Player Spawned** event and dragging your mouse, until it reaches
    the black square on the left-hand side of the **In** text.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击 **玩家生成** 事件右侧的 **Out** 文本的方块，并拖动鼠标直到它到达 **In** 文本左侧的黑方块，将 **玩家生成** 事件的输出连接到
    **控制台命令** 动作的输入。
- en: Connect the connector of both the **Instigator** and **Target** to the **Object**
    variable we created earlier.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **触发者** 和 **目标** 的连接器连接到我们之前创建的 **对象** 变量。
- en: 'By this point your Kismet should look similar to the following screenshot:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，你的 Kismet 应该看起来与以下截图相似：
- en: '![Time for action—changing the level to a third-person perspective](img/image_1901_04_05.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作时间——将视角更改为第三人称视角](img/image_1901_04_05.jpg)'
- en: Now start your game by clicking on the **Start Mobile Previewer** button on
    the main toolbar.? You will see the following screenshot:![Time for action—changing
    the level to a third-person perspective](img/image_1901_04_06.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过点击主工具栏上的 **开始移动预览器** 按钮来开始你的游戏。? 你将看到以下截图：![操作时间——将视角更改为第三人称视角](img/image_1901_04_06.jpg)
- en: What just happened?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Upon starting the game, when the player is spawned (the **Player Spawned** event
    is activated), we change our perspective to be in the third person (the **Console
    Command** action is called).? We've also learned some fundamentals in working
    with Kismet and have an understanding of how sequence objects connect to create
    different effects. Not too shabby for only using two sequence objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时，当玩家被生成（**玩家生成** 事件被激活）时，我们将视角更改为第三人称（调用 **控制台命令** 动作）。? 我们还学习了一些使用 Kismet
    的基础知识，并理解了序列对象如何连接以创建不同的效果。仅使用两个序列对象就能做到这一点，已经很不错了。
- en: Kismet primer
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kismet 入门
- en: While working? with Kismet, some of the terms may be difficult to understand
    at first, so I would like to quickly go over some aspects of Kismet in general.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Kismet 的时候，一些术语一开始可能难以理解，所以我将快速概述一些 Kismet 的一般方面。
- en: Parts of a sequence object
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列对象的部分
- en: Every node we work with is called a **sequence object**, because it is an object
    within a sequence. We will be talking more about sequences in [Chapter 6](ch06.html
    "Chapter 6. Bringing it All Together"), *Bringing It All Together*, but for now
    let's talk about the parts that make up a Kismet node.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所工作的每个节点都称为 **序列对象**，因为它是一个序列内的对象。我们将在 [第 6 章](ch06.html "第 6 章。整合一切") *整合一切*
    中更多地讨论序列，但现在让我们谈谈构成 Kismet 节点的部分。
- en: '![Parts of a sequence object](img/image_1901_04_07.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![序列对象的部分](img/image_1901_04_07.jpg)'
- en: The left-hand side of a sequence object is? called the **Input**; while the
    right-hand side is called the **Output**. The following are the variables that
    are either values given to us, or that we set depending on the object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 序列对象左侧被称为 **输入**；而右侧被称为 **输出**。以下是一些变量，它们要么是我们给出的值，要么是我们根据对象设置的值。
- en: 'There are four different kinds of sequence objects, three of which we will
    be using in this chapter and we will be using the fourth in [Chapter 5](ch05.html
    "Chapter 5. Action Sequences for Urban Warrior"), *Action sequences For Urban
    Warrior*. The following screenshot shows the sequence objects:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同的序列对象，其中三种我们将在这章中使用，我们将在[第5章](ch05.html "第5章。城市战士的动作序列") *城市战士的动作序列* 中使用第四种。以下截图显示了序列对象：
- en: '![Parts of a sequence object](img/image_1901_04_08.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![序列对象的部分](img/image_1901_04_08.jpg)'
- en: '**Events**: This is what all other sequence? objects get called from. Code
    in Kismet only gets called if a certain thing happens, like the **Player Spawned**
    event that was called when the player spawns in our level. These objects are red
    and are shaped like diamonds.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：这是所有其他序列对象被调用的地方。Kismet中的代码只有在发生某些事情时才会被调用，比如当玩家在我们的级别中生成时调用的**玩家生成**事件。这些对象是红色的，形状像钻石。'
- en: '**Actions**: These perform a defined task when an event is triggered. This
    is the most used item, so it is the object with the most variety. The **Console
    Command** action, as well as the **Delay** used previously, is an example of an
    action. Actions are presented as rectangles.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：当事件被触发时，这些会执行一个定义的任务。这是最常用的项目，因此它是具有最多变化的对象。**控制台命令**动作，以及之前使用的**延迟**，是动作的例子。动作以矩形的形式呈现。'
- en: '**Variables**: These are what hold information within our level. If another
    sequence object has squares underneath it, that is a spot that holds a variable.
    They are colored differently depending on what the variable actually is. The instigator
    in the **Player Spawned** event? is a variable that is filled with our player''s
    information when it is called, and the **Blue** number under the **Delay** variable
    in the previous screenshot is a float variable with the value of `2.0`. We will
    be using variables extensively in [Chapter 6](ch06.html "Chapter 6. Bringing it
    All Together"), *Bringing It All Together*. Variables are represented as circles.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：这些是我们级别中保存信息的东西。如果另一个序列对象下面有方块，那么这是一个保存变量的位置。它们根据变量实际是什么而有所不同。在**玩家生成**事件中的**发起者**？是一个变量，当它被调用时，会填充我们的玩家信息，并且在之前的截图中的**延迟**变量下的**蓝色**数字是一个值为`2.0`的浮点变量。我们将在[第6章](ch06.html
    "第6章。整合一切") *整合一切* 中广泛使用变量。变量表示为圆形。'
- en: '**Conditions**: These actions are special in the fact? that they can do different
    things based on the values of different objects used for comparing numbers or
    objects. They are used to control the flow of things within a sequence. The **Compare
    Objects** condition is an example of a condition. Conditions are traditionally
    blue and are rectangular.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：这些动作在比较数字或对象时可以基于不同对象的值做不同的事情。它们用于控制序列中的事物流程。**比较对象**条件是一个条件的例子。条件传统上是蓝色的，并且是矩形的。'
- en: Benefits and drawbacks of using Kismet
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kismet的优缺点
- en: 'As with any job, it is important to use the tool that is appropriate for it.
    UDK provides three ways of giving interactivity to the game world: Kismet (which
    we are discussing), Matinee (which we are going to discuss), and UnrealScript
    (which is out of the scope of this book, but it is covered extremely well in *Unreal
    Development Kit Game Programming with UnrealScript: Beginner''s Guide* by *Rachel
    Cordone* which is also available from Packt Publishing). All three have specific
    advantages and disadvantages to them, but Kismet is the one that I use most often.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '就像任何工作一样，使用适合的工具很重要。UDK提供了三种给游戏世界添加交互性的方式：Kismet（我们正在讨论的），Matinee（我们将会讨论），以及UnrealScript（这本书的范围之外，但在*Unreal
    Development Kit Game Programming with UnrealScript: Beginner''s Guide*中得到了非常好的覆盖，作者是Rachel
    Cordone，也可以从Packt Publishing购买）。三者都有特定的优点和缺点，但Kismet是我最常使用的一个。'
- en: As you expand your research into UDK after reading this book, you may see forum
    posts with people asking how to do something in Kismet. A lot of people will reply
    to telling them to learn UnrealScript instead. While they may seem arrogant, there
    are some reasons why they are saying to use that tool. I've included a list of
    pros and cons of Kismet which may help you, afterwards, in deciding if it is the
    correct tool for what you're working on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书并扩展您对UDK的研究后，您可能会看到论坛帖子，有人询问如何在Kismet中做某事。很多人会回复建议他们学习UnrealScript。虽然他们可能看起来很傲慢，但他们说使用那个工具的理由也有一些。我列出了Kismet的优缺点，这可能会在您决定它是否适合您正在做的工作时有所帮助。
- en: Benefits of using Kismet
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kismet的优点
- en: 'Kismet is a wonderful tool and is a great starting point when first starting
    out with UDK. Some other benefits associated with Kismet are:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Kismet是一个非常好的工具，当你刚开始使用UDK时，它是一个很好的起点。与Kismet相关的一些其他好处包括：
- en: '**Having a lower barrier to entry**: No programming knowledge is needed so
    it is easier to get started and you can start creating games now.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低入门门槛**：无需编程知识，因此更容易开始，你现在就可以开始创建游戏了。'
- en: '**Great for prototyping gameplay mechanics**: Saying a mechanic is going to
    be fun is one thing, but no one is going to believe you unless you can prove it.
    Kismet makes it extremely easy to get something up quickly. As a designer, having
    something to show a programmer will make it much easier for them to translate
    to code.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非常适合原型设计游戏机制**：说一个机制会很有趣是一回事，但除非你能证明这一点，否则没有人会相信你。Kismet使得快速搭建原型变得极其简单。作为一个设计师，有一件东西可以展示给程序员，这将使他们将想法转化为代码变得容易得多。'
- en: '**Great for one-off events**: If your level needs to have something specific
    or only at a specific time or level events like an explosion, Kismet is a great
    tool to use.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非常适合一次性事件**：如果你的关卡需要特定的事件，比如爆炸，或者只在特定时间或关卡发生的事件，Kismet是一个很好的工具。'
- en: '**Easier to see the flow of events**: If you are more of a visual thinker or
    like to stare at something to see the big picture, it is a lot easier to use Kismet.
    The Sequence Objects and colors all mean something specific to make it easy to
    discern what is going on within a specific scene.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易看到事件流程**：如果你是一个更倾向于视觉思考的人，或者喜欢盯着某物看以了解整体情况，使用Kismet会容易得多。序列对象和颜色都代表特定的含义，使得辨别特定场景中发生的事情变得容易。'
- en: '**Easily extendable with UnrealScript**: With knowledge of how UnrealScript
    works, it is possible to create custom sequence objects of your own to create
    actions of your very own. If your game would have a dialogue system, creating
    a custom **Show Dialog** action would be possible in Kismet to make it easy to
    create entire dialog trees within Kismet.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于与UnrealScript扩展**：了解UnrealScript的工作原理后，你可以创建自己的自定义序列对象，以创建你自己的动作。如果你的游戏有一个对话系统，在Kismet中创建一个自定义的**显示对话框**动作是可能的，这样就可以轻松地在Kismet中创建整个对话树。'
- en: Drawbacks
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**缺点**'
- en: 'However, Kismet is not the be-all and end-all solution for everything that
    can possibly be done with UDK. Here are some of the drawbacks that using Kismet
    may have:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kismet并不是UDK能做的一切事情的终极解决方案。以下是使用Kismet可能遇到的缺点：
- en: '**Complexity issues**: As you get more comfortable using Kismet, you will probably
    try to? do more and more complex things with it (I know I have). If you are not
    careful you may have problems reading what your code is actually doing. Basically,
    the more complex a sequence gets, the harder it is to read.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性问题**：随着你对Kismet越来越熟悉，你可能会尝试用它做更多和更复杂的事情（我知道我就是这样）。如果你不小心，你可能会遇到阅读你的代码实际在做什么的问题。基本上，序列越复杂，阅读起来就越困难。'
- en: '**Reiterations**: Many times in a game, you will want to have the same thing
    happen if you interact with a similar or identical object, like a door. If you
    want the same behavior with multiple objects or multiple levels, you have to paste
    it every single time you want to have that action happen. This can quickly stockpile
    into a really large amount of sequence objects which could be avoided if you wrote
    an UnrealScript file with the same behavior and made that object use that file
    to execute the actions within it.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复使用**：在游戏中，很多时候你希望在与类似或相同的对象（如门）交互时发生相同的事情。如果你想在多个对象或多个关卡上实现相同的行为，你必须每次都粘贴它。这可能会导致序列对象数量迅速增加，如果用具有相同行为的UnrealScript文件编写，并使该对象使用该文件来执行其中的动作，就可以避免这种情况。'
- en: '**Level Specific**: In much the same way Kismet is also specific to just the
    level that it is created in. For instance, if we wanted to create ten levels in
    our game, we would have to do the console command event in every single level.
    With UnrealScript, this would be built into the code base for the game and be
    automatic for all levels of the game.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定于关卡**：与Kismet一样，它也仅限于创建它的关卡。例如，如果我们想在游戏中创建十个关卡，我们就必须在每个关卡中执行控制台命令事件。使用UnrealScript，这将内置到游戏代码库中，并对所有关卡自动生效。'
- en: '**Kismet can''t do everything you''d like to in a game**: The truth is that
    the game Unreal Engine 3 was created to make a **First Person Shooter** (**FPS**),
    and the further you stray from that path, the harder it is going to be to create
    your game. That''s not to say UDK can''t be used to create other games. It''s
    just going to be much more difficult as the sequence objects in Kismet are meant
    to create an FPS.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kismet不能在游戏中做你想做的所有事情**：事实是，Unreal Engine 3游戏引擎是为了制作**第一人称射击游戏**（**FPS**）而创建的，你偏离这条道路越远，创建你的游戏就会越困难。这并不是说UDK不能用来创建其他游戏。只是由于Kismet中的序列对象旨在创建FPS，所以这将会更加困难。'
- en: '**More custom behavior requires UnrealScript**: Continuing with the previous
    point, most of the time a game does something such as a game mechanics that UDK
    doesn''t seem to do (like the Scarecrow boss battles in *Batman: Arkham Asylum*,
    "Plasmids" in *Bioshock 1* and *2*, or the jet packs in *Dark Void*). These examples
    probably use UnrealScript or C++ code to achieve the desired result.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要更多自定义行为时需要UnrealScript**：继续前面的观点，大多数时候游戏会做一些UDK似乎不会做的事情（比如《蝙蝠侠：阿卡姆疯人院》中的稻草人BOSS战，“Plasmids”在《生化奇兵1》和《2》中，或者《暗黑虚空》中的喷气背包）。这些例子可能使用了UnrealScript或C++代码来实现预期的结果。'
- en: '**Kismet is slower than UnrealScript**: While it will not matter with the project
    that we are creating now, as Kismet is basically a prewritten UnrealScript executed
    in a certain order, Kismet is slower than what could be achieved using just UnrealScript,
    and something that your game will continuously use would best be done with UnrealScript.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kismet比UnrealScript慢**：虽然在我们现在创建的项目中这不会很重要，因为Kismet基本上是按照一定顺序执行的预写UnrealScript，但Kismet比仅使用UnrealScript所能达到的速度要慢，而且游戏中持续使用的东西最好用UnrealScript来完成。'
- en: Have a go hero—Kismet
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——Kismet
- en: Console commands can do a lot of different things, giving you access to a lot
    of prewritten code including opening other maps (`open levelname`), and quitting
    the game (`quit`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台命令可以执行很多不同的事情，让你可以访问很多预写的代码，包括打开其他地图（`open levelname`），以及退出游戏（`quit`）。
- en: Try to make the game open another map when you start the level.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在开始关卡时让游戏打开另一个地图。
- en: Defining Matinee
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Matinee
- en: The **Matinee** tool is the driving force of all cinematic effects within the
    Unreal Engine. It gives users the ability to be the director within your game,
    giving you control over the camera, actor's movement, sound, as well as different
    cuts and animation effects. Think of any moment in an Unreal game where you didn't
    have direct control over the character, like a cutscene. Chances are, that was
    done in Matinee. However, Matinee can be used for many other things which we will
    discuss later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**Matinee**工具是Unreal Engine中所有电影效果的动力源泉。它使用户能够在游戏中成为导演，控制摄像机、演员的动作、声音，以及不同的剪辑和动画效果。想想在Unreal游戏中你无法直接控制角色的任何时刻，比如场景。很可能那是在Matinee中完成的。然而，Matinee可以用于许多其他事情，我们将在后面讨论。'
- en: In order to create a Matinee, we will use the (aptly named) Matinee Editor which
    can be accessed from within the Kismet menu.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建Matinee，我们将使用（恰如其名）Matinee编辑器，它可以从Kismet菜单中访问。
- en: Creating your first Matinee movie
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个Matinee电影
- en: Having defined what Matinee is used for, let's begin using it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了Matinee的用途之后，让我们开始使用它。
- en: Time for action—opening cutscene
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——打开场景
- en: As things are, when the game begins we are brought straight into the action
    with no prior warning. In order to prepare the player and give them an idea of
    where they are, let's create a cutscene!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照现状，当游戏开始时，我们直接进入行动，没有任何预先警告。为了准备玩家并让他们了解他们所在的位置，让我们创建一个场景！
- en: Go to the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there, you will see a list of classes that we can place within
    our level. Left-click on the **CameraActor** selection.![Time for action—opening
    cutscene](img/image_1901_04_09.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Actor Classes**浏览器**视图** | **浏览器窗口** | **Actor Classes**。从那里，您将看到我们可以放置在我们关卡中的类列表。左键单击**CameraActor**选择。![行动时间——打开场景](img/image_1901_04_09.jpg)
- en: Close out the **Actor Classes** browser and right-click anywhere in your level.
    From the menu that pops up, select **Create CameraActor Here**. This will create
    an actor on the ground, in the spot in the spot where you clicked. It may be a
    good idea to position the camera above the player and looking at it.![Time for
    action—opening cutscene](img/image_1901_04_10.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**演员类**浏览器，并在你的级别中任何地方右键单击。从弹出的菜单中选择**在此处创建CameraActor**。这将创建一个演员在地面上，在你点击的位置。将相机定位在玩家上方并朝向玩家可能是个好主意。![操作时间——打开场景](img/image_1901_04_10.jpg)
- en: If it isn't already up, open the Kismet editor by clicking on the **K** icon
    at the top of the UDK interface on the main toolbar.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有打开，请通过点击UDK界面主工具栏顶部的**K**图标来打开Kismet编辑器。
- en: Create a new Matinee by right-clicking inside the large area in the upper portion
    of the interface and selecting **New Matinee**. You should see an orange square
    pop out with a lot of different inputs and outputs.![Time for action—opening cutscene](img/image_1901_04_11.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在界面上半部分的大区域内右键单击并选择**新建Matinee**来创建一个新的Matinee。你应该会看到一个橙色方块弹出，带有许多不同的输入和输出。![操作时间——打开场景](img/image_1901_04_11.jpg)
- en: Double-click on the object to enter the Matinee editor as shown in the following
    screenshot:![Time for action—opening cutscene](img/image_1901_04_12.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击对象进入Matinee编辑器，如图下所示：![操作时间——打开场景](img/image_1901_04_12.jpg)
- en: Minimize Matinee and select your **CameraActor** on the main screen by left-clicking
    on it and then bringing Matinee up. Right-click inside the **Group List** (the
    dark-grey column below all the tabs with text and at left-hand side to the timeline.)
    From the **Context** menu that appears, click on **Add New Camera Group**. When
    prompted for a name type in `Camera`.![Time for action—opening cutscene](img/image_1901_04_13.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小化Matinee并选择主屏幕上的**CameraActor**，通过左键单击它并打开Matinee。在**组列表**（位于所有标签下的深灰色列，在时间轴左侧）内右键单击。从出现的**上下文**菜单中，点击**添加新相机组**。当提示输入名称时，键入`Camera`![操作时间——打开场景](img/image_1901_04_13.jpg)
- en: If you click on the little camera icon in the top-left of the **Camera** group,
    you will see the **Perspective** viewport changes into the camera's view.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击**相机**组左上角的相机图标，你会看到**透视**视口变为相机的视角。
- en: If the camera icon doesn't show up, that means the camera is not connected to
    the group. To fix this, left-click on your camera inside the editor and then go
    back into Kismet. From there, right-click below the **Camera** text in the Matinee
    that we have created and select **Create New Object Var Using CameraActor_0**
    and connect it to the **Camera** slot.![Time for action—opening cutscene](img/image_1901_04_14.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果相机图标没有显示，这意味着相机没有连接到组。要修复此问题，在编辑器中左键单击您的相机，然后返回Kismet。从那里，在创建的Matinee中**相机**文本下方右键单击，选择**使用CameraActor_0创建新对象变量**并将其连接到**相机**插槽。![操作时间——打开场景](img/image_1901_04_14.jpg)
- en: Click on the **Movement** track on the **Camera** and then click on the first
    keyframe (the red triangle located in the timeline). You will notice that the
    bottom of the **Perspective** viewport changes its text to **ADJUST KEY Movement0**.
    Now if you move within the viewport, it will transfer over to the Camera actor
    that we have created. Once you have moved your camera to the spot where? you want
    it, click outside of the keyframe in the Matinee window.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**相机**上的**运动**轨道，然后点击时间轴中的第一个关键帧（红色三角形）。你会注意到**透视**视口的底部文本变为**调整关键帧运动0**。现在，如果你在视口中移动，它将转移到我们创建的相机演员上。一旦你将相机移动到你想要的位置，请点击Matinee窗口中的关键帧外部。
- en: Right-click underneath **Camera** and select **Add New Director Group**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**相机**下方右键单击并选择**添加新导演组**。
- en: Left-click on the **Director** track and then click on the **Add Key** icon
    which is the first icon just below the **File** menu (circled in the following
    screenshot in red) to add a new keyframe,to say, we want to use a different camera
    at this position. Select to use **Camera for the Cut To Group** and click on **OK**.![Time
    for action—opening cutscene](img/image_1901_04_15.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击**导演**轨道，然后点击位于**文件**菜单下方（如图下所示，用红色圆圈圈出）的第一个图标**添加关键帧**，以添加一个新关键帧，例如，我们想要在这个位置使用不同的相机。选择使用**切换到组相机**并点击**确定**。![操作时间——打开场景](img/image_1901_04_15.jpg)
- en: Left-click on the **Movement** track again. Drag the time slider from **0.00**
    to the **2.00** second mark, to the grey bar along the bottom of the Matinee area
    where all of the numbers are located.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在**移动**音轨上左键单击。将时间滑块从**0.00**拖动到**2.00**秒标记，到Matinee区域底部的灰色条上，那里有所有的数字。
- en: Left-click on the **Add Key** icon to add a new keyframe to our movie. If all
    goes well, you should see something similar to the following screenshot:![Time
    for action—opening cutscene](img/image_1901_04_16.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击**添加关键帧**图标以向我们的电影添加一个新的关键帧。如果一切顺利，您应该会看到以下截图类似的内容：![行动时间—开场场景](img/image_1901_04_16.jpg)
- en: With the keyframe selected, move the camera closer to the player. At this point,
    if you drag the time slider, you will notice that the camera moves between the?
    two points that we have created over the course of two seconds.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择关键帧后，将摄像机拉近玩家。此时，如果您拖动时间滑块，您会注意到摄像机在两秒钟内创建的两个点之间移动。
- en: Left-click somewhere else on the timeline to remove the focus on the keyframe.
    Move the mouse scroller down in order to zoom-out from the timeline. You will
    notice a pink triangle pointing outwards at the 5.00 mark. That object marks the
    ending of the Matinee sequence, so click on it and drag it to the second mark.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间轴上的其他位置左键单击以取消关键帧的焦点。将鼠标滚轮向下移动以从时间轴中缩出。您会注意到一个指向5.00标记的粉红色三角形。该对象标记了Matinee序列的结束，因此单击它并将其拖动到第二个标记。
- en: You can also right-click on it and select **Move to Longest Track Endpoint**
    and it will automatically snap to the last keyframe added.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以右键单击它，选择**移动到最长音轨端点**，它将自动吸附到添加的最后一个关键帧。
- en: Close up Matinee and bring Kismet back up. Right-click next to the **Console
    Command** action that we created earlier, and select **NewAction** | **Toggle**
    | **ToggleCinematicMode**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Matinee，将Kismet重新调回。右键单击我们之前创建的**控制台命令**动作旁边，选择**新建动作** | **切换** | **切换电影模式**。
- en: Inside the properties for the **ToggleCinematicMode**, disable the **HidePlayer**
    option. Connect the **Target** to the **Instigator** from the **Player Spawned**
    event we created in the previous example. Left-click on the sequence object and
    copy it by pressing *Ctrl* + *C*.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**切换电影模式**的属性中，禁用**隐藏玩家**选项。将**目标**连接到我们在上一个示例中创建的**玩家生成**事件的**施动者**。左键单击序列对象，并按*Ctrl*
    + *C*复制它。
- en: Paste the sequence object by pressing *Ctrl* + *V* and move the created sequence
    object to the right-hand side of the Matinee by holding *Ctrl* and dragging while
    it is selected.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *V*粘贴序列对象，并将创建的序列对象移动到Matinee的右侧，同时按住*Ctrl*键并拖动，当它被选中时。
- en: Remove the connections to the **Console Command** action by holding the *Alt*
    key and clicking on the **In** and **Out** connectors. Drag the action next to
    the second? **Toggle Cinematic Mode** action by clicking on it, holding *Ctrl*
    and dragging it over. Connect the **Out** from the **Player Spawned** action to
    the **Enable** of the first **Toggle Cinematic Mode**. Connect that **Out** to
    the **Play** of the Matinee, connect the **Completed** output to the **Disable**
    input of the second Toggle Cinematic Mode, and finally, connect the **Out** on
    the **Toggle Cinematic Mode** to the input on the **Console Command**.![Time for
    action—opening cutscene](img/image_1901_04_17.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住*Alt*键并点击**控制台命令**动作的**输入**和**输出**连接器来移除与**控制台命令**动作的连接。点击并按住*Ctrl*键，将动作拖动到第二个**切换电影模式**动作旁边。将**玩家生成**动作的**输出**连接到第一个**切换电影模式**的**启用**。将那个**输出**连接到Matinee的**播放**，将**完成**输出连接到第二个切换电影模式的**禁用**输入，最后，将**切换电影模式**的**输出**连接到**控制台命令**的输入。![行动时间—开场场景](img/image_1901_04_17.jpg)
- en: Save your project (**File** | **Save**) and start your game by clicking on the
    **Start Mobile Previewer** button on the main toolbar.![Time for action—opening
    cutscene](img/image_1901_04_18.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目（**文件** | **保存**），然后通过点击主工具栏上的**开始移动预览器**按钮来启动您的游戏。![行动时间—开场场景](img/image_1901_04_18.jpg)
- en: What just happened?
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have created our first cinematic moment in Unreal! Now when our game starts,
    we zoom into our character enabling our players to get ready for the action leading
    up ahead. While it may have been a bit of a hassle to get such a simple movement,
    it is easy to see the great potential to create many exciting things with the
    Matinee tool!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在虚幻引擎中创造了第一个电影时刻！现在当我们的游戏开始时，我们会将镜头拉近我们的角色，让玩家为即将到来的动作做好准备。虽然实现这样一个简单的动作可能有些麻烦，但很容易看出使用Matinee工具创造许多令人兴奋事物的巨大潜力！
- en: Have a go hero—Matinee
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼——Matinee
- en: You can easily add more key points to this opening cutscene and extend its length
    to as long as you want. You can also add another **CameraActor** and switch between
    cameras while the movie is going on. Take some time to coast through your level
    and maybe spin around the player as the game begins.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地添加更多关键点到此开场戏，并延长其长度到你想要的任何长度。你还可以添加另一个**CameraActor**，在电影进行时切换相机。花些时间在你的关卡中滑行，也许在游戏开始时让玩家旋转。
- en: With our powers combined...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的力量结合在一起...
- en: Now that we have learned some fundamentals of using Kismet and Matinee, let's
    do a non-trivial example of something that can be done with them both together.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了使用Kismet和Matinee的一些基础知识，让我们来做一些非平凡的例子，看看它们两者结合能做什么。
- en: Time for action—creating an automatic door
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间——创建自动门
- en: If your game takes place somewhere that humans reside, chances are you are going
    to have a door, and as a? player, we are drawn to them to continue a level. With
    that in mind, let's create a door that will automatically open for us when someone
    comes near it, and close when it is empty.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏发生在人类居住的地方，那么你很可能会有一个门，作为玩家，我们会被它们吸引以继续关卡。考虑到这一点，让我们创建一个当有人靠近时会自动打开，空时关闭的门。
- en: Go back into the main editor window and access the **Content Browser** via **View**
    | **BrowserWindows** | **ContentBrowser**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回主编辑器窗口，通过**视图** | **浏览器窗口** | **内容浏览器**访问**内容浏览器**。
- en: In the **Object Type** tab, check the **Static Meshes** option as we only want
    to see Static Meshes. In the top search bar, type in `doorway`. Left-click on
    the mesh selected and close the **Content Browser**.![Time for action—creating
    an automatic door](img/image_1901_04_19.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象类型**选项卡中，勾选**静态网格**选项，因为我们只想看到静态网格。在顶部搜索栏中输入`doorway`。左键点击选定的网格并关闭**内容浏览器**。![动作时间——创建自动门](img/image_1901_04_19.jpg)
- en: Right-click somewhere in your level and select **AddActor** | **LoadStaticMesh:S_LT_Doors_SM_DoorWar04**.
    Right-click again and select **Add Static StaticMesh:S_LT_Doors_SM_DoorWar04**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的关卡中右键点击，选择**添加演员** | **加载静态网格：S_LT_Doors_SM_DoorWar04**。再次右键点击并选择**添加静态网格：S_LT_Doors_SM_DoorWar04**。
- en: Right-click on the door we placed and select **Convert** | **ConvertStaticMeshActortoMover?**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击放置的门并选择**转换** | **将静态网格演员转换为Mover**。
- en: Go into the properties for the door (*F4*) and type `collision` into the search
    bar. Change the **CollisionType** variable on the bottom to **COLLIDE_BlockAll**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入门的属性（*F4*）并在搜索栏中输入`collision`。将底部的**CollisionType**变量更改为**COLLIDE_BlockAll**。
- en: Use the **Builder Brush** and **Additive Geometry** discussed in [Chapter 2](ch02.html
    "Chapter 2. Beginning Urban Warrior, a Third-person Shooter"), *Beginning Urban
    Warrior; a First Person Shooter* to build a brush on each side of the door and
    one on top that covers the entire distance above the door.![Time for action—creating
    an automatic door](img/image_1901_04_20.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[第2章](ch02.html "Chapter 2. Beginning Urban Warrior, a Third-person Shooter")*Beginning
    Urban Warrior; a First Person Shooter*中讨论的**Builder Brush**和**添加几何**，在门的两侧以及顶部创建一个覆盖整个门上方距离的画刷。![动作时间——创建自动门](img/image_1901_04_20.jpg)
- en: Notice how the brush does not go all the way to the door and, if we make the
    brush larger, it will cover part? of the door. Luckily for us, there is an easy
    way to make the walls flush with the door we want to use.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意画刷并没有延伸到门那里，如果我们让画刷更大，它将覆盖部分门。幸运的是，有一个简单的方法可以使墙壁与我们要使用的门对齐。
- en: Use the **Side** viewport and click on the button that looks like a 3D cube
    to go into **Geometry Mode**. Click on the right side brush and make sure you
    are in translation mode by either clicking on the menu icon that looks like four
    arrows crossing, or by pressing *Spacebar* until you see the arrows to translate.
    Click on the top square at left-hand side to turn it red so that it is selected
    and drag it over to the edge of the door Do the opposite for the other brush.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**侧视图**并点击看起来像3D立方体的按钮进入**几何模式**。点击右侧的画刷并确保你处于平移模式，要么点击看起来像四个箭头交叉的菜单图标，要么按*空格键*直到你看到箭头以进行平移。点击左侧顶部的正方形将其变为红色以便选中，并将其拖动到门的边缘。对另一个画刷做相反的操作。
- en: I will be going over **Geometry Mode** and how it can be used to create gameplay
    areas and allow for fast prototyping of gameplay areas in [Chapter 6](ch06.html
    "Chapter 6. Bringing it All Together"), *Bringing It All Together*.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我将在第6章“Bringing It All Together”中介绍**几何模式**及其如何用于创建游戏区域，并允许快速原型化游戏区域。
- en: '![Time for action—creating an automatic door](img/image_1901_04_21.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作时间——创建自动门](img/image_1901_04_21.jpg)'
- en: Use the **Top** viewport and create a brush that is in the middle of the door
    with space in front and behind the door. Right-click on that brush and select
    **Convert** | **ConverttoVolume** | **Trigger Volume?** to change the brush into
    a trigger volume. After this, save your map and click on **Build All**.![Time
    for action—creating an automatic door](img/image_1901_04_22.jpg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**顶部**视口创建一个位于门中间的刷子，门的前后都有空间。右键单击该刷子并选择**Convert** | **ConverttoVolume**
    | **Trigger Volume?**将刷子转换为触发体积。之后，保存你的地图并点击**Build All**。![操作时间——创建自动门](img/image_1901_04_22.jpg)
- en: Click on the **Trigger Volume** that we've created to select it and open the
    Kismet editor by clicking on the **K** icon at the top of the UDK interface on
    the main toolbar.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们创建的**触发体积**以选择它，并通过点击UDK界面主工具栏顶部的**K**图标打开Kismet编辑器。
- en: Right-click anywhere inside the large area in the upper portion of the interface.
    Create a **Trigger Volume Touch** event by choosing **New Event using TriggerVolume_0**
    | **Touch** from the menu that pops up.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在界面上半部分的大区域中右键单击。通过从弹出的菜单中选择**New Event using TriggerVolume_0** | **Touch**来创建一个**触发体积触摸**事件。
- en: Left-click on the **TriggerVolume_0 Touch** event object so that the properties
    window comes up and change the value of **MaxTriggerCount** from `1` to `0`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击**TriggerVolume_0 Touch**事件对象，以便弹出属性窗口，并将**MaxTriggerCount**的值从`1`更改为`0`。
- en: We want to have a sound play when the door opens and when it closes, so create
    two **Play Sound** actions using **NewAction** | **Sound** | **PlaySound**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在门打开和关闭时播放声音，所以使用**NewAction** | **Sound** | **PlaySound**创建两个**播放声音**动作。
- en: Go into the **Content Browser** and change the object type you're looking for
    to **SoundCue** and change the search to just **door**. Select the first SoundCue
    **A_Door_Metal03_CloseStartCue** and go back into Kismet.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**内容浏览器**，将你要查找的对象类型更改为**SoundCue**，并将搜索更改为仅**door**。选择第一个SoundCue **A_Door_Metal03_CloseStartCue**并返回Kismet。
- en: Select the bottom **Play Sound** action. Inside the properties, you should see
    an icon that looks like a green arrow pointing at the left-hand side, next to
    the **PlaySound** property. Click on that button and it should fill the box with
    the value of what you have selected in the **Content Browser**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择底部的**播放声音**动作。在属性中，你应该看到一个看起来像绿色箭头指向左侧的图标，位于**PlaySound**属性旁边。点击该按钮，它应该将你在**内容浏览器**中选择的值填充到框中。
- en: Repeat steps from step 13 to step 14 using **A_Door_Metal03_OpenStartCue** and
    the top **PlaySound** respectively.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**A_Door_Metal03_OpenStartCue**和顶部的**PlaySound**分别重复从步骤13到步骤14。
- en: Back in the editor, click on the door and go back into Kismet. Create a new
    Matinee object by right-clicking next to the **Touch Event** and selecting **NewMatinee**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回编辑器，点击门并返回到Kismet。通过在**触摸事件**旁边右键单击并选择**NewMatinee**来创建一个新的Matinee对象。
- en: Go into the Matinee editor by double-clicking on the Matinee. Right-click inside
    the **Group List** and click on **AddNewCameraGroup**. When prompted for a name,
    type in `Door`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击Matinee进入Matinee编辑器。在**组列表**内右键单击并点击**AddNewCameraGroup**。当提示输入名称时，键入`Door`。
- en: Create a keyframe at the `0.50` position and, with it selected, left-click on
    the door in the **Perspective** viewport. Move the door to the left-hand side
    till it completely leaves the opening, making it possible for people to pass through.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0.50`位置创建一个关键帧，并选择它后，在**透视**视图中左键单击门。将门移动到左侧，直到它完全离开开口，这样人们就可以通过。
- en: Right-click on the end of the Matinee sequence (the pink triangle pointing out)
    and select **MovetoLongestTrackEndpoint**. Close Matinee and bring Kismet back
    up.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Matinee序列的末尾（指向外的粉红色三角形）右键单击，并选择**MovetoLongestTrackEndpoint**。关闭Matinee并重新打开Kismet。
- en: Connect the **Target** of both **Play Sound** actions to be the door in our
    Matinee sequence, so that we will hear the sound coming from the door.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个**播放声音**动作的**目标**连接到我们的Matinee序列中的门，这样我们就能听到从门传来的声音。
- en: From the **TriggerVolume_0 Touch** event connect the **Touched** output to the
    **Play** input on the top **Play Sound** event. Then, connect the **Empty** output
    to the **Play** input on the bottom **Play Sound** event. Connect the **Out**
    on the top **Play Sound** to the **Play** on the Matinee sequence. Connect the
    **Out** on the bottom **Play Sound** to the **Reverse** input on the Matinee sequence.![Time
    for action—creating an automatic door](img/image_1901_04_23.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **TriggerVolume_0 Touch** 事件将 **Touched** 输出连接到顶部 **Play Sound** 事件的 **Play**
    输入。然后，将 **Empty** 输出连接到底部 **Play Sound** 事件的 **Play** 输入。将顶部 **Play Sound** 的
    **Out** 连接到 Matinee 序列的 **Play**。将底部 **Play Sound** 的 **Out** 连接到 Matinee 序列的
    **Reverse** 输入。![创建自动门的时间](img/image_1901_04_23.jpg)
- en: Save your project (**File** | **Save**) and start your game by clicking on the
    **Start Mobile Previewer** button on the main toolbar.![Time for action—creating
    an automatic door](img/image_1901_04_24.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目（**文件** | **保存**），然后通过点击主工具栏上的 **开始移动预览器** 按钮来启动你的游戏。![创建自动门的时间](img/image_1901_04_24.jpg)
- en: What just happened?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'We have created one of the most used interactive objects within games: a door.
    With this basic idea, it is possible to do many similar things, such as moving
    platforms and elevators, as well as complex things like machinima using a game
    engine to create a cinematic production like *Rooster Teeth''s Red versus Blue*
    or Epic''s own *Samaritan* demo. There''s plenty more you can do with Matinee,
    but it is best for you to explore on your own to discover things through experimentation.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏中创建了一个最常用的交互式对象：一扇门。有了这个基本想法，就可以做许多类似的事情，例如移动平台和电梯，以及像使用游戏引擎创建类似 *Rooster
    Teeth 的 Red versus Blue* 或 Epic 的 *Samaritan* 演示这样的复杂事物。Matinee 还有很多其他功能，但最好是自己探索，通过实验来发现。
- en: Kismet for mobile devices
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动设备上的 Kismet
- en: All of the examples we have seen can be and are used in the normal version of
    UDK and transfer to? our mobile iOS game nicely. Most things in Kismet will work
    on mobiles as well, as long as the GameType supports it. Since it started supporting
    mobile devices, UDK has provided a set of sequence objects that are targeted for
    the mobile platform.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的所有示例都可以，并且已经在 UDK 的正常版本中使用，并且很好地转移到我们的移动 iOS 游戏中。只要游戏类型支持，Kismet 中的大多数事物在移动设备上也能正常工作。自从开始支持移动设备以来，UDK
    已经提供了一套针对移动平台的目标序列对象。
- en: Mobile Kismet—actions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动 Kismet—操作
- en: Unlike the traditional UDK game that would require either changing `.ini` files
    or writing UnrealScript to accept and respond to input, UDK gives mobile developers
    the ability to do things how they want directly in Kismet. This allows developers
    to change input on a per-level basis.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与需要更改 `.ini` 文件或编写 UnrealScript 以接受和响应用户输入的传统 UDK 游戏 不同，UDK 为移动开发者提供了直接在 Kismet
    中按自己的意愿做事的能力。这使得开发者能够根据每个级别来更改输入。
- en: Add Input Zone
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加输入区域
- en: '**Add Input Zone** displays an additional input zone to the screen. Zones need
    to have a unique name and will be referenced by their **Zone Name** property in
    other sequence objects when using them. We will be using this action later in
    the chapter in order to add buttons to our UI and learn how to create different
    kinds of zones for use in our project.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加输入区域** 在屏幕上显示一个额外的输入区域。区域需要有一个唯一的名称，当使用它们时，其他序列对象将通过它们的 **Zone Name** 属性来引用。我们将在本章后面使用此操作来添加按钮到我们的
    UI 中，并学习如何创建不同类型的区域以用于我们的项目。'
- en: '![Add Input Zone](img/image_1901_04_25.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![添加输入区域](img/image_1901_04_25.jpg)'
- en: This action is found in **NewAction** | **Mobile** | **AddInputZone**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **NewAction** | **Mobile** | **AddInputZone**.
- en: Clear Input Zone
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除输入区域
- en: This action removes all of the zones that were created or loaded at runtime.
    This basically leaves you with a clean slate to build an input scheme of your
    own. This is great if you are creating a game that does not require movement,
    or uses a different way of moving than what the provided ones do.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作会移除在运行时创建或加载的所有区域。这基本上为你提供了一个干净的画布来构建自己的输入方案。如果你正在创建一个不需要移动或使用与提供的不同移动方式的游戏，这将非常棒。
- en: '![Clear Input Zone](img/image_1901_04_26.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![清除输入区域](img/image_1901_04_26.jpg)'
- en: This action is found in **NewAction** | **Mobile** | **ClearInputZones**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **NewAction** | **Mobile** | **ClearInputZones**.
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using this action would also remove the **UberStickMoveZone** and **UberStickLookZone**
    joystick inputs leaving only the **UberLookZoneInput** zone left. Be sure to add
    them back if you'd like to have them within your project. However, that being
    said, it is likely best for users to avoid using this Event unless it is for a
    specific purpose within a single level. If we don't want parts of the default
    input zones for all levels, it is best that we modify the **RequiredMobileInputConfigs**
    of the `DefaultGameUDK.ini` file to fit our purposes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此操作也会移除**UberStickMoveZone**和**UberStickLookZone**摇杆输入，只留下**UberLookZoneInput**区域。如果你想在项目中使用它们，请务必将它们添加回来。然而，话虽如此，对于用户来说，最好避免在没有特定目的的情况下使用此事件。如果我们不希望所有级别的默认输入区域的部分都生效，最好修改`DefaultGameUDK.ini`文件的**RequiredMobileInputConfigs**以适应我们的需求。
- en: Remove Input Zone
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除输入区域
- en: This action allows you to remove an input zone by name; it is useful if you
    want to make an interaction?? only available at certain times of a game, like
    a save menu or a **Talk** button used for dialog. The **Zone Name** property can
    be found within the properties of the sequence object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作允许你通过名称移除输入区域；如果你只想在游戏的一定时间点使交互可用，例如保存菜单或用于对话的**说话**按钮，这很有用。**区域名称**属性可以在序列对象的属性中找到。
- en: '![Remove Input Zone](img/image_1901_04_27.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![移除输入区域](img/image_1901_04_27.jpg)'
- en: This action is found in **NewAction** | **Mobile** | **RemoveInputZone**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于**新建动作** | **移动** | **移除输入区域**。
- en: Save/Load values
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存/加载值
- en: This, as the name suggests, saves or loads variables created within Kismet from
    the hard drive using Kismet. You can hook up multiple variables to the same action
    allowing you to?? have as many variables as you like, but each variable needs
    to have a name within the **Var Name** property to be saved. I recommend that
    you use the same action for both loading and saving the same values. This way
    the order in which the variables are loaded are the same in which they were saved.
    If you have ten integers hooked to the same **Int Vars** holder Kismet does not
    guarantee the order in which it decides to place it and using the same action
    saves you the headache.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这是通过Kismet从硬盘保存或加载Kismet内部创建的变量。你可以将多个变量连接到同一操作，允许你拥有尽可能多的变量，但每个变量需要在**变量名称**属性中有一个名称才能保存。我建议你使用相同的操作来加载和保存相同的值。这样，变量的加载顺序将与保存时的顺序相同。如果你有十个整数连接到同一个**整型变量**容器，Kismet不能保证它决定放置它们的顺序，而使用相同的操作可以节省你很多麻烦。
- en: '![Save/Load values](img/image_1901_04_07.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![保存/加载值](img/image_1901_04_07.jpg)'
- en: This action is found in **NewAction** | **Mobile** | **Save/LoadValues**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于**新建动作** | **移动** | **保存/加载值**。
- en: Mobile Kismet—events
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动Kismet—事件
- en: Taking the input from input zones, as well as the iPod's own gyroscopes and
    gadgets, we can make use of certain functionality with events, as well as create
    our own **HUD** graphics.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入区域获取输入，以及使用iPod自身的陀螺仪和设备，我们可以利用事件来启用某些功能，以及创建我们自己的**HUD**图形。
- en: Analog Input
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟输入
- en: Working on PC, Console, and Mobile, **Analog Input** will fire whenever an analog
    input, used with the **Input Name** that you set with, has a value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在PC、控制台和移动设备上工作，**模拟输入**会在使用你设置的**输入名称**的模拟输入有值时触发。
- en: Some values that you can use include `MobileYaw` and `MobilePitch` which give
    values from the device's gyroscope. These will give you float values inside of
    the **Float Value** variable. **DeviceAccelerometerRawData** will return a vector
    with the `Roll, Portrait Pitch`, and `Landscape Pitch` in the **Vector Value**
    variable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的一些值包括`MobileYaw`和`MobilePitch`，它们从设备的陀螺仪中获取值。这些值将在**浮点值**变量中给出。**DeviceAccelerometerRawData**将在**向量值**变量中返回一个包含`Roll,
    Portrait Pitch`和`Landscape Pitch`的向量。
- en: It is important to note that unless you set **Trap** input to **FALSE** (by
    unchecking it), nothing else will be able to receive any input events, including
    touches.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，除非你将**陷阱**输入设置为**FALSE**（通过取消选中它），否则其他任何东西都无法接收任何输入事件，包括触摸。
- en: '![Analog Input](img/image_1901_04_28.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![模拟输入](img/image_1901_04_28.jpg)'
- en: This action is found in **New Event** | **Input** | **AnalogInput**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于**新建事件** | **输入** | **模拟输入**。
- en: Mobile Button Access
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动按钮访问
- en: If you are not referencing something that was already created from a `.ini`
    file, you will be using **Mobile Button Access** to trigger stuff within Kismet.
    This is similar to how the **Touch** event was shown previously. The property
    **Target Zone Name** should contain the name of an already created input zone.
    There are some properties that you can use, such as **Send Press Only On Touch
    Down** which will only call the **Input Pressed Output** when you click on the
    button and **Send Press Only On Touch Up** which will only be called when you
    remove your finger. Otherwise, as long as the button is held down, the action
    will be called.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是引用从 `.ini` 文件中已创建的内容，你将使用 **移动按钮访问** 在 Kismet 中触发内容。这与之前展示的 **触摸** 事件类似。属性
    **目标区域名称** 应包含已创建的输入区域的名称。你可以使用一些属性，例如 **仅触摸下发送按下**，它将在你点击按钮时仅调用 **Input Pressed
    输出**，以及 **仅触摸上发送按下**，它将在你移除手指时被调用。否则，只要按钮被按下，就会调用该操作。
- en: '![Mobile Button Access](img/image_1901_04_29.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![移动按钮访问](img/image_1901_04_29.jpg)'
- en: This action is found in **New Event** | **Input** | **Mobile Button Access**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **新事件** | **输入** | **移动按钮访问**。
- en: Mobile Input Access
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动输入访问
- en: The Mobile Input Access action is used whenever you have an input zone set with
    the value of **Mobile Input Zone** to **ZoneType_Joystick. Input Active** is called
    in each frame when the joystick is being used, while **Input Inactive** is used
    when it is released. Creating variables for the bottom sections gives you access
    to different values that you can use for interpreting how you are going to use
    the data. **X-Axis** and **Y-Axis** give you a value between **-1.0** and **1.0**,
    where **-1.0** is all the way down or left, and **1.0** is up or right. If you
    would prefer to be more precise, the four other values give you the pixel values
    of where the joystick's center and current position are.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置具有 **移动输入区域** 为 **ZoneType_Joystick** 的输入区域时，会使用 **移动输入访问** 动作。当摇杆被使用时，在每一帧都会调用
    **Input Active**，而当摇杆被释放时，则使用 **Input Inactive**。为底部部分创建变量可以让你访问不同的值，你可以使用这些值来解释你打算如何使用数据。**X轴**
    和 **Y轴** 提供介于 **-1.0** 和 **1.0** 之间的值，其中 **-1.0** 是完全向下或向左，而 **1.0** 是向上或向右。如果你希望更精确，其他四个值提供了摇杆中心和当前位置的像素值。
- en: '![Mobile Input Access](img/image_1901_04_30.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![移动输入访问](img/image_1901_04_30.jpg)'
- en: This action is found in **New Event** | **Input** | **MobileInputAccess**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **新事件** | **输入** | **MobileInputAccess**。
- en: Mobile Look
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动外观
- en: Mobile Look is extremely similar to the **Mobile Input Access** event, in that
    they both have the same type of outputs and are used with an input zone with **ZoneType_Joystick**
    as the **Mobile Input Zone**. However, the **Mobile Look** action takes the data
    and converts it into a Vector that represents the current vertical and horizontal
    axes of the joystick, instead of individual values which can be easily applied
    to a pawn using **New Action** | **Actor** | **Set Actor Location**. The **Yaw?**
    represents the direction the joy stick is moving in **Unreal Rotator** units where
    **0** is straight up and the rotation increases clockwise. The **Strength** gives
    the distance of the current location of the touch to the center of the joystick
    in pixels. This can be quite useful for top-down games.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 移动外观事件与 **移动输入访问** 事件极为相似，因为它们都具有相同类型的输出，并且与具有 **ZoneType_Joystick** 作为 **移动输入区域**
    的输入区域一起使用。然而，**移动外观** 操作将数据转换为表示摇杆当前垂直和水平轴的向量，而不是可以轻松应用于使用 **新动作** | **演员** |
    **设置演员位置** 的单独值。**偏航?** 代表摇杆在 **Unreal Rotator** 单位中的移动方向，其中 **0** 是垂直向上，旋转按顺时针方向增加。**强度**
    表示触摸当前位置到摇杆中心的像素距离。这对于俯视游戏非常有用。
- en: '![Mobile Look](img/image_1901_04_31.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![移动外观](img/image_1901_04_31.jpg)'
- en: This action is found in **New Event** | **Input** | **Mobile Look**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **新事件** | **输入** | **移动外观**。
- en: Mobile Object Picker
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动对象选择器
- en: '**Mobile Object Picker** is a simple way to check if target object with collision
    is being touched by a **Touch** input if it is within the **Trace Distance** away
    from the player. It will only call once unless you set **Check on Touch** to **TRUE**,
    then it will call once every frame. Like everything that does an action every
    frame, it is advised to set a **Re Trigger Delay** to some value such as `0.2`
    in order to put less strain on the hardware.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动对象选择器**是一种简单的方法，用于检查目标对象是否被 **触摸** 输入所接触，前提是它距离玩家 **追踪距离** 内。除非您将 **触摸检查**
    设置为 **TRUE**，否则它只会调用一次；然后它将每帧调用一次。像每帧执行动作的任何事物一样，建议设置一个 **重新触发延迟** 为某个值，例如 `0.2`，以减少对硬件的压力。'
- en: '![Mobile Object Picker](img/image_1901_04_32.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![移动对象选择器](img/image_1901_04_32.jpg)'
- en: This action is found in **New Event** | **Input** | **Mobile Object Picker**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **新事件** | **输入** | **移动对象选择器**。
- en: Mobile Simple Swipes
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动简单滑动
- en: The **Mobile Simple Swipes** event provides a simplistic form of swipe detection
    using different outputs depending on the swipe's direction. The **Tolerance**
    variable can be set to allow a swipe to occur on a more or less straight line
    and the **Min Distance** variable sets how long the swipe needs to be to be considered
    a swipe to make the move more or less drastic. The bottom value in purple, **Touched
    Actors List**, returns an object list which contains all of the actors with collision
    that were touched in the process of the swipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动简单滑动**事件提供了一种简单的滑动检测形式，根据滑动方向使用不同的输出。**容差**变量可以设置以允许在更直或更弯的线上发生滑动，而**最小距离**变量设置滑动需要多长才能被认为是滑动，以使动作更剧烈或更温和。紫色底部的**触摸演员列表**返回一个对象列表，其中包含在滑动过程中被触摸的所有具有碰撞的演员。'
- en: '![Mobile Simple Swipes](img/image_1901_04_33.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![移动简单滑动](img/image_1901_04_33.jpg)'
- en: This action is found in **New Event** | **Input** | **Mobile Simple Swipes**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **新事件** | **输入** | **移动简单滑动**。
- en: Touch Input
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸输入
- en: Any time the user touches the screen, it is considered a **Touch** event. The
    input system has the ability to track multiple touches at the same time by using
    the **Touch Index** with the **Touchpad Index** to refer to the input zone values
    that you provided. **Touch X** and **Touch Y** will give you the value in pixels
    of where in screen space they are and **Instigator** will refer to the **Player
    Controller** that did the touching. You may choose to use **Pressed** for a triggered
    event with **Repeated** to continue while the touch exists. **Released** will
    be called whenever the player removes his finger from the **Touch** event.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户触摸屏幕时，都视为 **触摸** 事件。输入系统可以通过使用 **触摸索引** 与 **触摸板索引** 来跟踪同时发生的多个触摸，以引用您提供的输入区域值。**触摸
    X** 和 **触摸 Y** 将给出它们在屏幕空间中的像素值，**发起者**将指代执行触摸的 **玩家控制器**。您可以选择使用 **按下** 来触发事件，使用
    **重复** 来在触摸存在时继续，**释放** 将在玩家从 **触摸** 事件中移除手指时被调用。
- en: '![Touch Input](img/image_1901_04_34.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![触摸输入](img/image_1901_04_34.jpg)'
- en: This action is found in **New Event** | **Input** | **Touch Input**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于 **新事件** | **输入** | **触摸输入**。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unless you set **Trap Input** to **FALSE** by unchecking it, you will be unable
    to use any other input zones while using this event.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您通过取消选中将其设置为 **FALSE** 来设置 **陷阱输入**，否则在使用此事件时，您将无法使用任何其他输入区域。
- en: Draw Image
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制图像
- en: The **Draw Image** action displays the **Texture2D** image in **Display Texture**
    as a **HUD** of sorts for players to use within your game as long as **Active/Is
    Active** are set to be **TRUE**. The **XL** and **YL** values are used to show
    how large the image should be to display **1.0** means to fill the screen 100%
    within the respective axis. **U** and **L** are the location of the top-left corner
    of that texture to draw. **UL** and **VL** are the horizontal and vertical width
    in pixels of the portion of the texture to be drawn. Make sure to change the **Display
    Color** to white as that is the color that it will be modulated by.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘制图像**操作将 **Texture2D** 图像显示在 **显示纹理** 中，作为某种形式的 **HUD**，供玩家在您的游戏中使用，只要 **激活/是否激活**
    设置为 **TRUE**。**XL** 和 **YL** 值用于显示图像应该有多大以显示 **1.0** 表示在相应轴线上填充屏幕 100%。**U** 和
    **L** 是要绘制的纹理的左上角的位置。**UL** 和 **VL** 是要绘制的纹理部分的水平和垂直宽度（以像素为单位）。请确保将 **显示颜色** 更改为白色，因为这是它将被调制的颜色。'
- en: There is a variable called **Authored Global Scale**, which specifies the scale
    factor of the display the content is being used in. A value of `2.0` is useful
    for high resolution screens like the iPhone 4S and new iPad, while `1.0` is useful
    for standard resolution screens such as the iPad and older iPhones/iPod Touches.
    It is also worth noting that the **Out** output does not actually get called.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个名为**已发布全局缩放**的变量，它指定了内容所使用的显示缩放因子。`2.0`的值对于iPhone 4S和新iPad等高分辨率屏幕很有用，而`1.0`对于iPad和较旧的iPhone/iPod
    Touch等标准分辨率屏幕很有用。还值得注意的是，**输出**实际上并没有被调用。
- en: '![Draw Image](img/image_1901_04_35.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![绘制图像](img/image_1901_04_35.jpg)'
- en: This action is found in **New Event** | **HUD** | **Draw Image**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于**新事件** | **HUD** | **绘制图像**。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This will not work with the gametype of **UTDeathmatch**. We will make use of
    this for our Main Menu, which we will be creating in [Chapter 7](ch07.html "Chapter 7. Advanced
    Content Creation for Urban Warrior"), *Advanced Content Creati on for Urban Warrior*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不适用于**UTDeathmatch**游戏类型。我们将利用这一点来制作我们的主菜单，我们将在[第7章](ch07.html "第7章。城市战士的高级内容创作")，*城市战士的高级内容创作*中创建。
- en: Draw Text
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制文本
- en: This event will display a string of text provided by **Display Text** on the
    screen. Be sure to set a value for?? **Display Font** using one of the fonts provided
    in the **Content Browser**. There are two **Text Draw Method** choices in how
    the text is going to be drawn on the screen; **DRAW_CenterText** which centers
    the text horizontally from the **Display Location** variable and **DRAW_WrapText**
    which draws the text wrapped starting from the **Display Location**. The text
    will be displayed as long as **Active/Is Active** are set to **TRUE**. The **Target**
    is the player that we want this information to be displayed to and will typically
    be the Player.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件将在屏幕上显示由**显示文本**提供的文本字符串。请确保使用**内容浏览器**中提供的字体之一设置**显示字体**的值。在屏幕上绘制文本的方式有两种**文本绘制方法**选择；**DRAW_CenterText**，它从**显示位置**变量水平居中文本，和**DRAW_WrapText**，它从**显示位置**开始绘制文本。只要**激活/是否激活**设置为**TRUE**，文本就会显示。**目标**是我们希望显示此信息的玩家，通常将是玩家。
- en: Like our **Draw Image** event, there is a variable called **Authored Global
    Scale** which specifies the scale factor of the display the content is being used
    in. A value of **2.0** is useful for high resolution screens like the iPhone 4S
    and new iPad, while **1.0** is useful for standard resolution screens such as
    the iPad and older iPhones/iPod Touches. It is also worth noting that the **Out**
    output does not actually get called.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的**绘制图像**事件一样，有一个名为**已发布全局缩放**的变量，它指定了内容所使用的显示缩放因子。**2.0**的值对于iPhone 4S和新iPad等高分辨率屏幕很有用，而**1.0**对于iPad和较旧的iPhone/iPod
    Touch等标准分辨率屏幕很有用。还值得注意的是，**输出**实际上并没有被调用。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This will not work with the gametype of **UTDeathmatch**. We will make use of
    this for our Main Menu, which we will be creating in [Chapter 7](ch07.html "Chapter 7. Advanced
    Content Creation for Urban Warrior"), *Advanced Content Creati on for Urban Warrior*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不适用于**UTDeathmatch**游戏类型。我们将利用这一点来制作我们的主菜单，我们将在[第7章](ch07.html "第7章。城市战士的高级内容创作")，*城市战士的高级内容创作*中创建。
- en: '![Draw Text](img/image_1901_04_36.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![绘制文本](img/image_1901_04_36.jpg)'
- en: This action is found in **New Event** | **HUD** | **Draw Text**.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作位于**新事件** | **HUD** | **绘制文本**。
- en: Give some input to the situation
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向该情况输入一些信息
- en: With that basic overview of the different mobile-specific sequence objects,
    let's put that knowledge to some good use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在对不同的移动特定序列对象有了一个基本的概述之后，让我们将这项知识用于一些有用的地方。
- en: Time for action—adding input
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——添加输入
- en: Right now in our game, we use the two joysticks that are provided in order to
    move around and glance around the world. If you tap the middle of the screen,
    the gun will fire, but there are other things that players can do that are already
    pre-written into the gametype. With a few of the new Kismet sequence objects we
    have learned about, we are going to create buttons that will allow the player
    to shoot, use their alternative fire, and jump.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在我们的游戏中，我们使用提供的两个摇杆来移动和环顾世界。如果你点击屏幕中央，枪会开火，但玩家还可以执行游戏类型中已经预先编写好的其他操作。我们将使用我们刚刚学到的几个新的Kismet序列对象，创建按钮，让玩家能够射击、使用替代射击和跳跃。
- en: Open up the Kismet editor by pressing the **K** button.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按**K**按钮打开Kismet编辑器。
- en: Create an **Add Input Zone** action by right-clicking and selecting **New Action**
    | **Mobile** | **Add Input Zone**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择**新建动作** | **移动** | **添加输入区域**来创建一个**添加输入区域**动作。
- en: Expand the **Seq Act Mobile Add Input Zones** tab and set the value of **Zone
    Name** to **AltFire**.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**序列动作移动添加输入区域**选项卡，并将**区域名称**的值设置为**AltFire**。
- en: Click on the blue triangle icon on the far end of **New Zone**, and then click
    on **MobileInputZone** to create a new zone we can use.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新区域**远端的蓝色三角形图标，然后点击**移动输入区域**以创建一个我们可以使用的新区域。
- en: Expand the **Zone** tab and set the value of **Caption** to **AltFire**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**区域**选项卡，并将**标题**的值设置为**AltFire**。
- en: Expand the **Input** tab and set the value of **Input Key** to `GBA_AltFire`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**输入**选项卡，并将**输入键**的值设置为`GBA_AltFire`。
- en: Expand the **Bounds** tab and set the value of **X** to **-100.0** and **Y**
    to **-300**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**边界**选项卡，并将**X**的值设置为**-100.0**，将**Y**的值设置为**-300**。
- en: The **X** and **Y** values of the bounds, if positive, will be moved from the
    top-left of the screen. Placing a negative number in either of the axes will cause
    the **HUD** to move the display to the bottom right-hand side edge of the viewport,
    which is what we want to achieve. We want to place our **HUD** buttons on the
    bottom right-hand side near the joystick used for glancing, so we use a negative
    number for each axis. Note that these values given were meant for the iPhone;
    they will need to be adjusted for use on other iOS devices.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 边界框的**X**和**Y**值，如果为正数，将从屏幕的左上角移动。在任一轴上放置负数将导致**HUD**将显示移动到视口的右下角边缘，这是我们想要达到的效果。我们希望将**HUD**按钮放置在靠近用于扫视的摇杆的右下角，因此我们为每个轴使用负数。请注意，这些值是为iPhone设计的；在其他iOS设备上使用时需要调整。
- en: Expand the **Rendering** tab and click on **Render Color**. Change it to some
    value that will be easily seen in your level. I picked blue for this level.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**渲染**选项卡，并点击**渲染颜色**。将其更改为在您的关卡中易于看到的一些值。我选择了蓝色用于这个关卡。
- en: Copy the **Add Input Zone** action and paste two copies of them inside our Kismet
    workspace. In the first copy, change the **Zone Name** and **Caption** variables
    to **Jump** and set the **Input Key** to **GBA_Jump** with a position of (**-200**,
    **-350**) in the **Bounds**. For the second one, change the **Zone Name** and
    **Caption** variables to **Fire** and set the **Input Key** to **GBA_Fire** with
    a position of (**-300**, **-300**) in the **Bounds**.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**添加输入区域**动作，并在我们的Kismet工作区内部粘贴两个副本。在第一个副本中，将**区域名称**和**标题**变量更改为**跳跃**，并将**输入键**设置为**GBA_Jump**，在**边界**中的位置为（**-200**，**-350**）。对于第二个，将**区域名称**和**标题**变量更改为**开火**，并将**输入键**设置为**GBA_Fire**，在**边界**中的位置为（**-300**，**-300**）。
- en: From the **Out** output of the **Console Command** Mode, connect our **Add Input
    Zone** sequence objects one after the other.![Time for action—adding input](img/image_1901_04_37.jpg)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控制台命令模式**的**Out**输出连接我们的**添加输入区域**序列对象，一个接一个。![行动时间——添加输入](img/image_1901_04_37.jpg)
- en: Save your project (**File** | **Save**) and start your game by clicking on the
    **Start Mobile Previewer** button on the main toolbar.![Time for action—adding
    input](img/image_1901_04_38.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目（**文件** | **保存**），然后通过点击主工具栏上的**开始移动预览器**按钮来开始您的游戏。![行动时间——添加输入](img/image_1901_04_38.jpg)
- en: What just happened?
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We've now created our own custom input buttons allowing us to jump, fire, and
    shoot our alternative fire while? retaining the original movement options. This
    will be quite useful when we get new weapons such as the rocket launcher, or if
    we want to provide platforming of a sort to our game.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了自己的自定义输入按钮，允许我们跳跃、开火和射击替代开火，同时保留原始移动选项。当我们获得新的武器，如火箭发射器，或者如果我们想为我们的游戏提供某种平台跳跃时，这将非常有用。
- en: Have a go hero—mobile sequence objects / adding input
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄，尝试一下——移动序列对象/添加输入
- en: Using the sequence objects described previously, it would be very simple to
    create many different kinds of games, including a hidden object game, where you
    are given two images that are almost exactly the same, aside from a few differences.
    Upon touching one of the differences, it would be hidden and you'd be closer to
    finding all of them. Prototype this functionality by using the **Mobile Object
    Picker** event, and the **Toggle Hidden** action to hide the door object we created
    when you click on it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前描述的序列对象，创建许多不同类型的游戏将非常简单，包括一个隐藏对象游戏，其中你被给出两张几乎完全相同但略有不同的图像。当你触摸其中一个差异时，它将被隐藏，你将更接近找到所有差异。通过使用**移动对象选择器**事件和**切换隐藏**动作来隐藏我们创建的门对象，当你点击它时。
- en: Pop quiz
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: Which of the following is not a Kismet object type?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是Kismet对象类型？
- en: a. Events
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 事件
- en: b. Actions
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 动作
- en: c. Console Command
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 控制台命令
- en: d. Conditions
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 条件
- en: What effect does changing the Max Trigger Count to 0 do?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最大触发次数更改为0会产生什么效果？
- en: a. The event will be triggered an infinite amount of times.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 事件将被无限次触发。
- en: b. It is not used anymore but exists for backwards compatibility, so there is
    no effect.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 它不再使用，但存在以保持向后兼容性，所以没有效果。
- en: c. Tells UDK how many Trigger/Trigger Volume may exist in our level.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 告诉UDK在我们的级别中可能存在多少触发/触发体积。
- en: d. The event will not be triggered until its value is larger.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 事件将不会触发，直到其值更大。
- en: What Kismet Event would I use to get information from the iOS device's gyroscope?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将使用哪个Kismet事件来从iOS设备的陀螺仪获取信息？
- en: a. Touch Input
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 触摸输入
- en: b. Analog Input
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 模拟输入
- en: c. Mobile Input Access
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 移动输入访问
- en: d. Mobile Simple Swipes
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 移动简单滑动
- en: How would I remove the two joysticks that are included in our gametype?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我该如何移除我们游戏类型中包含的两个操纵杆？
- en: a. Clear Input Zones
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 清除输入区域
- en: b. Remove Input Zone for each joystick
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 为每个操纵杆移除输入区域
- en: c. Modify the RequiredMobileInputConfigs of DefaultGameUDK.ini
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 修改DefaultGameUDK.ini中的RequiredMobileInputConfigs
- en: d. All of the above
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 所有上述
- en: What type of actor do we use in order to change the player's vision?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪种Actor来改变玩家的视野？
- en: a. Player Spawned
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 玩家生成
- en: b. Matinee
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. Matinee
- en: c. VisionActor
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 视觉Actor
- en: d. CameraActor
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 摄像机Actor
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about Unreal's advanced systems of Kismet in
    Matinee. We've implemented them both individually and together to see how they
    can be used to create a more interesting and dynamic experience within our game
    world. Using this fundamental knowledge, you can basically create any type of
    game you want; the possibilities are limitless!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关于Unreal引擎Matinee中Kismet的高级系统学到了很多。我们分别和一起实现了它们，以了解它们如何被用来在我们的游戏世界中创造更有趣和动态的体验。利用这些基本知识，你基本上可以创建任何你想要的类型游戏；可能性是无限的！
- en: In this short period of time, we've managed to cover quite a lot of things.
    We've specifically learned the following
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个短暂的时间内，我们设法覆盖了很多内容。我们具体学习了以下内容
- en: What Kismet is and how it can be used to create level-based events and prototyping
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Kismet以及如何用它来创建基于级别的活动和原型设计
- en: How to call console commands at runtime allowing us to change to a third-person
    perspective
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在运行时调用控制台命令，使我们能够改变到第三人称视角
- en: What Kismet should be used for and reasons why we would or would not decide
    to use it
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kismet应该用于什么，以及为什么我们会或不会决定使用它
- en: How Matinee is the cinematic tool of the Unreal Engine and allows designers
    to give exact direction in how things work in the engine
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matinee是如何成为Unreal引擎的电影工具，并允许设计师在引擎中精确地指示事物的工作方式
- en: How to create an introductory cutscene bringing players into our world
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个介绍性场景，将玩家带入我们的世界
- en: What the implementation of an automatic door using aspects of both Kismet and
    Matinee would look like
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kismet和Matinee的方面实现自动门的实现会是什么样子
- en: How Kismet is different on the Mobile platform and the extra functionality we
    get from that
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kismet在移动平台上的不同之处以及我们从那里获得的额外功能
- en: How to add functionality missing from the gametype using Sequence Objects we
    discussed previously
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用我们之前讨论的序列对象添加游戏类型中缺失的功能
- en: Now that we've learned about the basics of Kismet and Matinee, we're ready to
    explore how we can take our knowledge of Kismet to the next level and begin taking
    more steps towards building our Urban Warrior project.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Kismet和Matinee的基础知识，我们准备好探索如何将我们对Kismet的了解提升到下一个层次，并开始朝着构建我们的Urban
    Warrior项目迈出更多步伐。
- en: In the next chapter, we will be creating some dynamic action sequences by creating
    more complex systems, such as regenerating health (the console FPS favorite) and
    spawning enemies whose behavior and placement seem as realistic as possible.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过创建更复杂的系统，如恢复生命值（控制台FPS的喜爱）和生成看起来尽可能真实的敌人的行为和位置，来创建一些动态的动作序列。
