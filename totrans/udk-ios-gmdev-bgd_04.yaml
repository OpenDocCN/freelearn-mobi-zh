- en: Chapter 4. Using Kismet and Matinee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have learned how the basic interface of UDK works
    and how to build a basic environment. This is all well and good, but at the moment,
    all we can do is walk in the world while looking around. Don't we wish we could
    do something there?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a look at **Kismet** and **Matinee**,
    two of the most popular ways to create motion in our otherwise static world. This
    should help breathe life into the world of our game. After all, actions do speak
    louder than words.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn what Kismet is and what we can do with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Kismet to change our project's viewpoint to a third-person perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss Kismet and the benefits and drawbacks of its usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the Matinee editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a cinematic using Matinee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use both Kismet and Matinee to create an automatic door
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about sequence objects specifically made for mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about Mobile Input and add functionality to our iOS game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But before we dive into creating new things for our game, first let's get an
    understanding for what Kismet actually is and what it can be used for.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Kismet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kismet?** is a system of visual scripting in UDK that makes it possible for
    people to affect the game world and design gameplay events. For teams without
    a programmer, Kismet can be a Godsend; it makes it possible for someone without
    any coding knowledge to do things that would otherwise require the use of **UnrealScript**,
    a programming language that the Unreal Engine uses.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a? sequence of events, you have to connect a series of sequence
    objects together. This, in turn, generates code when the game is run, which causes
    it to do the things that you said it should do. It would be easy for me to write
    a book entirely about things that can be done in Kismet, but as we are planning
    on creating a third person shooter for the iOS, I will refrain from straying too
    far from that. However, we will be discussing the creation of more and more complex
    sequences as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Kismet sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned what Kismet is and what it can do for us, let's see it
    used in action and see how easy it is to get results!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—changing the level to a third-person perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The? default perspective given to players in UDK is first-person. Let's say
    we want it to be in third-person instead. It will be quite easy to do so due to
    Epic's console command which does just that. However, in order to first simplify
    learning Kismet as much as possible and practice what we've learned in previous
    chapters, we are going to be starting from scratch with a new level.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new map by selecting **File** | **New...** and then choose one
    of the four options at the top. I personally chose **Midday Lighting**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring up the **World Properties** menu by selecting **View** | **World Properties**
    from the menu bar at the top of the UDK interface. Type `Game Type` in the **Search**
    bar at the top of the **World Properties** menu, which will bring up the **Game
    Type** menu and the options relevant to us. From there, change the drop-down menus
    on both **Default Game Type** and **Game Type for PIE** to **UTDeathmatch**. While
    we are there in the **Zone Info** section, under **KillZ**, set the value to `-1000`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—changing the level to a third-person perspective](img/image_1901_04_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, before we get into Kismet, I want to explain what it is exactly that we
    are doing. Start up your game using the **Play** | **InEditor** option?. This
    starts up your game as it would be seen on the PC, so it is not representative
    of how the project will look on an iOS? device, but it will be easier to demonstrate
    the following change. When the game appears, press the *Tab* key and you will
    see a black bar appear on the screen. This is the console window, which can be
    used to execute different commands that Unreal has built in. The one we are going
    to be using right now, will toggle first and third person modes. With the console
    open, type in `behindview 1` and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also press the tilde (`~`) key to access the console window which will
    show all things logged during play as well as commands you've previously entered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—changing the level to a third-person perspective](img/image_1901_04_02(2).jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As you can see, the game switches your character to a third person mode. One
    of the? cool things about Kismet is we can, in fact, call these commands for the
    player, which is what we'll be doing in this demonstration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the Kismet interface by clicking on the **K** icon at the top of the
    UDK interface on the main toolbar. You should see a new window pop up that may
    look a bit daunting, but it's not too bad once you know what everything is.![Time
    for action—changing the level to a third-person perspective](img/image_1901_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the menu bars, you will see a large area with a lot of 1s and 0s
    on it. This is our workspace and where we will be placing all of the Sequence
    Objects that we create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bottom two bars are the **Properties** and **Sequences** windows. The **Properties**
    window will hold all of the data that we will want to set within the sequence
    objects, that we will be creating which can be accessed when we left-click on
    them. All of our work in this chapter will be in the same sequence, so we will
    not need to use the **Sequences** window, but we will be going over it in [Chapter
    5](ch05.html "Chapter 5. Action Sequences for Urban Warrior"), *Acti on Sequences
    for Urban Warrior*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere inside the large area in the upper portion of the interface.
    Choose to create a **Player Spawned** event by choosing **New Event** | **Player**
    | **Player Spawned** from the menu that pops up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click? on the **Player Spawned Event Sequence** object so that the **Properties**
    window comes up and change the value of **Max Trigger Count** from `1` to `0`.![Time
    for action—changing the level to a third-person perspective](img/image_1901_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having a value of 0 means that it can be triggered an infinite number of times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click under the instigator connection (the purple/pink arrow) and select
    **Create New Object Variable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a **Console Command** action by choosing **New Action**
    | **Misc** | **Console Command** from the menus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the properties, type `behindview 1` as the value for **Commands[0]**.![Time
    for action—changing the level to a third-person perspective](img/image_1901_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output from the **Player Spawned** event to the input of the **Console
    Command** action by clicking on the square on the right-hand side of the **Out**
    text on the **Player Spawned** event and dragging your mouse, until it reaches
    the black square on the left-hand side of the **In** text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the connector of both the **Instigator** and **Target** to the **Object**
    variable we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By this point your Kismet should look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—changing the level to a third-person perspective](img/image_1901_04_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now start your game by clicking on the **Start Mobile Previewer** button on
    the main toolbar.? You will see the following screenshot:![Time for action—changing
    the level to a third-person perspective](img/image_1901_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upon starting the game, when the player is spawned (the **Player Spawned** event
    is activated), we change our perspective to be in the third person (the **Console
    Command** action is called).? We've also learned some fundamentals in working
    with Kismet and have an understanding of how sequence objects connect to create
    different effects. Not too shabby for only using two sequence objects.
  prefs: []
  type: TYPE_NORMAL
- en: Kismet primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working? with Kismet, some of the terms may be difficult to understand
    at first, so I would like to quickly go over some aspects of Kismet in general.
  prefs: []
  type: TYPE_NORMAL
- en: Parts of a sequence object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every node we work with is called a **sequence object**, because it is an object
    within a sequence. We will be talking more about sequences in [Chapter 6](ch06.html
    "Chapter 6. Bringing it All Together"), *Bringing It All Together*, but for now
    let's talk about the parts that make up a Kismet node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Parts of a sequence object](img/image_1901_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The left-hand side of a sequence object is? called the **Input**; while the
    right-hand side is called the **Output**. The following are the variables that
    are either values given to us, or that we set depending on the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different kinds of sequence objects, three of which we will
    be using in this chapter and we will be using the fourth in [Chapter 5](ch05.html
    "Chapter 5. Action Sequences for Urban Warrior"), *Action sequences For Urban
    Warrior*. The following screenshot shows the sequence objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parts of a sequence object](img/image_1901_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Events**: This is what all other sequence? objects get called from. Code
    in Kismet only gets called if a certain thing happens, like the **Player Spawned**
    event that was called when the player spawns in our level. These objects are red
    and are shaped like diamonds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: These perform a defined task when an event is triggered. This
    is the most used item, so it is the object with the most variety. The **Console
    Command** action, as well as the **Delay** used previously, is an example of an
    action. Actions are presented as rectangles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables**: These are what hold information within our level. If another
    sequence object has squares underneath it, that is a spot that holds a variable.
    They are colored differently depending on what the variable actually is. The instigator
    in the **Player Spawned** event? is a variable that is filled with our player''s
    information when it is called, and the **Blue** number under the **Delay** variable
    in the previous screenshot is a float variable with the value of `2.0`. We will
    be using variables extensively in [Chapter 6](ch06.html "Chapter 6. Bringing it
    All Together"), *Bringing It All Together*. Variables are represented as circles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conditions**: These actions are special in the fact? that they can do different
    things based on the values of different objects used for comparing numbers or
    objects. They are used to control the flow of things within a sequence. The **Compare
    Objects** condition is an example of a condition. Conditions are traditionally
    blue and are rectangular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and drawbacks of using Kismet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with any job, it is important to use the tool that is appropriate for it.
    UDK provides three ways of giving interactivity to the game world: Kismet (which
    we are discussing), Matinee (which we are going to discuss), and UnrealScript
    (which is out of the scope of this book, but it is covered extremely well in *Unreal
    Development Kit Game Programming with UnrealScript: Beginner''s Guide* by *Rachel
    Cordone* which is also available from Packt Publishing). All three have specific
    advantages and disadvantages to them, but Kismet is the one that I use most often.'
  prefs: []
  type: TYPE_NORMAL
- en: As you expand your research into UDK after reading this book, you may see forum
    posts with people asking how to do something in Kismet. A lot of people will reply
    to telling them to learn UnrealScript instead. While they may seem arrogant, there
    are some reasons why they are saying to use that tool. I've included a list of
    pros and cons of Kismet which may help you, afterwards, in deciding if it is the
    correct tool for what you're working on.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using Kismet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kismet is a wonderful tool and is a great starting point when first starting
    out with UDK. Some other benefits associated with Kismet are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Having a lower barrier to entry**: No programming knowledge is needed so
    it is easier to get started and you can start creating games now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Great for prototyping gameplay mechanics**: Saying a mechanic is going to
    be fun is one thing, but no one is going to believe you unless you can prove it.
    Kismet makes it extremely easy to get something up quickly. As a designer, having
    something to show a programmer will make it much easier for them to translate
    to code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Great for one-off events**: If your level needs to have something specific
    or only at a specific time or level events like an explosion, Kismet is a great
    tool to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to see the flow of events**: If you are more of a visual thinker or
    like to stare at something to see the big picture, it is a lot easier to use Kismet.
    The Sequence Objects and colors all mean something specific to make it easy to
    discern what is going on within a specific scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easily extendable with UnrealScript**: With knowledge of how UnrealScript
    works, it is possible to create custom sequence objects of your own to create
    actions of your very own. If your game would have a dialogue system, creating
    a custom **Show Dialog** action would be possible in Kismet to make it easy to
    create entire dialog trees within Kismet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, Kismet is not the be-all and end-all solution for everything that
    can possibly be done with UDK. Here are some of the drawbacks that using Kismet
    may have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity issues**: As you get more comfortable using Kismet, you will probably
    try to? do more and more complex things with it (I know I have). If you are not
    careful you may have problems reading what your code is actually doing. Basically,
    the more complex a sequence gets, the harder it is to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reiterations**: Many times in a game, you will want to have the same thing
    happen if you interact with a similar or identical object, like a door. If you
    want the same behavior with multiple objects or multiple levels, you have to paste
    it every single time you want to have that action happen. This can quickly stockpile
    into a really large amount of sequence objects which could be avoided if you wrote
    an UnrealScript file with the same behavior and made that object use that file
    to execute the actions within it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level Specific**: In much the same way Kismet is also specific to just the
    level that it is created in. For instance, if we wanted to create ten levels in
    our game, we would have to do the console command event in every single level.
    With UnrealScript, this would be built into the code base for the game and be
    automatic for all levels of the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kismet can''t do everything you''d like to in a game**: The truth is that
    the game Unreal Engine 3 was created to make a **First Person Shooter** (**FPS**),
    and the further you stray from that path, the harder it is going to be to create
    your game. That''s not to say UDK can''t be used to create other games. It''s
    just going to be much more difficult as the sequence objects in Kismet are meant
    to create an FPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More custom behavior requires UnrealScript**: Continuing with the previous
    point, most of the time a game does something such as a game mechanics that UDK
    doesn''t seem to do (like the Scarecrow boss battles in *Batman: Arkham Asylum*,
    "Plasmids" in *Bioshock 1* and *2*, or the jet packs in *Dark Void*). These examples
    probably use UnrealScript or C++ code to achieve the desired result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kismet is slower than UnrealScript**: While it will not matter with the project
    that we are creating now, as Kismet is basically a prewritten UnrealScript executed
    in a certain order, Kismet is slower than what could be achieved using just UnrealScript,
    and something that your game will continuously use would best be done with UnrealScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a go hero—Kismet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Console commands can do a lot of different things, giving you access to a lot
    of prewritten code including opening other maps (`open levelname`), and quitting
    the game (`quit`).
  prefs: []
  type: TYPE_NORMAL
- en: Try to make the game open another map when you start the level.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Matinee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Matinee** tool is the driving force of all cinematic effects within the
    Unreal Engine. It gives users the ability to be the director within your game,
    giving you control over the camera, actor's movement, sound, as well as different
    cuts and animation effects. Think of any moment in an Unreal game where you didn't
    have direct control over the character, like a cutscene. Chances are, that was
    done in Matinee. However, Matinee can be used for many other things which we will
    discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a Matinee, we will use the (aptly named) Matinee Editor which
    can be accessed from within the Kismet menu.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Matinee movie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having defined what Matinee is used for, let's begin using it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—opening cutscene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As things are, when the game begins we are brought straight into the action
    with no prior warning. In order to prepare the player and give them an idea of
    where they are, let's create a cutscene!
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there, you will see a list of classes that we can place within
    our level. Left-click on the **CameraActor** selection.![Time for action—opening
    cutscene](img/image_1901_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close out the **Actor Classes** browser and right-click anywhere in your level.
    From the menu that pops up, select **Create CameraActor Here**. This will create
    an actor on the ground, in the spot in the spot where you clicked. It may be a
    good idea to position the camera above the player and looking at it.![Time for
    action—opening cutscene](img/image_1901_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it isn't already up, open the Kismet editor by clicking on the **K** icon
    at the top of the UDK interface on the main toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Matinee by right-clicking inside the large area in the upper portion
    of the interface and selecting **New Matinee**. You should see an orange square
    pop out with a lot of different inputs and outputs.![Time for action—opening cutscene](img/image_1901_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the object to enter the Matinee editor as shown in the following
    screenshot:![Time for action—opening cutscene](img/image_1901_04_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minimize Matinee and select your **CameraActor** on the main screen by left-clicking
    on it and then bringing Matinee up. Right-click inside the **Group List** (the
    dark-grey column below all the tabs with text and at left-hand side to the timeline.)
    From the **Context** menu that appears, click on **Add New Camera Group**. When
    prompted for a name type in `Camera`.![Time for action—opening cutscene](img/image_1901_04_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click on the little camera icon in the top-left of the **Camera** group,
    you will see the **Perspective** viewport changes into the camera's view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the camera icon doesn't show up, that means the camera is not connected to
    the group. To fix this, left-click on your camera inside the editor and then go
    back into Kismet. From there, right-click below the **Camera** text in the Matinee
    that we have created and select **Create New Object Var Using CameraActor_0**
    and connect it to the **Camera** slot.![Time for action—opening cutscene](img/image_1901_04_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Movement** track on the **Camera** and then click on the first
    keyframe (the red triangle located in the timeline). You will notice that the
    bottom of the **Perspective** viewport changes its text to **ADJUST KEY Movement0**.
    Now if you move within the viewport, it will transfer over to the Camera actor
    that we have created. Once you have moved your camera to the spot where? you want
    it, click outside of the keyframe in the Matinee window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click underneath **Camera** and select **Add New Director Group**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the **Director** track and then click on the **Add Key** icon
    which is the first icon just below the **File** menu (circled in the following
    screenshot in red) to add a new keyframe,to say, we want to use a different camera
    at this position. Select to use **Camera for the Cut To Group** and click on **OK**.![Time
    for action—opening cutscene](img/image_1901_04_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the **Movement** track again. Drag the time slider from **0.00**
    to the **2.00** second mark, to the grey bar along the bottom of the Matinee area
    where all of the numbers are located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the **Add Key** icon to add a new keyframe to our movie. If all
    goes well, you should see something similar to the following screenshot:![Time
    for action—opening cutscene](img/image_1901_04_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the keyframe selected, move the camera closer to the player. At this point,
    if you drag the time slider, you will notice that the camera moves between the?
    two points that we have created over the course of two seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click somewhere else on the timeline to remove the focus on the keyframe.
    Move the mouse scroller down in order to zoom-out from the timeline. You will
    notice a pink triangle pointing outwards at the 5.00 mark. That object marks the
    ending of the Matinee sequence, so click on it and drag it to the second mark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also right-click on it and select **Move to Longest Track Endpoint**
    and it will automatically snap to the last keyframe added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close up Matinee and bring Kismet back up. Right-click next to the **Console
    Command** action that we created earlier, and select **NewAction** | **Toggle**
    | **ToggleCinematicMode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the properties for the **ToggleCinematicMode**, disable the **HidePlayer**
    option. Connect the **Target** to the **Instigator** from the **Player Spawned**
    event we created in the previous example. Left-click on the sequence object and
    copy it by pressing *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the sequence object by pressing *Ctrl* + *V* and move the created sequence
    object to the right-hand side of the Matinee by holding *Ctrl* and dragging while
    it is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the connections to the **Console Command** action by holding the *Alt*
    key and clicking on the **In** and **Out** connectors. Drag the action next to
    the second? **Toggle Cinematic Mode** action by clicking on it, holding *Ctrl*
    and dragging it over. Connect the **Out** from the **Player Spawned** action to
    the **Enable** of the first **Toggle Cinematic Mode**. Connect that **Out** to
    the **Play** of the Matinee, connect the **Completed** output to the **Disable**
    input of the second Toggle Cinematic Mode, and finally, connect the **Out** on
    the **Toggle Cinematic Mode** to the input on the **Console Command**.![Time for
    action—opening cutscene](img/image_1901_04_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project (**File** | **Save**) and start your game by clicking on the
    **Start Mobile Previewer** button on the main toolbar.![Time for action—opening
    cutscene](img/image_1901_04_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created our first cinematic moment in Unreal! Now when our game starts,
    we zoom into our character enabling our players to get ready for the action leading
    up ahead. While it may have been a bit of a hassle to get such a simple movement,
    it is easy to see the great potential to create many exciting things with the
    Matinee tool!
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—Matinee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can easily add more key points to this opening cutscene and extend its length
    to as long as you want. You can also add another **CameraActor** and switch between
    cameras while the movie is going on. Take some time to coast through your level
    and maybe spin around the player as the game begins.
  prefs: []
  type: TYPE_NORMAL
- en: With our powers combined...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned some fundamentals of using Kismet and Matinee, let's
    do a non-trivial example of something that can be done with them both together.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—creating an automatic door
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your game takes place somewhere that humans reside, chances are you are going
    to have a door, and as a? player, we are drawn to them to continue a level. With
    that in mind, let's create a door that will automatically open for us when someone
    comes near it, and close when it is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Go back into the main editor window and access the **Content Browser** via **View**
    | **BrowserWindows** | **ContentBrowser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Object Type** tab, check the **Static Meshes** option as we only want
    to see Static Meshes. In the top search bar, type in `doorway`. Left-click on
    the mesh selected and close the **Content Browser**.![Time for action—creating
    an automatic door](img/image_1901_04_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click somewhere in your level and select **AddActor** | **LoadStaticMesh:S_LT_Doors_SM_DoorWar04**.
    Right-click again and select **Add Static StaticMesh:S_LT_Doors_SM_DoorWar04**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the door we placed and select **Convert** | **ConvertStaticMeshActortoMover?**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go into the properties for the door (*F4*) and type `collision` into the search
    bar. Change the **CollisionType** variable on the bottom to **COLLIDE_BlockAll**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Builder Brush** and **Additive Geometry** discussed in [Chapter 2](ch02.html
    "Chapter 2. Beginning Urban Warrior, a Third-person Shooter"), *Beginning Urban
    Warrior; a First Person Shooter* to build a brush on each side of the door and
    one on top that covers the entire distance above the door.![Time for action—creating
    an automatic door](img/image_1901_04_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how the brush does not go all the way to the door and, if we make the
    brush larger, it will cover part? of the door. Luckily for us, there is an easy
    way to make the walls flush with the door we want to use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the **Side** viewport and click on the button that looks like a 3D cube
    to go into **Geometry Mode**. Click on the right side brush and make sure you
    are in translation mode by either clicking on the menu icon that looks like four
    arrows crossing, or by pressing *Spacebar* until you see the arrows to translate.
    Click on the top square at left-hand side to turn it red so that it is selected
    and drag it over to the edge of the door Do the opposite for the other brush.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I will be going over **Geometry Mode** and how it can be used to create gameplay
    areas and allow for fast prototyping of gameplay areas in [Chapter 6](ch06.html
    "Chapter 6. Bringing it All Together"), *Bringing It All Together*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—creating an automatic door](img/image_1901_04_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Use the **Top** viewport and create a brush that is in the middle of the door
    with space in front and behind the door. Right-click on that brush and select
    **Convert** | **ConverttoVolume** | **Trigger Volume?** to change the brush into
    a trigger volume. After this, save your map and click on **Build All**.![Time
    for action—creating an automatic door](img/image_1901_04_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Trigger Volume** that we've created to select it and open the
    Kismet editor by clicking on the **K** icon at the top of the UDK interface on
    the main toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere inside the large area in the upper portion of the interface.
    Create a **Trigger Volume Touch** event by choosing **New Event using TriggerVolume_0**
    | **Touch** from the menu that pops up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the **TriggerVolume_0 Touch** event object so that the properties
    window comes up and change the value of **MaxTriggerCount** from `1` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to have a sound play when the door opens and when it closes, so create
    two **Play Sound** actions using **NewAction** | **Sound** | **PlaySound**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go into the **Content Browser** and change the object type you're looking for
    to **SoundCue** and change the search to just **door**. Select the first SoundCue
    **A_Door_Metal03_CloseStartCue** and go back into Kismet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the bottom **Play Sound** action. Inside the properties, you should see
    an icon that looks like a green arrow pointing at the left-hand side, next to
    the **PlaySound** property. Click on that button and it should fill the box with
    the value of what you have selected in the **Content Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps from step 13 to step 14 using **A_Door_Metal03_OpenStartCue** and
    the top **PlaySound** respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in the editor, click on the door and go back into Kismet. Create a new
    Matinee object by right-clicking next to the **Touch Event** and selecting **NewMatinee**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go into the Matinee editor by double-clicking on the Matinee. Right-click inside
    the **Group List** and click on **AddNewCameraGroup**. When prompted for a name,
    type in `Door`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a keyframe at the `0.50` position and, with it selected, left-click on
    the door in the **Perspective** viewport. Move the door to the left-hand side
    till it completely leaves the opening, making it possible for people to pass through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the end of the Matinee sequence (the pink triangle pointing out)
    and select **MovetoLongestTrackEndpoint**. Close Matinee and bring Kismet back
    up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Target** of both **Play Sound** actions to be the door in our
    Matinee sequence, so that we will hear the sound coming from the door.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **TriggerVolume_0 Touch** event connect the **Touched** output to the
    **Play** input on the top **Play Sound** event. Then, connect the **Empty** output
    to the **Play** input on the bottom **Play Sound** event. Connect the **Out**
    on the top **Play Sound** to the **Play** on the Matinee sequence. Connect the
    **Out** on the bottom **Play Sound** to the **Reverse** input on the Matinee sequence.![Time
    for action—creating an automatic door](img/image_1901_04_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project (**File** | **Save**) and start your game by clicking on the
    **Start Mobile Previewer** button on the main toolbar.![Time for action—creating
    an automatic door](img/image_1901_04_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have created one of the most used interactive objects within games: a door.
    With this basic idea, it is possible to do many similar things, such as moving
    platforms and elevators, as well as complex things like machinima using a game
    engine to create a cinematic production like *Rooster Teeth''s Red versus Blue*
    or Epic''s own *Samaritan* demo. There''s plenty more you can do with Matinee,
    but it is best for you to explore on your own to discover things through experimentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Kismet for mobile devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the examples we have seen can be and are used in the normal version of
    UDK and transfer to? our mobile iOS game nicely. Most things in Kismet will work
    on mobiles as well, as long as the GameType supports it. Since it started supporting
    mobile devices, UDK has provided a set of sequence objects that are targeted for
    the mobile platform.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Kismet—actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the traditional UDK game that would require either changing `.ini` files
    or writing UnrealScript to accept and respond to input, UDK gives mobile developers
    the ability to do things how they want directly in Kismet. This allows developers
    to change input on a per-level basis.
  prefs: []
  type: TYPE_NORMAL
- en: Add Input Zone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Add Input Zone** displays an additional input zone to the screen. Zones need
    to have a unique name and will be referenced by their **Zone Name** property in
    other sequence objects when using them. We will be using this action later in
    the chapter in order to add buttons to our UI and learn how to create different
    kinds of zones for use in our project.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Add Input Zone](img/image_1901_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **NewAction** | **Mobile** | **AddInputZone**.
  prefs: []
  type: TYPE_NORMAL
- en: Clear Input Zone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This action removes all of the zones that were created or loaded at runtime.
    This basically leaves you with a clean slate to build an input scheme of your
    own. This is great if you are creating a game that does not require movement,
    or uses a different way of moving than what the provided ones do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Clear Input Zone](img/image_1901_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **NewAction** | **Mobile** | **ClearInputZones**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using this action would also remove the **UberStickMoveZone** and **UberStickLookZone**
    joystick inputs leaving only the **UberLookZoneInput** zone left. Be sure to add
    them back if you'd like to have them within your project. However, that being
    said, it is likely best for users to avoid using this Event unless it is for a
    specific purpose within a single level. If we don't want parts of the default
    input zones for all levels, it is best that we modify the **RequiredMobileInputConfigs**
    of the `DefaultGameUDK.ini` file to fit our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Remove Input Zone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This action allows you to remove an input zone by name; it is useful if you
    want to make an interaction?? only available at certain times of a game, like
    a save menu or a **Talk** button used for dialog. The **Zone Name** property can
    be found within the properties of the sequence object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Remove Input Zone](img/image_1901_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **NewAction** | **Mobile** | **RemoveInputZone**.
  prefs: []
  type: TYPE_NORMAL
- en: Save/Load values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This, as the name suggests, saves or loads variables created within Kismet from
    the hard drive using Kismet. You can hook up multiple variables to the same action
    allowing you to?? have as many variables as you like, but each variable needs
    to have a name within the **Var Name** property to be saved. I recommend that
    you use the same action for both loading and saving the same values. This way
    the order in which the variables are loaded are the same in which they were saved.
    If you have ten integers hooked to the same **Int Vars** holder Kismet does not
    guarantee the order in which it decides to place it and using the same action
    saves you the headache.
  prefs: []
  type: TYPE_NORMAL
- en: '![Save/Load values](img/image_1901_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **NewAction** | **Mobile** | **Save/LoadValues**.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Kismet—events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking the input from input zones, as well as the iPod's own gyroscopes and
    gadgets, we can make use of certain functionality with events, as well as create
    our own **HUD** graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Analog Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working on PC, Console, and Mobile, **Analog Input** will fire whenever an analog
    input, used with the **Input Name** that you set with, has a value.
  prefs: []
  type: TYPE_NORMAL
- en: Some values that you can use include `MobileYaw` and `MobilePitch` which give
    values from the device's gyroscope. These will give you float values inside of
    the **Float Value** variable. **DeviceAccelerometerRawData** will return a vector
    with the `Roll, Portrait Pitch`, and `Landscape Pitch` in the **Vector Value**
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that unless you set **Trap** input to **FALSE** (by
    unchecking it), nothing else will be able to receive any input events, including
    touches.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analog Input](img/image_1901_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **Input** | **AnalogInput**.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Button Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not referencing something that was already created from a `.ini`
    file, you will be using **Mobile Button Access** to trigger stuff within Kismet.
    This is similar to how the **Touch** event was shown previously. The property
    **Target Zone Name** should contain the name of an already created input zone.
    There are some properties that you can use, such as **Send Press Only On Touch
    Down** which will only call the **Input Pressed Output** when you click on the
    button and **Send Press Only On Touch Up** which will only be called when you
    remove your finger. Otherwise, as long as the button is held down, the action
    will be called.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile Button Access](img/image_1901_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **Input** | **Mobile Button Access**.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Input Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Mobile Input Access action is used whenever you have an input zone set with
    the value of **Mobile Input Zone** to **ZoneType_Joystick. Input Active** is called
    in each frame when the joystick is being used, while **Input Inactive** is used
    when it is released. Creating variables for the bottom sections gives you access
    to different values that you can use for interpreting how you are going to use
    the data. **X-Axis** and **Y-Axis** give you a value between **-1.0** and **1.0**,
    where **-1.0** is all the way down or left, and **1.0** is up or right. If you
    would prefer to be more precise, the four other values give you the pixel values
    of where the joystick's center and current position are.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile Input Access](img/image_1901_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **Input** | **MobileInputAccess**.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Look
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile Look is extremely similar to the **Mobile Input Access** event, in that
    they both have the same type of outputs and are used with an input zone with **ZoneType_Joystick**
    as the **Mobile Input Zone**. However, the **Mobile Look** action takes the data
    and converts it into a Vector that represents the current vertical and horizontal
    axes of the joystick, instead of individual values which can be easily applied
    to a pawn using **New Action** | **Actor** | **Set Actor Location**. The **Yaw?**
    represents the direction the joy stick is moving in **Unreal Rotator** units where
    **0** is straight up and the rotation increases clockwise. The **Strength** gives
    the distance of the current location of the touch to the center of the joystick
    in pixels. This can be quite useful for top-down games.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile Look](img/image_1901_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **Input** | **Mobile Look**.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Object Picker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mobile Object Picker** is a simple way to check if target object with collision
    is being touched by a **Touch** input if it is within the **Trace Distance** away
    from the player. It will only call once unless you set **Check on Touch** to **TRUE**,
    then it will call once every frame. Like everything that does an action every
    frame, it is advised to set a **Re Trigger Delay** to some value such as `0.2`
    in order to put less strain on the hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile Object Picker](img/image_1901_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **Input** | **Mobile Object Picker**.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Simple Swipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Mobile Simple Swipes** event provides a simplistic form of swipe detection
    using different outputs depending on the swipe's direction. The **Tolerance**
    variable can be set to allow a swipe to occur on a more or less straight line
    and the **Min Distance** variable sets how long the swipe needs to be to be considered
    a swipe to make the move more or less drastic. The bottom value in purple, **Touched
    Actors List**, returns an object list which contains all of the actors with collision
    that were touched in the process of the swipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile Simple Swipes](img/image_1901_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **Input** | **Mobile Simple Swipes**.
  prefs: []
  type: TYPE_NORMAL
- en: Touch Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any time the user touches the screen, it is considered a **Touch** event. The
    input system has the ability to track multiple touches at the same time by using
    the **Touch Index** with the **Touchpad Index** to refer to the input zone values
    that you provided. **Touch X** and **Touch Y** will give you the value in pixels
    of where in screen space they are and **Instigator** will refer to the **Player
    Controller** that did the touching. You may choose to use **Pressed** for a triggered
    event with **Repeated** to continue while the touch exists. **Released** will
    be called whenever the player removes his finger from the **Touch** event.
  prefs: []
  type: TYPE_NORMAL
- en: '![Touch Input](img/image_1901_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **Input** | **Touch Input**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless you set **Trap Input** to **FALSE** by unchecking it, you will be unable
    to use any other input zones while using this event.
  prefs: []
  type: TYPE_NORMAL
- en: Draw Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Draw Image** action displays the **Texture2D** image in **Display Texture**
    as a **HUD** of sorts for players to use within your game as long as **Active/Is
    Active** are set to be **TRUE**. The **XL** and **YL** values are used to show
    how large the image should be to display **1.0** means to fill the screen 100%
    within the respective axis. **U** and **L** are the location of the top-left corner
    of that texture to draw. **UL** and **VL** are the horizontal and vertical width
    in pixels of the portion of the texture to be drawn. Make sure to change the **Display
    Color** to white as that is the color that it will be modulated by.
  prefs: []
  type: TYPE_NORMAL
- en: There is a variable called **Authored Global Scale**, which specifies the scale
    factor of the display the content is being used in. A value of `2.0` is useful
    for high resolution screens like the iPhone 4S and new iPad, while `1.0` is useful
    for standard resolution screens such as the iPad and older iPhones/iPod Touches.
    It is also worth noting that the **Out** output does not actually get called.
  prefs: []
  type: TYPE_NORMAL
- en: '![Draw Image](img/image_1901_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **HUD** | **Draw Image**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will not work with the gametype of **UTDeathmatch**. We will make use of
    this for our Main Menu, which we will be creating in [Chapter 7](ch07.html "Chapter 7. Advanced
    Content Creation for Urban Warrior"), *Advanced Content Creati on for Urban Warrior*.
  prefs: []
  type: TYPE_NORMAL
- en: Draw Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This event will display a string of text provided by **Display Text** on the
    screen. Be sure to set a value for?? **Display Font** using one of the fonts provided
    in the **Content Browser**. There are two **Text Draw Method** choices in how
    the text is going to be drawn on the screen; **DRAW_CenterText** which centers
    the text horizontally from the **Display Location** variable and **DRAW_WrapText**
    which draws the text wrapped starting from the **Display Location**. The text
    will be displayed as long as **Active/Is Active** are set to **TRUE**. The **Target**
    is the player that we want this information to be displayed to and will typically
    be the Player.
  prefs: []
  type: TYPE_NORMAL
- en: Like our **Draw Image** event, there is a variable called **Authored Global
    Scale** which specifies the scale factor of the display the content is being used
    in. A value of **2.0** is useful for high resolution screens like the iPhone 4S
    and new iPad, while **1.0** is useful for standard resolution screens such as
    the iPad and older iPhones/iPod Touches. It is also worth noting that the **Out**
    output does not actually get called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will not work with the gametype of **UTDeathmatch**. We will make use of
    this for our Main Menu, which we will be creating in [Chapter 7](ch07.html "Chapter 7. Advanced
    Content Creation for Urban Warrior"), *Advanced Content Creati on for Urban Warrior*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Draw Text](img/image_1901_04_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action is found in **New Event** | **HUD** | **Draw Text**.
  prefs: []
  type: TYPE_NORMAL
- en: Give some input to the situation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that basic overview of the different mobile-specific sequence objects,
    let's put that knowledge to some good use.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now in our game, we use the two joysticks that are provided in order to
    move around and glance around the world. If you tap the middle of the screen,
    the gun will fire, but there are other things that players can do that are already
    pre-written into the gametype. With a few of the new Kismet sequence objects we
    have learned about, we are going to create buttons that will allow the player
    to shoot, use their alternative fire, and jump.
  prefs: []
  type: TYPE_NORMAL
- en: Open up the Kismet editor by pressing the **K** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **Add Input Zone** action by right-clicking and selecting **New Action**
    | **Mobile** | **Add Input Zone**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Seq Act Mobile Add Input Zones** tab and set the value of **Zone
    Name** to **AltFire**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the blue triangle icon on the far end of **New Zone**, and then click
    on **MobileInputZone** to create a new zone we can use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Zone** tab and set the value of **Caption** to **AltFire**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Input** tab and set the value of **Input Key** to `GBA_AltFire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Bounds** tab and set the value of **X** to **-100.0** and **Y**
    to **-300**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **X** and **Y** values of the bounds, if positive, will be moved from the
    top-left of the screen. Placing a negative number in either of the axes will cause
    the **HUD** to move the display to the bottom right-hand side edge of the viewport,
    which is what we want to achieve. We want to place our **HUD** buttons on the
    bottom right-hand side near the joystick used for glancing, so we use a negative
    number for each axis. Note that these values given were meant for the iPhone;
    they will need to be adjusted for use on other iOS devices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Expand the **Rendering** tab and click on **Render Color**. Change it to some
    value that will be easily seen in your level. I picked blue for this level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the **Add Input Zone** action and paste two copies of them inside our Kismet
    workspace. In the first copy, change the **Zone Name** and **Caption** variables
    to **Jump** and set the **Input Key** to **GBA_Jump** with a position of (**-200**,
    **-350**) in the **Bounds**. For the second one, change the **Zone Name** and
    **Caption** variables to **Fire** and set the **Input Key** to **GBA_Fire** with
    a position of (**-300**, **-300**) in the **Bounds**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Out** output of the **Console Command** Mode, connect our **Add Input
    Zone** sequence objects one after the other.![Time for action—adding input](img/image_1901_04_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project (**File** | **Save**) and start your game by clicking on the
    **Start Mobile Previewer** button on the main toolbar.![Time for action—adding
    input](img/image_1901_04_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now created our own custom input buttons allowing us to jump, fire, and
    shoot our alternative fire while? retaining the original movement options. This
    will be quite useful when we get new weapons such as the rocket launcher, or if
    we want to provide platforming of a sort to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—mobile sequence objects / adding input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the sequence objects described previously, it would be very simple to
    create many different kinds of games, including a hidden object game, where you
    are given two images that are almost exactly the same, aside from a few differences.
    Upon touching one of the differences, it would be hidden and you'd be closer to
    finding all of them. Prototype this functionality by using the **Mobile Object
    Picker** event, and the **Toggle Hidden** action to hide the door object we created
    when you click on it.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which of the following is not a Kismet object type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Events
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Actions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Console Command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Conditions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What effect does changing the Max Trigger Count to 0 do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The event will be triggered an infinite amount of times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. It is not used anymore but exists for backwards compatibility, so there is
    no effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Tells UDK how many Trigger/Trigger Volume may exist in our level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. The event will not be triggered until its value is larger.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What Kismet Event would I use to get information from the iOS device's gyroscope?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Touch Input
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Analog Input
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Mobile Input Access
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Mobile Simple Swipes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How would I remove the two joysticks that are included in our gametype?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Clear Input Zones
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Remove Input Zone for each joystick
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Modify the RequiredMobileInputConfigs of DefaultGameUDK.ini
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. All of the above
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What type of actor do we use in order to change the player's vision?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Player Spawned
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Matinee
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. VisionActor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. CameraActor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about Unreal's advanced systems of Kismet in
    Matinee. We've implemented them both individually and together to see how they
    can be used to create a more interesting and dynamic experience within our game
    world. Using this fundamental knowledge, you can basically create any type of
    game you want; the possibilities are limitless!
  prefs: []
  type: TYPE_NORMAL
- en: In this short period of time, we've managed to cover quite a lot of things.
    We've specifically learned the following
  prefs: []
  type: TYPE_NORMAL
- en: What Kismet is and how it can be used to create level-based events and prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to call console commands at runtime allowing us to change to a third-person
    perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Kismet should be used for and reasons why we would or would not decide
    to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Matinee is the cinematic tool of the Unreal Engine and allows designers
    to give exact direction in how things work in the engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an introductory cutscene bringing players into our world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the implementation of an automatic door using aspects of both Kismet and
    Matinee would look like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Kismet is different on the Mobile platform and the extra functionality we
    get from that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add functionality missing from the gametype using Sequence Objects we
    discussed previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned about the basics of Kismet and Matinee, we're ready to
    explore how we can take our knowledge of Kismet to the next level and begin taking
    more steps towards building our Urban Warrior project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be creating some dynamic action sequences by creating
    more complex systems, such as regenerating health (the console FPS favorite) and
    spawning enemies whose behavior and placement seem as realistic as possible.
  prefs: []
  type: TYPE_NORMAL
