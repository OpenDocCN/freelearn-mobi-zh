- en: Chapter 8. Introduction to Game Math and Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The Pythagorean theorem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn all the basic mathematical concepts that we will
    be using in the next few chapters of this book. While learning game physics, it's
    always good to have some basic command over mathematics and physics, as they are
    the main key components in making realistic games. For example, when we drop a
    ball on the ground, it keeps bouncing back and forth before coming to rest. To
    implement such conditions, we have to apply certain conditions to physical bodies
    by updating their physical parameters, such as restitution, force, bounce, friction,
    and so on. In the next chapter, we will use all the physics and mathematical concepts
    that we will learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Pythagorean theorem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most widely used triangles are right-angled triangles. There are many interesting
    properties of right-angled triangles that can be used in games to make life easier.
    One of the famous properties is that the square of the hypotenuse of a right-angled
    triangle is equal to the sum of the squares of the other two sides.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The hypotenuse of a triangle is the longest side of a right-angled triangle,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the hypotenuse is denoted as h, the Pythagorean theorem can be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: h² = a² +b²
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take the square root of both the sides, you will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: h = sqrt(a²+b²)
  prefs: []
  type: TYPE_NORMAL
- en: This means that if we know the length of any two sides of a right-angled triangle,
    we can easily find the length of the third side.
  prefs: []
  type: TYPE_NORMAL
- en: When working with the game's Artificial Intelligence (AI), we will be using
    the Pythagorean theorem frequently to calculate which agent is closer to the object.
    If side A is bigger than side B, then it will always be bigger, irrespective of
    whether the lengths are squared or not. Now, we can avoid taking the square roots
    to compare the distance. Instead, we can just compare the squared values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a practical usage of the Pythagorean theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a gunman at position X (8, 4) and his target at position
    Y (2, 1). The gunman can only fire a bullet a maximum distance of 10 units. Consequently,
    to determine whether he can hit the target, the distance between them must be
    calculated. This is easy to determine using the Pythagorean theorem. First, the
    lengths of the sides YZ and XZ shown in the following figure are calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find the distance XZ, the y component of the gunman''s position is subtracted
    from the y component of the target''s position as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: XZ = 4 - 1 = 3
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the distance YZ, we do the same, but with the x components:'
  prefs: []
  type: TYPE_NORMAL
- en: YZ =8 - 2 =6
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that YZ and XZ are known, the distance from the gunman to the target can
    be calculated using the Pythagorean theorem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Well within target range. Let the target be hit!
  prefs: []
  type: TYPE_NORMAL
- en: If you know the length of one of the sides of a right-angled triangle and one
    of the remaining two angles, you can determine everything else about the triangle
    using trigonometry. First, take a look at the following figure. It shows the names
    of each side of a right-angled triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is what the figure represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sin(θ) = opposite/hypotenuse*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cos(θ) = adjacent/hypotenuse*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tan(θ) = opposite/adjacent*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to see how the sine, cosine, and tangent functions can be utilized
    is by taking a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We want to calculate the length of the opposite side, given the length of the
    adjacent side and the angle. From here, we know that the tangent of an angle is
    equal to the opposite side divided by the adjacent side. Rearranging the equation
    a little gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*o = aTan(θ)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, all we have to do in order to get **o** is to pick up a calculator (to
    determine the tangent) and plug in the numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*o = 6Tan(0.9)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*= 7.56*'
  prefs: []
  type: TYPE_NORMAL
- en: Using vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using vector math frequently when designing the AI for our games.
    Vectors are used everywhere, from calculating which direction a game agent should
    shoot its gun in, to expressing the inputs and outputs of an artificial neural
    network. You should know them well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a point P as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: P = (x, y)
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-dimensional vector looks almost the same when written, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: V = (x, y)
  prefs: []
  type: TYPE_NORMAL
- en: 'However, although similar, a vector represents two components: direction and
    magnitude. The right-hand side of the following diagram shows the vector (9, 6)
    situated at the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using vectors](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The bearing of the arrow shows the direction of the vector, and the length of
    the line represents the magnitude of the vector. A vector can represent the velocity
    of a vehicle. The magnitude of the vector represents the speed of the vehicle,
    and the direction represents the heading of the vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: That's quite a lot of information from just two numbers (x, y). Vectors aren't
    restricted to two dimensions either. They can be any size at all. You would use
    a three-dimensional vector, (x, y, z), for example, to represent the velocity
    of a vehicle that moves in three dimensions, like a helicopter. Let's take a look
    at some of the things you can do with vectors.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vectors can be used in multiple ways, few of them are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying vectors is a cinch. You just multiply each component by the value.
    For example, the vector V (4, 5) multiplied by 2 is (8, 10).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The magnitude of a vector is its length. In the previous example, the magnitude
    of the vector V (4, 5) is the distance from the start point to the point P(4,
    5) which is illustrated in the following figure:![How to do it](img/00131.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is easy to calculate using the Pythagorean theorem as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: magnitude = ![How to do it](img/00132.jpeg)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you had a three-dimensional vector, then you would use the similar equation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: magnitude = ![How to do it](img/00133.jpeg)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Mathematicians place two vertical bars around a vector to denote its length,
    as shown in the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: magnitude = |V|
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Normalizing Vectors**: When a vector is normalized, it retains its direction
    but its magnitude is recalculated so that it is of unit length (a length of 1).
    To do this you divide each component of the vector by the magnitude of the vector.
    Mathematicians write the formula as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: N = V/|V|
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Therefore, to normalize the vector (4, 5), you would do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new X = 4 /6.403 = 0.62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new Y = 5 /6.403 = 0.78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Resolving Vectors**: It''s possible to use trigonometry to resolve a vector
    into two separate vectors, one parallel to the *x* axis and one to the *y* axis.
    Take a look at the vector, V, representing the thrust of a jet fighter at point
    V, as shown in the following figure:![How to do it](img/00134.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To resolve V into its x/y components, we need to find **Oa** and **Ob**. This
    will give us the component of the aircraft's thrust that is acting along the *y*
    axis, and the component along the *x* axis. Another way of putting it is that
    **Oa** is the amount of thrust acting along the *x* axis, and **Ob** is the amount
    along the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s calculate the amount of thrust along the *y* axis: **Oa**. From
    trigonometry, we know that:'
  prefs: []
  type: TYPE_NORMAL
- en: cos(θ) = adjacent / hypotenuse = Oa / |V|
  prefs: []
  type: TYPE_NORMAL
- en: 'Rearranged, this gives:'
  prefs: []
  type: TYPE_NORMAL
- en: Oa = |V| Cos(θ) = y component
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate Ob, the following equation is used:'
  prefs: []
  type: TYPE_NORMAL
- en: sin(θ) = opposite / hypotenuse = Ob / |V|
  prefs: []
  type: TYPE_NORMAL
- en: 'Giving:'
  prefs: []
  type: TYPE_NORMAL
- en: Ob = |V| sin(θ) = x component
  prefs: []
  type: TYPE_NORMAL
- en: '**The Dot Product**: The dot product gives the angle between two vectors—something
    you will need to calculate often when programming AI. Given the two two-dimensional
    vectors, u and v, the equation looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: u.v = ux vx + uy uy //Equation (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.` (dot) symbol denotes the dot product. Equation (1) doesn''t give us
    an angle though. I promised an angle, so you''ll get one! Here''s another way
    of calculating the dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: u.v = |u| |v| cos(θ)
  prefs: []
  type: TYPE_NORMAL
- en: 'Rearranging, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cos(θ) = u.v / |u| |v|*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, the vertical lines surrounding a vector indicate its magnitude. Now
    is the time when you discover one of the useful uses for normalizing vectors.
    If v and u are both normalized, then the equation simplifies enormously to:'
  prefs: []
  type: TYPE_NORMAL
- en: "*cos(θ) = u.v / 1*1\P = u.v*"
  prefs: []
  type: TYPE_NORMAL
- en: 'Substituting in the equation from Equation (1) for the right-hand side gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cos(θ) = u.v = ux vx + uy uy*'
  prefs: []
  type: TYPE_NORMAL
- en: This gives us an equation for the angle between the vectors.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s an example of some of the vector methods you''ve just learned about
    working together. Let''s say you have a game agent, Eric the Troll, who stands
    at position T (the origin) and facing in the direction given by the normalized
    vector H (for heading). He can smell a helpless princess at position P and would
    very much like to throw his club at her, to tenderize her a little, before he
    rips her to pieces. To do this, he needs to know how many radians he must rotate
    to face her. The following figure shows the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You've discovered that you can calculate the angle between two vectors using
    the dot product. However, in this problem you only have one vector to start with,
    **H**. Therefore, we need to determine a vector—the vector **TP** that points
    directly at the princess. This is calculated by subtracting point **T** from point
    **P**. Because **T** is at the origin (0, 0), in this example, P–T= P. However,
    the answer P–T is a vector, so let's show this by typing it in bold and calling
    it **P**.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the cosine of the angle the troll needs to turn to face the princess
    is equivalent to the dot product of **H** and **P**, provided both vectors are
    normalized. **H** is already normalized, so we only need to normalize **P**. Remember,
    to normalize a vector, its components are divided by its magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the normal of P (NP) is:'
  prefs: []
  type: TYPE_NORMAL
- en: Np = P / |P| // Equation (2)
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot product can now be used to determine the angle:'
  prefs: []
  type: TYPE_NORMAL
- en: cos(θ) = Np.H // Equation (3)
  prefs: []
  type: TYPE_NORMAL
- en: 'So:'
  prefs: []
  type: TYPE_NORMAL
- en: θ = cos^(-1)(Np.H) // Equation (4)
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify the process, let''s do the whole thing again, but with some numbers.
    Let''s say, the troll is situated at the origin T (0, 0) and has a heading of
    H (1, 0). The princess is standing at the point P (4, 5). How many radians does
    the troll have to turn to face the princess? We know that we can use Equation
    (4) to calculate the angle, but first we need to determine the vector, TP, between
    the troll and the princess and normalize it. To obtain TP, we subtract T from
    P, resulting in the vector (4,5). To normalize TP, we divide it by its magnitude,
    resulting in NTP (0.62,0.78). Finally, we plug the numbers into Equation (4),
    which is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*θ = cos*^(-1)*(Ntp.H)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*θ = cos*^(-1) *((0.62 *1) + (0.78 * 0))*'
  prefs: []
  type: TYPE_NORMAL
- en: '*θ = cos*^(-1) *(0.62)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*θ = 0.902 radians*'
  prefs: []
  type: TYPE_NORMAL
- en: Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physics is the branch of science concerned with the nature and properties of
    matter and energy. The subject matter of physics includes mechanics, heat, light
    and other radiation, sound, electricity, magnetism, and the structure of atoms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Time**: Time is a scalar quantity (completely specified by its magnitude
    and with no direction) measured in seconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time = Distance / Speed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Distance**: The standard unit of distance—a scalar quantity—is the meter,
    abbreviated to m:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance=Speed * Time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Mass**: Mass is a scalar quantity measured in kilograms, abbreviated to kg.
    Mass is the measure of an amount of something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Velocity**: Velocity is a vector quantity (a quantity that has magnitude
    and direction) that expresses the rate of change of distance over time. The standard
    unit of measurement of velocity is meters per second, abbreviated to m/s. This
    can be expressed mathematically as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v = ∆x / ∆t
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Greek capital letter ∆, read as delta, is used in mathematics to denote
    a change in quantity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Acceleration**: Acceleration is a vector quantity that expresses the rate
    of change of velocity over time and is measured in meters per second square, written
    as m/s². Acceleration can be expressed mathematically as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a = ∆v / ∆t
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The above physics properties are used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time**: In games often we have to evaluate the time required for the player
    to reach a object with a given speed. In such cases, we use the Pythagorean theorem
    to evaluate the distance between the object and the player, then we will use the
    *Time = Distance/Speed* formula to evaluate the time that the player will need
    to cover a certain distance with a given speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distance**: Similarly, to evaluate the distance between the player and the
    object, we can use the *Distance = Speed * Time* formula to evaluate the distance
    between the object and the player, considering the speed and time as known factors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass**: This is a property that is frequently used while dealing with the
    physics engine. Whenever we want to demonstrate both the objects with different
    behavior in terms of movement, we can change their mass property. Consider a situation
    in which we want to have two physics objects such as bullet and a ball. In this
    case, the mass of the bullet will be very low as compared to the ball, so as to
    make the bullet travel with a high speed, even with a very little applied force
    or impulse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Velocity**: Whenever we apply any force to any physics body by using a vector,
    we are changing the velocity of the object by providing the magnitude and the
    direction to the physics object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
