- en: Chapter 2. Discovering New Territories – Linux at Last!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until recently, developing for Swift meant you needed a Mac, loaded with the
    Xcode IDE. However, all of that changed when Apple open sourced the Swift programming
    language in December 2015\. A brave new world has been opened to us as developers,
    as Swift can now run on Linux! In addition, you now have access to preview releases
    and have direct access to the development trunk from which you can download development
    snapshots (for example, non-official prebuilt binaries of Swift).
  prefs: []
  type: TYPE_NORMAL
- en: This is going to be a packed chapter, and I want to highlight what we will cover.
    My goal is to show you where to find the latest Swift source for both Mac and
    Linux. I will also provide instruction on how to use *toolchains* and explain
    how the Swift package manager works. Last, we will develop our first program on
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get started working with Swift 3, you need to download either a
    prebuilt binary (also known as a *toolchain*) or the source code to build the
    Swift library yourself. The Swift.org ([https://swift.org](https://swift.org))
    website hosts a **Download** section [https://swift.org/download/](https://swift.org/download/)
    that maintains a list of releases, previews and snapshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Release builds**:Maintains links to the current release and older official
    releases of Swift.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preview builds**:Contains links to developer previews, also known as *seeds*
    or *betas*. These binaries are not considered final releases but do provide a
    fairly stable version of the work completed to that date for upcoming releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer snapshots** - Are pre-built binaries from the development branch.
    These builds contain the latest development changes and have gone through automated
    unit testing but are not guaranteed to be stable. Snapshot builds are not put
    through the full testing process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since learning to build the binary isn't critical to your knowledge of learning
    Swift 3, we will leave compiling the source as an exercise for you to try on your
    own at some point. You can find the source code on Apple's GitHub ([https://github.com/apple](https://github.com/apple))
    along with build instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Swift 3 on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get up and going on a Mac, you simply need to choose the type of Swift *toolchain*
    you want to develop against. You can choose a version from the **Download** section.
    Swift on a Mac is included with Xcode, making it really easy to get started. Swift
    3 requires you to have macOS 10.11.5 (El Capitan) or later and Xcode 8\. Let's
    walk through the steps together and install Swift 3 on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: '**Download a toolchain** - Grab the latest Swift 3 release or preview candidate
    from the downloads page on [https://swift.org/](https://swift.org/). Xcode is
    created and maintained by Apple, selecting a release to download from [https://swift.org/](https://swift.org/)
    will take you to Apple''s downloads section on their developer portal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: An Xcode toolchain is a special binary with a toolchain extension that includes
    Xcode and all of the tools and libraries that make up Swift (LLVM, LLDB, REPL,
    and other tools) all targeted at a specific Swift version. You can think of a
    toolchain as a bundled development environment that you install and extract onto
    your system to work with a specific release. When you want to try out a different
    version, you have to download and install the toolchain that corresponds to the
    target version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Run the package installer** - This will install Xcode (toolchain).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Xcode package that you download for a release or developer snapshot should
    be digitally signed with a developer ID (Developer ID Installer: Swift Open Source
    (V9AUD2URP3)) of the open source project to protect against malicious code and
    tampering. The Swift installer should display a lock on the right side of the
    title bar. When you click the lock, you should see details on the developer signature.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Select a Toolchain [Optional]** - If this is the only Swift version on your
    machine, you can skip this step. However, if you have multiple developer snapshots
    or previews, you can tell Xcode which version to use by navigating to Preferences,
    choosing **Components** | **Toolchains** or using the **Toolchains** menu listed
    under **Preferences...** directly:![Swift 3 on Mac](img/image_02_001.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting Toolchains in Xcode 8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, you select the **Toolchain** you want to develop against, which will only
    change the Xcode settings. If you want your command line tools settings to change
    as well, you need to configure those using the *xcrun* and *xcodebuild*.![Swift
    3 on Mac](img/image_02_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toolchains menu in Xcode
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each command has an option to point to a specified Swift `toolchain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have your *toolchain* installed on your Mac, you simply need to launch
    Xcode and you can begin developing. Since we will spend the majority of the next
    few chapters tackling new Swift features using Xcode, we are going to shift gears
    and spend the rest of this chapter discussing Swift on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Swift 3 on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swift team currently supports installing Linux on Ubuntu 14.04 or 15.10
    (64-bit). On Linux, Swift packages are distributed as tar archives. Each package
    includes the Swift compiler, the LLDB debugger, and tools related to doing development
    in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't have access to a Linux box, you can create a virtual machine using
    VirtualBox [https://www.virtualbox.org](https://www.virtualbox.org) and Vagrant
    [https://www.vagrantup.com](https://www.vagrantup.com).
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox is a virtualization application that runs on multiple platforms and
    allows you to install another OS. You can download the latest version from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant is a configuration and provisioning package that allows you to install
    and configure a complete development environment. You can find instructions on
    how to install and configure a Linux box at this location [https://www.vagrantup.com/](https://www.vagrantup.com/)
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install our required dependencies. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`clang` : The C language front-end for LLVM compiler.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libicu-dev` : An Ubuntu package written in C++ and C that provides a solid
    full-featured Unicode and local support.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to download a *toolchain* along with a *.sig* file that serves as the
    *toolchain*'s digital signature. The *toolchain* has the format `swift-<VERSION>-<PLATFORM>.tar.gz`,
    and the digital signature file has the same format with extension *`.sig`.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to install a preview *toolchain* for Ubuntu 14.04\. Copy the link
    for the *toolchain* and download the files to your Linux machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the `toolchain` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the digital signature file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import PGP keys for verifying the integrity of our *toolchain*. You only need
    to download the keys once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We verify our downloaded *toolchain* using the PGP key we imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refresh your keys and download any newly available certificates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we verify that the signature file we downloaded is good:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If our `*gpg*` verify statement returns a `Bad signature` then do not open the
    *toolchain* and report the problem to `swift-infrastructure@swift.org`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract the *toolchain* from the archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to include the */usr* directory to our path so that we can execute
    the swift command for using the REPL environment. Add the Swift *toolchain* to
    your path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have Swift installed, we can use the Swift REPL (Read Evaluate Print
    Loop) environment and give Swift a test run on Linux. The Swift REPL environment
    and LLDB debugger are tightly linked to the *toolchain*, which aids in Swift type
    inference, syntax, and expression evaluation. Basically, it makes the compiler,
    debugger, and REPL environment's jobs easier if there is only one version of Swift
    to worry about at a time. Let's start the REPL environment and execute a few commands
    to get familiar with the REPL environment's capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the Swift REPL, you type the swift command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we add statements, the REPL environment is smart enough to only execute once
    you have completely entered a statement. We can create assignment statements,
    functions, or even entire classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the REPL prompt, let''s assign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each time we execute a statement, the REPL environment adds the result of the
    statement on the following line. In our case, we have assigned the numerical values
    to two different variables (`oneMillion` and `twoMillion`). Our third statement
    adds the two variables together. Notice that the result displays as `$R0 Int =
    3000000`. The Swift REPL environment will create a variable name for you if you
    don't assign an expression to a variable. We can use the assigned variable in
    future expressions. In our fourth expression, we use the value stored in `$R0to`
    create a new expression that divides the value by `1,000,000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned earlier in this section, the debugger is tightly coupled to
    the REPL environment. If we add a bad expression, the REPL environment displays
    the error message as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The REPL environment also supports multi-line statements, which you could use
    to create a function or class. To create a multi-line statement, you simply need
    to arrow down instead of pressing enter.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't used the REPL environment in past versions of Swift, you should
    give it a try. I believe the REPL environment could be very useful for experimenting
    on creating algorithms or testing out a function for rapid development.
  prefs: []
  type: TYPE_NORMAL
- en: Swift Package Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swift Package Manager is the Swift Army Knife that allows you to manage
    your code dependencies, share your own packages, and use the libraries created
    by others. It's an extremely important tool, one that you need to know in order
    to do anything productive with Swift. My goal is to provide you with a quick overview
    and then dive into some examples so we can use it in an example to solidify the
    core concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Like other languages, Swift allows you to organize and group your Swift code.
    Swift refers to these groupings as modules. Modules in Swift allow the developer
    to enforce control on the functionality that is exposed publicly (outside of the
    module) and the functionality that is only visible within the module.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we use modules that we create or that other developers create
    to write our software. When we use other developers' modules, we create a dependency
    on their code. Swift allows us to create a package, which consists of the Swift
    code we write plus a manifest file to manage everything we need to build our products.
    The manifest file that we include in the package defines what we are building,
    as it includes a package name and a listing of the contents included. A Swift
    package can have one or more targets, each of which specifies a product or one
    or more dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever worked with Node.js, you can quickly see the similarities between
    node's package manager and Swift's package manager. Both allow the developer to
    define manifest files that describe the types of dependencies required to make
    an application work. Swift's package manager requires you to provide either a
    relative or absolute URL to the source and the version required. Once provided,
    the package manager takes over, downloading and compiling the required dependencies
    for you. In fact, the package manager recursively checks each dependency, evaluating
    a dependency to see if it has any dependencies and repeats this process until
    it covers the entire graph. This could be a big task depending on the size of
    your package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More Resources**'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the source for the Swift Package Manager here: [https://github.com/apple/swift-package-manager](https://github.com/apple/swift-package-manager).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about how to structure your manifest files here: [https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md](https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get insights on creating your own packages here: [https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md](https://github.com/apple/swift-package-manager/blob/master/Documentation/DevelopingPackages.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Our first Swift program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our first program on Linux using Swift. Our first project will
    be a package. Create a directory named `guesswho` and then enter the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to initialize a new package with the type being an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I want to point out a couple of things about the output of swift package init.
    First, using the swift package init command is optional and meant only to be a
    utility mechanism for generating files and directories you may need. Second, the
    package manager expects you to put your sources files within the Sources directory.
    You can further nest additional directories under the `Sources` directory and
    the package manager will treat those directories as modules. Finally, when you
    want to create an executable, you need to include a `main.swift` file in the module's
    subdirectory or directly within the `Sources` directory in cases when you only
    have one target. Let's look at an example of a Swift package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a package with multiple modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mymodule/Sources/worker/workerbot.swift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mymodule/Sources/manager/manager.swift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running swift build on the package above creates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mymodule/.build/debug/workerbot.a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mymodule/.build/debug/manager.a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a package with one executable and one library module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mymodule/Sources/worker/main.swift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mymodule/Sources/manager/manager.swift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running swift build in this time would result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mymodule/.build/debug/workerbot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mymodule/.build/debug/manager.a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that our executable doesn't have an extension; however, our library file
    is created with a `*.a*` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Open main.swift and remove the code that is currently in there. We are going
    to replace the existing code with some new logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a function that will recursively call itself and remove the first
    letter of its input string from the remaining characters, repeating the task until
    there are no letters left in the string. Once we are finished, we execute a closure
    to let the caller know we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to handle the arguments passed when executing our swift program.
    First in line 1, we store the argument lists as an array. Next, in line 2 we check
    to make sure we have at least one argument that we can process using our `breakWord(combine:)`
    function. Lines 3-8 iterate over our argument list and call our`breakWord(combine:)`
    function for each argument. In line 4, we use a closure expression to print the
    final result of our `breakWord(combine:)` routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer to see the source all in one place, you can download the code
    from this chapter using the following link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Close and save `main.swift` and then compile the program using swift build.
    You can execute the program by typing `guesswho` along with one or more arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to get your development environment configured
    for Swift development on a Mac or Linux machine. We learned about *toolchains*,
    using the REPL environment, and the Swift Package Manager. We also created our
    first Swift package, which we're able to execute on Linux. If you're still with
    me, we will cover even more awesome things in Swift in the forthcoming chapters!
    If you're observant, you've probably noticed that our example package lacked a
    few things. Rest assured, we will take a deep dive into creating and executing
    tests and debugging techniques in [Chapter 9](ch09.html "Chapter 9. Improving
    Your Code with Xcode Server and LLDB Debugging"), *Improving Your Code with Xcode
    Server and LLDB Debugging*. We'll also come back to Linux to tackle a more complicated
    use case that includes adding dependencies to our package in [Chapter 10](ch10.html
    "Chapter 10. Exploring Swift on the Server"),* Exploring Swift on the Server*.
  prefs: []
  type: TYPE_NORMAL
