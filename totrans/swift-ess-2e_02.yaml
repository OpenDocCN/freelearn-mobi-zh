- en: Chapter 2. Playing with Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xcode ships with both a command-line interpreter (which was covered in [Chapter
    1](part0016_split_000.html#F8901-d7e55eb5242648e89c396442afe4f84b "Chapter 1. Exploring
    Swift"), *Exploring Swift*) and a graphical interface called **playground** that
    can be used to prototype and test Swift code snippets. Code that is typed into
    the playground is compiled and executed interactively, which permits a fluid style
    of development. In addition, the user interface can present a graphical view of
    variables as well as a timeline, which can show how loops are executed. Finally,
    playgrounds can mix and match code and documentation leading to the possibility
    of providing example code as playgrounds and using playgrounds to learn how to
    use existing APIs and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will present the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying values in the timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting objects with Quick Look
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using playground's live documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple pages in a playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of playgrounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with playgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Xcode is started, the welcome screen is displayed with various options,
    including the ability to create a playground. The welcome screen can be shown
    with *Command* + *Shift* + *1*, or by navigating to **Window** | **Welcome to
    Xcode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with playgrounds](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a playground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using either the Xcode welcome screen (which can be opened by navigating to
    **Window** | **Welcome to Xcode**) or by navigating to **File** | **New** | **Playground**,
    create `MyPlayground` in a suitable location targeting **iOS**. Creating the playground
    on the `Desktop` will allow easy access to testing Swift code, but it can be located
    anywhere on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Playgrounds can be targeted either towards OS X applications or towards iOS
    applications. This can be configured when the playground is created, or by switching
    to the **Utilities** view by navigating to **View** | **Utilities** | **Show File
    Inspector** or pressing *Command* + *Option* + *1* and changing the dropdown from
    OS X to iOS or vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a playground](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When initially created, the playground will have a code snippet that looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Playgrounds targeting OS X will read `import Cocoa` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side, a column will display the value of the code when each
    line is executed. By grabbing the vertical divider between the Swift code and
    the output, the output can be resized to show the full value of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a playground](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, by moving the mouse over the right-hand side of the playground,
    the **Quick Look** icon (the eye symbol) will appear. If this is clicked, a pop-up
    box will show the full details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a playground](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing the console output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The console output can be viewed in the *Debug Area*. This can be shown by pressing
    *Command* + *Shift* + *Y* or by navigating to **View** | **Debug Area** | **Show
    Debug Area**. This will show the result of any `print` statements that are executed
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a simple `for` loop to the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the debug area below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the console output](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing the timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The timeline shows what the values were at a particular time. In the case of
    the print loop that was shown previously, the output was displayed in the **Debug
    Area**. However, it is possible to use the playground to inspect the value of
    an expression on a line without having to display it directly. In addition, results
    can be graphed to show how these values change over time. The value of the graph
    is shown in-line with the source code unlike previous versions of Xcode, which
    displayed them on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Add another line above the `print` statement to calculate the result of executing
    an expression, `(i-6)*(i-7)`, and store it in a `j` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the line next to the variable definition, click on the add variable history
    (**+**) symbol, which is in the right-hand column (visible when the mouse moves
    over that area). After it is clicked , it will change to an (**o**) symbol and
    display the graph on the right-hand side. This can be done for the `print` statement
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Viewing the timeline](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to display a timeline slider at the bottom of the window by
    selecting the **Show Timeline** checkbox in the **Utilities** area. This adds
    a timeline slider at the bottom, with a red tick mark, and this can be used to
    slide the vertical bar to see the exact value at certain points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the timeline](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To display several values at once, use additional variables to hold the values
    and display them in the timeline as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Viewing the timeline](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the timeline slider is dragged, both values will be displayed at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying objects with Quick Look
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The playground timeline can display objects as well as numbers and simple strings.
    It is possible to load and view images in a playground using classes, such as
    `UIImage` (or `NSImage` on OS X). These are known as *Quick Look supported objects*,
    and by default include:'
  prefs: []
  type: TYPE_NORMAL
- en: String (attributed and unattributed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class and struct types (members are shown)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to build support for custom-based types into Swift by implementing
    a `debugQuickLookObject` method that returns a graphical view of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Showing colored labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To show a colored label, a color needs to be obtained first. When building against
    iOS, this will be `UIColor`; but when building against OS X, it will be `NSColor`.
    The methods and types are largely equivalent between the two, but this chapter
    will demonstrate using iOS types.
  prefs: []
  type: TYPE_NORMAL
- en: 'A color can be acquired with an initializer or using one of the predefined
    colors that are exposed in Swift using methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Xcode 7.1 and above, a color can be dragged in from a color picker into the
    Swift code directly where it will be translated as a color initializer with the
    specific hardcoded color values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The color can be used as the `textColor` of a `UILabel`, which displays a text
    string in a particular size and color. The `UILabel` needs a size, which is represented
    by a `CGRect`, and this can be defined with an `x` and `y` position along with
    a `width` and `height`. The `x` and `y` positions are not relevant for playgrounds,
    and so, they can be left as zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the text needs to be displayed in blue and with a larger font size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the playground is run, the color and font are displayed in the timeline
    and are available for quick view. Even though the same `UILabel` instance is being
    shown, the timeline and the quick look values show a snapshot of the state of
    the object at each point, making it easy to see what has happened between changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing colored labels](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Showing images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images can be created and loaded into a playground using the `UIImage` constructor
    (or `NSImage` on OS X). Both take a `named` argument, which is used to find and
    load an image with the given name from the playground's `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy a file into the playground''s `Resources` folder, first download an
    image, such as `http://alblue.bandlem.com/images/AlexHeadshotLeft.png`, and save
    it as `alblue.png` in a suitable location such as the `Desktop`. In order to add
    it to the playground, the project navigator needs to be opened with *Command*
    + *1* or by navigating to **View** | **Navigators** | **Show Project Navigator**.
    Once opened, the file can be dragged and dropped into the `Resources` element
    in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing images](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xcode 7.1 allows the image to be dragged directly into the source code area.
    It will populate a `UIImage` (or `NSImage`) as well as copy it to the resources
    area. Xcode 7.0 and below will just copy the full file path of the source if dragged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, to download a logo with the command line, open `Terminal.app`
    and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An image can now be created in swift using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The location of the `Resources` that are associated with a playground can be
    seen in the **File Inspector** utilities view, which can be opened by pressing
    *Command* + *Option* + *1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The created image can be displayed using **Quick Look** or by adding it to
    the value history:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing images](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to use a URL to acquire an image by creating an NSURL with `NSURL(string:"http://...")!`,
    then loading the contents of the URL with `NSData(contentsOfURL:)!`, and finally,
    using `UIImage(data:)` to convert it to an image. However, as Swift will keep
    re-executing the code over and over again, the URL will be hit multiple times
    in a single debugging session without caching. It is recommended that `NSData(contentsOfURL:)`
    and similar networking classes be avoided in playgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The playground has its own `XCPlayground` framework, which can be used to perform
    certain tasks. For example, individual values can be captured during loops for
    later analysis. It also permits asynchronous code to continue to execute once
    the playground has finished running.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing values explicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to explicitly add values to the timeline by importing the `XCPlayground`
    framework and using `XCPlaygroundPage.currentPage`, and calling `captureValue`
    with a value that should be displayed in the timeline. This takes an identifier,
    which is used both as the title and to group related data values in the same series.
    When the value history button is selected, it essentially inserts a call to `captureValue`
    with the value of the expression as the identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to add the logo to the timeline automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening the **Assistant Editor** will show the timeline along with the recorded
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing values explicitly](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to use the identifier to group the data that is being shown
    in a loop, with the identifier representing categories of the values. For example,
    to display a list of all even and odd numbers between `1` and `6`, the following
    code could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the result will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing values explicitly](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running asynchronous code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when execution hits the end of the current playground page, the
    execution stops. In most cases this is desirable, but when asynchronous code is
    involved, execution may need to continue to run even if the main code has finished
    executing. This may be the case if networking data is involved or if there are
    multiple tasks whose results need to be synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, wrapping the previous even/odd split in an asynchronous call will
    result in no data being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This uses one of Swift''s language features: the `dispatch_async` method which
    is actually a two-argument method that takes a queue and a block type. However,
    if the last argument is a block type, then it can be represented as a trailing
    closure rather than an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow playground to continue executing after reaching the end, add the following
    assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this suggests that the execution will run forever, it is limited to
    30 seconds of runtime, or whatever the value is displayed at the bottom-right
    corner of the screen. This timeout can be changed by typing in a new value or
    using the **+** and **–** buttons to increase/decrease time by one second. In
    addition to this, the execution can be stopped by clicking the square icon on
    the lower left-hand side of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running asynchronous code](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Playgrounds and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playgrounds can contain a mix of code and documentation. This allows a set of
    code, samples, and explanations to be mixed in with the playground itself.
  prefs: []
  type: TYPE_NORMAL
- en: Learning with playgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As playgrounds can contain a mixture of code and documentation, it makes them
    an ideal format to view annotated code snippets. In fact, Apple's Swift Tour book
    can be opened as a playground file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xcode documentation can be searched by navigating to **Help** | **Documentation
    and API Reference** or by pressing *Command* + *Shift* + *0*. In the search dialog
    that is presented, type `Swift Tour` and then select the first result. The Swift
    Tour book should be presented in Xcode''s help system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning with playgrounds](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A link to download and open the documentation as a playground is given in the
    first section; if this is downloaded, it can be opened in Xcode as a standalone
    playground. This provides the same information, but it allows the code examples
    to be dynamic and show the results in the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning with playgrounds](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A key advantage of learning through playground-based documentation is that the
    code can be experimented with. In the *Simple Values* section of the documentation,
    where `myVariable` is assigned, the right-hand side of the playground shows the
    values. If the literal numbers are changed, the new values will be recalculated
    and shown on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the playground format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The playground is an *OS X bundle*, which means that it is a directory that
    looks like a single file. If the playground is selected either in `TextEdit.app`
    or in `Finder`, then it looks like a regular file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the playground format](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the covers, it is actually a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the directory, there are a number of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Contents.swift` file, which is the Swift file that is created by default
    when a new playground is created, and this contains the code that is typed in
    for any new playground content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Resources` directory, which was created earlier to hold the logo image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `contents.xcplayground` file, which is an XML table of contents of the files
    that make up the playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `playground.xcworkspace`, which is used to hold metadata about the project
    in Xcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `timeline.xctimeline`, which is the file containing timestamps of execution
    that are generated by the runtime when executing a Swift file and the timeline
    is open
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The table of contents file defines which runtime environment is being targeted
    (for example, iOS or OS X) and a reference to the timeline file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Xcode playground directory is deleted and recreated whenever changes are
    made in Xcode. Any `Terminal.app` windows that are open in that directory will
    no longer display any files. As a result, using external tools and editing the
    files in place may result in changes being lost. In addition, using ancient versions
    of control systems, such as SVN and CVS, may find their version control metadata
    being wiped out between saves. Xcode ships with the industry standard Git version
    control system, which should be preferred instead.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, an Xcode playground has a single page open. However, for more comprehensive
    documentation examples, many separate pages may be preferable. For example, instead
    of creating a single very long page with subheadings (which may take a while to
    interpret and execute), additional pages can be added, each with their own specific
    examples. This also has the advantage of being able to interactively experiment
    with code as only the examples on a page need to be recalculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new page to an existing playground, right-click on the **MyPlayground**
    top-level element in the project navigator and select the **New Playground Page**
    menu item. Alternatively, navigate to **File** | **New** | **Playground Page**
    or its keyboard shortcut, *Command* + *Option* + *N*. When this is done, the first
    page becomes **Untitled Page** and the newly added page becomes **Untitled Page
    2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a page](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pages can be reordered by dragging and dropping them in the project navigator
    on the left. They can also be renamed by selecting the page, then clicking it
    to reveal a text field that can be renamed. This is similar to renaming files
    in the `Finder`. The documentation's `@previous` and `@next` links allow the reader
    to navigate through the pages, as described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with a playground with pages, the `contents.xcplayground` file's
    version number is updated to `6.0`, and a new `Pages` directory is created that
    sits alongside the `Resources` top-level folder. Inside the `Pages` directory,
    each page is represented as its own `.xcplaygroundpage` folder, which contains
    a `Contents.swift` file and an individual `timeline.xctimeline` file.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift 2 adopts a new markup scheme for documentation, both for use with playgrounds
    but to also document Swift code. As a result, the documentation comments are described
    as applying to *Playground Comments* or *Symbol Documentation*.
  prefs: []
  type: TYPE_NORMAL
- en: Playground comments start with `//:` for single-line comments, and uses `/*:`
    and `*/` for block-level comments. These are rendered in playgrounds as in-line
    documentation, and they replace the nested HTML that existed in prior versions
    of Xcode. Markup defaults to showing as raw text, but the rendered content can
    be seen by navigating to **Editor** | **Show Rendered Markup**. To toggle it back
    to display the raw markup and allow the text to be edited, navigate to **Editor**
    | **Show Raw Markup**. This setting is also persisted in the `xcplayground` file
    with the `display-mode='rendered'` or `display-mode='raw'` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Symbol documentation starts with `///` for single-line comments, and uses `/**`
    and `*/` for block-level comments. Symbol documentation applies to variables and
    constants, functions, and types. Only one type of symbol documentation comment
    (either single-line or multiline, but not both) may be present above a symbol
    definition. Multiple contiguous single-line comments will be merged into a single
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symbol documentation can be revealed by pressing *Command* + *Control* + *?*
    while the cursor is over an identifier, or by pressing *Alt* and clicking on the
    identifier in Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Both playground and symbol documentation allow some markup to be used for text
    formatting purposes. In addition, there are certain symbol *format commands* that
    can be specified with a hyphen, followed by the command name, and then a colon.
    These are used to introduce documentation, for example, for a specific parameter
    of a function, the return type, or what errors are thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Playground navigation documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to create navigational links between pages in a multipage playground.
    Each page has a name (which starts off as **Untitled Page**, **Untitled Page 2**,
    and so on) but can be renamed in the project navigator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To rename a page, open the project navigator with *Command* + *1* and then
    select the page in the navigator view. The name can be made editable by double-clicking
    on the page name, which turns it into a text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playground navigation documentation](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Links to specific pages are performed with a link, which is represented as
    `[Link Name](Page%20Name)`. For example, to create a link to the first page that
    was just shown, the following can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spaces in the page name need to be URL escaped, so a space is represented as
    `%20`. Using `+` does not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As page names may be fragile, it is recommended to use the **Next** and **Previous**
    links instead. These can be represented using the `@next` and `@previous` special
    identifiers as the page names, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using `@next` and `@previous` is recommended in order to chain multiple pages
    together because it allows pages to be reordered without requiring any changes
    to the content. Pages can be reordered in the project navigator by dragging and
    dropping projects up and down the order.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Page navigation is only available in playgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: Text formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The playground and symbol documentation can use a number of different formatting
    styles using a markup language to represent different types of text. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bulleted lists, which use one of the `*`, `+`, or `–` characters as the bullet,
    followed by a single space, and the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbered lists, which use a number, followed by a period, a single space, and
    the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal rules, which use four dashes `----` to generate a horizontal rule
    in the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block quotations, which start each line with `>` followed by a single space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block code, which is either indented four spaces in from the start, or begin
    and end with [PRE18]` [PRE19]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '//: # Example Documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '//: Navigate to the [previous](@previous) or [next](@next) page'
  prefs: []
  type: TYPE_NORMAL
- en: '//: ----'
  prefs: []
  type: TYPE_NORMAL
- en: '//: Numbered lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '//: 1\. First item'
  prefs: []
  type: TYPE_NORMAL
- en: '//: 2\. Second item'
  prefs: []
  type: TYPE_NORMAL
- en: '//: 3\. Third item'
  prefs: []
  type: TYPE_NORMAL
- en: '//:'
  prefs: []
  type: TYPE_NORMAL
- en: '//: Bulleted lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '//: * First item'
  prefs: []
  type: TYPE_NORMAL
- en: '//: * Second item'
  prefs: []
  type: TYPE_NORMAL
- en: '//:   + child item'
  prefs: []
  type: TYPE_NORMAL
- en: '//:   + child item'
  prefs: []
  type: TYPE_NORMAL
- en: '//: * Third item'
  prefs: []
  type: TYPE_NORMAL
- en: '//:'
  prefs: []
  type: TYPE_NORMAL
- en: '//: How to do loops in Swift using `for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '//:'
  prefs: []
  type: TYPE_NORMAL
- en: '//:     for i in 1...12 {'
  prefs: []
  type: TYPE_NORMAL
- en: '//:       print("Looping \(i)")'
  prefs: []
  type: TYPE_NORMAL
- en: '//:     }'
  prefs: []
  type: TYPE_NORMAL
- en: '//:'
  prefs: []
  type: TYPE_NORMAL
- en: '//: > This is a block quote'
  prefs: []
  type: TYPE_NORMAL
- en: '//: > which is merged together'
  prefs: []
  type: TYPE_NORMAL
- en: '//: > using _italics_ or **bold**'
  prefs: []
  type: TYPE_NORMAL
- en: '//:'
  prefs: []
  type: TYPE_NORMAL
- en: '//: Link to [AlBlue''s Blog](http://alblue.bandlem.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '//: Image of ![AlBlue](http://alblue.bandlem.com/images/AlexHeadshotLeft.png
    "AlBlue")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: /**
  prefs: []
  type: TYPE_NORMAL
- en: Returns the string in SHOUTY CAPS
  prefs: []
  type: TYPE_NORMAL
- en: '- parameter input: the input string'
  prefs: []
  type: TYPE_NORMAL
- en: '- author: Alex Blewitt'
  prefs: []
  type: TYPE_NORMAL
- en: '- returns: The input string, but in upper case'
  prefs: []
  type: TYPE_NORMAL
- en: '- throws: No errors thrown'
  prefs: []
  type: TYPE_NORMAL
- en: '- note: Please don''t shout'
  prefs: []
  type: TYPE_NORMAL
- en: '- seealso: String.uppercaseString'
  prefs: []
  type: TYPE_NORMAL
- en: '- since: 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: func shout(input:String) -> String {
  prefs: []
  type: TYPE_NORMAL
- en: return input.uppercaseString
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the mouse hovers over the `shout` function, the following documentation
    will be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbol documentation](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Limitations of playgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although playgrounds can be very powerful for interacting with code, there are
    some limitations that are worth being aware of. There is no debugging support
    in the playground, so it is not possible to add a breakpoint and use the debugger
    and find out what are the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that the UI allows tracking values—and that it''s very easy to add new
    lines with just the value to be tracked—this is not much of a hardship. Other
    limitations of playgrounds include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only the simulator can be used for the execution of iOS-based playgrounds. This
    prevents the use of hardware-specific features that may only be present on a device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance of playground scripts is mainly based on how many lines are
    executed and how much output is saved by the debugger. It should not be used to
    test the performance of performance-sensitive code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the playground is well suited to present user interface components,
    it cannot be used for user input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything requiring entitlements (such as in-app purchases or access to iCloud)
    is not possible in playground at the current time of writing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented playgrounds, an innovative way of running Swift code
    with graphical representation of values and introspection of running code. Both
    expressions and timeline were presented as a way of showing the state of the program
    at any time, as well as graphically inspecting objects using Quick Look. The `XCPlayground`
    framework can also be used to record specific values and allow asynchronous code
    to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at how to create an iOS application with Swift.
  prefs: []
  type: TYPE_NORMAL
