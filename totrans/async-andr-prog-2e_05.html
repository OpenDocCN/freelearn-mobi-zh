<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Interacting with Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Interacting with Services</h1></div></div></div><p>In the previous chapters we focused our attention on the basic, high-level, Android-specific constructs to load data asynchronously on an independent line of execution (background thread); <code class="literal">android.os.AsyncTask</code> and <code class="literal">android.content.Loader</code>.</p><p>What if we want to provide a common set of operations that implement any kind of business logic over a centralized single entity that could be re-used by different clients and has a lifecycle that is not bound to the client lifecycle? By clients, in Android, we mean any kind of UI entity, such as an <code class="literal">Activity</code> or <code class="literal">Fragment</code> object, a <code class="literal">BroadcastReceiver</code>, or any kind of object that wants to exercise business logic.</p><p>The solution for this pattern in Android is available in the form of <code class="literal">android.app.Service</code>.</p><p>In Android, the Service programming pattern, well-known in enterprise architectures, does not necessarily mean background work, so to avoid any kind of responsiveness degradation in the UI we should try keep the main Thread execution of the Service as lean as possible.</p><p>Therefore, we have to use asynchronous techniques to coordinate the <code class="literal">Service</code> work between the main thread and other threads that help to accomplish the <code class="literal">Service</code> goal, to either keep the responsiveness at quite a decent level and provide results to the Service request.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing Service</li><li class="listitem" style="list-style-type: disc">Started Service</li><li class="listitem" style="list-style-type: disc">Building responsive apps with IntentService</li><li class="listitem" style="list-style-type: disc">Posting results with pending intents</li><li class="listitem" style="list-style-type: disc">Reporting progress on the notification drawer</li><li class="listitem" style="list-style-type: disc">Applications of IntentService</li><li class="listitem" style="list-style-type: disc">Bound service</li><li class="listitem" style="list-style-type: disc">Communicating with a local service</li><li class="listitem" style="list-style-type: disc">Broadcasting results with intents</li><li class="listitem" style="list-style-type: disc">Applications of services</li></ul></div><div class="section" title="Introducing Service"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Introducing Service</h1></div></div></div><p>A <code class="literal">Service</code> in <a id="id247" class="indexterm"/>Android, as referred to before, is an entity that runs without a user interface that could be used to execute any kind of business logic which the application requires during the execution.</p><p>If the basic unit of a visible application is <code class="literal">Activity</code>, its equivalent unit for non-visible components is <code class="literal">Service</code>. Just like activities, services must be declared in the AndroidManifest file so that the system is aware of them and can manage them for us:</p><div class="informalexample"><pre class="programlisting">&lt;service android:name=".MyService"/&gt;</pre></div><p>Service has lifecycle callback methods, similar to those of Activity, that are always invoked on the application's main thread. Here are the most important callbacks that the user must define when it creates a service by extending the Service base class:</p><div class="informalexample"><pre class="programlisting">void onCreate();
void onDestroy()
void onStartCommand(Intent intent, int flags, int startId)  
IBinder onBind(Intent intent)   
boolean onUnbind(Intent intent)</pre></div><p>The <code class="literal">onCreate()</code> is the lifecycle callback that is called once when the service is created that might be used to allocate Service resources.</p><p>The <code class="literal">onDestroy()</code> is the lifecycle callback called when the service is going to be destroyed and might be used to free Service resources.</p><p>The <code class="literal">onStartCommand()</code> is the lifecycle callback invoked when a started Service is explicitly started with the <code class="literal">startService()</code> command.</p><p>
<code class="literal">onBind()</code> is the lifecycle callback called when the service is bound to a Service client – <code class="literal">bindService()</code>.</p><p>The <code class="literal">onUnbind()</code> is the callback called when the service is unbound from a client - <code class="literal">unbindService()</code>:</p><div class="mediaobject"><img src="graphics/Image_B05062_05_03.jpg" alt="Introducing Service"/></div><p>Also, just like <code class="literal">Activity</code>, <code class="literal">Service</code> does not automatically entail a separate background thread or process, and as a result, performing intensive or blocking operations in a <code class="literal">Service</code> callback <a id="id248" class="indexterm"/>method can lead to the annoying ANR dialog.</p><p>However, there are several ways in which services are different to activities, those ways are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Service does not provide a user interface.</li><li class="listitem" style="list-style-type: disc">There can be many services active at the same time within an application.</li><li class="listitem" style="list-style-type: disc">A Service can remain active even if the application hosting it is not the current foreground application, which means that there can be many services of many apps are active at the same time.</li><li class="listitem" style="list-style-type: disc">Because the system is aware of services running within a process, it can avoid killing those processes unless absolutely necessary, allowing the background work to continue. Services have a higher priority than inactive or invisible activities.</li></ul></div><p>Services in Android can be classified based on how the clients interact with it, taking the next forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Started Service</strong></span>: This is a <a id="id249" class="indexterm"/>kind of service that is explicitly started when any object on the system invokes <code class="literal">startService()</code> and it will continue to run until it stops itself by calling <code class="literal">stopSelf()</code> or it is explicitly destroyed with <code class="literal">stopService()</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bound Service</strong></span>: This is a kind of service that is started when the first client binds to it and runs <a id="id250" class="indexterm"/>until it has clients are connected. Service <a id="id251" class="indexterm"/>clients attach to a Service by calling <code class="literal">bindService()</code>, and the service will be destroyed when all the clients unbind, calling <code class="literal">unbindService()</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hybrid Service</strong></span>: This <a id="id252" class="indexterm"/>Service is started when an object on the system calls <code class="literal">startService()</code> and might have clients connected to it during its <a id="id253" class="indexterm"/>lifecycle, by calling <code class="literal">bindService()</code>. Like the started Service, it runs indefinitely until the service is stopped, stops itself, or is killed by the system.<div class="mediaobject"><img src="graphics/Image_B05062_05_01.jpg" alt="Introducing Service"/></div></li></ul></div><p>The Service can be also classified by its boundaries, taking the following forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Local Service</strong></span> (<span class="strong"><strong>LS</strong></span>): The Service runs on the same process as the other Android components <a id="id254" class="indexterm"/>and therefore the shared memory could be used to send Java Objects between client and Server.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Internal Remote Service</strong></span> (<span class="strong"><strong>IRS</strong></span>): The Service runs on a separate process but it can only be <a id="id255" class="indexterm"/>used by the components that belong to the application that defines it. To access it, an IPC technique (Messenger or AIDL) is required to interact with the remote process.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Global Service</strong></span> (<span class="strong"><strong>GS</strong></span>): The Service runs on a separate process and could be accessed by other <a id="id256" class="indexterm"/>applications. For instance, with IRS, an IPC communication technique must be used by the client to access it.</li></ul></div></div></div>
<div class="section" title="Started service"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Started service</h1></div></div></div><p>As described <a id="id257" class="indexterm"/>previously, a started Service is a service that is initiated when the <a id="id258" class="indexterm"/><code class="literal">Context </code>method <code class="literal">startService()</code> is invoked by any entity on the system that has access to a Context object or is a Context itself, such as an Activity:</p><div class="informalexample"><pre class="programlisting">         ComponentName startService(Intent service)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>An Intent is a messaging object that can carry data (action, category, extras, and so on) and that you can use to request an action from another Android component.</p></div></div><p>The <code class="literal">startService()</code> function basically starts a service with an intent, and returns to the user a component name that can be used to verify that the correct service was resolved and invoked.</p><p>To simplify the Service resolution, we pass an Intent created from the current context with the Service class that needs to be started:</p><div class="informalexample"><pre class="programlisting">     startService(new Intent(this,MyStartedService.class));</pre></div><p>When the system receives the first <code class="literal">startService(intent</code>) request, it builds up the Service by calling <code class="literal">onCreate()</code> and forwards the intent from the first <code class="literal">startService</code> and the subsequent Intents to the <code class="literal">onStartCommand </code>function to be processed according to the order of <code class="literal">startService</code> calls:</p><div class="informalexample"><pre class="programlisting">  int onStartCommand(Intent intent, int flags, int startId)</pre></div><p>The <code class="literal">onStartCommand</code> should return an <code class="literal">int</code> that defines the Service restart behavior applied by the system in cases where the system kills it to release resources. Like explained before, the system maintains a list of Android running entities on the system ordered by rank, and once the available system resources are low it destroys the entities with lower rank first to free up resources.</p><p>The most common restart <code class="literal">int</code> values are defined by the following Service static fields:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">START_STICKY</code>: If the Service process is terminated by the system, the Service is going to <a id="id259" class="indexterm"/>be restarted and no processed Intents will be delivered to the <code class="literal">onStartCommand</code> function. When no start Intents are pending for delivery, a null Intent is passed to the <code class="literal">onStartCommand</code> function. If a start request didn't return before the system kills the Service, the start request is submitted again on the restarted Service passing <code class="literal">START_FLAG_RETRY</code> on the <code class="literal">onStartCommand</code> second argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">START_NOT_STICKY</code>: If <a id="id260" class="indexterm"/>the Service is terminated by the system, the Service is only restarted when there is at least one pending start request to be delivered.</li><li class="listitem" style="list-style-type: disc"><code class="literal">START_REDELIVER_INTENT</code>: If the <code class="literal">Service</code> is terminated by the system, the <code class="literal">Service</code> will be restarted redelivering the last delivered start Intent and any pending requests. This kind of service is similar to <code class="literal">START_STICKY</code>, but instead of delivering a null Intent in the start command, the last successfully delivered Intent is dispatched. When the start request is redelivered, the flag <code class="literal">START_FLAG_REDELIVERY</code> is passed in on the <code class="literal">onStartCommand</code> second argument.</li></ul></div><p>The <code class="literal">onStartCommand</code>, which executes on the main <code class="literal">Thread</code>, is the entry point for your service, so in cases where you execute long running operations on your <code class="literal">Service</code>, the offload of your operation into a background thread is imperative for keeping your application responsiveness at bearable levels.</p><p>In the next code snippet, we are going to create a basic <code class="literal">Service</code> that offloads the <code class="literal">Intent</code> processing to a background thread. The <code class="literal">SaveMyLocationService</code> Service subclass is going to receive an address location in a String and consume it in an operation that could occupy the CPU for a long period. First, we are going to create the background thread, that will retrieve the locations from a queue and consume them until it receives a signal to stop:</p><div class="informalexample"><pre class="programlisting">public class SaveMyLocationService extends Service {
  boolean shouldStop = false;
  Queue&lt;String&gt; jobs = new LinkedList&lt;String&gt;();

  Thread thread = new Thread() {
    @Override
    public void run() {
      while (!shouldStop) {
        String location = takeLocation();
        if (location != null) {
          consumeLocation(location);
        }
      }
    }
  };


  @Override
  public void onCreate() {
    super.onCreate();
    thread.start();
}

String takeLocation() {
  String location = null;
  synchronized (jobs) {
    if (jobs.isEmpty()) {
      try {
       jobs.wait();
      } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
       return null;
      }
     }
     location = jobs.poll();
    }
    return location;
  }
void consumeLocation(String location) {...}
}</pre></div><p>In the previous code, we basically constructed the foundations for our asynchronous processing. The single <a id="id261" class="indexterm"/>thread that is started when the Service's <code class="literal">onCreate()</code> callback is invoked on the main <code class="literal">Thread</code>, is going to monitor the jobs queue for new location requests. The Thread will wait in the background efficiently, using a Java monitor, until it gets notified with <code class="literal">notify()</code> when a new location is submitted.</p><p>When our background thread finds new locations in the queue, the <code class="literal">takeLocation()</code> that is waiting on the Java monitor returns and forwards the new request to the <code class="literal">consumeLocation()</code> to execute the business logic requested.  The jobs are going to be processed sequentially <a id="id262" class="indexterm"/>following the order of insertion.</p><p>Once the <code class="literal">shouldStop</code> is set to <a id="id263" class="indexterm"/>true, the <code class="literal">run()</code> function will return and the thread will be terminated.</p><p>We'll need to register the Service in our AndroidManifest file, using a <code class="literal">&lt;service&gt;</code> element as follows:</p><div class="informalexample"><pre class="programlisting">   &lt;service android:name=".chapter5.SaveMyLocationService"/&gt;</pre></div><p>In the next step we are going to implement the <code class="literal">onStartCommand</code>, the function that will receive the request from the system in the first place and forward it to our thread to be processed in background:</p><div class="informalexample"><pre class="programlisting">@Override
public int onStartCommand(Intent intent, int flags, int startId) {
  super.onStartCommand(intent, flags, startId);
  String location = intent.getStringExtra(LOCATION_KEY);
  synchronized (jobs) {
    jobs.add(location);
    jobs.notify();
  }
  return START_STICKY;
    }</pre></div><p>On the <code class="literal">onStartCommand</code>, we received the intent object from the system and the location passed as a String on the Intent extras. Next, we push it to our queue of jobs used to store the jobs in sequence. Later, we return the <code class="literal">START_STICKY</code> flag, which means that we want the Service restarted after the system shuts down our application and the pending intents delivered in case the system shuts down the system to free up resources.</p><p>Finally, we have to implement the callback function to stop our background processing infrastructure. This function is going to be called when the system forces the service to terminate or any component sends a <code class="literal">stop</code> command:</p><div class="informalexample"><pre class="programlisting">@Override
public void onDestroy() { 
  super.onDestroy();
  synchronized (jobs) {
    shouldStop = true;
    jobs.notify();
  }
}</pre></div><p>In the <code class="literal">onDestroy()</code> function, we mainly ask our thread to terminate, setting the <code class="literal">shouldStop</code> as true and by notifying the thread to finish the <code class="literal">run()</code> function. In case you allocated objects in your <a id="id264" class="indexterm"/><code class="literal">onCreate()</code> function, this callback should be used to liberate any resources that you created during the Service lifecycle.</p><p>Now we are going to create a <a id="id265" class="indexterm"/>simple Activity that is able to start the service and stop the service:</p><div class="informalexample"><pre class="programlisting">public class SaveMyLocationActivity extends Activity {

  ...

  void onStartServiceClick() {
    Intent intent = new Intent(this, SaveMyLocationService.class);
    intent.putExtra(SaveMyLocationService.LOCATION_KEY,
                    getCurrentLocation());
    startService(intent);
  }

  void onStopServiceClick() {
    Intent intent = new Intent(this,SaveMyLocationService.class);
    stopService(intent);
  }
}</pre></div><p>In our Activity, we created a start button that calls <code class="literal">onStartServiceClick()</code>, and a stop button that calls <code class="literal">onStopServiceClick()</code>, but for brevity we omitted the code.</p><p>Once the <span class="strong"><strong>start</strong></span> button is clicked, our Activity will submit a new save location request, with the current location retrieved from the <code class="literal">getCurrentLocation()</code> function, to our service calling <code class="literal">startService()</code>.</p><p>Clicking on the <span class="strong"><strong>stop</strong></span> button will result in a <code class="literal">stopService()</code>, which sends a stop request to our Service that leads to a <code class="literal">onDestroy()</code> invocation on our Service.</p><p>It is essential to mention that if the service is stopped and started repeatedly, a new thread is created to replace the older one. As mentioned before, the thread creation is an expensive operation, so in order to reduce the burden of the thread creation, the developer should keep the Service running as long it may be needed.</p><p>Our custom service is able to handle the <code class="literal">onStartCommand()</code> asynchronously very well but in the next section, we <a id="id266" class="indexterm"/>will focus our attention on the <code class="literal">IntentService</code> class, a special-purpose subclass of <code class="literal">Service</code> that comes in the Android SDK that makes it very easy to <a id="id267" class="indexterm"/>implement a task queue to process work on a single background thread.</p><div class="section" title="Building responsive apps with IntentService"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Building responsive apps with IntentService</h2></div></div></div><p>The <a id="id268" class="indexterm"/><code class="literal">IntentService</code> class is a specialized subclass of <code class="literal">Service</code> that implements a background <a id="id269" class="indexterm"/>work queue using a single <code class="literal">HandlerThread</code>. When work is submitted to an <code class="literal">IntentService</code>, it is queued for processing by a <a id="id270" class="indexterm"/>single <code class="literal">HandlerThread</code>, and processed in order of submission on the <code class="literal">onHandleIntent</code> function:</p><div class="informalexample"><pre class="programlisting">abstract void onHandleIntent(Intent intent);</pre></div><p>If the user exits the app before the queued work is completely processed, the <code class="literal">IntentService</code> will continue working in the background. When the <code class="literal">IntentService</code> has no more work in its queue, it will stop itself to avoid consuming unnecessary resources.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>The system may still kill a background app with an active <code class="literal">IntentService</code>, if it really needs to (to reclaim enough memory to run the current foreground process), but it will kill lower priority processes first, for example, other non-foreground apps that do not have active services.</p></div></div><p>The <code class="literal">IntentService</code> class gets its name from the way in which we submit work to it by invoking <code class="literal">startService</code> with an Intent:</p><div class="informalexample"><pre class="programlisting">startService(new Intent(context, MyIntentService.class));</pre></div><p>As we do with our previous example, we can call <code class="literal">startService</code> as often as we like, which will start the <code class="literal">IntentService</code> if it isn't already running, or simply enqueue work to an already running instance if there is one.</p><p>If we want to pass some data to a <code class="literal">Service</code>, we can do so by supplying a data URI or extra data fields via an Intent:</p><div class="informalexample"><pre class="programlisting">Intent intent = new Intent(context, MyIntentService.class);
intent.setData(uri); intent.putExtra("param", "some value");
startService(intent);</pre></div><p>We can <a id="id271" class="indexterm"/>create an <code class="literal">IntentService</code> subclass by extending <code class="literal">android.app.IntentService</code> and implementing the <a id="id272" class="indexterm"/>abstract <code class="literal">onHandleIntent</code> <a id="id273" class="indexterm"/>method.</p><p>We must invoke the single-argument constructor with a name for its background thread (naming the thread makes debugging and profiling much easier).</p><div class="informalexample"><pre class="programlisting">public class MyIntentService extends IntentService {

  public MyIntentService() {
    super("myIntentService");
  }
  protected void onHandleIntent(Intent intent) {
    // executes on the background HandlerThread.
  }
}</pre></div><p>We'll need to register the <code class="literal">IntentService</code> in our AndroidManifest file, using a <code class="literal">&lt;service&gt;</code> element as follows:</p><div class="informalexample"><pre class="programlisting">   &lt;service android:name=".chapter5.MyIntentService"/&gt;</pre></div><p>If we want our <code class="literal">IntentService</code> to only be used by the components of our own application, we can specify that it is not public with an extra attribute:</p><div class="informalexample"><pre class="programlisting">   &lt;service android:name=".chapter5.MyIntentService"
            android:exported="false"/&gt;</pre></div><p>Let's get started by implementing an <code class="literal">IntentService</code> to retrieve the number of SMSs in the inbox from a particular mobile number:</p><div class="informalexample"><pre class="programlisting">public class CountMsgsIntentService extends IntentService {

public static final String NUMBER_KEY = "number";

public CountMsgsIntentService() {
    super("CountThread");
  }

@Override
protected void onHandleIntent(Intent intent) {
  String phoneNumber = intent.getStringExtra(NUMBER_KEY);
  Cursor cursor = getMsgsFrom(phoneNumber);
  int numberOfMsgs = cursor.getCount();
    // Return will be adressed later
    ...
  }
  // Retrieve the number of messages in the inbox for a
  // specific number
  private Cursor getMsgsFrom(String phoneNumber) {
    String[] select = {
      Telephony.Sms._ID,
      Telephony.Sms.ADDRESS,
      Telephony.Sms.BODY,
    };
  String whereClause =
    Telephony.Sms.ADDRESS + " = '" + phoneNumber + "'";
    Uri quri = Uri.parse("content://sms/inbox");
    return getContentResolver().query(
        quri,
        select, // Columns to select
        whereClause, // Clause to filter results
        null, // Arguments for the whereClause
        null);
  }
}</pre></div><p>Once the request <a id="id274" class="indexterm"/>is received on the <code class="literal">IntentService</code>, the <a id="id275" class="indexterm"/>request is pushed to the internal <code class="literal">Looper</code> queue and as soon as it get chance to process it, the <code class="literal">IntenService</code> invokes the <code class="literal">onHandleIntent</code> method with the Intent we passed in on the <code class="literal">startService()</code> method.</p><p>Next, we query the SMS Inbox Content Provider using the <code class="literal">phoneNumber</code> received, and after that we count the records retrieved.</p><p>Notice that <a id="id276" class="indexterm"/>we're declaring a public <a id="id277" class="indexterm"/>static constant name for the argument parameter, just to make it easy to use the correct name from any client <code class="literal">Activity</code> that wants to invoke the Service.</p><p>We can now invoke this <code class="literal">IntentService</code> as follows:</p><div class="informalexample"><pre class="programlisting">void triggerIntentService(String phone) {
    Intent intent = new Intent(this,
                               CountMsgsIntentService.class);
    intent.putExtra(CountMsgsIntentService.NUMBER_KEY, phone);
    startService(intent);
}</pre></div><p>The code above receives the <code class="literal">phoneNumber</code> as an argument and submits a new start request to <code class="literal">IntentService</code> to be processed sequentially following the submission order.</p><p>So far so good, but you've <a id="id278" class="indexterm"/>probably noticed that we haven't done anything with the result we retrieved. In the next section, we'll look at some of the ways in which we can send results from services to activities or fragments.</p></div><div class="section" title="Handling results"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Handling results</h2></div></div></div><p>Any <code class="literal">Service</code>—including subclasses of <code class="literal">IntentService</code>—can be used to start background work <a id="id279" class="indexterm"/>from which the originating <code class="literal">Fragment</code> or <code class="literal">Activity</code> doesn't expect a response.</p><p>However, it is very common to need to return a result or display the result of the background work to the user. We have several options for doing this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Send a <a id="id280" class="indexterm"/><code class="literal">PendingIntent</code> to the <code class="literal">Service</code> from the originating <code class="literal">Activity</code>, allowing the <code class="literal">Service</code> to callback to the <code class="literal">Activity</code> via its <code class="literal">onActivityResult</code> method</li><li class="listitem" style="list-style-type: disc">Post a system notification allowing the user to be informed that the background work was completed, even if the application is no longer in the foreground</li><li class="listitem" style="list-style-type: disc">Send a message to a <code class="literal">Handler</code> in the originating <code class="literal">Activity</code> using <code class="literal">Messenger</code></li><li class="listitem" style="list-style-type: disc">Broadcast the result as an <code class="literal">Intent</code>, allowing any <code class="literal">Fragment</code> or <code class="literal">Activity</code>—including the originator—to receive the result of background processing</li></ul></div><p>We'll learn about <code class="literal">BroadcastReceiver</code>, long-running tasks with <code class="literal">Service</code>, later, but now we'll return results with <a id="id281" class="indexterm"/><code class="literal">PendingIntent</code> and alert the user with system notifications.</p></div><div class="section" title="Posting results with PendingIntent"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Posting results with PendingIntent</h2></div></div></div><p>When we <a id="id282" class="indexterm"/>invoke an <code class="literal">IntentService</code>, it does not automatically have any way to respond to the calling Activity; so if the <code class="literal">Activity</code> wants to receive a result, it must provide some means for the <code class="literal">IntentService</code> to reply.</p><p>Arguably the easiest way to do that is with <code class="literal">PendingIntent</code>, which will be familiar to any Android <a id="id283" class="indexterm"/>developer who has worked with <a id="id284" class="indexterm"/>multiple activities using the <a id="id285" class="indexterm"/><code class="literal">startActivityForResult</code> and <code class="literal">onActivityResult</code> methods, as the pattern is essentially the same.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>A PendingIntent is a token that you give to a foreign application component (Service, BroacastReceiver, or other applications) that allows the foreign entity to use your application's permissions to execute a predefined piece of code.</p></div></div><p>First, we'll add a few static members to <code class="literal">CountMsgsIntentService</code> to ensure that we use consistent values between it and the calling <code class="literal">Activity</code>:</p><div class="informalexample"><pre class="programlisting">    public static final String PENDING_RESULT = "pending_result";
    public static final String RESULT = "result";
    public static final int RESULT_CODE = "countMsgs".hashCode();</pre></div><p>We'll also need to define a static member in our Activity for the <code class="literal">REQUEST_CODE</code> constant, which we can use to correctly identify the results returned to our <code class="literal">onActivityResult</code> method:</p><div class="informalexample"><pre class="programlisting">private static final int REQUEST_CODE = 0;</pre></div><p>Now, when we want to invoke <code class="literal">CountMsgsIntentService</code> from our <code class="literal">Activity</code>, we'll create a <code class="literal">PendingIntent</code> for the current <code class="literal">Activity</code>, which will act as a callback to invoke the Activity <code class="literal">onActivityResult</code> method.</p><p>We can create a <code class="literal">PendingIntent</code> with the <code class="literal">createPendingResult</code> method of the Activity, which accepts three parameters: an <code class="literal">int</code> result code, an Intent to use as the default result, and an <code class="literal">int</code> that encodes some flags for how the <code class="literal">PendingIntent</code> can be used (for example, whether it may be used more than once):</p><div class="informalexample"><pre class="programlisting"> PendingIntent pending = createPendingResult(REQUEST_CODE,
                                             new Intent(), 0);</pre></div><p>We pass the <code class="literal">PendingIntent</code> to the <code class="literal">IntentService</code> by adding it as an extra to the Intent we launch the <code class="literal">IntentService</code> with:</p><div class="informalexample"><pre class="programlisting">private void triggerIntentService(String phone) {
    PendingIntent pending = createPendingResult(
                              REQUEST_CODE, new Intent(), 0);
    Intent intent = new Intent(this,CountMsgsIntentService.class);
    intent.putExtra(CountMsgsIntentService.NUMBER_KEY, phone);
    intent.putExtra(CountMsgsIntentService.PENDING_RESULT, 
                   pending);
    startService(intent);
}</pre></div><p>To handle the result that will be returned when this <code class="literal">PendingIntent</code> is invoked, we need to implement <a id="id286" class="indexterm"/><code class="literal">onActivityResult</code> <a id="id287" class="indexterm"/>in the <code class="literal">Activity</code>, and check <a id="id288" class="indexterm"/>for the result code:</p><div class="informalexample"><pre class="programlisting">protected void onActivityResult(int req, int res, Intent data) {

    if (req == REQUEST_CODE &amp;&amp;
        res == CountMsgsIntentService.RESULT_CODE) {

     // Retrieve the count from result Intent
      int result = data.getIntExtra(
                  CountMsgsIntentService.RESULT, -1);

     // Update UI View with the result
       TextView msgCountBut = (TextView) findViewById(
                               R.id.msgCountTv);
  msgCountBut.setText(Integer.toString(result));
    }
    super.onActivityResult(req, res, data);
}</pre></div><p>The <code class="literal">IntentService</code> can now reply to the calling <code class="literal">Activity</code> by invoking one of the <code class="literal">PendingIntent</code> send methods with the appropriate request code. Our updated <code class="literal">onHandleIntent</code> method looks as follows:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onHandleIntent(Intent intent) {

  String phoneNumber = intent.getStringExtra(NUMBER_KEY);
  Cursor cursor = countMsgsFrom(phoneNumber);
  int numberOfMsgs = cursor.getCount();

  try {
 Intent result = new Intent();
 result.putExtra(RESULT, numberOfMsgs);
 PendingIntent reply = intent.getParcelableExtra(
                           PENDING_RESULT);
    reply.send(this, RESULT_CODE, result);
  } catch (PendingIntent.CanceledException exc) {
 Log.e("CountMsgsIntentService", "reply cancelled", exc);
  }
}</pre></div><p>The additional code creates a new Intent object and populates it with our counter result retrieved from the cursor, and sends the result back to the calling Activity using the received <a id="id289" class="indexterm"/><code class="literal">PendingIntent</code>. Additionally, we <a id="id290" class="indexterm"/>handle the <code class="literal">CanceledException</code>, in case the calling <code class="literal">Activity</code> decided that it wasn't interested in the result <a id="id291" class="indexterm"/>anymore and canceled the <code class="literal">PendingIntent</code>.</p><p>That's all there is to it—our <code class="literal">Activity</code> will now be invoked via its <code class="literal">onActivityResult</code> method when the <code class="literal">IntentService</code> completes its work. As a bonus, we will even receive the result if the <code class="literal">Activity</code> has restarted, for example, due to configuration changes such as a device rotation.</p><p>What if the user left the <code class="literal">Activity</code> (or even left the application) while the background work was in progress? In the next section, we'll use notifications to provide feedback without interrupting the user's new context.</p></div><div class="section" title="Posting results as system notifications"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Posting results as system notifications</h2></div></div></div><p>System <a id="id292" class="indexterm"/>notifications appear initially as an icon in the notification area, normally at the very top of the device screen. Once <a id="id293" class="indexterm"/>notified, the user can open the notification drawer to see more details.</p><p>Notifications are an ideal way to inform the user of results or status updates from services, particularly when the operation may take a long time to complete and the user is likely to be doing something else in the meantime.</p><p>Let's post the result of our message counter as a notification, with a message containing the result that the user can read when they open the notification drawer. We'll use the support library to ensure broad API level compatibility, and add one method to <code class="literal">CountMsgsIntentService</code>, as follows:</p><div class="informalexample"><pre class="programlisting">private void notifyUser(String phoneNumber, int msgsCount) {
 
  String msg = String.format(
    "Found %d from the phone number %s", msgsCount, phoneNumber);
 
  NotificationCompat.Builder builder =
    new NotificationCompat.Builder(this)
      .setSmallIcon(R.drawable.ic_sms_counter_not)
      .setContentTitle("Inbox Counter")
      .setContentText(msg);

  // Gets an instance of the NotificationManager service
  NotificationManager nm = (NotificationManager) getSystemService(
                             Context.NOTIFICATION_SERVICE);
  // Sets an unique ID for this notification
  nm.notify(phoneNumber.hashCode(), builder.build());
}</pre></div><p>Each notification has an identifier that we can use to control whether a new notification is posted or <a id="id294" class="indexterm"/>an existing one is reused. The identifier is an <code class="literal">int</code>, and is the first parameter to the notify method. Since our <code class="literal">countMsgsFrom</code> value is an <code class="literal">int</code>, and we would like to be able to post multiple notifications, it makes sense to use <code class="literal">phoneNumber</code> as the ID for our notifications so that each different request can produce its own separate notification.</p><p>To post a notification containing the result of our service request, we just need to update <code class="literal">onHandleIntent</code> to invoke the <code class="literal">notifyUser</code> method:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onHandleIntent(Intent intent) {

  String phoneNumber = intent.getStringExtra(NUMBER_KEY);
  Cursor cursor = countMsgsFrom(phoneNumber);
  int numberOfMsgs = cursor.getCount();
  notifyUser(phoneNumber,numberOfMsgs);
  ...
}</pre></div><p>Now that we've <a id="id295" class="indexterm"/>learned the basics of using <code class="literal">IntentService</code>, let's consider some real- world applications.</p></div><div class="section" title="Applications of IntentService"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Applications of IntentService</h2></div></div></div><p>Ideal applications <a id="id296" class="indexterm"/>for <code class="literal">IntentService</code> include just about <a id="id297" class="indexterm"/>any long-running task where the work is not especially tied to the behavior of a <code class="literal">Fragment</code> or <code class="literal">Activity</code>, and particularly when the task must complete its processing regardless of whether the user exits the application.</p><p>However, <code class="literal">IntentService</code> is only suitable for situations where a single worker thread is sufficient to handle the workload, since its work is processed by a single <code class="literal">HandlerThread </code>sequentially following the order of submission, and we cannot start more than one instance of the same <code class="literal">IntentService</code> subclass.</p><p>A use case that <code class="literal">Intent Service</code> is ideally suited for is one-shot, long–running tasks that could be processed in the background without user intervention:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Uploading data to remote servers</li><li class="listitem" style="list-style-type: disc">Database <a id="id298" class="indexterm"/>or data backups</li><li class="listitem" style="list-style-type: disc">Time consuming <a id="id299" class="indexterm"/>file data processing</li><li class="listitem" style="list-style-type: disc">Communication with web service resources (WSDL or REST)</li><li class="listitem" style="list-style-type: disc">Periodic time operations such as alarm processing, calendar event processing, and so on</li></ul></div><p>A use case that <code class="literal">IntentService</code> is ideally suited for is uploading data to remote servers because:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The upload usually must complete, even if the user leaves the application</li><li class="listitem" style="list-style-type: disc">A single upload at a time usually makes best use of the available connection, since bandwidth is often asymmetric (there is much smaller bandwidth for upload than download)</li><li class="listitem" style="list-style-type: disc">A single upload at a time gives us a better chance of completing each individual upload before losing our data connection</li></ul></div><p>Let's see how we might implement a very simple <code class="literal">IntentService</code> that uploads images to a simple web service via HTTP POST.</p><div class="section" title="HTTP uploads with IntentService"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec08"/>HTTP uploads with IntentService</h3></div></div></div><p>For this example, we'll <a id="id300" class="indexterm"/>create a new <code class="literal">Activity</code>, <code class="literal">UploadArtworkActivity</code>, to allow the user to pick an album artwork to upload. We'll start with the code for <code class="literal">AlbumListActivity</code> that we created in <a class="link" href="ch04.html" title="Chapter 4. Exploring the Loader">Chapter 4</a>, <span class="emphasis"><em>Exploring the Loader</em></span>.</p><p>Our new <code class="literal">UploadArtworkActivity</code> only needs a small modification to add an <code class="literal">OnItemClickListener</code> <a id="id301" class="indexterm"/>interface to the <code class="literal">GridView</code> of images, so that tapping an image triggers its upload. We can add the listener as an anonymous inner class in <code class="literal">onCreate</code> as follows:</p><div class="informalexample"><pre class="programlisting">grid.setOnItemClickListener(new AdapterView.OnItemClickListener() {
  @Override
  public void onItemClick(AdapterView&lt;?&gt; parent, View view,
                          int position, long id) {
    Cursor cursor = (Cursor) mAdapter.getItem(position);
    int albumId = cursor.getInt( 
      cursor.getColumnIndex(MediaStore.Audio.Albums._ID));
    Uri sArtworkUri = Uri.parse(
      "content://media/external/audio/albumart");
    Uri albumArtUri = ContentUris.
                        withAppendedId(sArtworkUri, albumId);
    Intent intent = new Intent(UploadArtworkActivity.this,
                               UploadArtworkIntentService.class);
    intent.setData(albumArtUri);
    startService(intent);
  }
});</pre></div><p>This looks like quite a dense chunk of code, but all it really does is use the position of the tapped thumbnail to <a id="id302" class="indexterm"/>move the <code class="literal">Cursor</code> to the correct row in its result set, extract the ID of the album that was tapped, create a <code class="literal">Uri</code> for its artwork file, and then start <code class="literal">UploadArtworkIntentService</code> with an Intent containing that Uri.</p><p>We'll extract the details of the upload into a separate class, so <code class="literal">UploadArtworkIntentService</code> itself is just a fairly sparse <code class="literal">IntentService</code> implementation. In <code class="literal">onCreate</code>, we'll set up an instance of our <code class="literal">ImageUploader</code> class, which will be used to process all uploads added to the queue during this lifetime of the Service:</p><div class="informalexample"><pre class="programlisting">public void onCreate() {
  super.onCreate();
  mImageUploader = new ImageUploader(getContentResolver());
}</pre></div><p>The implementation of <code class="literal">ImageUploader</code> itself is not all that interesting—we just use Java's <code class="literal">HTTPURLConnection</code> class to post the image data to the server. The complete source code is available on the Packt Publishing website, so we'll just list two critical methods—upload and <a id="id303" class="indexterm"/>pump—and leave out the housekeeping:</p><div class="informalexample"><pre class="programlisting">public boolean upload(Uri data, ProgressCallack callback) {
  HttpURLConnection conn = null;
  try {
    int len = getContentLength(data);
    URL destination = new URL(UPLOAD_URL);
    conn = (HttpURLConnection) destination.openConnection();
    conn.setRequestMethod("POST");
    ...
    OutputStream out = null;
    try {
      pump(in = mContentResolver.openInputStream(data),
           out = conn.getOutputStream(),
           callback, len);
    } finally {
      if (in != null )
        in.close();
      if (out != null )
        out.close();
      int responseCode = conn.getResponseCode();
      return (( responseCode &gt;= 200) &amp;&amp;
              (responseCode &lt; 400));
    }
  } catch (IOException e) {
    Log.e("Upload Service", "upload failed", e);
    return false;
  } finally {
    conn.disconnect();
  }
}</pre></div><p>The <code class="literal">pump</code> method just copies 1 KB chunks of data from the <code class="literal">InputStream</code> to the <code class="literal">OutputStream</code>, pumping the data to the server, and invokes the progress callback function, as follows:</p><div class="informalexample"><pre class="programlisting">private void pump(InputStream in, OutputStream out,
                  ProgressCallack callback, int len)
throws IOException {

  int length, i = 0, size = 1024;
  byte[] buffer = new byte[size]; // 1kb buffer
  while ((length = in.read(buffer)) &gt; -1) {   
    out.write(buffer, 0, length);
    out.flush();
    if (callback != null)
      callback.onProgress(len, ++i * size);
  }
}</pre></div><p>Each time a 1 KB chunk of data is pushed to the <code class="literal">OutputStream</code>, we invoke the <code class="literal">ProgressCallback</code> <a id="id304" class="indexterm"/>method, which we'll use in the next section to report the progress to the user.</p></div><div class="section" title="Reporting progress"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Reporting progress</h3></div></div></div><p>For long-running <a id="id305" class="indexterm"/>processes, it can be very useful to report progress so that the user can take comfort in knowing that something is actually happening.</p><p>To report progress from an <code class="literal">IntentService</code>, we can use the same mechanisms that we use to send results—for example, sending <code class="literal">PendingIntents</code> containing progress information, or posting system notifications with progress updates.</p><p>We can also use other techniques that we'll cover later in the chapter, broadcasting intents to registered receivers.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>Whichever approach we take to report progress, we should be careful not to report progress too frequently, otherwise we'll waste resources updating the progress bar at the expense of completing the work itself!</p></div></div><p>Let's look at an example that displays a progress bar on notifications in the drawer—a use case that the Android development team anticipated and therefore made easy for us with the <code class="literal">setProgress</code> method of <code class="literal">NotificationCompat.Builder</code>:</p><div class="informalexample"><pre class="programlisting">Builder setProgress(int max, int progress, boolean indeterminate);</pre></div><p>Here, max sets the target value at which our work will be completed, progress is where we have got to so far, and indeterminate controls which type of progress bar is shown. When indeterminate is true, the notification shows a progress bar that indicates something is in progress without specifying how far through the operation we are, while false shows the kind of progress bar that we need—one that shows how much work we have done, and how <a id="id306" class="indexterm"/>much is left to do.</p><p>We'll need to calculate progress and dispatch notifications at appropriate intervals, which we've facilitated through our <code class="literal">ProgressCallback</code> class. Now we need to implement the <code class="literal">ProgressCallback</code> and hook it up in <code class="literal">UploadArtworkIntentService</code>:</p><div class="informalexample"><pre class="programlisting">private class ProgressNotificationCallback
  implements ImageUploader.ProgressCallack {
  private NotificationCompat.Builder builder;
  private NotificationManager nm;
  private int id, prev;

  public ProgressNotificationCallback(
    Context ctx, int id, String msg) {
    this.id = id;
    prev = 0;
    builder = new NotificationCompat.Builder(ctx)
      .setSmallIcon(android.R.drawable.stat_sys_upload_done)
      .setContentTitle("Uploading Artwork")
      .setContentText(msg)
      .setProgress(100, 0, false);
    nm = (NotificationManager)
         getSystemService(Context.NOTIFICATION_SERVICE);
    nm.notify(id, builder.build());
  }

  public void onProgress(int max, int progress) {
    int percent = (int) ((100f * progress) / max);
    if (percent &gt; (prev + 5)) {
      builder.setProgress(100, percent, false);
      nm.notify(id, builder.build());
      prev = percent;
    }
  }

  public void onComplete(String msg) {
    builder.setProgress(0, 0, false);
    builder.setContentText(msg);
    nm.notify(id, builder.build());
  }
}</pre></div><p>The constructor of <code class="literal">ProgressNotificationCallback</code> consists of familiar code to post a notification with a progress bar.</p><p>The <code class="literal">onProgress</code> method throttles the rate at which notifications are dispatched, so that we only post an update as each additional 5 percent of the total data is uploaded, in order not to swamp the system with notification updates.</p><p>The <code class="literal">onComplete</code> method posts a notification that sets both the integer progress parameters to zero, which removes the progress bar.</p><p>To complete the code, we <a id="id307" class="indexterm"/>implement <code class="literal">onHandleIntent</code> to display the notification drawer and deliver the upload result:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onHandleIntent(Intent intent) {
  Uri data = intent.getData();
 
  // Unique id per upload, so each has its own notification
  int id = Integer.parseInt(data.getLastPathSegment());
  String msg = String.format("Uploading %s.jpg", id);

  ProgressNotificationCallback progress =
    new ProgressNotificationCallback(this, id, msg);
 
  // On Upload sucess
  if (mImageUploader.upload(data, progress)) {
    progress.onComplete(
      String.format("Upload finished for %s.jpg", id)); 
  // On Upload Failure
  } else {
    progress.onComplete(
      String.format("Upload failed %s.jpg", id));
  }
}</pre></div><p>Tap an artwork image to start uploading and you'll see a notification appear. Slide open the notification drawer and watch the progress bar ticking up as your image uploads.</p><p>We are finished with started services, so now it is time to move to a different type of Service, the Bound <a id="id308" class="indexterm"/>Service.</p></div></div></div>
<div class="section" title="Bound Service"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Bound Service</h1></div></div></div><p>A Bound Service is an <a id="id309" class="indexterm"/>Android Service that defines a client interface and allows several entities to bind it by invoking <code class="literal">bindService()</code> and creating a relation between each order that facilitates the interaction with a request-response model.</p><p>The <code class="literal">Service</code> instance will be created when the first client attempts to connect to it and will be alive until the last client disconnects from it using the <code class="literal">unbindService()</code> function.</p><p>In order to create the connection between the client and the server, the service must implement the <code class="literal">onBind()</code> function and return an <code class="literal">IBinder</code> object that implements a lightweight remote procedure mechanism to perform in-process or cross-process calls:</p><div class="informalexample"><pre class="programlisting">IBinder onBind(Intent intent)</pre></div><p>When all the clients disconnect from the Service, calling <code class="literal">unbindService()</code>, the service <code class="literal">onUnbind()</code> member method is called:</p><div class="informalexample"><pre class="programlisting">boolean onUnbind (Intent intent)</pre></div><p>A Bound Service might reside in the same process (LS), in a different process that belongs to the application (LIS), or in an another application process (GS), so the technique to communicate with the service and the <code class="literal">IBinder</code> type returned depends entirely on the service process location, as mentioned before.</p><p>In the next section, we are going to explain how to interact and bind to a local Service to initiate an asynchronous action on the Service.</p><p>The remote binding with <a id="id310" class="indexterm"/>AIDL or with Messenger are other techniques used in advanced use cases where inter-process communication is required, though in this book we are not going to cover it.</p><p>For a smooth start, first we are going to cover a local <code class="literal">Service</code> binding.</p><div class="section" title="Communicating with a Local Service"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Communicating with a Local Service</h2></div></div></div><p>A local bound <a id="id311" class="indexterm"/>service is the most common type of bound <code class="literal">service</code>, and given that the server and the client run on the same <a id="id312" class="indexterm"/>process, there is no need to use an <span class="strong"><strong>inter-process communication</strong></span> (<span class="strong"><strong>IPC</strong></span>) technique to send requests and receive responses between them. Moreover, both entities, the service client and server, share the same address memory space within the process, making the exchange of requests and responses quite easy using Java Objects.</p><p>Since we are within the same process, the <code class="literal">Binder</code> object returned by the <code class="literal">onBind()</code> <code class="literal">Service</code> method might define a method to return the <code class="literal">Service</code> class instance object. In this manner, we can use the public <code class="literal">Service</code> class functions to submit new requests to the <code class="literal">Service</code> in the same way as we invoke a regular object method.</p><p>Let's demonstrate this with an example, creating a bound service that creates an SHA1 cryptographic digest from a string that we type in a UI <code class="literal">EditText</code>.</p><p>Primarily, we <a id="id313" class="indexterm"/>will start by implementing our own <code class="literal">Binder</code>:</p><div class="informalexample"><pre class="programlisting">public class Sha1HashService extends Service {
 
  // Instance Binder given to clients
  private final IBinder mBinder = new LocalBinder();

  public class LocalBinder extends Binder {
    Sha1HashService getService() {
      // Return this instance of LocalService
      // so clients can call public methods
      return Sha1HashService.this;
    }
  }
  @Override
  public IBinder onBind(Intent intent) {
    return mBinder;
  }
}</pre></div><p>Our binder, <code class="literal">LocalBinder</code>, extends from the <code class="literal">Binder</code> class, and provides a <code class="literal">getService()</code> method to retrieve the instance of our <code class="literal">Service</code>. Then, when any client connects to our <code class="literal">Service</code>, the <code class="literal">onBind()</code> function will return our <code class="literal">LocalBinder</code> instance object.</p><p>An <code class="literal">Activity</code> or <code class="literal">Fragment</code> that wants to directly interact with this <code class="literal">Service</code> first needs to bind to it using the <code class="literal">bindService</code> method and secondly supply a <code class="literal">ServiceConnection</code> to handle the <code class="literal">onServiceConnected()</code>/<code class="literal">onServiceDisconnected()</code> callbacks.</p><p>The <code class="literal">ServiceConnection</code> implementation simply casts the <code class="literal">IBinder</code> received to the concrete class defined <a id="id314" class="indexterm"/>by the <code class="literal">Service</code>, obtains a reference to the <code class="literal">Service</code>, and records it in a member variable of the <code class="literal">Activity</code>:</p><div class="informalexample"><pre class="programlisting">public class Sha1Activity extends Activity {

  Sha1HashService mService;
  boolean mBound = false;

  // Defines callbacks for service binding,
  // passed to bindService()
  private ServiceConnection mConnection = new ServiceConnection()   
  {
    @Override
    public void onServiceConnected(ComponentName name,
                                   IBinder service) {

      // We've bound to LocalService,
      // cast the IBinder and get LocalService instance
      Sha1HashService.LocalBinder binder =
        (Sha1HashService.LocalBinder) service;
      mService = binder.getService();
      mBound = true;

      // After this the Activity can invoke the Service methods
    }

    @Override
    public void onServiceDisconnected(ComponentName arg0) {
      mBound = false;
      mService = null;
    }
  };
}</pre></div><p>When we lose the <a id="id315" class="indexterm"/>connection with Service unexpectedly, due to a service crash or an unexpected error in the Android system, <code class="literal">onServiceDisconnected</code> gets called to notify the client that the connection to the service is considered lost.</p><p>We can make the <code class="literal">Activity</code> bind and unbind during its <code class="literal">onStart()</code> and <code class="literal">onStop()</code> lifecycle method, because we only need to interact with the service when the <code class="literal">Activity</code> is visible on the screen. We should try to avoid the bind and unbind <code class="literal">onResume()</code> and <code class="literal">onPause() Activity</code> callbacks to reduce the number of connect and disconnect transitions in <a id="id316" class="indexterm"/>your application's lifecycle:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onStart() {
    super.onStart();
    // Bind to LocalService
    Intent intent = new Intent(this, Sha1HashService.class);
    bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
}

@Override
protected void onStop() {
    super.onStop();
    // Unbind from the service
    if (mBound) {
        unbindService(mConnection);
        mBound = false;
    }
}</pre></div><p>Once the <code class="literal">Activity</code> starts, we call the <code class="literal">Context.bindService()</code>, passing an Intent that explicitly defines the <code class="literal">Service</code> class that we want to bind, our <code class="literal">ServiceConnection</code> instance, and the optional flag <code class="literal">Context.BIND_AUTO_CREATE</code> that means that the System will keep the Service running as long as this bind exists.</p><p>In Hybrid Services (Bound/Started), after we bind to a Service, we can access the Service by calling <code class="literal">startService(Intent)</code> and process Service calls over <code class="literal">onStartCommand(Intent, int, int)</code>.</p><p>This is great—once the binding is made, we have a direct reference to the <code class="literal">Service</code> instance and can call its methods! However, we didn't implement any methods in our <code class="literal">Service</code> yet, so it's currently useless.</p><p>Let's create a method on <code class="literal">Sha1HashService</code> to calculate the digest in the background and return the result to the <code class="literal">Activity</code>.</p><p>First, to execute this task in background we need to setup the execution engine, so to achieve that we are going to set up our own <code class="literal">Executor</code> based on the <code class="literal">ThreadPool</code> class supplied in <code class="literal">java.util.concurrent</code>. The Executor will support concurrency, from two to four concurrent <a id="id317" class="indexterm"/>threads, and request queueing up to 32 queued jobs:</p><div class="informalexample"><pre class="programlisting">public class Sha1HashService extends Service {

  private static final int CORE_POOL_SIZE = 2;
  private static final int MAXIMUM_POOL_SIZE = 4;
  private static final int MAX_QUEUE_SIZE = 32;
  private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =
    new LinkedBlockingQueue&lt;Runnable&gt;(MAX_QUEUE_SIZE);

  private ThreadPoolExecutor mExecutor;

  // Factory to set the Thread Names
  private static final ThreadFactory sThreadFactory =
  new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);
    public Thread newThread(Runnable r) {
      Thread t = new Thread(r, "SHA1HashService #" +
                                mCount.getAndIncrement());
      t.setPriority(Thread.MIN_PRIORITY);
      return t;
    }
  };

  @Override
  public void onCreate() {
    super.onCreate();
    mExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE,
                                       MAXIMUM_POOL_SIZE, 1,
                                       TimeUnit.SECONDS, 
                                       sPoolWorkQueue,
                                       sThreadFactory);
    mExecutor.prestartAllCoreThreads();
  }</pre></div><p>When the Service is created, immediately after the first binding, the <code class="literal">ThreadPool</code> is started and the <a id="id318" class="indexterm"/>core threads (2) are started with <code class="literal">prestartAllCoreThreads</code>, ready to process the incoming requests as soon as they arrive in the Service. If the clients submit requests at such a pace that the core threads are not able handle them, the thread pool will increase the number of worker threads in the pool until it reaches four threads.</p><p>Now that we have the executor in place, we will create the public method that receives the request to digest a <code class="literal">String</code>:</p><div class="informalexample"><pre class="programlisting">void getSha1Digest(final String text) {

  Runnable runnable = new Runnable() {
    @Override
    public void run() {
     try {
        // Execute the Long Running Computation
        final String <span class="strong"><strong>digest</strong></span> = SHA1(text);
      } catch (Exception e) {
        Log.e("Sha1HashService", "Hash failed for "+ text, e);
      }
    }
  };
  // Submit the Runnable on the ThreadPool
  mExecutor.execute(runnable);
}

private String SHA1(String text) throws Exception {
  MessageDigest md = MessageDigest.getInstance("SHA-1");
  md.update(text.getBytes("iso-8859-1"), 0, text.length());
  byte[] sha1hash = md.digest();
  return convertToHex(sha1hash);
}
private String convertToHex(byte[] data) {
   ...
}</pre></div><p>Since <code class="literal">Sha1Activity</code> has a direct object reference to <code class="literal">Sha1HashService</code>, we can now go ahead and <a id="id319" class="indexterm"/>invoke its <code class="literal">getSha1Digest</code> method directly—taking care to check that the <code class="literal">Service</code> is actually bound first, of course:</p><div class="informalexample"><pre class="programlisting">// Invoke the Sha1Hash Service to calculate the digest
//  when the hash button is pressed
queryButton.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View v) {
    EditText et = (EditText)findViewById(R.id.text);
    if (mService != null) {
      mService.getSha1Digest(et.getText().toString());
    }
  }
});</pre></div><p>Taking the text retrieved from our <code class="literal">EditText</code> view, we call our Service <code class="literal">getSha1Digest</code> to calculate the typed text digest. This is a very convenient and efficient way of submitting work to a <code class="literal">Service</code>—there's no need to package up a request in an Intent, so there's no excess object creation or communication overhead.</p><p>Since <code class="literal">getSha1Digest</code> is asynchronous, we can't return a result directly from the method invocation, and <code class="literal">Sha1HashService</code> itself has no user interface, so how can we present results to our user?</p><p>One possibility is <a id="id320" class="indexterm"/>to pass a callback to <code class="literal">Sha1HashService</code> so that we can invoke methods of our <code class="literal">Activity</code> when the background work completes. Let's define a generic callback interface for the activity to implement:</p><div class="informalexample"><pre class="programlisting">public interface ResultCallback&lt;T&gt; {
    void onResult(T data);
}</pre></div><p>There is a serious risk that by passing an <code class="literal">Activity</code> into the <code class="literal">Service</code>, we'll expose ourselves to memory leaks. The lifecycles of <code class="literal">Service</code> and <code class="literal">Activity</code> do not coincide, so strong references to an <code class="literal">Activity</code> from a <code class="literal">Service</code> can prevent it from being garbage collected in a timely fashion.</p><p>The simplest way to prevent such memory leaks is to make sure that <code class="literal">Sha1HashService</code> only keeps a weak reference to the calling <code class="literal">Activity</code> so that when its lifecycle is complete, the <code class="literal">Activity</code> can be garbage collected, even if there is an ongoing calculation in the Service.</p><p>It is really important to remember that whenever we update the UI during the <code class="literal">ResultCallback.onResult</code>, we must do it in the UI Thread; therefore, it is essential to create a <code class="literal">Runnable</code> object with the result and post it on the main <code class="literal">Looper</code>.</p><p>The modified <a id="id321" class="indexterm"/><code class="literal">Sha1HashService</code> is shown in the following code:</p><div class="informalexample"><pre class="programlisting">private void postResultOnUI(final String result,
  final WeakReference&lt;ResultCallback&lt;String&gt;&gt; refCallback) {
 
  // Retrieve the main Thread Looper
  Looper mainLooper = Looper.getMainLooper();
  final Handler handler = new Handler(mainLooper);
  handler.post(new Runnable() {
    @Override
    public void run() {
      if ( refCallback.get() != null ) {
        refCallback.get().onResult(result);
      }
    }
  });
}

public void getSha1Digest(final String text, 
                          ResultCallback&lt;String&gt; callback) {

  final WeakReference&lt;ResultCallback&lt;String&gt;&gt; ref =
    new WeakReference&lt;ResultCallback&lt;String&gt;&gt;(callback);

  Runnable runnable = new Runnable() {
    @Override
    public void run() {
      try {
        // Execute the Long Running Computation
        final String digest = SHA1(text);     
        // Execute the Runnable on UI Thread
        postResultOnUI(digest, ref);
      } catch (Exception e) {
        Log.e("Sha1HashService", "Hash failed", e);
      }
    }
  };
  // Submit the Runnable on the ThreadPool
  mExecutor.execute(runnable);
}</pre></div><p>We invoke the callback on the main thread using <code class="literal">postResultOnUI</code>, so that <code class="literal">Sha1Activity</code> <a id="id322" class="indexterm"/>can interact with the user interface directly in the callback method. We can implement the callback as a method of <code class="literal">Sha1Activity</code>:</p><div class="informalexample"><pre class="programlisting">public class Sha1Activity extends Activity
  implements ResultCallback&lt;String&gt; {

   @Override
    public void onResult(String data) {
        // Updates the result view with the digest string
        TextView et = (TextView)findViewById(R.id.hashResult);
        et.setText(data);
    }
   }</pre></div><p>Now we can directly invoke methods in <code class="literal">Sha1HashService</code> and return results via a callback method of <code class="literal">Sha1Activity</code> by passing the <code class="literal">Activity</code> itself as the callback:</p><div class="informalexample"><pre class="programlisting">if ( mService != null ) {
  mService.getSha1Digest(et.getText().toString(),
                         Sha1Activity.this);
}</pre></div><p>Our service uses their local <code class="literal">ThreadPool</code> executor to handle the requests in an asynchronous way, although we might have used the <code class="literal">AsyncTask</code> public static executors: <code class="literal">SERIAL_EXECUTOR</code> to <a id="id323" class="indexterm"/>execute our digest calculation in a serialized way, or the <code class="literal">THREAD_POOL_EXECUTOR</code> to calculate the digest concurrently and independently:</p><div class="informalexample"><pre class="programlisting">void getSha1Digest(final String text,
                   ResultCallback&lt;String&gt; callback) {

  AsyncTask.SERIAL_EXECUTOR.execute(runnable);
  // or
  AsyncTask.THREAD_POOL_EXECUTOR.execute(runnable);
}</pre></div><p>Notice that the <code class="literal">AsyncTask</code> executors are a system-shared resource, a shared group of threads, used by all the <code class="literal">AsyncTasks</code> in the system; therefore, our processing might suffer a delay when all the executor threads are occupied doing work. In most use cases there is no need to create our own custom group of working threads and the <code class="literal">AsyncTask</code> executors should be used.</p><p>This direct communication between <code class="literal">Sha1Activity</code> and <code class="literal">Sha1HashService</code> is very efficient and easy to work with. However, there is a downside: if the <code class="literal">Activity</code> restarts because of a configuration change, such as a device rotation, the <code class="literal">WeakReference</code> to the callback will be garbage collected and <code class="literal">Sha1HashService</code> cannot send the result.</p><p>In the next section we are going to explore a mechanism that sends the results back to an Activity, or an <a id="id324" class="indexterm"/>other part of the application, even after a configuration change – Broadcast Intents.</p></div><div class="section" title="Broadcasting results with intents"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Broadcasting results with intents</h2></div></div></div><p>Broadcasting <a id="id325" class="indexterm"/>an <code class="literal">Intent</code> is a way of sending <a id="id326" class="indexterm"/>results to anyone who registers to receive them. This can even include other applications in separate processes if we choose, but if the <code class="literal">Activity</code> and <code class="literal">Service</code> are a part of the same process, broadcasting is best done using a local broadcast, as this is more efficient and secure:</p><div class="mediaobject"><img src="graphics/Image_B05062_05_02.jpg" alt="Broadcasting results with intents"/></div><p>We can update <code class="literal">Sha1HashService</code> to broadcast its results with just a few extra lines of code. First, let's define two constants to make it easy to register a receiver for the broadcast and extract the result from the broadcast Intent object:</p><div class="informalexample"><pre class="programlisting">    public static final String DIGEST_BROADCAST =
            "asynchronousandroid.chapter5.DIGEST_BROADCAST";
    public static final String RESULT = "digest";</pre></div><p>Now we can implement <a id="id327" class="indexterm"/>the method that does most of the work using the <code class="literal">LocalBroadcastManager</code> to send an Intent object containing the calculated result. We're using the support library class <code class="literal">LocalBroadcastManager</code> here for efficiency and security—broadcasts sent locally don't incur the overhead of interprocess communication and cannot be <a id="id328" class="indexterm"/>leaked outside of our <a id="id329" class="indexterm"/>application:</p><div class="informalexample"><pre class="programlisting">    private void broadcastResult(String digest) {
        Intent intent = new Intent(DIGEST_BROADCAST);
        intent.putExtra(RESULT, digest);
        LocalBroadcastManager.getInstance(this).
          sendBroadcast(intent);
    }</pre></div><p>The <code class="literal">sendBroadcast</code> method is asynchronous and will return immediately without waiting for the message to be broadcast and handled by receivers. Finally, we invoke our new <code class="literal">broadcastResult</code> method from <code class="literal">getSha1Digest</code>:</p><div class="informalexample"><pre class="programlisting">void getSha1Digest(final String text) {
  Runnable runnable = new Runnable() {
    @Override
    public void run() {
      try {
        // Execute the Long Running Computation
        final String digest = SHA1(text);
        // Broadcast Result to Subscribers
        broadcastResult(digest);       
  ...
}</pre></div><p>Great! We're broadcasting the result of our background calculation. Now we need to register a receiver <a id="id330" class="indexterm"/>in <code class="literal">Sha1Activity</code> to handle the result. Here's how we might define our <code class="literal">BroadcastReceiver</code> subclass:</p><div class="informalexample"><pre class="programlisting">private static class DigestReceiver extends BroadcastReceiver {

  private TextView view;

  @Override
  public void onReceive(Context context, Intent intent) {
    if (view != null) {
      String result = intent.getStringExtra(
                        Sha1HashService.RESULT);
      view.setText(result);
    } else {
      Log.i("Sha1HashService", " ignoring - we're detached");
    }
  }

  public void attach(TextView view) {
    this.view = view;
  }
  public void detach() {
    this.view = null;
  }
};</pre></div><p>This <code class="literal">DigestReceiver</code> implementation is quite simple—all it does is extract and display the result from the Intent it receives—basically fulfilling the role of the Handler we used in the previous section.</p><p>We only want this <code class="literal">BroadcastReceiver</code> to listen for results while our <code class="literal">Activity</code> is at the top of the stack and visible in the application, so we'll register and unregister it in the <code class="literal">onStart()</code> and <code class="literal">onStop()</code> lifecycle methods. As with the <code class="literal">Handler</code> that we used previously, we'll <a id="id331" class="indexterm"/>also apply the attach/detach <a id="id332" class="indexterm"/>pattern to make sure we don't leak View objects:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onStart() {
  super.onStart();
     ...
  mReceiver.attach((TextView) findViewById(R.id.hashResult));
  IntentFilter filter =
    new IntentFilter(Sha1HashService.DIGEST_BROADCAST);
  LocalBroadcastManager.getInstance(this).
  registerReceiver(mReceiver, filter);
}

@Override
protected void onStop() {
  ...
  LocalBroadcastManager.getInstance(this).
  unregisterReceiver(mReceiver);
  mReceiver.detach();
}</pre></div><p>Of course, if the user moves to another part of the application that doesn't register a <code class="literal">BroadcastReceiver</code>, or if we exit the application altogether, they won't see the result of the calculation.</p><p>If our Service <a id="id333" class="indexterm"/>could detect unhandled broadcasts, we could modify it to alert the user with a system notification instead. We'll see how to do that in the next section.</p></div><div class="section" title="Detecting unhandled broadcasts"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Detecting unhandled broadcasts</h2></div></div></div><p>In the previous <a id="id334" class="indexterm"/>sections, we used system notifications to <a id="id335" class="indexterm"/>post results to the notification drawer—a nice solution for when the user has navigated away from our app before the background work has completed. However, we don't want to annoy the user by posting notifications when our app is still in the foreground and can display the results directly.</p><p>Ideally, we'll display the results in the app if it is still in the foreground and send a notification otherwise. If we're broadcasting results, the <code class="literal">Service</code> will need to know if anyone handled the broadcast and if not, send a notification.</p><p>One way to do this is to use the <code class="literal">sendBroadcastSync</code> synchronous broadcast method and take advantage of the fact that the <code class="literal">Intent</code> object we're broadcasting is mutable (any receiver can modify it). To begin with, we'll add one more constant to <code class="literal">Sha1HashService</code>:</p><div class="informalexample"><pre class="programlisting">public static final String HANDLED = "intent_handled";</pre></div><p>Next, modify <code class="literal">broadcastResult</code> to use the synchronous broadcast method and return the value of a Boolean extra property; <code class="literal">HANDLED</code> from the Intent:</p><div class="informalexample"><pre class="programlisting">void broadcastResult(final String text) { 
  Intent intent = new Intent(DIGEST_BROADCAST);
  intent.putExtra(RESULT, digest);              
  // Synchronous Broadcast
<span class="strong"><strong>  LocalBroadcastManager.getInstance(Sha1HashService.this).</strong></span>
<span class="strong"><strong>    sendBroadcastSync(intent);</strong></span>
  boolean handled = intent.getBooleanExtra(HANDLED, false);
}</pre></div><p>Because <code class="literal">sendBroadcastSync</code> is synchronous, all registered <code class="literal">BroadcastReceivers</code> will have handled the broadcast by the time <code class="literal">sendBroadcastSync</code> returns. This means that if any receiver sets the Boolean extra property <code class="literal">HANDLED</code> to <code class="literal">true</code>, <code class="literal">broadcastResult</code> will return <code class="literal">true</code>.</p><p>In our <code class="literal">BroadcastReceiver</code>, we'll update the <code class="literal">Intent</code> object by adding a Boolean property to indicate <a id="id336" class="indexterm"/>that we've handled it:</p><div class="informalexample"><pre class="programlisting">@Override
public void onReceive(Context context, Intent intent) {
  if (view != null) {
    String result = intent.getStringExtra(
                      Sha1HashBroadCastUnhService.RESULT);
    intent.putExtra(Sha1HashBroadCastUnhService.HANDLED, true);
    view.setText(result);
  } else {
    Log.i("Sha1HashService", " ignoring - we're detached");
  }
}</pre></div><p>Now if <code class="literal">Sha1Activity</code> is still running, its <code class="literal">BroadcastReceiver</code> is registered and receives the <code class="literal">Intent</code> object and will set the extra Boolean property <code class="literal">HANDLED</code> with the value <code class="literal">true</code>.</p><p>However, if <code class="literal">Sha1Activity</code> has finished, the <code class="literal">BroadcastReceiver</code> will no longer be registered and <code class="literal">Sha1HashService</code> will return <code class="literal">false</code> from its <code class="literal">broadcastResult</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>There's one final complication: unlike <code class="literal">sendBroadcast</code>, which always invokes <code class="literal">BroadcastReceivers</code> on the main thread, <code class="literal">sendBroadcastSync</code> uses the thread that it is called with.</p></div></div><p>Our <code class="literal">BroadcastReceiver</code> interacts directly with the user interface, so we must call it on the main thread. To <a id="id337" class="indexterm"/>broadcast the intent on the main thread synchronously, we create an anonymous Runnable to execute the broadcast:</p><div class="informalexample"><pre class="programlisting">private void broadcastResult(final String text,
                             final String digest) {

  Looper mainLooper = Looper.getMainLooper();
  Handler handler = new Handler(mainLooper);
  handler.post(new Runnable() {
    @Override
    public void run() {
      Intent intent = new Intent(DIGEST_BROADCAST);
      intent.putExtra(RESULT, digest);
      LocalBroadcastManager.getInstance(Sha1HashService.this).
      sendBroadcastSync(intent);
      boolean handled = intent.getBooleanExtra(HANDLED,
                                               false);
      if (!handled) {
        notifyUser(text, digest);
      }
    }
  });
}</pre></div><p>Now that we have the broadcast function in place, we can call it from the <code class="literal">getSha1Digest</code> to <a id="id338" class="indexterm"/>generate an Android notification when the intent is not handled by a <code class="literal">Receiver</code>:</p><div class="informalexample"><pre class="programlisting">void getSha1Digest(final String text) {
  ...
  final String digest = SHA1(text);
  // Execute the Runnable on UI Thread
  broadcastResult(text, digest);
  ...
}</pre></div><p>This does just what we want—if our <code class="literal">BroadcastReceiver</code> handles the message, we don't post a notification; otherwise, we will do so to make sure the user gets their result.</p><p>So far we have been binding to a Service that runs within the same process, where the client shares the memory address space with the Service. In the next section we are going to detail how to interact with Services that run in remote processes using the Android IPC-specific techniques.</p></div></div>
<div class="section" title="Applications of Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Applications of Services</h1></div></div></div><p>With a little bit of work, <code class="literal">Services</code> give us the means to perform long-running background tasks, and free <a id="id339" class="indexterm"/>us from the tyranny of the <code class="literal">Activity</code> lifecycle. As opposed to <code class="literal">IntentService</code>, directly sub-classing a <code class="literal">Service</code> also gives us the ability to control the level of concurrency.</p><p>With the ability to run as many tasks as we need and to take as long as is necessary to complete those tasks, a world of new possibilities opens up.</p><p>The only real constraint on how and when we use <code class="literal">Services</code> comes from the need to communicate results to a user-interface component, such as a <code class="literal">Fragment</code> or <code class="literal">Activity</code>, and the complexity this entails.</p><p>Ideal use cases for <code class="literal">Services</code> tend to have the following characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Long-running (a few hundred milliseconds and upward):</li><li class="listitem" style="list-style-type: disc">Not specific to a single Activity or Fragment class</li><li class="listitem" style="list-style-type: disc">Must complete, even if the user leaves the application</li><li class="listitem" style="list-style-type: disc">Does not require user intervention to complete</li><li class="listitem" style="list-style-type: disc">Operations that require state between different calls</li><li class="listitem" style="list-style-type: disc">Requires more concurrency than <code class="literal">IntentService</code> provides, or needs control over the level of concurrency</li></ul></div><p>There are many applications that exhibit these characteristics, but the stand-out example is, of course, handling concurrent downloads from a web service.</p><p>To make good use of the available download bandwidth and to limit the impact of network latency, we want to be able to run more than one download at a time (but not too many). We also don't want to use more bandwidth than necessary by failing to completely download a <a id="id340" class="indexterm"/>file and having to restart the download later. So ideally, once a download starts, it should run to completion even if the user leaves the application.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we explored the very powerful <code class="literal">Service</code> component, putting it to use to execute long-running background tasks with or without a configurable level of concurrency.</p><p>We explored the incredibly useful <code class="literal">IntentService</code>—an ideal construct for performing long-running background tasks off the main thread, surviving well beyond the lifecycle of the initiating <code class="literal">Activity</code>, and even continuing to do useful work when the application is no longer in the foreground.</p><p>We learned how to send work to an <code class="literal">IntentService</code> with parameterized Intents, how to process that work in the background by implementing <code class="literal">onHandleIntent</code>, and how to send results back to the originating <code class="literal">Activity</code> using a <code class="literal">PendingIntent</code>.</p><p>For cases where the application is no longer in the foreground or an operation is particularly long-running, we saw how to post notifications to the notification drawer, complete with progress updates.</p><p>We also saw the wide range of communication mechanisms available for delivering results back to the user: direct invocation of local <code class="literal">Service</code> methods; broadcasting results to registered parties with <code class="literal">BroadcastReceiver</code>; and, if the user has already left the application, raising system notifications.</p><p>In the next chapter, we'll add one other weapon to our arsenal: the ability to run background tasks at specific times—even when the device is asleep—by scheduling alarms with <code class="literal">AlarmManager</code>.</p></div></body></html>