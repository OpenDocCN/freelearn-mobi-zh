<html><head></head><body>
		<div><h1 id="_idParaDest-253" class="chapter-number"><a id="_idTextAnchor379" class="calibre6 pcalibre pcalibre1"/>13</h1>
			<h1 id="_idParaDest-254" class="calibre5"><a id="_idTextAnchor380" class="calibre6 pcalibre pcalibre1"/>Acing the Coding Assessment</h1>
			<p class="calibre3"><a id="_idTextAnchor381" class="calibre6 pcalibre pcalibre1"/>In the previous chapter, we discussed architecture in depth. Architecture discussions tend to be very theoretical and methodological; the same can be said for design pattern discussions.</p>
			<p class="calibre3">In this chapter, we will get to the meat – to the code, working with Xcode, and playing with algorithms. We will cover everything related to coding interview tasks, such as the following:</p>
			<ul class="calibre10">
				<li class="calibre11">How to succeed in a live coding interview, the different tests, and how to code like a pro</li>
				<li class="calibre11">How to excel in home assessments by discussing different skills to use and reviewing home assessment examples</li>
				<li class="calibre11">How to avoid mistakes that may raise red flags in our interviews</li>
			</ul>
			<p class="calibre3">This is the final chapter! You will be fully prepared for your first interview by the end of it. Now, let’s dive straight into tips for the live coding interview.</p>
			<h1 id="_idParaDest-255" class="calibre5"><a id="_idTextAnchor382" class="calibre6 pcalibre pcalibre1"/>Succeeding in live coding</h1>
			<p class="calibre3"><a id="_idTextAnchor383" class="calibre6 pcalibre pcalibre1"/>The live coding interview <a id="_idIndexMarker985" class="calibre6 pcalibre pcalibre1"/>is probably the most intimidating in the process.</p>
			<p class="calibre3">It’s easy to understand why – for most developers, it’s a stage that is an uncomfortable situation in any case.</p>
			<p class="calibre3">For a start, in most cases, we aren’t working in our beloved (to some of us) Xcode. We are required to handle tasks that we usually don’t face in our day-to-day work, and we’re doing that under pressure while someone is watching us at every step.</p>
			<p class="calibre3">The reason why I said “probably” and “most developers” at the start of this section is that it doesn’t have to be intimidating. Sure, live coding is a stressful interview, but we can make it exciting and much more joyful with the right approach.<a id="_idTextAnchor384" class="calibre6 pcalibre pcalibre1"/></p>
			<p class="calibre3">Skeptical? Don’t be!<a id="_idTextAnchor385" class="calibre6 pcalibre pcalibre1"/> Throughout the preceding 12 chapters, we have observed that proper preparation can make anything achievable.</p>
			<p class="calibre3">Before we rush <a id="_idIndexMarker986" class="calibre6 pcalibre pcalibre1"/>into the interview itself, let’s learn about the different environments we will work in and the different types of tests.</p>
			<h2 id="_idParaDest-256" class="calibre7"><a id="_idTextAnchor386" class="calibre6 pcalibre pcalibre1"/>Learning about the different live coding tests</h2>
			<p class="calibre3">Unlike the other<a id="_idIndexMarker987" class="calibre6 pcalibre pcalibre1"/> interview stages, the live coding interview usually has different shapes and forms that dramatically affect how the whole interview feels and looks.</p>
			<p class="calibre3">There are three types of live coding interviews – whiteboard, online, and in-person. We call them live coding here, but each provides different experiences and challenges. Let’s start with the whiteboard interview.</p>
			<h3 class="calibre9">The whiteboard intervi<a id="_idTextAnchor387" class="calibre6 pcalibre pcalibre1"/>ew</h3>
			<p class="calibre3">If I recall<a id="_idIndexMarker988" class="calibre6 pcalibre pcalibre1"/> correctly, this is the third time we’re <a id="_idIndexMarker989" class="calibre6 pcalibre pcalibre1"/>mentioning the importance of the whiteboard. The first time was in <a href="B18653_02.xhtml#_idTextAnchor041" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 2</em></a>, when we discussed preparing for the interview process (in the <em class="italic">Getting ready for the screening interview</em> section). The second time was in <a href="B18653_12.xhtml#_idTextAnchor360" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 12</em></a> (in the <em class="italic">The architecture design interview</em> section) when we discussed the architecture interview, and now, we’re mentioning it in approaching the live coding stage.</p>
			<p class="calibre3">Why is the whiteboard such an essential tool in interviews? What makes interviewers highly value the whiteboard, and how can we maximize it for our benefit?</p>
			<p class="calibre3">Well, the whiteboard has one significant advantage – it promotes clarity and communication between people and allows us to visualize our thinking when explaining an idea. That’s the reason why most meeting rooms include a whiteboard.</p>
			<p class="calibre3">Now, as candidates, it is sometimes difficult to use the whiteboard if we are not used to it. And the fact that we’re standing there struggling with a coding question doesn’t help that situation either.</p>
			<p class="calibre3">But it can also be a good tool for communicating with our interviewer, as we did in the previous chapter.</p>
			<p class="calibre3">If you think that communication is not a big deal in interviews, let’s get into the online interview, and you’ll<a id="_idIndexMarker990" class="calibre6 pcalibre pcalibre1"/> understand why it is critical.</p>
			<h3 class="calibre9">The online interview</h3>
			<p class="calibre3">The online <a id="_idIndexMarker991" class="calibre6 pcalibre pcalibre1"/>interview is a session that<a id="_idIndexMarker992" class="calibre6 pcalibre pcalibre1"/> takes place<a id="_idIndexMarker993" class="calibre6 pcalibre pcalibre1"/> via a <strong class="bold">video conference</strong> using a platform such as Zoom, FaceTime, or Google Meet.</p>
			<p class="calibre3">You might think the online interview’s significant advantage would be using an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>). But in most cases, the session happens on a<a id="_idIndexMarker994" class="calibre6 pcalibre pcalibre1"/> dedicated website without indentation, code completion, or syntax highlighting.</p>
			<p class="calibre3">In addition, the online coding interview has another drawback that we didn’t have in the whiteboard interview: communication.</p>
			<p class="calibre3">I have observed, on multiple occasions, that interaction with the interviewer plays a vital role in the success of an interview. It is undeniable that communication is more challenging in online sessions compared to in-person <a id="_idTextAnchor388" class="calibre6 pcalibre pcalibre1"/>meetings.</p>
			<p class="calibre3">However, complaining is not the path to success.</p>
			<p class="calibre3">We need to look for other advantages of an online coding session. For example, the fact that we are coding on a computer allows us to edit and push rows down if needed. Whiteboard editing is much more difficult and forces us to plan what we are going to write.</p>
			<p class="calibre3">Furthermore, scheduling and preparing for an online coding interview is comparatively more straightforward. Remote meetings and using computers are likely within our comfort zone, as the Covid-19 era has taught us how to navigate these aspects effectively.</p>
			<h3 class="calibre9">Combining both worlds – the in-person coding interview</h3>
			<p class="calibre3">The “in-person” coding <a id="_idIndexMarker995" class="calibre6 pcalibre pcalibre1"/>interview<a id="_idIndexMarker996" class="calibre6 pcalibre pcalibre1"/> takes place on a laptop in front of our interviewer. This is a unique approach compared to the previous two methods (whiteboard and remote), and there’s an excellent reason for that. The in-person coding interview has an advantage in terms of personal interaction. Still, this advantage is often not strong enough when considering the logistical efforts that come with it.</p>
			<p class="calibre3">Therefore, the whiteboard coding interview is preferable when discussing in-person sessions.</p>
			<p class="calibre3">Having said that, the in-person coding interview usually happens in companies that wish to see us coding in a natural working environment. In some instances, the interviewer accompanies us while we code, while in other cases, we are given privacy to code in a room on our own, with the interviewer checking in periodically to assess our progress. Both cases can be stressful for developers, having to code while someone is watching them. But sometimes, that’s part of the test – to see how we perform complex tasks under slight pressure.</p>
			<p class="calibre3">All three ways (whiteboard, in-person, and remote coding) are common, and all of them can be<a id="_idIndexMarker997" class="calibre6 pcalibre pcalibre1"/> stressful experiences. The best <a id="_idIndexMarker998" class="calibre6 pcalibre pcalibre1"/>way to decrease the pressure level is to practice and be prepared for this challenge.</p>
			<h2 id="_idParaDest-257" class="calibre7"><a id="_idTextAnchor389" class="calibre6 pcalibre pcalibre1"/>Preparing ourselves for the coding interview</h2>
			<p class="calibre3">I know you might <a id="_idIndexMarker999" class="calibre6 pcalibre pcalibre1"/>be thinking that the fact that we are veteran developers means that we are ready for a coding interview since coding is what we do almost every day. But you can’t be more wrong on that – the coding interview requires new skills and techniques to pass it successfully.</p>
			<p class="calibre3">We have already reviewed the different coding test types – whiteboard, in-person, and remote. We will see that some skills need to be sharpened to pass these tests. We’ll start with the first and primary one – writing code in a plain text editor.</p>
			<h3 class="calibre9">Working with a plain text editor</h3>
			<p class="calibre3">In most coding <a id="_idIndexMarker1000" class="calibre6 pcalibre pcalibre1"/>interviews, we will work <a id="_idIndexMarker1001" class="calibre6 pcalibre pcalibre1"/>with a <strong class="bold">plain text editor</strong>. A whiteboard, for that matter, is a plain text editor.</p>
			<p class="calibre3">A plain text editor lacks syntax highlighting, indentation, and code completion, creating an unfamiliar environment for us.</p>
			<p class="calibre3">It might be easy to declare a function without any problems in a plain text editor, as you can see in the following code:</p>
			<pre class="source-code">
func foo() { print("foo") }</pre>			<p class="calibre3">But that’s the easy part! Let’s see what the challenges are and how we deal with them.</p>
			<h4 class="calibre16">Spotting syntax errors</h4>
			<p class="calibre3">Syntax highlighting<a id="_idIndexMarker1002" class="calibre6 pcalibre pcalibre1"/> helps us spot keywords and expressions, but it also helps us find syntax errors, such as missing parentheses, brackets, or semicolons. In a text editor, there’s a best practice of typing both open and closed brackets or parentheses and only then writing the expression inside.</p>
			<p class="calibre3">However, on a whiteboard, we can’t use that technique. One option is to <em class="italic">highlight delimiters</em> ourselves and write them in a different color. Sure, doing that can slow us down, but it will make our code much clearer and more aesthetic. Another option is to <em class="italic">draw the delimiter bigger</em>, which is another way of highlight<a id="_idTextAnchor390" class="calibre6 pcalibre pcalibre1"/>ing.</p>
			<h4 class="calibre16">Avoiding typos</h4>
			<p class="calibre3">While syntax is just <a id="_idIndexMarker1003" class="calibre6 pcalibre pcalibre1"/>one aspect of an IDE, code completion is another crucial feature. We are used to writing extended descriptive functions and variable names, relying on the code editor to handle them through code completion. However, that’s not the case with a plain text editor. Without code completion, typos can break our code. Although typos can be more acceptable in whiteboard coding interviews than in in-person or remote interviews, they still look bad and unprofessional.</p>
			<p class="calibre3">A way to help us avoid typos is to use clear and short names for functions and variables. That can speed up the coding and help us organize our writing on the whiteboard.</p>
			<h4 class="calibre16">Mastering complex Swift expressions</h4>
			<p class="calibre3">I mentioned earlier <a id="_idIndexMarker1004" class="calibre6 pcalibre pcalibre1"/>how simple it is to declare a function in Swift. But Swift is much more than functions and variables declarations. So, to master Swift, we need to have complete knowledge of more complex expressions and functions, such as the following:</p>
			<ul class="calibre10">
				<li class="calibre11">Collections functions – <strong class="source-inline1">filter</strong>, <strong class="source-inline1">map</strong>, and <strong class="source-inline1">reduce</strong></li>
				<li class="calibre11">Closures</li>
				<li class="calibre11">Advanced type system features – generics and protocols</li>
				<li class="calibre11">Tuples and enums</li>
			</ul>
			<p class="calibre3">This list contains features prone to mistakes, and when I say mistakes, I don’t mean just cosmetic ones. The closure format, for example, has critical components that directly affect our code<a id="_idIndexMarker1005" class="calibre6 pcalibre pcalibre1"/> flow. The same goes for generics and protocols.</p>
			<p class="calibre3">We should practice Swift’s complex expressions and ensure we master them.</p>
			<h4 class="calibre16">Maintaining code organization</h4>
			<p class="calibre3">Code organization<a id="_idIndexMarker1006" class="calibre6 pcalibre pcalibre1"/> is a critical topic because it’s a real challenge when working with a plain editor. As you know, a plain editor doesn’t have indentation, which usually helps us to create a readable and organized code. Remember closures and filtering? Trying to read these Swift features without indentation is complex, and code readability affects ou<a id="_idTextAnchor391" class="calibre6 pcalibre pcalibre1"/>r chances of success.</p>
			<p class="calibre3">Indentation becomes even more critical when coding on a whiteboard. On a laptop, at least, we can use tabs, something that doesn’t exist on whiteboards.</p>
			<p class="calibre3">We understand now that many of the challenges we face in plain text editor coding become even more prominent on a whiteboard. Don’t worry! There’s still time to manage that.</p>
			<h3 class="calibre9">Practicing on a whiteboard</h3>
			<p class="calibre3">For most of us, coding <a id="_idIndexMarker1007" class="calibre6 pcalibre pcalibre1"/>on a whiteboard is not natural. Consider developers who have spent nearly 10,000 hours coding in front of a computer; the transition to coding on a whiteboard can be challenging.</p>
			<p class="calibre3">When it comes to coding on a whiteboard as opposed to a laptop, there are several challenges that we should bear in mind. For example, whiteboards don’t have scroll capabilities, it is much more difficult to edit or insert new rows, there are no straight lines or font sizes, and our canvas is just one big white surface without a grid.</p>
			<p class="calibre3">Having said that, some tips can help us improve our whiteboarding skills. Let’s go over them:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Visualize our code structure</em>: As I said, whiteboards<a id="_idIndexMarker1008" class="calibre6 pcalibre pcalibre1"/> don’t have any built-in scrolling mechanism, and their coding area is fixed. Therefore, before coding on a whiteboard, we should visualize our answer structure. Notice I wrote <em class="italic">answer</em> and not <em class="italic">code</em>. The reason for that is that our answer is much more than just the function we were supposed to implement – there are tests, diagrams, and perhaps even notes we need to consider. We should divide the whiteboard into zones and allocate space for each answer’s component. Of course, the same goes for the coding area itself – try to imagine how long your answer will be and choose your font size accordingly. Look <a id="_idIndexMarker1009" class="calibre6 pcalibre pcalibre1"/>at <em class="italic">Figure 13</em><em class="italic">.1</em>:</li>
			</ul>
			<div><div><img src="img/Figure_13.01_B18653.jpg" alt="Figure 13.1 – Dividing the whiteboard into spaces" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Dividing the whiteboard into spaces</p>
			<p class="calibre3"><em class="italic">Figure 13</em><em class="italic">.1</em> shows<a id="_idIndexMarker1010" class="calibre6 pcalibre pcalibre1"/> how we set a different space for each part of our answer. Organizing your whiteboard is the key to presenting a clear answer.</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Use diagrams</em>: We talked about allocating a specific space for diagrams. However, diagrams are not a limitation of whiteboards at all – drawing diagrams is a significant advantage we don’t have on a laptop, especially when working remotely. Diagrams let us visualize our algorithms, ideas, and thoughts and communicate them to our interviewer much better. When practicing coding questions, we should try to illustrate our thinking and answers. The best way to learn how to do that is to watch videos on the internet that explain how to solve different algorithms and focus on the visual part. We should know how to describe flows, arrays, trees, and database schemes on a whiteb<a id="_idTextAnchor392" class="calibre6 pcalibre pcalibre1"/>oard.</li>
				<li class="calibre11"><em class="italic">Practice out loud</em>: A common challenge many developers face is solving a coding question on a whiteboard while effectively explaining it. Why? Because most developers are not used to writing code down on a whiteboard and then explaining it at the same time. We shouldn’t just practice writing on a whiteboard – we should also practice presenting our solutions while thinking out loud, whether to<a id="_idIndexMarker1011" class="calibre6 pcalibre pcalibre1"/> ourselves or others.</li>
			</ul>
			<p class="calibre3">Few developers have good whiteboard drawing skills, but practicing is an effective way to improve <a id="_idIndexMarker1012" class="calibre6 pcalibre pcalibre1"/>dramatically. These small tips can raise the bar and provide us with more skills.</p>
			<p class="calibre3">Now, let’s move on to the actual coding. How do we start?</p>
			<h2 id="_idParaDest-258" class="calibre7"><a id="_idTextAnchor393" class="calibre6 pcalibre pcalibre1"/>Starting to code</h2>
			<p class="calibre3">Now that we understand<a id="_idIndexMarker1013" class="calibre6 pcalibre pcalibre1"/> the different interview options, we can start with the real fun – coding. Can you guess what tip I have when facing a coding question unrelated to iOS, Swift, or coding<a id="_idTextAnchor394" class="calibre6 pcalibre pcalibre1"/> in general?</p>
			<h3 class="calibre9">Take your time</h3>
			<p class="calibre3">We first need to relax, step back, and analyze our task. It is a common mistake to start coding immediately even if we (think that we) already know the answer.</p>
			<p class="calibre3">First, sure, you might know the answer or at least know how to approach the question. But take one or two minutes to rethink what you will do. Maybe find a more effective way to solve the question or a more engaging way to present the answer. If you have the time, why not use it?</p>
			<p class="calibre3">Furthermore, taking your time is not a bad sign for the interviewer. The opposite is the truth. The fact that you are not rushing to code is a sign that you are thinking before you act and want to focus o<a id="_idTextAnchor395" class="calibre6 pcalibre pcalibre1"/>n planning and researching. In the previous chapter, we said interviewers are searching for soft skills during the architecture interview. However, soft skills are tested everywhere, including in the coding interview. Planning and critical thinking, essential soft skills, are also evaluated during the interview process.</p>
			<h3 class="calibre9">Start with testing</h3>
			<p class="calibre3">Are we doing <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>)? Well, not exactly. One of the most noticeable differences <a id="_idIndexMarker1014" class="calibre6 pcalibre pcalibre1"/>between the coding and the architecture interview is that in the coding interview, we must understand all our constraints and guidelines from the beginning. We can’t discover them as the interview proceeds.</p>
			<p class="calibre3">In coding interviews, the session begins when we ask our interviewer for all the necessary information to accomplish our task.</p>
			<p class="calibre3">But how do we know what to ask?</p>
			<p class="calibre3">The best way is to <em class="italic">write down the tests for the function</em> we will code.</p>
			<p class="calibre3">Look at the following<a id="_idIndexMarker1015" class="calibre6 pcalibre pcalibre1"/> coding question:</p>
			<p class="author-quote">Write a function in Swift that takes an array of integers as input and returns the maximum difference between any two elements in the array. The maximum difference should be calculated by subtracting the smallest element from the largest element.</p>
			<p class="calibre3">Now, let’s write down our test cases:</p>
			<pre class="source-code">
Input: [1, 2, 3, 4, 5] | Expected Output: 4Input: [7, 2, 9, 5, 1] | Expected Output: 8
Input: [10, 3, 5, 2, 8] | Expected Output: 8
Input: [6, 5] | Expected Output: 1
Input: [6] | Expected Output: 0
Input: [] | Expected Output: 0
Input: [-10, -5] | Expected Output: -5</pre>
			<p class="calibre3">These test cases are crucial for us to provide a good answer. First, they answer all our questions – what if we have negative numbers? What if the input has one element or no elements at all?</p>
			<p class="calibre3">Not only can the test cases lead us to the algorithm we need to write, but they also behave as a checklist throughout the session. If we want to ensure we’ve finished our coding and covered all our cases, we can review the list and check our code.</p>
			<h3 class="calibre9">Start strong – don’t be afraid of brute force</h3>
			<p class="calibre3">One thing that rings in our heads during interviews is that we need to provide an optimized solution in terms of space and time complexity.</p>
			<p class="calibre3">And this is true – providing an efficient solution is one of the things we are tested on. But, as a starting point, we need to focus on accomplishing the task and only then optimize it. In other words, we should<a id="_idIndexMarker1016" class="calibre6 pcalibre pcalibre1"/> start with <strong class="bold">brute force</strong>.</p>
			<p class="callout-heading">What is brute force?</p>
			<p class="callout">The term <em class="italic">brute force</em> refers to a straightforward approach to solving a problem involving basic algorithms without thinking of optimizations and efficiency. Brute-force solutions are impractical in real-world scenarios due to their high space and time complexity.</p>
			<p class="calibre3">If brute force is not practical in real-life scenarios, why have I suggested starting with it?</p>
			<p class="calibre3">When we receive a task <a id="_idIndexMarker1017" class="calibre6 pcalibre pcalibre1"/>to do, we first want to provide a working solution. A working solution proves that we understand the problem and is a great starting point for optimization. We can start measuring the time and space complexity a<a id="_idTextAnchor396" class="calibre6 pcalibre pcalibre1"/>nd perform incremental updates.</p>
			<p class="calibre3">In other words, brute force is an anchor for further changes we want to make, providing us the flexibility to revert and find an alternate path if something goes wr<a id="_idTextAnchor397" class="calibre6 pcalibre pcalibre1"/>ong.</p>
			<p class="calibre3">Let’s go over an example:</p>
			<p class="author-quote">Find the maximum sum of a subarray within an array of integers.</p>
			<p class="calibre3">The brute-force solution would be to iterate an array with two nested loops while<a id="_idTextAnchor398" class="calibre6 pcalibre pcalibre1"/> maintaining a <code>maxSum</code> variable:</p>
			<pre class="source-code">
func maxSubarraySum(_ nums: [Int]) -&gt; Int {    var maxSum = Int.min
    for i in 0..&lt;nums.count {
        var currentSum = 0
        for j in i..&lt;nums.count {
            currentSum += nums[j]
            maxSum = max(maxSum, currentSum)
        }
    }
    return maxSum
}</pre>
			<p class="calibre3">In the first loop, we iterate all the elements in the array, and for each iteration, we create another loop that starts from the current element until the end of the same array. In this approach, we cover all the different subarray combinations and try to find the maximum sum by using the <code>maxSum</code> array.</p>
			<p class="calibre3">This solution works! But we understand that using nested arrays makes our algorithm inefficient with a time complexity of O(n^2).</p>
			<p class="calibre3">So, how can we improve it?</p>
			<p class="calibre3">We said a <a id="_idIndexMarker1018" class="calibre6 pcalibre pcalibre1"/>brute-force<a id="_idIndexMarker1019" class="calibre6 pcalibre pcalibre1"/> solution is a great starting point for optimization. Having two nested loops should raise a concern – we understand that our time complexity is too high. Usually, the trade-off for time is space. In this case, we can have one array iteration and preserve the current sum in a specific variable.</p>
			<p class="calibre3">Let’s see an optimized version of the code:</p>
			<pre class="source-code">
func maxSubarraySum(_ nums: [Int]) -&gt; Int {    var maxSum = nums[0]
    var currentSum = nums[0]
    for i in 1..&lt;nums.count {
        currentSum = max(nums[i], currentSum + nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}</pre>
			<p class="calibre3">The preceding algorithm is<a id="_idIndexMarker1020" class="calibre6 pcalibre pcalibre1"/> called <strong class="bold">Kadane’s algorithm</strong>, and it is an efficient way to solve that problem. In Kadane’s algorithm, we calculate the maximum subarray that ends in a specific index using the previous index’s subarray calculation.</p>
			<p class="calibre3">Confused? Let’s test it on a random array:</p>
			<pre class="source-code">
[2, -3, 5, -<a id="_idTextAnchor399" class="pcalibre pcalibre1 calibre17"/>1, 6]Iteration 1: currentSum = 2, maxSum = 2
Iteration 2: currentSum = -1, maxSum = 2
Iteration 3: currentSum = 5, maxSum = 5
Iteration 4: currentSum = 4, maxSum = 5
Iteration 5: currentSum = 10, maxSum = 10</pre>
			<p class="calibre3">Kadane’s algorithm is a clever algorithm that provides an efficient and straightforward solution to a complex problem. You would not be expected to be able to use this algorithm if you haven’t<a id="_idIndexMarker1021" class="calibre6 pcalibre pcalibre1"/> come across it before. But the point here is that we have<a id="_idIndexMarker1022" class="calibre6 pcalibre pcalibre1"/> two versions for our answer, and unless the optimal solution pops into our mind, we should start with the brute-force method and then continue solving the problem.</p>
			<h2 id="_idParaDest-259" class="calibre7"><a id="_idTextAnchor400" class="calibre6 pcalibre pcalibre1"/>Coding like a pro</h2>
			<p class="calibre3">So, how do we code<a id="_idIndexMarker1023" class="calibre6 pcalibre pcalibre1"/> like a pro? We already know that our chances to succeed in the coding interview have much to do with how much we practice and solve algorithm problems at home. But practicing is only part of the solution. There are some key factors that we should follow during the session.</p>
			<p class="calibre3">Let’s start with two critical key factors – time and space complexities.</p>
			<h3 class="calibre9">Use the terms “time complexity” and “space complexity”</h3>
			<p class="calibre3">We’ve mentioned time <a id="_idIndexMarker1024" class="calibre6 pcalibre pcalibre1"/>and space complexities in this chapter several times for a good reason. We know that effective communication with the interviewer is essential, and it should be done with proper terms.</p>
			<p class="calibre3">After we finish the brute-force solution (as soon as possible), we need to optimize it and use the correct terms. This is so important because time and space complexities are objective ways to evaluate our code’s efficiency.</p>
			<p class="calibre3">For example, saying something such as “<em class="italic">It’s not efficient to have a nested loop</em>” is not a professional way of describing an algorithm. The proper way would be, “<em class="italic">This algorithm has a time complexity of O(N^2), but I think we can improve it </em><em class="italic">to O(N)</em>.”</p>
			<p class="calibre3">So, what is time complexity? The following information box provides a definition.</p>
			<p class="callout-heading">What is time complexity?</p>
			<p class="callout">Time complexity <a id="_idIndexMarker1025" class="calibre6 pcalibre pcalibre1"/>refers to the time an algorithm requires to run as the input size grows. We describe the input size as <strong class="source-inline1">N</strong> and express the complexity with big-O notation.</p>
			<p class="calibre3">There are several use<a id="_idIndexMarker1026" class="calibre6 pcalibre pcalibre1"/> cases for time complexity:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Constant time complexity, “O(1)”</em>: Accessing a specific index in an array or performing basic arithmetic operations</li>
				<li class="calibre11"><em class="italic">Linear time complexity, “O(n)”</em>: Iterating an array or a linked list with the size of <strong class="source-inline1">n</strong></li>
				<li class="calibre11"><em class="italic">Quadratic time complexity, “O(n^2)”</em>: Using nested loops or bubble sort</li>
				<li class="calibre11"><em class="italic">Logarithmic time complexity, “O(log n)”</em>: Binary search</li>
			</ul>
			<p class="calibre3">I don’t want to get into too many details about time and space complexity, but there are two things to keep in mind when discussing complexity in an interview:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Complexity calculation</em>: This is a topic we should address before starting the interview, and it’s broader than we think. First, we should count the different operations in our code and define each’s complexity. Then, we need to sum it up and, in the end, determine the complexity of different inputs – best, worst, and average cases.</li>
				<li class="calibre11"><em class="italic">Understand logarithmic time complexity</em>: Most of the use cases I mentioned earlier are straightforward, but O(log n) is the one that confuses many developers. This complexity describes an algorithm whose runtime grows nonlinearly (<strong class="bold">logarithmically</strong>) with<a id="_idIndexMarker1027" class="calibre6 pcalibre pcalibre1"/> the input size. The increase is slower than O(n) and O(n^2), making it more efficient.</li>
			</ul>
			<p class="calibre3">Let’s have a look at the following <code>findElement</code> function and try to calculate its time complexity:</p>
			<pre class="source-code">
func findElement(_ array: [Int], target: Int) -&gt; Bool {    for element in array {
        if element == target {
            return true
        }
    }
    return false
}</pre>
			<p class="calibre3">The algorithm is <a id="_idIndexMarker1028" class="calibre6 pcalibre pcalibre1"/>simple – we iterate in an array and check each element to see whether it’s equal to the target function parameter. If we find an element with the same value, we return <code>true</code>. Otherwise, we return <code>false</code>.</p>
			<p class="calibre3">To calculate the function time complexity, we need to list our operations and describe their complexity individually. We have a <code>for</code> loop with a time complexity of O(n) and an <code>if</code> statement with a time complexity of O(1).</p>
			<p class="calibre3">In this case, the overall time complexity of the function is O(n), and it is determined by the linear dominant operation.</p>
			<p class="calibre3">And what <a id="_idIndexMarker1029" class="calibre6 pcalibre pcalibre1"/>about <strong class="bold">space complexity</strong>?</p>
			<p class="callout-heading">What is space complexity?</p>
			<p class="callout">Space complexity<a id="_idIndexMarker1030" class="calibre6 pcalibre pcalibre1"/> refers to the memory or storage an algorithm requires to run as the input size grows. We describe the input size as <strong class="source-inline1">N</strong> and express the complexity with big-O notation.</p>
			<p class="calibre3">Space complexity is usually the trade-off of time complexity. When we optimize an algorithm, we need to consider the balance between the amount of memory it consumes and the time taken to execute the algorithm.</p>
			<p class="calibre3">We measure space complexity in a similar way as we do for time complexity. For instance, let’s look at the following code:</p>
			<pre class="source-code">
func printNumbers(n: Int) {    var numbers = [Int]()  // Array to store numbers
    for i in 1...n {
        numbers.append(i)  // Adding numbers to the array
    }
    for number in numbers {
        print(number)  // Printing each number
    }
}</pre>
			<p class="calibre3">The <code>printNumbers()</code> function<a id="_idIndexMarker1031" class="calibre6 pcalibre pcalibre1"/> takes <code>n</code> as input and creates an array to store the numbers from 1 to <code>n</code>. The space complexity of this function is O(n) as the size of the numbers grows linearly with the input <code>n</code>.</p>
			<p class="calibre3">The main goal of using time and space complexities is to not only communicate with the interviewer professionally, but also to be able to evaluate our solutions so we can provide <a id="_idTextAnchor401" class="calibre6 pcalibre pcalibre1"/>an optimized answer.</p>
			<h3 class="calibre9">Come with a set of tools</h3>
			<p class="calibre3">Never enter a combat field without a weapon or ammo – the same goes for a coding interview and a suitable set of tools. Every interview question or challenge can be addressed if we come prepared with a list of techniques to help us.</p>
			<p class="calibre3">For example, we can have a complex question about linked lists. To solve that question, we must master the basics of a linked list – how to traverse a list, remove/add an element, or convert a list into an array and vice versa. We should know how to do these things before we come to the interview.</p>
			<p class="calibre3">Knowing the basic data structures well can help us focus on the real challenge, which is the algorithm itself. In the previous chapter, we discussed app architectures and said that design patterns are the building blocks of architecture. Here, we also have building blocks. We start with data structures, then go over the fundamental design patterns that manipulate these data structures, and then the algorithms that are based upon these patterns.</p>
			<h3 class="calibre9">Leave time for testing</h3>
			<p class="calibre3">Not testing is a common<a id="_idIndexMarker1032" class="calibre6 pcalibre pcalibre1"/> mistake many candidates make in coding interviews. When we discussed how to start the coding interview, we discussed testing as a key to understanding the problem. Eventually, the coding interview evolves around the tests – they are the key to understanding the problem, but they are also our checklist that ensures our answers fulfill the interviewer’s requirements.</p>
			<p class="calibre3">But it’s not just leaving time for testing – presume that your tests will fail and you’ll have to fix them, so you’ll also need to leave time to fix bugs, similar to a real-world deployment process.</p>
			<p class="calibre3">In this book, I’ve aimed to guide you through solving complex interview challenges by accompanying you every step of the way. The architecture interview (discussed in <a href="B18653_12.xhtml#_idTextAnchor360" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 12</em></a>) and the coding interview are separate interviews that target your development skills <a id="_idIndexMarker1033" class="calibre6 pcalibre pcalibre1"/>from different angles. The home assessment is the interview that combines most of your skills.</p>
			<h1 id="_idParaDest-260" class="calibre5"><a id="_idTextAnchor402" class="calibre6 pcalibre pcalibre1"/>Excelling in a home assessment</h1>
			<p class="calibre3">A <strong class="bold">home assessment</strong> is a common<a id="_idIndexMarker1034" class="calibre6 pcalibre pcalibre1"/> interview task many companies use to check a candidate’s skills in dealing with a real-world problem. Home assessments require us to plan, architect, code, test, and deploy, sometimes with unfamiliar iOS topics<a id="_idIndexMarker1035" class="calibre6 pcalibre pcalibre1"/> we have no experience with.</p>
			<p class="calibre3">Let’s start with analyzing what a home assessment is.</p>
			<h2 id="_idParaDest-261" class="calibre7"><a id="_idTextAnchor403" class="calibre6 pcalibre pcalibre1"/>What does a home assessment look like?</h2>
			<p class="calibre3">The framework for a regular <a id="_idIndexMarker1036" class="calibre6 pcalibre pcalibre1"/>home assessment won’t come to you as a surprise. However, it is still worth going over it so we can be aligned on the process:</p>
			<ol class="calibre15">
				<li class="calibre11"><em class="italic">Assignment</em>: This is the initial phase where we receive the task, including the requirements and instructions.</li>
				<li class="calibre11"><em class="italic">Understanding</em>: In this stage, we carefully read the instructions and analyze the requirements. This is also the phase where we ask the interviewer anything we are unclear about and clarify what we must do.</li>
				<li class="calibre11"><em class="italic">Execution</em>: This is the current assignment implementation, which typically takes place remotely. However, there are instances where it may be carried out at the hiring company’s office. This step involves planning and writing our task, and if carried out at home, the execution phase may span several days.</li>
				<li class="calibre11"><em class="italic">Testing</em>: Once the implementation is complete, we test our solution. That includes running test cases and addressing bugs and issues.</li>
				<li class="calibre11"><em class="italic">Submission</em>: After the testing, we must submit the assignment to the interviewer. In most cases, the submission is done using Git for convenience.</li>
				<li class="calibre11"><em class="italic">Post-delivery discussion</em>: In many companies, the interview is followed by a discussion or another interview where the interviewer will review the assessment with you to understand the different decisions and approaches taken while doing the home assessment.</li>
			</ol>
			<p class="calibre3">The exact structure may vary between companies and assessments, but this framework provides an understanding of the significant steps involved in the process.</p>
			<p class="calibre3">Now that we know what a home assessment looks like, let’s understand why companies choose<a id="_idTextAnchor404" class="calibre6 pcalibre pcalibre1"/> to spend their and our time on this type of task.</p>
			<h2 id="_idParaDest-262" class="calibre7"><a id="_idTextAnchor405" class="calibre6 pcalibre pcalibre1"/>The different skills being tested in a home assessment</h2>
			<p class="calibre3">The home <a id="_idIndexMarker1037" class="calibre6 pcalibre pcalibre1"/>assessment examines some skills that are hard to test in the other interview stages, primarily the ability to develop an end-to-end app.</p>
			<p class="calibre3">The skills required for a home assessment are both soft and hard, representing what is needed from an iOS developer in real-world situations.</p>
			<p class="calibre3">Most of the skills are what we’ve discussed in previous chapters, but let’s list them here so we can be aligned<a id="_idTextAnchor406" class="calibre6 pcalibre pcalibre1"/> on what the interviewer expects from us:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Technical proficiency</em>: We are being tested for our technical skills – Swift, frameworks, Xcode, and other tools are all part of the skills we need to master as part of the test.</li>
				<li class="calibre11"><em class="italic">Problem solving</em>: Home assessments check our ability to solve problems and break them into smaller, more manageable steps while using our experience and creativity. Architecture and app design are part of those skills, which are crucial in these kinds of tests.</li>
				<li class="calibre11"><em class="italic">Algorithm design:</em> This may not be as superior a skill as the coding test, but it is part of the home assessment. Notice that we have a project, probably a tiny app, to develop. Being able to choose suitable data structures and write efficient algorithms may be required to solve complex problems and demonstrate our knowledge.</li>
				<li class="calibre11"><em class="italic">Attention to detail</em>: Unlike the other interview steps, in the home assessment, we have time. How much time? Enough to<a id="_idTextAnchor407" class="calibre6 pcalibre pcalibre1"/> provide a good, accurate, and error-free solution. So, you see, more time means more expectations of us, and we are tested on being able to handle edge cases and complete code.</li>
				<li class="calibre11"><em class="italic">Code quality</em>: Our approach to the home assessment needs to resemble a complete project in terms of code quality. It means we need to document our code using comments, perform testing and QA, choose proper naming conventions, and have an organized file structure. Yes, I know it’s a <em class="italic">small</em> project for an interview. But here’s a secret – at this stage, the interviewer already knows we can build a table view and set up a Singleton. The quality of the implementation is what is important.</li>
				<li class="calibre11"><em class="italic">Independence</em>: One of the best things about home assessments is that they allow us to showcase our ability to fulfill a task from end to end, including project setup, coding, testing, and deployment, while being observed.</li>
			</ul>
			<p class="calibre3">Having said that, the different skills required depend on the specific role and the company we are interviewing for. At this stage, we should already know what the company culture <a id="_idIndexMarker1038" class="calibre6 pcalibre pcalibre1"/>is and what is expected from us.</p>
			<p class="calibre3">Now, let’s go over some common examples of projects you may encounter in a home assessment.</p>
			<h2 id="_idParaDest-263" class="calibre7"><a id="_idTextAnchor408" class="calibre6 pcalibre pcalibre1"/>Going over examples</h2>
			<p class="calibre3">Before moving on, a<a id="_idIndexMarker1039" class="calibre6 pcalibre pcalibre1"/> quick note on how to read these examples. You probably won’t encounter one of these examples in an interview, and that’s perfectly fine because that is not my intention. The goal of providing these examples is to strengthen your skills and make you prepared for the unknown. Unlike iOS interview questions, where knowledge matters, a home assessment concerns skills and techniques. That’s why I’m trying to emphasize the list of skills and the home assessment process.</p>
			<p class="calibre3">Each example can teach us a different aspect of the home assessment, and the ability to quickly build a small app with a short explanation is crucial for that task.</p>
			<p class="calibre3">Let’s go over the examples and pay attention to what’s essential:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Build a to-do list app</em>: A home assessment focuses on table views, local data storage, and state management. Also, typical to-do apps usually support offline work and provide a streamlined user experience.</li>
				<li class="calibre11"><em class="italic">Build a weather app with an engaging user interface and reactive API updates</em>: It’s important to integrate Combine frameworks in this kind of app to provide updated information to the user in an elegant design pattern.</li>
				<li class="calibre11"><em class="italic">Build a photo gallery app</em>: Photo gallery apps require close work with <strong class="bold">PhotoKit</strong> (the iOS SDK’s<a id="_idIndexMarker1040" class="calibre6 pcalibre pcalibre1"/> photos framework), working with a collection view while optimizing it for fast loading and caching. Also, memory management capabilities are essential to handle large amounts of data.</li>
				<li class="calibre11"><em class="italic">Create a social media feed</em>: A social media feed usually works with a table view combined with a pagination pattern. It is vital to provide efficient memory management, user interactions such as likes and comments, and image loading as part of the feed.</li>
				<li class="calibre11"><em class="italic">Build a calendar app</em>: A calendar app requires managing an events list with tight integration<a id="_idIndexMarker1041" class="calibre6 pcalibre pcalibre1"/> to the <strong class="bold">EventKit</strong> framework (Apple’s framework that helps us connect to the calendar), including a table view with a pagination design pattern.</li>
			</ul>
			<p class="calibre3">Each of these assessments requires us to face different challenges, implement various design patterns, and tweak the architecture to create an organized project. It’s a great mental exercise for your brain, trying to think about the different solutions and architectures, and is something that can improve your chances of succeeding in the test.</p>
			<p class="calibre3">Even though our<a id="_idIndexMarker1042" class="calibre6 pcalibre pcalibre1"/> code results are extremely important, it is important to understand that our interviewer is looking at additional aspects of our work – red flags.</p>
			<h1 id="_idParaDest-264" class="calibre5"><a id="_idTextAnchor409" class="calibre6 pcalibre pcalibre1"/>Avoiding red flags</h1>
			<p class="calibre3">Now that we<a id="_idIndexMarker1043" class="calibre6 pcalibre pcalibre1"/> understand what live coding interviews and home assessments are, let’s briefly discuss perfection. Do we have to provide a perfect solution to pass the interview? What is the interviewer looking for?</p>
			<p class="calibre3">That’s not an easy question as it may differ for various interviewers and companies.</p>
			<p class="calibre3">But there’s something that all interviewers will look out for: red flags. The fact that we didn’t provide an optimized solution or didn’t know a particular Swift feature can be accepted by many interviewers – in most cases, they are looking for signals of som<a id="_idTextAnchor410" class="calibre6 pcalibre pcalibre1"/>ething unhealthy in the way we approach, think, and code.</p>
			<p class="calibre3">There are red flags we should avoid, even if they may initially seem insignificant to the interview process. Let’s go over some of them now.</p>
			<h2 id="_idParaDest-265" class="calibre7"><a id="_idTextAnchor411" class="calibre6 pcalibre pcalibre1"/>Inability to explain or defend a solution</h2>
			<p class="calibre3">This is a red flag that incorporates two crucial missing skills. The first one is <em class="italic">deep thinking and code/design understanding</em>. Many developers use their memory to regurgitate solutions without understanding why and how they work. Passing an interview question is not enough; we should also understand why we have done what we have done. Now that we are at the end of the book, it is essential to go back and validate that we fully understand the different answers and solutions.</p>
			<p class="calibre3">The second<a id="_idIndexMarker1044" class="calibre6 pcalibre pcalibre1"/> skill is <em class="italic">communication and the ability to explain</em> ourselves. Sometimes it is hard to find the right words to describe why we made certain decisions, which can be translated into communication skills. But that is what this book is for – to help you verbalize your knowledge and get you ready for the interview.</p>
			<h2 id="_idParaDest-266" class="calibre7"><a id="_idTextAnchor412" class="calibre6 pcalibre pcalibre1"/>Dichotomic thinking</h2>
			<p class="calibre3">Many interview questions, especially the design, architecture, and coding questions, require trade-offs and multiple approaches to be considered. There’s no room for black-and-white thinking without explaining the alternative solutions. We should always be flexible and understand that there is <a id="_idTextAnchor413" class="calibre6 pcalibre pcalibre1"/>not always a single correct answer.</p>
			<h2 id="_idParaDest-267" class="calibre7"><a id="_idTextAnchor414" class="calibre6 pcalibre pcalibre1"/>Limited error handling</h2>
			<p class="calibre3">While it may sound trivial, ignoring error handling can be perceived as a red flag by<a id="_idTextAnchor415" class="calibre6 pcalibre pcalibre1"/> interviewers, indicating a potentially unhealthy approach. Focusing on happy flows suggests a lack of attention to detail and a very shallow level of development. Handling code flows that may produce errors and unexpected results is significant.</p>
			<h2 id="_idParaDest-268" class="calibre7"><a id="_idTextAnchor416" class="calibre6 pcalibre pcalibre1"/>Poor code quality</h2>
			<p class="calibre3">Our code is our artwork, and it should look good and express our expertise and capabilities as developers. But what does this mean? It means we should make structured and organized code with clear naming conventions, including comments and documentation. Try to avoid too short and unclear names and add indentations and spaces to your code.</p>
			<p class="calibre3">Also, good <a id="_idIndexMarker1045" class="calibre6 pcalibre pcalibre1"/>separations, short functions, and folder organization can greatly help with our code appearence and clarity. The basics do matter at this stage.</p>
			<h1 id="_idParaDest-269" class="calibre5"><a id="_idTextAnchor417" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">That’s it! We have reached the finale of the book, and what an e<a id="_idTextAnchor418" class="calibre6 pcalibre pcalibre1"/>xciting journey it has been!</p>
			<p class="calibre3">In this concluding chapter, we delved into live coding, home assessments, and avoiding red flags. We learned how to tackle a whiteboard task, what to focus on when coding, and how to approach this important stage in the process. At this point, you should feel prepared to tackle the most experimental stage of the interview process: the coding assessment.</p>
			<p class="calibre3">While the book may have ended, our journey of practice and hard work is just beginning. The world of iOS development is vast, and there is always more to learn and explore. Each chapter, section, and question has opened the door to numerous topics that can help you improve.</p>
			<p class="calibre3">So, don’t stop now; you’re just getting started. Embrace continuous learning and strive for excellence in your iOS development career.</p>
		</div>
	</body></html>