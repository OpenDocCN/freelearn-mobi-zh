- en: Finishing the Perky Penguin 2D Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter was all about new and beginner developers interested in
    Unity and game development. As this book is focused on game development for the
    Android platform, so the previous chapter, which happens to be the very first
    chapter of the book, introduced the Android platform, its different versions,
    and its marketplace, Google Play. Then the chapter revised the concepts of game
    engines and then brought Unity 3D into light by comparing it with other major
    game engines such as Unreal, Adobe Flash, and Game Maker Studio. The chapter made
    a transition through the very basics of Unity game development, such as introducing
    Unity's interface, its panels, such as the inspector panel, the hierarchy panel,
    and so on. It also introduced the concepts of scene view and game view and how
    they interact with each other and how these views help developers to make it an
    easy and fun experience to create awesome games.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding particle systems to a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefabs and level management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lasers and enemies in a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After providing enough information on the theoretical side of unity game development
    for Android platforms, the previous chapter started practical examples from configuring
    empty game projects which are especially useful for 2D games. Configuring empty
    projects is the very first step in any game and we covered this in [Chapter 1](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml),
    *Introduction to Android Game Development with Unity 3D*, in a very practical
    manner, and we also introduced a 2D game called **Perky Penguin**. The following
    is the screenshot of the game from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 Perky Penguin game
  prefs: []
  type: TYPE_NORMAL
- en: We learned how a player, such as the penguin, is added in Unity and how the
    colliders and physics were applied on the penguin. Unity also supports scripting
    and programming in C# or JavaScript languages to define custom behaviors such
    as making the penguin jump, avoiding gravity while flying, stopping the penguin
    from leaving the screen during gameplay, and so on. The chapter finished by having
    a Perky Penguin game with a penguin jumping in it.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with the 2D concepts of Unity or have created 2D
    games already, then you can skip this chapter and move on to the third dimension.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will finish this Penguin Perky game by learning some other
    advanced concepts of Unity 2D, such as adding particle effects, camera management,
    creating levels, using animations and controllers introduced in Unity 4.x versions,
    and so on. Until now, the Perky Penguin game has a cute penguin that can fly and
    jump on the screen but it can't walk forward and neither can it explore the game
    world. One thing to note here is that how the penguin is flying, whereas in real
    life, penguins don't fly. In our game, the penguin has got its hands on a red
    rocket which gives a boost of fire on the penguin to make it fly for a little
    instant. In the game, this boost is applied by a single tap on the screen of an
    Android device.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start work on our game and bring the game to life
    by adding particle effects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Particle Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into the details of particle systems, let's discuss what exactly
    these systems are and how they are used. Let's start with a discussion of what
    particle systems are.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Particle System?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any 3D complex game, characters, props, and environment elements are mostly
    created as 3D meshes and models, while in 2D games, sprites and images are used
    for these same purposes. Now, whether these objects are meshes or sprites, they
    mostly represent solid objects which contain a well-defined shape. But any game
    contains other entities such as fluids, liquids, smokes, clouds, flames, magic
    balls, and so on. These are some sort of special kinds of animations and objects,
    and are handled also with a special type of properties and behaviors, called particle
    systems in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot below shows some interesting magic spell particle systems created
    in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Different Particle Effects or magic spells created in Unity'
  prefs: []
  type: TYPE_NORMAL
- en: Particles are small and simple images, or even meshes, that are displayed and
    animated in a huge number by a full-fledged system known as a Particle System.
    In any particle system, each small particle contributes a minor role and, overall,
    it looks like some highly polished animation or effect. For example, a snowfall
    effect can be treated as a particle system. A single particle of snow doesn't
    represent any snowfall if it is animated singularly, but if those same single
    snow particles are animated in a huge quantity with random speed, random direction,
    and random size, all these particles will not look like some image animation;
    rather, they will look like a system of snowfall in the game. That's the main
    key power of using a Particle System in Unity--it allows batch operations of heavy
    code in a very light and optimized way, resulting in very beautiful effects for
    games.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of Particle System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, a Particle System consists of all of the particles. Developers are
    only expected to manage the particles and the rest will be handled by Unity. Each
    particle has a predetermined lifetime through various changes, such as fading
    away for any snowfall effect, or getting scaled up and fading for any smoke effect,
    and so on. Like all other physical game objects, these particles have velocity
    to change the speed and direction throughout their lifetime duration, and these
    particles can be affected by forces and gravity applied by the environment's physics
    kinematics.
  prefs: []
  type: TYPE_NORMAL
- en: The developers' end is to manage and control the particle's lifetime and its
    behavior, such as how many seconds will a particle last? How it will grow throughout
    its lifetime duration? Will it scale up or not? Will it fade away throughout its
    lifetime? All these questions are answered by developers and Unity will award
    them an amazing particle system in the form of an effect.
  prefs: []
  type: TYPE_NORMAL
- en: The particles can be as simple as a sphere of white color or can be as complex
    as any mesh with high-resolution texture and normal maps.
  prefs: []
  type: TYPE_NORMAL
- en: The particle system's job is to manage all these particles from an abstract
    view. This system tells when to generate the next particle and where it should
    be, with what position, rotation, and scale. What should be the emission shape
    of the system, for example, hemisphere, code, or simple box? What should be the
    emission rate of the particles and how long should any particle effect take to
    execute one complete cycle of the system?
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rocket fire Particle Effect for a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, after getting to grips with some basic knowledge of particle effects and
    particle systems in Unity, let''s put this knowledge into action by creating the
    first particle system for our Perky Penguin game. As we know, the penguin wears
    a rocket tied to its back which lets it fly and boost when tapped on screen by
    the player. Now, this rocket will create a small fire-like effect when it becomes
    active. The following screenshot shows the rocket with its fire effect of boost
    as the final result of this small particle system exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Rocket''s fire effect final result'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, you can observe how the fire starts from
    the edge of the rocket and how it disappears slowly with a fading effect, similar
    to real life. Now, let's create this simple particle effect for our penguin's
    rocket in our last created `PerkyPenguin_PenguinMovement` project from [Chapter
    1](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml), *Introduction to Android Game
    Development with Unity 3D*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating a particle system object by selecting GameObject | Particle
    System as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 Creating Particle System GameObject
  prefs: []
  type: TYPE_NORMAL
- en: 'This will add a game object with the name Particle System in the Hierarchy
    panel immediately. But you might notice a strange thing here of the white spheres
    moving outward in the Scene View as soon the object is created and selected. The
    screenshot below shows a simple example of those white spheres in the Scene view
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 A Particle System GameObject selected in Unity
  prefs: []
  type: TYPE_NORMAL
- en: You can see that, as we created a Particle System object, a simple white sphere
    particle system started playing in the scene. A small control panel is shown in
    the scene, consisting of controls such as pause, stop, playback speed, and playback
    time. As you select any other game object or deselect the Particle System game
    object, the Particle System will stop automatically.
  prefs: []
  type: TYPE_NORMAL
- en: One of feature of the interface of Unity is that developers don't need to play
    the game in order to test their particle systems. These can be checked directly
    within the scene view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you should notice the Inspector panel of the selected Particle System
    and see how lots of different properties are shown in the Particle System component
    of the object, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 Particle System component in Inspector panel
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be good to know that almost everything about the Unity''s Particle
    System is provided in this Particle System component, which is a set of a huge
    number of properties. On tweaking and changing the values of these properties,
    a snowfall can be converted into burning fire, or it can be converted into an
    explosion for any airplane games, or it can be converted in a magic ball or magic
    spell for any dungeon role-playing games, and so on. To learn about it, let''s
    continue our rocket fire particle system by following the steps given below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to put the particle system always below the rocket, it should be a
    child of the penguin object. So drag the Particle System object onto the penguin
    game object in the Hierarchy panel and you will see something like the following
    screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_02_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 Particle System GameObject as child of penguin object
  prefs: []
  type: TYPE_NORMAL
- en: Rename the Particle System to rocketFire.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set its Position to (-0.62, -0.33, 0) to move it to the nozzle of the rocket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set its Rotation to (65, 270, 270) to set the direction of the particles in
    orientation with the rocket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot highlights all the changes provided in the above steps
    of the Inspector panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 The rocketFire Transform in Inspector panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the Inspector panel with the rocketFire particle system object selected,
    let''s alter the values of the Particle System component to create a beautiful
    type of fire for our penguin''s rocket to boost. Here are the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Set Start Lifetime to 0.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set Start Size to 0.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Start Color and set Red to 255, Green to 135, Blue to 40 and Alpha
    to 255, this will turn our white particles into orange ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand the Emission section and set Rate to 300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand the Shape section and set Shape to Cone, Angle to 12 and Radius to 0.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the Random Direction checkbox to checked state to create randomness in fire
    particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Particle System component''s previously
    set along with its result of rocket fire below the penguin in the Scene view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 The rocketFire Particle System
  prefs: []
  type: TYPE_NORMAL
- en: 'You can observe how the random white spheres being generated and moving in
    random directions have changed into a cone-shaped fire emission from a rocket
    tied on the back of the penguin. What we have done is to alter some values in
    the Particle System component in the Inspector panel. Let''s briefly look at what
    these properties actually do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start Lifetime** is the total lifetime in seconds that particles will have
    when emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Size** is the initial size of particles when emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Color** is the initial color of particles when emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emission Rate** is the number of particles emitted per unit of time or distance
    moved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shape** is the shape of the emission volume: the options are *Sphere*, *Hemisphere*,
    *Cone*, *Box*, *Mesh*, *Circle* and *Edge*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angle** is the angle of the cone at its point (for cones only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radius** is the radius of the circular aspect of the shape'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random Direction** enabled means that the particles'' initial direction will
    be chosen randomly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see more of these properties and their purposes on Unity's manual or
    documentation website at [http://docs.unity3d.com/Manual/ParticleSystemModules.html](http://docs.unity3d.com/Manual/ParticleSystemModules.html).
  prefs: []
  type: TYPE_NORMAL
- en: So, our rocket fire Particle System is ready. But, in real life, fire never
    ends instantly, it always ends by getting faded over time. We can also add this
    property into our fire by enabling the Start Color property in the Particle System
    component. Then click on the Color box and select the top slider on the right,
    which is for alpha of the end color, and set its value to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole setting is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 Adding fade effect in fire using Color over Lifetime
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not sure of what exactly Color over Lifetime changed in the fire
    effect, the following screenshot shows the difference in the fire particle system
    with and without the fading effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 The fire effects with and without fade effects
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have a penguin which flies on a tap of the screen and its rocket
    is exploding fire all the time. Now it's time to put some environment in the game
    to make the theme of the game. This environment will be for the penguin to move
    forward through and our game needs an endless room for the background. But, in
    order to test the penguin walking, we will only add background without any endless
    moving functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding game-level backgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A game with no background or theme is no game at all. So far, the penguin has
    got no reason to walk through the game, fly, or use its rocket to boost because
    it is in a void space of blue color. Let's bring this penguin into the snowy and
    hilly world where it actually belongs. And in order to survive melting ice due
    to global warming, it can also use its rocket to fly a little. In this section,
    we will learn how to add backgrounds and how the order of these backgrounds and
    sprites is managed in any 2D game where z-order is not used at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating backgrounds for the levels of the game. These backgrounds
    can be created in your favorite graphics tools, such as Adobe Photoshop and so
    on. The following screenshot shows the background we created for the Perky Penguin
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_012.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig 2.12 Background of the Penguin Perky Game
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already learned about how the images are imported as sprites in Unity.
    For backgrounds, we have to do exactly the same procedure again. We have prepared
    two repeatable images with the names `bg_snow1.png` and `bg_snow2.png` and imported
    these images into the Graphics folder of the Assets directory in the Project Browser
    panel. The following screenshot shows the Project Browser panel with background
    images in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 Backgrounds in the Project browser panel
  prefs: []
  type: TYPE_NORMAL
- en: 'It must be noted that the backgrounds should be repeatable so that when these
    images are put together, they should merge and avoid players recognizing the repeating
    order. The following screenshot shows both the background images we have designed
    for the Penguin Perky game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_014.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 Backgrounds of Penguin Perky game
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the images that if we keep these two images repeating beside
    each other, it will create a very smooth background which will forever be repeating
    over and over again. We will do that with some scripting later in this chapter.
    For now, let's set up the scene background of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing the background images in the Graphics folder of Assets, place
    two objects of `bg_snow1.png` and one object of `bg_snow2.png` in the Hierarchy
    panel. Set the first `bg_snow1.png` position to (0, 0, 0), then the `bg_snow2.png`
    position to (4.8, 0, 0), and finally another `bg_snow1.png` position to (9.6,
    0, 0), and you will get a small background in the scene. So, now you will observe
    that the penguin is hidden behind these backgrounds. As this is a 2D game, so
    there is no concept of a z-axis here. We can set the z-axis position and bring
    forward and backward the sprites and images but for 2D games it is not a good
    approach. Unity provides developers with an ordering mechanism for placing 2D
    images front and backward optimized for 2D games especially. This is done through
    the sorting layers. Select the `bg_snow1` object in the Hierarchy panel and look
    at the Inspector in the SpriteRenderer component, and you will see an option of
    Sorting Layer as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 Sorting Layer in SpriteRenderer in Inspector panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, all the sprites you import in Unity have a default sorting layer.
    Click on the drop-down menu and you will see the list of all sorting layers in
    the project. At the moment, we only have one layer called Default and there is
    another option, Add Sorting Layer..., to add a new layer. Click on the Add Sorting
    Layer... option as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_016.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 Add Sorting Layer... option
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open a new Tags & Layers panel in place of the Inspector panel. Add
    four layers, namely Background, Surroundings, Objects, and Player in the order
    as explained. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 Sorting Layers panel
  prefs: []
  type: TYPE_NORMAL
- en: You can drag these layers up or down by pressing and dragging the two lines
    icon to the left of each layer row. Moving these layers up or down describes the
    order of layers. For example, currently the Default layer is the lowest layer
    and it will be behind everything, and the Player layer will be in front of everything that
    uses layers except the Player layer.
  prefs: []
  type: TYPE_NORMAL
- en: There is a huge difference between Sorting Layers and Layers. Sorting Layers
    are only used to arrange 2D sprites for 2D games but the Layers are not for arranging
    purposes. It's totally a different concept and you must be careful when using
    layers in order to avoid any conflict between layers and sorting layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we only need Player and Background sorting layers; we will use other
    layers later in this chapter. Now, select the penguin game object in the Hierarchy
    panel and choose the Player layer from the Sorting Layer option in Sprite Renderer,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_018.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 Selecting Penguin's Sorting Layer
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, select the Background layer for all the snow background objects in
    the scene. And now you will observe that the penguin will be in front of these
    snow backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: Camera management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now we have a game in which we have a penguin that can fly and jump with
    a rocket fire particle system effect. Also, we have a basic environment of snow
    backgrounds in the scene as well. In this section, we will learn about how we
    to make the penguin move throughout an endless generated level and how the camera
    will always be focused on the penguin.
  prefs: []
  type: TYPE_NORMAL
- en: Making the penguin move forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by making our penguin move in a forward direction. To do that,
    open the file `PenguinController.cs` created in [Chapter 1](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml),
    *Introduction to Android Game Development with Unity3D*. This file is contained
    in the Scripts folder of the Assets directory. Add the forward speed public field
    in the class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that adding any public field results in the addition of a property in
    the script''s game object, as shown in the Inspector panel in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_020.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 Forward Movement speed field in the Inspector panel
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to move the penguin with any speed, we have to update the speed
    of the penguin in the `Update()` or `FixedUpdate()` methods. Since we are using
    the `FixedUpdate()` method in order to utilize the physics behavior of the penguin,
    so add this code at end of the `FixedUpdate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_021.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, there is not much of anything new in this code snippet. As we updated
    the penguin's y-position in through jetpack force, we are updating only the x-axis
    of the penguin's object. See how we are assigning `forwardMovementSpeed` in each
    frame on the velocity of penguin's game object. When you run the project, the
    penguin will start moving in the right direction, and after a minute, it will
    leave the screen. Our next task is to make the camera follow the penguin so that
    the penguin always remains on screen and never gets out of bounds of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Making the camera follow the Penguin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object as a child of the penguin game object, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have lots of methods to make the camera follow the penguin. The easiest
    is to put the Camera object as a child of the penguin game object, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_022.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 Camera as child of the Penguin object
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you can do this, but there is a problem with this solution. When the
    penguin jumps or flies, the camera also moves up or down with it. We don''t need
    that in our game. We only need to move the camera horizontally and continuously
    move forward keeping the penguin in the bounds. So, we will do that by creating
    another C# script file in the Script folder of the Assets directory with the name
    `CameraFollow.cs`. Now, add a public `GameObject` field with a variable named
    `targetObject`. This field will tell the camera about which object to follow.
    We will keep a reference of the penguin''s game object in this field. And finally,
    to move the camera continuously forward, we will do code similar to the penguin''s
    moving forward code. The only difference here is that we put our code in the `Update()`
    method instead of `FixedUpdate()`. The reason for this is that `FixedUpdate()`
    should be used when the object has a rigid body and/or other physical behaviors.
    As our camera has no connection with the physics, we can do this by simply adding
    the moving code in the `Update()` method. The following is the whole code of the
    `CameraFollow.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After writing the code, let''s put this script on the Camera object. Select
    the Main Camera object in the Hierarchy panel, and click on the Add Component
    button in Inspector and choose Scripts - CameraFollow.cs, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_024.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 Adding CameraFollow.cs on camera
  prefs: []
  type: TYPE_NORMAL
- en: You can also apply scripts on the game objects by simply dragging the script
    files from the Project Browser panel directly onto game objects in the Hierarchy
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the project, although the Camera will move, you will a see an
    error in the Debug Log panel, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_025.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 Camera error in Debug Log
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that the variable `targetObject` in the `CameraFollow` script
    is not assigned to any value and we are accessing it the `Update()` method. Recall
    from earlier that we need to assign the penguin game object in the `targetObject`
    value to tell the camera about the target to follow. You can use Unity''s public
    inspector feature and directly assign the penguin object by dragging it into the
    camera''s `targetObject` field in the Inspector panel, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_026.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 Assigning Penguin Object in Target Object
  prefs: []
  type: TYPE_NORMAL
- en: Now run the game and you will see the camera will never allow the penguin off
    the screen. However, after moving for a short time, the penguin will start falling
    since its floor has been left behind and the penguin has no physical support to
    oppose its gravity. To fix this and continue with the game, we will now work on
    creating endless levels in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs and level management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is not a single game which doesn't contain at least one level. Levels
    are what makes games feel like an experience and adventure. Levels come with different
    kinds of difficulties and players start to have feelings of accomplishing something
    and rewards. So, to put the soul in our Penguin Perky game, let's add levels to
    our game. But the question that arises here is what type of levels we should add
    to the game. Since the game is endless, so it would be a very suitable to add
    automatically generated levels with random obstacles and enemies in the game.
    In order to do that, we need a script that will take care of generating random
    environments and rooms along with putting enemies and barriers to balance the
    game difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides developers with the opportunity to instantiate the game objects
    at runtime and define behaviours in them, also at runtime. We can add rooms, levels,
    coins, enemies, and so on separately at runtime but Unity provides a better and
    organized way to handle these types of situations to manage reusable elements
    at runtime. This is done through the Prefab objects. Let's discuss Prefabs in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Unity's documentation, a Prefab is a type of asset--a reusable
    `GameObject` stored in Project View. Prefabs can be inserted into any number of
    scenes, multiple times per scene. When you add a Prefab to a scene, you create
    an instance of it. All Prefab instances are linked to the original Prefab and
    are essentially clones of it. No matter how many instances exist in your project,
    when you make any changes to the Prefab, you will see the change applied to all
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the empty Prefab in the Project browser view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_027.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 An empty BoxPrefab in the Project browser panel
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we have a folder called Prefabs in our Assets directory.
    We created this folder when configuring the project. We will store all the Prefabs
    used in the game in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs are exactly like game objects. They can have colliders, rigid body,
    scripts, other components, and so on. The only difference between Prefabs and
    game objects is that Prefabs can be instantiated at runtime and copy the same
    behavior at runtime, but game objects can be generated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create an endless level, we have to create a small block of levels
    for our game. This block will be continuously generated at runtime over and over
    again as the penguin keeps going through the level. Let's create the small level
    block in the next section and see how this Prefab theory goes into action.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Level Block Prefab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Level Block Prefab will have a ground object and a ceiling object to avoid
    the penguin going out of the bounds from the screen and it will have an environment
    in the background for decoration and theme purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an empty game object in the Hierarchy by right-clicking
    in hierarchy view and clicking Create Empty, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_028.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 Creating an empty GameObject
  prefs: []
  type: TYPE_NORMAL
- en: Now, put all the necessary game objects to be included in the Prefab as a child
    of this empty game object. We are adding `snow_bg1` and `snow_bg2` backgrounds,
    the `floor` object, and the `ceiling` object at the moment. We can update it later
    at any time and add new objects and components in the Prefabs. But you must remember
    that it would change all the existing Prefab objects as well, so you must be careful
    when you update the Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these objects can be dragged onto the empty created game object to make
    these children and rename the empty game object `level_block` then. The following
    screenshot shows the game object hierarchy of the `level_block` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_029.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.27 The level_block game object
  prefs: []
  type: TYPE_NORMAL
- en: If you have decorated your level block with more objects, decorations, surroundings,
    and so on, then you should also add them to the level block empty game object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a level block game object. Now it''s time to put it into Prefab
    form. To do that, right-click on the Prefabs folder in the Assets directory, and
    choose Create - Prefab from the menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_030.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.28 Creating a Prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'It will create an empty Prefab in the Prefabs folder. Now, drag the level_block
    game object from the hierarchy view onto the empty created Prefab and your Prefab
    will be ready. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_031.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.29 Adding an Object to a Prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Prefab is created, it will show you a small preview of the game object
    contents in the Project Browser panel. You will also observe a small arrow in
    it, which will explore all the objects put into the Prefab as well. The following
    screenshot shows the preview of Level Block Prefab in the Project Browser panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_032.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.30 Prefab in Project Browser Panel
  prefs: []
  type: TYPE_NORMAL
- en: The Prefabs can be used in any scenes. These are reusable anywhere throughout
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see how the Prefabs will work at runtime, just drag our Level Block
    Prefab object into the scene a few times in different positions and see how it
    comes in the view. The following screenshot shows a few level blocks placed in
    a scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_033.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.31 Level Block Prefabs placed randomly in the scene
  prefs: []
  type: TYPE_NORMAL
- en: You can observe that whenever we drag any Prefab into the scene, it creates
    the whole block, consisting of all the functionality, child objects, behaviors,
    scripts, and so on. That is the main advantage of using Prefabs in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Our Level Block Prefab is ready. Now we have to tell Unity when to create the
    block at runtime and at what positions it should be instantiated. We will do this
    by adding a script called `BlockGenerator.cs` into the penguin object. Let's explain
    about this generator in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The level block generator concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind the generator script is quite simple. The script has an array
    of level blocks it can generate (for now, we have only one block created), a list
    of blocks currently generated, and two additional methods. One method checks to
    see whether another block needs to be added and the other method actually adds
    a block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a block needs to be added, the script will enumerate all existing
    rooms and see whether there is a room ahead, farther than the screen width, to
    guarantee that the player never sees the end of the level. To understand this
    more clearly, let''s look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_034.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.32 Level block generator idea
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in scenario 1, there is enough space or width yet to cover some
    distance in the block. But in scenario 2, there is not enough space to cover,
    because as the penguin moves forward, the empty space will start to show up. So
    before it shows any blank space, we need to add a new level block beside the current
    block so that the player never sees any empty spaces there. The figure only tries
    to clarify the rough concept of how the new block will be added and when. The
    following screenshot shows a sample generation of blocks and our penguin''s moving
    forward status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_035.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.33 Penguin Moving Forward and Level Blocks Generating
  prefs: []
  type: TYPE_NORMAL
- en: You can see that as the penguin keeps moving forward, new blocks will be generating
    over and over again. Once any block leaves the screen, it will be deleted to optimize
    the memory usage and increase game performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now bring this whole scenario into action by writing the `BlockGenerator.cs`
    code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The BlockGenerator.cs code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating an empty C# script file in the Scripts folder of the
    Assets directory with the name `BlockGenerator.cs`. Then drag this script onto
    the penguin object to apply on the penguin.
  prefs: []
  type: TYPE_NORMAL
- en: Any game object can have many scripts applied to it. There is no restriction
    of scripts or components applied on the game objects.
  prefs: []
  type: TYPE_NORMAL
- en: Open `BlockGenerator.cs` in `MonoDevelop` by double-clicking it in the Project
    view or in the Inspector panel.
  prefs: []
  type: TYPE_NORMAL
- en: You have to add the `System.Collections.Generic` namespace if you're going to
    use the `List<T>` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following field variables into the `BlockGenerator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`availableBlocks` will contain an array of Prefabs which the script can generate.
    Currently, we have only one Prefab (`LevelBlockPrefab`). But we can create many
    different blocks types and add them all to this array, so that the script could
    randomly choose which block type to generate. The `currentBlocks` list will store
    instanced blocks, so that it can check where the last block ends and whether it
    needs to add more blocks. Once the block is behind the player character, it will
    remove it as well. The `screenWidthInPoints` variable is just required to cache
    screen size in points.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see these fields in the Inspector view of the penguin game object,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_037.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.34 Block Generator Fields in Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code in the `Start()` method of the `BlockGenerator.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_038.png)'
  prefs: []
  type: TYPE_IMG
- en: Here you calculate the size of the screen in points. The screen size will be
    used to determine whether you need to generate a new block, described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `AddBlock()` method to `BlockGenerator.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This method adds a new block using the `farhtestBlockEndX` point, which is
    the rightmost point of the level so far. Here is description of every line of
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Picks a random index of the block type (Prefab) to generate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a block object from the array of available blocks using the random index
    above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the block is empty containing all the block parts, you cannot simply take
    its size. Instead, you get the size of the floor inside the block, which is equal
    to the block's width.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you set the block position, you set the position of its center so you add
    the half block width to the position where the level ends. This way gets the point
    at which you should add the block, so that it starts straight after the last block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sets the position of the block. You need to change only the x-coordinate
    since all blocks have the same y and z coordinates equal to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you add the block to the list of current blocks. It will be cleared
    in the next method, which is why you need to maintain this list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the `AddBlock()` method, let''s go into the details of the `GenerateBlockIfRequired()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_040.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This method is the implementation of the idea explained in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new list to store blocks that need to be removed. Separate lists are
    required since you cannot remove items from the list while you are iterating through
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a flag that shows whether you need to add more blocks. By default, it
    is set to true, but most of the time it will be set to false inside the `foreach`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saves player position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the point after which the block should be removed. If a block's position
    is behind this point (to the left), it needs to be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no block after the `addBlockX`point, you need to add a block, since
    the end of the level is closer than the screen width.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `farthestBlockEndX`, you store the point where the level currently ends.
    You will use this variable to add a new block if required, since the new block
    should start at that point to make the level seamless.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `foreach`, you simply enumerate the current blocks. You use the floor to
    get the block width and calculate the `BlockStartX` (the point where the block
    starts, the leftmost point of the block) and `BlockEndX` (the point where the
    block ends, the rightmost point of the block).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is a block that starts after `addBlockX` then you don't need to add
    blocks right now. However, there is no `break` instruction here, since you still
    need to check whether this block needs to be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a block ends to the left of the `removeBlockX` point, then it is already
    off the screen and needs to be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here you simply find the rightmost point of the level. This will be the point
    where the level currently ends. It is used only if you need to add a block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This removes blocks that are marked for removal. The mouse `GameObject` already
    flew through them and thus they are far behind, so you need to remove them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If at this point `addBlocks` is still `true`, then the level end is near. `addBlocks`
    will be true if it didn't find a block starting farther than the screen width.
    This indicates that a new block needs to be added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, after all this explanation, let''s add our final method, `FixedUpdate()` to
    the the `BlockGenerator.cs` files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating blocks in `FixedUpdate()` will continue to periodically make sure
    that the player never experiences blank space in the game. Now, return to Unity
    and select the *penguin* GameObject in the Hierarchy. In the Inspector, find the
    `BlockGenerator` component. Drag the LevelBlockPrefab from the Hierarchy to the
    Current Blocks list. Then open the Prefabs folder in Project Browser and drag
    LevelBlockPrefab from it to Available Blocks. The following screenshot shows the
    `BlockGenerator` component of the penguin object after adding Prefabs in the lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_042.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.35 Block Generator Component with Prefabs
  prefs: []
  type: TYPE_NORMAL
- en: Now run the project and you will see that blocks will keep generating. Note
    that blocks are appearing and disappearing in the Hierarchy while you fly. And
    for even more fun, run the scene and switch to the *Scene View* without stopping
    the game. This way, you will see how blocks are added and removed in real time.
  prefs: []
  type: TYPE_NORMAL
- en: So, after level generation, let's discuss how to add obstacles such as ice spikes
    in the game to make the penguin be little careful while going through the level
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ice spikes to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The penguin flying through the level looks great but the game is all about the
    challenges and obstacles. So, this section is all about the obstacles which can
    be added to the game. We will add ice spikes, which will be generated randomly
    in a similar manner as you generate blocks. Let's create the ice spike first.
    You need two images for the spikes on and spikes off states.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the spikes on and spikes off states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_043.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.36 Block generator fields in Inspector pane
  prefs: []
  type: TYPE_NORMAL
- en: 'Import these images into Unity with the names `spike_on.png` and `spike_off.png`
    in the Graphics folder of the Assets directory. And then we have to create a Prefab
    of the spike for it. So, here are the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project view, find the `spike_on` sprite and drag it to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select it in the Hierarchy and rename it `spike`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Sorting Layer to Objects*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Box Collider 2D component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the Is Trigger property in the Box Collider 2D component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the Is Trigger property is enabled, the collider will trigger collision
    events, but will be ignored by the physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: Set the Size of the collider, *X* to *0.18* and *Y* to *3.1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C# script named `SpikeScript.cs` in the Scripts folder and attach
    it to the `spike` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows all the steps done here to create a spike GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_044.png)'
  prefs: []
  type: TYPE_IMG
- en: Fig 2.37 Adding a spike game object
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `SpikeScript.cs` and add the following fields in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_045.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then add the following code in the `Start()` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will set the time until the spike should toggle its state for the first
    time. Then, to toggle and rotate the spike, add `FixedUpdate()` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_047.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, select `spike` in the Hierarchy. Drag the `spike_on` sprite from project
    browser to the Spike On Sprite property of the `SpikeScript` component in the
    inspector view. Also, do it for the `spike_off` sprite as well. Set Rotation speed
    to 30 and position to (2, 0.25, 0). Run the project and you will get a spike nicely
    rotating and finally turn into spike game object into a SpikePrefab in spikes
    folder as we did in the earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the spike running in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_048.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.38 Spike in the game
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continued our Perky Penguin game and added particle systems
    to it. Then we learned about managing the camera, and we made the camera follow
    the penguin throughout the game. Then we worked on Prefabs and created a level
    block Prefab which we generated in the game from the code to make an endless level
    generating game. Then we created a Spike Prefab to create an obstacle for the
    penguin in the game which gets generated randomly and rotates with different speeds
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move our concepts of making games to 3D and introduce
    you to the workflow and systems to create 3D complex games in Unity 3D.
  prefs: []
  type: TYPE_NORMAL
