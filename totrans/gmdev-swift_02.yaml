- en: Chapter 2. Sprites, Camera, Actions!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：精灵、相机、动作！
- en: Drawing with SpriteKit is a breeze. We are free to focus on building great gameplay
    experiences while SpriteKit performs the mechanical work of the **game loop**.
    To draw an item to the screen, we create a new instance of a SpriteKit node. These
    nodes are simple; we attach a child node to our scene, or to existing nodes, for
    each item we want to draw. Sprites, particle emitters, and text labels are all
    considered nodes in SpriteKit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SpriteKit 绘制非常简单。我们可以自由地专注于构建出色的游戏体验，同时 SpriteKit 执行游戏循环的机械工作。要在屏幕上绘制一个项目，我们创建一个
    SpriteKit 节点的新的实例。这些节点很简单；我们为每个要绘制的项目将子节点附加到场景或现有节点上。精灵、粒子发射器和文本标签在 SpriteKit
    中都被视为节点。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The game loop is a common game design pattern used to constantly update the
    game many times per second, and to maintain the same gameplay speed on fast or
    slow hardware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环是一个常用的游戏设计模式，用于每秒多次更新游戏，并在硬件快或慢的情况下保持相同的游戏速度。
- en: SpriteKit wires new nodes into the game loop automatically. As you gain expertise
    with SpriteKit, you may wish to explore the game loop further to understand what
    is going on "under the hood".
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 会自动将新节点连接到游戏循环中。随着你对 SpriteKit 的熟练，你可能希望进一步探索游戏循环以了解“幕后”发生了什么。
- en: 'The topics in this chapter include:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Preparing your project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备你的项目
- en: Drawing your first sprite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制你的第一个精灵
- en: 'Animation: movement, scaling, and rotation'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画：移动、缩放和旋转
- en: Working with textures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与纹理一起工作
- en: Organizing art into texture atlases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将艺术作品组织到纹理图集中
- en: Centering the camera on a sprite
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在精灵上居中相机
- en: Sharpening our pencils
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磨尖我们的铅笔
- en: 'There are four quick items to take care of before we start drawing:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始绘制之前，有四个快速事项需要注意：
- en: 'Since we will design our game to use landscape screen orientations, we will
    disable the portrait view altogether:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将设计我们的游戏以使用横幅屏幕方向，我们将完全禁用纵向视图：
- en: With your game project open in Xcode, select the overall project folder in the
    project navigator (the top-most item).
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 中打开你的游戏项目后，在项目导航器中选择整体项目文件夹（最顶部的项目）。
- en: You will see your project settings in the main frame of Xcode. Under **Deployment
    Info**, find the **Device Orientation** section.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在 Xcode 的主框架中看到你的项目设置。在**部署信息**下，找到**设备方向**部分。
- en: Uncheck the **Portrait** option, as shown in the following screenshot:![Sharpening
    our pencils](img/Image_B04532_02_01.jpg)
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**纵向**选项，如图所示：![磨尖我们的铅笔](img/Image_B04532_02_01.jpg)
- en: 'The SpriteKit template generates a visual layout file for arranging sprites
    in our scene. We will not need it; we will use the SpriteKit visual editor later
    when we explore level design. To delete this extra file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpriteKit 模板为在场景中排列精灵生成一个视觉布局文件。我们不需要它；在探索关卡设计时，我们将使用 SpriteKit 视觉编辑器。要删除这个额外的文件：
- en: Right-click on `GameScene.sks` in the project navigator and choose **delete**.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目导航器中右键单击 `GameScene.sks` 并选择**删除**。
- en: Choose **Move to Trash** in the dialog window.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框窗口中选择**移动到废纸篓**。
- en: 'We need to resize our scene to fit the new landscape view. Follow these steps
    to resize the scene:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要调整场景大小以适应新的横幅视图。按照以下步骤调整场景大小：
- en: Open `GameViewController.swift` from the project navigator and locate the `viewDidLoad`
    function inside the `GameViewController` class. The `viewDidLoad` function is
    going to fire before the game realizes it is in landscape view, so we need to
    use a function that fires later in the startup process. Delete `viewDidLoad` completely,
    removing all of its code.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目导航器打开 `GameViewController.swift` 并定位到 `GameViewController` 类中的 `viewDidLoad`
    函数。`viewDidLoad` 函数将在游戏意识到它处于横幅视图之前触发，因此我们需要使用在启动过程中较晚触发的函数。完全删除 `viewDidLoad`，移除其所有代码。
- en: 'Replace `viewDidLoad` with a new function named `viewWillLayoutSubviews`. Do
    not worry about understanding every line right now; we are just configuring our
    project. Use this code for `viewWillLayoutSubviews`:'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `viewDidLoad` 替换为名为 `viewWillLayoutSubviews` 的新函数。现在不必担心理解每一行；我们只是在配置项目。为
    `viewWillLayoutSubviews` 使用以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Lastly, in `GameViewController.swift`, find the `supportedInterfaceOrientations`
    function and reduce it to this code:'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `GameViewController.swift` 中找到 `supportedInterfaceOrientations` 函数并将其缩减到以下代码：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 出版物书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: Additionally, each chapter provides checkpoint links you can use to download
    the example project to that point.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，每个章节还提供了检查点链接，你可以使用这些链接下载到该点的示例项目。
- en: We should double-check that we are ready to move on. Try to run our clean project
    in the simulator using the toolbar play button or the *command* + *r* keyboard
    shortcut. After loading, the simulator should switch to landscape view with a
    blank gray background (and with the node and FPS counter in the bottom right).
    If the project will not run, or you still see "**Hello World**", you will need
    to retrace your steps from the end of [Chapter 1](ch01.html "Chapter 1. Designing
    Games with Swift"), *Designing Games with Swift*, to finish your project preparation.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该再次确认我们已经准备好继续前进。尝试使用工具栏上的播放按钮或*command* + *r*键盘快捷键在模拟器中运行我们的清洁项目。加载后，模拟器应该切换到横幅视图，背景为空白灰色（并在右下角显示节点和FPS计数器）。如果项目无法运行，或者你仍然看到“**Hello
    World**”，你需要从[第1章](ch01.html "第1章。使用Swift设计游戏")的结尾，*使用Swift设计游戏*，重新追踪你的步骤，以完成你的项目准备。
- en: Checkpoint 2- A
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 2- A
- en: 'If you want to download my project to this point, you can do so from this URL:
    [http://www.thinkingswiftly.com/game-development-with-swift/chapter-2](http://www.thinkingswiftly.com/game-development-with-swift/chapter-2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要下载到这一点的我的项目，你可以从以下网址下载：[http://www.thinkingswiftly.com/game-development-with-swift/chapter-2](http://www.thinkingswiftly.com/game-development-with-swift/chapter-2)
- en: Drawing your first sprite
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制你的第一个精灵
- en: It is time to write some game code – fantastic! Open your `GameScene.swift`
    file and find the `didMoveToView` function. Recall that this function fires every
    time the game switches to this scene. We will use this function to get familiar
    with the `SKSpriteNode` class. You will use `SKSpriteNode` extensively in your
    game, whenever you want to add a new 2D graphic entity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写一些游戏代码了——太棒了！打开你的 `GameScene.swift` 文件，找到 `didMoveToView` 函数。回想一下，这个函数每次游戏切换到这个场景时都会触发。我们将使用这个函数来熟悉
    `SKSpriteNode` 类。你将在游戏中广泛使用 `SKSpriteNode`，无论何时你想添加一个新的2D图形实体。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The term sprite refers to a 2D graphic or animation that moves around the screen
    independently from the background. Over time, the term has developed to refer
    to any game object on the screen in a 2D game. We will create and draw your first
    sprite in this chapter: a happy little bee.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “精灵”一词指的是在屏幕上独立于背景移动的2D图形或动画。随着时间的推移，这个术语已经发展到指代2D游戏中屏幕上的任何游戏对象。我们将在本章中创建并绘制你的第一个精灵：一只快乐的小蜜蜂。
- en: Building a SKSpriteNode class
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 SKSpriteNode 类
- en: 'Let''s begin by drawing a blue square to the screen. The `SKSpriteNode` class
    can draw both texture graphics and solid blocks of color. It is often helpful
    to prototype your new game ideas with blocks of color before you spend time with
    artwork. To draw the blue square, add an instance of `SKSpriteNode` to the game:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在屏幕上画一个蓝色方块。`SKSpriteNode` 类可以绘制纹理图形和实色块。在花费时间在艺术品上之前，用色块原型化你的新游戏想法通常很有帮助。要绘制蓝色方块，向游戏中添加一个
    `SKSpriteNode` 实例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Go ahead and run the project. You should see a similar small blue square appear
    in your simulator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，运行项目。你应该在模拟器中看到一个类似的小蓝色方块出现：
- en: '![Building a SKSpriteNode class](img/Image_B04532_02_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![构建 SKSpriteNode 类](img/Image_B04532_02_02.jpg)'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Swift allows you to define variables as constants, which can be assigned a value
    only once. For best performance, use `let` to declare constants whenever possible.
    Declare your variables with `var` when you need to alter the value later in your
    code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许你将变量定义为常量，它只能被赋予一次值。为了最佳性能，尽可能使用 `let` 来声明常量。当你需要在代码中稍后更改值时，使用 `var`
    声明变量。
- en: Adding animation to your Toolkit
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将动画添加到你的工具包中
- en: 'Before we dive back in to sprite theory, we should have some fun with our blue
    square. SpriteKit uses action objects to move sprites around the screen. Consider
    this example: if our goal is to move the square across the screen, we must first
    create a new action object to describe the animation. Then, we instruct our sprite
    node to execute the action. I will illustrate this concept with many examples
    in the chapter. For now, add this code in the `didMoveToView` function, below
    the `self.addChild(mySprite)` line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入精灵理论之前，我们应该用我们的蓝色正方形玩得开心一些。SpriteKit使用动作对象在屏幕上移动精灵。考虑以下示例：如果我们的目标是移动正方形穿过屏幕，我们必须首先创建一个新的动作对象来描述动画。然后，我们指示我们的精灵节点执行该动作。我将在本章中用许多示例来说明这个概念。现在，在`didMoveToView`函数中，在`self.addChild(mySprite)`行下方添加以下代码：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the project. You will see our blue square slide across the screen towards
    the (100,100) position. This action is re-usable; any node in your scene can execute
    this action to move to the (100,100) position. As you can see, SpriteKit does
    a lot of the heavy lifting for us when we need to animate node properties.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你会看到我们的蓝色正方形滑过屏幕，向（100,100）位置移动。这个动作是可重用的；场景中的任何节点都可以执行这个动作来移动到（100,100）位置。正如你所见，当我们需要对节点属性进行动画处理时，SpriteKit为我们做了很多繁重的工作。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Inbetweening, or tweening, uses the engine to animate smoothly between a start
    frame and an end frame. Our `moveTo` animation is a tween; we provide the start
    frame (the sprite's original position) and the end frame (the new destination
    position). SpriteKit generates the smooth transition between our values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 中间画，或称补间，使用引擎在起始帧和结束帧之间进行平滑动画。我们的`moveTo`动画是一个补间；我们提供起始帧（精灵的原始位置）和结束帧（新的目标位置）。SpriteKit生成我们值之间的平滑过渡。
- en: 'Let''s try some other actions. The `SKAction.moveTo` function is only one of
    many options. Try replacing the `demoAction` line with this code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些其他动作。`SKAction.moveTo`函数只是众多选项之一。尝试将`demoAction`行替换为以下代码：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the project. You will see our blue square grow to four times its original
    size.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你会看到我们的蓝色正方形增长到原来的四倍大小。
- en: Sequencing multiple animations
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个动画的序列化
- en: 'We can execute actions together simultaneously or one after the each other
    with action groups and sequences. For instance, we can easily scale our sprite
    larger and spin it at the same time. Delete all of our action code so far and
    replace it with this code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用动作组和序列同时执行动作或依次执行。例如，我们可以轻松地将我们的精灵放大并旋转。删除到目前为止的所有动作代码，并用以下代码替换：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you run the project, you will see a spinning, growing square. Terrific!
    If you want to run these actions in sequence (rather than at the same time) change
    `SKAction.group` to `SKAction.sequence`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行项目时，你会看到一个旋转并变大的正方形。太棒了！如果你想按顺序运行这些动作（而不是同时运行），将`SKAction.group`更改为`SKAction.sequence`：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code and watch as your square first grows and then spins. Good. You
    are not limited to two actions; we can group or sequence as many actions together
    as we need.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，观察你的正方形首先变大然后旋转。很好。你不仅限于两个动作；我们可以将所需数量的动作组合或序列化。
- en: We have only used a few actions so far; feel free to explore the `SKAction`
    class and try out different action combinations before moving on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止只使用了几个动作；在继续之前，你可以自由探索`SKAction`类并尝试不同的动作组合。
- en: Recapping your first sprite
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾你的第一个精灵
- en: 'Congratulations, you have learned to draw a non-textured sprite and animate
    it with SpriteKit actions. Next, we will explore some important positioning concepts,
    and then add game art to our sprites. Before you move on, make sure your `didMoveToView`
    function matches with mine, and your sequenced animation is firing properly. Here
    is my code up to this point:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经学会了如何使用SpriteKit动作绘制非纹理精灵并对其进行动画处理。接下来，我们将探索一些重要的定位概念，然后为我们的精灵添加游戏艺术。在你继续之前，请确保你的`didMoveToView`函数与我的匹配，并且你的序列化动画正在正确触发。以下是到目前为止的我的代码：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The story on positioning
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位的故事
- en: SpriteKit uses a grid of points to position nodes. In this grid, the bottom
    left corner of the scene is (0,0), with a positive X-axis to the right and a positive
    Y-axis to the top.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit使用点阵来定位节点。在这个网格中，场景的左下角是（0,0），X轴向右为正方向，Y轴向上为正方向。
- en: Similarly, on the individual sprite level, (0,0) refers to the bottom left corner
    of the sprite, while (1,1) refers to the top right corner.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在单个精灵级别上，（0,0）指的是精灵的左下角，而（1,1）指的是右上角。
- en: Alignment with anchor points
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与锚点对齐
- en: Each sprite has an `anchorPoint` property, or an origin. The `anchorPoint` property
    allows you to choose which part of the sprite aligns to the sprite's overall position.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个精灵都有一个`anchorPoint`属性，或称为原点。`anchorPoint`属性允许您选择精灵的哪个部分与精灵的整体位置对齐。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default anchor point is (0.5,0.5), so a new `SKSpriteNode` centers perfectly
    on its position.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认锚点为（0.5，0.5），因此新的`SKSpriteNode`在其位置上完美居中。
- en: 'To illustrate this, let us examine the blue square sprite we just drew on the
    screen. Our sprite is 50 pixels wide and 50 pixels tall, and its position is (300,300).
    Since we have not modified the `anchorPoint` property, its anchor point is (0.5,0.5).
    This means the sprite will be perfectly centered over the (300,300) position on
    the scene''s grid. Our sprite''s left edge begins at 275 and the right edge terminates
    at 325\. Likewise, the bottom starts at 275 and the top ends at 325\. The following
    diagram illustrates our block''s position on the grid:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们检查一下我们在屏幕上刚刚绘制的蓝色方块精灵。我们的精灵宽度为50像素，高度为50像素，其位置是（300，300）。由于我们没有修改`anchorPoint`属性，其锚点为（0.5，0.5）。这意味着精灵将在场景网格的（300，300）位置上完美居中。我们的精灵的左侧边缘始于275，右侧边缘终止于325。同样，底部始于275，顶部终止于325。以下图表说明了我们的方块在网格上的位置：
- en: '![Alignment with anchor points](img/Image_B04532_02_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用锚点对齐](img/Image_B04532_02_03.jpg)'
- en: 'Why do we prefer centered sprites by default? You may think it simpler to position
    elements by their bottom left corner with an `anchorPoint` property setting of
    (0,0). However, the centered behavior benefits us when we scale or rotate sprites:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们默认喜欢居中的精灵？您可能会认为通过将`anchorPoint`属性设置为（0，0）来根据元素的左下角定位元素会更简单。然而，当我们在缩放或旋转精灵时，居中行为对我们更有益：
- en: When we scale a sprite with an `anchorPoint` property of (0,0) it will only
    expand up the y-axis and out the x-axis. Rotation actions will swing the sprite
    in wide circles around its bottom left corner.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用`anchorPoint`属性为（0，0）缩放精灵时，它只会沿着y轴向上扩展并沿x轴向外出扩展。旋转动作会使精灵围绕其左下角进行大圆旋转。
- en: A centered sprite, with the default `anchorPoint` property of (0.5, 0.5), will
    expand or contract equally in all directions when scaled and will spin in place
    when rotated, which is usually the desired effect.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的`anchorPoint`属性为（0.5，0.5）的居中精灵在缩放时会在所有方向上等比例扩展，并且在旋转时会在原地旋转，这通常是期望的效果。
- en: There are some cases when you will want to change an anchor point. For instance,
    if you are drawing a rocket ship, you may want the ship to rotate around the front
    nose of its cone, rather than its center.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您可能想要更改锚点。例如，如果您在绘制火箭船，您可能希望船围绕其圆锥形的前端旋转，而不是围绕其中心。
- en: Adding textures and game art
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加纹理和游戏艺术
- en: You may want to take a screenshot of your blue box for your own enjoyment later.
    I absolutely love reminiscing over old screenshots of my finished games when they
    were nothing more than simple colored blocks sliding around the screen. Now it
    is time to move past that stage and attach some fun artwork to our sprite.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想为您的蓝色方块拍一张截图，以备将来欣赏。我非常喜欢回忆我完成的游戏的老截图，当时它们只是简单的彩色方块在屏幕上滑动。现在是我们超越这个阶段，并将一些有趣的艺术作品附加到我们的精灵上的时候了。
- en: Downloading the free assets
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载免费资源
- en: I am providing a downloadable pack for all of the art assets I use in this book.
    I recommend you use these assets so you will have everything you need for our
    demo game. Alternatively, you are certainly free to create your own art for your
    game if you prefer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这本书中使用的所有艺术资源提供了一个可下载的包。我建议您使用这些资源，这样您将为我们的演示游戏准备齐全。或者，如果您愿意，当然可以自由地为您的游戏创建自己的艺术作品。
- en: 'These assets come from an outstanding public domain asset pack from Kenney
    Game Studio. I am providing a small subset of the asset pack that we will use
    in our game. Download the game art from this URL:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源来自Kenney Game Studio的一个杰出的公共领域资源包。我提供的是我们将用于游戏的资源包的小子集。请从以下URL下载游戏艺术资源：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/assets](http://www.thinkingswiftly.com/game-development-with-swift/assets)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/assets](http://www.thinkingswiftly.com/game-development-with-swift/assets)'
- en: More exceptional art
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更出色的艺术作品
- en: If you like the art, you can download over 16,000 game assets in the same style
    for a small donation at [http://kenney.itch.io/kenney-donation](http://kenney.itch.io/kenney-donation).
    I do not have an affiliation with Kenney; I just find it admirable that he has
    released so much public domain artwork for indie game developers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这些艺术作品，你可以在[http://kenney.itch.io/kenney-donation](http://kenney.itch.io/kenney-donation)通过小额捐赠下载超过16,000个同风格的游戏资源。我与Kenney没有关联；我只是觉得他向独立游戏开发者发布了如此多的公共领域艺术作品令人钦佩。
- en: 'As CC0 assets, you can copy, modify, and distribute the art, even for commercial
    purposes, all without asking permission. You can read the full license here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为CC0资源，你可以复制、修改和分发这些艺术作品，甚至用于商业目的，而无需请求许可。你可以在这里阅读完整的许可证：
- en: '[https://creativecommons.org/publicdomain/zero/1.0/](https://creativecommons.org/publicdomain/zero/1.0/)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://creativecommons.org/publicdomain/zero/1.0/](https://creativecommons.org/publicdomain/zero/1.0/)'
- en: Drawing your first textured sprite
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制你的第一个纹理精灵
- en: Let us use some of the graphics you just downloaded. We will start by creating
    a bee sprite. We will add the bee texture to our project, load the image onto
    a `SKSpriteNode` class, and then size the node for optimum sharpness on retina
    screens.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用你刚刚下载的一些图形。我们将从创建一个蜜蜂精灵开始。我们将把蜜蜂纹理添加到我们的项目中，将图像加载到`SKSpriteNode`类中，然后调整节点大小以在视网膜屏幕上获得最佳清晰度。
- en: Adding the bee image to your project
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将蜜蜂图像添加到你的项目中
- en: 'We need to add the image files to our Xcode project before we can use them
    in the game. Once we add the images, we can reference them by name in our code;
    SpriteKit is smart enough to find and implement the graphics. Follow these steps
    to add the bee image to the project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在游戏中使用它们之前，我们需要将图像文件添加到我们的Xcode项目中。一旦添加了图像，我们就可以在代码中通过名称引用它们；SpriteKit足够智能，能够找到并实现图形。按照以下步骤将蜜蜂图像添加到项目中：
- en: Right-click on your project in the project navigator and click on **Add Files
    to "Pierre Penguin Escapes the Antarctic"** (or the name of your game). Refer
    to this screenshot to find the correct menu item:![Adding the bee image to your
    project](img/Image_B04532_02_04.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目导航器中右键单击你的项目，然后点击**将文件添加到“Pierre Penguin Escapes the Antarctic”**（或你的游戏名称）。参考此截图以找到正确的菜单项：![将蜜蜂图像添加到你的项目中](img/Image_B04532_02_04.jpg)
- en: Browse to the asset pack you downloaded and locate the `bee.png` image inside
    the `Enemies` folder.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览你下载的资产包，并在`Enemies`文件夹中找到`bee.png`图像。
- en: Check **Copy items if needed**, then click **Add**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**如果需要则复制项目**，然后点击**添加**。
- en: You should now see `bee.png` in your project navigator.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在项目导航器中看到`bee.png`。
- en: Loading images with SKSpriteNode
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SKSpriteNode加载图像
- en: 'It is quite easy to draw images to the screen with `SKSpriteNode`. Start by
    clearing out all of the code we wrote for the blue square inside the `didMoveToView`
    function in `GameScene.swift`. Replace `didMoveToView` with this code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SKSpriteNode`将图像绘制到屏幕上相当简单。首先，清除我们在`GameScene.swift`中的`didMoveToView`函数内编写的所有用于蓝色方块的代码。将`didMoveToView`替换为以下代码：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the project and witness our glorious bee – great work!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并见证我们辉煌的蜜蜂——干得好！
- en: '![Loading images with SKSpriteNode](img/Image_B04532_02_05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用SKSpriteNode加载图像](img/Image_B04532_02_05.jpg)'
- en: Designing for retina
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为视网膜设计
- en: You may notice that our bee image is quite blurry. To take advantage of retina
    screens, assets need to be twice the pixel dimensions of their node's size property
    (for most retina screens), or three times the node size for the iPhone 6 Plus.
    Ignore the height for a moment; our bee node is 100 points wide but the PNG file
    is only 56 pixels wide. The PNG file needs to be 300 pixels wide to look sharp
    on the iPhone 6 Plus, or 200 pixels wide to look sharp on 2x retina devices.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们的蜜蜂图像相当模糊。为了利用视网膜屏幕，资源需要是其节点大小属性的两倍像素维度（对于大多数视网膜屏幕），或者iPhone 6 Plus的节点大小的三倍。暂时忽略高度；我们的蜜蜂节点宽度为100点，但PNG文件只有56像素宽。PNG文件需要宽度为300像素才能在iPhone
    6 Plus上看起来清晰，或者在2x视网膜设备上看起来清晰需要宽度为200像素。
- en: SpriteKit will automatically resize textures to fit their nodes, so one approach
    is to create a giant texture at the highest retina resolution (three times the
    node size) and let SpriteKit resize the texture down for lower density screens.
    However, there is a considerable performance penalty, and older devices can even
    run out of memory and crash from the huge textures.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit会自动调整纹理大小以适应其节点，因此一种方法是在最高的视网膜分辨率（节点大小的三倍）创建一个巨大的纹理，然后让SpriteKit将其调整到较低密度屏幕。然而，这会带来相当大的性能损失，并且旧设备甚至可能因为巨大的纹理而耗尽内存并崩溃。
- en: The ideal asset approach
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理想资产方法
- en: 'These double- and triple-sized retina assets can be confusing to new iOS developers.
    To solve this issue, Xcode normally lets you provide three image files for each
    texture. For example, our bee node is currently 100 points wide and 100 points
    tall. In a perfect world, you would provide the following images to Xcode:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些双倍和三倍大小的视网膜资源可能会让新的iOS开发者感到困惑。为了解决这个问题，Xcode通常允许你为每个纹理提供三个图像文件。例如，我们的蜜蜂节点目前宽度为100点，高度为100点。在一个完美的世界里，你会向Xcode提供以下图像：
- en: '`Bee.png` (100 pixels by 100 pixels)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bee.png` (100像素 x 100像素)'
- en: '`Bee@2x.png` (200 pixels by 200 pixels)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bee@2x.png` (200像素 x 200像素)'
- en: '`Bee@3x.png` (300 pixels by 300 pixels)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bee@3x.png` (300像素 x 300像素)'
- en: However, there is currently an issue that prevents 3x textures from working
    correctly with **texture atlases**. Texture atlases group textures together and
    increase rendering performance dramatically (we will implement our first texture
    atlas in the next section). I hope that Apple will upgrade texture atlases to
    support 3x textures in Swift 2\. For now, we need to choose between texture atlases
    and 3x assets for the iPhone 6 Plus.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前有一个问题阻止3x纹理与**纹理图集**正确工作。纹理图集将纹理组合在一起并显著提高渲染性能（我们将在下一节中实现我们的第一个纹理图集）。我希望Apple能在Swift
    2中升级纹理图集以支持3x纹理。目前，我们需要在iPhone 6 Plus的纹理图集和3x资源之间做出选择。
- en: My solution for now
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我目前的解决方案
- en: In my opinion, texture atlases and their performance benefits are key features
    of SpriteKit. I will continue using texture atlases, thus serving 2x images to
    the iPhone 6 Plus (which still looks fairly sharp). This means that we will not
    be using any 3x assets in this book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，纹理图集及其性能优势是SpriteKit的关键特性。我将继续使用纹理图集，为iPhone 6 Plus提供2x图像（它仍然看起来相当清晰）。这意味着在这本书中我们不会使用任何3x资源。
- en: Further simplifying matters, Swift only runs on iOS7 and higher. The only non-retina
    devices that run iOS7 are the aging iPad 2 and iPad mini 1st generation. If these
    older devices are important for your finished games, you should create both standard
    and 2x images for your games. Otherwise, you can safely ignore non-retina assets
    with Swift.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步简化问题，Swift只运行在iOS7及以上版本。唯一运行iOS7的非视网膜设备是老化的iPad 2和第一代iPad mini。如果你的最终游戏需要这些旧设备，你应该为你的游戏创建标准图像和2x图像。否则，你可以安全地忽略Swift的非视网膜资源。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This means that we will only use double-sized images in this book. The images
    in the downloadable asset bundle forgo the 2x suffix, since we are only using
    this size. Once Apple updates texture atlases to use 3x assets, I recommend that
    you switch to the methodology outlined in *The ideal asset approach* section for
    your games.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在这本书中我们只会使用双倍大小的图像。在可下载的资源包中的图像放弃了2x后缀，因为我们只使用这个大小。一旦Apple更新纹理图集以使用3x资源，我建议你切换到*理想资源方法*部分中概述的方法来为你的游戏使用。
- en: Hands-on with retina in SpriteKit
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在SpriteKit中使用视网膜显示
- en: 'Our bee image illustrates how this all works:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的蜜蜂图像说明了这一切是如何工作的：
- en: Because we set an explicit node size, SpriteKit automatically resizes the bee
    texture to fit our 100-point wide, 100-point tall sized node. This automatic size-to-fit
    is very handy, but notice that we have actually slightly distorted the aspect
    ratio of the image.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们设置了显式的节点大小，SpriteKit会自动调整蜜蜂纹理的大小以适应我们100点宽、100点高的节点。这种自动调整大小以适应的功能非常方便，但请注意，我们实际上略微扭曲了图像的宽高比。
- en: If we do not set an explicit size, SpriteKit sizes the node (in points) to the
    match texture's dimensions (in pixels). Go ahead and delete the line that sets
    the size for our bee node and re-run the project. SpriteKit maintains the aspect
    ratio automatically, but the smaller bee is still fuzzy. That is because our new
    node is 56 points by 48 points, matching our PNG file's pixel dimensions of 56
    pixels by 48 pixels . . . yet our PNG file needs to be 112 pixels by 96 pixels
    for a sharp image at this node size on 2x retina screens.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不设置显式的大小，SpriteKit会将节点（以点为单位）的大小调整为与纹理的维度（以像素为单位）相匹配。删除设置我们蜜蜂节点大小的行，并重新运行项目。SpriteKit会自动保持宽高比，但较小的蜜蜂仍然模糊。这是因为我们的新节点是56点
    x 48点，与我们的PNG文件的56像素 x 48像素像素维度相匹配……然而，我们的PNG文件需要是112像素 x 96像素，才能在2x视网膜屏幕上以这个节点大小显示清晰图像。
- en: 'We want a smaller bee anyway, so we will resize the node rather than generate
    larger artwork in this case. Set the `size` property of your bee node, in points,
    to half the size of the texture''s pixel resolution:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无论如何都需要一个更小的蜜蜂，所以我们将调整节点的大小而不是生成更大的艺术品。将你的蜜蜂节点的`size`属性设置为纹理像素分辨率的二分之一：
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the project and you will see a smaller, crystal sharp bee, as in this screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，你会看到一个更小、更清晰的蜜蜂，就像这个截图所示：
- en: '![Hands-on with retina in SpriteKit](img/Image_B04532_02_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![在SpriteKit中使用视网膜显示](img/Image_B04532_02_08.jpg)'
- en: Great! The important concept here is to design your art files at twice the pixel
    resolution of your node point sizes to take advantage of 2x retina screens, or
    three times the point sizes to take full advantage of the iPhone 6 Plus. Now we
    will look at organizing and animating multiple sprite frames.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这里的重要概念是要将你的艺术文件设计成节点点大小的两倍像素分辨率，以便利用2x视网膜屏幕，或者将点大小增加到三倍以充分利用iPhone 6 Plus。现在我们将看看如何组织和动画多个精灵帧。
- en: Organizing your assets
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织你的资源
- en: We will quickly overrun our project navigator with image files if we add all
    our textures as we did with our bee. Luckily, Xcode provides several solutions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像处理蜜蜂一样添加所有纹理，我们的项目导航器很快就会被图像文件淹没。幸运的是，Xcode提供了几个解决方案。
- en: Exploring Images.xcassets
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Images.xcassets
- en: 'We can store images in an `.xcassets` file and refer to them easily from our
    code. This is a good place for our background images:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将图像存储在`.xcassets`文件中，并轻松地从我们的代码中引用它们。这是一个存储背景图像的好地方：
- en: Open `Images.xcassets` from your project navigator.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目导航器中打开`Images.xcassets`。
- en: We do not need to add any images here now but, in the future, you can drag image
    files directly into the image list, or right-click, then **Import**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前我们不需要在这里添加任何图像，但将来，你可以直接将图像文件拖到图像列表中，或者右键单击，然后**导入**。
- en: Notice that the SpriteKit demo's spaceship image is stored here. We do not need
    it anymore, so we can right-click on it and choose **Removed Selected Items**
    to delete it.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，SpriteKit演示中的飞船图像存储在这里。我们不再需要它，所以我们可以右键单击它，然后选择**删除所选项目**来删除它。
- en: Collecting art into texture atlases
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将艺术作品收集到纹理图集中
- en: 'We will use texture atlases for most of our in-game art. Texture atlases organize
    assets by collecting related artwork together. They also increase performance
    by optimizing all of the images inside each atlas as if they were one texture.
    SpriteKit only needs one draw call to render multiple images out of the same texture
    atlas. Plus, they are very easy to use! Follow these steps to build your bee texture
    atlas:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用纹理图集来组织大部分游戏中的艺术资源。纹理图集通过收集相关的艺术作品来组织资源。它们还通过将每个图集中的所有图像优化为单个纹理来提高性能。SpriteKit只需要一个绘制调用就能从同一纹理图集中渲染多个图像。此外，它们非常容易使用！按照以下步骤构建你的蜜蜂纹理图集：
- en: We need to remove our old bee texture. Right-click on `bee.png` in the project
    navigator and choose **Delete**, then **Move to Trash**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要移除旧的蜜蜂纹理。在项目导航器中右键单击`bee.png`，然后选择**删除**，然后**移动到废纸篓**。
- en: Using Finder, browse to the asset pack you downloaded and locate the `Enemies`
    folder.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Finder，浏览到你下载的资源包，并定位到`Enemies`文件夹。
- en: Create a new folder inside `Enemies` and name it `bee.atlas`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Enemies`内部创建一个新的文件夹，并将其命名为`bee.atlas`。
- en: Locate the `bee.png` and `bee_fly.png` images inside `Enemies` and copy them
    into your new `bee.atlas` folder. You should now have a folder named `bee.atlas`
    containing the two bee PNG files. This is all you need to do to create a new texture
    atlas – simply place your related images into a new folder with the `.atlas` suffix.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Enemies`中找到`bee.png`和`bee_fly.png`图像，并将它们复制到你的新`bee.atlas`文件夹中。现在你应该有一个名为`bee.atlas`的文件夹，其中包含两个蜜蜂PNG文件。创建新的纹理图集你所需要做的就是将相关的图像放置到一个带有`.atlas`后缀的新文件夹中。
- en: Add the atlas to your project. In Xcode, right-click on the project folder in
    the project navigator and click **Add Files…**, as we did earlier for our single
    bee texture.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图集添加到你的项目中。在Xcode中，在项目导航器中右键单击项目文件夹，然后点击**添加文件…**，就像我们之前为单个蜜蜂纹理所做的那样。
- en: Find the `bee.atlas` folder and select the folder itself.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`bee.atlas`文件夹，并选择文件夹本身。
- en: Check **Copy items if needed**, then click **Add**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**如果需要则复制项目**，然后点击**添加**。
- en: The texture atlas will appear in the project navigator. Good work; we organized
    our bee assets into one collection and Xcode will automatically create the performance
    optimizations mentioned earlier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图集将出现在项目导航器中。做得好；我们将蜜蜂资源组织到一个集合中，Xcode将自动创建之前提到的性能优化。
- en: Updating our bee node to use the texture atlas
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新我们的蜜蜂节点以使用纹理图集
- en: We can actually run our project right now and see the same bee as before. Our
    old bee texture was `bee.png`, and a new `bee.png` exists in the texture atlas.
    Though we deleted the standalone `bee.png`, SpriteKit is smart enough to find
    the new `bee.png` in the texture atlas.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上现在可以运行我们的项目，看到之前相同的蜜蜂。我们旧的蜜蜂纹理是`bee.png`，而一个新的`bee.png`存在于纹理图集中。尽管我们删除了独立的`bee.png`，但SpriteKit足够智能，能够在纹理图集中找到新的`bee.png`。
- en: 'We should make sure our texture atlas is working, and that we successfully
    deleted the old individual `bee.png`. In `GameScene.swift`, change our `SKSpriteNode`
    instantiation line to use the new `bee_fly.png` graphic in the texture atlas:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该确保我们的纹理图集正在正常工作，并且我们已经成功删除了旧的单独的`bee.png`。在`GameScene.swift`中，将我们的`SKSpriteNode`实例化行更改为使用纹理图集中的新`bee_fly.png`图形：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the project again. You should see a different bee image, its wings held
    lower than before. This is the second frame of the bee animation. Next, we will
    learn to animate between the two frames to create an animated sprite.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。你应该看到不同的蜜蜂图像，它的翅膀比之前更低。这是蜜蜂动画的第二帧。接下来，我们将学习如何在两个帧之间进行动画，以创建一个动画精灵。
- en: Iterating through texture atlas frames
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历纹理图集帧
- en: 'We need to study one more texture atlas technique: we can quickly flip through
    multiple sprite frames to make our bee come alive with motion. We now have two
    frames of our bee in flight; it should appear to hover in place if we switch back
    and forth between these frames.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要学习一种额外的纹理图集技术：我们可以快速翻阅多个精灵帧，让我们的蜜蜂通过动作变得生动起来。我们现在有两个蜜蜂在飞行中的帧；如果我们在这两个帧之间切换，它应该看起来像是悬停在原地。
- en: 'Our node will run a new `SKAction` to animate between the two frames. Update
    your `didMoveToView` function to match mine (I removed some older comments to
    save space):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小结点将运行一个新的`SKAction`在两个帧之间进行动画。更新你的`didMoveToView`函数以匹配我的（我移除了一些旧的注释以节省空间）：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the project. You will see our bee flap its wings back and forth – cool!
    You have learned the basics of sprite animation with texture atlases. We will
    create increasingly complicated animations using this same technique later in
    the book. For now, pat yourself on the back. The result may seem simple, but you
    have unlocked a major building block towards your first SpriteKit game!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你会看到我们的蜜蜂翅膀一上一下地拍打——酷！你已经学会了使用纹理图集进行精灵动画的基础。我们将在本书的后面使用相同的技巧创建越来越复杂的动画。现在，给自己鼓掌。结果可能看起来很简单，但你已经解锁了通往你的第一个SpriteKit游戏的主要构建块！
- en: Putting it all together
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些整合在一起
- en: First, we learned how to use actions to move, scale, and rotate our sprites.
    Then, we explored animating through multiple frames, bringing our sprite to life.
    Let us now combine these techniques to fly our bee back and forth across the screen,
    flipping the texture at each turn.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们学习了如何使用动作来移动、缩放和旋转我们的精灵。然后，我们探索了通过多个帧进行动画，让我们的精灵栩栩如生。现在，让我们将这些技术结合起来，让我们的蜜蜂在屏幕上飞来飞去，每次转弯时翻转纹理。
- en: 'Add this code at the bottom of the `didMoveToView` function, beneath the `bee.runAction(beeAction)`
    line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`didMoveToView`函数的底部添加此代码，在`bee.runAction(beeAction)`行之下：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the project. You will see the bee flying back and forth, flapping its wings.
    You have officially learned the fundamentals of animation in SpriteKit! We will
    build on this knowledge to create a rich, animated game world for our players.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你会看到蜜蜂在飞来飞去，拍打翅膀。你正式学会了SpriteKit中的动画基础！我们将在此基础上构建，为我们的玩家创建一个丰富的动画游戏世界。
- en: Centering the camera on a sprite
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将相机中心对准精灵
- en: Games often require that the camera follows the player sprite as it moves through
    space. We definitely want this camera behavior for Pierre, our penguin character,
    whom we will soon be adding to the game. Since SpriteKit does not come with built-in
    camera functionality, we will create our own structure to simulate the effect
    we want.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常需要相机跟随玩家精灵在空间中的移动。我们确实希望我们的企鹅角色皮埃尔有这种行为，我们很快就会将其添加到游戏中。由于SpriteKit没有内置相机功能，我们将创建自己的结构来模拟我们想要的效果。
- en: One way we could accomplish this is by keeping Pierre in one position and moving
    every other object past him. This is effective, yet semantically confusing, and
    can cause errors when you are positioning game objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现这一目标的一种方法是将皮埃尔保持在同一位置，并将其他每个对象移动过他。这是有效的，但在语义上可能有些混乱，并且在定位游戏对象时可能会引起错误。
- en: Creating a new world
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新世界
- en: I prefer to create a world node and attach all of our game nodes to it (instead
    of directly to the scene). We can move Pierre forward through the world and simply
    reposition the world node so that Pierre is always at the center of our device's
    viewport. All of our enemies, power-ups, and structures will be children of the
    world node, and will appear to move past the screen as we scroll through the world.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢创建一个世界节点，并将所有我们的游戏节点附加到它上（而不是直接附加到场景）。我们可以通过世界将皮埃尔向前移动，并简单地重新定位世界节点，以便皮埃尔始终位于我们设备视口的中心。所有我们的敌人、道具和结构都将作为世界节点的子节点，并且在我们滚动世界时看起来像是在屏幕上移动。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Each sprite node's position is always relative to its direct parent. When you
    change a node's position, all of its child nodes come along for the ride. This
    is very handy behavior for simulating our camera.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个精灵节点的位置始终相对于其直接父节点。当您更改节点的位置时，所有子节点都会随之移动。这对于模拟我们的相机来说是一个非常方便的行为。
- en: 'This diagram illustrates a simplified version of this technique with some made-up
    numbers:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了该技术的简化版本，并使用了一些虚构的数字：
- en: '![Creating a new world](img/Image_B04532_02_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![创建新世界](img/Image_B04532_02_06.jpg)'
- en: 'You can find the code for our camera functionality in the following code block.
    Read the comments for a detailed explanation. This is just a quick recap of the
    changes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码块中找到我们相机功能的代码。阅读注释以获取详细说明。这只是一个快速回顾更改：
- en: Our `didMoveToView` function was becoming too crowded. I broke out our flying
    bee code into a new function named `addTheFlyingBee`. Later, we will encapsulate
    game objects, such as bees, into their own classes.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`didMoveToView`函数变得越来越拥挤。我将我们的飞行蜜蜂代码拆分到一个名为`addTheFlyingBee`的新函数中。稍后，我们将游戏对象，如蜜蜂，封装到它们自己的类中。
- en: 'I created two new constants on the `GameScene` class: the world node and the
    bee node.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我在`GameScene`类中创建了两个新的常量：世界节点和蜜蜂节点。
- en: I updated the `didMoveToView` function. It adds the world node to the scene's
    node tree, and calls the new `addTheFlyingBee` function.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我更新了`didMoveToView`函数。它将世界节点添加到场景的节点树中，并调用新的`addTheFlyingBee`函数。
- en: Inside the new bee function, I removed the bee constant, as `GameScene` now
    declares it above as its own property.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的蜜蜂函数内部，我移除了蜜蜂常量，因为`GameScene`现在将其声明为其自己的属性。
- en: Inside the new bee function, instead of adding the bee node to the scene, with
    `self.addChild(bee)`, we want to add it to the world, with `world.addChild(bee)`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的蜜蜂函数内部，我们不是通过`self.addChild(bee)`将蜜蜂节点添加到场景中，而是想通过`world.addChild(bee)`将其添加到世界中。
- en: 'We are implementing a new function: `didSimulatePhysics`. SpriteKit calls this
    function every frame after performing physics calculations and adjusting positions.
    It is a great place to update our world position. The math to change the world
    position resides in this new function.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在实现一个新的函数：`didSimulatePhysics`。SpriteKit在执行物理计算和调整位置后，每帧都会调用此函数。这是一个更新我们世界位置的好地方。更改世界位置的数学计算位于这个新函数中。
- en: 'Please update your entire `GameScene.swift` file to match mine:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请更新您的整个`GameScene.swift`文件以匹配我的：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the game. You should see our bee stuck directly at the center of the screen,
    flipping back and forth every two seconds.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏。您应该看到我们的蜜蜂直接固定在屏幕中心，每两秒翻转一次。
- en: '![Creating a new world](img/Image_B04532_02_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![创建新世界](img/Image_B04532_02_07.jpg)'
- en: The bee is actually changing position, just as before, but the world is compensating
    to keep the bee centered on the screen. When we add more game objects in [Chapter
    3](ch03.html "Chapter 3. Mix in the Physics"), *Mix in the Physics*, our bee will
    appear to fly as the entire world pans past the screen.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜蜂实际上正在改变位置，就像之前一样，但世界正在补偿以保持蜜蜂在屏幕中心。当我们[第3章](ch03.html "第3章。加入物理")中添加更多游戏对象时，*加入物理*，蜜蜂看起来就像整个世界在屏幕上滚动时在飞行。
- en: Checkpoint 2-B
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 2-B
- en: 'We have made many changes to our project in this chapter. If you would like
    to download my project to this point, do so here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对项目进行了许多更改。如果您想下载到这一点的项目，请在此处操作：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-2](http://www.thinkingswiftly.com/game-development-with-swift/chapter-2)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[Swift 游戏开发](http://www.thinkingswiftly.com/game-development-with-swift/chapter-2)'
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have gained foundational knowledge of sprites, nodes, and actions in SpriteKit
    and already taken huge strides towards your first game with Swift.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经获得了SpriteKit中精灵、节点和动作的基础知识，并且已经朝着用Swift制作您的第一个游戏迈出了巨大的步伐。
- en: You configured your project for landscape orientation, drew your first sprite,
    and then made it move, spin, and scale. You added a bee texture to your sprite,
    created an image atlas, and animated through the frames of flight. Finally, you
    built a world node to keep the gameplay centered on the player. Terrific work!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您已为项目配置了横幅方向，绘制了您的第一个精灵，然后让它移动、旋转和缩放。您为精灵添加了蜜蜂纹理，创建了一个图像图集，并通过飞行帧进行动画。最后，您构建了一个世界节点，以使游戏玩法始终围绕玩家进行。做得好！
- en: In the next chapter, we will use SpriteKit's physics engine to assign weight
    and gravity to our world, spawn more flying characters, and create the ground
    and sky.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 SpriteKit 的物理引擎为我们的世界分配重量和重力，生成更多飞行角色，并创建地面和天空。
