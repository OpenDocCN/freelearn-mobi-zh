- en: Chapter 2. Sprites, Camera, Actions!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing with SpriteKit is a breeze. We are free to focus on building great gameplay
    experiences while SpriteKit performs the mechanical work of the **game loop**.
    To draw an item to the screen, we create a new instance of a SpriteKit node. These
    nodes are simple; we attach a child node to our scene, or to existing nodes, for
    each item we want to draw. Sprites, particle emitters, and text labels are all
    considered nodes in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The game loop is a common game design pattern used to constantly update the
    game many times per second, and to maintain the same gameplay speed on fast or
    slow hardware.
  prefs: []
  type: TYPE_NORMAL
- en: SpriteKit wires new nodes into the game loop automatically. As you gain expertise
    with SpriteKit, you may wish to explore the game loop further to understand what
    is going on "under the hood".
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing your first sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Animation: movement, scaling, and rotation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing art into texture atlases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centering the camera on a sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharpening our pencils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four quick items to take care of before we start drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will design our game to use landscape screen orientations, we will
    disable the portrait view altogether:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With your game project open in Xcode, select the overall project folder in the
    project navigator (the top-most item).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see your project settings in the main frame of Xcode. Under **Deployment
    Info**, find the **Device Orientation** section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **Portrait** option, as shown in the following screenshot:![Sharpening
    our pencils](img/Image_B04532_02_01.jpg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The SpriteKit template generates a visual layout file for arranging sprites
    in our scene. We will not need it; we will use the SpriteKit visual editor later
    when we explore level design. To delete this extra file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `GameScene.sks` in the project navigator and choose **delete**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Move to Trash** in the dialog window.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to resize our scene to fit the new landscape view. Follow these steps
    to resize the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `GameViewController.swift` from the project navigator and locate the `viewDidLoad`
    function inside the `GameViewController` class. The `viewDidLoad` function is
    going to fire before the game realizes it is in landscape view, so we need to
    use a function that fires later in the startup process. Delete `viewDidLoad` completely,
    removing all of its code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace `viewDidLoad` with a new function named `viewWillLayoutSubviews`. Do
    not worry about understanding every line right now; we are just configuring our
    project. Use this code for `viewWillLayoutSubviews`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, in `GameViewController.swift`, find the `supportedInterfaceOrientations`
    function and reduce it to this code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, each chapter provides checkpoint links you can use to download
    the example project to that point.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We should double-check that we are ready to move on. Try to run our clean project
    in the simulator using the toolbar play button or the *command* + *r* keyboard
    shortcut. After loading, the simulator should switch to landscape view with a
    blank gray background (and with the node and FPS counter in the bottom right).
    If the project will not run, or you still see "**Hello World**", you will need
    to retrace your steps from the end of [Chapter 1](ch01.html "Chapter 1. Designing
    Games with Swift"), *Designing Games with Swift*, to finish your project preparation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checkpoint 2- A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to download my project to this point, you can do so from this URL:
    [http://www.thinkingswiftly.com/game-development-with-swift/chapter-2](http://www.thinkingswiftly.com/game-development-with-swift/chapter-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing your first sprite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to write some game code – fantastic! Open your `GameScene.swift`
    file and find the `didMoveToView` function. Recall that this function fires every
    time the game switches to this scene. We will use this function to get familiar
    with the `SKSpriteNode` class. You will use `SKSpriteNode` extensively in your
    game, whenever you want to add a new 2D graphic entity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term sprite refers to a 2D graphic or animation that moves around the screen
    independently from the background. Over time, the term has developed to refer
    to any game object on the screen in a 2D game. We will create and draw your first
    sprite in this chapter: a happy little bee.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a SKSpriteNode class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by drawing a blue square to the screen. The `SKSpriteNode` class
    can draw both texture graphics and solid blocks of color. It is often helpful
    to prototype your new game ideas with blocks of color before you spend time with
    artwork. To draw the blue square, add an instance of `SKSpriteNode` to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and run the project. You should see a similar small blue square appear
    in your simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a SKSpriteNode class](img/Image_B04532_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift allows you to define variables as constants, which can be assigned a value
    only once. For best performance, use `let` to declare constants whenever possible.
    Declare your variables with `var` when you need to alter the value later in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding animation to your Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive back in to sprite theory, we should have some fun with our blue
    square. SpriteKit uses action objects to move sprites around the screen. Consider
    this example: if our goal is to move the square across the screen, we must first
    create a new action object to describe the animation. Then, we instruct our sprite
    node to execute the action. I will illustrate this concept with many examples
    in the chapter. For now, add this code in the `didMoveToView` function, below
    the `self.addChild(mySprite)` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run the project. You will see our blue square slide across the screen towards
    the (100,100) position. This action is re-usable; any node in your scene can execute
    this action to move to the (100,100) position. As you can see, SpriteKit does
    a lot of the heavy lifting for us when we need to animate node properties.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inbetweening, or tweening, uses the engine to animate smoothly between a start
    frame and an end frame. Our `moveTo` animation is a tween; we provide the start
    frame (the sprite's original position) and the end frame (the new destination
    position). SpriteKit generates the smooth transition between our values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try some other actions. The `SKAction.moveTo` function is only one of
    many options. Try replacing the `demoAction` line with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the project. You will see our blue square grow to four times its original
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Sequencing multiple animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can execute actions together simultaneously or one after the each other
    with action groups and sequences. For instance, we can easily scale our sprite
    larger and spin it at the same time. Delete all of our action code so far and
    replace it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the project, you will see a spinning, growing square. Terrific!
    If you want to run these actions in sequence (rather than at the same time) change
    `SKAction.group` to `SKAction.sequence`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run the code and watch as your square first grows and then spins. Good. You
    are not limited to two actions; we can group or sequence as many actions together
    as we need.
  prefs: []
  type: TYPE_NORMAL
- en: We have only used a few actions so far; feel free to explore the `SKAction`
    class and try out different action combinations before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Recapping your first sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Congratulations, you have learned to draw a non-textured sprite and animate
    it with SpriteKit actions. Next, we will explore some important positioning concepts,
    and then add game art to our sprites. Before you move on, make sure your `didMoveToView`
    function matches with mine, and your sequenced animation is firing properly. Here
    is my code up to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The story on positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpriteKit uses a grid of points to position nodes. In this grid, the bottom
    left corner of the scene is (0,0), with a positive X-axis to the right and a positive
    Y-axis to the top.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, on the individual sprite level, (0,0) refers to the bottom left corner
    of the sprite, while (1,1) refers to the top right corner.
  prefs: []
  type: TYPE_NORMAL
- en: Alignment with anchor points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each sprite has an `anchorPoint` property, or an origin. The `anchorPoint` property
    allows you to choose which part of the sprite aligns to the sprite's overall position.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default anchor point is (0.5,0.5), so a new `SKSpriteNode` centers perfectly
    on its position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let us examine the blue square sprite we just drew on the
    screen. Our sprite is 50 pixels wide and 50 pixels tall, and its position is (300,300).
    Since we have not modified the `anchorPoint` property, its anchor point is (0.5,0.5).
    This means the sprite will be perfectly centered over the (300,300) position on
    the scene''s grid. Our sprite''s left edge begins at 275 and the right edge terminates
    at 325\. Likewise, the bottom starts at 275 and the top ends at 325\. The following
    diagram illustrates our block''s position on the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Alignment with anchor points](img/Image_B04532_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Why do we prefer centered sprites by default? You may think it simpler to position
    elements by their bottom left corner with an `anchorPoint` property setting of
    (0,0). However, the centered behavior benefits us when we scale or rotate sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: When we scale a sprite with an `anchorPoint` property of (0,0) it will only
    expand up the y-axis and out the x-axis. Rotation actions will swing the sprite
    in wide circles around its bottom left corner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A centered sprite, with the default `anchorPoint` property of (0.5, 0.5), will
    expand or contract equally in all directions when scaled and will spin in place
    when rotated, which is usually the desired effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some cases when you will want to change an anchor point. For instance,
    if you are drawing a rocket ship, you may want the ship to rotate around the front
    nose of its cone, rather than its center.
  prefs: []
  type: TYPE_NORMAL
- en: Adding textures and game art
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to take a screenshot of your blue box for your own enjoyment later.
    I absolutely love reminiscing over old screenshots of my finished games when they
    were nothing more than simple colored blocks sliding around the screen. Now it
    is time to move past that stage and attach some fun artwork to our sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the free assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am providing a downloadable pack for all of the art assets I use in this book.
    I recommend you use these assets so you will have everything you need for our
    demo game. Alternatively, you are certainly free to create your own art for your
    game if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'These assets come from an outstanding public domain asset pack from Kenney
    Game Studio. I am providing a small subset of the asset pack that we will use
    in our game. Download the game art from this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/assets](http://www.thinkingswiftly.com/game-development-with-swift/assets)'
  prefs: []
  type: TYPE_NORMAL
- en: More exceptional art
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you like the art, you can download over 16,000 game assets in the same style
    for a small donation at [http://kenney.itch.io/kenney-donation](http://kenney.itch.io/kenney-donation).
    I do not have an affiliation with Kenney; I just find it admirable that he has
    released so much public domain artwork for indie game developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As CC0 assets, you can copy, modify, and distribute the art, even for commercial
    purposes, all without asking permission. You can read the full license here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://creativecommons.org/publicdomain/zero/1.0/](https://creativecommons.org/publicdomain/zero/1.0/)'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing your first textured sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us use some of the graphics you just downloaded. We will start by creating
    a bee sprite. We will add the bee texture to our project, load the image onto
    a `SKSpriteNode` class, and then size the node for optimum sharpness on retina
    screens.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the bee image to your project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to add the image files to our Xcode project before we can use them
    in the game. Once we add the images, we can reference them by name in our code;
    SpriteKit is smart enough to find and implement the graphics. Follow these steps
    to add the bee image to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your project in the project navigator and click on **Add Files
    to "Pierre Penguin Escapes the Antarctic"** (or the name of your game). Refer
    to this screenshot to find the correct menu item:![Adding the bee image to your
    project](img/Image_B04532_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the asset pack you downloaded and locate the `bee.png` image inside
    the `Enemies` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Copy items if needed**, then click **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see `bee.png` in your project navigator.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images with SKSpriteNode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is quite easy to draw images to the screen with `SKSpriteNode`. Start by
    clearing out all of the code we wrote for the blue square inside the `didMoveToView`
    function in `GameScene.swift`. Replace `didMoveToView` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the project and witness our glorious bee – great work!
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading images with SKSpriteNode](img/Image_B04532_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Designing for retina
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may notice that our bee image is quite blurry. To take advantage of retina
    screens, assets need to be twice the pixel dimensions of their node's size property
    (for most retina screens), or three times the node size for the iPhone 6 Plus.
    Ignore the height for a moment; our bee node is 100 points wide but the PNG file
    is only 56 pixels wide. The PNG file needs to be 300 pixels wide to look sharp
    on the iPhone 6 Plus, or 200 pixels wide to look sharp on 2x retina devices.
  prefs: []
  type: TYPE_NORMAL
- en: SpriteKit will automatically resize textures to fit their nodes, so one approach
    is to create a giant texture at the highest retina resolution (three times the
    node size) and let SpriteKit resize the texture down for lower density screens.
    However, there is a considerable performance penalty, and older devices can even
    run out of memory and crash from the huge textures.
  prefs: []
  type: TYPE_NORMAL
- en: The ideal asset approach
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These double- and triple-sized retina assets can be confusing to new iOS developers.
    To solve this issue, Xcode normally lets you provide three image files for each
    texture. For example, our bee node is currently 100 points wide and 100 points
    tall. In a perfect world, you would provide the following images to Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bee.png` (100 pixels by 100 pixels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bee@2x.png` (200 pixels by 200 pixels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bee@3x.png` (300 pixels by 300 pixels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is currently an issue that prevents 3x textures from working
    correctly with **texture atlases**. Texture atlases group textures together and
    increase rendering performance dramatically (we will implement our first texture
    atlas in the next section). I hope that Apple will upgrade texture atlases to
    support 3x textures in Swift 2\. For now, we need to choose between texture atlases
    and 3x assets for the iPhone 6 Plus.
  prefs: []
  type: TYPE_NORMAL
- en: My solution for now
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In my opinion, texture atlases and their performance benefits are key features
    of SpriteKit. I will continue using texture atlases, thus serving 2x images to
    the iPhone 6 Plus (which still looks fairly sharp). This means that we will not
    be using any 3x assets in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further simplifying matters, Swift only runs on iOS7 and higher. The only non-retina
    devices that run iOS7 are the aging iPad 2 and iPad mini 1st generation. If these
    older devices are important for your finished games, you should create both standard
    and 2x images for your games. Otherwise, you can safely ignore non-retina assets
    with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that we will only use double-sized images in this book. The images
    in the downloadable asset bundle forgo the 2x suffix, since we are only using
    this size. Once Apple updates texture atlases to use 3x assets, I recommend that
    you switch to the methodology outlined in *The ideal asset approach* section for
    your games.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on with retina in SpriteKit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our bee image illustrates how this all works:'
  prefs: []
  type: TYPE_NORMAL
- en: Because we set an explicit node size, SpriteKit automatically resizes the bee
    texture to fit our 100-point wide, 100-point tall sized node. This automatic size-to-fit
    is very handy, but notice that we have actually slightly distorted the aspect
    ratio of the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do not set an explicit size, SpriteKit sizes the node (in points) to the
    match texture's dimensions (in pixels). Go ahead and delete the line that sets
    the size for our bee node and re-run the project. SpriteKit maintains the aspect
    ratio automatically, but the smaller bee is still fuzzy. That is because our new
    node is 56 points by 48 points, matching our PNG file's pixel dimensions of 56
    pixels by 48 pixels . . . yet our PNG file needs to be 112 pixels by 96 pixels
    for a sharp image at this node size on 2x retina screens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We want a smaller bee anyway, so we will resize the node rather than generate
    larger artwork in this case. Set the `size` property of your bee node, in points,
    to half the size of the texture''s pixel resolution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project and you will see a smaller, crystal sharp bee, as in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with retina in SpriteKit](img/Image_B04532_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Great! The important concept here is to design your art files at twice the pixel
    resolution of your node point sizes to take advantage of 2x retina screens, or
    three times the point sizes to take full advantage of the iPhone 6 Plus. Now we
    will look at organizing and animating multiple sprite frames.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will quickly overrun our project navigator with image files if we add all
    our textures as we did with our bee. Luckily, Xcode provides several solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Images.xcassets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can store images in an `.xcassets` file and refer to them easily from our
    code. This is a good place for our background images:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Images.xcassets` from your project navigator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not need to add any images here now but, in the future, you can drag image
    files directly into the image list, or right-click, then **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the SpriteKit demo's spaceship image is stored here. We do not need
    it anymore, so we can right-click on it and choose **Removed Selected Items**
    to delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collecting art into texture atlases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use texture atlases for most of our in-game art. Texture atlases organize
    assets by collecting related artwork together. They also increase performance
    by optimizing all of the images inside each atlas as if they were one texture.
    SpriteKit only needs one draw call to render multiple images out of the same texture
    atlas. Plus, they are very easy to use! Follow these steps to build your bee texture
    atlas:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to remove our old bee texture. Right-click on `bee.png` in the project
    navigator and choose **Delete**, then **Move to Trash**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Finder, browse to the asset pack you downloaded and locate the `Enemies`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder inside `Enemies` and name it `bee.atlas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `bee.png` and `bee_fly.png` images inside `Enemies` and copy them
    into your new `bee.atlas` folder. You should now have a folder named `bee.atlas`
    containing the two bee PNG files. This is all you need to do to create a new texture
    atlas – simply place your related images into a new folder with the `.atlas` suffix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the atlas to your project. In Xcode, right-click on the project folder in
    the project navigator and click **Add Files…**, as we did earlier for our single
    bee texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `bee.atlas` folder and select the folder itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Copy items if needed**, then click **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The texture atlas will appear in the project navigator. Good work; we organized
    our bee assets into one collection and Xcode will automatically create the performance
    optimizations mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our bee node to use the texture atlas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can actually run our project right now and see the same bee as before. Our
    old bee texture was `bee.png`, and a new `bee.png` exists in the texture atlas.
    Though we deleted the standalone `bee.png`, SpriteKit is smart enough to find
    the new `bee.png` in the texture atlas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should make sure our texture atlas is working, and that we successfully
    deleted the old individual `bee.png`. In `GameScene.swift`, change our `SKSpriteNode`
    instantiation line to use the new `bee_fly.png` graphic in the texture atlas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the project again. You should see a different bee image, its wings held
    lower than before. This is the second frame of the bee animation. Next, we will
    learn to animate between the two frames to create an animated sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through texture atlas frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to study one more texture atlas technique: we can quickly flip through
    multiple sprite frames to make our bee come alive with motion. We now have two
    frames of our bee in flight; it should appear to hover in place if we switch back
    and forth between these frames.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our node will run a new `SKAction` to animate between the two frames. Update
    your `didMoveToView` function to match mine (I removed some older comments to
    save space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the project. You will see our bee flap its wings back and forth – cool!
    You have learned the basics of sprite animation with texture atlases. We will
    create increasingly complicated animations using this same technique later in
    the book. For now, pat yourself on the back. The result may seem simple, but you
    have unlocked a major building block towards your first SpriteKit game!
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we learned how to use actions to move, scale, and rotate our sprites.
    Then, we explored animating through multiple frames, bringing our sprite to life.
    Let us now combine these techniques to fly our bee back and forth across the screen,
    flipping the texture at each turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code at the bottom of the `didMoveToView` function, beneath the `bee.runAction(beeAction)`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the project. You will see the bee flying back and forth, flapping its wings.
    You have officially learned the fundamentals of animation in SpriteKit! We will
    build on this knowledge to create a rich, animated game world for our players.
  prefs: []
  type: TYPE_NORMAL
- en: Centering the camera on a sprite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games often require that the camera follows the player sprite as it moves through
    space. We definitely want this camera behavior for Pierre, our penguin character,
    whom we will soon be adding to the game. Since SpriteKit does not come with built-in
    camera functionality, we will create our own structure to simulate the effect
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: One way we could accomplish this is by keeping Pierre in one position and moving
    every other object past him. This is effective, yet semantically confusing, and
    can cause errors when you are positioning game objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I prefer to create a world node and attach all of our game nodes to it (instead
    of directly to the scene). We can move Pierre forward through the world and simply
    reposition the world node so that Pierre is always at the center of our device's
    viewport. All of our enemies, power-ups, and structures will be children of the
    world node, and will appear to move past the screen as we scroll through the world.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each sprite node's position is always relative to its direct parent. When you
    change a node's position, all of its child nodes come along for the ride. This
    is very handy behavior for simulating our camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram illustrates a simplified version of this technique with some made-up
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new world](img/Image_B04532_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can find the code for our camera functionality in the following code block.
    Read the comments for a detailed explanation. This is just a quick recap of the
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Our `didMoveToView` function was becoming too crowded. I broke out our flying
    bee code into a new function named `addTheFlyingBee`. Later, we will encapsulate
    game objects, such as bees, into their own classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I created two new constants on the `GameScene` class: the world node and the
    bee node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I updated the `didMoveToView` function. It adds the world node to the scene's
    node tree, and calls the new `addTheFlyingBee` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the new bee function, I removed the bee constant, as `GameScene` now
    declares it above as its own property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the new bee function, instead of adding the bee node to the scene, with
    `self.addChild(bee)`, we want to add it to the world, with `world.addChild(bee)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are implementing a new function: `didSimulatePhysics`. SpriteKit calls this
    function every frame after performing physics calculations and adjusting positions.
    It is a great place to update our world position. The math to change the world
    position resides in this new function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please update your entire `GameScene.swift` file to match mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run the game. You should see our bee stuck directly at the center of the screen,
    flipping back and forth every two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new world](img/Image_B04532_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The bee is actually changing position, just as before, but the world is compensating
    to keep the bee centered on the screen. When we add more game objects in [Chapter
    3](ch03.html "Chapter 3. Mix in the Physics"), *Mix in the Physics*, our bee will
    appear to fly as the entire world pans past the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint 2-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have made many changes to our project in this chapter. If you would like
    to download my project to this point, do so here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-2](http://www.thinkingswiftly.com/game-development-with-swift/chapter-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have gained foundational knowledge of sprites, nodes, and actions in SpriteKit
    and already taken huge strides towards your first game with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: You configured your project for landscape orientation, drew your first sprite,
    and then made it move, spin, and scale. You added a bee texture to your sprite,
    created an image atlas, and animated through the frames of flight. Finally, you
    built a world node to keep the gameplay centered on the player. Terrific work!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use SpriteKit's physics engine to assign weight
    and gravity to our world, spawn more flying characters, and create the ground
    and sky.
  prefs: []
  type: TYPE_NORMAL
