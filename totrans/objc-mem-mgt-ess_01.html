<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Introduction to Objective-C Memory Management"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Introduction to Objective-C Memory Management</h1></div></div></div><p class="calibre8">In this chapter, we will concern ourselves principally with the core issues of the memory management problem as well as an Objective-C-based solution of it. We will look at the ownership and life cycle of the object. This basic idea is known as manual references counting, or <a id="id0" class="calibre1"/><span class="strong"><strong class="calibre2">Manual Retain Release</strong></span> (<span class="strong"><strong class="calibre2">MRR</strong></span>), where you need to claim and relinquish ownership of every object. It defines an object's life cycle. And finally, we'll take a look deeper into <span class="strong"><strong class="calibre2">NSObject</strong></span><a id="id1" class="calibre1"/> for a better understanding of what's going on.</p><p class="calibre8">We will cover the following topics in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Why do we need memory management in Objective-C?</li><li class="listitem">An object's ownership and life cycle</li><li class="listitem">The principles of reference counting</li><li class="listitem">What's a memory leak and why pay attention to it?</li></ul></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Introduction to Objective-C Memory Management">
<div class="book" title="Why do we need memory management in Objective-C?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Why do we need memory management in Objective-C?</h1></div></div></div><p class="calibre8">It does not matter what programming language is being used; the question of memory management always persists. In general, it is a question of resource management that cannot be avoided because memory is always a limited resource.</p><p class="calibre8">The scripting languages <a id="id2" class="calibre1"/>and Java, where <a id="id3" class="calibre1"/>memory management is handled by the virtual machine or application (where it is hidden from the code), are not always effective enough. While it is easier for the programmer this way, it can have a negative impact on resources, since you don't have an absolute control of it and there are objects still "living" when we don't need them anymore, plus these "living" objects still occupy precious memory space, which can be used by other objects. Additionally, depending on what you ask, another opinion is that an automatic memory management is the only right way to go.</p><p class="calibre8">Such talks usually<a id="id4" class="calibre1"/> start discussions like "Which is the best programming language?" and" What is the best way of memory management?". Let's leave that meaningless business for blogs' and forums' "Holy-Wars". Every tool has it's use in the correct context and Objective-C memory management concept is quite efficient in terms of both time cost savings and resource saving.</p><p class="calibre8">The memory in<a id="id5" class="calibre1"/> Objective-C, is managed in a different way from some of the widespread languages such as C/C++, Java, or C#, which are typically taught in schools as it introduces new concepts such as object ownership. Memory management is crucial for devices that run on a limited amount of memory such as mobile phones, smart watches, and so on, since effective memory management will allow you to squeeze every ounce of performance needed to run efficiently on these small devices, where memory is scarce on these devices.</p></div></div>
<div class="book" title="An object's ownership and life cycle"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>An object's ownership and life cycle</h1></div></div></div><p class="calibre8">The idea of <a id="id6" class="calibre1"/>object ownership abstraction is simple—one entity is simply responsible for another and an entity has the ability to own an object. When an entity owns an object, the entity is responsible to free that object too.</p><p class="calibre8">Let's go to our <a id="id7" class="calibre1"/>code example. If an object was created and used in the main function, then the main function is responsible for the object, as the following code listing demonstrates:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char *argv[]) {

  SomeObject *myOwnObject;
  // myOwnObject is created in main
   myOwnObject = [[SomeObject alloc] init];

    // myOwnObject can be used by other objects
  [anotherObject using:myOwnObject];
    
    // but main is responsible for releasing it
   [myOwnObject release];</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Downloading the example code</strong></span>
</p><p class="calibre8">You can download the example code files from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre8">What makes this concept a bit more complicated is that objects can be owned by more than one entity. So, an object may be created and owned in the main function and will also be used by another entity that will claim ownership of the object.</p><p class="calibre8">A common situation <a id="id8" class="calibre1"/>where you will see multiple object ownership is when you use arrays. Arrays are indexed lists of objects, and when an object is placed into an array, the <a id="id9" class="calibre1"/>array claims ownership of the object. So, if I create an object in the main function and then put that object into an array, both the main function and the array will claim ownership of the object and create a reference to it at the same time. Ownership and reference are different as an object references another object, which it does not own and both are responsible for cleaning up the object. The following code demonstrates this:</p><div class="informalexample"><pre class="programlisting">int main (int argc, char *argv[]) {

  SomeObject *myOwnObject;
  // myOwnObject is created in main
myOwnObject = [[SomeObject alloc] init];

// myOwnObject can be used by other objects
NSMutableArray *myArray;
// add my object to myArray    
myArray = [[NSMutableArray alloc] initWithObjects:myOwnObject, nil];
    
// main does not need myOwnObject any more
[myOwnObject release];

// but myOwnObject still is needed inside the array
[anotherObj usingArray: myArray];</pre></div><p class="calibre8">Just like objects in the real world, Objective-C objects are created; they live, and then go away when the application is closed. This is how the object life cycle works. Obviously, arrays have to claim the ownership on the object and prevent it to be deleted in the release method called in the main function.</p><p class="calibre8">However, what is the correct way for the entity to claim its rights on an object that it owns? Let's take a deeper look at the problem.</p></div>
<div class="book" title="Ownership of object and reference counting"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Ownership of object and reference counting</h1></div></div></div><p class="calibre8">To indicate the number of owners using objects, those objects are given a reference count.</p><p class="calibre8">At the<a id="id10" class="calibre1"/> beginning, the <a id="id11" class="calibre1"/>reference count of the object is <code class="email">1</code>. This happens because the function creating the object is going to use that object. When any entity needs to claim an ownership of the object, since that entity is going to access and use that object, it sends a retain message to it and its retain count is incremented by <code class="email">1</code>. When an entity is finished with the object, it sends the release message to the object and its retain count decrements by <code class="email">1</code>. As long as this object's reference count is higher than zero, some "things" are using it. When it comes to zero, the object is no longer useful for any of those "things", and it can be safely deallocated.</p><p class="calibre8">Let's return to the example with the object owned by an array. Explanations are given in the following code comments and diagram:</p><div class="informalexample"><pre class="programlisting">int main(int argc, char *argv[]) {

  SomeObject *myOwnObject;
  // myOwnObject is created in main
   myOwnObject = [[SomeObject alloc] init];
  // myOwnObject has retain count equal to 1

// myOwnObject can be used by other objects
NSMutableArray *myArray;
// add my object to myArray    
myArray = [[NSMutableArray alloc] initWithObjects:myOwnObject, nil];
//inside myOwnObject got another retain message
//and now its retain count equal 2
    
// main does not need myOwnObject any more
[myOwnObject release];
// release decrements retain count
// and now myOwnObject retain count now is 2-1 = 1

// but myOwnObject still is needed inside the array
[anotherObj usingArray: myArray];

[myArray release];
// on array destruction every object inside array gets release message

//myOwnObject retain count decreases this time to 0 and myOwnObject will be deleted together with the array</pre></div><p class="calibre8">The following diagram illustrates the principle of reference counting:</p><div class="mediaobject"><img src="../images/00002.jpeg" alt="Ownership of object and reference counting" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Forgetting<a id="id12" class="calibre1"/> to send a<a id="id13" class="calibre1"/> release message to an object before setting a pointer to point at something else will guarantee you a memory leak. In order to create an object before it's initiated, a chunk of the OS memory is allocated to store it. Also, if you send a <code class="email">release</code> statement to an object, which was not previously sent, a <code class="email">retain</code> statement is sent to the object. This will be considered as a <a id="id14" class="calibre1"/><span class="strong"><strong class="calibre2">premature deallocation</strong></span>, where the memory previously allocated to it is not related to it anymore. A lot of time is spent on debugging these issues, which can easily become very complex in large projects. If you don't follow some solid principles for memory management, you can often forget and quickly find yourself getting stuck for hours checking every retain and release statement. Even worse is if you're going through someone else's code, and they mess things up. Going through to fix memory management issues in someone else's code can take forever.</p></div>
<div class="book" title="What's a memory leak and why pay attention to it?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>What's a memory leak and why pay attention to it?</h1></div></div></div><p class="calibre8">A memory leak<a id="id15" class="calibre1"/> is when your program loses track of a piece of memory that was allocated and has forgotten to release it. The consequence is that the "leaked" memory will never be freed by the program. When more memory is leaked after a certain point in time, there will be no more free memory and this will cause your application to crash. Usually, this tends to happen when a piece of code does <code class="email">new</code>, <code class="email">malloc</code>, or <code class="email">alloc</code>, but never does a corresponding "delete", "free", or "release" respectively.</p><p class="calibre8">When you do <code class="email">new</code>, <code class="email">malloc</code>, or <code class="email">alloc</code>, what the operating system does is that it is giving your program a chunk of memory on the heap. The OS says, "Here, take this memory address and have this block of memory on it." Thus, you need to create a reference to that memory address (usually in the form of a pointer), depending on the OS, such as, "I'm done with this, it's not useful anymore" (by calling "free", "delete", or "release").</p><p class="calibre8">Memory leaks happen when you throw away your pointer to that memory. If your program does not retain where your memory is allocated on the heap, how can you even free it? The following line of code shows an example of a memory leak if you never call the release method on it:</p><div class="informalexample"><pre class="programlisting">NSMutableString *str = [[NSMutableString alloc] initWithString:@"Leaky"];</pre></div><p class="calibre8">So why should you care? At best, you're the dissipating memory that will be freed when the user quits your app. At worst, there could be a memory leak that happens in every screen. It would not be a great mode to end up your program, especially if the user lets it run for a long time. A program crash is very hard to debug as it can crash at random moments in your application as memory leaks are very unpredictable to replicate and creating an application that crashes often will lead to bad reviews of your program on the App Store, or through word of mouth, which is something that you do not want to happen.</p><p class="calibre8">This is why in the process of evolution, there are other methods of memory management in Objective-C, which you will find further in this book.</p></div>
<div class="book" title="What is an object within Objective-C?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>What is an object within Objective-C?</h1></div></div></div><p class="calibre8">How do things <a id="id16" class="calibre1"/>work inside Objective-C? <code class="email">NSObject</code> <a id="id17" class="calibre1"/>is the root class of most Objective-C class hierarchies, through it an object inherits basic methods and behaves like an Objective-C object. </p><p class="calibre8">This object is an instance of a class and can also be a member of a class or one of its derivatives. So, let's take a deeper look at <code class="email">NSObject</code>. In the early stage, Objective-C had a class called <code class="email">Object</code>. This had a method called <code class="email">+new</code>, which wrapped <code class="email">malloc()</code>, and a method called <code class="email">-free</code>. Since Objective-C objects were generally aliased and managing object life cycles became quite complex, this was troublesome.</p><p class="calibre8">NSObject is used by NeXT—Steve Job's second company, founded after he was fired from Apple in 1985—in order to provide reference counting, thus, dividing Object pointers in two categories: pointers that own references and pointers that do not own references. Those pointers that contribute towards the object's reference count are owning reference pointers. If there is a certainty that a reference is going to be held somewhere else for the duration of a variable's lifetime, a non-owning reference pointer can be used avoiding the additional overhead of reference count manipulation since a non-owning reference pointer does not have the added cost of keeping track of object ownership.</p><p class="calibre8">Non-owning reference pointers are often used for autoreleased values. Autorelease pools make it <a id="id18" class="calibre1"/>possible for a temporary object to receive a non-owning reference pointer in return. An object, by receiving an <code class="email">-autorelease</code> message is added to a list that will be deallocated afterwards, with the destruction of the current autorelease pool. You can call autorelease using the autorelease method as shown here:</p><div class="informalexample"><pre class="programlisting"> [myObject autorelease];</pre></div><p class="calibre8">The following table shows some description on the roles of autorelease and release:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Release type</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">The autorelease method</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">An object is <a id="id19" class="indexterm"/>sent a release message, but put in an autorelease pool and the object is released when the pool is drained later during the run loop, but still occupies memory</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">The release method</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">An object<a id="id20" class="indexterm"/> is released immediately and memory is freed after the object is released</p>
</td></tr></tbody></table></div><p class="calibre8">Any object that receives the autorelease message will be released when the autorelease pool is drained. Using autorelease instead of the normal release method will extend the lifetime of an object until the pool is drained at the end of the run loop.</p><p class="calibre8">At <span class="strong"><strong class="calibre2">Worldwide Developers Conference</strong></span> (<span class="strong"><strong class="calibre2">WWDC</strong></span>) 2011, Apple introduced ARC, the acronym of Automatic Reference Counting. It forces the compiler to handle the memory management calls at compile time instead of the conventional garbage collection functionality, which occurs during runtime. ARC also adds some things to the language model in general. It has been supported since iOS5, OS X 10.7, and by GNUstep.</p><p class="calibre8">First, what we will find out is that there are two NSObjects in Cocoa, a class and a protocol. Why is this so and what is the purpose of this? Let's look into classes and protocols.</p><p class="calibre8">In Objective-C, protocols define a set of behaviors that an object is expected to conform to in certain situations at runtime. For example, a table view object is expected to be able to communicate with a certain data source so that the table view will know what data and information to display. Protocols and classes do not share the same namespaces (a set of identifiers containing names, the names of classes and protocols, thus the same name can exist in different namespaces). It's possible to have both, which are unrelated at the language level, but have the same name. This is the case with NSObject.</p><p class="calibre8">If you look at the language, there are no places where you can use either a protocol or a class name. Using class names as the target of message sends, as type names, and in <code class="email">@interface</code> declarations is allowed. Likewise, it's possible to use protocols names in a few identical places; however, not in the same way. Having a protocol with the same name as a class won't result any issue.</p><p class="calibre8">It is impossible for root class to have a superclass as they are at the top of the hierarchy, so there is no superclass above a root class and NSObject class is one of them. And I give emphasis on saying <span class="strong"><em class="calibre9">one of them</em></span> because in comparison to other programming languages in Objective-C, it's perfectly possible to have the existence of multiple root classes.</p><p class="calibre8">Java's single root class is named <code class="email">java.lang.Object</code>, which is the parent ultimate class of any other. For this reason, any piece of code in Java, which comes from any object, has the basic methods added by <code class="email">java.lang.Object</code>.</p><p class="calibre8">Cocoa can have multiple root classes. Besides <code class="email">NSObject</code>, there is <code class="email">NSProxy</code><a id="id21" class="calibre1"/> and a few others root classes; and such root classes are, in part, the reason for the existence of the <code class="email">NSObject</code> protocol. The <code class="email">NSObject</code> protocol determines a specific set of basic methods, expecting their implementation by the others root classes, consequently, making those methods available whenever and wherever they are needed.</p><p class="calibre8">The <code class="email">NSObject</code> class is<a id="id22" class="calibre1"/> in accordance to the <code class="email">NSObject</code> protocol, which results in the implementation of this basic method:</p><div class="informalexample"><pre class="programlisting">   //for NSObject class 
  @interface NSObject &lt;NSObject&gt;</pre></div><p class="calibre8">Implementing the same method works for <code class="email">NSProxy</code>, which is also in accordance to the <code class="email">NSObject</code> protocol:</p><div class="informalexample"><pre class="programlisting">   // for NSProxy class @interface NSProxy &lt;NSObject&gt;</pre></div><p class="calibre8">Methods such as <a id="id23" class="calibre1"/>hash, description, <code class="email">isEqual</code>, <code class="email">isKindOfClass</code>, <code class="email">isProxy</code>, and others are found in the <code class="email">NSObject</code> protocol. <code class="email">NSProxy</code> to <code class="email">NSObject</code> protocol denotes that, implementing the basic <code class="email">NSObject</code> methods, it's still possible to count on <code class="email">NSProxy</code> instances.</p><p class="calibre8">Subclassing <code class="email">NSObject</code> would pull in a lot of baggage that may cause a problem. <code class="email">NSProxy</code> assists in order to prevent this by giving you a simpler superclass that doesn't have so much extra stuff in it.</p><p class="calibre8">The fact that the <code class="email">NSObject</code> protocol is useful for root classes isn't all that interesting for most Objective-C programming, for the simple fact that we don't make use of other root classes frequently. However, it will be very convenient when you need to make your own protocols.</p><p class="calibre8">Let's say, you have the following protocol:</p><div class="informalexample"><pre class="programlisting">    @protocol MyOwnProtocol
    - (void)myFunction;
    @end</pre></div><p class="calibre8">And there is a pointer to a simple object, <code class="email">myOwnObject</code>, that accords to it:</p><div class="informalexample"><pre class="programlisting">    id&lt;MyProtocol&gt; myOwnObject;</pre></div><p class="calibre8">You can tell this object to perform <code class="email">myFunction</code>:</p><div class="informalexample"><pre class="programlisting">    [myOwnObject myFunction];</pre></div><p class="calibre8">However, you cannot ask the object for its description:</p><div class="informalexample"><pre class="programlisting">    [myOwnObject description]; // no such method in the protocol</pre></div><p class="calibre8">And you can't check it for equality:</p><div class="informalexample"><pre class="programlisting">    [myOwnObject isEqual: anotherObject];
    // no such method in the protocol</pre></div><p class="calibre8">In general, you can't ask it to do any of the stuff that a normal object can do. There are times when this doesn't have any importance, but in some circumstances, you will wish to be able to perform this task.</p><p class="calibre8">As mentioned earlier, <code class="email">NSObject</code>, the <a id="id24" class="calibre1"/>root class of most Objective-C class hierarchies and through <code class="email">NSObjects</code>, your Objective-C classes can inherit an interface to the system and also gain the ability to behave as Objective-C objects. So, <code class="email">NSObject</code> is important if you want your objects to gain access to methods such as <code class="email">isEqual</code>, so on, and so forth. This is where the <code class="email">NSObject</code> protocol comes into the picture. Protocols can inherit from other protocols, which means that <code class="email">MyProtocol</code> can inherit from the <code class="email">NSObject</code> protocol:</p><div class="informalexample"><pre class="programlisting">    @protocol MyOwnProtocol &lt;NSObject&gt;
    - (void)myFunction;
    @end</pre></div><p class="calibre8">This says that not<a id="id25" class="calibre1"/> only do objects that conform to <code class="email">MyOwnProtocol</code> respond to <code class="email">myFunction</code>, but they also respond to all those common messages in the <code class="email">NSObject</code> protocol. Knowing that any object in your application directly or indirectly inherits from the <code class="email">NSObject</code> class, that it's in accordance to the <code class="email">NSObject</code> protocol, there is no imposition to any additional requirements on people implementing <code class="email">MyOwnProtocol</code>, while giving you the permission to use these basic methods on instances.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">The fact that there are two different NSObjects is abnormal for the frameworks; however, it starts to make sense when you go deeper into it. The <code class="email">NSObject</code> protocol grants the permission to all root classes that have the same basic methods, making, also, a very easy way to declare a protocol that also includes basic functionality expected from any object. The <code class="email">NSObject</code> class introduces it all together, since it's in accordance to the <code class="email">NSObject</code> protocol. One thing to note here is that a custom class that's created and does not inherit <code class="email">NSObject</code> can be considered as a root class, but once you make your custom class inherit from <code class="email">NSObject</code>, then the root class won't be your custom class anymore, and the root class will be <code class="email">NSObject</code>. However, generally, most of your custom classes should inherit from NSObjects; it will implement NSObject's functionality such as <code class="email">alloc</code>, <code class="email">init</code>, <code class="email">release</code>, and so on and without inheriting from NSObject, these functionalities need to be written and implemented by you.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you learned what memory management in Objective-C is and how it works. You also learned the best practices while working with Manual Retain Release, and got an introduction to Automatic Reference Counting, Objective-C Objects, and root classes. ARC basically can be considered as a compile time guard against memory leaks as the compiler will automatically write the release statements for you at compile time. So, there is no need to write verbose release statements in your code to keep it clean and terse.</p><p class="calibre8">One tip to note for coding with memory management is that whenever you do <code class="email">alloc</code> and <code class="email">init</code>, then write your release code after that and put it in its appropriate place in your class, you can forget to call the release method after writing some or fixing some bugs. So writing your object release statements after you do <code class="email">alloc</code> and <code class="email">init</code> will help you to keep memory leaks to a minimum so that you won't have a situation where you get a memory leak as you have forgotten to write your object release statement.</p><p class="calibre8">In the next chapter, you will learn more about ARC, how it works, its advantages, how to set up your projects to use ARC and memory models in Objective-C and UI Kit with ARC.</p></div></body></html>