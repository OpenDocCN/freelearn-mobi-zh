- en: '23'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with SwiftData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During Apple’s **World** **Wide Developer Conference** (**WWDC**) in 2023, they
    introduced **SwiftData**, an all-new framework for saving app data. Previously,
    developers had to use an editor to create data models, but SwiftData allows developers
    to describe data models and manipulate model instances using regular Swift code.
    Features such as relationship management, undo/redo support, iCloud synchronization,
    and more are provided automatically. In 2024, Apple added new APIs that enable
    developers to build custom data stores, work with transaction history, model indices
    and compound uniqueness constraints, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’re going to modify the *JRNL* app that you completed in
    *Chapter 16*, *Passing Data between View Controllers*, to save journal entries
    using SwiftData. This means that when you add new journal entries to the app,
    they will reappear the next time the app is launched.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll learn about SwiftData and its components. Next, you’ll modify
    the `JournalEntry` class to make it compatible with SwiftData and modify the `JournalListViewController`
    class to work with the modified `JournalEntry` class. After that, you’ll implement
    SwiftData by adding code that will allow you to read, write, and delete journal
    entries; and finally, you’ll modify the `JournalViewController` class to read,
    save, and delete stored journal entries.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned how to save app data using SwiftData
    and will be able to implement it in your own apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SwiftData
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the `JournalEntry` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing SwiftData components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the `JournalListViewController` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will continue working on the `JRNL` project that you modified in *Chapter
    16*, *Passing Data between View Controllers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource files and completed Xcode project for this chapter are in the
    `Chapter23` folder of the code bundle for this book, which can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition](https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://youtu.be/VFYb8Yohh6g](https://youtu.be/VFYb8Yohh6g%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by learning more about SwiftData.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SwiftData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftData is Apple’s all-new framework for saving app data to your device. It
    automatically provides relationship management, undo/redo support, iCloud synchronization,
    and more. You can model your data using regular Swift types, and SwiftData will
    then build a custom schema using your specified model and map its fields to device
    storage. You can query and filter your data using expressions that are type-checked
    by the compiler, resulting in fewer typos or mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about SwiftData at [https://developer.apple.com/documentation/swiftdata](https://developer.apple.com/documentation/swiftdata).
  prefs: []
  type: TYPE_NORMAL
- en: During WWDC 2024, Apple added new APIs to SwiftData. These enable you to model
    indices and compound unique constraints using macros, build custom data stores
    using your own document format, keep track of transaction history, and more.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about what’s new in SwiftData at [https://developer.apple.com/videos/play/wwdc2024/10137/](https://developer.apple.com/videos/play/wwdc2024/10137/).
  prefs: []
  type: TYPE_NORMAL
- en: Several steps are required to implement SwiftData for an app. First, existing
    classes are turned into models with the `@Model` macro. Primitive types such as
    `Bool`, `Int`, and `String` are supported, as well as complex value types such
    as structures and enumerations. Next, model attributes are customized as required
    using annotations such as `@Attribute(.unique)` to ensure the property’s value
    is unique and `@Attribute(.externalStorage)` to store the property’s value adjacent
    to model storage as binary data. Then, models to be persisted are specified and
    a `ModelContainer` instance is created, which manages an app’s schema and model
    storage configuration.
  prefs: []
  type: TYPE_NORMAL
- en: After that, a `ModelContext` instance is used to fetch, insert, and delete model
    instances and save any changes to device storage while the app is running. Finally,
    to fetch specific instances from device storage, a `FetchDescriptor` instance
    containing a search predicate and a sort order is used.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about preserving your app’s model data across launches at
    [https://developer.apple.com/documentation/swiftdata/preserving-your-apps-model-data-across-launches](https://developer.apple.com/documentation/swiftdata/preserving-your-apps-model-data-across-launches).
  prefs: []
  type: TYPE_NORMAL
- en: Before you implement SwiftData for the *JRNL* app, here’s an example to help
    you visualize what you need to do to save journal entries.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re saving a journal entry using Microsoft Word. You first create
    a new Word document template with the relevant fields for a journal entry. You
    then create new Word documents based on the templates and fill in the data. You
    make whatever changes are necessary, perhaps changing the text of the journal
    entry, or changing the photo. When you are happy with your document, you save
    it to the hard disk of your computer. The next time you want to view your journal
    entry, you search your hard disk for the relevant document and double-click it
    to open it in Word so you can see it once more.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of what you need to do, let’s review the steps required
    to implement SwiftData for your app.
  prefs: []
  type: TYPE_NORMAL
- en: First, you turn the existing `JournalEntry` class into a model, which is like
    a Microsoft Word template. You do this by annotating the `JournalEntry` class
    with the `@Model` macro. The properties of the `JournalEntry` class are like fields
    in the Microsoft Word template and you will customize properties with the `@Attribute`
    macro if required.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will create a `ModelContainer` instance, which will be used to store
    `JournalEntry` model instances on your device’s storage, and create a `ModelContext`
    instance, which will be used to store `JournalEntry` model instances in memory.
    This is like the way Microsoft Word files created from Microsoft Word templates
    can be stored on your computer’s hard disk or kept in memory as they are being
    edited.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you will add code so that when you create a new journal entry, a
    `JournalEntry` model instance is created and added to the `ModelContext` instance,
    which then coordinates with the `ModelContainer` instance to save it to device
    storage. This is like saving Word documents to your hard disk when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about how to build an app with SwiftData by watching the
    following video: [https://developer.apple.com/videos/play/wwdc2023/10154/](https://developer.apple.com/videos/play/wwdc2023/10154/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of how SwiftData works, you’ll use the
    `JournalEntry` class to create the `JournalEntry` model in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the JournalEntry class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, when you create a new journal entry using the Add New Journal Entry
    screen and click the **Save** button, the entry will appear on the Journal List
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31371_23_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.1: Simulator showing new entries added to the Journal List screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you quit and restart your app, the newly added entries will disappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31371_23_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.2: Simulator showing new entries disappearing after the app is relaunched'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the contents of the `journalEntries` array are only kept in
    memory and not saved to device storage when the app is closed. To resolve this,
    you will implement SwiftData for your app. The first step in implementing SwiftData
    is to create model objects from your existing `JournalEntry` class, modifying
    this and other classes in your app as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project navigator, click the **JournalEntry** file (located in the **Journal
    List Scene** | **Model** group). Import the `SwiftData` framework and annotate
    the `JournalEntry` class with the `@Model` macro, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Choose **Build** from Xcode’s **Product** menu. You will see error messages
    appear in the Navigator area. Click any one of the first three error messages
    to expand the macro and display the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_23_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.3: Editor area showing errors'
  prefs: []
  type: TYPE_NORMAL
- en: These errors appear because SwiftData at present does not support the `UIImage`
    class. To fix this, you will need to modify the `JournalEntry` class to use `Data`
    instances in place of `UIImage` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `photo` property in the `JournalEntry` class with a `photoData`
    property of type `Data?`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@Attribute(.externalStorage)` annotation will store the data for the photo
    in a binary file adjacent to the model data, which makes it more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will address the other error messages, which say **Cannot expand
    accessors on variable declared with ‘let’**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_23_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.4: Navigator area showing errors'
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, replace all the `let` keywords for the `JournalEntry` class
    properties with `var`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There will be an error in the initializer for the `JournalEntry` class. To
    fix it, modify the code in the initializer, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '****This statement will convert a `UIImage` instance into a `Data` instance
    using JPEG encoding, which can be stored in the `photoData` property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build the project now, more errors will appear. Click the **JournalEntryDetailViewController**
    file in the Project navigator. Modify the `viewDidLoad()` method as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code checks to see if the `JournalEntry` instance’s `photoData` property
    has a value. If this is the case, it is converted into a `UIImage` instance and
    assigned to the `photoImageView` instance’s `image` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **JournalListViewController** file in the Project navigator. Modify
    the `tableView(_:cellForRowAt:)` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code checks to see if the `JournalEntry` instance’s `photoData` property
    has a value. If this is the case, it is converted into a `UIImage` instance and
    assigned to `journalCell.photoImageView.image`. Since this process is repeated
    for every row in the table view and decoding JPEG data into a `UIImage` instance
    can be slow, a `Task` block is used to make this process asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: All errors should now be resolved. You may need to quit and reopen your project
    before all the errors disappear.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to build and run your project now, you would get an error because
    the SwiftData `ModelContainer` instance has not been created. You’ll learn how
    to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SwiftData components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have used the `JournalEntry` class to create a `JournalEntry` model,
    you will create a **singleton** class that contains a `ModelContainer` object
    and a `ModelContext` instance. You will then add methods to manipulate instances
    of the `JournalEntry` model stored in `ModelContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The term **singleton** means that there is only one instance of this class in
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `JRNL` folder in the Project navigator and choose **New File
    from Template...** from the pop-up menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**iOS** should already be selected. Choose **Swift File** and then click **Next**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this file `SharedData`. Click **Create**. The `SharedData` file appears
    in the Project navigator. Move the file so that it is under the `SceneDelegate`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code after the `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This lets you use the SwiftData framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the `import` statements to declare and define
    the `SharedData` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class creates a singleton instance that will be available throughout your
    app and assigns it to the `shared` static variable. It also creates and initializes
    `ModelContainer` and `ModelContext` instances and assigns them to the `container`
    and `context` properties, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll add methods for loading, adding, and deleting `JournalEntry` model
    instances. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the initializer to implement the `loadJournalEntries()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method returns an array of `JournalEntry` instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This statement creates a `FetchDescriptor` instance that specifies that all
    `JournalEntry` model instances stored in the `ModelContext` instance are to be
    fetched and sorted by date, from newest to oldest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This block of code gets all the `JournalEntry` model instances specified by
    the `FetchDescriptor` instance from the `ModelContext` instance and assigns them
    to `journalEntries`, a constant of type `[JournalEntry]`, which is then returned.
    If the operation fails, an empty array will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `saveJournalEntry(_:)` method by adding the following code before
    the final curly brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method inserts the `journalEntry` instance passed to it into the `ModelContext`
    instance as a `JournalEntry` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `deleteJournalEntry(_:)` method by adding the following code
    before the final curly brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method removes the corresponding `JournalEntry` model instance from the
    `ModelContext` instance.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve created a `SharedData` class that creates a `ModelContainer` instance
    and implemented methods to fetch, add, and delete `JournalEntry` model instances
    from a `ModelContext` object. You can build your app to test for errors, but you
    can’t run it yet.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ve implemented all the required SwiftData components in your
    app. In the next section, you’ll configure the `JournalListViewController` class
    to fetch all journal entries stored in the `ModelContainer` instance when the
    app is run, add new `JournalEntry` model instances to the `ModelContext` instance
    when you add a new journal entry, and remove `JournalEntry` model instances from
    the `ModelContext` instance when you delete a journal entry.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the JournalListViewController class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, when you added or removed journal entries from your app, the changes
    made would be gone when you stopped and ran the app again because the code in
    the `JournalListViewController` class had no way to save app data to your device.
    You will add code to the `JournalListViewController` class to save app data using
    SwiftData in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will update the `viewDidLoad()` method to fetch all journal entries from
    device storage when you run the app, update the `unwindNewEntrySave(segue:)` method
    to add a new journal entry to the `ModelContext` instance, and update the `tableView(_:commit:forRowAt:)`
    method to remove the specified journal entry from the `ModelContext` instance.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `JournalListViewController` file in the Project navigator and add
    a method to fetch all journal entries from device storage before the closing curly
    brace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method calls the `loadJournalEntries()` method in the `SharedData` singleton,
    which returns an array of `JournalEntry` instances. This array is then assigned
    to the `journalEntries` array, and the table view is reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `viewDidLoad()` method as follows to call the `fetchJournalEntries()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the journal entries you add to the app will now be persistent, you no
    longer need to call the method used to create sample data for your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `unwindNewEntrySave(segue:)` method to add the new journal entry
    to device storage and update the table view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new `JournalEntry` instance is passed to the `saveJournalEntry` method in
    the `SharedData` singleton, where it is inserted into the `ModelContext` instance
    as a `JournalEntry` model instance. The `fetchJournalEntries()` method then updates
    the `journalEntries` array and reloads the table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `tableView(_:commit:forRowAt:)` method to delete the specified journal
    entry from device storage and update the table view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `JournalEntry` instance to be removed is passed to the `deleteJournalEntry`
    method in the `SharedData` singleton, where the corresponding `JournalEntry` model
    instance is removed from the `ModelContext` instance. The `fetchJournalEntries()`
    method then updates the `journalEntries` array and reloads the table view.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have made all the changes required for the `JournalListViewController`
    class. Build and run your app, and you should see a blank table view on the Journal
    List screen. Add a few journal entries using the Add New Journal Entry screen,
    and they will appear on the Journal List screen. Stop and run your app again.
    The journal entries you added will still be there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B31371_23_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.5: Simulator showing that new entries are still present after your
    app has been relaunched'
  prefs: []
  type: TYPE_NORMAL
- en: Swipe a row to delete a journal entry. Stop and run your app again. The journal
    entry you removed will still be gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image15494.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.6: Simulator showing that deleted entries do not reappear after your
    app has been relaunched'
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully implemented SwiftData in your app, and now journal entries
    added to your app will still be there when your app is relaunched. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you modified the *JRNL* app that you completed in *Chapter
    16*, *Passing Data between View Controllers*, to use SwiftData to save journal
    entries to your device storage, so that any changes you make will still be there
    when you next launch the app. First, you learned about SwiftData and its different
    components. Next, you modified the `JournalEntry` class to make it work with SwiftData
    and modified your `JournalListViewController` class to work with the modified
    `JournalEntry` class. After that, you added code that allowed you to fetch, add,
    and delete journal entries from a SwiftData model container, and finally, you
    modified the `JournalViewController` class so it can read, save, and delete stored
    journal entries.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a basic understanding of how SwiftData works, and you will now
    be able to write your own apps that use SwiftData to save app data. Great job!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the latest developments in **SwiftUI**.
  prefs: []
  type: TYPE_NORMAL
- en: Join us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, experts, and the author himself. Ask questions,
    provide solutions to other readers, chat with the author via Ask Me Anything sessions,
    and much more. Scan the QR code or visit the link to join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/ios-Swift](https://packt.link/ios-Swift%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/QR_Code2370024260177612484.png)](https://packt.link/ios-Swift%0D)****'
  prefs: []
  type: TYPE_NORMAL
