- en: Collections and Data Operations in Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 中的集合和数据操作
- en: In the previous chapters, we have covered a wide range of topics, starting from
    data types, classes, and objects in Kotlin and moving on to immutability, functions,
    delegates, and coroutines in the last chapter. In this chapter, we are going to
    discuss the collections framework and data operations in Kotlin. Kotlin inherits
    collections framework from Java, but has significant changes from it in favor
    of functional programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经涵盖了广泛的主题，从 Kotlin 中的数据类型、类和对象开始，到上一章中的不可变性、函数、委托和协程。在本章中，我们将讨论 Kotlin
    中的集合框架和数据操作。Kotlin 从 Java 继承了集合框架，但在函数式编程方面与之有显著的不同。
- en: The collections framework that Kotlin provides is more functional than Java
    and, as the signature of Kotlin, it is easier to use and understand.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供的集合框架比 Java 更函数式，作为 Kotlin 的签名，它更容易使用和理解。
- en: 'We will start this chapter with the fundamentals of collections and gradually
    move on to data operations that collections support in Kotlin. The following is
    the list of topics that we are going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节的集合基础知识开始，然后逐渐过渡到 Kotlin 中集合支持的数据操作。以下是本章将要涵盖的主题列表：
- en: An introduction to collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合简介
- en: The `Iterator` and `Iterable` interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator` 和 `Iterable` 接口'
- en: Collection types in Kotlin—`Array`, `List`, `Map`, and `Set`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 中的集合类型—`Array`、`List`、`Map` 和 `Set`
- en: Mutability and immutability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性和不可变性
- en: Working with lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与列表一起工作
- en: Various data operations—`map`, `sort`, `filter`, `flatMap`, `partition`, `fold`,
    and `group by`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种数据操作—`map`、`sort`、`filter`、`flatMap`、`partition`、`fold` 和 `group by`
- en: So, what are we waiting for? Let's get started with collections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还在等什么呢？让我们开始学习集合。
- en: An introduction to collections
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合简介
- en: 'The **collections framework** is a set of classes and interfaces that provides
    a unified architecture for performing common groups of data related operations,
    such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合框架**是一组类和接口，它提供了一种统一的架构来执行常见的数据相关操作，如下所示：'
- en: Searching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索
- en: Sorting
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: Insertion
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入
- en: Deletion
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: Manipulation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: All the lists, maps, and sets we use in our programs everyday are part of this
    collections framework.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在日常生活中使用的所有列表、映射和集合都是这个集合框架的一部分。
- en: 'All collections frameworks contain the following things:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合框架都包含以下内容：
- en: '**Interfaces**: These are abstract data types are used to represent collections.
    Interfaces allow collections to be manipulated independent of the details of their
    representation. In object-oriented languages, these are generally interfaces form
    a hierarchy.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：这些是抽象数据类型，用于表示集合。接口允许独立于其表示的细节来操作集合。在面向对象的语言中，这些通常形成层次结构。'
- en: '**Implementations**: These are concrete implementations of the collection of
    interfaces. In essence, these are reusable data structures.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：这些是实现接口集合的具体实现。本质上，这些是可重用的数据结构。'
- en: '**Algorithms**: Methods that perform useful computations, such as searching
    and sorting (as listed earlier), on objects that implement collection interfaces.
    These algorithms are said to be **polymorphic**. The same method can be used on
    many different implementations of the appropriate collection interface. In short,
    algorithms are a reusable functionality.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**：执行有用计算的方法，例如搜索和排序（如前所述），在实现集合接口的对象上。这些算法被称为 **多态**。同一个方法可以用于许多不同实现的相关集合接口。简而言之，算法是可重用的功能。'
- en: Apart from the Java and Kotlin collections framework, the best-known examples
    of collections framework are the **C++ Standard Template Library** (**STL**) and
    Smalltalk's collection hierarchy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Java 和 Kotlin 集合框架之外，最著名的集合框架示例是 **C++ 标准模板库**（**STL**）和 Smalltalk 的集合层次结构。
- en: The advantages of a collections framework
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合框架的优势
- en: So, what is the benefit of having a collections framework? There are several
    benefits, but, most importantly, it reduces the programming time and effort. The
    collections framework provides a developer with high-quality (in terms of performance
    and code optimization) implementations of useful data structures and algorithms,
    while providing you with interoperability between unrelated APIs. You can use
    these implementations in your program, thus reducing your programming effort and
    time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，拥有集合框架有什么好处呢？有几个好处，但最重要的是，它减少了编程时间和努力。集合框架为开发者提供了高质量（在性能和代码优化方面）的有用数据结构和算法的实现，同时提供了与无关API之间的互操作性。您可以在程序中使用这些实现，从而减少编程努力和时间。
- en: So, as we have got to know what the collections framework is, let us now have
    a look at the hierarchy of classes and interfaces in the collections framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经了解了集合框架是什么，那么现在让我们来看看集合框架中类和接口的层次结构。
- en: 'So, let''s go through the following figure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看一下以下图：
- en: '![](img/fed6486d-41c8-4e4d-8e06-95b502f14c07.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fed6486d-41c8-4e4d-8e06-95b502f14c07.png)'
- en: As we mentioned earlier, the collections framework is a set of data types and
    classes that lets us work with a group (or groups) of data. That group may be
    in the form of a simple list/map/set or any other data structure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，集合框架是一组数据类型和类，它使我们能够处理一组（或几组）数据。这组数据可能是一个简单的列表/映射/集合，或者任何其他数据结构。
- en: The preceding figure represents the collections framework of Kotlin. Just like
    Java, all collection interfaces in Kotlin are originated from the `Iterable` interface.
    However, the Kotlin collections framework is a bit different than that of Java;
    Kotlin distinguishes between mutable and immutable collections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表示了Kotlin的集合框架。就像Java一样，Kotlin中的所有集合接口都起源于`Iterable`接口。然而，Kotlin的集合框架与Java的不同；Kotlin区分可变和不可变集合。
- en: Kotlin has two base collection interfaces, namely `Iterable` and `MutableIterable`.
    The `Iterable` interface is extended by the `Collection` interface, which defines
    basic read-only collection operations (like `size`, `isEmpty()`, `contains()`,
    and so on).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有两个基本集合接口，即`Iterable`和`MutableIterable`。`Iterable`接口被`Collection`接口扩展，该接口定义了基本的只读集合操作（如`size`、`isEmpty()`、`contains()`等）。
- en: The `MutableCollection` interface extends the `Collection` interface and the
    `MutableIterable` interface, adding the read-write feature.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableCollection`接口扩展了`Collection`接口和`MutableIterable`接口，增加了读写特性。'
- en: Before the collections framework was introduced in Java, developers used to
    use arrays, vectors, and HashTables to work with a group of data. The problem
    with this approach was that none of them have some common methods. The collections
    framework was thus created to make a developer's life easier by providing common
    methods and operations across various types of collections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java引入集合框架之前，开发者通常使用数组、向量以及哈希表来处理一组数据。这种方法的缺点是它们都没有一些共同的方法。因此，集合框架被创建出来，通过提供跨各种类型集合的通用方法和操作，使开发者的生活变得更简单。
- en: The collection framework was introduced in Java before formation of the Kotlin
    language and it has been included in Kotlin from the very beginning.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架是在Kotlin语言形成之前在Java中引入的，并且从一开始就被包含在Kotlin中。
- en: Aren't you curious about why there are so many collection types? Let's find
    out the purpose of some of the most commonly used collection types as we cover
    them in the following sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您难道不好奇为什么有这么多集合类型吗？让我们在接下来的章节中介绍它们时，找出一些最常用集合类型的目的。
- en: List and MutableList
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: List和MutableList
- en: List is one of the most commonly used collection data types. It is an implementation
    of the `Collection` interface used to work with a group of ordered data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: List是使用最广泛的集合数据类型之一。它是一个`Collection`接口的实现，用于处理一组有序数据。
- en: The data in a list may be ordered based on when it was added (like if we add
    `3` after `4` to an `Int List`, then `4` will appear in the list before `3`, much
    like an array) or may even be ordered based on other ordering algorithms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的数据可以根据添加的顺序进行排序（例如，如果我们将`3`添加到`Int List`中，那么`4`将出现在列表中，在`3`之前，就像数组一样）或者甚至可以根据其他排序算法进行排序。
- en: 'As we mentioned earlier, Kotlin distinguishes between mutable and read-only
    collection types; so, the `List` interface, which is immutable, contains only
    the read-only functions, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Kotlin区分可变和只读集合类型；因此，只读的`List`接口只包含只读函数，如下所示：
- en: '`fun get(index: Int):E`: This method is used to get an element from the list
    at the given index.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun get(index: Int):E`: 此方法用于从给定索引的列表中获取元素。'
- en: '`fun indexOf(element: @UnsafeVariance E):Int`: This method is used to identify
    the index of an element in the list. This method will search for the specified
    element inside the whole list and return the position of the element if it''s
    in the list. Otherwise, it will return `-1`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun indexOf(element: @UnsafeVariance E):Int`: 此方法用于识别列表中元素的索引。此方法将在整个列表中搜索指定的元素，如果它在列表中，则返回元素的位位置。否则，它将返回`-1`。'
- en: '`fun listIterator(): ListIterator<E>`: In case you want to get an instance
    of `ListIterator` (this will be covered later in this chapter, while we discuss
    `Iterator` and `Iterable`).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun listIterator(): ListIterator<E>`: 如果您想获取`ListIterator`的实例（这将在本章后面讨论，当我们讨论`Iterator`和`Iterable`时）。'
- en: '`fun subList(fromIndex: Int, toIndex: Int): List<E>`: Returns a portion of
    the list with the specified `fromIndex` and `toIndex` value.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun subList(fromIndex: Int, toIndex: Int): List<E>`: 返回具有指定`fromIndex`和`toIndex`值的列表的一部分。'
- en: So considering this, it contains only read-only functions, how can we have a
    list with data? While you cannot put data into an immutable list after it gets
    created, you can definitely create an immutable list with pre-populated data (obviously,
    otherwise there wouldn't be any purpose in having immutable lists). You can achieve
    that in many ways, but the most popular one is to use the `listOf` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，它只包含只读函数，我们如何有一个包含数据的列表？虽然您不能在创建后向不可变列表中添加数据，但您当然可以创建一个预填充数据的不可变列表（显然，否则拥有不可变列表就没有任何意义了）。您可以通过多种方式实现这一点，但最流行的方式是使用`listOf`函数。
- en: 'The `listOf` function declaration looks like the following (which can be found
    inside `Collections.kt`, in the `kotlin.collections` package):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`listOf`函数声明如下（可以在`Collections.kt`中的`kotlin.collections`包内找到）：'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see in the function declaration, the function takes a `vararg` parameter
    of a generic type as an element; the function will return a `list` instance containing
    those elements. As you already know, the significance of a `vararg` argument is
    that it can contain 0 to almost 64K arguments (if each argument is of 1 byte,
    a function can have a maximum of 64K bytes allocation, so actually it would be
    less) within it; so, while creating `list` with the `listOf` function, you can
    call it even without parameters to create an empty list, or call the function
    with as many arguments as you need (assuming you don't need more than 64K bytes)
    to create the read-only `list` with them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在函数声明中看到的，该函数接受一个泛型类型的`vararg`参数作为元素；函数将返回一个包含这些元素的`list`实例。正如您已经知道的，`vararg`参数的重要性在于它可以包含0到几乎64K个参数（如果每个参数是1字节，一个函数可以有最大64K字节的分配，所以实际上会更少）；因此，在用`listOf`函数创建`list`时，您甚至可以不传递任何参数来创建一个空列表，或者传递尽可能多的参数（假设您不需要超过64K字节）来创建包含这些参数的只读`list`。
- en: 'The following program is an example of the `listOf` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序是`listOf`函数的一个示例：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding program, we created a `list` value containing numbers `1` through
    `10`. We then used a `for` loop to loop through each element in the `list` value
    and print it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个包含数字`1`到`10`的`list`值。然后我们使用`for`循环遍历`list`值中的每个元素并打印它。
- en: 'Let''s have a look at the following output to validate that:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下输出以验证这一点：
- en: '![](img/12e2918f-eeba-4e45-bbb8-de68a825215d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12e2918f-eeba-4e45-bbb8-de68a825215d.png)'
- en: The `i in list` inside the braces of the `for` loop, tells the `for` loop to
    iterate through all the elements inside the `list` value and copy the element
    to a temporary variable `i` for each of the iterations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环花括号内的`i in list`告诉`for`循环遍历`list`值中的所有元素，并将每个迭代中的元素复制到临时变量`i`。'
- en: We will look at more ways to work with collections later in this chapter, but
    first let us learn different types of collections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面部分探讨更多与集合操作的方法，但首先让我们学习不同类型的集合。
- en: So, continuing our discussions on lists, we've seen how to create an immutable
    list with pre-defined elements; now, we will look at how to create and work with
    mutable lists, but before that let's have a look at the ways to create an empty
    list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继续我们关于列表的讨论，我们已经看到了如何使用预定义元素创建不可变列表；现在，我们将探讨如何创建和操作可变列表，但在那之前，让我们看看创建空列表的方法。
- en: 'Let''s go through the following program:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析以下程序：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, in the preceding program, we created empty lists, one with a `listOf` function
    with no arguments, another one is with an `emptyList` function. Please note that
    the `listOf` function, if called without any arguments, calls an `emptyList` function
    internally.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的程序中，我们创建了空列表，一个使用不带参数的`listOf`函数，另一个使用`emptyList`函数。请注意，如果`listOf`函数不带任何参数调用，则它内部调用`emptyList`函数。
- en: 'The following is the screenshot of the output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出截图：
- en: '![](img/996b36b3-22db-44b0-ab46-dbe9dbeb4b26.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/996b36b3-22db-44b0-ab46-dbe9dbeb4b26.png)'
- en: So, we've seen how to work with immutable lists with a pre-defined bunch of
    elements, but what if we need to add items to the `list` value dynamically? Kotlin
    provides you with mutable lists for this purpose.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何使用预定义的一组元素与不可变列表一起工作，但如果我们需要动态地向`list`值中添加项目怎么办？Kotlin为此提供了可变列表。
- en: 'The following example will help you understand immutable lists:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将帮助您理解不可变列表：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output of the program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的输出：
- en: '![](img/46f5c310-a7fc-460e-bd34-12381e8a332f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46f5c310-a7fc-460e-bd34-12381e8a332f.png)'
- en: Now, let us explain the program. So, at first, we created the `list` value with
    `mutableListOf` function on comment `(1)`, with the items `1`, `2`, and `4`. Note,
    we skipped the type parameter here, it's not important if you pass the elements
    to the function, as Kotlin has type interference. We printed the `list` values
    before moving ahead to add items.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解释一下程序。首先，我们在注释`(1)`处使用`mutableListOf`函数创建了`list`值，其中包含项目`1`、`2`和`4`。请注意，这里我们跳过了类型参数，如果您将元素传递给函数，则这不是很重要，因为Kotlin有类型推断。我们在添加项目之前打印了`list`值。
- en: For `listOf` or any other collections function, type interference is an issue.
    So, you'll not need to specify the generic type of the collection in use if you
    pass the elements or if you've provided the type of the collection itself.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`listOf`或其他任何集合函数，类型推断是一个问题。因此，如果您传递了元素或已提供集合的类型，则不需要指定正在使用的集合的泛型类型。
- en: On comment `(2)`, we added item `5` to the `list`, with the `List$add()` function,
    which appends the provided item to the `list` array.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(2)`处，我们使用`List$add()`函数向`list`中添加了项目`5`，该函数将提供的项目追加到`list`数组中。
- en: Then, on comment `(3)`, we used the `add` function with an index parameter,
    to add item `4` to the second position (counting from `0`, as usual).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在注释`(3)`处，我们使用带有索引参数的`add`函数将项目`4`添加到第二个位置（从`0`开始计数，如通常一样）。
- en: Then, again we appended the `list` array with `5`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们又用`5`向`list`数组中添加了元素。
- en: 'So, we added elements to a `list` array and accessed all the items through
    the `for` loop, but what about accessing a single element? Let''s have an example
    to access and modify single elements in Kotlin. Go through the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`list`数组中添加了元素，并通过`for`循环访问所有项目，但如何访问单个元素呢？让我们通过以下示例来了解如何在Kotlin中访问和修改单个元素。请看以下示例：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We accessed the third element with index `2` and the fourth element with index
    `3`. The reason is simple and straightforward as, with arrays and in lists, counting
    begins at `0`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用索引`2`访问了第三个元素，使用索引`3`访问了第四个元素。原因很简单，因为在数组和列表中，计数从`0`开始。
- en: The thing to notice here is that Kotlin provides out-of-the-box support for
    lists and provides you with a square bracket operator (`[]`) to access elements
    of the `list` value just like an array. In the first `get` statement, we used
    the `get` function with an index to get the element of that index; in the second
    `get` statement, we used the square brackets, which, in turn, call that `get`
    function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的事情是，Kotlin为列表提供了开箱即用的支持，并提供了一个方括号运算符（`[]`）来访问`list`值的元素，就像数组一样。在第一个`get`语句中，我们使用带有索引的`get`函数来获取该索引的元素；在第二个`get`语句中，我们使用了方括号，它反过来调用那个`get`函数。
- en: As lists store items as per their order/index, it's easy to get items from a
    list with an index; you can easily skip a loop if you want just a particular element
    from that list and if you know the index for the element you want. Just pass the
    element to the `get` function and you have the element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表按顺序/索引存储项目，因此很容易通过索引从列表中获取项目；如果您只想从列表中获取特定元素并且知道该元素的索引，则可以轻松跳过循环。只需将元素传递给`get`函数，您就有该元素了。
- en: This `get` element by index is not supported by other collection interfaces
    like `set` (though `OrderedSet` supports them), which doesn't support the ordering
    of elements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引获取元素不支持其他集合接口，如`set`（尽管`OrderedSet`支持它们），它不支持元素的排序。
- en: So, as we have got a little grip on lists, let us move ahead and have a look
    at the sets.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经对列表有了些许了解，让我们继续前进，看看集合。
- en: Set and MutableSet
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和 MutableSet
- en: 'Just like `List`, `Set` also has the following two variants in Kotlin:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `List` 一样，`Set` 在 Kotlin 中也有以下两种变体：
- en: '`Set`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`'
- en: '`MutableSet`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutableSet`'
- en: '`Set` is read-only and `MutableSet` is the mutable version of `Set`, which
    contains the read-write functionalities.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 是只读的，而 `MutableSet` 是 `Set` 的可变版本，它包含读写功能。'
- en: Just like with list, set values also have read-only functions and properties
    like `size`, `iterator()`, and so on. We are skipping mentioning them here to
    avoid redundant contents in this book. Also, please note that set doesn't do ordering
    like list (unless you use `OrderedSet`). So, it lacks the functions which involve
    orders like `indexOf(item)`, `add(index, item)`, and so on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像列表一样，集合的值也有只读函数和属性，如 `size`、`iterator()` 等。我们在这里省略了它们的提及，以避免在这本书中重复内容。请注意，集合不像列表那样进行排序（除非你使用
    `OrderedSet`）。因此，它缺少涉及排序的函数，如 `indexOf(item)`、`add(index, item)` 等。
- en: Sets in collections represent mathematical sets (as in set theory).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的集合表示数学集合（如集合论中的集合）。
- en: 'The following is an example with `MutableSet`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `MutableSet` 的示例：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/e5486b76-2bb9-4eed-ac21-6e4bbcba1367.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5486b76-2bb9-4eed-ac21-6e4bbcba1367.png)'
- en: The output clearly shows that, even though we added multiple duplicate items
    to the `set`, both at the time of initialization and later, only unique items
    got inserted and all duplicate items got ignored.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，尽管我们在初始化和之后都向 `set` 中添加了多个重复项，但只有唯一的项被插入，所有重复的项都被忽略了。
- en: 'Now, you may be curious as to whether the same will happen with custom classes
    and data classes; let us check with the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能很好奇，这与自定义类和数据类会发生什么；让我们通过以下示例来检查：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this program, we first created a data class and a custom class, then we created
    sets with them and inserted duplicate items.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们首先创建了一个数据类和一个自定义类，然后使用它们创建了集合并插入了重复项。
- en: 'Let us see the following output to check whether the sets are free of duplicate
    items:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下输出以检查集合是否没有重复项：
- en: '![](img/49fedff6-df68-4e79-b4c8-61511cfd80a9.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49fedff6-df68-4e79-b4c8-61511cfd80a9.png)'
- en: Have a look at the preceding output carefully. While, as is the case with data
    classes,  `set` ignored the duplicate items, when trying the same with a normal
    class, it was unable to detect the duplicate insertions and kept them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看前面的输出。虽然与数据类的情况一样，`set` 忽略了重复项，但在尝试与普通类做同样的事情时，它无法检测到重复插入并保留了它们。
- en: The last item that got added in `dataClassSet`—`MyDataClass(2,"will be added")`
    if you think it was a duplicate item then check again, while the value of `someNumericValue`
    for this object is identical to a previous one, the `someStringValue` value differs
    from that previous object's `someStringValue`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dataClassSet` 中最后添加的项是 `MyDataClass(2,"will be added")`，如果你认为它是一个重复项，那么请再次检查，尽管这个对象的
    `someNumericValue` 值与之前的相同，但 `someStringValue` 值与之前对象的 `someStringValue` 不同。
- en: Why is this an anomaly? The answer is short and simple—the collections framework
    internally uses `hashCode()` and `equals()` functions to perform equality checks
    while adding items to the `set` values and they are missing from the custom class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是一个异常？答案是简单明了——集合框架在向 `set` 值添加项时内部使用 `hashCode()` 和 `equals()` 函数来执行相等性检查，而自定义类中缺少这些函数。
- en: 'In Kotlin, the compiler automatically extracts the `hashCode()` and `equals()`
    functions. Thus, the `set` values were able to distinguish between duplicate items
    without custom implementations of those functions. For more information on data
    classes visit the following link: [https://kotlinlang.org/docs/reference/data-classes.html](https://kotlinlang.org/docs/reference/data-classes.html)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，编译器会自动提取 `hashCode()` 和 `equals()` 函数。因此，`set` 值能够区分重复项，而无需自定义这些函数的实现。有关数据类的更多信息，请访问以下链接：[https://kotlinlang.org/docs/reference/data-classes.html](https://kotlinlang.org/docs/reference/data-classes.html)
- en: 'So, if we implement those functions, then `set` will be able to distinguish
    between the duplicate items in the `customClassSet` values as well. Obviously,
    that''s how it works for data classes as well. Just add the following code to
    the `MyCustomClass` definition and run the program to see the difference yourself:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们实现这些函数，那么 `set` 也将能够区分 `customClassSet` 值中的重复项。显然，这对于数据类也是这样工作的。只需将以下代码添加到
    `MyCustomClass` 定义中并运行程序，自己看看效果：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Cool, isn't it? So, we are done with `List` and `Set`. Let us now have a look
    at the `Map` interface; then, we will discuss the data operation functions provided
    by the collections framework.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？所以，我们已经完成了`List`和`Set`。现在让我们看看`Map`接口；然后，我们将讨论集合框架提供的数据操作函数。
- en: Map and MutableMap
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map和MutableMap
- en: The `Map` interface in the collections framework is a bit different than all
    others interfaces we have covered earlier; unlike others it works with key-value
    pairs. No, this is not similar to `Pair`; `Pair` is just a pair of two values
    combined together, while a map is a collection of key-value pairs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架中的`Map`接口与其他所有我们之前覆盖的接口略有不同；与其他接口不同，它使用键值对。不，这并不类似于`Pair`；`Pair`只是两个值组合在一起，而映射是一组键值对。
- en: In a map, keys are unique and cannot be duplicated. If you add two values with
    the same key, then the later one will replace the previous one. Values, on the
    other hand can be redundant/duplicate. The reason behind this behavior is that
    in a map, a value is stored and retrieved with respect to its key, so redundant
    keys will make it impossible to distinguish them from each-other and to fetch
    their values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射中，键是唯一的，不能重复。如果你添加两个具有相同键的值，那么后面的值将替换前面的值。另一方面，值可以是冗余的/重复的。这种行为背后的原因是，在映射中，值是根据其键存储和检索的，因此冗余的键将使得无法区分它们，也无法获取它们的值。
- en: The declaration of `Map` in Kotlin reads like interface `Map<K, out V>`, the
    `K` value is the generic type of the key and `V` is the generic type of value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中`Map`的声明读起来像接口`Map<K, out V>`，`K`值是键的泛型类型，而`V`是值的泛型类型。
- en: 'To learn more about collections, let us have a look at a few of the functions
    and properties. Go through the following list:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于集合的信息，让我们看看一些函数和属性。查看以下列表：
- en: '`val size: Int`: This function indicates the size of the `Map` interface, that
    is, the number of key-value pairs residing inside the map.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val size: Int`: 这个函数表示`Map`接口的大小，即映射中驻留的键值对数量。'
- en: '`fun isEmpty(): Boolean`: This function helps in checking whether a `Map` interface
    is empty or not.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun isEmpty(): Boolean`: 这个函数有助于检查`Map`接口是否为空。'
- en: '`fun containsKey(key: K): Boolean`: This function checks for the provided `key`
    inside the collection of key-value pairs it has and returns `true` if it is found.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun containsKey(key: K): Boolean`: 这个函数检查提供的`key`是否在它拥有的键值对集合中，如果找到则返回`true`。'
- en: '`operator fun get(key: K): V?`: This function cum operator (if used by square
    brackets (`[]`) like an array) returns the value corresponding to a key or null
    if the key doesn''t exist within it.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator fun get(key: K): V?`: 这个函数兼操作符（如果像数组一样使用方括号`[]`）返回与键对应的值，如果键不存在则返回null。'
- en: '`val keys: Set<K>`: This function indicates the collection of keys available
    in that map at that point of time. As keys cannot be duplicated and they are not
    ordered, a `Set` value is the best data-structure to hold them.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val keys: Set<K>`: 这个函数表示在该映射的某个时间点可用的键集合。由于键不能重复且无序，`Set`值是存储它们的最佳数据结构。'
- en: '`val values: Collection<V>`: Contains all the values of the `map` value as
    a collection.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val values: Collection<V>`: 包含`map`值的所有值作为一个集合。'
- en: '`interface Entry<out K, out V>`: This function is defined inside the `Map`
    interface. An `Entry` represents a single key-value pair in the `Map` interface.
    The key-value pairs are stored as an entry inside the `map` value.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface Entry<out K, out V>`: 这个函数定义在`Map`接口内部。`Entry`表示`Map`接口中的单个键值对。键值对作为条目存储在`map`值中。'
- en: '`val entries: Set<Map.Entry<K, V>>`: This function gets you all the entries
    in the map.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val entries: Set<Map.Entry<K, V>>`: 这个函数可以获取映射中的所有条目。'
- en: 'The previous were read-only interfaces of `Map` as it only supports read-only
    operations. For read-write access, you''ve to use the `mutableMap` function. So,
    let us now have a look at the read-write interfaces provided by `mutableMap` as
    seen in the following list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的都是只读接口的`Map`，因为它只支持只读操作。对于读写访问，你必须使用`mutableMap`函数。因此，现在让我们看看`mutableMap`提供的读写接口，如下所示：
- en: '`fun put(key: K, value: V): V?` : This interface adds a key-value pair to the
    `Map` and returns the previous value associated with the key (if any or null if
    the key wasn''t present in the `Map` earlier).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun put(key: K, value: V): V?` : 这个接口向`Map`添加键值对，并返回与键关联的先前值（如果有，则为null，如果键之前不在`Map`中）。'
- en: '`fun remove(key: K): V?` : This interface removes a key-value pair from the
    map with the key and returns the value and returns null if the key doesn''t exist
    in the `Map` interface.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun remove(key: K): V?`：此接口从 `Map` 接口中删除具有键的键值对，并返回值。如果键不存在于 `Map` 接口中，则返回
    null。'
- en: '`fun putAll(from: Map<out K, V>): Unit` : This interface adds the key-value
    pairs from the provided `map` value.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun putAll(from: Map<out K, V>): Unit`：此接口从提供的 `map` 值添加键值对。'
- en: '`fun clear(): Unit`: As the name suggests, this instance clears the `map` value.
    It removes everything that the `map` value contains—every key and every value.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun clear(): Unit`：正如其名所示，此实例清除 `map` 值。它移除 `map` 值包含的每一项——每个键和每个值。'
- en: So, as we now know the interfaces and functions the `Map` interfaces has to
    offer, let's now have an example with `Map`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们现在知道了 `Map` 接口提供的接口和函数，让我们现在通过一个 `Map` 的例子来展示。
- en: 'Let''s go through the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例进行说明：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, we demonstrated the use of the following two types of maps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们展示了以下两种类型映射的使用：
- en: Read-only `Map`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读 `Map`
- en: Read-write `MutableMap`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读写 `MutableMap`
- en: Kotlin provides you with a version of the `mapOf()` function that accepts `vararg`
    parameters of the `Pair` type. This makes it easy for you to create read-only
    maps—just pass the key-value pairs as the instances of `Pair` to the `mapOf()`
    function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 为你提供了一个接受 `Pair` 类型的 `vararg` 参数的 `mapOf()` 函数版本。这使得你可以轻松地创建只读映射——只需将键值对作为
    `Pair` 实例传递给 `mapOf()` 函数。
- en: 'Let us see the output before further inspecting and discussing the program.
    See the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步检查和讨论程序之前，让我们看看输出。请看以下截图：
- en: '![](img/011bf909-bf9d-4205-90bf-cfa0e42bcfb0.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/011bf909-bf9d-4205-90bf-cfa0e42bcfb0.png)'
- en: While creating the map, on comment `(1),` we passed a `"Five".to(0)` pair and
    on comment `(2)`, we passed the `"Five".to(5)` pair to the same `mapOf` function,
    to check which value the `map` stores for the `"Five"` key; the output suggests
    that the `map` took the second value—`5`, as we described earlier that a `map` value
    always takes the last value for the same key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建地图时，在注释 `(1)` 中，我们传递了一个 `"Five".to(0)` 对，在注释 `(2)` 中，我们传递了 `"Five".to(5)`
    对到同一个 `mapOf` 函数，以检查 `map` 为 `"Five"` 键存储的值；输出表明 `map` 采用了第二个值——`5`，正如我们之前所描述的，`map`
    的值总是取相同键的最后一个值。
- en: Also note that Kotlin supports array-like square brackets in `Map` as well.
    Instead of an index, you can pass the key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，Kotlin 还支持在 `Map` 中使用类似数组的方括号。你可以传递键而不是索引。
- en: 'So, as we got our hands dirty with three most important interfaces in Kotlin''s
    collection framework: `List`, `Set`, and `Map`. Let''s now move forward and get
    ourselves introduced to data operations in a collection.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们熟悉了 Kotlin 集合框架中的三个最重要的接口：`List`、`Set` 和 `Map` 后，现在让我们继续前进，了解集合中的数据操作。
- en: Data operations in a collection
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合中的数据操作
- en: Kotlin provides out-of-the-box support for its collection framework. As a result,
    the collections framework in Kotlin is full of interesting features that make
    it stand apart from the collections framework in other languages, such as Java.
    You already got introduced with some of those features, such as separate interfaces
    for read-only and mutable collections, square box operator-like arrays, and so
    on. What I'm going to introduce now is probably the most interesting feature of
    Kotlin's collections framework, but goes mostly unnoticed—data operation functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 为其集合框架提供了开箱即用的支持。因此，Kotlin 的集合框架充满了有趣的功能，使其与其他语言的集合框架（如 Java）区别开来。你已经接触到了其中的一些功能，例如为只读和可变集合提供单独的接口、类似方框操作符的数组等。我现在要介绍的是
    Kotlin 集合框架中最有趣的功能之一，但通常被忽视——数据操作函数。
- en: Kotlin supports data operation functions for all of its collections framework
    interfaces, objects, and classes. By data operation functions, I mean the operators
    and functions by which we can access, process or operate on data from a collection;
    if you are familiar with ReactiveX framework/RxJava/RxKotlin, you'll find it similar
    as Kotlin picked them mostly from there.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 支持其所有集合框架接口、对象和类的数据操作函数。数据操作函数是指我们可以通过它们访问、处理或操作集合中的数据的操作符和函数；如果你熟悉 ReactiveX
    框架/RxJava/RxKotlin，你会发现它们很相似，因为 Kotlin 主要从那里借鉴了它们。
- en: 'The following is a list of a few of the collection data operation functions
    that we are going to cover here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要介绍的一些集合数据操作函数列表：
- en: The `map` function
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 函数'
- en: The `filter` function
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter` 函数'
- en: The `flatMap` function
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap` 函数'
- en: The `drop` functions
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop` 函数'
- en: The `take` functions
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take`函数'
- en: The `zip` functions
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`函数'
- en: So, what are we waiting for? Let us get started.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还在等什么呢？让我们开始吧。
- en: Though, the data operation functions with collections make you feel like you're
    working with streams/Rx, they are in no way similar to streams/Rx. What they do
    is simply use high order functions and extension functions to provide you with
    stream-like interfaces and internally they operate on the same loops (yes, you
    read it right, they use loops to produce results and then return it from the function
    just like a simple imperial program). It is advisable to avoid bigger chains of
    these functions in your program, as you'll end up with multiple loops. Using `forEach`
    or your own loop in such scenarios is a better choice, as you will be able to
    perform multiple operations with a single loop with `forEach` or with your own
    loop. However, for a single operation or small chains, you can definitely use
    these functions to make your code well organized.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，使用集合的数据操作函数会让你感觉像在使用流/Rx，但它们在本质上与流/Rx没有任何相似之处。它们所做的只是使用高阶函数和扩展函数为你提供类似流的接口，并且在内部它们操作在相同的循环中（是的，你读对了，它们使用循环来产生结果，然后像简单的帝国程序一样从函数中返回它）。建议你在程序中避免使用这些函数的大链，因为最终你会得到多个循环。在这种情况下使用`forEach`或你自己的循环是更好的选择，因为你可以使用`forEach`或你自己的循环在一个循环中执行多个操作。然而，对于单个操作或小的链，你当然可以使用这些函数来使你的代码更有组织性。
- en: The map function
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图函数
- en: The `map` function allows you to apply an algorithm to a collection all-together
    and obtain the results as a resultant set. It's helpful in making your code well-organized
    and writing loops (though it'll use loop internally, you're freed from writing
    those boilerplate codes).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数允许你将算法应用于整个集合，并作为结果集获得结果。这对于使你的代码更有组织性和编写循环很有帮助（尽管它会在内部使用循环，但你将免于编写那些样板代码）。'
- en: The `map` function receives all the elements of the collection as each iteration
    and should return the computed resultant item that should be placed in the resultant
    list in place of the passed item.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数接收集合中的所有元素作为每次迭代的元素，并应返回应放置在结果列表中替代传递项的计算结果项。'
- en: 'Go through the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, we had a list of `Int`, we needed to multiply each item from the `list` value
    with `2`, and we did it with ease with just a single line of code—`list.map {
    it*2 }`, which would normally take us two or three lines more of boilerplate.
    Insane, isn't it?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个`Int`列表，我们需要将列表中的每个项乘以`2`，我们只需一行代码就能轻松完成——`list.map { it*2 }`，这通常需要我们多两到三行样板代码。疯狂，不是吗？
- en: 'The following is the output of the program:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的输出：
- en: '![](img/b178834e-cece-4c43-9e2e-c0bf9ae395bb.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b178834e-cece-4c43-9e2e-c0bf9ae395bb.png)'
- en: As expected, the `map` function applied the provided lambda to each of the elements
    of the list and returned the resultant list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`map`函数将提供的lambda函数应用于列表的每个元素，并返回结果列表。
- en: The filter function
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`filter`函数'
- en: Think of a situation where you need to filter the items in a collection. For
    example, when you want to obtain only even numbers from a list of integers. The
    `filter` function is there to help you in these scenarios.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你需要过滤集合中的项的情况。例如，当你想从整数列表中获取仅偶数时。`filter`函数就是为了帮助你在这些场景中。
- en: The `filter` function receives all the elements of the collection as each iteration
    and should return `true` or `false`, based on its determination of whether the
    passed item should be on the resultant list or not.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`函数接收集合中的所有元素作为每次迭代的元素，并应根据其确定是否应将传递的项放在结果列表中来返回`true`或`false`。'
- en: 'Go through the following program:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个程序示例：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this program, we first obtained a list of `Int` containing numbers from `1`
    to `50` with the help of `IntRange`. We then filtered the list to obtain even
    numbers on comment `(2)` and printed them. On comment `(3)`, we filtered the list
    (the original list containing `Int` values from `1` to `50`) to obtain perfect
    squares and printed them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们首先使用`IntRange`帮助获取一个包含从`1`到`50`数字的`Int`列表。然后，我们在注释`(2)`中过滤列表以获取偶数并打印它们。在注释`(3)`中，我们过滤包含从`1`到`50`的`Int`值的原始列表以获取完全平方数并打印它们。
- en: 'The following is the output of the program:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的输出：
- en: '![](img/4f0bbb4f-4034-4041-89ed-e9fb2c5d9b48.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f0bbb4f-4034-4041-89ed-e9fb2c5d9b48.png)'
- en: The previous code snippet and its output show just how much boilerplate code
    can be eliminated with the help of these data operation functions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段及其输出显示了这些数据操作函数可以消除多少样板代码。
- en: The flatMap function
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平滑映射函数
- en: Another awesome function available with collections framework is the `flatMap`
    function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架中可用的另一个令人惊叹的函数是`flatMap`函数。
- en: Like the `map` function, it receives each of the items in the collection as
    an iteration, but, unlike the `map` function, it should return another collection
    for each of the items passed. These returned collections are then combined to
    create the resultant collection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`map`函数一样，它将集合中的每个项目作为迭代接收，但与`map`函数不同，它应该为传递的每个项目返回另一个集合。然后，这些返回的集合被组合起来创建结果集合。
- en: 'Have a look at the following example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output looks like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来如下：
- en: '![](img/3ba5c3b3-b4dd-4360-bd5f-eb3bdab9141b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ba5c3b3-b4dd-4360-bd5f-eb3bdab9141b.png)'
- en: While the original list contained only three numbers—`10`, `20`, and `30`, the
    resultant list contains three more numbers for each of the numbers in the original
    list, all thanks to the `flatMap` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管原始列表中只包含三个数字——`10`、`20`和`30`，但结果列表中每个原始列表中的数字都增加了三个数字，这都要归功于`flatMap`函数。
- en: The drop functions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除函数
- en: 'There may be some scenarios when you want to drop a portion (say, the first
    5 or the last 10) of the collection and work on the remaining parts. Kotlin''s
    collection framework provides you with a set of the `drop` functions that can
    help you in these scenarios. Have a look at the following program:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一些场景，当你想要丢弃集合的一部分（比如说，前5个或最后10个）并处理剩余的部分时。Kotlin的集合框架为你提供了一组`drop`函数，这些函数可以帮助你在这些场景下。看看以下程序：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding program, we've dropped the first `25` items from the list on
    comment `(1)`, and on comment `(2)`, I've dropped the last `25` items.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们在注释`(1)`中从列表中删除了前`25`个项目，在注释`(2)`中，我删除了最后`25`个项目。
- en: 'The following screenshot shows the output of the program:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序的输出：
- en: '![](img/d75cc5be-d87a-479e-a934-9025fbeafeff.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d75cc5be-d87a-479e-a934-9025fbeafeff.png)'
- en: Worked perfectly, didn't it?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 工作得完美，不是吗？
- en: The take functions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`take`函数'
- en: The `take` functions work in just the opposite way to the `drop` functions.
    You can take a selection from the collection and ignore the rest.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`take`函数与`drop`函数的工作方式正好相反。你可以从集合中选择一部分，忽略其余部分。'
- en: 'Have a look at the following program:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下程序：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While statements on comment `(1)` and comment `(2)` are opposite to the `drop`
    functions earlier, they just take and print the `25` items from the list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 而在注释`(1)`和注释`(2)`中的while语句与之前的`drop`函数相反，它们只是从列表中取出并打印`25`个项目。
- en: The statement on comment `(3)` is a bit different, here we used the `takeWhile`
    function. The `takeWhile` function takes a predicate and keeps taking items on
    the resultant collection while the predicate returns `true`; once the predicate
    returns `false` the `takeWhile` value will stop checking for any more items and
    will return the resultant collection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注释`(3)`中的语句有点不同，这里我们使用了`takeWhile`函数。`takeWhile`函数接受一个谓词，并在谓词返回`true`时继续在结果集合中取项目；一旦谓词返回`false`，`takeWhile`值将停止检查更多项目，并返回结果集合。
- en: The `takeLastWhile` values work in a similar way but in reverse.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeLastWhile`值的工作方式与它相反。'
- en: 'The following is a screenshot of the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个输出截图：
- en: '![](img/df4ae23a-0073-4ee7-898b-0f9e55ff1e2f.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df4ae23a-0073-4ee7-898b-0f9e55ff1e2f.png)'
- en: Let's now move ahead with the `zip` functions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续使用`zip`函数。
- en: The zip function
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`zip`函数'
- en: 'The `zip` function does exactly what it sounds like, it zips collections. Confusing?
    Let''s have a look at the following example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`函数确实如其名所示，它将集合“压缩”在一起。令人困惑？让我们看看以下示例：'
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created two lists—one with `Int` and the other with `String`. We then created
    a resultant list by zipping the `Int` list with the `String` list and printed
    the resultant list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两张列表——一张是`Int`类型的，另一张是`String`类型的。然后我们通过将`Int`列表与`String`列表进行`zip`操作创建了一个结果列表，并打印了这个结果列表。
- en: So, what does the `resultantList` value contain? What operation did the `zip`
    function perform?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`resultantList`值包含什么？`zip`函数执行了什么操作？
- en: 'Let us decide it ourselves by having a look at the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看以下输出自行决定：
- en: '![](img/f158d2ea-32e5-44bc-9911-b32f07745d98.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f158d2ea-32e5-44bc-9911-b32f07745d98.png)'
- en: Amazing, isn't it? The `zip` function takes another collection, combines the
    source collection with the provided collection, and creates a `Pair` value for
    each of the items. But what if the collections differ in item counts? What if
    we want to combine each item in a list with the next item in the same list?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？`zip`函数接受另一个集合，将源集合与提供的集合组合起来，并为每个项目创建一个`Pair`值。但如果集合的项目数量不同怎么办？如果我们想将列表中的每个项目与同一列表中的下一个项目组合起来呢？
- en: 'Let''s take another example. Have a look at the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子。看看以下代码：
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, the first `println` statement here answers our first question—it tries to
    combine two lists with asymmetrical item counts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的第一个`println`语句回答了我们的第一个问题——它试图将两个项目数量不对称的列表组合起来。
- en: On the second `println` statement, we used the `zipWithNext` function, which
    zips one item of a collection with the next item of the same collection. So, let's
    have a look at the output to find out what happens.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`println`语句中，我们使用了`zipWithNext`函数，该函数将集合中的一个项目与同一集合的下一个项目进行压缩。那么，让我们看一下输出结果，以了解发生了什么。
- en: 'The following is the output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![](img/1ccd9aa4-3a4b-446d-9fb4-a76c1d876257.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ccd9aa4-3a4b-446d-9fb4-a76c1d876257.png)'
- en: So, the `zip` operator only zipped those items of `list1`, for which it could
    find a pair in `list2` and skipped the remaining. The `zipWithNext` operator on
    the other hand, worked as expected.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`zip`操作符仅将`list1`中的那些项目与`list2`中的配对项进行压缩，并跳过了剩余的项。另一方面，`zipWithNext`操作符则按预期工作。
- en: So, we are done with data operation functions in Kotlin collection framework.
    However, Kotlin provides you with more capabilities for collections; so, let's
    move ahead and see what more it has to offer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了Kotlin集合框架中的数据操作函数。然而，Kotlin为您提供了更多关于集合的能力；所以，让我们继续前进，看看它还能提供什么。
- en: Grouping collections
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组集合
- en: Kotlin's collection framework allows you to group collections based on your
    requirements. For example, if you have a list of strings and want to group them
    with respect to their size, you can easily do that with the help of the `groupBy`
    function, which groups a collection based on the logic provided and returns `Map`
    with that group of collections.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的集合框架允许您根据需求对集合进行分组。例如，如果您有一个字符串列表，并希望根据它们的长度进行分组，您可以使用`groupBy`函数轻松实现，该函数根据提供的逻辑对集合进行分组，并返回包含该组集合的`Map`。
- en: 'So, the following is a short example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是一个简短的示例：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So, what we did here is as follows: we created a list of `Int` containing numbers
    from `1` to `50` (both inclusive) then, we tried to group them based on their
    remnants when divided by `5`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里所做的是：我们创建了一个包含从`1`到`50`（包括两端）的数字的`Int`列表，然后我们尝试根据它们除以`5`的余数来分组它们。
- en: 'So, there should be five groups, from `0` to `5`, and each of them should contain
    10 numbers. Let''s check the following output to see if that happened or not:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应该有五个组，从`0`到`5`，每个组都应该包含10个数字。让我们检查以下输出结果，看看这是否发生了。
- en: '![](img/0d47e4fd-5eba-4647-8a73-9540bc7d9d44.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d47e4fd-5eba-4647-8a73-9540bc7d9d44.png)'
- en: So, the `groupBy` function just worked as expected and returned `Map<Int,List<Int>>`
    that contained the grouped list.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`groupBy`函数按预期工作，并返回包含分组列表的`Map<Int,List<Int>>`。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, this chapter was on collections and data operations in Kotlin. We started
    the chapter by exploring the collection framework in Kotlin and data structure
    of collections, and we gradually moved towards learning the data operations and
    functions that Kotlin collection framework provides out of the box.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章是关于Kotlin中的集合和数据操作。我们通过探索Kotlin的集合框架和数据结构开始本章，然后逐渐转向学习Kotlin集合框架提供的开箱即用的数据操作和函数。
- en: In the next chapter, we will learn how to work with functional programming,
    reactive programming, and OOP altogether. We believe Kotlin is the best language
    for this, as it lets you take the benefits of both worlds—functional programming
    and OOP. In the next chapter, we will see how to take advantage of this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何一起处理函数式编程、响应式编程和面向对象编程。我们相信Kotlin是做这件事的最佳语言，因为它让您能够同时获得函数式编程和面向对象编程的好处。在下一章中，我们将看到如何利用这一点。
- en: In the next chapter, we will also introduce ourselves to the ReactiveX framework,
    which is among the most popular frameworks for functional reactive programming.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们还将介绍ReactiveX框架，这是功能响应式编程中最受欢迎的框架之一。
- en: So, lets move ahead; the next chapter is just a page turn away.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续前进；下一章就在眼前。
