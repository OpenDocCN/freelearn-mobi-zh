- en: Collections and Data Operations in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have covered a wide range of topics, starting from
    data types, classes, and objects in Kotlin and moving on to immutability, functions,
    delegates, and coroutines in the last chapter. In this chapter, we are going to
    discuss the collections framework and data operations in Kotlin. Kotlin inherits
    collections framework from Java, but has significant changes from it in favor
    of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework that Kotlin provides is more functional than Java
    and, as the signature of Kotlin, it is easier to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start this chapter with the fundamentals of collections and gradually
    move on to data operations that collections support in Kotlin. The following is
    the list of topics that we are going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Iterator` and `Iterable` interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection types in Kotlin—`Array`, `List`, `Map`, and `Set`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability and immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various data operations—`map`, `sort`, `filter`, `flatMap`, `partition`, `fold`,
    and `group by`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what are we waiting for? Let's get started with collections.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **collections framework** is a set of classes and interfaces that provides
    a unified architecture for performing common groups of data related operations,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the lists, maps, and sets we use in our programs everyday are part of this
    collections framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'All collections frameworks contain the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfaces**: These are abstract data types are used to represent collections.
    Interfaces allow collections to be manipulated independent of the details of their
    representation. In object-oriented languages, these are generally interfaces form
    a hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementations**: These are concrete implementations of the collection of
    interfaces. In essence, these are reusable data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms**: Methods that perform useful computations, such as searching
    and sorting (as listed earlier), on objects that implement collection interfaces.
    These algorithms are said to be **polymorphic**. The same method can be used on
    many different implementations of the appropriate collection interface. In short,
    algorithms are a reusable functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the Java and Kotlin collections framework, the best-known examples
    of collections framework are the **C++ Standard Template Library** (**STL**) and
    Smalltalk's collection hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of a collections framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is the benefit of having a collections framework? There are several
    benefits, but, most importantly, it reduces the programming time and effort. The
    collections framework provides a developer with high-quality (in terms of performance
    and code optimization) implementations of useful data structures and algorithms,
    while providing you with interoperability between unrelated APIs. You can use
    these implementations in your program, thus reducing your programming effort and
    time.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we have got to know what the collections framework is, let us now have
    a look at the hierarchy of classes and interfaces in the collections framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go through the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fed6486d-41c8-4e4d-8e06-95b502f14c07.png)'
  prefs: []
  type: TYPE_IMG
- en: As we mentioned earlier, the collections framework is a set of data types and
    classes that lets us work with a group (or groups) of data. That group may be
    in the form of a simple list/map/set or any other data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure represents the collections framework of Kotlin. Just like
    Java, all collection interfaces in Kotlin are originated from the `Iterable` interface.
    However, the Kotlin collections framework is a bit different than that of Java;
    Kotlin distinguishes between mutable and immutable collections.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin has two base collection interfaces, namely `Iterable` and `MutableIterable`.
    The `Iterable` interface is extended by the `Collection` interface, which defines
    basic read-only collection operations (like `size`, `isEmpty()`, `contains()`,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The `MutableCollection` interface extends the `Collection` interface and the
    `MutableIterable` interface, adding the read-write feature.
  prefs: []
  type: TYPE_NORMAL
- en: Before the collections framework was introduced in Java, developers used to
    use arrays, vectors, and HashTables to work with a group of data. The problem
    with this approach was that none of them have some common methods. The collections
    framework was thus created to make a developer's life easier by providing common
    methods and operations across various types of collections.
  prefs: []
  type: TYPE_NORMAL
- en: The collection framework was introduced in Java before formation of the Kotlin
    language and it has been included in Kotlin from the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Aren't you curious about why there are so many collection types? Let's find
    out the purpose of some of the most commonly used collection types as we cover
    them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: List and MutableList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List is one of the most commonly used collection data types. It is an implementation
    of the `Collection` interface used to work with a group of ordered data.
  prefs: []
  type: TYPE_NORMAL
- en: The data in a list may be ordered based on when it was added (like if we add
    `3` after `4` to an `Int List`, then `4` will appear in the list before `3`, much
    like an array) or may even be ordered based on other ordering algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, Kotlin distinguishes between mutable and read-only
    collection types; so, the `List` interface, which is immutable, contains only
    the read-only functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fun get(index: Int):E`: This method is used to get an element from the list
    at the given index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun indexOf(element: @UnsafeVariance E):Int`: This method is used to identify
    the index of an element in the list. This method will search for the specified
    element inside the whole list and return the position of the element if it''s
    in the list. Otherwise, it will return `-1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun listIterator(): ListIterator<E>`: In case you want to get an instance
    of `ListIterator` (this will be covered later in this chapter, while we discuss
    `Iterator` and `Iterable`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun subList(fromIndex: Int, toIndex: Int): List<E>`: Returns a portion of
    the list with the specified `fromIndex` and `toIndex` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So considering this, it contains only read-only functions, how can we have a
    list with data? While you cannot put data into an immutable list after it gets
    created, you can definitely create an immutable list with pre-populated data (obviously,
    otherwise there wouldn't be any purpose in having immutable lists). You can achieve
    that in many ways, but the most popular one is to use the `listOf` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `listOf` function declaration looks like the following (which can be found
    inside `Collections.kt`, in the `kotlin.collections` package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the function declaration, the function takes a `vararg` parameter
    of a generic type as an element; the function will return a `list` instance containing
    those elements. As you already know, the significance of a `vararg` argument is
    that it can contain 0 to almost 64K arguments (if each argument is of 1 byte,
    a function can have a maximum of 64K bytes allocation, so actually it would be
    less) within it; so, while creating `list` with the `listOf` function, you can
    call it even without parameters to create an empty list, or call the function
    with as many arguments as you need (assuming you don't need more than 64K bytes)
    to create the read-only `list` with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program is an example of the `listOf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we created a `list` value containing numbers `1` through
    `10`. We then used a `for` loop to loop through each element in the `list` value
    and print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following output to validate that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12e2918f-eeba-4e45-bbb8-de68a825215d.png)'
  prefs: []
  type: TYPE_IMG
- en: The `i in list` inside the braces of the `for` loop, tells the `for` loop to
    iterate through all the elements inside the `list` value and copy the element
    to a temporary variable `i` for each of the iterations.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at more ways to work with collections later in this chapter, but
    first let us learn different types of collections.
  prefs: []
  type: TYPE_NORMAL
- en: So, continuing our discussions on lists, we've seen how to create an immutable
    list with pre-defined elements; now, we will look at how to create and work with
    mutable lists, but before that let's have a look at the ways to create an empty
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, in the preceding program, we created empty lists, one with a `listOf` function
    with no arguments, another one is with an `emptyList` function. Please note that
    the `listOf` function, if called without any arguments, calls an `emptyList` function
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/996b36b3-22db-44b0-ab46-dbe9dbeb4b26.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we've seen how to work with immutable lists with a pre-defined bunch of
    elements, but what if we need to add items to the `list` value dynamically? Kotlin
    provides you with mutable lists for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will help you understand immutable lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46f5c310-a7fc-460e-bd34-12381e8a332f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let us explain the program. So, at first, we created the `list` value with
    `mutableListOf` function on comment `(1)`, with the items `1`, `2`, and `4`. Note,
    we skipped the type parameter here, it's not important if you pass the elements
    to the function, as Kotlin has type interference. We printed the `list` values
    before moving ahead to add items.
  prefs: []
  type: TYPE_NORMAL
- en: For `listOf` or any other collections function, type interference is an issue.
    So, you'll not need to specify the generic type of the collection in use if you
    pass the elements or if you've provided the type of the collection itself.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)`, we added item `5` to the `list`, with the `List$add()` function,
    which appends the provided item to the `list` array.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on comment `(3)`, we used the `add` function with an index parameter,
    to add item `4` to the second position (counting from `0`, as usual).
  prefs: []
  type: TYPE_NORMAL
- en: Then, again we appended the `list` array with `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we added elements to a `list` array and accessed all the items through
    the `for` loop, but what about accessing a single element? Let''s have an example
    to access and modify single elements in Kotlin. Go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We accessed the third element with index `2` and the fourth element with index
    `3`. The reason is simple and straightforward as, with arrays and in lists, counting
    begins at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The thing to notice here is that Kotlin provides out-of-the-box support for
    lists and provides you with a square bracket operator (`[]`) to access elements
    of the `list` value just like an array. In the first `get` statement, we used
    the `get` function with an index to get the element of that index; in the second
    `get` statement, we used the square brackets, which, in turn, call that `get`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: As lists store items as per their order/index, it's easy to get items from a
    list with an index; you can easily skip a loop if you want just a particular element
    from that list and if you know the index for the element you want. Just pass the
    element to the `get` function and you have the element.
  prefs: []
  type: TYPE_NORMAL
- en: This `get` element by index is not supported by other collection interfaces
    like `set` (though `OrderedSet` supports them), which doesn't support the ordering
    of elements.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we have got a little grip on lists, let us move ahead and have a look
    at the sets.
  prefs: []
  type: TYPE_NORMAL
- en: Set and MutableSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like `List`, `Set` also has the following two variants in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MutableSet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set` is read-only and `MutableSet` is the mutable version of `Set`, which
    contains the read-write functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like with list, set values also have read-only functions and properties
    like `size`, `iterator()`, and so on. We are skipping mentioning them here to
    avoid redundant contents in this book. Also, please note that set doesn't do ordering
    like list (unless you use `OrderedSet`). So, it lacks the functions which involve
    orders like `indexOf(item)`, `add(index, item)`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Sets in collections represent mathematical sets (as in set theory).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example with `MutableSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5486b76-2bb9-4eed-ac21-6e4bbcba1367.png)'
  prefs: []
  type: TYPE_IMG
- en: The output clearly shows that, even though we added multiple duplicate items
    to the `set`, both at the time of initialization and later, only unique items
    got inserted and all duplicate items got ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may be curious as to whether the same will happen with custom classes
    and data classes; let us check with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we first created a data class and a custom class, then we created
    sets with them and inserted duplicate items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the following output to check whether the sets are free of duplicate
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49fedff6-df68-4e79-b4c8-61511cfd80a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Have a look at the preceding output carefully. While, as is the case with data
    classes,  `set` ignored the duplicate items, when trying the same with a normal
    class, it was unable to detect the duplicate insertions and kept them.
  prefs: []
  type: TYPE_NORMAL
- en: The last item that got added in `dataClassSet`—`MyDataClass(2,"will be added")`
    if you think it was a duplicate item then check again, while the value of `someNumericValue`
    for this object is identical to a previous one, the `someStringValue` value differs
    from that previous object's `someStringValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this an anomaly? The answer is short and simple—the collections framework
    internally uses `hashCode()` and `equals()` functions to perform equality checks
    while adding items to the `set` values and they are missing from the custom class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, the compiler automatically extracts the `hashCode()` and `equals()`
    functions. Thus, the `set` values were able to distinguish between duplicate items
    without custom implementations of those functions. For more information on data
    classes visit the following link: [https://kotlinlang.org/docs/reference/data-classes.html](https://kotlinlang.org/docs/reference/data-classes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we implement those functions, then `set` will be able to distinguish
    between the duplicate items in the `customClassSet` values as well. Obviously,
    that''s how it works for data classes as well. Just add the following code to
    the `MyCustomClass` definition and run the program to see the difference yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Cool, isn't it? So, we are done with `List` and `Set`. Let us now have a look
    at the `Map` interface; then, we will discuss the data operation functions provided
    by the collections framework.
  prefs: []
  type: TYPE_NORMAL
- en: Map and MutableMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Map` interface in the collections framework is a bit different than all
    others interfaces we have covered earlier; unlike others it works with key-value
    pairs. No, this is not similar to `Pair`; `Pair` is just a pair of two values
    combined together, while a map is a collection of key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: In a map, keys are unique and cannot be duplicated. If you add two values with
    the same key, then the later one will replace the previous one. Values, on the
    other hand can be redundant/duplicate. The reason behind this behavior is that
    in a map, a value is stored and retrieved with respect to its key, so redundant
    keys will make it impossible to distinguish them from each-other and to fetch
    their values.
  prefs: []
  type: TYPE_NORMAL
- en: The declaration of `Map` in Kotlin reads like interface `Map<K, out V>`, the
    `K` value is the generic type of the key and `V` is the generic type of value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about collections, let us have a look at a few of the functions
    and properties. Go through the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`val size: Int`: This function indicates the size of the `Map` interface, that
    is, the number of key-value pairs residing inside the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun isEmpty(): Boolean`: This function helps in checking whether a `Map` interface
    is empty or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun containsKey(key: K): Boolean`: This function checks for the provided `key`
    inside the collection of key-value pairs it has and returns `true` if it is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator fun get(key: K): V?`: This function cum operator (if used by square
    brackets (`[]`) like an array) returns the value corresponding to a key or null
    if the key doesn''t exist within it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val keys: Set<K>`: This function indicates the collection of keys available
    in that map at that point of time. As keys cannot be duplicated and they are not
    ordered, a `Set` value is the best data-structure to hold them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val values: Collection<V>`: Contains all the values of the `map` value as
    a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interface Entry<out K, out V>`: This function is defined inside the `Map`
    interface. An `Entry` represents a single key-value pair in the `Map` interface.
    The key-value pairs are stored as an entry inside the `map` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val entries: Set<Map.Entry<K, V>>`: This function gets you all the entries
    in the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previous were read-only interfaces of `Map` as it only supports read-only
    operations. For read-write access, you''ve to use the `mutableMap` function. So,
    let us now have a look at the read-write interfaces provided by `mutableMap` as
    seen in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fun put(key: K, value: V): V?` : This interface adds a key-value pair to the
    `Map` and returns the previous value associated with the key (if any or null if
    the key wasn''t present in the `Map` earlier).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun remove(key: K): V?` : This interface removes a key-value pair from the
    map with the key and returns the value and returns null if the key doesn''t exist
    in the `Map` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun putAll(from: Map<out K, V>): Unit` : This interface adds the key-value
    pairs from the provided `map` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fun clear(): Unit`: As the name suggests, this instance clears the `map` value.
    It removes everything that the `map` value contains—every key and every value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, as we now know the interfaces and functions the `Map` interfaces has to
    offer, let's now have an example with `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we demonstrated the use of the following two types of maps:'
  prefs: []
  type: TYPE_NORMAL
- en: Read-only `Map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-write `MutableMap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin provides you with a version of the `mapOf()` function that accepts `vararg`
    parameters of the `Pair` type. This makes it easy for you to create read-only
    maps—just pass the key-value pairs as the instances of `Pair` to the `mapOf()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the output before further inspecting and discussing the program.
    See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/011bf909-bf9d-4205-90bf-cfa0e42bcfb0.png)'
  prefs: []
  type: TYPE_IMG
- en: While creating the map, on comment `(1),` we passed a `"Five".to(0)` pair and
    on comment `(2)`, we passed the `"Five".to(5)` pair to the same `mapOf` function,
    to check which value the `map` stores for the `"Five"` key; the output suggests
    that the `map` took the second value—`5`, as we described earlier that a `map` value
    always takes the last value for the same key.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that Kotlin supports array-like square brackets in `Map` as well.
    Instead of an index, you can pass the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as we got our hands dirty with three most important interfaces in Kotlin''s
    collection framework: `List`, `Set`, and `Map`. Let''s now move forward and get
    ourselves introduced to data operations in a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: Data operations in a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin provides out-of-the-box support for its collection framework. As a result,
    the collections framework in Kotlin is full of interesting features that make
    it stand apart from the collections framework in other languages, such as Java.
    You already got introduced with some of those features, such as separate interfaces
    for read-only and mutable collections, square box operator-like arrays, and so
    on. What I'm going to introduce now is probably the most interesting feature of
    Kotlin's collections framework, but goes mostly unnoticed—data operation functions.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin supports data operation functions for all of its collections framework
    interfaces, objects, and classes. By data operation functions, I mean the operators
    and functions by which we can access, process or operate on data from a collection;
    if you are familiar with ReactiveX framework/RxJava/RxKotlin, you'll find it similar
    as Kotlin picked them mostly from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of a few of the collection data operation functions
    that we are going to cover here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filter` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `flatMap` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drop` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `take` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `zip` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what are we waiting for? Let us get started.
  prefs: []
  type: TYPE_NORMAL
- en: Though, the data operation functions with collections make you feel like you're
    working with streams/Rx, they are in no way similar to streams/Rx. What they do
    is simply use high order functions and extension functions to provide you with
    stream-like interfaces and internally they operate on the same loops (yes, you
    read it right, they use loops to produce results and then return it from the function
    just like a simple imperial program). It is advisable to avoid bigger chains of
    these functions in your program, as you'll end up with multiple loops. Using `forEach`
    or your own loop in such scenarios is a better choice, as you will be able to
    perform multiple operations with a single loop with `forEach` or with your own
    loop. However, for a single operation or small chains, you can definitely use
    these functions to make your code well organized.
  prefs: []
  type: TYPE_NORMAL
- en: The map function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map` function allows you to apply an algorithm to a collection all-together
    and obtain the results as a resultant set. It's helpful in making your code well-organized
    and writing loops (though it'll use loop internally, you're freed from writing
    those boilerplate codes).
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function receives all the elements of the collection as each iteration
    and should return the computed resultant item that should be placed in the resultant
    list in place of the passed item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, we had a list of `Int`, we needed to multiply each item from the `list` value
    with `2`, and we did it with ease with just a single line of code—`list.map {
    it*2 }`, which would normally take us two or three lines more of boilerplate.
    Insane, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b178834e-cece-4c43-9e2e-c0bf9ae395bb.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the `map` function applied the provided lambda to each of the elements
    of the list and returned the resultant list.
  prefs: []
  type: TYPE_NORMAL
- en: The filter function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of a situation where you need to filter the items in a collection. For
    example, when you want to obtain only even numbers from a list of integers. The
    `filter` function is there to help you in these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` function receives all the elements of the collection as each iteration
    and should return `true` or `false`, based on its determination of whether the
    passed item should be on the resultant list or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we first obtained a list of `Int` containing numbers from `1`
    to `50` with the help of `IntRange`. We then filtered the list to obtain even
    numbers on comment `(2)` and printed them. On comment `(3)`, we filtered the list
    (the original list containing `Int` values from `1` to `50`) to obtain perfect
    squares and printed them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f0bbb4f-4034-4041-89ed-e9fb2c5d9b48.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous code snippet and its output show just how much boilerplate code
    can be eliminated with the help of these data operation functions.
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another awesome function available with collections framework is the `flatMap`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `map` function, it receives each of the items in the collection as
    an iteration, but, unlike the `map` function, it should return another collection
    for each of the items passed. These returned collections are then combined to
    create the resultant collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ba5c3b3-b4dd-4360-bd5f-eb3bdab9141b.png)'
  prefs: []
  type: TYPE_IMG
- en: While the original list contained only three numbers—`10`, `20`, and `30`, the
    resultant list contains three more numbers for each of the numbers in the original
    list, all thanks to the `flatMap` function.
  prefs: []
  type: TYPE_NORMAL
- en: The drop functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be some scenarios when you want to drop a portion (say, the first
    5 or the last 10) of the collection and work on the remaining parts. Kotlin''s
    collection framework provides you with a set of the `drop` functions that can
    help you in these scenarios. Have a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we've dropped the first `25` items from the list on
    comment `(1)`, and on comment `(2)`, I've dropped the last `25` items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d75cc5be-d87a-479e-a934-9025fbeafeff.png)'
  prefs: []
  type: TYPE_IMG
- en: Worked perfectly, didn't it?
  prefs: []
  type: TYPE_NORMAL
- en: The take functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `take` functions work in just the opposite way to the `drop` functions.
    You can take a selection from the collection and ignore the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While statements on comment `(1)` and comment `(2)` are opposite to the `drop`
    functions earlier, they just take and print the `25` items from the list.
  prefs: []
  type: TYPE_NORMAL
- en: The statement on comment `(3)` is a bit different, here we used the `takeWhile`
    function. The `takeWhile` function takes a predicate and keeps taking items on
    the resultant collection while the predicate returns `true`; once the predicate
    returns `false` the `takeWhile` value will stop checking for any more items and
    will return the resultant collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `takeLastWhile` values work in a similar way but in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df4ae23a-0073-4ee7-898b-0f9e55ff1e2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now move ahead with the `zip` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The zip function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `zip` function does exactly what it sounds like, it zips collections. Confusing?
    Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We created two lists—one with `Int` and the other with `String`. We then created
    a resultant list by zipping the `Int` list with the `String` list and printed
    the resultant list.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the `resultantList` value contain? What operation did the `zip`
    function perform?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us decide it ourselves by having a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f158d2ea-32e5-44bc-9911-b32f07745d98.png)'
  prefs: []
  type: TYPE_IMG
- en: Amazing, isn't it? The `zip` function takes another collection, combines the
    source collection with the provided collection, and creates a `Pair` value for
    each of the items. But what if the collections differ in item counts? What if
    we want to combine each item in a list with the next item in the same list?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another example. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, the first `println` statement here answers our first question—it tries to
    combine two lists with asymmetrical item counts.
  prefs: []
  type: TYPE_NORMAL
- en: On the second `println` statement, we used the `zipWithNext` function, which
    zips one item of a collection with the next item of the same collection. So, let's
    have a look at the output to find out what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ccd9aa4-3a4b-446d-9fb4-a76c1d876257.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the `zip` operator only zipped those items of `list1`, for which it could
    find a pair in `list2` and skipped the remaining. The `zipWithNext` operator on
    the other hand, worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: So, we are done with data operation functions in Kotlin collection framework.
    However, Kotlin provides you with more capabilities for collections; so, let's
    move ahead and see what more it has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin's collection framework allows you to group collections based on your
    requirements. For example, if you have a list of strings and want to group them
    with respect to their size, you can easily do that with the help of the `groupBy`
    function, which groups a collection based on the logic provided and returns `Map`
    with that group of collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the following is a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what we did here is as follows: we created a list of `Int` containing numbers
    from `1` to `50` (both inclusive) then, we tried to group them based on their
    remnants when divided by `5`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there should be five groups, from `0` to `5`, and each of them should contain
    10 numbers. Let''s check the following output to see if that happened or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d47e4fd-5eba-4647-8a73-9540bc7d9d44.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the `groupBy` function just worked as expected and returned `Map<Int,List<Int>>`
    that contained the grouped list.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, this chapter was on collections and data operations in Kotlin. We started
    the chapter by exploring the collection framework in Kotlin and data structure
    of collections, and we gradually moved towards learning the data operations and
    functions that Kotlin collection framework provides out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to work with functional programming,
    reactive programming, and OOP altogether. We believe Kotlin is the best language
    for this, as it lets you take the benefits of both worlds—functional programming
    and OOP. In the next chapter, we will see how to take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will also introduce ourselves to the ReactiveX framework,
    which is among the most popular frameworks for functional reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: So, lets move ahead; the next chapter is just a page turn away.
  prefs: []
  type: TYPE_NORMAL
