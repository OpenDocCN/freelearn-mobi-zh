["```swift\n#import \"GameWaypoint.h\"\n@interface GameActor : GameObject {\nNSMutableArray *waypoints;\nfloat runSpeed;\n}\n@end\n@implementation GameActor\n-(void) processWaypoints {\nbool removeFirstWaypoint = NO;\n//The actor's position onscreen\nCGPoint worldPosition = CGPointMake(self.body->GetPosition().x * PTM_RATIO, self.body->GetPosition().y * PTM_RATIO);\n//Process waypoints\nfor(GameWaypoint *wp in waypoints){\nfloat distanceToNextPoint = [GameHelper distanceP1:worldPosition toP2:CGPointMake(wp.position.x, wp.position.y)];\n//If we didn't make progress to the next point, increment timesBlocked\nif(distanceToNextPoint >= wp.lastDistance){\ntimesBlocked++;\n//Drop this waypoint if we failed to move a number of times\nif(timesBlocked > TIMES_BLOCKED_FAIL){\ndistanceToNextPoint = 0.0f;\n}\n}else{\n//If we are just starting toward this point we run our pre-callback\nwp.lastDistance = distanceToNextPoint;\n[wp processPreCallback];\n}\n//If we are close enough to the waypoint we move onto the next one\nif(distanceToNextPoint <= WAYPOINT_DIST_THRESHOLD){\nremoveFirstWaypoint = YES;\n[self stopRunning];\n//Run post callback\n[wp processPostCallback];\n}else{\n//Keep running toward the waypoint\nfloat speedMod = wp.speedMod;\n//Slow down close to the waypoint\nif(distanceToNextPoint < [self runSpeed]/PTM_RATIO){\nspeedMod = (distanceToNextPoint)/([self runSpeed]/PTM_RATIO);\n}\n[self runWithVector:ccp(wp.position.x - worldPosition.x, wp.position.y - worldPosition.y) withSpeedMod:speedMod withConstrain:NO ];\nbreak;\n}\n}\nif(removeFirstWaypoint){\n[waypoints removeObjectAtIndex:0];\ntimesBlocked = 0;\n}\n}\n@end\n@implementation Ch7_Waypoints\n-(CCLayer*) runRecipe {\n//Add polygons\n[self addRandomPolygons:10];\n//Create Actor\n[self addActor];\n/* CODE OMITTED */\nreturn self;\n}\n-(void) step: (ccTime) dt {\n[super step:dt];\n//Process actor waypoints\n[actor processWaypoints];\n//Turn actor toward next waypoint\nif(actor.waypoints.count > 0){\nCGPoint movementVector = ccp(actor.body->GetLinearVelocity().x, actor.body->GetLinearVelocity().y);\nactor.body->SetTransform(actor.body->GetPosition(), -1 * [GameHelper vectorToRadians:movementVector] + PI_CONSTANT/2);\n}\n}\n/* Draw all waypoint lines */\n-(void) drawLayer {\nglColor4ub(255,255,0,32);\nCGPoint actorPosition = ccp(actor.body->GetPosition().x*PTM_RATIO, actor.body->GetPosition().y*PTM_RATIO);\nif(actor.waypoints.count == 1){\nGameWaypoint *gw = (GameWaypoint*)[actor.waypoints objectAtIndex:0];\nccDrawLine(actorPosition, gw.position);\n}else if(actor.waypoints.count > 1){\nfor(int i=0; i<actor.waypoints.count-1; i++){\nGameWaypoint *gw = (GameWaypoint*)[actor.waypoints objectAtIndex:i];\nGameWaypoint *gwNext = (GameWaypoint*)[actor.waypoints objectAtIndex:i+1];\nif(i == 0){\n//From actor to first waypoint\nccDrawLine(actorPosition, gw.position);\nccDrawLine(gw.position, gwNext.position);\n}else{\n//From this waypoint to next one\nccDrawLine(gw.position, gwNext.position);\n}\n}\n}\nglColor4ub(255,255,255,255);\n}\n/* Add a new waypoint when you touch the screen */\n-(void) tapWithPoint:(CGPoint)point {\nObjectCallback *goc1 = [ObjectCallback createWithObject:self withCallback:@\"movingToWaypoint\"];\nObjectCallback *goc2 = [ObjectCallback createWithObject:self withCallback:@\"reachedWaypoint\"];\nGameWaypoint *wp = [GameWaypoint createWithPosition:[self convertTouchCoord:point] withSpeedMod:1.0f];\nwp.preCallback = goc1;\nwp.postCallback = goc2;\n[actor addWaypoint:wp];\n}\n@end\n\n```", "```swift\n    for all waypoints\n    if we didn't make progress, increment timesBlocked\n    if we have reached this waypoint we remove it and move to the next\n    else keep running toward this waypoint and break the loop\n\n    ```", "```swift\n    [preCallback.obj performSelector:NSSelectorFromString(preCallback.callback)];\n\n    ```", "```swift\n    NSMutableArray *convexPolygon = [GameHelper convexHull:points];\n\n    ```", "```swift\n@implementation Ch7_ProjectileAiming\n-(void) step: (ccTime) dt {\n[super step:dt];\n/* CODE OMITTED */\n//Firing projectiles\nfireCount += dt;\nif(fireCount > 1.0f){\nfireCount = 0;\n[self fireMissiles];\n}\n}\n/* Each enemy fires a missile object */\n-(void) fireMissiles {\nfor(int i=0; i<enemies.count; i++){\nGameActor *enemy = [enemies objectAtIndex:i];\n//Create missile\nGameMisc *missile = [[GameMisc alloc] init];\nmissile.gameArea = self;\nmissile.tag = GO_TAG_MISSILE;\nmissile.bodyDef->type = b2_dynamicBody;\nmissile.bodyDef->position.Set( enemy.body->GetPosition().x, enemy.body->GetPosition().y );\nmissile.bodyDef->userData = missile;\nmissile.body = world->CreateBody(missile.bodyDef);\nmissile.polygonShape = new b2PolygonShape();\nmissile.polygonShape->SetAsBox(0.5f, 0.2f);\nmissile.fixtureDef->density = 10.0f;\nmissile.fixtureDef->shape = missile.polygonShape;\nmissile.fixtureDef->filter.categoryBits = CB_MISSILE;\nmissile.fixtureDef->filter.maskBits = CB_EVERYTHING & ~CB_MISSILE & ~CB_ENEMY;\nmissile.body->CreateFixture(missile.fixtureDef);\n//Calculate intercept trajectory\nVector3D *point = [self interceptSrc:missile dst:actor projSpeed:20.0f];\nif(point){\n//Align missile\nCGPoint pointToFireAt = CGPointMake(point.x, point.y);\nCGPoint directionVector = CGPointMake(pointToFireAt.x - missile.body->GetPosition().x, pointToFireAt.y - missile.body->GetPosition().y);\nfloat radians = [GameHelper vectorToRadians:directionVector];\nmissile.body->SetTransform(missile.body->GetPosition(), -1 * radians + PI_CONSTANT/2);\n//Fire missile\nCGPoint normalVector = [GameHelper radiansToVector:radians];\nmissile.body->SetLinearVelocity( b2Vec2(normalVector.x*20.0f, normalVector.y*20.0f) );\n}\n[missiles addObject:missile];\n}\n}\n/* Find the intercept angle given projectile speed and a moving target */\n-(Vector3D*) interceptSrc:(GameObject*)src dst:(GameObject*)dst projSpeed:(float)projSpeed {\nfloat tx = dst.body->GetPosition().x - src.body->GetPosition().x;\nfloat ty = dst.body->GetPosition().y - src.body->GetPosition().y;\nfloat tvx = dst.body->GetLinearVelocity().x;\nfloat tvy = dst.body->GetLinearVelocity().y;\n//Get quadratic equation components\nfloat a = tvx*tvx + tvy*tvy - projSpeed*projSpeed;\nfloat b = 2 * (tvx * tx + tvy * ty);\nfloat c = tx*tx + ty*ty;\n//Solve quadratic equation\nVector3D *ts = [GameHelper quadraticA:a B:b C:c];\n//Find the smallest positive solution\nVector3D *solution = nil;\nif(ts){\nfloat t0 = ts.x;\nfloat t1 = ts.y;\nfloat t = MIN(t0,t1);\nif(t < 0){ t = MAX(t0,t1); }\nif(t > 0){\nfloat x = dst.body->GetPosition().x + dst.body->GetLinearVelocity().x*t;\nfloat y = dst.body->GetPosition().y + dst.body->GetLinearVelocity().y*t;\nsolution = [Vector3D x:x y:y z:0];\n}\n}\nreturn solution;\n}\n@end\n\n```", "```swift\n    x = (-b +/- sqrt(b2 - 4ac)) / 2a\n\n    ```", "```swift\n    float a = tvx*tvx + tvy*tvy - projSpeed*projSpeed;\n    float b = 2 * (tvx * tx + tvy * ty);\n    float c = tx*tx + ty*ty;\n\n    ```", "```swift\n    Vector3D *ts = [GameHelper quadraticA:a B:b C:c];\n\n    ```", "```swift\n    float x = dst.body->GetPosition().x + dst.body->GetLinearVelocity().x*t;\n    float y = dst.body->GetPosition().y + dst.body->GetLinearVelocity().y*t;\n    solution = [Vector3D x:x y:y z:0];\n\n    ```", "```swift\n    missile.fixtureDef->filter.categoryBits = CB_MISSILE;\n    missile.fixtureDef->filter.maskBits = CB_EVERYTHING & ~CB_MISSILE & ~CB_ENEMY;\n\n    ```", "```swift\nclass RayCastAnyCallback : public b2RayCastCallback\n{\npublic:\nRayCastAnyCallback()\n{\nm_hit = false;\n}\nfloat32 ReportFixture( b2Fixture* fixture, const b2Vec2& point,\nconst b2Vec2& normal, float32 fraction)\n{\nb2Body* body = fixture->GetBody();\nvoid* userData = body->GetUserData();\nif (userData)\n{\nint32 index = *(int32*)userData;\nif (index == 0)\n{\n// filter\nreturn -1.0f;\n}\n}\nm_hit = true;\nm_point = point;\nm_normal = normal;\nm_fraction = fraction;\nm_fixture = fixture;\nreturn 0.0f;\n}\nbool m_hit;\nb2Vec2 m_point;\nb2Vec2 m_normal;\nfloat32 m_fraction;\nb2Fixture *m_fixture;\n};\n@implementation Ch7_LineOfSight\n-(void) step: (ccTime) dt {\n[super step:dt];\n/* CODE OMITTED */\n//Make the enemies follow the actor\n[self followActorWithEnemies];\n}\n-(void) followActorWithEnemies {\n//If enemies can see the actor they follow\nfor(int i=0; i<enemies.count; i++){\n//Align enemies\nGameActor *enemy = [enemies objectAtIndex:i];\nCGPoint directionVector = CGPointMake(actor.body->GetPosition().x - enemy.body->GetPosition().x, actor.body->GetPosition().y - enemy.body->GetPosition().y);\nfloat radians = [GameHelper vectorToRadians:directionVector];\nenemy.body->SetTransform(enemy.body->GetPosition(), -1 * radians + PI_CONSTANT/2);\nRayCastClosestCallback callback;\nworld->RayCast(&callback, enemy.body->GetPosition(), actor.body->GetPosition());\n//Did the raycast hit anything?\nenemy.tag = 0; //Assume it didn't\n//Note that in this case we are using the 'tag' property for something other than its intended purpose.\nif(callback.m_hit){\n//Is the closest point the actor?\nif(callback.m_fixture->GetBody() == actor.body){\n//If so, follow the actor\nb2Vec2 normal = b2Vec2( callback.m_normal.x * -5.0f, callback.m_normal.y * -5.0f);\nenemy.body->ApplyForce(normal, actor.body->GetPosition());\nenemy.tag = 1; //Set seeing flag to true\n}\n}\n}\n}\n/* Draw each enemy 'sight line' if they can see you */\n-(void) drawLayer {\nfor(int i=0; i<enemies.count; i++){\nGameActor *enemy = [enemies objectAtIndex:i];\nif(enemy.tag == 1){\nglColor4ub(255,255,0,32);\nCGPoint actorPosition = ccp(actor.body->GetPosition().x*PTM_RATIO, actor.body->GetPosition().y*PTM_RATIO);\nCGPoint enemyPosition = ccp(enemy.body->GetPosition().x*PTM_RATIO, enemy.body->GetPosition().y*PTM_RATIO);\nccDrawLine(actorPosition, enemyPosition);\nglColor4ub(255,255,255,255);\n}\n}\n}\n@end\n\n```", "```swift\n    RayCastClosestCallback callback;\n    world->RayCast(&callback, enemy.body->GetPosition(), actor.body->GetPosition());\n\n    ```", "```swift\n@interface Ch7_AIFlocking : Ch7_LineOfSight {}\n/* CODE OMITTED */\n@end\n@implementation Ch7_AIFlocking\n-(void) step:(ccTime)delta {\n[super step:delta];\n//Process the 'boids' flocking algorithm\n[self processBoids];\n}\n/* Make the flock of 'boids' follow the actor */\n-(void) followActorWithEnemies {\n//All enemies constantly follow the actor\nfor(int i=0; i<enemies.count; i++){\n//Align enemies\nGameActor *enemy = [enemies objectAtIndex:i];\nCGPoint directionVector = CGPointMake(actor.body->GetPosition().x - enemy.body->GetPosition().x, actor.body->GetPosition().y - enemy.body->GetPosition().y);\nfloat radians = [GameHelper vectorToRadians:directionVector];\nenemy.body->SetTransform(enemy.body->GetPosition(), -1 * radians + PI_CONSTANT/2);\nb2Vec2 normal = actor.body->GetPosition() - enemy.body->GetPosition();\nCGPoint vector = ccp(normal.x, normal.y);\nCGPoint normalVector = [GameHelper radiansToVector:[GameHelper vectorToRadians:vector]];\n//If so, follow the actor\nb2Vec2 v = enemy.body->GetLinearVelocity();\nenemy.body->SetLinearVelocity(b2Vec2(v.x + normalVector.x*0.2f, v.y + normalVector.y*0.2f));\n}\n}\n/* Process boids algorithm */\n-(void) processBoids {\nfor(int i=0; i<enemies.count; i++){\nGameActor *b = [enemies objectAtIndex:i];\nb2Vec2 v1 = b2Vec2(0,0);\nb2Vec2 v2 = b2Vec2(0,0);\nb2Vec2 v3 = b2Vec2(0,0);\nv1 = [self boidRule1:b];\nv2 = [self boidRule2:b];\nv3 = [self boidRule3:b];\nb2Vec2 v = b.body->GetLinearVelocity();\nb2Vec2 newV = v+v1+v2+v3;\n/* Limit velocity */\nfloat vLimit = 7.5f;\nb2Vec2 absV = b2Vec2([GameHelper absoluteValue:newV.x], [GameHelper absoluteValue:newV.y]);\nif(absV.x > vLimit || absV.y > vLimit){\nfloat ratio;\nif(absV.x > absV.y){\nratio = vLimit / absV.x;\n}else{\nratio = vLimit / absV.y;\n}\nnewV = b2Vec2( newV.x*ratio, newV.y*ratio );\n}\nb.body->SetLinearVelocity(newV);\n}\n}\n/* Clump the Boids together */\n-(b2Vec2) boidRule1:(GameActor*)bJ {\n//The variable 'pcJ' represents the center point of the flock\nb2Vec2 pcJ = b2Vec2(0,0);\nfloat N = enemies.count;\n//Add up all positions\nfor(int i=0; i<enemies.count; i++){\nGameActor *b = [enemies objectAtIndex:i];\nif(b != bJ){\npcJ += b.body->GetPosition();\n}\n}\n//Average them out\npcJ = b2Vec2(pcJ.x/(N-1), pcJ.y/(N-1));\n//Return 1/100 of the velocity required to move to this point\nreturn b2Vec2( (pcJ.x - bJ.body->GetPosition().x)/100.0f, (pcJ.y - bJ.body->GetPosition().y)/100.0f );\n}\n/* Keep the Boids apart from each other */\n-(b2Vec2) boidRule2:(GameActor*)bJ {\n//Set optimal distance boids should keep between themselves (padding)\nfloat padding = 1.5f;\n//The variable 'c' represents the velocity required to move away from any other boids in this one's personal space\nb2Vec2 c = b2Vec2(0,0);\n//If an ememy is too close we add velocity required to move away from it\nfor(int i=0; i<enemies.count; i++){\nGameActor *b = [enemies objectAtIndex:i];\nif(b != bJ){\nCGPoint bPos = ccp(b.body->GetPosition().x, b.body->GetPosition().y);\nCGPoint bJPos = ccp(bJ.body->GetPosition().x, bJ.body->GetPosition().y);\nif([GameHelper distanceP1:bPos toP2:bJPos] < padding){\nc = c - (b.body->GetPosition() - bJ.body->GetPosition());\n}\n}\n}\nreturn c;\n}\n/* Match up all Boid velocities */\n-(b2Vec2) boidRule3:(GameActor*)bJ {\n//The variable 'pvJ' represents the total velocity of all the boids combined\nb2Vec2 pvJ = b2Vec2(0,0);\n//Get the total velocity\nfor(int i=0; i<enemies.count; i++){\nGameActor *b = [enemies objectAtIndex:i];\nif(b != bJ){\npvJ += b.body->GetLinearVelocity();\n}\n}\n//Get this boid's velocity\nb2Vec2 v = bJ.body->GetLinearVelocity();\n//Return the difference averaged out over the flock then divided by 30\nreturn b2Vec2((pvJ.x - v.x)/30.0f/enemies.count, (pvJ.y - v.y)/30.0f/enemies.count);\n}\n@end\n\n```", "```swift\n    enemy.body->SetLinearVelocity(b2Vec2(v.x + normalVector.x*0.2f, v.y + normalVector.y*0.2f));\n\n    ```", "```swift\n    float vLimit = 7.5f;\n    b2Vec2 absV = b2Vec2([GameHelper absoluteValue:newV.x], [GameHelper absoluteValue:newV.y]);\n    if(absV.x > vLimit || absV.y > vLimit){\n    float ratio;\n    if(absV.x > absV.y){\n    ratio = vLimit / absV.x;\n    }else{\n    ratio = vLimit / absV.y;\n    }\n    newV = b2Vec2( newV.x*ratio, newV.y*ratio );\n    }\n    b.body->SetLinearVelocity(newV);\n\n    ```", "```swift\n/* AStarNode */\n@interface AStarNode : NSObject\n{\nCGPoint position; //The node's position on our map\nNSMutableArray *neighbors; //An array of neighbor AStarNode objects\nbool active; //Is this node active?\nfloat costMultiplier; //Use this to multiply the normal cost to reach this node.\n}\n@end\n@implementation AStarNode\n/* Cost to node heuristic */\n-(float) costToNode:(AStarNode*)node {\nCGPoint src = ccp(self.position.x, self.position.y);\nCGPoint dst = ccp(node.position.x, node.position.y);\nfloat cost = [GameHelper distanceP1:src toP2:dst] * node.costMultiplier;\nreturn cost;\n}\n@end\n/* AStarPathNode */\n@interface AStarPathNode : NSObject\n{\nAStarNode *node; //The actual node this \"path\" node points to\nAStarPathNode *previous; //The previous node on our path\nfloat cost; //The cumulative cost of reaching this node\n}\n@end\n@implementation AStarPathNode\n/* Our implementation of the A* search algorithm */\n+(NSMutableArray*) findPathFrom:(AStarNode*)fromNode to:(AStarNode*)toNode {\nNSMutableArray *foundPath = [[NSMutableArray alloc] init];\nif(fromNode.position.x == toNode.position.x && fromNode.position.y == toNode.position.y){\nreturn nil;\n}\nNSMutableArray *openList = [[[NSMutableArray alloc] init] autorelease];\nNSMutableArray *closedList = [[[NSMutableArray alloc] init] autorelease];\nAStarPathNode *currentNode = nil;\nAStarPathNode *aNode = nil;\nAStarPathNode *startNode = [AStarPathNode createWithAStarNode:fromNode];\nAStarPathNode *endNode = [AStarPathNode createWithAStarNode:toNode];\n[openList addObject:startNode];\nwhile(openList.count > 0){\ncurrentNode = [AStarPathNode lowestCostNodeInArray:openList];\nif( currentNode.node.position.x == endNode.node.position.x &&\ncurrentNode.node.position.y == endNode.node.position.y){\n//Path Found!\naNode = currentNode;\nwhile(aNode.previous != nil){\n//Mark path\n[foundPath addObject:[NSValue valueWithCGPoint: CGPointMake(aNode.node.position.x, aNode.node.position.y)]];\naNode = aNode.previous;\n}\n[foundPath addObject:[NSValue valueWithCGPoint: CGPointMake(aNode.node.position.x, aNode.node.position.y)]];\nreturn foundPath;\n}else{\n//Still searching\n[closedList addObject:currentNode];\n[openList removeObject:currentNode];\nfor(int i=0; i<currentNode.node.neighbors.count; i++){\nAStarPathNode *aNode = [AStarPathNode createWithAStarNode:[currentNode.node.neighbors objectAtIndex:i]];\naNode.cost = currentNode.cost + [currentNode.node costToNode:aNode.node] + [aNode.node costToNode:endNode.node];\naNode.previous = currentNode;\nif(aNode.node.active && ![AStarPathNode isPathNode:aNode inList:openList] && ![AStarPathNode isPathNode:aNode inList:closedList]){\n[openList addObject:aNode];\n}\n}\n}\n}\n//No Path Found\nreturn nil;\n}\n@end\n/* Ch7_GridPathfinding */\n@implementation Ch7_GridPathfinding\n-(CCLayer*) runRecipe {\n//Initial variables\ngridSize = ccp(25,15);\nnodeSpace = 16.0f;\ntouchedNode = ccp(0,0);\nstartCoord = ccp(2,2);\nendCoord = ccp(gridSize.x-3, gridSize.y-3);\nfoundPath = [[NSMutableArray alloc] init];\n//Create 2D array (grid)\ngrid = [[NSMutableArray alloc] initWithCapacity:((int)gridSize.x)];\nfor(int x=0; x<gridSize.x; x++){\n[grid addObject:[[NSMutableArray alloc] initWithCapacity:((int)gridSize.y)]];\n}\n//Create AStar nodes and place them in the grid\nfor(int x=0; x<gridSize.x; x++){\nfor(int y=0; y<gridSize.y; y++){\n//Add a node\nAStarNode *node = [[AStarNode alloc] init];\nnode.position = ccp(x*nodeSpace + nodeSpace/2, y*nodeSpace + nodeSpace/2);\n[[grid objectAtIndex:x] addObject:node];\n}\n}\n//Add neighbor nodes\nfor(int x=0; x<gridSize.x; x++){\nfor(int y=0; y<gridSize.y; y++){\n//Add a node\nAStarNode *node = [[grid objectAtIndex:x] objectAtIndex:y];\n//Add self as neighbor to neighboring nodes\n[self addNeighbor:node toGridNodeX:x-1 Y:y-1]; //Top-Left\n[self addNeighbor:node toGridNodeX:x-1 Y:y]; //Left\n[self addNeighbor:node toGridNodeX:x-1 Y:y+1]; //Bottom-Left\n[self addNeighbor:node toGridNodeX:x Y:y-1]; //Top\n[self addNeighbor:node toGridNodeX:x Y:y+1]; //Bottom\n[self addNeighbor:node toGridNodeX:x+1 Y:y-1]; //Top-Right\n[self addNeighbor:node toGridNodeX:x+1 Y:y]; //Right\n[self addNeighbor:node toGridNodeX:x+1 Y:y+1]; //Bottom-Right\n}\n}\n/* CODE OMITTED */\nreturn self;\n}\n/* Find a path from the startNode to the endNode */\n-(void) findPath:(id)sender {\nAStarNode *startNode = [[grid objectAtIndex:(int)startCoord.x] objectAtIndex:(int)startCoord.y];\nAStarNode *endNode = [[grid objectAtIndex:(int)endCoord.x] objectAtIndex:endCoord.y];\nif(foundPath){\n[foundPath removeAllObjects];\n[foundPath release];\n}\nfoundPath = nil;\n//Run the pathfinding algorithm\nfoundPath = [AStarPathNode findPathFrom:startNode to:endNode];\nif(!foundPath){\n[self showMessage:@\"No Path Found\"];\n}else{\n[self showMessage:@\"Found Path\"];\n}\n}\n/* Helper method for adding neighbor nodes */\n-(void) addNeighbor:(AStarNode*)node toGridNodeX:(int)x Y:(int)y {\nif(x >= 0 && y >= 0 && x < gridSize.x && y < gridSize.y){\nAStarNode *neighbor = [[grid objectAtIndex:x] objectAtIndex:y];\n[node.neighbors addObject:neighbor];\n}\n}\n@end\n\n```", "```swift\n    +(NSMutableArray*) findPathFrom:(AStarNode*)fromNode to:(AStarNode*)toNode;\n\n    ```", "```swift\n    /* Cost to node heuristic */\n    -(float) costToNode:(AStarNode*)node {\n    CGPoint src = ccp(self.position.x, self.position.y);\n    CGPoint dst = ccp(node.position.x, node.position.y);\n    float cost = [GameHelper distanceP1:src toP2:dst] * node.costMultiplier;\n    return cost;\n    }\n\n    ```", "```swift\n@interface Ch7_Box2DPathfinding : GameArea2D\n{\nNSMutableArray *grid;\nfloat nodeSpace; //The space between each node, increase this to increase A* efficiency at the cost of accuracy\nint gridSizeX;\nint gridSizeY;\n}\n@end\n@implementation Ch7_Box2DPathfinding\n-(CCLayer*) runRecipe {\n//Initial variables\nnodeSpace = 32.0f;\nactorRadius = nodeSpace/PTM_RATIO/3;\n/* CODE OMITTED */\n//Remove neighbors from positive TestPoint and RayCast tests\nfor(int x=0; x<gridSizeX; x++){\nfor(int y=0; y<gridSizeY; y++){\n//Add a node\nAStarNode *node = [[grid objectAtIndex:x] objectAtIndex:y];\n//If a node itself is colliding with an object we cut off all connections\nfor (b2Body* b = world->GetBodyList(); b; b = b->GetNext()){\nif (b->GetUserData() != NULL) {\nGameObject *obj = (GameObject*)b->GetUserData();\nif(obj->polygonShape){\nb2Vec2 nodePosition = b2Vec2(node.position.x/PTM_RATIO, node.position.y/PTM_RATIO);\n//Test this node point against this polygon\nif(obj->polygonShape->TestPoint(b->GetTransform(), nodePosition)){\nfor(int i=0; i<node.neighbors.count; i++){\n//Remove connections\nAStarNode *neighbor = [node.neighbors objectAtIndex:i];\n[node.neighbors removeObject:neighbor];\n[neighbor.neighbors removeObject:node];\n}\n}\n}\n}\n}\n//Test all node to neighbor connections using a RayCast test\nfor(int i=0; i<node.neighbors.count; i++){\nAStarNode *neighbor = [node.neighbors objectAtIndex:i];\n//Do a RayCast from the node to the neighbor.\n//If there is something in the way, remove the link\nb2Vec2 nodeP = b2Vec2(node.position.x/PTM_RATIO, node.position.y/PTM_RATIO);\nb2Vec2 neighborP = b2Vec2(neighbor.position.x/PTM_RATIO, neighbor.position.y/PTM_RATIO);\n//Do 4 tests (based on actor size)\nfor(float x = -actorRadius; x <= actorRadius; x+= actorRadius*2){\nfor(float y = -actorRadius; y <= actorRadius; y+= actorRadius*2){\nRayCastAnyCallback callback;\nworld->RayCast(&callback, b2Vec2(nodeP.x+x,nodeP.y+y), b2Vec2(neighborP.x+x,neighborP.y+y));\nif(callback.m_hit){\n//Remove connections\n[node.neighbors removeObject:neighbor];\n[neighbor.neighbors removeObject:node];\nbreak; break;\n}\n}\n}\n}\n}\n}\nreturn self;\n}\n/* Find a path and add it (as a set of waypoints) when we tap the screen */\n-(void) tapWithPoint:(CGPoint)point {\n//Convert touch coordinate to physical coordinate\nCGPoint endPoint = [self convertTouchCoord:point];\nif(endPoint.x < 0 || endPoint.y < 0 || endPoint.x >= gameAreaSize.x*PTM_RATIO || endPoint.y >= gameAreaSize.y*PTM_RATIO){\nreturn;\n}\n//Actor position\nCGPoint actorPosition = ccp(actor.body->GetPosition().x*PTM_RATIO, actor.body->GetPosition().y*PTM_RATIO);\n//We use the last waypoint position if applicable\nif(actor.waypoints.count > 0){\nactorPosition = [[actor.waypoints objectAtIndex:actor.waypoints.count-1] position];\n}\n//Starting node\nAStarNode *startNode = [[grid objectAtIndex:(int)(actorPosition.x/nodeSpace)] objectAtIndex:(int)(actorPosition.y/nodeSpace)];\n//Make sure the start node is actually properly connected\nif(startNode.neighbors.count == 0){\nbool found = NO; float n = 1;\nwhile(!found){\n//Search the nodes around this point for a properly connected starting node\nfor(float x = -n; x<= n; x+= n){\nfor(float y = -n; y<= n; y+= n){\nif(x == 0 && y == 0){ continue; }\nfloat xIndex = ((int)(actorPosition.x/nodeSpace))+x;\nfloat yIndex = ((int)(actorPosition.y/nodeSpace))+y;\nif(xIndex >= 0 && yIndex >= 0 && xIndex < gridSizeX && yIndex < gridSizeY){\nAStarNode *node = [[grid objectAtIndex:xIndex] objectAtIndex:yIndex];\nif(node.neighbors.count > 0){\nstartNode = node;\nfound = YES;\nbreak; break;\n}\n}\n}\n}\nn += 1;\n}\n}\n//End node\nAStarNode *endNode = [[grid objectAtIndex:(int)(endPoint.x/nodeSpace)] objectAtIndex:(int)(endPoint.y/nodeSpace)];\n//Run the pathfinding algorithm\nNSMutableArray *foundPath = [AStarPathNode findPathFrom:startNode to:endNode];\nif(!foundPath){\n[self showMessage:@\"No Path Found\"];\n}else{\n[self showMessage:@\"Found Path\"];\n//Add found path as a waypoint set to the actor\nfor(int i=foundPath.count-1; i>=0; i--){\nCGPoint pathPoint = [[foundPath objectAtIndex:i] CGPointValue];\n[actor addWaypoint:[GameWaypoint createWithPosition:pathPoint withSpeedMod:1.0f]];\n}\n}\n}\n@end\n\n```", "```swift\n    obj->polygonShape->TestPoint(b->GetTransform(), nodePosition);\n\n    ```", "```swift\n    world->RayCast(&callback, b2Vec2(nodeP.x+x,nodeP.y+y), b2Vec2(neighborP.x+x,neighborP.y+y));\n\n    ```", "```swift\n@interface Ch7_TileMapPathfinding : Ch8_TMXTilemap\n{\nNSMutableArray *grid;\nfloat actorRadius;\n}\n@end\n@implementation Ch7_TileMapPathfinding\n-(CCLayer*) runRecipe {\n//Shorter variable names\nfloat mw = tileMap.mapSize.width;\nfloat mh = tileMap.mapSize.height;\nfloat tw = tileMap.tileSize.width;\nfloat th = tileMap.tileSize.height;\n/* CODE OMITTED */\n//Create active and inactive nodes determined by the \"Collidable\" TMX layer\nCCTMXLayer *collidableLayer = [tileMap layerNamed:@\"Collidable\"];\nfor(int x=0; x<mw; x++){\nfor(int y=0; y<mh; y++){\n//Add a node\nAStarNode *node = [[AStarNode alloc] init];\nnode.position = ccp(x*tw + tw/2, y*th + th/2);\nif([collidableLayer tileAt:ccp(x,y)]){ node.active = NO; }\n[[grid objectAtIndex:x] addObject:node];\n}\n}\n/* CODE OMITTED */\nreturn self;\n}\n@end\n\n```", "```swift\n/* SSAStarNode */\n@implementation SSAStarNode\n-(float) costToNeighbor:(SSNeighborNode*)nn {\nSSAStarNode *node = nn.node;\n//Here we use jumping/running to determine cost. We could also possibly use a heuristic.\nCGPoint src = ccp(self.position.x/PTM_RATIO, self.position.y/PTM_RATIO);\nCGPoint dst = ccp(node.position.x/PTM_RATIO, node.position.y/PTM_RATIO);\nfloat cost;\nif(node.body == self.body){\n//Compute simple distance\nfloat runTime = ([GameHelper distanceP1:src toP2:dst]) / actor.runSpeed;\ncost = runTime * node.costMultiplier;\n}else{\n//Compute a jump\nfloat y = dst.y - src.y;\nif(y == 0){ y = 0.00001f; } //Prevent divide by zero\nCGPoint launchVector = nn.launchVector;\nfloat gravity = actor.body->GetWorld()->GetGravity().y;\nVector3D *at = [GameHelper quadraticA:gravity*0.5f B:launchVector.y C:y*-1];\nfloat airTime;\nif(at.x > at.y){\nairTime = at.x;\n}else{\nairTime = at.y;\n}\ncost = airTime * node.costMultiplier;\n}\nreturn cost;\n}\n@end\n/* SSGameActor */\n@implementation SSGameActor\n+(Vector3D*) canJumpFrom:(CGPoint)src to:(CGPoint)dst radius:(float)radius world:(b2World*)world maxSpeed:(CGPoint)maxSpeed {\nfloat x = dst.x - src.x;\nfloat y = dst.y - src.y;\nif(y == 0){ y = 0.00001f; } //Prevent divide by zero\nbool foundJumpSolution = NO;\nbool triedAngles = NO;\nCGPoint launchVector;\nfloat jumpHeightMod = 0.5f;\nwhile(!triedAngles){\n//Gravity\nfloat gravity = world->GetGravity().y;\nif(gravity == 0){ gravity = 0.00001f; } //Prevent divide by zero\nlaunchVector = [SSGameActor getLaunchVector:CGPointMake(x,y) jumpHeightMod:jumpHeightMod gravity:gravity];\nbool hitObject = NO;\nbool movingTooFast = NO;\n/* Make sure jump doesn't hit an object */\nVector3D *at = [GameHelper quadraticA:gravity*0.5f B:launchVector.y C:y*-1];\nfloat airTime;\nif(at.x > at.y){ airTime = at.x; }else{ airTime = at.y; }\n//Do a ray test sequence (from 0.1 to 0.9 of airTime)\nfor(float t=airTime/10; t<airTime-airTime/10; t+= airTime/10){\nif(hitObject){ break; }\nfloat t1 = t + airTime/10;\nfloat x1 = launchVector.x * t + src.x;\nfloat y1 = launchVector.y * t + (0.5f) * gravity * pow(t,2) + src.y;\nfloat x2 = launchVector.x * t1 + src.x;\nfloat y2 = launchVector.y * t1 + (0.5f) * gravity * pow(t1,2) + src.y;\n//Point Test\n/* CODE OMITTED */\n//RayCast Test\n/* CODE OMITTED */\n}\n//Make sure the launchVector is not too fast for this actor\nif(!hitObject){\nif([GameHelper absoluteValue:launchVector.x] > maxSpeed.x || [GameHelper absoluteValue:launchVector.y] > maxSpeed.y){\nmovingTooFast = YES;\n}\n}\nif(hitObject || movingTooFast){\n//This jump failed, try another\nif(jumpHeightMod <= 0.5f && jumpHeightMod >= 0.2f){ //First, try 0.5f to 0.1f\njumpHeightMod -= 0.1f;\n}else if(jumpHeightMod > 0.5f && jumpHeightMod < 1.0f){ //Then try 0.6f to 1.0f\njumpHeightMod += 0.1f;\n}else if(jumpHeightMod < 0.2f){\njumpHeightMod = 0.6f;\n}else if(jumpHeightMod >= 1.0f){\n//FAIL\ntriedAngles = YES;\n}\n}else{\n//SUCCESS\nfoundJumpSolution = YES;\ntriedAngles = YES;\n}\n}\nif(foundJumpSolution){\nreturn [Vector3D x:launchVector.x y:launchVector.y z:0];\n}else{\nreturn nil;\n}\n}\n+(CGPoint) getLaunchVector:(CGPoint)vect jumpHeightMod:(float)jumpHeightMod gravity:(float)gravity {\n//Gravity\nif(gravity == 0){ gravity = 0.00001f; } //Prevent divide by zero\n//The angle between the points\nfloat directionAngle = [GameHelper vectorToRadians:ccp(vect.x, vect.y)];\n//Jump height is a percentage of X distance, usually 0.5f\nfloat apexX;\nif(vect.y > 0){ apexX = vect.x - (vect.x*0.5f*pow([GameHelper absoluteValue:sinf(directionAngle)],0.5f/jumpHeightMod));\n}else{ apexX = vect.x*0.5f*pow([GameHelper absoluteValue:sinf(directionAngle)],0.5f/jumpHeightMod); }\nfloat apexY;\nif(vect.y > 0){ apexY = vect.y + [GameHelper absoluteValue:vect.x*jumpHeightMod]*[GameHelper absoluteValue:sinf(directionAngle)];\n}else{ apexY = [GameHelper absoluteValue:vect.x*jumpHeightMod]*[GameHelper absoluteValue:sinf(directionAngle)]; }\n//Get launch vector\nfloat vectY = sqrtf(2*(-1)*gravity*apexY);\nfloat vectX = (apexX*(-1)*gravity) / vectY;\nreturn CGPointMake(vectX, vectY);\n}\n@end\n/* Ch7_SideScrollingPathfinding */\n@implementation Ch7_SideScrollingPathfinding\n-(CCLayer*) runRecipe {\n/* CODE OMITTED */\n//Distance between nodes that the actor can run between\nfloat nodeRunDistInterval = 100.0f;\n//How far to search for nodes the actor can jump to\nfloat maxJumpSearchDist = 500.0f;\n//Add some nodes to the bottom of the level\nfor(float x=20.0f; x<=gameAreaSize.x*PTM_RATIO-20.0f; x+=nodeRunDistInterval){\n//Add node\n/* CODE OMITTED */\n}\n//Link those nodes together as 'run neighbors'\nfor(int i=0; i<nodes.count-1; i++){\nSSAStarNode *n1 = (SSAStarNode*)[nodes objectAtIndex:i];\nSSAStarNode *n2 = (SSAStarNode*)[nodes objectAtIndex:i+1];\n[self linkRunNeighbor:n1 with:n2];\n}\n/* Add nodes to all level platforms */\nfor(b2Body *b = world->GetBodyList(); b; b = b->GetNext()){\nif (b->GetUserData() != NULL) {\nGameObject *obj = (GameObject*)b->GetUserData();\nif(obj.tag == GO_TAG_WALL && obj->polygonShape){\n//Nodes on this body only\nNSMutableArray *nodesThisBody = [[[NSMutableArray alloc] init] autorelease];\n//Process each polygon vertex\nfor(int i=0; i<obj->polygonShape->m_vertexCount; i++){\nb2Vec2 vertex = obj->polygonShape->m_vertices[i];\n//All nodes are 1 unit above their corresponding platform\nb2Vec2 nodePosition = b2Vec2(vertex.x + b->GetPosition().x,vertex.y + b->GetPosition().y+1.0f);\n//Move nodes inward to lessen chance of missing a jump\nif(obj->polygonShape->m_centroid.x < vertex.x){\nnodePosition = b2Vec2(nodePosition.x-0.5f, nodePosition.y);\n}else{\nnodePosition = b2Vec2(nodePosition.x+0.5f, nodePosition.y);\n}\n//If this node position is not inside the polygon we create an SSAStarNode\nif(!obj->polygonShape->TestPoint(b->GetTransform(), nodePosition)){\n//Add node\n/* CODE OMITTED */\n}\n}\n//Add in-between nodes (for running)\nbool done = NO;\nwhile(!done){\nif(nodesThisBody.count == 0){ break; }\ndone = YES;\nfor(int i=0; i<nodesThisBody.count-1; i++){\nSSAStarNode *n1 = (SSAStarNode*)[nodesThisBody objectAtIndex:i];\nSSAStarNode *n2 = (SSAStarNode*)[nodesThisBody objectAtIndex:i+1];\nif([GameHelper absoluteValue:n1.position.y-n2.position.y] > 0.1f){\n//These are not side by side\ncontinue;\n}\nif( [GameHelper distanceP1:n1.position toP2:n2.position] > nodeRunDistInterval ){\nCGPoint midPoint = [GameHelper midPointP1:n1.position p2:n2.position];\nb2Vec2 mp = b2Vec2(midPoint.x/PTM_RATIO, midPoint.y/PTM_RATIO);\n//If node is not in the polygon, add it\nif(!obj->polygonShape->TestPoint(b->GetTransform(), mp)){\n//Add node\n/* CODE OMITTED */\nbreak;\n}\n}\n}\n}\n//Link all of the neighboring nodes on this body\nfor(int i=0; i<nodesThisBody.count-1; i++){\nif(nodesThisBody.count == 0){ break; }\nSSAStarNode *n1 = (SSAStarNode*)[nodesThisBody objectAtIndex:i];\nSSAStarNode *n2 = (SSAStarNode*)[nodesThisBody objectAtIndex:i+1];\nif([GameHelper absoluteValue:n1.position.y-n2.position.y] > 0.1f){\n//These are not side by side\ncontinue;\n}\n//Two-way link\n[self linkRunNeighbor:n1 with:n2];\n}\n}\n}\n}\n//Neighbor all other nodes (for jumping)\nfor(int i=0; i<nodes.count; i++){\nfor(int j=0; j<nodes.count; j++){\nif(i==j){ continue; }\nSSAStarNode *n1 = (SSAStarNode*)[nodes objectAtIndex:i];\nSSAStarNode *n2 = (SSAStarNode*)[nodes objectAtIndex:j];\nif(n1.body == n2.body){ continue; }\nif( [GameHelper distanceP1:n1.position toP2:n2.position] <= maxJumpSearchDist ){\nCGPoint src = ccp(n1.position.x/PTM_RATIO, n1.position.y/PTM_RATIO);\nCGPoint dst = ccp(n2.position.x/PTM_RATIO, n2.position.y/PTM_RATIO);\n//Calculate our jump \"launch\" vector\nVector3D *launchVector3D = [SSGameActor canJumpFrom:src to:dst radius:actor.circleShape->m_radius*1.5f world:world maxSpeed:actor.maxSpeed];\nif(launchVector3D){\n//Only neighbor up if a jump can be made\n//1-way link\nif(![n1 containsNeighborForNode:n2]){\n//Add neighbor\n/* CODE OMITTED */\n}\n}\n}\n}\n}\nreturn self;\n}\n@end\n\n```", "```swift\n    -(void) runToWaypoint:(SSGameWaypoint*)wp speedMod:(float)speedMod constrain:(bool)constrain;\n    -(void) jumpToWaypoint:(SSGameWaypoint*)wp;\n    +(Vector3D*) canJumpFrom:(CGPoint)src to:(CGPoint)dst radius:(float)radius world:(b2World*)world maxSpeed:(CGPoint)maxSpeed;\n    +(CGPoint) getLaunchVector:(CGPoint)vect jumpHeightMod:(float)jumpHeightMod gravity:(float)gravity;\n\n    ```", "```swift\n#import \"mcLua.hpp\"\n@interface Ch7_LuaScripting : Recipe\n{\nclass mcLuaManager * lua_;\nmcLuaScript * sc;\n}\n@end\n//Callback pointer\nCh7_LuaScripting *lsRecipe = nil;\n//Static append message C function\nstatic int lsAppendMessage(lua_State * l)\n{\n//Pass lua string into append message method\n[lsRecipe appendMessage:[NSString stringWithUTF8String:lua_tostring(l,1)]];\nreturn 0;\n}\n@implementation Ch7_LuaScripting\n-(CCLayer*) runRecipe {\n//Set callback pointer\nlsRecipe = self;\n//Lua initialization\nlua_ = new mcLuaManager;\n//Lua function wrapper library\nstatic const luaL_reg scriptLib[] =\n{\n{\"appendMessage\", lsAppendMessage },\n{NULL, NULL}\n};\nlua_->LuaOpenLibrary(\"scene\",scriptLib);\n//Open Lua script\nsc = lua_->CreateScript();\nNSString *filePath = [[NSBundle mainBundle] pathForResource:@\"show_messages.lua\" ofType:@\"\"];\nsc->LoadFile([filePath UTF8String]);\n//Set initial update method counter\nlua_->Update(0);\n//Schedule step method\n[self schedule: @selector(step:)];\n//Resume button\nCCMenuItemFont *resumeItem = [CCMenuItemFont itemFromString:@\"Resume Script\" target:self selector:@selector(resumeScript:)];\nCCMenu *menu = [CCMenu menuWithItems:resumeItem, nil];\n[self addChild:menu];\nreturn self;\n}\n-(void) step:(ccTime)delta {\n//Update Lua script runner\nlua_->Update(delta);\n}\n/* Resume script callback */\n-(void) resumeScript:(id)sender {\nsc->YieldResume();\n}\n@end\n\n```", "```swift\n    class mcLuaManager lua_ = new mcLuaManager;\n\n    ```", "```swift\n    mcLuaScript *sc = lua_->CreateScript();\n    NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"show_messages.lua\" ofType:@\"\"];\n    sc->LoadFile([filePath UTF8String]);\n\n    ```", "```swift\n    lua_->Update(0);\n\n    ```", "```swift\n    script.waitSeconds(1);\n\n    ```", "```swift\n    static int lsAppendMessage(lua_State * l)\n    {\n    [lsRecipe appendMessage:[NSString stringWithUTF8String:lua_tostring(l,1)]];\n    return 0;\n    }\n\n    ```", "```swift\n    lua_ = new mcLuaManager;\n    static const luaL_reg scriptLib[] =\n    {\n    {\"appendMessage\", lsAppendMessage },\n    {NULL, NULL}\n    };\n    lua_->LuaOpenLibrary(\"scene\", scriptLib);\n\n    ```", "```swift\n    scene.appendMessage(\"This is a Lua script.\");\n\n    ```", "```swift\n    sc->YieldResume();\n\n    ```", "```swift\n#import \"mcLua.hpp\"\n#import \"Reachability.h\"\n@interface Ch7_DynamicScriptLoading : Recipe\n{\nclass mcLuaManager * lua_;\n}\n@end\n//Callback pointer\nCh7_DynamicScriptLoading *dslRecipe = nil;\n//Static append message C function\nstatic int dslAppendMessage(lua_State * l)\n{\n//Pass lua string into append message method\n[dslRecipe appendMessage:[NSString stringWithUTF8String:lua_tostring(l,1)]];\nreturn 0;\n}\n@implementation Ch7_DynamicScriptLoading\n-(CCLayer*) runRecipe {\n//Superclass initialization\n[super runRecipe];\n//Set callback pointer\ndslRecipe = self;\n//Lua initialization\nlua_ = new mcLuaManager;\n//Lua function wrapper library\nstatic const luaL_reg scriptLib[] =\n{\n{\"appendMessage\", dslAppendMessage },\n{NULL, NULL}\n};\nlua_->LuaOpenLibrary(\"scene\",scriptLib);\n//Load Lua script\n[self loadScript];\n//Set initial update method counter\nlua_->Update(0);\n//Schedule step method\n[self schedule: @selector(step:)];\n//Reload script button\nCCMenuItemFont *reloadItem = [CCMenuItemFont itemFromString:@\"Reload Script\" target:self selector:@selector(loadScript)];\nCCMenu *menu = [CCMenu menuWithItems:reloadItem, nil];\n[self addChild:menu];\nreturn self;\n}\n-(void) step:(ccTime)delta {\n//Update Lua script runner\nlua_->Update(delta);\n}\n-(void) loadScript{\n//Reset message\n[self resetMessage];\n//Make sure localhost is reachable\nReachability* reachability = [Reachability reachabilityWithHostName:@\"localhost\"];\nNetworkStatus remoteHostStatus = [reachability currentReachabilityStatus];\nif(remoteHostStatus == NotReachable) {\n[self showMessage:@\"Script not reachable.\"];\n}else{\n[self appendMessage:@\"Loading script from http://localhost/ch7_remote_script.lua\"];\n//Load script via NSURL\nmcLuaScript *sc = lua_->CreateScript();\nNSString *remoteScriptString = [NSString stringWithContentsOfURL:[NSURL URLWithString:@\"http://localhost/ch7_remote_script.lua\"]\nencoding:NSUTF8StringEncoding error:nil];\nsc->LoadString([remoteScriptString UTF8String]);\n}\n}\n@end\n\n```", "```swift\n    mcLuaScript *sc = lua_->CreateScript();\n    NSString *remoteScriptString = [NSString stringWithContentsOfURL:[NSURL URLWithString:@\"http://localhost/ch7_remote_script.lua\"] encoding:NSUTF8StringEncoding error:nil];\n    sc->LoadString([remoteScriptString UTF8String]);\n\n    ```", "```swift\n//Static C functions\nstatic int ldtLogic(lua_State * l) {\nint num = [ldtRecipe logic:[NSString stringWithUTF8String:lua_tostring(l,1)]];\nlua_pushnumber(l,num);\nreturn 1;\n}\nstatic int ldtPresentOptions(lua_State * l) {\n[ldtRecipe presentOptions];\nldtRecipe.sc->YieldPause();\nreturn (lua_yield(l, 0));\n}\n@implementation Ch7_LuaDecisionTree\n/* Logic callback */\n-(int) logic:(NSString*)str {\nint num = 0;\nif([str isEqualToString:@\"Put guns down\"]){\ngunsDown = YES;\n}else if([str isEqualToString:@\"Are guns down?\"]){\nif(gunsDown){\nnum = 1;\n}else{\nnum = 0;\n}\n}else if([str isEqualToString:@\"You win\"]){\n[self showMessage:@\"You WIN!!\"];\n}\nreturn num;\n}\n/* Present options callback */\n-(void) presentOptions {\ntext = @\"\";\n[textLabel setString:text];\noptionsNode.visible = YES;\n}\n/* Select option callback */\n-(void) selectOption:(id)sender {\n/* CODE OMITTED */\n//Resume the script\nsc->YieldResume();\n}\n@end\n/* decision_tree.lua */\nfunction start()\nscene.desc(\"You are deep undercover with the mafia.\");\nscene.anim(\"Open door\");\nscene.anim(\"Enter officer\");\nscene.anim(\"Louie looks away\");\nscene.dialog(\"Officer: Alright Big Louie. This is a raid. You're under arrest for the murder of Frankie Boy Caruso.\");\nscene.anim(\"Pull guns\");\nscene.dialog(\"Big Louie: Murder? What's a murder?\");\nscene.dialog(\"Officer: Don't play dumb with me.\");\nscene.dialog(\"Big Louie: A one-man raid? You must have a death wish.\");\nscene.anim(\"Louie looks at you\");\nscene.dialog(\"Big Louie: What do YOU think we should do with him?\");\nscene.dialogOption(\"You can't take him out now. There are too many witnesses.\");\nscene.dialogOption(\"I say take him out. He's here alone.\");\nscene.dialogOption(\"He's a cop. We'll have a mess on our hands if we take him down.\");\nscene.presentOptions();\nif scene.getResponse() == 1 then\ntooManyWitnesses();\nelseif scene.getResponse() == 2 then\nhereAlone();\nelseif scene.getResponse() == 3 then\nbigMess();\nend\nend\nfunction tooManyWitnesses()\nscene.dialog(\"Big Louie: Whaddya mean too many witnesses? These are all my men...\");\nscene.anim(\"Louie scowls\");\nscene.dialog(\"Big Louie: ...and YOU! Blast him boys.\");\nscript.waitSeconds(1);\nscene.anim(\"Gun pointed at you\");\nscene.desc(\"You are dead.\");\nend\nfunction bigMess()\nscene.dialog(\"Big Louie: I don't like it, but, you're right.\");\nscene.dialog(\"Big Louie: Men, you can put your guns down.\");\nscene.logic(\"Put guns down\");\nscene.anim(\"Put guns down\");\nscene.desc(\"Louie's men lower their weapons\");\nscene.anim(\"Louie looks away\");\nscene.dialog(\"Big Louie: Cop, looks like you have a new lease on life.\");\nscene.actionOption(\"Pull your gun on Big Louie\");\nscene.actionOption(\"Pull your gun on Big Louie's men\");\nscene.presentOptions();\nif scene.getResponse() == 1 then\npullGunOnLouie();\nelseif scene.getResponse() == 2 then\npullGunOnMen();\nend\nend\nfunction hereAlone()\nscene.anim(\"Officer shocked\");\nscript.waitSeconds(1);\nscene.dialog(\"Officer: Jerry! What the hell are you doing?!\");\nscene.anim(\"Louie scowls\");\nscene.dialog(\"Big Louie: Jerry? You lying scumbag! We trusted you...blast him boys.\");\nscript.waitSeconds(1);\nscene.anim(\"Gun pointed at you\");\nscene.desc(\"You are dead.\");\nend\nfunction pullGunOnLouie()\nscene.anim(\"Pull gun on Louie\");\nscene.anim(\"Louie scowl\");\nscene.dialog(\"Big Louie: This guy's a Fed! Blast him!\");\nscript.waitSeconds(1);\nscene.anim(\"Gun pointed at you\");\nscene.desc(\"You are dead.\");\nend\nfunction pullGunOnMen()\ngunsDown = scene.logic(\"Are guns down?\");\nscene.anim(\"Pull gun on men\");\nif gunsDown == 1 then\nscene.anim(\"Louie scowls\");\nscene.dialog(\"Big Louie: You played me for a fool!\");\nscene.anim(\"Louie looks away\");\nscene.dialog(\"Officer: You're under arrest Big Louie.\");\nscene.dialog(\"Big Louie: I'll be back on the streets in twenty-four hours!\");\nscene.dialog(\"Officer: We'll try to make it twelve.\");\nscene.anim(\"Louie looks at you\");\nscene.logic(\"You win\");\nscene.desc(\"You win!\");\nelse\nscene.anim(\"Louie scowls\");\nscene.dialog(\"Big Louie: This guy's a Fed! Blast him!\");\nscript.waitSeconds(1);\nscene.anim(\"Gun pointed at you\");\nscene.desc(\"You are dead.\");\nend\nend\nstart();\n\n```", "```swift\n    lua_State * l;\n    NSString *str = [NSString stringWithUTF8String:lua_tostring(l,1)];\n\n    ```", "```swift\n    int num = 7;\n    lua_pushnumber(l,num);\n\n    ```", "```swift\n    return 1;\n\n    ```"]