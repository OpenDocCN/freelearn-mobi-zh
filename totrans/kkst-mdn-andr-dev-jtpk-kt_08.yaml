- en: '*Chapter 6*: Adding Offline Capabilities with Jetpack Room'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：使用 Jetpack Room 添加离线功能'
- en: In this chapter, we're starting our journey of exploring ways to architecture
    our apps by first making sure that our application can be used without an internet
    connection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从确保我们的应用程序可以在没有互联网连接的情况下使用开始，从而探索构建应用程序架构的方法。
- en: In the *Introducing Jetpack Room* section, we will briefly note the various
    caching mechanisms that are on Android. Then, we will introduce the Jetpack Room
    library and its core elements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *介绍 Jetpack Room* 部分，我们将简要介绍 Android 上的各种缓存机制。然后，我们将介绍 Jetpack Room 库及其核心元素。
- en: Next, in the *Enabling offline usage by implementing Room* section, we will
    implement Room in our Restaurants app and allow users to use the application without
    an internet connection. In the *Applying partial updates to the Room database*
    section, we will learn how to partially update data inside Room so that we can
    save selections such as whether the restaurants were favorited by the user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 *通过实现 Room 启用离线使用* 部分，我们将在我们的餐馆应用程序中实现 Room，并允许用户在没有互联网连接的情况下使用应用程序。在
    *将部分更新应用于 Room 数据库* 部分，我们将学习如何部分更新 Room 内部的数据，以便我们可以保存诸如用户是否喜欢餐馆之类的选择。
- en: Finally, in the *Making local data the single source of truth for app content*
    section, we will understand why having a single source of truth for app data is
    beneficial, and then we will set the Room database as the single source of content
    for our app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *将本地数据作为应用程序内容的单一事实来源* 部分，我们将了解为什么拥有应用程序数据的单一事实来源是有益的，然后我们将设置 Room 数据库作为我们应用程序的单一内容来源。
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下主要主题：
- en: Introducing Jetpack Room
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Jetpack Room
- en: Enabling offline usage by implementing Room
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现 Room 启用离线使用
- en: Applying partial updates to the Room database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将部分更新应用于 Room 数据库
- en: Making local data the single source of truth for app content
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地数据作为应用程序内容的单一事实来源
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为本章设置技术要求。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Usually, building Compose-based Android projects with Jetpack Room will require
    your day-to-day tools. However, to follow along with the examples smoothly, make
    sure you have the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用 Jetpack Room 构建 Compose 基础的 Android 项目需要您的日常工具。然而，为了顺利地跟随示例，请确保您有以下内容：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that the IDE interface and
    other generated code files might differ from the ones used throughout this book.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1 版本的 Android Studio。您也可以使用更新的 Android Studio 版本或甚至 Canary
    构建，但请注意，IDE 界面和其他生成的代码文件可能与本书中使用的不同。
- en: The Kotlin 1.6.10, or newer, plugin installed in Android Studio
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在 Android Studio 中的 Kotlin 1.6.10 或更新的插件
- en: The Restaurants app code from the previous chapter.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的餐馆应用程序代码。
- en: Minimal knowledge of SQL databases and queries
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 SQL 数据库和查询的最低了解
- en: The starting point for this chapter is represented by the Restaurants application
    that was developed in the previous chapter. If you haven't followed the implementation
    described in the previous chapter, access the starter code for this chapter by
    navigating to the `Chapter_05` directory of the repository. Then, import the Android
    project entitled `chapter_5_restaurants_app`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是上一章开发的餐馆应用程序。如果您没有遵循上一章中描述的实现，请通过导航到存储库的 `Chapter_05` 目录来访问本章的起始代码。然后，导入名为
    `chapter_5_restaurants_app` 的 Android 项目。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_06`
    directory:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到 `Chapter_06` 目录：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app).'
- en: Introducing Jetpack Room
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Jetpack Room
- en: Modern applications should be available for use in any conditions, including
    when the user is missing an internet connection. This allows apps to provide a
    seamless user experience and usability even when the user's device cannot access
    the network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用应在任何条件下都可用，包括当用户没有互联网连接时。这允许应用在用户的设备无法访问网络的情况下提供无缝的用户体验和可用性。
- en: 'In this section, we will discuss the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下内容：
- en: Exploring the caching mechanism on Android
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Android 上的缓存机制
- en: Introducing Jetpack Room as a solution for local caching
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Jetpack Room 作为本地缓存的解决方案
- en: So, let's begin!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Exploring the caching mechanism on Android
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Android 上的缓存机制
- en: 'To cache specific content or application data, reliable Android apps make use
    of the various offline caching mechanisms that are suitable for different use
    cases:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓存特定内容或应用数据，可靠的 Android 应用会使用适合不同用例的各种离线缓存机制：
- en: Shared preferences are used to store lightweight data (such as user-related
    selections) as key-value pairs. This option shouldn't be used to store objects
    that are part of the app's content.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享首选项用于存储轻量级数据（例如与用户相关的选择）作为键值对。这个选项不应该用来存储应用内容的一部分对象。
- en: Device storage (either internal or external) is used for storing heavyweight
    data (such as files, pictures, and more).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备存储（无论是内部还是外部）用于存储重量级数据（例如文件、图片等）。
- en: SQLite database is used for storing app content in a structured manner inside
    a private database. **SQLite** is an open source SQL database that stores data
    in private text files.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 数据库用于在私有数据库中以结构化方式存储应用内容。**SQLite** 是一个开源的 SQL 数据库，它将数据存储在私有文本文件中。
- en: In this chapter, we will focus on learning how to cache structured content (which
    is, usually, held by Kotlin `data class` objects) within a SQLite database. In
    this way, we allow the user to browse the app's data while remaining offline.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于学习如何在 SQLite 数据库中缓存结构化内容（通常是 Kotlin `data class` 对象持有的内容）。这样，我们允许用户在离线状态下浏览应用的数据。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Android comes with a built-in SQLite database implementation that allows us
    to save structured data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Android 内置了 SQLite 数据库实现，允许我们保存结构化数据。
- en: In our app, we can consider the array of restaurants to be a perfect candidate
    for app content that can be saved inside a SQLite database. Since the data is
    structured, with SQLite, we get the advantage of being able to perform different
    actions such as searching for restaurants within the database, updating particular
    restaurants, and more.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们可以将餐厅数组视为一个完美的候选者，可以在 SQLite 数据库中保存的应用内容。由于数据是有结构的，使用 SQLite，我们能够执行不同的操作，例如在数据库中搜索餐厅、更新特定餐厅等。
- en: By caching app content in this way, we can allow users to browse the app's restaurants
    while offline. However, for this to work, the users need to have previously opened
    the app using an active internet connection, thereby allowing the app to cache
    the contents for future offline use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式缓存应用内容，我们可以允许用户在离线状态下浏览应用的餐厅。然而，为了使这一功能正常工作，用户需要之前使用活跃的互联网连接打开过应用，从而允许应用缓存内容以供未来的离线使用。
- en: 'Now, to save the restaurants to the SQLite private database, we need to make
    use of the SQLite APIs. These APIs are powerful. However, by using them, you face
    quite a few disadvantages:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将餐厅保存到 SQLite 私有数据库，我们需要使用 SQLite API。这些 API 功能强大。然而，使用它们时，你会面临相当多的缺点：
- en: The APIs are of a low level and are relatively difficult to use.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 是低级别的，相对难以使用。
- en: The SQLite APIs provide no compile-time verification of SQL queries, which can
    lead to unwanted runtime errors.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite API 不提供 SQL 查询的编译时验证，这可能导致不希望的运行时错误。
- en: There is a lot of boilerplate code involved in creating a database, performing
    SQL queries, and more.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库、执行 SQL 查询等操作涉及大量的模板代码。
- en: To mitigate these issues, Google provides the Jetpack Room library. This library
    is nothing more than a wrapper library that simplifies the way we access and interact
    with the SQLite database.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这些问题，Google 提供了 Jetpack Room 库。这个库不过是一个包装库，它简化了我们访问和交互 SQLite 数据库的方式。
- en: Introducing Jetpack Room as a solution for local caching
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Jetpack Room 作为本地缓存的解决方案
- en: '**Room** is a persistence library that is defined as an abstraction layer over
    SQLite and provides simplified database access while taking advantage of the power
    of the SQLite APIs.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Room** 是一个持久化库，它被定义为 SQLite 之上的抽象层，提供了简化的数据库访问，同时利用了 SQLite API 的强大功能。'
- en: As opposed to using the raw SQLite APIs, Room abstracts most of the complexity
    associated with working with SQLite. The library removes most of the unpleasant
    boilerplate code that is required to set up and interact with SQLite databases
    on Android while also providing the compile-time checking of SQL queries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用原始 SQLite API 相比，Room 抽象了与 SQLite 一起工作的大部分复杂性。该库消除了在 Android 上设置和与 SQLite
    数据库交互所需的大部分不愉快的样板代码，同时提供了 SQL 查询的编译时检查。
- en: 'To make use of the Room library and cache contents using its API, you need
    to define three primary components:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Room 库并使用其 API 缓存内容，您需要定义三个主要组件：
- en: '`Restaurant` data class as an entity. This means that we will have a table
    populated with `Restaurant` objects. In other words, the rows of the table are
    represented by instances of our restaurants.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Restaurant` 数据类作为一个实体。这意味着我们将有一个包含 `Restaurant` 对象的表。换句话说，表的行由我们的餐厅实例表示。'
- en: A database class that will contain and expose the actual database.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将包含并公开实际数据库的数据库类。
- en: '**Data Access Objects** (**DAOs**) that represent an interface. This allows
    us to get, insert, delete, or update the actual content within the database.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问对象（DAOs**）代表一个接口。这允许我们获取、插入、删除或更新数据库中的实际内容。'
- en: 'The database class provides us with a reference to the DAO interface associated
    with the SQLite database:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库类为我们提供了与 SQLite 数据库关联的 DAO 接口的引用：
- en: '![Figure 6.1 – The interaction between the application and the Room database'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 应用程序与 Room 数据库之间的交互'
- en: '](img/B17788_06_1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_06_1.jpg](img/B17788_06_1.jpg)'
- en: Figure 6.1 – The interaction between the application and the Room database
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 应用程序与 Room 数据库之间的交互
- en: As previously illustrated, we can use the DAO to retrieve or update the data
    from the database in the form of entity objects – in our case, the entity is the
    restaurant, so we will be applying such operations to restaurant objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用 DAO 以实体对象的形式从数据库检索或更新数据 – 在我们的案例中，实体是餐厅，因此我们将对这些餐厅对象执行此类操作。
- en: Now that we have a basic understanding of how Room works and how we can interact
    with it, it's time to see it in action for ourselves and implement Room in our
    Restaurants app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了 Room 的工作原理以及我们如何与之交互，是时候亲自看到它的实际应用并在我们餐厅应用中实现 Room 了。
- en: Enabling offline usage by implementing Room
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过实现 Room 启用离线使用
- en: We want to locally cache all the restaurants that we receive from our Firebase
    database. Since this content is structured, we want to use Room to help us with
    this task.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们从 Firebase 数据库接收到的所有餐厅本地缓存。由于此内容是有结构的，我们希望使用 Room 来帮助我们完成这项任务。
- en: 'Essentially, we are trying to save the restaurants when the user is browsing
    our Restaurants app while online. Then, we will reuse them when the user browses
    the app while being offline:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们试图在用户在线浏览我们的餐厅应用时挽救餐厅。然后，当用户离线浏览应用时，我们将重新使用它们：
- en: '![](img/B17788_06_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17788_06_2.jpg](img/B17788_06_2.jpg)'
- en: Figure 6.2 – Data retrieval for the Restaurants app with two sources of truth
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 餐厅应用的数据检索，具有两个数据源
- en: When online, we retrieve the restaurants from our web API. Before displaying
    them to the user, first, we will cache them to our Room database. If offline,
    we will retrieve the restaurants from the Room database and then display them
    to the user.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当在线时，我们从我们的网络 API 获取餐厅。在向用户显示之前，首先，我们将它们缓存到 Room 数据库中。如果离线，我们将从 Room 数据库中检索餐厅并向用户显示。
- en: 'Essentially, we are creating two sources of truth for our app:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们正在为我们的应用创建两个数据源：
- en: The remote API for when the user is online
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在线时的远程 API
- en: The local Room database for when the user is offline
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户离线时的本地 Room 数据库
- en: In the next section, we will discuss why this approach is not ideal. However,
    until then, we are content with the fact that we will be able to use the app while
    remaining offline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论为什么这种方法并不理想。然而，在此之前，我们对于能够在离线状态下使用应用的事实感到满意。
- en: 'Let''s start implementing Room, and then let''s cache those restaurants! Perform
    the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现 Room，然后让我们缓存那些餐厅！执行以下步骤：
- en: 'Inside the `build.gradle` file in the app module, add the dependencies for
    Room inside the `dependencies` block:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用模块的 `build.gradle` 文件中，在 `dependencies` 块内添加 Room 的依赖项：
- en: '[PRE0]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While you are still inside the `build.gradle` file, add the `kotlin-kapt` plugin
    for Room inside the `plugins` block:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您仍在 `build.gradle` 文件中时，在 `plugins` 块内添加 Room 的 `kotlin-kapt` 插件：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `kapt` plugin stands for **Kotlin Annotation Processing Tool**. This allows
    Room to generate annotated code at compile time while hiding most of the associated
    complexity from us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`kapt`插件代表**Kotlin注解处理工具**。这允许Room在编译时生成注解代码，同时将大部分相关复杂性隐藏起来。'
- en: After updating the `build.gradle` files, make sure to sync your project with
    its Gradle files. You can do that by pressing on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新`build.gradle`文件后，请确保将您的项目与其Gradle文件同步。您可以通过点击**文件**菜单选项，然后选择**同步项目与Gradle文件**来完成此操作。
- en: 'Since we want to store restaurant objects inside our local database, let''s
    instruct Room that the `Restaurant` data class is an entity that must be saved.
    Head inside the `Restaurant.kt` file, and add the `@Entity` annotation on top
    of the class declaration:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想在本地数据库中存储餐厅对象，让我们指示Room，`Restaurant`数据类是一个必须保存的实体。进入`Restaurant.kt`文件，并在类声明上方添加`@Entity`注解：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Inside the `@Entity` annotation, we have passed the name of the table via the
    `tableName` parameter. We will use this name when making queries.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Entity`注解内部，我们通过`tableName`参数传递了表的名称。我们将使用此名称进行查询。
- en: 'Now that Room will create a table with `Restaurant` objects as rows, it''s
    time to define the columns (or fields) of the entity. While we are still inside
    the `Restaurant.kt` class, let''s add the `@ColumnInfo` annotation on top of each
    field that we''re interested in, and that should represent a column:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Room将创建一个以`Restaurant`对象为行的表，是时候定义实体的列（或字段）了。当我们在`Restaurant.kt`类内部时，让我们在每个我们感兴趣的、应该代表列的字段上添加`@ColumnInfo`注解：
- en: '[PRE3]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For each field we're interested in saving, we've added the `@ColumnInfo` annotation
    and passed a `String` value to the `name` parameter. These names will correspond
    to the name of the table's columns. Right now, we are not interested in saving
    the `isFavorite` field; we will do that a bit later.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们感兴趣的每个字段，我们添加了`@ColumnInfo`注解，并将`String`值传递给`name`参数。这些名称将对应于表列的名称。目前，我们并不感兴趣保存`isFavorite`字段；我们稍后会做这件事。
- en: 'The entity that represents a table should have a primary key column that ensures
    uniqueness within the database. For this, we can use the `id` field that was configured
    from our Firebase database to be unique. While still inside the `Restaurant.kt`
    class, let''s add the `@PrimaryKey` annotation to the `id` field:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代表表的实体应该有一个主键列，以确保在数据库中的唯一性。为此，我们可以使用从我们的Firebase数据库配置为唯一的`id`字段。当仍在`Restaurant.kt`类内部时，让我们在`id`字段上添加`@PrimaryKey`注解：
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we have defined the entity for our database and configured the table's columns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了数据库的实体并配置了表的列。
- en: It's time to create a DAO that will serve as the entry point to our database,
    allowing us to perform various actions on it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个DAO了，它将作为我们数据库的入口点，使我们能够执行各种操作。
- en: 'Create a DAO by clicking on the application package, selecting `RestaurantsDao`
    as the name, and select **Interface** as the type. Inside the new file, add the
    following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击应用程序包，选择`RestaurantsDao`作为名称，并选择**接口**作为类型来创建一个DAO。在新的文件中，添加以下代码：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since Room will take care of implementing any actions that we need to interact
    with the database, the DAO is an interface, just like Retrofit also had an interface
    for the HTTP methods. To instruct Room that this is a DAO entity, we've added
    the `@Dao` annotation on top of the interface declaration.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Room将负责实现我们需要与数据库交互的任何操作，DAO是一个接口，就像Retrofit也有一个用于HTTP方法的接口一样。为了指示Room这是一个DAO实体，我们在接口声明上方添加了`@Dao`注解。
- en: 'Inside the `RestaurantsDao` interface, add two `suspend` functions that will
    help us to both save the restaurants and retrieve them from the database:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsDao`接口内部，添加两个`suspend`函数，这将帮助我们保存餐厅并从数据库中检索它们：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s analyze the two methods that we''ve added:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析我们添加的两个方法：
- en: '`getAll()` is a query statement that returns the restaurants that were previously
    cached inside the database. Since we need to perform a SQL query when calling
    this method, we''ve marked it with the `@Query` annotation and specified that
    we want all the restaurants (by adding `*`) from the `restaurants` table defined
    in the `Restaurant` entity data class.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAll()`是一个查询语句，它返回之前缓存在数据库中的餐厅。由于我们需要在调用此方法时执行SQL查询，我们已使用`@Query`注解标记它，并指定我们想要从在`Restaurant`实体数据类中定义的`restaurants`表中获取所有餐厅（通过添加`*`）。'
- en: '`addAll()` is an `insert` statement that caches the received restaurants inside
    the database. To mark this as a SQL `insert` statement, we''ve added the `@Insert`
    annotation. However, if the restaurants being inserted are already present in
    the database, we should replace the old ones with the new ones to refresh our
    cache. We instructed Room to do so by passing the `OnConflictStrategy.REPLACE`
    value into the `@Insert` annotation.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAll()`是一个将接收到的餐厅缓存到数据库中的`insert`语句。为了将其标记为SQL `insert`语句，我们添加了`@Insert`注解。但是，如果正在插入的餐厅已经在数据库中存在，我们应该用新的替换旧的，以刷新我们的缓存。我们通过将`OnConflictStrategy.REPLACE`值传递给`@Insert`注解来指示Room这样做。'
- en: Both methods are marked as `suspend` functions because any interaction with
    the Room database can take time and is an async job; therefore, it shouldn't block
    the UI.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都被标记为`suspend`函数，因为与Room数据库的任何交互都可能需要时间，并且是一个异步任务；因此，它不应该阻塞UI。
- en: Now, we have defined an entity class and a DAO class, we must define the last
    component that Room needs in order to function, the database class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了一个实体类和一个DAO类，我们必须定义Room为了运行所需的最后一个组件，即数据库类。
- en: 'Create a Room database class by clicking on the application package. Select
    `RestaurantsDb` as the name, and select **File** as the type. Inside the new file,
    add the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击应用程序包创建Room数据库类。将名称选为`RestaurantsDb`，并将类型选为**文件**。在新的文件中，添加以下代码：
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s analyze the code that we''ve just added:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析我们刚刚添加的代码：
- en: '`RestaurantsDb` is an abstract class that inherits from `RoomDatabase()`. This
    will allow Room to create the actual implementation of the database behind the
    scenes and hide all the heavy implementation details from us.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RestaurantsDb`是一个继承自`RoomDatabase()`的抽象类。这将允许Room在幕后创建数据库的实际实现，并隐藏所有繁重的实现细节。'
- en: 'For the `RestaurantsDb` class, we''ve added the `@Database` annotation so that
    Room knows that this class represents a database and provides an implementation
    for it. Inside this annotation, we''ve passed the following:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`RestaurantsDb`类，我们添加了`@Database`注解，以便Room知道这个类代表一个数据库并提供其实现。在这个注解内部，我们传递了以下内容：
- en: The `Restaurant` class to the `entities` parameter. This parameter tells Room
    which entities are associated with this database so that it can create corresponding
    tables. The parameter expects an array, so you can add as many entity classes
    as you wish, as long as they are annotated with `@Entity`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Restaurant`类传递给`entities`参数。此参数告诉Room哪些实体与该数据库相关联，以便它可以创建相应的表。该参数期望一个数组，因此您可以添加任意多的实体类，只要它们被注解为`@Entity`。
- en: '`1` as the `version` number of the database. We should increment this version
    number whenever the schema of the database changes. The `Restaurant` class, since
    it''s an entity, we might change the schema of the database, and Room needs to
    know that for migration purposes.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`作为数据库的`version`版本号。每当数据库的架构发生变化时，我们应该增加这个版本号。由于`Restaurant`类是一个实体，我们可能会更改数据库的架构，Room需要知道这一点以进行迁移。'
- en: '`false` to the `exportSchema` parameter. Room can export the schema of our
    database externally; however, for simplicity, we chose not to do so.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`false`传递给`exportSchema`参数。Room可以外部导出我们数据库的架构；然而，为了简单起见，我们选择不这样做。
- en: 'Inside the `RestaurantsDb` class, add an abstract `RestaurantsDao` variable:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsDb`类内部，添加一个抽象的`RestaurantsDao`变量：
- en: '[PRE8]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We know that the database class should expose a DAO object so that we can interact
    with the database. By leaving it abstract, we allow Room to provide its implementation
    behind the scenes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道数据库类应该公开一个DAO对象，这样我们就可以与数据库交互。通过将其留为抽象的，我们允许Room在幕后提供其实现。
- en: 'Even though we declared a variable to hold our DAO object, we still need to
    find a way to build the database and obtain a reference to the `RestaurantsDao`
    instance that Room will create for us. Inside the `RestaurantsDb` class, add `companion
    object` and then add the `buildDatabase` method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们声明了一个变量来保存我们的DAO对象，我们仍然需要找到一种方法来构建数据库并获取Room为我们创建的`RestaurantsDao`实例的引用。在`RestaurantsDb`类内部，添加`companion
    object`然后添加`buildDatabase`方法：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Essentially, this method returns a `RestaurantsDb` instance. To construct a
    Room database, we need to call the `Room.databaseBuilder` constructor, which expects
    the following parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，此方法返回一个`RestaurantsDb`实例。要构建Room数据库，我们需要调用`Room.databaseBuilder`构造函数，它期望以下参数：
- en: A `Context` object that we provided from the `context` input argument of our
    `buildDatabase` method.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`buildDatabase`方法的`context`输入参数提供的`Context`对象。
- en: The class of the database you're trying to build, that is, the `RestaurantsDb`
    class.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在尝试构建的数据库的类，即`RestaurantsDb`类。
- en: A name for the database – we named it `"restaurants_database"`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库的名称——我们将其命名为`"restaurants_database"`。
- en: The builder returns a `RoomDatabase.Builder` object on which we called `.fallbackToDestructiveMigration()`.
    This means that, in the case of a schema change (such as performing changes in
    the entity class and modifying the table columns), the tables would be dropped
    (or deleted) instead of trying to migrate the contents from the previous schema
    (which would have been a bit more complex).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器返回一个`RoomDatabase.Builder`对象，我们在其上调用`.fallbackToDestructiveMigration()`。这意味着，在模式更改的情况下（例如在实体类中执行更改并修改表列），表将被删除（或删除），而不是尝试从先前的模式（这将更复杂一些）迁移内容。
- en: Finally, we called `build()` on the builder object so that our `buildDatabase()`
    method returns a `RestaurantsDb` instance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在构建器对象上调用`build()`，以便我们的`buildDatabase()`方法返回一个`RestaurantsDb`实例。
- en: It's time to finally get a reference to our DAO so that we can start using the
    database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候获取我们DAO的引用，以便我们可以开始使用数据库了。
- en: 'While still inside the `companion object` of the `RestaurantsDb` class, add
    the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`RestaurantsDb`类的`companion object`内部，添加以下代码：
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s break down what we''ve done:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分解我们所做的工作：
- en: We added an `INSTANCE` variable of type `RestaurantsDao`. Since this variable
    is inside the companion object, `INSTANCE` is static. Additionally, we marked
    it with `@Volatile`. This means that writes to this field are immediately made
    visible to other threads. Don't worry too much about these multithreading concepts
    – we will get rid of this boilerplate code soon enough.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个类型为`RestaurantsDao`的`INSTANCE`变量。由于这个变量在伴生对象内部，`INSTANCE`是静态的。此外，我们用`@Volatile`标记了它。这意味着对这个字段的写入会立即对其他线程可见。不必过于担心这些多线程概念——我们很快就会摆脱这些样板代码。
- en: We created a `getDaoInstance()` method where we added a block of code that calls
    the `buildDatabase()` method and gets the DAO object by calling the `.dao` accessor.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`getDaoInstance()`方法，在其中添加了一块代码，调用`buildDatabase()`方法并通过调用`.dao`访问器获取DAO对象。
- en: Since we want only one memory reference to our database (and not create other
    database instances in other parts of the app), we made sure that our `INSTANCE`
    variable conforms to the singleton pattern. Essentially, the **singleton pattern**
    allows us to hold a static reference to an object so that it lives as long as
    our application does.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想有一个数据库的内存引用（而不是在应用程序的其他部分创建其他数据库实例），我们确保我们的`INSTANCE`变量符合单例模式。本质上，**单例模式**允许我们持有对象的静态引用，使其在应用程序的生命周期内持续存在。
- en: By following this approach, anytime we need to access the Room database from
    different parts of the app, we can call the `getDaoInstance()` method, which returns
    an instance of `RestaurantsDao`. Additionally, we can be sure that it's always
    the same memory reference and that no concurrency issues will occur since we have
    wrapped the instance creation code inside a `synchronized` block.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，每次我们需要从应用程序的不同部分访问Room数据库时，我们都可以调用`getDaoInstance()`方法，它返回一个`RestaurantsDao`实例。此外，我们可以确信它始终是相同的内存引用，并且由于我们在`synchronized`块中封装了实例创建代码，因此不会发生并发问题。
- en: You might have noticed that to get a reference to our DAO and cache our restaurants
    in the database, the `RestaurantsDb.getDaoInstance()` method expects a `Context`
    object. This is needed to create the instance of the database. However, we want
    to get our DAO in the `RestaurantsViewModel` class, and we have no context there,
    so what should we do?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了获取我们的DAO并将餐厅缓存到数据库中，`RestaurantsDb.getDaoInstance()`方法期望一个`Context`对象。这是创建数据库实例所需的。然而，我们想在`RestaurantsViewModel`类中获取我们的DAO，而我们那里没有上下文，所以我们该怎么办？
- en: 'Let''s expose the application context from the application class! Create the
    application class by clicking on the application package, selecting `RestaurantsApplication`
    as the name, and select **File** as the type. Inside the new file, add the following
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序类中暴露应用上下文！通过点击应用程序包，将名称设置为`RestaurantsApplication`，并选择**文件**类型来创建应用程序类。在新文件中，添加以下代码：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This class now inherits from `android.app.Application` and exposes its context
    through the static `getAppContext()` method. The only issue is that even though
    we have an application class, we still haven't configured the project to recognize
    it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类现在继承自 `android.app.Application` 并通过静态 `getAppContext()` 方法公开其上下文。唯一的问题是，尽管我们有应用程序类，但我们还没有配置项目以识别它。
- en: 'In the `AndroidManifest.xml` file, inside the `<application>` element, add
    the `android:name` identifier that sets our `RestaurantsApplication` class as
    the application class:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中，在 `<application>` 元素内部，添加设置我们的 `RestaurantsApplication`
    类为应用程序类的 `android:name` 标识符：
- en: '[PRE12]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's time to finally start working on caching those restaurants in our database.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始在我们的数据库中缓存那些餐厅了。
- en: 'Inside the `RestaurantsViewModel` class, add a `restaurantsDao` variable. Then,
    instantiate it via the static `RestaurantsDb.getDaoInstance` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 类内部，添加一个 `restaurantsDao` 变量。然后，通过静态方法 `RestaurantsDb.getDaoInstance`
    实例化它：
- en: '[PRE13]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure that you pass the application context through the newly created `getAppContext()`
    method inside the application class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 确保通过在应用程序类内部新创建的 `getAppContext()` 方法传递应用程序上下文。
- en: 'Now we''re ready to save the restaurants locally! While you are still in the
    `RestaurantsViewModel` class, inside the `getRemoteRestaurants()` method, add
    these new lines of code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在本地保存餐厅了！当你仍然在 `RestaurantsViewModel` 类中时，在 `getRemoteRestaurants()`
    方法中添加这些新行代码：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Essentially, what we are doing is the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们所做的是以下操作：
- en: I. Getting the restaurants from the remote API (here, it's the Retrofit `restInterface`
    variable).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: I. 从远程 API（此处为 Retrofit 的 `restInterface` 变量）获取餐厅。
- en: II. Caching those restaurants inside the local database through Room by calling
    `restaurantsDao.addAll()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: II. 通过调用 `restaurantsDao.addAll()` 在本地数据库中通过 Room 缓存那些餐厅。
- en: III. Finally, returning the restaurants to the UI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: III. 最后，将餐厅返回到 UI。
- en: Run the app while you have a working internet connection.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你有正常工作的互联网连接时运行应用程序。
- en: In terms of the UI, nothing should change – you should still see the restaurants.
    That said, behind the scenes, the restaurants should now have been cached.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 方面，不应该有任何变化——你应该仍然看到餐厅。但话虽如此，在幕后，餐厅现在应该已经被缓存了。
- en: Run the app again but without internet.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用程序，但不要连接到互联网。
- en: The chances are that you won't see anything. The restaurants are not there.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你什么也看不到。餐厅不在那里。
- en: This happens because, while we are offline, we never try to get the previously
    cached restaurants from the Room database. Moreover, when offline, the `restInterface.getRestaurants()`
    suspending function throws an error because the HTTP call that fetches the restaurants
    has failed – this exception should arrive inside `CoroutineExceptionHandler`.
    The exception is thrown by Retrofit because the associated network request has
    failed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，当我们离线时，我们从未尝试从 Room 数据库获取之前缓存的餐厅。此外，当离线时，`restinterface.getRestaurants()`
    挂起函数会抛出一个错误，因为获取餐厅的 HTTP 调用失败了——这个异常应该出现在 `CoroutineExceptionHandler` 中。异常是由 Retrofit
    抛出的，因为相关的网络请求失败了。
- en: 'Let''s leverage the fact that, while we''re offline, the `restInterface.getRestaurants()`
    function call throws an exception. This is so that we can wrap the whole block
    of code inside `getRemoteRestaurants()` inside a `try-catch` block:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们利用这样一个事实：当我们离线时，`restinterface.getRestaurants()` 函数调用会抛出异常。这样我们就可以将 `getRemoteRestaurants()`
    内部的整个代码块包裹在一个 `try-catch` 块中：
- en: '[PRE15]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Essentially, what happens now is that if the user is offline, we catch the exception
    thrown by Retrofit. Alternatively, we return the cached restaurants from the Room
    database by calling `restaurantsDao.getAll()`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，现在发生的情况是，如果用户离线，我们将捕获 Retrofit 抛出的异常。或者，我们可以通过调用 `restaurantsDao.getAll()`
    从 Room 数据库返回缓存的餐厅。
- en: As an extra, we also check whether the exception we've caught has been thrown
    because of the user's poor or inexistent internet connectivity. If the `Exception`
    object is of type `UnknownHostException`, `ConnectException`, or `HttpException`,
    we're loading the restaurants from Room through our DAO; otherwise, we propagate
    the exception so that it's caught later by `CoroutineExceptionHandler`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外操作，我们还检查我们捕获的异常是否是由于用户糟糕或不存在的网络连接引起的。如果 `Exception` 对象是 `UnknownHostException`、`ConnectException`
    或 `HttpException` 类型，我们将通过我们的 DAO 从 Room 加载餐厅；否则，我们将传播异常，以便它稍后被 `CoroutineExceptionHandler`
    捕获。
- en: Before running the app, let's refactor our `getRemoteRestaurants()` method a
    bit. Now, the name of the method implies that it retrieves restaurants from a
    remote source. However, in reality, it also retrieves restaurants from Room if
    the user is offline. Room is a local data source, so the name of this method is
    no longer appropriate.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，让我们稍微重构一下`getRemoteRestaurants()`方法。现在，方法名暗示它从远程源检索餐厅。然而，实际上，如果用户离线，它也会从Room中检索餐厅。Room是本地数据源，因此这个方法的名字不再合适。
- en: 'Rename the `getRemoteRestaurants()` method to `getAllRestaurants()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`getRemoteRestaurants()`方法重命名为`getAllRestaurants()`：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Additionally, remember to rename its usage in the `getRestaurants()` method
    where the coroutine is launched:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住在启动协程的`getRestaurants()`方法中更改其使用方式：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the app again without an internet connection.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在没有互联网连接的情况下运行应用程序。
- en: Because the restaurants were previously cached and now the user is offline,
    we are fetching them from Room. You should see the restaurants even without the
    internet. Success!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于餐厅之前已被缓存，现在用户处于离线状态，我们从Room中获取它们。你应该即使在没有互联网的情况下也能看到餐厅。成功了！
- en: 'Even though we''ve come a long way and have managed to make the Restaurants
    app usable even without internet, there is still something that we''ve missed.
    To reproduce it, perform the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经走了很长的路，并成功使餐厅应用程序在没有互联网的情况下也可用，但我们仍然忽略了一些东西。为了重现它，请执行以下步骤：
- en: Try running the application (either online or offline), and then mark a couple
    of restaurants as favorites.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行应用程序（无论是在线还是离线），然后标记几家餐厅为收藏。
- en: Disconnect your device from the internet and make sure you are now offline.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断开您的设备与互联网的连接，并确保您现在处于离线状态。
- en: Restart the application while remaining offline.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在离线状态下重新启动应用程序。
- en: You will get to see the restaurants, but your previous selections have been
    lost. More precisely, even though we have marked some restaurants as favorites,
    all restaurants now appear as not favorites. It's time to fix this!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到餐厅，但你的之前的选项已经丢失。更确切地说，尽管我们标记了一些餐厅为收藏，但现在所有餐厅都显示为非收藏。是时候修复这个问题了！
- en: Applying partial updates to the Room database
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Room数据库应用部分更新
- en: Right now, our application is saving the restaurants that we receive from the
    remote web API directly inside the Room database.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序正在将我们从远程Web API接收到的餐厅直接保存到Room数据库中。
- en: 'This is not a bad approach; however, whenever we are marking a restaurant as
    a favorite, we aren''t updating the corresponding restaurant inside Room. If we
    take a look inside the `RestaurantsViewModel` class and we check its `toggleFavorite()`
    method, we can see that we''re only updating the `isFavorite` flag of a restaurant
    inside the `state` variable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个坏的方法；然而，每次我们标记一家餐厅为收藏时，我们并没有更新Room中的对应餐厅。如果我们查看`RestaurantsViewModel`类，并检查其`toggleFavorite()`方法，我们可以看到我们只更新了`state`变量中餐厅的`isFavorite`标志：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We aren't updating the corresponding restaurant's `isFavorite` field value inside
    Room. So, whenever we use the application offline, the restaurants will no longer
    appear as favorites, even though when we were online, we might have marked some
    as favorites.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在Room中更新对应餐厅的`isFavorite`字段值。所以，每次我们在离线状态下使用应用程序时，餐厅将不再显示为收藏，即使我们在在线时可能已经标记了一些为收藏。
- en: To fix this, whenever we mark a restaurant as a favorite or not a favorite,
    we need to apply a partial update on a particular `Restaurant` object inside our
    Room database. The partial update should not replace the entire `Restaurant` object,
    but it should only update its `isFavorite` field value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，每次我们标记一家餐厅为收藏或非收藏时，我们都需要在我们的Room数据库中的特定`Restaurant`对象上应用部分更新。部分更新不应替换整个`Restaurant`对象，而应仅更新其`isFavorite`字段值。
- en: 'Let''s get started! Perform the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！执行以下步骤：
- en: 'Create a partial entity class by clicking on the application package, selecting
    `PartialRestaurant` as the name, and select **File** as the type. Inside the new
    file, add the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击应用程序包，选择`PartialRestaurant`作为名称，并选择**文件**作为类型来创建一个部分实体类。在新的文件中，添加以下代码：
- en: '[PRE19]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this `@Entity` annotated class, we''ve only added two fields:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`@Entity`注解的类中，我们只添加了两个字段：
- en: An `id` field with a `@ColumnInfo()` annotation that has the same value (`"r_id"`)
    passed to the `name` parameter as the `Restaurant` object's `id` field. This allows
    Room to match the `Restaurant` object's `id` field with the one from `PartialRestaurant`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 `@ColumnInfo()` 注解的 `id` 字段，其值（`"r_id"`) 与传递给 `name` 参数的 `Restaurant` 对象的
    `id` 字段相同。这允许 Room 将 `Restaurant` 对象的 `id` 字段与 `PartialRestaurant` 中的对应字段匹配。
- en: An `isFavorite` field with a `@ColumnInfo()` annotation that has the name set
    to `"is_favorited"`. So far, Room can't match this field with the one from `Restaurant`,
    because inside `Restaurant`, we haven't annotated the `isFavorite` field with
    `@ColumnInfo` – we'll do that next.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 `@ColumnInfo()` 注解的 `isFavorite` 字段，其名称设置为 `"is_favorited"`。到目前为止，Room
    还不能将此字段与 `Restaurant` 中的字段匹配，因为在 `Restaurant` 中，我们还没有用 `@ColumnInfo` 注解 `isFavorite`
    字段——我们将在下一步中这样做。
- en: 'Now that our partial entity, called `PartialRestaurant`, has a column corresponding
    to the `isFavorite` field, it''s time to also add a `@ColumnInfo()` annotation
    with the same value (`"is_favorite"`) for the `isFavorite` field of the `Restaurant`
    entity:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的部分实体 `PartialRestaurant` 已经有一个与 `isFavorite` 字段对应的列，是时候也为 `Restaurant`
    实体的 `isFavorite` 字段添加一个具有相同值（`"is_favorite"`) 的 `@ColumnInfo()` 注解了：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As a good practice, we've also made the `isFavorite` field `val` instead of
    `var` to prevent its value from being changed once the object has been created.
    Because `Restaurant` is an object passed to a Compose `State` object, we want
    to promote immutability across its fields to ensure recomposition events happen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，我们还已将 `isFavorite` 字段从 `var` 改为 `val`，以防止在对象创建后更改其值。因为 `Restaurant`
    是传递给 Compose `State` 对象的对象，我们希望在其字段上提升不可变性，以确保重新组合事件发生。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By having a data class field as `var`, we can easily change its value at runtime
    and risk having Compose miss a well-needed recomposition. Immutability ensures
    that whenever an object field's value changes, a new object is created (just as
    we do with the `.copy()` function), and Compose is notified so that it can trigger
    recomposition.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据类字段作为 `var`，我们可以在运行时轻松更改其值，并冒着 Compose 错过所需的重新组合的风险。不可变性确保每当对象字段的值发生变化时，就会创建一个新的对象（就像我们使用
    `.copy()` 函数那样），并且 Compose 会被通知，以便它可以触发重新组合。
- en: 'Since the `isFavorite` field is now `val`, the `restoreSelections()` extension
    function inside `RestaurantViewModel` has broken. Update its code as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `isFavorite` 字段现在是 `val`，`RestaurantViewModel` 内部的 `restoreSelections()`
    扩展函数已损坏。更新其代码如下：
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Essentially, what we have done is make sure our `restaurantsMap` of type `Map<Int,
    Restaurant>` is mutable so that we can replace elements inside it. With this approach,
    we are now replacing the restaurant at entry `id` by passing a new object reference
    with the `copy` function. We are not going to go into much detail since this portion
    of the code will soon be removed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们所做的是确保我们的 `restaurantsMap` 类型为 `Map<Int, Restaurant>` 是可变的，这样我们就可以替换其内部元素。采用这种方法，我们现在通过传递一个带有
    `copy` 函数的新对象引用来替换 `id` 条目的餐厅。我们不会深入探讨，因为这部分代码很快就会被移除。
- en: 'Now that we have a partial entity defined, we need to add another function
    inside our DAO that will update a `Restaurant` entity through a `PartialRestaurant`
    entity. Inside `RestaurantsDao`, add the `update()` function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个部分实体，我们需要在 DAO 中添加另一个函数，该函数将通过 `PartialRestaurant` 实体更新 `Restaurant`
    实体。在 `RestaurantsDao` 中添加 `update()` 函数：
- en: '[PRE22]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s understand, step by step, how the new `update()` function works:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地了解新的 `update()` 函数是如何工作的：
- en: I. It's a `suspend` function because, as we know by now, any interaction with
    the local database is a suspending job that should not run on the main thread.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: I. 它是一个 `suspend` 函数，因为我们现在知道，任何与本地数据库的交互都是一个挂起作业，不应在主线程上运行。
- en: II. It receives a `PartialRestaurant` entity as an argument and returns nothing.
    The partial entity's field values correspond to the restaurant that we're trying
    to update.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: II. 它接收一个 `PartialRestaurant` 实体作为参数，并返回空值。部分实体的字段值对应于我们试图更新的餐厅。
- en: 'III. It''s annotated with the `@Update` annotation to which we passed the `Restaurant`
    entity. The update process has two steps, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: III. 它被注解为 `@Update` 注解，我们传递了 `Restaurant` 实体。更新过程有两个步骤，如下所示：
- en: i. First, `PartialRestaurant` exposes the `id` field, whose value matches the
    `id` field's value of the corresponding `Restaurant` object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: i. 首先，`PartialRestaurant` 暴露了 `id` 字段，其值与对应 `Restaurant` 对象的 `id` 字段值相匹配。
- en: ii. Once the match is complete, the `isFavorite` field's value is set to the
    `isFavorite` field of the matched `Restaurant` object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ii. 一旦匹配完成，`isFavorite`字段的值被设置为匹配的`Restaurant`对象的`isFavorite`字段。
- en: These matches are possible because the `id` and `isFavorite` fields of both
    entities have the same `@ColumnInfo` name values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些匹配是可能的，因为两个实体的`id`和`isFavorite`字段具有相同的`@ColumnInfo`名称值。
- en: Now that our DAO knows how to partially update our `Restaurant` entity, it's
    time to perform the update.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们的DAO知道如何部分更新我们的`Restaurant`实体，现在是时候执行更新了。
- en: 'First, inside `RestaurantsViewModel`, add a new suspending function, called
    `toggleFavoriteRestaurant()`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsViewModel`内部添加一个新的挂起函数，称为`toggleFavoriteRestaurant()`：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s understand, step by step, what this new method does:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地理解这个新方法做了什么：
- en: I. It receives the `id` field of the restaurant that we're trying to update,
    along with the `oldValue` field which represents the value of the `isFavorite`
    field just before the user has toggled the heart icon of the restaurant.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: I. 它接收我们试图更新的餐厅的`id`字段，以及`oldValue`字段，它代表用户在切换餐厅心形图标之前`isFavorite`字段的值。
- en: II. To partially update a restaurant, it needs to interact with the Room DAO
    object. This means that the `toggleFavoriteRestaurant` method must be a `suspend`
    function. As a good practice, we wrapped it inside a `withContext` block that
    specifies its work must be done inside the `IO` dispatcher. While Room ensures
    that we wrap our suspending work with a special dispatcher, we explicitly specified
    the `Dispatchers.IO` dispatcher to better highlight that such heavy work should
    be done in an appropriate dispatcher.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: II. 要部分更新餐厅，它需要与Room DAO对象交互。这意味着`toggleFavoriteRestaurant`方法必须是一个`suspend`函数。作为一个好的实践，我们将其包裹在一个`withContext`块中，指定其工作必须在`IO`调度器内完成。虽然Room确保我们将挂起的工作用特殊的调度器包裹起来，但我们明确指定了`Dispatchers.IO`调度器，以更好地突出这种重工作应该在适当的调度器中完成。
- en: III. It builds a `PartialRestaurant` object, which it then passes to the DAO's
    `update()` method that was created earlier. The `PartialRestaurant` object gets
    the `id` field of the restaurant we're updating, along with the negated value
    of the `isFavorite` flag. If the user previously didn't have the restaurant marked
    as favorite, upon clicking the heart icon, we should negate the old (`false`)
    value and obtain `true`, or vice versa.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: III. 它构建一个`PartialRestaurant`对象，然后将其传递给之前创建的DAO的`update()`方法。`PartialRestaurant`对象获取我们正在更新的餐厅的`id`字段，以及`isFavorite`标志的否定值。如果用户之前没有将餐厅标记为收藏，当点击心形图标时，我们应该否定旧的（`false`）值并获取`true`，反之亦然。
- en: Now that we have the method in place to update a restaurant, it's time to call
    it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了更新餐厅的方法，现在是时候调用它了。
- en: 'While you are still in `RestaurantsViewModel`, make the `toggleFavorite` method
    launch a coroutine at the end of its body. Then, inside it, call the new `toggleFavoriteRestaurant()`
    suspending function:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你仍然在`RestaurantsViewModel`中时，让`toggleFavorite`方法在其主体末尾启动一个协程。然后，在它内部，调用新的`toggleFavoriteRestaurant()`挂起函数：
- en: '[PRE24]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To the `toggleFavoriteRestaurant()` function, we''ve passed the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`toggleFavoriteRestaurant()`函数传递以下内容：
- en: The `id` parameter, which represents the ID of the restaurant the user is trying
    to mark as favorite or not favorite
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`参数，它代表用户试图标记为收藏或不收藏的餐厅的ID'
- en: The old value of the favorite status of the restaurant, as defined by the `isFavorite`
    flag of the `item` field
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据定义在`item`字段的`isFavorite`标志中的餐厅收藏状态的老值
- en: Now, whenever the user presses on the heart icon, we not only update the UI
    but also cache this selection inside the local database through a partial update.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当用户按下心形图标时，我们不仅更新UI，还通过部分更新在本地数据库中缓存这个选择。
- en: 'Build and run the application because it''s time to test what we''ve just implemented!
    Unfortunately, the app crashes. Can you think of one reason why this happens?
    If we look at the stack trace of the error, we will see the following message:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，因为现在是时候测试我们刚刚实现的内容了！不幸的是，应用程序崩溃了。你能想到一个导致这种情况的原因吗？如果我们查看错误的堆栈跟踪，我们将看到以下消息：
- en: '[PRE25]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This error message makes total sense because we've changed the schema of the
    database, and now Room doesn't know whether to migrate the old entries or delete
    them. But how did we change the schema?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息完全合理，因为我们已经更改了数据库的模式，现在Room不知道是迁移旧条目还是删除它们。但我们是如何更改模式的呢？
- en: Well, we changed the schema when we defined a new column for the Restaurants
    table by adding the `@ColumnInfo()` annotation to the `isFavorite` field.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，当我们为“餐厅”表定义了一个新的列时，我们更改了模式，通过在`isFavorite`字段上添加`@ColumnInfo()`注解。
- en: 'To mitigate this issue, we must increase the `version` number of the database.
    Inside the `RestaurantsDb` class, increase the `version` number from `1` to `2`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，我们必须增加数据库的`version`号。在`RestaurantsDb`类中，将`version`号从`1`增加到`2`：
- en: '[PRE26]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, Room knows that we've changed the schema of the database. In turn, because
    we haven't provided a migration strategy, and instead, we've called the `fallbackToDestructiveMigration()`
    method in the `Room.databaseBuilder` constructor when we initially instantiated
    the database, Room will drop the old contents and tables and provide us with a
    fresh start.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Room知道我们已经更改了数据库的模式。反过来，因为我们没有提供迁移策略，而是在最初实例化数据库时在`Room.databaseBuilder`构造函数中调用了`fallbackToDestructiveMigration()`方法，Room将删除旧的内容和表，并为我们提供一个全新的开始。
- en: Try running the application online, and then mark a couple of restaurants as
    favorites.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在线运行应用程序，然后标记一些餐厅为收藏。
- en: Disconnect your device from the internet and make sure you are now offline.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断开您的设备与互联网的连接，并确保您现在处于离线状态。
- en: Restart the application while remaining offline.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在离线状态下重新启动应用程序。
- en: Great news! The selections were now kept, and we can see which restaurants were
    previously marked as favorites!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！现在选择被保留了，我们可以看到哪些餐厅之前被标记为收藏！
- en: To continue testing, while you are offline, you can try marking other restaurants
    as favorites.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了继续测试，当您离线时，您可以尝试将其他餐厅标记为收藏。
- en: Then, still in offline mode, restart the app and you will notice that these
    new selections have also been saved.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，仍然在离线模式下，重新启动应用，你会注意到这些新的选择也已经保存。
- en: Connect your device to the internet and run the application – while you are
    online.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的设备连接到互联网并运行应用程序——当您在线时。
- en: Oops! The restaurants that we have previously marked as favorites no longer
    appear as such, even though we previously cached these selections inside the Room
    database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们之前标记为收藏的餐厅不再显示为收藏，尽管我们之前已经在Room数据库中缓存了这些选择。
- en: Essentially, every time we open the application while being connected to the
    internet, we lose all the previous selections, and no restaurant is marked as
    favorite anymore.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每次我们打开应用并连接到互联网时，我们都会丢失所有之前的选项，并且没有餐厅被标记为收藏。
- en: There are two issues in our code that are causing this! Can you think of why
    this is happening?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中有两个问题导致了这个问题！你能想到为什么会发生这种情况吗？
- en: In the next section, we will identify and address them. Additionally, we will
    make sure that Room is the single source of truth for the content of our application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将识别并解决这些问题。此外，我们还将确保Room是应用内容的唯一真相来源。
- en: Making local data the single source of truth for app content
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将本地数据作为应用内容的唯一真相来源
- en: Whenever we launch the app with the internet, all the restaurants appear as
    not favorites, even though we previously marked them as favorites and cached the
    selections in the Room database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们带互联网启动应用时，所有餐厅都显示为非收藏，尽管我们之前已将它们标记为收藏并在Room数据库中缓存了选择。
- en: 'To identify the issue, let''s navigate back inside `RestaurantsViewModel` and
    inspect the `getAllRestaurants()` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别问题，让我们回到`RestaurantsViewModel`内部，并检查`getAllRestaurants()`方法：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, when we launch the app while online, we do three things:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在线启动应用时，我们做三件事：
- en: 'We load the restaurants from the server by calling `restInterface.getRestaurants()`.
    For these restaurants, we don''t receive the `isFavorite` flag, so we automatically
    have it set to `false`. This happens because our `Restaurant` class defaults the
    value of `isFavorite` to false if no value is passed from the Gson deserialization:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过调用`restInterface.getRestaurants()`从服务器加载餐厅。对于这些餐厅，我们没有收到`isFavorite`标志，所以我们自动将其设置为`false`。这是因为我们的`Restaurant`类默认将`isFavorite`的值设置为`false`，如果没有从Gson反序列化传递值：
- en: '[PRE28]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then, we save those restaurants to Room by calling `restaurantsDao.addAll(restaurants)`.
    However, because we've used the `REPLACE` strategy inside our DAO's `addAll()`
    function, and because we received the same restaurants from the server, we override
    the `isFavorite` flags of the corresponding restaurants inside the database to
    `false`. So, even though our restaurants in Room might have had the `isFavorite`
    flag set to `true`, because we receive restaurants with the same `id` fields from
    the server, we end up overriding all those values to `false`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`restaurantsDao.addAll(restaurants)`将这些餐厅保存到Room中。然而，因为我们已经在DAO的`addAll()`函数内部使用了`REPLACE`策略，并且因为我们从服务器接收了相同的餐厅，所以我们覆盖了数据库中相应餐厅的`isFavorite`标志为`false`。因此，尽管我们的Room中的餐厅可能已经将`isFavorite`标志设置为`true`，但由于我们从服务器接收了具有相同`id`字段的餐厅，我们最终将这些值全部重置为`false`。
- en: Next, we pass the `restaurants` list that we've received from the server to
    the UI. As we already know, these restaurants have the `isFavorite` field's value
    of `false`. So, anytime we start the app while connected to the internet, we will
    always see no restaurants marked as favorites.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将从服务器接收到的`restaurants`列表传递给UI。正如我们已经知道的，这些餐厅的`isFavorite`字段的值为`false`。因此，每次我们在连接到互联网时启动应用程序，我们都会看到没有标记为收藏的餐厅。
- en: 'If we think about it, there are two main issues here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，这里有两个主要问题：
- en: 'Our application has two sources of truth:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序有两个单一数据来源：
- en: When online, it displays the restaurants from the remote server.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在线时，它显示远程服务器上的餐厅。
- en: When offline, it displays the restaurants from the local database.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当离线时，它显示本地数据库中的餐厅。
- en: Whenever we cache restaurants that already exist inside the local database,
    we override their `isFavorite` flag to `false`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们缓存本地数据库中已经存在的餐厅时，我们将它们的`isFavorite`标志重置为`false`。
- en: If we can fix these two issues by having our UI receive content from a single
    source of data, we will also be able to remove the need for `SavedStateHandle`
    and all the special handling related to process recreation – we will see why in
    a moment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以通过让我们的UI从单一数据源接收内容来修复这两个问题，我们也将能够消除对`SavedStateHandle`以及与进程重建相关的所有特殊处理的需求——我们将在稍后看到原因。
- en: 'Essentially, in this section, we will be doing the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在本节中，我们将执行以下操作：
- en: Refactoring the Restaurants app to have a single source of truth for data
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将餐厅应用重构为具有单一数据来源
- en: Removing the logic of persisting state inside `SavedStateHandle` in the case
    of process recreation
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程重建的情况下移除在`SavedStateHandle`中持久化状态的逻辑
- en: So, let's begin with the first issue at hand!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从手头的第一个问题开始吧！
- en: Refactoring the Restaurants app to have a single source of truth for data
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将餐厅应用重构为具有单一数据来源
- en: The approach of having multiple sources of data can lead to many inconsistencies
    and subtle bugs – just like how our app is now inconsistent in terms of what data
    it displays when the user is either online or offline.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 采用多个数据来源的方法可能导致许多不一致性和微小的错误——就像我们的应用现在在用户在线或离线时显示的数据不一致一样。
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The concept of designing systems to rely on only one data source used for storing
    and updating content is related to a practice that is called **Single Source of
    Truth** (**SSOT**). Having multiple sources of truth for data that the UI consumes
    can lead to inconsistencies between what's expected to be shown to the UI and
    what is actually shown. The SSOT concept helps us to structure the data access
    so that only one data source is trusted to provide the app with data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 设计系统仅依赖于用于存储和更新内容的单一数据源的概念与一种称为**单一数据来源**（**SSOT**）的实践相关。对于UI消耗的数据，拥有多个数据来源可能导致预期显示给UI的内容与实际显示的内容之间不一致。SSOT概念帮助我们结构化数据访问，以便只有一个数据来源被信任为应用提供数据。
- en: Let's make sure that our application only has one source of truth, but which
    one should we choose?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们的应用程序只有一个单一数据来源，但我们应该选择哪一个？
- en: On the one hand, we cannot control the data that is being sent from our Firebase
    database, and we also can't update the restaurants stored inside it when the user
    marks one as a favorite.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们无法控制从我们的Firebase数据库发送的数据，而且我们也不能在用户将某个餐厅标记为收藏时更新数据库中的餐厅。
- en: On the other hand, we can do that with Room! In fact, we are already doing that
    – every time a user marks a restaurant as a favorite or not a favorite, we're
    applying a partial update to that restaurant inside the local database.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以在Room中做到这一点！事实上，我们已经在做了——每次用户将餐厅标记为收藏或不收藏时，我们都会在本地数据库中对该餐厅进行部分更新。
- en: 'So, let''s make the local Room database our only source of data:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将本地Room数据库作为我们唯一的 数据来源：
- en: '![](img/B17788_06_3.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_06_3.jpg)'
- en: Figure 6.3 – Data retrieval for the Restaurants app with the local database
    as an SSOT
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 使用本地数据库作为SSOT的餐厅应用的数据检索
- en: When the user is online, we should get the restaurants from the server, cache
    them into Room, and then obtain the restaurants again from Room to finally send
    them to the UI.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在线时，我们应该从服务器获取餐厅，将其缓存到Room中，然后再次从Room获取餐厅，最后将它们发送到UI。
- en: Similarly, if the user is offline, we simply obtain the restaurants from Room
    and display them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果用户离线，我们只需从Room获取餐厅并显示它们。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, instead of always asking your Room database for the most up-to-date
    content, you could update the DAO interface to provide you with a reactive data
    stream that we can observe. This way, upon every data update, you would automatically
    be notified with the most up-to-date content in a reactive manner, without having
    to manually ask for it. To achieve that, you must use special data holders provided
    by libraries such as Jetpack LiveData, Kotlin Flow, or RxJava. We will explore
    Kotlin Flow in [*Chapter 11*](B17788_11_ePub.xhtml#_idTextAnchor317), *Creating
    Infinite Lists with Jetpack Paging and Kotlin Flow*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你不必总是从Room数据库请求最新的内容，你可以更新DAO接口以提供我们可以观察的响应式数据流。这样，每当数据更新时，你都会自动以响应式的方式收到最新的内容，而无需手动请求。为了实现这一点，你必须使用由Jetpack
    LiveData、Kotlin Flow或RxJava等库提供的特殊数据持有者。我们将在[*第11章*](B17788_11_ePub.xhtml#_idTextAnchor317)中探讨Kotlin
    Flow，*使用Jetpack Paging和Kotlin Flow创建无限列表*。
- en: The similarity between our two scenarios is that now, regardless of the internet
    connectivity of the user, our UI always displays the restaurants from inside our
    Room database. In other words, the local database is our SSOT!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们两个场景的相似之处在于，现在，无论用户的网络连接如何，我们的UI总是显示Room数据库内的餐厅。换句话说，本地数据库是我们的SSOT（单点登录）！
- en: 'Let''s start implementing! Perform the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现！执行以下步骤：
- en: 'Inside `RestaurantsViewModel`, refactor the `getAllRestaurants()` function
    to always return the restaurants from the Room database:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`内部，重构`getAllRestaurants()`函数，使其始终返回Room数据库中的餐厅：
- en: '[PRE29]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, our app tries to display the restaurants from the local database in any
    condition.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的应用试图在任何情况下显示本地数据库中的餐厅。
- en: Now, it's time to refactor the `try – catch` block inside the `getAllRestaurants()`
    method! Essentially, what we want to do is to get the restaurants from the server
    and then cache them locally.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候重构`getAllRestaurants()`方法内的`try – catch`块了！本质上，我们想要做的是从服务器获取餐厅，然后将其本地缓存。
- en: 'Replace the contents within the `try { }` block with a new `refreshCache()`
    method:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将`try { }`块内的内容替换为新的`refreshCache()`方法：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Additionally, we want to define the `refreshCache()` function to get the restaurants
    from the remote server and then cache them inside the local database, thereby
    refreshing their contents:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们想要定义`refreshCache()`函数，从远程服务器获取餐厅并将它们缓存到本地数据库中，从而刷新其内容：
- en: '[PRE31]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We know that if the refresh of the cache fails, we will still show the local
    restaurants from Room. But what if the local database is empty?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道，如果缓存刷新失败，我们仍然会从Room显示本地餐厅。但如果是本地数据库为空呢？
- en: 'Continue refactoring the `getAllRestaurants()` method by updating its `catch`
    block. You can do this by removing the `return@withContext restaurantsDao.getAll()`
    call (which is now redundant) from the `is UnknownHostException, is ConnectException,
    is HttpException` branch and by replacing it with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 继续重构`getAllRestaurants()`方法，更新其`catch`块。你可以通过从`is UnknownHostException, is ConnectException,
    is HttpException`分支中移除（现在已冗余）`return@withContext restaurantsDao.getAll()`调用，并用以下代码替换它：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Essentially, if a network exception has been thrown, we can check whether we
    have any local restaurants saved in the Room database:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果抛出了网络异常，我们可以检查Room数据库中是否保存了任何本地餐厅：
- en: If the list is empty, we return from the parent method early by throwing a custom
    exception to inform the user that we have no data to display.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果列表为空，我们通过抛出自定义异常从父方法中提前返回，以通知用户我们没有数据可以显示。
- en: However, if the local database has elements, we do nothing and let the `getAllRestaurants()`
    method return the cached restaurants to the UI.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果本地数据库有元素，我们不做任何操作，让 `getAllRestaurants()` 方法将缓存的餐厅返回给 UI。
- en: 'Now, inside the `toggleFavorite()` function of `ViewModel`, whenever we toggle
    a restaurant as a favorite or not, we can observe that we''re updating the Room
    database with a partial update. However, we''re not fetching the restaurants again
    from Room and so the UI is never informed of this change:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `ViewModel` 的 `toggleFavorite()` 函数内部，无论何时切换餐厅的收藏状态，我们都可以观察到我们在使用部分更新更新
    Room 数据库。然而，我们没有再次从 Room 中获取餐厅，因此 UI 永远不会被告知这种变化：
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Instead, we're updating the `state` variable's value – so the UI receives the
    updated restaurants in-memory. This means that we are not conforming to the SSOT
    practice in which we opt to always feed the UI with restaurants from the local
    database. Let's fix this.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们正在更新 `state` 变量的值 – 因此 UI 接收了内存中更新的餐厅。这意味着我们并没有遵循 SSOT 实践，即我们选择始终从本地数据库向
    UI 提供餐厅。让我们解决这个问题。
- en: 'Make the `toggleFavoriteRestaurant()` function return the restaurants from
    our local database. You can do this by calling the `restaurantsDao.getAll()` function
    from inside the `withContext()` block:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `toggleFavoriteRestaurant()` 函数返回我们本地数据库中的餐厅。你可以通过在 `withContext()` 块内部调用
    `restaurantsDao.getAll()` 函数来实现这一点：
- en: '[PRE34]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside the `toggleFavorite()` method, store the updated restaurants returned
    by the `toggleFavoriteRestaurant()` method inside an `updatedRestaurants` variable,
    and then move the `state.value = restaurants` line from outside the coroutine
    to inside it while, this time, making it receive the value stored by the `updatedRestaurants`
    variable:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `toggleFavorite()` 方法内部，将 `toggleFavoriteRestaurant()` 方法返回的更新后的餐厅存储在 `updatedRestaurants`
    变量中，然后，这次将 `state.value = restaurants` 行从协程外部移动到内部，同时让它接收由 `updatedRestaurants`
    变量存储的值：
- en: '[PRE35]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we have not updated the `state` object value with the `restaurants` value
    from the previous state value. Instead, we passed the restaurants from the local
    database, which were obtained from the `toggleFavoriteRestaurant()` function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有使用前一个状态值中的 `restaurants` 值更新 `state` 对象的值。相反，我们传递了从 `toggleFavoriteRestaurant()`
    函数获得的本地数据库中的餐厅。
- en: Now that we have made our local database the single source of truth for data,
    we might assume that our issues have been solved. However, remember that we are
    still overriding the `isFavorite` field values of the local restaurants whenever
    we cache restaurants with the same IDs from the server.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经将本地数据库作为数据的唯一真相来源，我们可能会认为我们的问题已经解决。然而，请记住，每次我们从服务器缓存具有相同 ID 的餐厅时，我们仍在覆盖本地餐厅的
    `isFavorite` 字段值。
- en: 'That''s why the final problem lies in the `refreshCache()` method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，最终问题在于 `refreshCache()` 方法：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We must find a way to preserve the `isFavorite` field of the restaurants whenever
    we call `restaurantsDao.addAll(remoteRestaurants)`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须找到一种方法，在调用 `restaurantsDao.addAll(remoteRestaurants)` 时保留餐厅的 `isFavorite`
    字段。
- en: We can fix this issue by complicating the logic that is happening inside the
    `refreshCache()` function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过复杂化 `refreshCache()` 函数内部发生的逻辑来解决这个问题。
- en: 'Inside the `refreshCache()` function, add the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `refreshCache()` 函数内部，添加以下代码：
- en: '[PRE37]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s break down what we''ve just done:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分解我们刚刚所做的事情：
- en: i. First, just as before, we got the restaurants from the server (which will
    all have the `isFavorite` fields set to `false` as their default values) by calling
    `restInterface.getRestaurants()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: i. 首先，就像之前一样，我们通过调用 `restInterface.getRestaurants()` 从服务器获取了餐厅（它们的 `isFavorite`
    字段将默认设置为 `false`）。
- en: ii. Then, from Room, we obtained all the restaurants that were favorited by
    calling `restaurantsDao.getAllFavorited()` – we haven't added this function yet
    so don't worry if your code doesn't compile yet.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ii. 然后，从 Room 中，我们通过调用 `restaurantsDao.getAllFavorited()` 获取了所有收藏的餐厅 – 我们还没有添加这个函数，所以如果你的代码还没有编译，请不要担心。
- en: iii. Next, just as before, we saved the remote restaurants in Room by calling
    `restaurantsDao.addAll(remoteRestaurants)`. With this, we override the `isFavorite`
    field (to `false`) of the existing restaurants that have the same ID as `remoteRestaurants`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: iii. 然后，就像之前一样，我们通过调用 `restaurantsDao.addAll(remoteRestaurants)` 将远程餐厅保存到 Room
    中。这样，我们就覆盖了具有与 `remoteRestaurants` 相同 ID 的现有餐厅的 `isFavorite` 字段（将其设置为 `false`）。
- en: iv. Finally, we partially updated all the restaurants within Room by calling
    `restaurantsDao.updateAll()`. To this method (which we have yet to implement),
    we are passing a list of `PartialRestaurant` objects.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: iv. 最后，我们通过调用 `restaurantsDao.updateAll()` 部分更新了 Room 中所有的餐厅。我们将一个 `PartialRestaurant`
    对象的列表传递给这个方法（我们尚未实现）。
- en: These objects resulted from mapping the previously cached `favoriteRestaurants`
    objects of type `Restaurant` to objects of type `PartialRestaurant`, which have
    their `isFavorite` fields set to `true`. With this approach, we have now restored
    the `isFavorite` field's value for those favorited restaurants that were initially
    cached.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是从之前缓存的 `favoriteRestaurants` 对象（类型为 `Restaurant`）映射到具有 `isFavorite` 字段设置为
    `true` 的对象 `PartialRestaurant`。通过这种方法，我们现在已经恢复了那些最初缓存的已收藏餐厅的 `isFavorite` 字段值。
- en: 'Inside `RestaurantsDao`, we must implement the two methods used earlier:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsDao` 中，我们必须实现之前使用的两个方法：
- en: '[PRE38]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have added the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了以下内容：
- en: 'The `updateAll()` method: This is a partial update that works in the same way
    as the `update()` method. Here, the only difference is that we update the `isFavorite`
    field for a list of restaurants instead of only one.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateAll()` 方法：这是一个部分更新，与 `update()` 方法的工作方式相同。这里唯一的区别是我们更新了一组餐厅的 `isFavorite`
    字段，而不是只更新一个。'
- en: 'The `getAllFavorited()` method: This is a query just like the `getAll()` method
    but more specific, as it obtains all the restaurants that have their `isFavorite`
    field values equal to `1` (which stands for `true`).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAllFavorited()` 方法：这是一个查询，就像 `getAll()` 方法一样，但更具体，因为它获取所有 `isFavorite`
    字段值等于 `1`（代表 `true`）的餐厅。'
- en: We are finally done! It's time to test out the app!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了！现在是时候测试应用程序了！
- en: Try running the application offline and then mark a couple of restaurants as
    favorites.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试离线运行应用程序，然后标记几家餐厅为收藏。
- en: Connect your device to the internet and run the application – while you are
    online.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的设备连接到互联网并运行应用程序——当您在线时。
- en: You should now be able to see the previous selections – all the restaurants
    that were originally marked as favorites are now persisted across any scenario.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该能够看到之前的选项——所有最初标记为收藏的餐厅现在在所有场景中都被持久化了。
- en: However, we have one more thing to address!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一件事要处理！
- en: Removing the logic of persisting state in the case of process recreation
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在进程重建的情况下移除持久化状态逻辑
- en: 'Now our application has a single source of truth, that is, the local database:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序有一个单一的事实来源，即本地数据库：
- en: Whenever we receive restaurants from the server, we cache them to Room and then
    refresh the UI with the restaurants from Room.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们从服务器接收到餐厅信息时，我们会将它们缓存到 Room，然后使用 Room 中的餐厅信息刷新 UI。
- en: Whenever we mark a restaurant as a favorite or not, we cache the selection to
    Room, and similarly, we then refresh the UI with restaurants from Room.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们标记一家餐厅为收藏或非收藏时，我们会将选择缓存到 Room，然后同样地，我们使用 Room 中的餐厅刷新 UI。
- en: This means that if a system-initiated process death occurs, we should be able
    to restore the UI state easily because, now, the restaurants in Room also have
    the `isFavorite` field cached.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果发生系统启动的进程死亡，我们应该能够轻松地恢复 UI 状态，因为现在 Room 中的餐厅也缓存了 `isFavorite` 字段。
- en: In other words, our app no longer needs to rely on `SavedStateHandle` to restore
    the restaurants that have been favorited or not; the local source of data for
    our application will now handle this automatically.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们的应用程序不再需要依赖 `SavedStateHandle` 来恢复已收藏或未收藏的餐厅；我们的应用程序的本地数据源现在将自动处理这一点。
- en: 'Let''s remove our special handling for a system-initiated process death:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除对系统启动的进程死亡的特殊处理：
- en: 'Inside `RestaurantsViewModel`, remove the `stateHandle: SavedStateHandle` parameter:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `RestaurantsViewModel` 中，移除 `stateHandle: SavedStateHandle` 参数：'
- en: '[PRE39]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Inside `RestaurantsViewModel`, remove the `storeSelection()` and the `restoreSelections()`
    methods.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 中，移除 `storeSelection()` 和 `restoreSelections()` 方法。
- en: Remove the `companion object` of the `RestaurantsViewModel` class.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `RestaurantsViewModel` 类的 `companion object`。
- en: 'While you are still inside `ViewModel`, remove all the logic related to the
    `stateHandle` variable from within the `toggleFavorite()` method. The method should
    now look like this:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您仍然在 `ViewModel` 中时，从 `toggleFavorite()` 方法中移除所有与 `stateHandle` 变量相关的逻辑。现在该方法应如下所示：
- en: '[PRE40]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The issue is that we no longer have the `item` variable, so we don't know what
    to pass to the `toggleFavoriteRestaurant()` function's `oldValue` parameter instead
    of `item.isFavorite`. We need to fix this.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们不再有`item`变量，因此不知道应该将什么传递给`toggleFavoriteRestaurant()`函数的`oldValue`参数来代替`item.isFavorite`。我们需要修复这个问题。
- en: 'Add a new parameter to the `toggleFavorite()` method, called `oldValue`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`toggleFavorite()`方法添加一个新参数，称为`oldValue`：
- en: '[PRE41]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This `Boolean` argument should tell us whether the restaurant was previously
    marked as favorite or not.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Boolean`参数应该告诉我们餐厅之前是否被标记为收藏。
- en: 'Following this, refactor the `getRestaurants()` method to no longer use the
    `restoreSelections()` method. The method should now look like this:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重构`getRestaurants()`方法，使其不再使用`restoreSelections()`方法。该方法现在应该看起来像这样：
- en: '[PRE42]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, navigate to the `RestaurantsScreen` file. Then, inside the `RestaurantItem`
    composable, add another `oldValue` parameter to the `onFavoriteClick` callback
    function:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到`RestaurantsScreen`文件。然后，在`RestaurantItem`可组合组件内部，向`onFavoriteClick`回调函数添加另一个`oldValue`参数：
- en: '[PRE43]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Also, make sure that you pass the `item.isFavorite` value to the newly added
    parameter when the `onFavoriteClick` function is called.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保在调用`onFavoriteClick`函数时，将`item.isFavorite`值传递给新添加的参数。
- en: 'Inside the `RestaurantsScreen()` composable, make sure you register and then
    pass the newly received `oldValue` function parameter to the `toggleFavorite`
    method of `ViewModel`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen()`可组合组件内部，确保您注册并传递新接收的`oldValue`函数参数到`ViewModel`的`toggleFavorite`方法：
- en: '[PRE44]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We're done! Now it's time to simulate the system-initiated process death scenario.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！现在，是时候模拟系统触发的进程死亡场景了。
- en: Build the project and run the application.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并运行应用程序。
- en: Mark some restaurants as favorites.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记一些餐厅为收藏。
- en: Place the app in the background by pressing the home button on the device/emulator.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按设备/模拟器的home按钮将应用置于后台。
- en: 'Select the **Logcat** window and then press the red rectangular button on the
    left-hand side to terminate the application:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Logcat**窗口，然后按左侧的红色矩形按钮来终止应用程序：
- en: '![Figure 6.4 – Simulating a system-initiated process death'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 模拟系统触发的进程死亡'
- en: '](img/B17788_06_4.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_06_4.jpg]'
- en: Figure 6.4 – Simulating a system-initiated process death
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 模拟系统触发的进程死亡
- en: Relaunch the application from the application drawer.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用抽屉中重新启动应用程序。
- en: Because the app relies on the content saved in the local database, it should
    now correctly display the UI state with the previously favorited restaurants from
    before the system-initiated process death.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因为应用程序依赖于本地数据库中保存的内容，所以它现在应该正确地显示UI状态，包括系统触发的进程死亡之前的已收藏餐厅。
- en: Assignment
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 作业
- en: In this chapter, we made sure to cache the restaurants in Room so that the first
    screen of the application could be accessed without the internet. As a homework
    assignment, you can try to refactor the details screen of the application (where
    the details of a specific restaurant are displayed) to obtain its own data from
    Room if the user enters the app without the internet.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们确保在Room中缓存了餐厅，以便在没有互联网的情况下可以访问应用程序的第一个屏幕。作为家庭作业，你可以尝试重构应用程序的详细信息屏幕（显示特定餐厅的详细信息），如果用户在没有互联网的情况下进入应用程序，可以从Room获取其自己的数据。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gained an understanding of how Room is an essential Jetpack
    library because it allows us to offer offline capabilities to our applications.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Room是如何成为Jetpack库的必要组成部分的，因为它允许我们为应用程序提供离线功能。
- en: First, we explored the core elements of Room to see how a private database is
    set up. Second, we implemented Room inside our Restaurants application and explored
    how to save and retrieve cached content from the local database.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们探讨了Room的核心元素，以了解如何设置私有数据库。其次，我们在Restaurants应用程序中实现了Room，并探讨了如何从本地数据库保存和检索缓存内容。
- en: Afterward, we discovered what partial updates are and how to implement them
    to preserve a user's selections within the app.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们发现了部分更新是什么，以及如何实现它们以保留用户在应用程序中的选择。
- en: Toward the end of the chapter, we understood why having a single source of truth
    for the application's content is beneficial and how that helps us in edge cases
    such as a system-initiated process death.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们了解了为什么对于应用程序的内容来说有一个单一的真实来源是有益的，以及这如何帮助我们处理边缘情况，例如系统触发的进程死亡。
- en: In the next chapter, we're going to dive deeper into various ways of defining
    the architecture of our applications by exploring architectural presentation patterns.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索架构展示模式，更深入地探讨定义我们应用程序架构的各种方法。
