<html><head></head><body>
        

                            
                    <h1 class="header-title">Functors, Applicatives, and Monads</h1>
                
            
            
                
<p class="mce-root">Functors, applicatives, and monads are among the most searched words related to functional programming, which makes sense if you consider that no-one knows what they mean (not really, there are bright people that know what they're talking about). The confusion about monads, in particular, has become a joke/meme in the programming community:</p>
<p>"A monad is a monoid in the category of endofunctors, what's the problem?"</p>
<p class="mce-root">This quote is fictionally attributed to Philip Wadler by James Iry on his classic blog post, <em>A Brief, Incomplete and Mostly Wrong History of Programming Languages,</em> (<a href="http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html">http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html</a>).</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li class="mce-root">Functors</li>
<li class="mce-root">Options, lists, and functions as functors</li>
<li class="mce-root">Monads</li>
<li class="mce-root">Applicatives</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Functors   </h1>
                
            
            
                
<p>What if I told you that you already use functors in Kotlin? Surprised? Let's have a look at the following code:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    listOf(1, 2, 3)<br/>            .map { i -&gt; i * 2 }<br/>            .map(Int::toString)<br/>            .forEach(::println)<br/>}</pre>
<p>The <kbd>List&lt;T&gt;</kbd> class has a function, <kbd>map(transform: (T) -&gt; R): List&lt;R&gt;</kbd>.  Where does the name <kbd>map</kbd> come from? It came from category theory. What we do when we transform from <kbd>Int</kbd> to <kbd>String</kbd>, is we map from the <kbd>Int</kbd> category to the <kbd>String</kbd> category. In the same sense, in our example, we transform from <kbd>List&lt;Int&gt;</kbd> to <kbd>List&lt;Int&gt;</kbd> (not that exciting), and then from <kbd>List&lt;Int&gt;</kbd> to <kbd>List&lt;String&gt;</kbd>. We didn't change the external type, just the internal value.</p>
<p>And that is a functor. A <strong>functor</strong> is a type that defines a way to transform or to map its content. You can find different definitions of a functor, more or less academic; but in principle, all point to the same direction.</p>
<p>Let's define a generic interface for a functor type:</p>
<pre>interface Functor&lt;C&lt;_&gt;&gt; { //Invalid Kotlin code<br/>    fun &lt;A,B&gt; map(ca: C&lt;A&gt;, transform: (A) -&gt; B): C&lt;B&gt;<br/>}</pre>
<p>And, it doesn't compile because Kotlin doesn't support higher-kinded types.</p>
<p>You'll find more information on higher-kinded types for Kotlin, including alternatives and the future of Kotlin, in <a href="e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml">Chapter 13</a>, <em>Arrow Types</em><strong>.</strong></p>
<p>In languages that support higher-kinded types, such as <strong>Scala</strong> and <strong>Haskell</strong>, it is possible to define a <kbd>Functor</kbd> type, for example, the Scala cats functor:</p>
<pre>trait Functor[F[_]] extends Invariant[F] { self =&gt;<br/>  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]<br/><br/>  //More code here</pre>
<p>In Kotlin, we don't have those features, but we can simulate them by convention. If a type has a function or an extension function, then <kbd>map</kbd> is a functor (this is called <strong>structural typing</strong>, defining a type by its structure rather than its hierarchy).</p>
<p>We can have a simple <kbd>Option</kbd> type:</p>
<pre>sealed class Option&lt;out T&gt; {<br/>    object None : Option&lt;Nothing&gt;() {<br/>        override fun toString() = "None"<br/>    }<br/><br/>    data class Some&lt;out T&gt;(val value: T) : Option&lt;T&gt;()<br/><br/>    companion object<br/>}</pre>
<p>Then, you can define a <kbd>map</kbd> function for it:</p>
<pre>fun &lt;T, R&gt; Option&lt;T&gt;.map(transform: (T) -&gt; R): Option&lt;R&gt; = when (this) {<br/>    Option.None -&gt; Option.None<br/>    is Option.Some -&gt; Option.Some(transform(value))<br/>}</pre>
<p>And use it in the following way:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println(Option.Some("Kotlin")<br/>            .map(String::toUpperCase)) //Some(value=KOTLIN)<br/>}</pre>
<p>Now, an <kbd>Option</kbd> value will behave differently for <kbd>Some</kbd> and <kbd>None:</kbd></p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    println(Option.Some("Kotlin").map(String::toUpperCase)) //Some(value=KOTLIN)<br/>    println(Option.None.map(String::toUpperCase)) //None<br/>}</pre>
<p>Extension functions are so flexible that we can write a <kbd>map</kbd> function for a function type, <kbd>(A) -&gt; B</kbd>, therefore, transforming functions into functors:</p>
<pre>fun &lt;A, B, C&gt; ((A) -&gt; B).map(transform: (B) -&gt; C): (A) -&gt; C = { t -&gt; transform(this(t)) }</pre>
<p>What we are changing here is the return type from <kbd>B</kbd> to <kbd>C</kbd> by applying the parameter function, <kbd>transform: (B) -&gt; C</kbd> to the result of the function <kbd>(A) -&gt; B</kbd> itself:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val add3AndMultiplyBy2: (Int) -&gt; Int = { i: Int -&gt; i + 3 }.map { j -&gt; j * 2 }<br/>    println(add3AndMultiplyBy2(0)) //6<br/>    println(add3AndMultiplyBy2(1)) //8<br/>    println(add3AndMultiplyBy2(2)) //10<br/>}</pre>
<p>If you have experience in other functional programming languages, recognize this behavior as forward function composition (more on function composition in <a href="54f4e874-0af4-411a-9820-369d4683e40a.xhtml" target="_blank">Chapter 12</a>, <em>Getting Started with Arrow).</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Monads</h1>
                
            
            
                
<p class="mce-root">A <strong>monad</strong> is a functor type that defines a <kbd>flatMap</kbd> (or <kbd>bind</kbd>, in other languages) function, that receives a lambda that returns the same type. Let me explain it with an example. Luckily for us, <kbd>List&lt;T&gt;</kbd> defines a <kbd>flatMap</kbd> function:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val result = listOf(1, 2, 3)<br/>            .flatMap { i -&gt;<br/>                listOf(i * 2, i + 3)<br/>            }<br/>            .joinToString()<br/>    <br/>    println(result) //2, 4, 4, 5, 6, 6<br/>}</pre>
<p>In a <kbd>map</kbd> function, we just transform the <kbd>List</kbd> value's content, but in <kbd>flatMap</kbd>, we can return a new <kbd>List</kbd> type with less or more items, making it a lot more potent than <kbd>map</kbd>.</p>
<p>So, a generic monad will look like this (just remember that we don't have higher-kinded types):</p>
<pre>interface Monad&lt;C&lt;_&gt;&gt;: Functor&lt;C&gt; { //Invalid Kotlin code<br/>    fun &lt;A, B&gt; flatMap(ca:C&lt;A&gt;, fm:(A) -&gt; C&lt;B&gt;): C&lt;B&gt;<br/>}</pre>
<p>Now, we can write a <kbd>flatMap</kbd> function for our <kbd>Option</kbd> type:</p>
<pre>fun &lt;T, R&gt; Option&lt;T&gt;.flatMap(fm: (T) -&gt; Option&lt;R&gt;): Option&lt;R&gt; = when (this) {<br/>    Option.None -&gt; Option.None<br/>    is Option.Some -&gt; fm(value)<br/>}</pre>
<p>If you pay close attention, you can see that <kbd>flatMap</kbd> and map look very similar; so similar that we can rewrite <kbd>map</kbd> using <kbd>flatMap</kbd>:</p>
<pre>fun &lt;T, R&gt; Option&lt;T&gt;.map(transform: (T) -&gt; R): Option&lt;R&gt; = flatMap { t -&gt; Option.Some(transform(t)) }</pre>
<p>And now we can use a <kbd>flatMap</kbd> function's power in cool ways that will be impossible with a plain map:</p>
<pre>fun calculateDiscount(price: Option&lt;Double&gt;): Option&lt;Double&gt; {<br/>    return price.flatMap { p -&gt;<br/>        if (p &gt; 50.0) {<br/>            Option.Some(5.0)<br/>        } else {<br/>            Option.None<br/>        }<br/>    }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    println(calculateDiscount(Option.Some(80.0))) //Some(value=5.0)<br/>    println(calculateDiscount(Option.Some(30.0))) //None<br/>    println(calculateDiscount(Option.None)) //None<br/>}</pre>
<p>Our function, <kbd>calculateDiscount</kbd>, receives and returns <kbd>Option&lt;Double&gt;</kbd>. If the price is higher than <kbd>50.0</kbd>, we return a discount of <kbd>5.0</kbd> wrapped on <kbd>Some</kbd>, and <kbd>None</kbd> if it doesn't.</p>
<p>One cool trick with <kbd>flatMap</kbd> is that it can be nested:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val maybeFive = Option.Some(5)<br/>    val maybeTwo = Option.Some(2)<br/><br/>    println(maybeFive.flatMap { f -&gt;<br/>        maybeTwo.flatMap { t -&gt;<br/>            Option.Some(f + t)<br/>        }<br/>    }) // Some(value=7)<br/>}</pre>
<p>In the inner <kbd>flatMap</kbd> function, we have access to both values and operate over them.</p>
<p>We can write this example in a slightly shorter way by combining <kbd>flatMap</kbd> and <kbd>map</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val maybeFive = Option.Some(5)<br/>    val maybeTwo = Option.Some(2)<br/><br/>    println(maybeFive.flatMap { f -&gt;<br/>        maybeTwo.map { t -&gt;<br/>            f + t<br/>        }<br/>    }) // Some(value=7)<br/>}</pre>
<p>As such, we can rewrite our first <kbd>flatMap</kbd> example as a composition of two lists—one of numbers and another one of functions:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val numbers = listOf(1, 2, 3)<br/>    val functions = listOf&lt;(Int) -&gt; Int&gt;({ i -&gt; i * 2 }, { i -&gt; i + 3 })<br/>    val result = numbers.flatMap { number -&gt;<br/>        functions.map { f -&gt; f(number) }<br/>    }.joinToString()<br/><br/>    println(result) //2, 4, 4, 5, 6, 6<br/>}</pre>
<p>This technique of nesting several <kbd>flatMap</kbd> or combinations of <kbd>flatMap</kbd> with <kbd>map</kbd> is very powerful and is the primary idea behind another concept named monadic comprehensions, which allow us to combine monadic operations (more about comprehensions in <a href="e8047703-5a99-4b69-be68-f3fe94900fc4.xhtml" target="_blank">Chapter 13</a>, <em>Arrow Types</em>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applicatives</h1>
                
            
            
                
<p>Our previous example, invoking a lambda inside a wrapper with a parameter inside the same kind of wrapper, is the perfect way to introduce applicatives.</p>
<p>An <strong>applicative</strong> is a type that defines two functions, a <kbd>pure(t: T)</kbd> function that returns the <kbd>T</kbd> value wrapped in the applicative type, and an <kbd>ap</kbd> function (<kbd>apply</kbd>, in other languages) that receives a lambda wrapped in the applicative type.</p>
<p>In the previous section, when we explained monads, we made them extend directly from a functor but in reality, a monad extends from an applicative and an applicative extends from a functor. Therefore, our pseudo code for a generic applicative, and the entire hierarchy, will look like this:</p>
<pre>interface Functor&lt;C&lt;_&gt;&gt; { //Invalid Kotlin code<br/>    fun &lt;A,B&gt; map(ca:C&lt;A&gt;, transform:(A) -&gt; B): C&lt;B&gt;<br/>}<br/><br/>interface Applicative&lt;C&lt;_&gt;&gt;: Functor&lt;C&gt; { //Invalid Kotlin code<br/>    fun &lt;A&gt; pure(a:A): C&lt;A&gt;<br/><br/>    fun &lt;A, B&gt; ap(ca:C&lt;A&gt;, fab: C&lt;(A) -&gt; B&gt;): C&lt;B&gt;<br/>}<br/><br/>interface Monad&lt;C&lt;_&gt;&gt;: Applicative&lt;C&gt; { //Invalid Kotlin code<br/>    fun &lt;A, B&gt; flatMap(ca:C&lt;A&gt;, fm:(A) -&gt; C&lt;B&gt;): C&lt;B&gt;<br/>}</pre>
<p>In short, an applicative is a more powerful functor, and a monad is a more powerful applicative.</p>
<p>Now, let's write an <kbd>ap</kbd> extension function for <kbd>List&lt;T&gt;</kbd>:</p>
<pre>fun &lt;T, R&gt; List&lt;T&gt;.ap(fab: List&lt;(T) -&gt; R&gt;): List&lt;R&gt; = fab.flatMap { f -&gt; this.map(f) }</pre>
<p>And we can revisit our last example from the <em>Monads</em> section:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val numbers = listOf(1, 2, 3)<br/>    val functions = listOf&lt;(Int) -&gt; Int&gt;({ i -&gt; i * 2 }, { i -&gt; i + 3 })<br/>    val result = numbers.flatMap { number -&gt;<br/>        functions.map { f -&gt; f(number) }<br/>    }.joinToString()<br/><br/>    println(result) //2, 4, 4, 5, 6, 6<br/>}</pre>
<p>Let's rewrite it with the <kbd>ap</kbd> function:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val numbers = listOf(1, 2, 3)<br/>    val functions = listOf&lt;(Int) -&gt; Int&gt;({ i -&gt; i * 2 }, { i -&gt; i + 3 })<br/>    val result = numbers<br/>            .ap(functions)<br/>            .joinToString()<br/>    println(result) //2, 4, 6, 4, 5, 6<br/>}</pre>
<p>Easier to read, but with a caveat—the result is in a different order. We need to be aware and choose which option is appropriate for our particular case.</p>
<p>We can add <kbd>pure</kbd> and <kbd>ap</kbd> to our <kbd>Option</kbd> class:</p>
<pre>fun &lt;T&gt; Option.Companion.pure(t: T): Option&lt;T&gt; = Option.Some(t)<br/></pre>
<p><kbd>Option.pure</kbd> is just a simple alias for the <kbd>Option.Some</kbd> constructor.</p>
<p>Our <kbd>Option.ap</kbd> function is fascinating:</p>
<pre>//Option<br/>fun &lt;T, R&gt; Option&lt;T&gt;.ap(fab: Option&lt;(T) -&gt; R&gt;): Option&lt;R&gt; = fab.flatMap { f -&gt; map(f) }<br/><br/>//List<br/>fun &lt;T, R&gt; List&lt;T&gt;.ap(fab: List&lt;(T) -&gt; R&gt;): List&lt;R&gt; = fab.flatMap { f -&gt; this.map(f) }</pre>
<p>Both <kbd>Option.ap</kbd> and <kbd>List.ap</kbd> have the same body, using a combination of <kbd>flatMap</kbd> and <kbd>map</kbd>, which is precisely how we combine monadic operations.</p>
<p>With monads, we summed two <kbd>Option&lt;Int&gt;</kbd> using <kbd>flatMap</kbd> and <kbd>map:</kbd></p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val maybeFive = Option.Some(5)<br/>    val maybeTwo = Option.Some(2)<br/><br/>    println(maybeFive.flatMap { f -&gt;<br/>        maybeTwo.map { t -&gt;<br/>            f + t<br/>        }<br/>    }) // Some(value=7)<br/>}</pre>
<p>Now, using applicatives:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val maybeFive = Option.pure(5)<br/>    val maybeTwo = Option.pure(2)<br/><br/>    println(maybeTwo.ap(maybeFive.map { f -&gt; { t: Int -&gt; f + t } })) // Some(value=7)<br/>}</pre>
<p>That is not very easy to read. First, we map <kbd>maybeFive</kbd> with a lambda <kbd>(Int) -&gt; (Int) -&gt; Int</kbd> (technically, a curried function, and there is more information about curried functions in <a href="54f4e874-0af4-411a-9820-369d4683e40a.xhtml" target="_blank">Chapter 12</a>, <em>Getting Started with Arrow</em>), that returns an <kbd>Option&lt;(Int) -&gt; Int&gt;</kbd> that can be passed as a parameter for <kbd>maybeTwo.ap</kbd>.</p>
<p>We can make things easier to read with a little trick (that I'm borrowing from Haskell):</p>
<pre>infix fun &lt;T, R&gt; Option&lt;(T) -&gt; R&gt;.`(*)`(o: Option&lt;T&gt;): Option&lt;R&gt; = flatMap { f: (T) -&gt; R -&gt; o.map(f) }</pre>
<p>The <kbd>infix</kbd> extension function <kbd>Option&lt;(T) -&gt; R&gt;.`(*)`</kbd> will let us read the <kbd>sum</kbd> operation from left to right; how cool is that? Now, let's look at the following code, summing two <kbd>Option&lt;Int&gt;</kbd> using applicatives</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val maybeFive = Option.pure(5)<br/>    val maybeTwo = Option.pure(2)<br/><br/>    println(Option.pure { f: Int -&gt; { t: Int -&gt; f + t } } `(*)` maybeFive `(*)` maybeTwo) // Some(value=7)<br/>}</pre>
<p>We wrap the <kbd>(Int) -&gt; (Int) -&gt; Int</kbd> lambda with the <kbd>pure</kbd> function and then we apply <kbd>Option&lt;Int&gt;</kbd>, one by one. We use the name <kbd>`(*)`</kbd> as a homage to Haskell's <kbd>&lt;*&gt;</kbd>.</p>
<p>So far, you can see that applicatives let you do some cool tricks, but monads are more powerful and flexible. When do use one or the other? It obviously depends on your particular problem, but our general advice is to use the abstraction with the least amount of power possible. You can start with a functor's <kbd>map</kbd>, then an applicative's <kbd>ap</kbd>, and lastly a monad's <kbd>flatMap</kbd>. Everything can be done with <kbd>flatMap</kbd> (as you can see  <kbd>Option</kbd>, <kbd>map</kbd>, and <kbd>ap</kbd> were implemented using <kbd>flatMap</kbd>), but most of the time <kbd>map</kbd> and <kbd>ap</kbd> can be more accessible to reason about it.</p>
<p>Coming back to functions, we can make a function behave as an applicative. First, we should add a pure function:</p>
<pre>object Function1 {<br/>    fun &lt;A, B&gt; pure(b: B) = { _: A -&gt; b }<br/>}</pre>
<p>First, we create an object <kbd>Function1</kbd>, as the function type <kbd>(A) -&gt; B</kbd> doesn't have a companion object to add new extension functions as we did with <kbd>Option:</kbd></p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val f: (String) -&gt; Int = Function1.pure(0)<br/>    println(f("Hello,"))    //0<br/>    println(f("World"))     //0<br/>    println(f("!"))         //0<br/>}</pre>
<p><kbd>Function1.pure(t: T)</kbd> will wrap a <kbd>T</kbd> value in a function and will return it, regardless of the parameter that we use. If you have experience with other functional languages, you'll recognize function's <kbd>pure</kbd> as an <kbd>identity</kbd> function (more about <kbd>identity</kbd> functions in <a href="54f4e874-0af4-411a-9820-369d4683e40a.xhtml" target="_blank">Chapter 12</a>, <em>Getting Started with Arrow</em>).</p>
<p>Let's add <kbd>flatMap</kbd>, an <kbd>ap</kbd>, to a function <kbd>(A) -&gt; B</kbd>:</p>
<pre>fun &lt;A, B, C&gt; ((A) -&gt; B).map(transform: (B) -&gt; C): (A) -&gt; C = { t -&gt; transform(this(t)) }<br/><br/>fun &lt;A, B, C&gt; ((A) -&gt; B).flatMap(fm: (B) -&gt; (A) -&gt; C): (A) -&gt; C = { t -&gt; fm(this(t))(t) }<br/><br/>fun &lt;A, B, C&gt; ((A) -&gt; B).ap(fab: (A) -&gt; (B) -&gt; C): (A) -&gt; C = fab.flatMap { f -&gt; map(f) }</pre>
<p>We already cover <kbd>map(transform: (B) -&gt; C): (A) -&gt; C</kbd> and we know that it behaves as a forward function composition. If you pay close attention to <kbd>flatMap</kbd> and <kbd>ap</kbd>, you'll see that the parameter is kind of backwards (and that <kbd>ap</kbd> is implemented as all the other <kbd>ap</kbd> functions for other types).</p>
<p>But, what can we do with the function's <kbd>ap</kbd>? Let's look at the following code:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val add3AndMultiplyBy2: (Int) -&gt; Int = { i: Int -&gt; i + 3 }.ap { { j: Int -&gt; j * 2 } }<br/>    println(add3AndMultiplyBy2(0)) //6<br/>    println(add3AndMultiplyBy2(1)) //8<br/>    println(add3AndMultiplyBy2(2)) //10<br/>}</pre>
<p>Well, we can compose functions, which is not exciting at all because we already did that with <kbd>map</kbd>. But there is a little trick with function's <kbd>ap</kbd>. We can access the original parameter:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    val add3AndMultiplyBy2: (Int) -&gt; Pair&lt;Int, Int&gt; = { i:Int -&gt; i + 3 }.ap { original -&gt; { j:Int -&gt; original to (j * 2) } }<br/>    println(add3AndMultiplyBy2(0)) //(0, 6)<br/>    println(add3AndMultiplyBy2(1)) //(1, 8)<br/>    println(add3AndMultiplyBy2(2)) //(2, 10)<br/>}</pre>
<p>Accessing the original parameter in a function composition is useful in several scenarios, such as debugging and auditing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We've covered a lot of cool concepts with scary names but with simple ideas behind them. The functor, applicative, and monad types open the door for several abstractions and more powerful functional concepts that we'll cover in the following chapters. We learned about some of the limitations of Kotlin and how we can overcome them as we create functions to mimic functor, applicative, and monad for different types. We also explored the hierarchical relationship between functors, applicatives, and monads.</p>
<p>In the next chapter, we'll cover  how to work effectively with Streams of data.</p>


            

            
        
    </body></html>