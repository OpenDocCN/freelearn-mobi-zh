<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Displaying Data</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Providing lists</li><li class="listitem" style="list-style-type: disc">Displaying data in a table</li><li class="listitem" style="list-style-type: disc">Customizing rows</li><li class="listitem" style="list-style-type: disc">Editing a table: deleting rows</li><li class="listitem" style="list-style-type: disc">Editing a table: inserting rows</li><li class="listitem" style="list-style-type: disc">Table indexing</li><li class="listitem" style="list-style-type: disc">Searching through the data</li><li class="listitem" style="list-style-type: disc">Creating a simple web browser</li><li class="listitem" style="list-style-type: disc">Displaying local content</li><li class="listitem" style="list-style-type: disc">Displaying formatted text</li><li class="listitem" style="list-style-type: disc">Displaying documents</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Introduction</h1></div></div></div><p>In the previous chapter, we discussed about some of the available options for data management in an iOS application. In this chapter, we will discuss various ways of displaying data to the user.</p><p>Specifically, we will see how to use the following controls:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UIPickerView:</code> This is the control that provides similar functionality to a list box.<a id="id411" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UITableView:</code> This is a very customizable view for displaying data. One of the most used controls in iOS applications.<a id="id412" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UISearchBar</code><strong> and</strong><code class="literal"> UISearchDisplayController:</code> These are a combination of controls that provide an easy-to-use interface for searching through data.<a id="id413" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UIWebView:</code> This brings web browser functionality to applications.<a id="id414" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">QLPreviewController:</code> This displays various document formats.<a id="id415" class="indexterm"/></li></ul></div><p>Furthermore, we will learn how to provide indexing in tables, to make large volumes of data easily accessible to the user. We will also discuss some of the available ways to display formatted text, even<strong> Portable Document Format (PDF)</strong> , and other documents.<a id="id416" class="indexterm"/>
</p><p>Also, starting from this chapter, all code examples will use a default view controller named<code class="literal"> MainController</code>, unless otherwise stated.<a id="id417" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Providing lists</h1></div></div></div><p>In this recipe, we will learn how to use the<code class="literal"> UIPickerView</code> class.<a id="id418" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec01"/>Getting ready</h2></div></div></div><p>The<code class="literal"> UIPickerView</code> class provides us with a control whose functionality is similar to a listbox, specifically designed for human fingers touching the screen. Its main difference to a common listbox is that each column can have its own number of rows. To get started, create a new iPhone project and name it<code class="literal"> PickerViewApp</code>.<a id="id419" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> MainController.xib</code> file in Interface Builder.</li><li class="listitem"> Add a<code class="literal"> UILabel</code> and a<code class="literal"> UIPickerView</code> on the main View.</li><li class="listitem"> Save the document.</li><li class="listitem"> Back in MonoDevelop, create a nested class in the<code class="literal"> MainController</code> class that inherits from<code class="literal"> UIPickerViewModel:</code><a id="id420" class="indexterm"/><div><pre class="programlisting">private class PickerModelDelegate : UIPickerViewModel
</pre></div></li><li class="listitem"> Add the following constructor and fields in the nested class:<div><pre class="programlisting">public PickerModelDelegate (MainController controller) {
this.parentController = controller;
this.transportList = new List&lt;string&gt;() { "On foot", "Bicycle", "Motorcycle", "Car", "Bus" };
this.distanceList = new List&lt;string&gt;() { "0.5", "1", "5", "10", "100" };
this.unitList = new List&lt;string&gt;() { "mi", "km" };
this.transportSelected = this.transportList[0];
this.distanceSelected = this.distanceList[0];
this.unitSelected = this.unitList[0];
}
private MainController parentController;
private List&lt;string&gt; transportList;
private List&lt;string&gt; distanceList;
private List&lt;string&gt; unitList;
string transportSelected;
string distanceSelected;
string unitSelected;
</pre></div></li><li class="listitem"> You will now need to override four methods from the<code class="literal"> UIPickerViewModel</code> class:<a id="id421" class="indexterm"/><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">int GetComponentCount (UIPickerView picker)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">int GetRowsInComponent (UIPickerView picker, int component)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">string GetTitle (UIPickerView picker, int row, int component)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">void Selected (UIPickerView picker, int row, int component)</code></li></ul></div></li><li class="listitem"> Finally, set the model object created to the picker view's<code class="literal"> Model</code> property inside the controller's<code class="literal"> ViewDidLoad</code> method:<div><pre class="programlisting">this.picker.Model = new PickerModelDelegate (this);
</pre></div></li></ol></div><p>The complete code can be found in the<code class="literal"> PickerViewApp</code> project.<a id="id422" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec03"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIPickerViewModel</code> class does not exist in<code class="literal"> Objective-C</code>. MonoTouch provides this class as a wrapper around the native protocols<code class="literal"> UIPickerViewDataSource</code> and<code class="literal"> UIPickerViewDelegate</code> and contains both of these class' methods for us to override. This is extremely helpful, since we only have to implement and assign one class instead of two for our picker view. Both of these protocols are at the same time available as classes in MonoTouch.<a id="id423" class="indexterm"/>
</p><p>Inside the constructor, we initialize the lists that will hold the data to be displayed in the picker. The four classes we need to override are responsible for displaying the data:</p><div><ol class="orderedlist"><li class="listitem"><code class="literal"> int GetComponentCount (UIPickerView picker):</code> This returns the number of columns we want the picker view to display.<a id="id424" class="indexterm"/></li><li class="listitem"><code class="literal"> int GetRowsInComponent (UIPickerView picker, int component):</code> This returns the number of rows each component will display.<a id="id425" class="indexterm"/></li><li class="listitem"><code class="literal"> string GetTitle (UIPickerView picker, int row, int component):</code> This returns the text of each row.<a id="id426" class="indexterm"/></li><li class="listitem"><code class="literal"> void Selected (UIPickerView picker, int row, int component):</code> This returns the action to take when the user selects an item from any component/row combination in the picker view.<a id="id427" class="indexterm"/></li></ol></div><p>We use the lists we have assigned in the constructor to display the data. For example, the<code class="literal"> GetTitle</code> method is implemented as follows:<a id="id428" class="indexterm"/>
</p><div><pre class="programlisting">switch (component){
case 0:
return this.transportList[row];
case 1:
return this.distanceList[row];
default:
return this.unitList[row];
}
</pre></div><p>When we run the application and select anything from the picker, the result will be similar to the following screenshot:</p><div><img src="img/1468EXP_05_01.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec04"/>There's more...</h2></div></div></div><p>We can programmatically select the initial selection of the picker view by calling the method<code class="literal"> Select (int, int, bool)</code>. The first two parameters reflect the row and component index respectively, while the<code class="literal"> bool</code> parameter toggles the selection animation. The only thing to remember with this method is to call it after we have assigned the picker's<code class="literal"> Model</code> property. An exception will occur otherwise.<a id="id429" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec01"/>More information on UIPickerView customization</h3></div></div></div><p>Apart from the options presented, we also have the option of setting the width of each component. To do this, we override the<code class="literal"> GetComponentWidth (UIPickerView, int)</code> method, which returns a float that represents the width for each component.<a id="id430" class="indexterm"/>
</p><p>We can also set custom views as items in the picker view, instead of plain text. This can be done by overriding the<code class="literal"> GetView(UIPickerView, int, int, UIView)</code> method and returning the view we want to be displayed in each position in the<code class="literal"> UIPickerView</code> control.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Date and time selection</h3></div></div></div><p>There is a control named<code class="literal"> UIDatePicker</code> that is similar to the<code class="literal"> UIPickerView</code> and is specifically customized for displaying and selecting date and time values. Note that although its user interface is the same as the picker view, it does not inherit the<code class="literal"> UIPickerView</code> class. It just uses an instance of it as a sub-view.<a id="id431" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec05"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Displaying data in a table</h1></div></div></div><p>In this recipe, we will learn how to use the<code class="literal"> UITableView</code> class to display data.<a id="id432" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec06"/>Getting ready</h2></div></div></div><p>The<code class="literal"> UITableView</code> class, along with the<code class="literal"> UITableViewCell</code> object, provides an interface for displaying data on the screen in multiple rows, but on a single column. To get started, create a new project in MonoDevelop, and name it<code class="literal"> TableViewApp.</code>
<a id="id433" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec07"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a view with controller to the project, and name it<code class="literal"> TableController</code>.</li><li class="listitem"> Change the<code class="literal"> TableController</code> class' inheritance from<code class="literal"> UIViewController</code> to<code class="literal"> UITableViewController:</code><a id="id434" class="indexterm"/><div><pre class="programlisting">public partial class TableController : UITableViewController
</pre></div></li><li class="listitem"> Open the<code class="literal"> TableController.xib</code> file in Interface.</li><li class="listitem"> Delete the document's<code class="literal"> UIView</code>, and add a<code class="literal"> UITableView</code> in its place.</li><li class="listitem"> Connect the outlet named view of the<code class="literal"> TableController</code> to the table view added.</li><li class="listitem"> Save the document.</li><li class="listitem"> Back in MonoDevelop, create the following nested class inside the<code class="literal"> TableController</code> class:<a id="id435" class="indexterm"/><div><pre class="programlisting">private class TableSource : UITableViewSource{
public TableSource (){
this.cellID = "cellIdentifier";
this.tableData = new Dictionary&lt;int, string&gt; () {
{0, "Music"},
{1, "Videos"},
{2, "Images"}
};
}
private string cellID;
private Dictionary&lt;int, string&gt; tableData;
public override int RowsInSection (UITableView tableview, int section){
return this.tableData.Count;
}
public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath){
int rowIndex = indexPath.Row;
UITableViewCell cell = tableView.DequeueReusableCell (this.cellID);
if (null == cell){
cell = new UITableViewCell (UITableViewCellStyle.Default, this.cellID);
}
cell.TextLabel.Text = this.tableData[rowIndex];
return cell;
}
}
</pre></div></li><li class="listitem"> Override the controller's<code class="literal"> ViewDidLoad</code> method, and add the following line of code:<div><pre class="programlisting">this.TableView.Source = new TableSource ();
</pre></div></li></ol></div><p>The complete code can be found in the<code class="literal"> TableViewApp</code> project.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec08"/>How it works...</h2></div></div></div><p>The nested class that we created acts as the data source of the<code class="literal"> UITableView</code>. It inherits from the MonoTouch<code class="literal"> UITableViewSource</code> class:<a id="id436" class="indexterm"/>
</p><div><pre class="programlisting">private class TableSource : UITableViewSource
</pre></div><div><h3 class="title"><a id="note29"/>Note</h3><p>Like the<code class="literal"> UIPickerView</code>, in the example discussed in the previous recipe, the<code class="literal"> UITableViewSource</code> class does not exist in<code class="literal"> Objective-C</code>. It is merely a wrapper object offered by MonoTouch around<code class="literal"> UITableViewDelegate</code> and<code class="literal"> UITableViewSource</code> protocols.</p></div><p>In its constructor, we initialize two variables. A string that will act as the cells' identifier and a generic<code class="literal"> Dictionary</code> for our data source.<a id="id437" class="indexterm"/>
</p><div><pre class="programlisting">this.cellID = "cellIdentifier";
this.tableData = new Dictionary&lt;int, string&gt; () {
{0, "Music"},
{1, "Videos"},
{2, "Images"}
};
</pre></div><p>To make the<code class="literal"> TableSource</code> class work, we need to override two methods. The first method, named<code class="literal"> RowsInSection</code>, which returns the number of rows the table shall display. Here, we return the number of items in our data source object:<a id="id438" class="indexterm"/>
</p><div><pre class="programlisting">return this.tableData.Count;
</pre></div><p>The second method,<code class="literal"> GetCell</code>, returns the<code class="literal"> UITableViewCell</code> object that will be displayed in the table.<a id="id439" class="indexterm"/>
</p><div><h3 class="title"><a id="note30"/>Note</h3><p>The<code class="literal"> UITableViewCell</code> class represents a single row and manages its content in a<code class="literal"> UITableView</code>.</p></div><p>To be more efficient, the table view creates its cell objects when they are needed. For this reason, we need to get a previously used<code class="literal"> UITableViewCell</code> from the table through its<code class="literal"> DequeueReusableCell</code> method:<a id="id440" class="indexterm"/>
</p><div><pre class="programlisting">UITableViewCell cell = tableView.DequeueReusableCell (this.cellID);
</pre></div><p>If no cells exist for the particular cell identifier, the method returns<code class="literal"> null</code>. Hence, we create the cell that will be used:</p><div><pre class="programlisting">cell = new UITableViewCell (UITableViewCellStyle.Default, this.cellID);
</pre></div><p>Then, we assign the text that the particular cell will display and return it:</p><div><pre class="programlisting">cell.TextLabel.Text = this.tableData[rowIndex];
return cell;
</pre></div><p>By default, the<code class="literal"> UITableViewCell</code> class contains two labels that can be used to display text. The main label can be accessed through the<code class="literal"> TextLabel</code> property and the secondary label through the<code class="literal"> DetailTextLabel</code> property. Note that when using a cell with the<code class="literal"> Default</code> style, the<code class="literal"> DetailTextLabel</code> property cannot be used and will return<code class="literal"> null</code>.<a id="id441" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec09"/>There's more...</h2></div></div></div><p>To provide functionality when the user selects a particular row, we need to override the<code class="literal"> RowSelected</code> property in the class that acts as a<code class="literal"> UITableViewSource</code>. By default, when the user taps on a row, the cell is highlighted with a blue color to indicate the selection. To de-select the row, we use the<code class="literal"> UITableView.DeselectRow(NSIndexPath, bool)</code> method:<a id="id442" class="indexterm"/>
</p><div><pre class="programlisting">public override void RowSelected (UITableView tableView, NSIndexPath indexPath){
tableView.DeselectRow (indexPath, true);
}
</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec03"/>UITableView styles</h3></div></div></div><p>The<code class="literal"> UITableView</code> can be created with two different styles. The default style is<code class="literal"> Plain</code>. The other style that can be used is the<code class="literal"> Grouped</code> style. This style is being used in many iOS native applications, such as the<code class="literal"> Settings</code> application.</p><p>Also, the<code class="literal"> UITableView</code> supports display of data divided into different sections. We must explicitly return the number of rows that each section will have in the<code class="literal"> RowsInSection</code> override if we want to use different sections.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec10"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Providing lists</em></li><li class="listitem" style="list-style-type: disc"><em>Customizing rows</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch03.html" title="Chapter 3. User Interface: View Controllers">Chapter 3</a>, User Interface: View Controllers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating</em> a<em> table controller</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Customizing rows</h1></div></div></div><p>In this recipe, we will cover some of the different options available for customizing the display of content in table cells.<a id="id443" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec11"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop in the same manner the project in the previous recipe was created. Name it<code class="literal"> CustomRowsApp.</code>
<a id="id444" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec12"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Copy and paste the<code class="literal"> TableSource</code> class from the project in the previous task, inside the<code class="literal"> TableController</code> class.<a id="id445" class="indexterm"/></li><li class="listitem"> Perform the following changes in the<code class="literal"> GetCell</code> override:<div><pre class="programlisting">int rowIndex = indexPath.Row;
string cellID = this.tableData[rowIndex];
UITableViewCell cell = tableView.DequeueReusableCell (cellID);
if (null == cell){
cell = new UITableViewCell (this.cellStyles[rowIndex], cellID);
}
cell.TextLabel.Text = this.tableData[rowIndex];
if (rowIndex &gt; 0){
cell.DetailTextLabel.Text = String.Format ("Details for {0}", cellID);
}
return cell;
</pre></div></li><li class="listitem"> Remove the<code class="literal"> cellID</code> field and add a new one:<div><pre class="programlisting">private Dictionary&lt;int, UITableViewCellStyle&gt; cellStyles;
</pre></div></li><li class="listitem"> Initialize it in the constructor, as follows:<div><pre class="programlisting">this.cellStyles = new Dictionary&lt;int, UITableViewCellStyle&gt;() {
{0, UITableViewCellStyle.Default},
{1, UITableViewCellStyle.Subtitle},
{2, UITableViewCellStyle.Value1},
{3, UITableViewCellStyle.Value2}
};
</pre></div></li><li class="listitem"> Add another<code class="literal"> KeyValuePair</code> in the data source object:<div><pre class="programlisting">{3, "Recordings"}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. The output should be something similar to the following, as explained in the following screenshot:</li></ol></div><div><img src="img/1468EXP_05_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec13"/>How it works...</h2></div></div></div><p>A table cell can have four different cell styles, which are represented by the<code class="literal"> UITableViewCellStyle</code> enumeration. Its values are:<a id="id446" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><code class="literal"> Default:</code> This is the default cell style. Only the<code class="literal"> TextLabel</code> property can be used to display text.<a id="id447" class="indexterm"/></li><li class="listitem"><code class="literal"> Subtitle:</code> This is a style that provides the<code class="literal"> DetailTextLabel</code> as a sub-title to the<code class="literal"> TextLabel</code>.<a id="id448" class="indexterm"/></li><li class="listitem"><code class="literal"> Value1:</code> This is a style that displays both<code class="literal"> TextLabel</code> and<code class="literal"> DetailTextLabel</code> text in the same size, with different colors and aligned to the sides of the cell.<a id="id449" class="indexterm"/></li><li class="listitem"><code class="literal"> Value2:</code> This is a style that displays the<code class="literal"> TextLabel</code> text smaller than the<code class="literal"> DetailTextLabel</code> text. This style is used in the native<code class="literal"> Contacts</code> application, in the contact details screen.<a id="id450" class="indexterm"/></li></ol></div><p>To easily use all available styles, we have added all the values of the<code class="literal"> UITableViewCellStyle</code> enumeration in a<code class="literal"> Dictionary:</code>
</p><div><pre class="programlisting">private Dictionary&lt;int, UITableViewCellStyle&gt; cellStyles;
</pre></div><p>Now that we use different cell styles, hence different cells, we need one cell identifier for each string. To avoid declaring another list or more fields in the class, we use the data source for this reason:</p><div><pre class="programlisting">int rowIndex = indexPath.Row;
string cellID = this.tableData[rowIndex];
UITableViewCell cell = tableView.DequeueReusableCell (cellID);
</pre></div><p>To create each cell with a specific style, we extract the<code class="literal"> UITableViewCellStyle</code> value from the<code class="literal"> cellStyles</code> field, according to the current row:</p><div><pre class="programlisting">cell = new UITableViewCell (this.cellStyles[rowIndex], cellID);
</pre></div><p>To set the<code class="literal"> DetailTextLabel</code> text for each cell, we just make sure we are not trying to set it on a cell with<code class="literal"> Default</code> style, as the first one in this example:<a id="id451" class="indexterm"/>
</p><div><pre class="programlisting">if (rowIndex &gt; 0){
cell.DetailTextLabel.Text = String.Format ("Details for {0}", cellID);
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec14"/>There's more...</h2></div></div></div><p>Further customization can be done in a<code class="literal"> UITableViewCell</code>. All views a cell contains, including the<code class="literal"> TextLabel</code> and<code class="literal"> DetailTextLabel,</code> are sub-views to the cell's view, which is exposed through its<code class="literal"> ContentView</code> property. We can create custom views and add them as sub-views to it.<a id="id452" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec04"/>Other useful properties of the UITableViewCell class</h3></div></div></div><p>Apart from adding text in the default labels, the<code class="literal"> UITableViewCell</code> contains some other properties, whose values we can set, to add more default items in a cell:<a id="id453" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ImageView:</code> This property accepts a<code class="literal"> UIImageView</code>. We can use it to display an image in a cell, on its left side.<a id="id454" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">AccessoryView:</code> This property accepts any instance of<code class="literal"> UIView</code>. Its position defaults to the right of the cell, in the place of the cell's<code class="literal"> Accessory</code>, which is located at the right side of the cell.<a id="id455" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Accessory:</code> This property accepts values of the type<code class="literal"> UITableViewCellAccessory</code>. It provides predefined views for the cell's accessory, such as a<code class="literal"> DetailDisclosureButton</code> or a<code class="literal"> Checkmark</code>.<a id="id456" class="indexterm"/></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec15"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li><li class="listitem" style="list-style-type: disc"><em>Editing data in a table</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Editing a table: deleting rows</h1></div></div></div><p>In this recipe, we will discuss how to delete rows from a<code class="literal"> UITableView</code>, with appropriate feedback to the user.<a id="id457" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec16"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> EditingTableDataApp</code>.<a id="id458" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec17"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a view controller to the project, and convert it to a<code class="literal"> UITableViewController</code> as described in the<em> Displaying data in a table</em> section in this chapter, and name it<code class="literal"> TableController</code>.</li><li class="listitem"> Add a<code class="literal"> UINavigationController</code> in the<code class="literal"> AppDelegate</code> class. Initialize it, setting the<code class="literal"> TableController</code> as its root controller:<a id="id459" class="indexterm"/><div><pre class="programlisting">TableController tableController;
UINavigationController navController;
//…
this.tableController = new TableController();
this.navController = new UINavigationController(this.tableController);
window.RootViewController = this.navController;
</pre></div></li><li class="listitem"> Back in MonoDevelop, add three fields in the TableController class:<code class="literal"> List&lt;string&gt; tableData, UIBarButtonItem buttonEdit</code>, and<code class="literal"> UIBarButtonItem buttonDone</code>. Override the class'<code class="literal"> ViewDidLoad</code> method, as follows:<div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.buttonEdit = new UIBarButtonItem ("Edit", UIBarButtonItemStyle.Bordered, this.ButtonEdit_Clicked);
this.buttonDone = new UIBarButtonItem (UIBarButtonSystemItem.Done, this.ButtonDone_Clicked);
this.NavigationItem.SetRightBarButtonItem (this.buttonEdit, false);
this.tableData = new List&lt;string&gt;() {"Music", "Videos", "Images" };
this.TableView.Source = new TableSource(this.tableData);
}
</pre></div></li><li class="listitem"> Create a proper table view source for the table, which accepts the<code class="literal"> tableData</code> generic<code class="literal"> List</code> as an argument in its constructor. Create the handler method<code class="literal"> ButtonEdit_Clicked</code>, and enter the following code in it:<a id="id460" class="indexterm"/><div><pre class="programlisting">this.TableView.SetEditing (true, true);
this.NavigationItem.SetRightBarButtonItem (this.buttonDone, true);
</pre></div></li><li class="listitem"> Create the handler method<code class="literal"> ButtonDone_Clicked</code>, and enter the following code in it:<a id="id461" class="indexterm"/><div><pre class="programlisting">this.TableView.SetEditing (false, true);
this.NavigationItem.SetRightBarButtonItem (this.buttonEdit, true);
</pre></div></li><li class="listitem"> Finally, override the<code class="literal"> CommitEditingStyle</code> method of the table source:<a id="id462" class="indexterm"/><div><pre class="programlisting">public override void CommitEditingStyle (UITableView tableView, UITableViewCellEditingStyle editingStyle, NSIndexPath indexPath){
int rowIndex = indexPath.Row;
if (editingStyle == UITableViewCellEditingStyle.Delete) {
this.tableData.RemoveAt (rowIndex);
tableView.DeleteRows (new NSIndexPath[] { indexPath }, UITableViewRowAnimation.Left);
}
}
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch05lvl2sec18"/>How it works...</h3></div></div></div><p>The first thing we do here is make use of the navigation bar to add buttons that will handle the table's edit mode. When the view loads, we set the edit button with the<code class="literal"> SetRightBarButtonItem</code> method:<a id="id463" class="indexterm"/>
</p><div><pre class="programlisting">this.NavigationItem.SetRightBarButtonItem (this.buttonEdit, false);
</pre></div><p>Inside the<code class="literal"> ButtonEdit_Clicked</code> method, we set the table to editing mode. Then, we change the button in the navigation bar so that the user can exit from editing:</p><div><pre class="programlisting">this.TableView.SetEditing (true, true);
this.NavigationItem.SetRightBarButtonItem (this.buttonDone, true);
</pre></div><p>The<code class="literal"> SetEditing</code> method enables or disables the table's editing mode. When a table view is in editing mode, a round red icon with the minus (-) symbol appears on the left side of each cell. When the user taps the icon, a confirmation red<strong> Delete</strong> button appears in the cell. To actually delete the row when the user confirms deletion by tapping on the<strong> Delete</strong> button, we must implement the<code class="literal"> CommitEditingStyle</code> method in the table source:<a id="id464" class="indexterm"/>
</p><div><pre class="programlisting">if (editingStyle == UITableViewCellEditingStyle.Delete){
this.tableData.RemoveAt (rowIndex);
tableView.DeleteRows (new NSIndexPath[] { indexPath }, UITableViewRowAnimation.Left);
}
</pre></div><p>The first thing we need to do is check if the method was called as a result of the user tapping the<code class="literal"> Delete</code> button. This is done by checking the<code class="literal"> editingStyle</code> parameter, highlighted in this code. Then, we delete the data of the row from the data source and the row from the table with the<code class="literal"> DeleteRows</code> method.<a id="id465" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl2sec19"/>There's more...</h3></div></div></div><p>The table view provides another, more direct way to the user for deleting rows. This can be accomplished by swiping the finger on the cell we want to delete. In this case, only the<strong> Delete</strong> button is shown. We still need to implement the<code class="literal"> CommitEditingStyle</code> method in the table source to actually remove the row from the table.</p><p>The fact that a navigation controller was used in this recipe doesn't mean it is the only way to accomplish the function of deleting rows. It is, however, a combination of view controllers that will be used most of the time, in real-world application scenarios.</p><div><div><div><div><h4 class="title"><a id="ch05lvl3sec05"/>Row removal animations</h4></div></div></div><p>The<code class="literal"> UITableViewRowAnimation</code> enumeration used in the<code class="literal"> DeleteRows</code> method represents the type of animation a row will be removed by. It contains various values (Left,<code class="literal"> Right, Middle, Fade, Top, Bottom</code>, and<code class="literal"> None)</code> for animating the row. Note that to accomplish the best result, the type of animation should be used according to the position of the row in the data source. For example, if the row to be removed is the last one on the table, it is best to use<code class="literal"> UITableViewRowAnimation.Bottom</code> so that the row that should be removed will move downwards. If the row to be removed is the first one in the data source, it is best to use<code class="literal"> UITableViewRowAnimation.Top</code> so the row that should be removed will move upwards. The rest of the options are more suitable for the intermediate rows, between the first and last.<a id="id466" class="indexterm"/>
</p></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl2sec20"/>See also</h3></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li><li class="listitem" style="list-style-type: disc"><em>Editing a table: Inserting rows</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch03.html" title="Chapter 3. User Interface: View Controllers">Chapter 3</a>, User Interface: View Controllers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Navigating through different view controllers</em></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Editing a table: inserting rows</h1></div></div></div><p>In this recipe, we will learn how to provide the user with the ability to insert rows in a<code class="literal"> UITableView</code>.<a id="id467" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec21"/>Getting ready</h2></div></div></div><p>For this task, we will use the project<code class="literal"> EditingTableDataApp</code> from the previous task. Open it in MonoDevelop.<a id="id468" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec22"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add another<code class="literal"> UIBarButtonItem</code> field in the<code class="literal"> TableController</code> class, and initialize it in the<code class="literal"> ViewDidLoad</code> method:<a id="id469" class="indexterm"/><div><pre class="programlisting">this.buttonAdd = new UIBarButtonItem (UIBarButtonSystemItem.Add, this.ButtonAdd_Clicked);
</pre></div></li><li class="listitem"> Add the handler method<code class="literal"> ButtonAdd_Clicked:</code><div><pre class="programlisting">private void ButtonAdd_Clicked (object sender, EventArgs e){
this.tableData.Add ("Recordings");
this.TableView.ReloadData ();
}
</pre></div></li><li class="listitem"> In the<code class="literal"> ButtonEdit_Clicked</code> method, add the following line:<a id="id470" class="indexterm"/><div><pre class="programlisting">this.NavigationItem.SetLeftBarButtonItem (this.buttonAdd, true);
</pre></div></li><li class="listitem"> Also add the following line in the<code class="literal"> ButtonDone_Clicked</code> method:<a id="id471" class="indexterm"/><div><pre class="programlisting">this.NavigationItem.SetLeftBarButtonItem (null, true);
</pre></div></li><li class="listitem"> Compile and run the app on the simulator.</li><li class="listitem"> Tap the<strong> Edit</strong> button, and see the add button appear on the leftside in the navigation bar. Tap it and see the new row is added to the table.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec23"/>How it works...</h2></div></div></div><p>A system-default<strong> Add</strong> button is used here. When the user taps on the button, a new row is added in the table. The button is added in the edit button's<code class="literal"> Clicked</code> handler as the left button in the navigation bar. To remove it, we call the same method, passing as the<code class="literal"> UIBarButtonItem</code> parameter, which is a<code class="literal"> null</code> value inside the<code class="literal"> ButtonDone_Clicked</code> method:<a id="id472" class="indexterm"/>
</p><div><pre class="programlisting">this.NavigationItem.SetLeftBarButtonItem (this.buttonAdd, true);
this.NavigationItem.SetLeftBarButtonItem (null, true);
</pre></div><p>This way, when the user disables the editing mode, the<code class="literal"> add</code> button will disappear. Next, all we need to do to add a row is add the data to the data source and force the table to reload, which is done as follows:</p><div><pre class="programlisting">this.tableData.Add ("Recordings");
this.TableView.ReloadData ();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec24"/>There's more...</h2></div></div></div><p>This is the simplest way of inserting rows in a table. It is not the most efficient though. Calling the<code class="literal"> UITableView.ReloadData</code> method causes the<code class="literal"> UITableView</code> to reload everything, which will degrade performance if the table contains a large number of rows. To avoid this, you can replace the<code class="literal"> ReloadData</code> call in this example with the following line:<a id="id473" class="indexterm"/>
</p><div><pre class="programlisting">this.TableView.InsertRows (new NSIndexPath[] { NSIndexPath.FromRowSection(this.tableData.Count - 1, 0) }, UITableViewRowAnimation.Right);
</pre></div><p>The<code class="literal"> InsertRows</code> method causes the table view to reload only the part of its contents that are needed, in this case the last item in the data source. Note that with this method, we can also specify in which section of the table the cell will be inserted.<a id="id474" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec06"/>Row re-ordering</h3></div></div></div><p>Another useful feature of the<code class="literal"> UITableView</code> class is that of re-ordering rows. To demonstrate this, add the following method overrides in the table source:<a id="id475" class="indexterm"/>
</p><div><pre class="programlisting">public override bool CanMoveRow (UITableView tableView, NSIndexPath indexPath){
return true;
}
public override void MoveRow (UITableView tableView, NSIndexPath sourceIndexPath, NSIndexPath destinationIndexPath){
string itemToMove = this.tableData[sourceIndexPath.Row];
this.tableData.Remove (itemToMove);
this.tableData.Insert (destinationIndexPath.Row, itemToMove);
}
</pre></div><p>Returning<code class="literal"> true</code> in the<code class="literal"> CanMoveRow</code> method enables re-ordering for all cells. This is indicated by a grip appearance icon displaying on the right side in each cell. When the user touches and drags the icon, the cell can be moved to another position. Inside the<code class="literal"> MoveRow</code> method is where the actual re-ordering occurs. The only thing that needs to be done is to remove and re-insert the item in the data source in the desired index, using the<code class="literal"> sourceIndexPath</code> and<code class="literal"> destinationIndexPath</code> parameters.<a id="id476" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec25"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li><li class="listitem" style="list-style-type: disc"><em>Editing a table: deleting rows</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Table indexing</h1></div></div></div><p>In this recipe, we will learn how to provide an index in a table, allowing the user to browse through the rows of a<code class="literal"> UITableView</code> quicker.<a id="id477" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec26"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> TableIndexApp</code>. Add a<code class="literal"> UITableViewController</code> as shown in the previous tasks in this chapter, and implement the<code class="literal"> TableSource</code> class.<a id="id478" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>How to do it...</h2></div></div></div><p>In the table source class, override and implement the following methods:</p><div><pre class="programlisting">public override int NumberOfSections (UITableView tableView){
return this.tableData.Count;
}
public override string TitleForHeader (UITableView tableView, int section){
return Convert.ToString (this.tableData[section][0]);
}
public override string[] SectionIndexTitles (UITableView tableView){
return this.tableData.Select (s =&gt; Convert.ToString (s[0])).Distinct ().ToArray ();
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>How it works...</h2></div></div></div><p>The table source created in this task contains many different sections. For simplicity, each section contains one row. The<code class="literal"> NumberOfSections</code> method returns the total number of sections the table will display.<a id="id479" class="indexterm"/>
</p><p>To set a title for each section, we must override the<code class="literal"> TitleForHeader</code> method:<a id="id480" class="indexterm"/>
</p><div><pre class="programlisting">public override string TitleForHeader (UITableView tableView, int section){
return Convert.ToString (this.tableData[section][0]);
}
</pre></div><p>This implementation returns the first letter of each string in the data source. To provide the index, we override the<code class="literal"> SectionIndexTitles</code> method:<a id="id481" class="indexterm"/>
</p><div><pre class="programlisting">public override string[] SectionIndexTitles (UITableView tableView){
return this.tableData.Select (s =&gt; Convert.ToString (s[0])).Distinct ().ToArray ();
}
</pre></div><p>Here, it returns the first letter of each item in the data source. The result of this project will be similar to the following:</p><div><img src="img/1468EXP_05_03.jpg" alt="How it works..."/></div><p>When the user touches somewhere on the index, the table view will automatically scroll to that specific section.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec29"/>There's more...</h2></div></div></div><p>Indexing should be applied on tables with a<code class="literal"> Plain</code> style. Applying an index in tables with a<code class="literal"> Grouped</code> style set is not advisable, because the index will not be easily distinguished.<a id="id482" class="indexterm"/>
</p><p>A good example of a native iOS application with an index on a table can be found in the native<code class="literal"> Contacts</code> application.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec30"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li><li class="listitem" style="list-style-type: disc"><em>Searching through the data</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec08"/>Searching through the data</h1></div></div></div><p>In this recipe, we will learn how to provide search functionality for the content in a table view.<a id="id483" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec31"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> SearchTableApp</code>. Add a<code class="literal"> UITableViewController</code>, and name it<code class="literal"> TableController</code>.<a id="id484" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> TableController.xib</code> file in Interface Builder.</li><li class="listitem"> Add a<strong> Search Bar</strong> and<strong> Search Display Controller</strong> in the<code class="literal"> UITableView</code>. Note that after this action, some outlets are created and connected automatically. We need most of them, so we leave them as they are and save the document.<a id="id485" class="indexterm"/></li><li class="listitem"> Back in MonoDevelop, implement a class that will act as a delegate object for the search display controller:<div><pre class="programlisting">private class SearchDelegate : UISearchDisplayDelegate{
public SearchDelegate (TableController controller){
this.parentController = controller;
}
private TableController parentController;
public override bool ShouldReloadForSearchString ( UISearchDisplayController controller, string forSearchString){
this.parentController.filterDataList = this.parentController.tableData
.Where (s =&gt; s.ToLower ().Contains (forSearchString.ToLower ()))
.ToList ();
this.parentController.filterDataList.Sort (delegate (string firstStr, string secondStr) {
return firstStr.CompareTo (secondStr);
});
return true;
}
}
</pre></div></li><li class="listitem"> Override the<code class="literal"> ViewDidLoad</code> method and assign the source and delegate objects in it:<div><pre class="programlisting">this.TableView.Source = new TableSource (this);
this.SearchDisplayController.SearchResultsSource = new TableSource(this);
this.SearchDisplayController.Delegate = new SearchDelegate(this);
</pre></div></li><li class="listitem"> You can find the complete code in the<code class="literal"> SearchTableApp</code> project. The result will be the common iOS search bar above the table, similar to the following screenshot:<a id="id486" class="indexterm"/></li></ol></div><div><img src="img/1468EXP_05_04.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>How it works...</h2></div></div></div><p>The<code class="literal"> UISearchDisplayController</code> class provides a convenient way of search through data. It contains a<code class="literal"> UISearchBar</code> that accepts input from the user and a<code class="literal"> UITableView</code> that is used to display the results. After we add a search controller in a view controller, we can access it through that controller's<code class="literal"> SearchDisplayController</code> property. To trigger the results table, we must implement a<code class="literal"> UISearchDisplayDelegate</code> and override its<code class="literal"> ShouldReloadForSearchString</code>, which returns a boolean value:<a id="id487" class="indexterm"/>
</p><div><pre class="programlisting">private class SearchDelegate : UISearchDisplayDelegate
</pre></div><p>Inside the<code class="literal"> ShouldReloadForSearchString</code> method override, we search our data source saving the filtered results in a new data source, according to its<code class="literal"> forSearchString</code> parameter:<a id="id488" class="indexterm"/>
</p><div><pre class="programlisting">this.parentController.filterDataList = this.parentController.tableData
.Where (s =&gt; s.ToLower ().Contains (forSearchString.ToLower ()))
.ToList ();
</pre></div><p>We then sort the results alphabetically and return<code class="literal"> true</code>, so that the search controller's table will reload its data:</p><div><pre class="programlisting">this.parentController.filterDataList.Sort (delegate( string firstStr, string secondStr) {
return firstStr.CompareTo (secondStr);
});
return true;
</pre></div><p>The search controller's table view also needs a source object. In this example, we set it to the same object that we created for our table:</p><div><pre class="programlisting">this.TableView.Source = new TableSource (this);
this.SearchDisplayController.SearchResultsSource = new TableSource(this);
</pre></div><p>Since we are using instances of the same object, we need to modify some things in it to display data according to which table calls it. So, for example, the<code class="literal"> RowsInSection</code> method looks like the following:<a id="id489" class="indexterm"/>
</p><div><pre class="programlisting">public override int RowsInSection (UITableView tableview, int section){
if (tableview.Equals (this.parentController.TableView)){
return this.parentController.tableData.Count;
} else{
return this.parentController.filterDataList.Count;
}
}
</pre></div><p>This way, we return the number of rows according to which table calls the method. Similarly, we need to set each cell's text label inside the<code class="literal"> GetCell</code> method:<a id="id490" class="indexterm"/>
</p><div><pre class="programlisting">if (tableView.Equals (this.parentController.TableView)){
cell.TextLabel.Text = this.parentController.tableData[rowIndex];
} else{
cell.TextLabel.Text = this.parentController.filterDataList[rowIndex];
}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec34"/>There's more...</h2></div></div></div><p>When the user taps on the search bar, the keyboard appears, setting the search controller active. To de-activate it, we can hook on the search bar's<code class="literal"> SearchButtonClicked</code> event. This event will get triggered when the user taps on the keyboard's<strong> Search</strong> button:<a id="id491" class="indexterm"/>
</p><div><pre class="programlisting">this.SearchDisplayController.SearchBar.SearchButtonClicked += delegate {
this.SearchDisplayController.SetActive(false, true);
};
</pre></div><p>The<code class="literal"> SetActive</code> method is what we can use to enable or disable the search controller.<a id="id492" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec07"/>Providing search functionality to other controllers.</h3></div></div></div><p>Although this example uses a<code class="literal"> UISearchDisplayController</code> in a<code class="literal"> UITableViewController</code>, it does not mean that it is the only way it can be used. We can use a search controller with whatever kind of<code class="literal"> UIViewController</code> we want. The only extra thing we need to do in this case is set the search controller's<code class="literal"> SearchContentsController</code> property to the view controller it belongs to. This is being taken care of automatically by Interface Builder when we add a<code class="literal"> UISearchDisplayController</code> in a<code class="literal"> UITableViewController</code>, but not with other controllers.<a id="id493" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec35"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying data in a table</em></li><li class="listitem" style="list-style-type: disc"><em>Table indexing</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec09"/>Creating a simple web browser</h1></div></div></div><p>In this recipe, we will discuss displaying online content with the<code class="literal"> UIWebView</code> class.<a id="id494" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> WebBrowserApp</code>.<a id="id495" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec37"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> MainController.xib</code> file in Interface Builder, and add a<code class="literal"> UIWebView</code> object on the main View.</li><li class="listitem"> Create and connect an outlet for it with the name<code class="literal"> webView</code>.</li><li class="listitem"> Save the document.</li><li class="listitem"> Override the<code class="literal"> ViewDidAppear</code> method in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">public override void ViewDidAppear (bool animated){
NSUrl url = new NSUrl ("http://software.tavlikos.com");
NSUrlRequest urlRequest = new NSUrlRequest (url);
this.webView.LoadRequest (urlRequest);
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. Watch the website load on the screen!</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec38"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIWebView</code> class is iOS SDK's web browser control. To load web content, we just have to call its<code class="literal"> LoadRequest</code> method, which accepts a parameter of the type<code class="literal"> NSUrlRequest</code>. The<code class="literal"> NSUrlRequest</code> object contains the URL we want it to load:<a id="id496" class="indexterm"/>
</p><div><pre class="programlisting">NSUrl url = new NSUrl ("http://software.tavlikos.com");
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec39"/>There's more...</h2></div></div></div><p>The<code class="literal"> UIWebView</code> class contains some very useful events:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LoadStarted:</code> It is triggered when the control has started loading content<a id="id497" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">LoadFinished:</code> It is triggered when the content has finished loading successfully<a id="id498" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">LoadError:</code> It is triggered when loading of the content has failed<a id="id499" class="indexterm"/></li></ul></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec08"/>Scaling content</h3></div></div></div><p>Another important feature of the<code class="literal"> UIWebView</code> is the automatic scaling of content. It can be activated by setting its<code class="literal"> ScalePageToFit</code> property to<code class="literal"> true</code>.<a id="id500" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec40"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying local content</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying formatted text</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying documents</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec10"/>Displaying local content</h1></div></div></div><p>In this recipe, we will discuss displaying local HTML files.<a id="id501" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> LocalContentApp</code>.<a id="id502" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a<code class="literal"> UIWebView</code> on the main view of<code class="literal"> MainController</code>, and save the document.</li><li class="listitem"> Add a new folder to the project, and name it<code class="literal"> html_content.</code><a id="id503" class="indexterm"/></li><li class="listitem"> Add your content to that folder through MonoDevelop. Don't forget to set each file's<strong> Build Action</strong> to<strong> Content</strong>.</li><li class="listitem"> Override the<code class="literal"> ViewDidAppear</code> method in the<code class="literal"> MainController</code> class, and enter the following code:<div><pre class="programlisting">NSUrl fileUrl = NSUrl.FromFilename ( "./html_content/T-Shirts.html");
NSUrlRequest urlRequest = new NSUrlRequest (fileUrl);
this.webView.ScalesPageToFit = false;
this.webView.LoadRequest (urlRequest);
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> View your HTML content displayed on the screen.</li><li class="listitem"> Zoom in to view the content larger, just like you would do for online content.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>How it works...</h2></div></div></div><p>The process of displaying local content is the same as displaying online content. The<code class="literal"> NSUrl</code> class has a static method that creates an instance, based on a file path:<a id="id504" class="indexterm"/>
</p><div><pre class="programlisting">NSUrl fileUrl = NSUrl.FromFilename ("./html_content/T-Shirts.html");
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>There's more...</h2></div></div></div><p>The<code class="literal"> UIWebView</code> is a very powerful control. It can be used to display everything the Safari browser on iOS can. This includes HTML, plain text, images, and PDF documents.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Navigating through content</h3></div></div></div><p>You can also navigate through the history of<code class="literal"> UIWebView</code> with its<code class="literal"> GoBack()</code> and<code class="literal"> GoForward()</code> methods.<a id="id505" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec10"/>UIWebView supported files</h3></div></div></div><p>The<code class="literal"> UIWebView</code> control can be used to display other types of files as well. These file types are:<a id="id506" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Excel (.xls)</strong> <a id="id507" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Keynote (.key.zip)</strong> <a id="id508" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Numbers (.numbers.zip)</strong> <a id="id509" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Pages (.pages.zip)</strong> <a id="id510" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>PDF (.pdf)</strong> <a id="id511" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>PowerPoint (.ppt)</strong> <a id="id512" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Word (.doc)</strong> <a id="id513" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Rich Text Format</strong> (.rtf)<a id="id514" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Rich Text Format Directory (.rtfd.zip)</strong> <a id="id515" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Keynote '09 (.key)</strong> <a id="id516" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Numbers '09 (.numbers)</strong> <a id="id517" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><strong>Pages '09  (.pages) </strong><a id="id518" class="indexterm"/></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a simple web browser</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying documents</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec11"/>Displaying formatted text</h1></div></div></div><p>In this chapter, we will learn how to use the<code class="literal"> UIWebView</code> class to display formatted text.<a id="id519" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Getting ready</h2></div></div></div><p>In this task, we will work on the<code class="literal"> LocalContentApp</code> project discussed previously. Open it in MonoDevelop.<a id="id520" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec47"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Comment out the previous code in the<code class="literal"> ViewDidAppear</code> method, and add the following:<div><pre class="programlisting">string htmlString = "&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;span style=\"font-weight: bold;\"&gt;This&lt;/span&gt; " + "&lt;span style=\"text-decoration: underline;\"&gt;is&lt;/span&gt; &lt;span style=\"font-style: italic;\"&gt;some formatted&lt;/span&gt; " +" &lt;span style=\"font-weight: bold; text-decoration: underline;\"&gt;text!&lt;/span&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;";
this.webView.LoadHtmlString (htmlString, null);
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Watch how the HTML string is displayed.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec48"/>How it works...</h2></div></div></div><p>As discussed in<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views"> Chapter 2</a>,<em> User Interface: Views</em>, the<code class="literal"> UITextView</code> can be used to display large blocks of text and edit it, but it cannot display formatted text. The<code class="literal"> UIWebView</code> can do this by passing our HTML-formatted text as a parameter to the<code class="literal"> LoadHtmlString</code> method:<a id="id521" class="indexterm"/>
</p><div><pre class="programlisting">this.webView.LoadHtmlString (htmlString, null);
</pre></div><p>The second parameter is of the type<code class="literal"> NSUrl</code>. Since we have created our HTML string in-code and there are no external references to other files, we don't need it, and so we just pass<code class="literal"> null</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec49"/>There's more...</h2></div></div></div><p>If we would like to reference external files inside our HTML string, we should set the<code class="literal"> NSUrl</code> parameter of<code class="literal"> LoadHtmlString</code> to the path that contains the files, thus setting the base directory for the HTML. For example, consider the following HTML string, which references a file inside the<code class="literal"> html_content</code> folder of the application bundle:</p><div><pre class="programlisting">string htmlString = "&lt;img style=\"width: 215px;\" src=\"tshirts_s.jpg\"&gt;";
</pre></div><p>If we were to pass it to the<code class="literal"> LoadHtmlString</code> to display the image, we should have also set the<code class="literal"> baseUrl</code> parameter:</p><div><pre class="programlisting">this.webView.LoadHtmlString (htmlString, new NSUrl ( "./html_content", true));
</pre></div><p>The<code class="literal"> bool</code> parameter of the<code class="literal"> NSUrl</code> constructor indicates that the URL string of the first parameter is a path to a directory and should be treated like one.</p><div><h3 class="title"><a id="note31"/>Note</h3><p>Although the<code class="literal"> UIWebView</code> can display a wide variety of content, it cannot be used to edit it.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec11"/>Allowing specific links</h3></div></div></div><p>The<code class="literal"> UIWebView</code> also provides control on how links that the user taps on be treated. To do this, we can assign a handler to its<code class="literal"> ShouldStartLoad</code> property. It accepts delegates of the type<code class="literal"> UIWebLoaderControl</code>.<a id="id522" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec50"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a simple web browser</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying local content</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>,User Interface: Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying and editing text</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec12"/>Displaying documents</h1></div></div></div><p>In this recipe, we will discuss how to easily display various documents of different formats with the<code class="literal"> QLPreviewController</code> class.<a id="id523" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> DocumentPreviewApp</code>. Add a view with controller, and name it<code class="literal"> MainController</code>.<a id="id524" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec52"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> MainController.xib</code> file in Interface Builder and add a<code class="literal"> UIButton</code>.</li><li class="listitem"> Save the document.</li><li class="listitem"> Add a folder named<code class="literal"> docs</code> to the project and put some document files in it. The project<code class="literal"> DocumentPreviewApp</code> contains three different documents: a<code class="literal"> PDF</code>, a<code class="literal"> DOCX</code>, and an<code class="literal"> XLSX</code>.</li><li class="listitem"> Enter the following<code class="literal"> using</code> directive in the<code class="literal"> MainController.cs</code> file:<div><pre class="programlisting">using MonoTouch.QuickLook;
</pre></div></li><li class="listitem"> Create the following nested class inside the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private class PreviewDataSource : QLPreviewControllerDataSource{
public PreviewDataSource (List&lt;PreviewItem&gt; items){
this.previewItems = items;
}
private List&lt;PreviewItem&gt; previewItems;
public override int PreviewItemCount ( QLPreviewController controller){
return this.previewItems.Count;
}
public override QLPreviewItem GetPreviewItem ( QLPreviewController controller, int index){
return this.previewItems[index];
}
}
</pre></div></li><li class="listitem"> Enter the following code in the<code class="literal"> ViewDidLoad</code> override of the<code class="literal"> MainController:</code><a id="id525" class="indexterm"/><div><pre class="programlisting">this.previewItems = new List&lt;PreviewItem&gt;() {
new PreviewItem("PDF", NSUrl.FromFilename("docs/pdfdoc.pdf")),
new PreviewItem("DOCX", NSUrl.FromFilename("docs/text.docx")),
new PreviewItem("XLSX", NSUrl.FromFilename("docs/spreadsheet.xlsx"))
};
this.previewController = new QLPreviewController();
this.previewController.DataSource = new PreviewDataSource(this.previewItems);
this.buttonPreviewDocs.TouchUpInside += delegate {
this.PresentModalViewController(this.previewController, true);
};
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec53"/>How it works...</h2></div></div></div><p>The<code class="literal"> QLPreviewController</code> class provides a very convenient way of displaying multiple document formats at once. It is a controller that can be displayed either by pushing it in a navigation controller stack, or by presenting it modally.<a id="id526" class="indexterm"/>
</p><p>To define the documents that we want it to display, we have to create a<code class="literal"> QLPreviewControllerDataSource</code> class and assign it to its<code class="literal"> DataSource</code> property:<a id="id527" class="indexterm"/>
</p><div><pre class="programlisting">private class PreviewDataSource : QLPreviewControllerDataSource
</pre></div><p>The<code class="literal"> QLPreviewControllerDataSource</code> contains two methods we need to override:<code class="literal"> PreviewItemCount</code>, which returns the number of items the controller has to display, and<code class="literal"> GetPreviewItem,</code> which returns the actual item. This item is of the type<code class="literal"> QLPreviewItem</code>, and we have to implement a method that inherits it:<a id="id528" class="indexterm"/>
</p><div><pre class="programlisting">private class PreviewItem : QLPreviewItem
</pre></div><p>In this class, we have to override two properties, both of which represent the information of the item to be previewed. These are<code class="literal"> ItemTitle</code> and<code class="literal"> ItemUrl</code>.<a id="id529" class="indexterm"/>
</p><p>When the controller calls the<code class="literal"> PreviewItemCount</code> method and it returns a number more than<code class="literal"> 1</code>, it adds a<code class="literal"> UIToolbar</code> with two arrow buttons that allows the user to navigate through the documents. When the<code class="literal"> GetPreviewItem</code> method is called, it sets the current title to its<code class="literal"> ItemTitle</code> property and loads the document according to the<code class="literal"> ItemUrl</code> property. If the button is tapped in this application, the result will be similar to the following:<a id="id530" class="indexterm"/>
</p><div><img src="img/1468EXP_05_05.jpg" alt="How it works..."/></div><p>This screenshot displays the<code class="literal"> QLPreviewController</code> after navigating to the last document that is a file of the type<code class="literal"> XLSX</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec54"/>There's more...</h2></div></div></div><p>The controller contains a system-default<strong> Done</strong> button on its navigation bar. If the button is tapped, the controller is automatically dismissed. We can hook on its<code class="literal"> WillDismiss</code> and/or<code class="literal"> DidDismiss</code> events to provide extra behavior.<a id="id531" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec55"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying local content</em></li><li class="listitem" style="list-style-type: disc"><em>Displaying formatted text</em></li></ul></div></div></div></body></html>