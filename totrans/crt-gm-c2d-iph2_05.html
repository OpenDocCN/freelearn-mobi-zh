<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Brick Breaking Balls with Box2D</h1></div></div></div><p>There is a lot you can do with cocos2d by itself. However, when you combine it with a true physics engine, such as Box2D or Chipmunk, you can do so much more. There is a steep learning curve, so this chapter will be both a new project and a basic primer on Box2D for the beginner.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Box2D basics</li><li class="listitem" style="list-style-type: disc">Building Box2D objects</li><li class="listitem" style="list-style-type: disc">Using mouse joints</li><li class="listitem" style="list-style-type: disc">Singleton classes</li><li class="listitem" style="list-style-type: disc">Separate HUD layer</li><li class="listitem" style="list-style-type: disc">Using plists to store level data</li><li class="listitem" style="list-style-type: disc">Changing game physics during play</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>The project is…</h1></div></div></div><p>In this chapter we will discuss the classic <a id="id897" class="indexterm"/>
<a id="id898" class="indexterm"/>brick breaking game. Dating back to the early days of Atari, this game is a wonderful way to start exploring physics engines, because there aren't too many objects moving at the same time. If you are not familiar with this game, it is fairly easy to explain. The player controls a paddle at the bottom of the screen that can move side-to-side. The top portion of the screen has a number of bricks in fixed positions. There is a small ball bouncing around, and the player's job is to break all of the bricks without letting the ball past the paddle. Of course, the ball bounces around everywhere, so there are actually quite a lot of physics-based calculations needed to make it work. </p><p>Let's take a look at the final game:</p><div><img src="img/9007_05_01.jpg" alt="The project is…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Box2D – a primer</h1></div></div></div><p>Before we can even begin to think about our project, we need to review the basics of Box2D. There is a lot of depth to the Box2D engine, and we <a id="id899" class="indexterm"/>
<a id="id900" class="indexterm"/>will only be scratching the surface in this book. This section aims to give an overview of the parts of the engine that we will need to interact with for this game.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Box2D – what is it?</h2></div></div></div><p>To quote the manual, "Box2D is a 2D rigid body simulation library for games. Programmers can use it in their games to make objects move in believable ways and make the game world more interactive." That's a pretty <a id="id901" class="indexterm"/>straightforward description of what Box2D is, except for the "rigid body" term. What does that mean? Rigid body means that Box2D <a id="id902" class="indexterm"/>is built to simulate hard objects such as balls, walls, stone, metal, and so on. Box2D was not built to simulate "soft body" objects such as pillows, jelly, and so on.</p><p>We will briefly go through the basic terms of the Box2D environment here, and we will deal with everything in more detail when we build the game. The official documentation for Box2D is <a id="id903" class="indexterm"/>available at: <a class="ulink" href="http://box2d.org/documentation.html">http://box2d.org/documentation.html</a>
</p><p>One important aspect of Box2D to be pointed out here is that it is written in C++, so there is a little bit of a language translation aspect when using Box2D with a game written primarily in Objective-C. For the most part, the two play together nicely, but you will have to gain some familiarity with C++ notation to make sense out of the Box2D-specific code. (If the C++ notation looks alien to you, we would advise consulting your favorite search engine to learn the basics of C++.)</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Basic parts of Box2D</h3></div></div></div><p>The widest-reaching component of the Box2D environment is called a <a id="id904" class="indexterm"/>
<strong>world</strong>. <a id="id905" class="indexterm"/>All objects created in Box2D will be contained in the world. <a id="id906" class="indexterm"/>
<a id="id907" class="indexterm"/>This is where all movement, collisions, and so on take place. The world is also where we set the gravity of the environment. Normally, a given simulation will have only one Box2D world.</p><p>The next object that we have is called a <a id="id908" class="indexterm"/>
<strong>body</strong>. A body represents a thing of some sort in the world. <a id="id909" class="indexterm"/>The body controls the position of the object, as well as other attributes necessary for the simulation, such as the body type. The body type lets you identify whether it is a static (non-moving) or dynamic (movable) body. A body does not directly "know" how big it is, how dense it is, and so on.</p><p>A <a id="id910" class="indexterm"/>
<a id="id911" class="indexterm"/>
<strong>shape</strong> describes the geometry of the object. There are several different types of shapes supported by Box2D. The most commonly used are the circle shape, the polygon shape, and the edge shape. For a complete list of supported shapes, please refer to the Box2D documentation.</p><p>A <a id="id912" class="indexterm"/>
<a id="id913" class="indexterm"/>
<strong>fixture</strong> can be thought of as the "glue" between the shape and the body. However, it is more than that. A fixture also defines core attributes of the object, such as density, friction, and restitution (aka bounciness).</p><p>Box2D supports a wide variety of <a id="id914" class="indexterm"/>
<strong>joints</strong> to connect bodies together. There are distance joints, pulley joints, <a id="id915" class="indexterm"/>revolute joints, and so on. The only joints we will be concerned with in this game are the mouse joint and the prismatic joint, both used in the paddle controls.</p><p>As you might imagine, there is also a collision handler. One of the core components we use is called a <a id="id916" class="indexterm"/>
<a id="id917" class="indexterm"/>
<strong>contact listener</strong>. This is a very complex piece of software, and the one that makes us dive into C++ the most. We will only scratch the surface with a basic collision handler in this game.</p><p>A very important value is the <a id="id918" class="indexterm"/>
<a id="id919" class="indexterm"/>
<code class="literal">PTM_RATIO</code>. This is the Points-To-Meters Ratio. Internally, Box2D represents everything as meters. The default value for this ratio is 32, which represents 32 points as 1 meter in the simulation world. For most games, this will work perfectly. In our code, we will have to apply this <code class="literal">PTM_RATIO</code> to many calculations when we are converting locations between the cocos2D layer and the Box2D world.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>On to the game!</h1></div></div></div><p>We start our game from the Cocos2D + Box2D template, so it has all the libraries we need. To prepare for this project, we still go through the same motions from the template, namely removing <code class="literal">HelloWorldLayer.h/.mm</code>, and changing the references in the <code class="literal">IntroLayer.mm</code> to our menu class. There are a couple of additional classes in the template, <code class="literal">GLES-Render</code> and <code class="literal">PhysicsSprite</code>. We will deal with them later. We also need to switch the supported orientation to portrait only, as we did in the previous chapter. (Don't forget to also remove the background rotation line in the <code class="literal">IntroLayer.mm</code> file.)</p><p>With a Box2D project, it is important to note that all our implementation classes will need names that end in <code class="literal">.mm</code> instead of <code class="literal">.m</code>. This tells the compiler that we will be using a mixture of Objective-C and C++. You must do this with Box2D, because Box2D is written in C++. So where do we start?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec51"/>World building</h2></div></div></div><p>We will start with building the <a id="id920" class="indexterm"/>
<a id="id921" class="indexterm"/>Box2D <a id="id922" class="indexterm"/>world itself.</p><p>
<strong>Filename:</strong> <a id="id923" class="indexterm"/>
<a id="id924" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) setupWorld {
    // Define the gravity vector.
    b2Vec2 gravity;
    gravity.Set(0.0f, 0.0f);
    
    // Construct a world object
    world = new b2World(gravity);

    world-&gt;SetAllowSleeping(true);
    world-&gt;SetContinuousPhysics(true);

    // Create contact listener
    contactListener = new BRContactListener();
    world-&gt;SetContactListener(contactListener);
}</pre></div><p>As you can see, the world is pretty easy to set up. Here we are defining <code class="literal">gravity</code> as zero, as we don't want our ball to slow down and we don't want our bricks falling off the screen. We then set up the world, which is assigned to a variable called <code class="literal">world</code>, which is a <code class="literal">b2World</code> variable type<a id="id925" class="indexterm"/>
<a id="id926" class="indexterm"/>. When you set up the <code class="literal">b2World</code>, you define the gravity for the world. We will allow objects to sleep. Sleeping means that objects that are at rest will "sleep", so the simulation won't spend a lot of time calculating movements of a body at rest. However, if something else interacts with it (that is, runs into it), the body will wake up immediately and react appropriately. We set the continuous physics to be <code class="literal">true</code>. This allows for a more accurate simulation, but requires more computing power. We also establish the contact listener we will use for this world. We won't get into the details here – we will save that for our discussion about the collision handler.</p><p>If you're confused by the C++ syntax here, it is helpful to know that the lines with the arrow (-&gt;) symbol are calling functions from the object to the left-hand <a id="id927" class="indexterm"/>
<a id="id928" class="indexterm"/>side of the arrow. So the line <code class="literal">world-&gt;SetContactListener(contactListener);</code> would look like <code class="literal">[world setContactListener:contactListener];</code>, if Box2D was written in Objective-C.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Although there are some wrappers that allow you to use Box2D with Objective-C syntax, as of this writing none of the projects are mature enough to be recommended here.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec52"/>On the edge</h2></div></div></div><p>Now that we have a world, we can start defining "stuff" to go in our world. <a id="id929" class="indexterm"/>
<a id="id930" class="indexterm"/>Let's start with some edges for the screen:</p><p>
<strong>Filename:</strong> <a id="id931" class="indexterm"/>
<a id="id932" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildEdges {
    // Define the wall body
    b2BodyDef wallBodyDef;
    wallBodyDef.position.Set(0, 0);
    
    // Create a body for the walls
    wallBody = world-&gt;CreateBody(&amp;wallBodyDef);
    
    // This defines where the bottom edge of the HUD is
    float maxY = 424;
    
    // Define the 4 corners of the playfield
    b2Vec2 bl(0.0f, 0.0f); // bottom left corner
    b2Vec2 br(size.width/PTM_RATIO,0); // bottom right
    b2Vec2 tl(0,maxY/PTM_RATIO); // top left corner
    b2Vec2 tr(size.width/PTM_RATIO,maxY/PTM_RATIO); // top right
    
    b2EdgeShape bottomEdge;
    b2EdgeShape leftEdge;
    b2EdgeShape rightEdge;
    b2EdgeShape topEdge;
    
    // Set the edges
    bottomEdge.Set(bl, br);
    leftEdge.Set(bl, tl);
    rightEdge.Set(br, tr);
    topEdge.Set(tl, tr);

    // Define the fixtures for the walls
    wallBody-&gt;CreateFixture(&amp;topEdge,0);
    wallBody-&gt;CreateFixture(&amp;leftEdge,0);
    wallBody-&gt;CreateFixture(&amp;rightEdge,0);

    // Keep a reference to the bottom wall
    bottomGutter = wallBody-&gt;CreateFixture(&amp;bottomEdge,0);
}</pre></div><p>We've written quite a bit of new code here, so let's break it down. First we defined a new body definition (<code class="literal">b2BodyDef</code>), called <a id="id933" class="indexterm"/>
<a id="id934" class="indexterm"/>
<code class="literal">wallBodyDef</code>. It is an extremely basic body. We then tell the <code class="literal">world</code> to create a <code class="literal">body</code> using the <a id="id935" class="indexterm"/>
<a id="id936" class="indexterm"/>
<code class="literal">b2BodyDef</code> we just created, and we keep a reference to it. Our world now has one formless, shapeless body in it.</p><p>We fix the "shapeless" problem next. We begin by defining the positions for each of the four corners of our playing area, using a shorthand naming pattern (that is, bl = bottom left, br = bottom right, and so on). There are two important things we need to point out here. For all non-zero positions, we divide the "normal" screen position by the <code class="literal">PTM_RATIO</code>. This is the standard way we can convert the <a id="id937" class="indexterm"/>
<a id="id938" class="indexterm"/>
<code class="literal">ccp</code> value we normally would use into a Box2D-friendly coordinate. As you recall, PTM means Points-To-Meters, so 32 screen points equals 1 meter in the simulation world. Doing this conversion keeps our display and our Box2D simulation in sync. <a id="id939" class="indexterm"/>
<a id="id940" class="indexterm"/>You may also notice we are using the <code class="literal">maxY</code> value of <code class="literal">424</code>, rather than the top of the screen. Our game has a Heads-Up Display covering the top portion of the screen, and a <code class="literal">y</code> value of 424 places this top edge at the bottom of that display HUD. We really don't want our player losing their ball under the Heads-Up Display, do we?</p><p>We then create four <code class="literal">b2EdgeShape</code> <a id="id941" class="indexterm"/>
<a id="id942" class="indexterm"/>objects, for each side of the screen. We use our corner variables to define their positions, using the <a id="id943" class="indexterm"/>
<a id="id944" class="indexterm"/>
<code class="literal">Set</code> function. We then instruct the <code class="literal">wallBody</code> to create a fixture for each of these walls. You will notice that we set the variable <code class="literal">bottomGutter</code> to the returned value of the <a id="id945" class="indexterm"/>
<a id="id946" class="indexterm"/>
<code class="literal">CreateFixture</code> command. We will use this later in the collision handler to determine when the player lost his ball.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Having a ball</h2></div></div></div><p>So far we have a world with walls, but we don't <a id="id947" class="indexterm"/>have any moving parts yet. <a id="id948" class="indexterm"/>
<a id="id949" class="indexterm"/>Let's build a ball to bounce around:</p><p>
<strong>Filename:</strong> <a id="id950" class="indexterm"/>
<a id="id951" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildBallAtStartingPosition:(CGPoint)startPos
                 withInitialImpulse:(b2Vec2)impulse {
    // Create sprite and add it to layer
    PhysicsSprite *ball = [PhysicsSprite
                spriteWithSpriteFrameName:@"ball.png"];
    ball.position = startPos;
    ball.tag = kBall;
    [bricksheet addChild:ball z:50];
    
    // Create ball body
    b2BodyDef ballBodyDef;
    ballBodyDef.type = b2_dynamicBody;
    ballBodyDef.position.Set(startPos.x/PTM_RATIO, 
                             startPos.y/PTM_RATIO);
    ballBodyDef.userData = ball;
    b2Body *ballBody = world-&gt;CreateBody(&amp;ballBodyDef);
    
    // Link the body to the sprite
    [ball setPhysicsBody:ballBody];
    
    //Create a circle shape
    b2CircleShape circle;
    circle.m_radius = 7.0/PTM_RATIO;
    
    //Create fixture definition and add to body
    b2FixtureDef ballFixtureDef;
    ballFixtureDef.shape = &amp;circle;
    ballFixtureDef.density = 1.0f;
    ballFixtureDef.friction = 0.0f;
    ballFixtureDef.restitution = 1.0f;
    ballBody-&gt;CreateFixture(&amp;ballFixtureDef);
    ballBody-&gt;ApplyLinearImpulse(impulse,
                                 ballBody-&gt;GetPosition());
    isBallInPlay = YES;
}</pre></div><p>Building a dynamic object is a little more involved than building the edges, but the same basic concepts still apply. Because the ball will have a visible sprite associated with the body, we first build a <code class="literal">PhysicsSprite</code> object. <a id="id952" class="indexterm"/>
<a id="id953" class="indexterm"/>
<code class="literal">PhysicsSprite</code> is one of the classes in the cocos2d + Box2D template we used to create the project. It is a subclass of <code class="literal">CCSprite</code>, but includes a couple of extra methods that will automatically keep the sprite locked in position with the physics body connected to it. The only thing we need to do differently than a normal <code class="literal">CCSprite</code> is to call <a id="id954" class="indexterm"/>
<a id="id955" class="indexterm"/>
<code class="literal">setPhysicsBody</code> on it, which connects the Box2D body to the sprite. The end result is that we do not <a id="id956" class="indexterm"/>have to manually move (or rotate) <a id="id957" class="indexterm"/>the sprite. Without this "helper" class, we would be responsible for updating the position and rotation of the sprite ourselves.</p><p>You will also notice that we assign a <code class="literal">tag</code> value to the ball. This will be useful later, when we are dealing with collisions. (The <a id="id958" class="indexterm"/>
<a id="id959" class="indexterm"/>
<code class="literal">tag</code> definitions are contained in <code class="literal">typedef enum</code> in the <code class="literal">BRDefinitions.h</code> file.)</p><p>We then build a body for the ball. We assign it a type of <code class="literal">b2_dynamicBody</code>, to let Box2D know that this is a body that can move. We set the position of the body to correspond to the position of the sprite. A body is by default anchored in the middle, just like a <code class="literal">CCSprite</code>. We can use the same coordinates for the body (divided by the <code class="literal">PTM_RATIO</code>).</p><p>The <code class="literal">userData</code> is a flexible part of the body definition; <a id="id960" class="indexterm"/>
<a id="id961" class="indexterm"/>
<code class="literal">userData</code> can hold anything you want to store in it. <code class="literal">userData</code> is customarily used to hold a reference to the <code class="literal">CCSprite</code> object (or the <code class="literal">PhysicsSprite</code> object<a id="id962" class="indexterm"/>
<a id="id963" class="indexterm"/>, in our case) that represents the actor. Following this convention makes it a trivial matter to get to the sprite from the body.</p><p>After we instruct the world to create a body with this definition, we define a shape. Since we are using a round ball, the <a id="id964" class="indexterm"/>
<a id="id965" class="indexterm"/>
<code class="literal">b2CircleShape</code> is perfect. We define the shape's radius by taking the radius of the ball (half the sprite width) and dividing by the <code class="literal">PTM_RATIO</code>.</p><p>We then build the fixture to represent the "guts" that accompany the body. We assign the circle shape we just defined, and then we set the <code class="literal">density</code>, <code class="literal">friction</code>, and <code class="literal">restitution</code>. Density is used in the calculation of mass. The higher the density, the more massive the object is. Friction is used to control how the objects slide along each other. Friction is normally set between 0 and 1. Higher friction values will slow objects down as they slide against each other. We don't want any friction on the ball to keep it moving nicely. The final parameter here is <a id="id966" class="indexterm"/>
<a id="id967" class="indexterm"/>
<code class="literal">restitution</code>. </p><p>The term restitution is less familiar than the other two, but you can think of it as how bouncy the object is. A value of zero means the object will not bounce at all. A value of 1 means the <a id="id968" class="indexterm"/>
<a id="id969" class="indexterm"/>object is perfectly bouncy, and will not lose any of its velocity when it impacts another object. We don't want the ball to lose any velocity when it collides, so we use a value of 1 for the restitution of the ball.</p><p>After we define the fixture, we create it with the <code class="literal">ballBody</code>. As a final step, we add a linear impulse to the ball, based on the message passed to this method. An impulse is basically a kick, with the strength and direction of the impulse controlled by the <code class="literal">b2Vec2</code> parameter, here called <a id="id970" class="indexterm"/>
<a id="id971" class="indexterm"/>
<code class="literal">impulse</code>. The second argument <code class="literal">ballBody-&gt;GetPosition()</code> returns the center of the <code class="literal">ballBody</code>. This will apply the impulse to the center of the body, so we get a straight application of the impulse.</p><p>Now we need a <a id="id972" class="indexterm"/>
<a id="id973" class="indexterm"/>
<code class="literal">newBall</code> method that will <a id="id974" class="indexterm"/>always start the ball in the same position, and give it a decent impulse to set it in motion.</p><p>
<strong>Filename:</strong> <a id="id975" class="indexterm"/>
<a id="id976" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) newBall {
    [self buildBallAtStartingPosition:ccp(150,200)
                   withInitialImpulse:b2Vec2(0.2,-1.5)];
}</pre></div><p>As we see from the <a id="id977" class="indexterm"/>
<a id="id978" class="indexterm"/>
<code class="literal">newBall</code> method, we give the ball <a id="id979" class="indexterm"/>a very slight "kick" with the initial impulse, down and to the right.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>A <code class="literal">b2Vec2()</code> <a id="id980" class="indexterm"/>
<a id="id981" class="indexterm"/>is equivalent to a <code class="literal">ccp()</code>, and uses the same bottom-left origin point.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Setting everything in motion</h1></div></div></div><p>At this point we have a world, we have edges to hold everything in, and we have a ball. Now we need to get it all moving. As you might expect, we handle this in the <code class="literal">update</code> method.</p><p>
<strong>Filename:</strong> <a id="id982" class="indexterm"/>
<a id="id983" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void)update:(ccTime)dt {
    // Step the world forward
  world-&gt;Step(dt, 10, 10);
    
    // Iterate through all bodies in the world
    for(b2Body *b = world-&gt;GetBodyList(); b;b=b-&gt;GetNext()) {
    if (b-&gt;GetUserData() != NULL) {
            // Get the sprite for this body
      PhysicsSprite *sprite = 
(PhysicsSprite*)b-&gt;GetUserData();
  
            // Speed clamp for balls
            if (sprite.tag == kBall) {
        static int maxSpeed = 15;
                
        b2Vec2 velocity = b-&gt;GetLinearVelocity();
        float32 speed = velocity.Length();
        
        if (speed &gt; maxSpeed) {
          b-&gt;SetLinearDamping(0.5);
        } else if (speed &lt; maxSpeed) {
          b-&gt;SetLinearDamping(0.0);
        }
      }
    }
  }
}</pre></div><p>This is an abbreviated form of our final <code class="literal">update</code> method, with just the ball movement handling in place. We start by instructing the world to step forward in its simulation. The three parameters sent to the <a id="id984" class="indexterm"/>
<a id="id985" class="indexterm"/>
<code class="literal">Step</code> function are, in order, the <a id="id986" class="indexterm"/>
<a id="id987" class="indexterm"/>
<strong>time step</strong>, the <strong>velocity iterations</strong>
<a id="id988" class="indexterm"/>
<a id="id989" class="indexterm"/>, and the <a id="id990" class="indexterm"/>
<a id="id991" class="indexterm"/>
<strong>position iterations</strong>. In this game, we are using a variable time step (using the delta value <code class="literal">dt</code>), which works well in our case. More intensive and detailed simulations are better suited to use a fixed time step. (Point your favorite search engine to the topic to learn more about how to implement a fixed time step.) The velocity iterations and position iterations control how detailed the simulation is. A value of 10 for both iteration values is a good starting point for most projects. Higher values will result in more accuracy, but the trade-off is more of a processor load to calculate the simulation.</p><p>Now that we have made one step forward in time for the world, we evaluate all of the bodies in the world to determine what we should do with them. We iterate through the world's bodies with <code class="literal">world-&gt;GetBodyList()</code>, and advance to the next body with <code class="literal">b-&gt;GetNext()</code>. For each body we find, we evaluate whether or not it has a sprite attached by checking that <code class="literal">userData</code> is not null. When we find a body with a sprite, we get a sprite reference from that body's <code class="literal">userData</code>. (We already have the variable <code class="literal">b</code> to represent the body, from the <code class="literal">for</code> loop.)</p><p>Because the ball might pick up speed during the game, we put in a speed clamping check next. If the sprite is a ball, and the speed is over the set value of 15, the body has <a id="id992" class="indexterm"/>
<a id="id993" class="indexterm"/>
<strong>linear damping</strong> applied, which will affect the velocity of the ball on the next step of the simulation. Damping is essentially applying the brakes on the object. We use a value of 0.5, which will slow the ball down, but not stop it completely. This acts the same as tapping the brakes in a car, decreasing the forward velocity a little bit at a time.</p><p>You will notice that we don't actually move the ball sprite at all. Because we are using a <code class="literal">PhysicsSprite</code> <a id="id994" class="indexterm"/>
<a id="id995" class="indexterm"/>object instead of a <a id="id996" class="indexterm"/>
<a id="id997" class="indexterm"/>
<code class="literal">CCSprite</code> object, it will automatically take care of that for us.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Collision handling</h2></div></div></div><p>The code we have reviewed so far will make the ball bounce around the screen, but nothing interesting will happen when the ball hits the <a id="id998" class="indexterm"/>wall, except it will <a id="id999" class="indexterm"/>bounce around. What we need is to add a way to take some action when certain objects collide with others. We do this by implementing a contact listener. A contact listener has four components: <code class="literal">BeginContact</code>, <code class="literal">EndContact</code>, <code class="literal">PreSolve</code>, and <code class="literal">PostSolve</code>. Going into detail on each of these is beyond the scope of this book. For our project, we will only be implementing a simplified contact listener with code for <code class="literal">BeginContact</code> and <code class="literal">EndContact</code> only. Let's look at the header first:</p><p>
<strong>Filename:</strong> <a id="id1000" class="indexterm"/>
<a id="id1001" class="indexterm"/>
<code class="literal">BRContactListener.h</code>
</p><div><pre class="programlisting">#import "Box2D.h"
#import &lt;vector&gt;
#import &lt;algorithm&gt;

struct BRContact {
  b2Fixture *fixtureA;
  b2Fixture *fixtureB;
  bool operator ==(const BRContact&amp; other) const
  {
    return (fixtureA == other.fixtureA) &amp;&amp;
               (fixtureB == other.fixtureB);
  }
};

class BRContactListener : public b2ContactListener {

public:
  std::vector&lt;BRContact&gt;_contacts;
  
  BRContactListener();
  ~BRContactListener();
  
  virtual void BeginContact(b2Contact* contact);
  virtual void EndContact(b2Contact* contact);
  virtual void PreSolve(b2Contact* contact,
                        const b2Manifold* oldManifold);
  virtual void PostSolve(b2Contact* contact,
                        const b2ContactImpulse* impulse);
};</pre></div><p>Now we can look at the implementation file <a id="id1002" class="indexterm"/>for this class:</p><p>
<strong>Filename:</strong> <a id="id1003" class="indexterm"/>
<a id="id1004" class="indexterm"/>
<code class="literal">BRContactListener.mm</code>
</p><div><pre class="programlisting">#import "BRContactListener.h"

BRContactListener::BRContactListener() : _contacts() {
}

BRContactListener::~BRContactListener() {
}

void BRContactListener::BeginContact(b2Contact* contact) {
  // We need to copy the data because b2Contact is reused.
  BRContact brContact = { contact-&gt;GetFixtureA(),
                            contact-&gt;GetFixtureB() };
  _contacts.push_back(brContact);
}
  
void BRContactListener::EndContact(b2Contact* contact) {
  BRContact brContact = { contact-&gt;GetFixtureA(),
                            contact-&gt;GetFixtureB() };
  std::vector&lt;BRContact&gt;::iterator pos;
  pos = std::find(_contacts.begin(), _contacts.end(),
                    brContact);
  if (pos != _contacts.end()) {
    _contacts.erase(pos);
  }
}

void BRContactListener::PreSolve(b2Contact* contact,
                    const b2Manifold* oldManifold) {
}

void BRContactListener::PostSolve(b2Contact* contact,
                    const b2ContactImpulse* impulse) {
}</pre></div><p>This is the simplified contact listener published as part of a tutorial by <a id="id1005" class="indexterm"/>
<a id="id1006" class="indexterm"/>Ray Wenderlich (<a class="ulink" href="http://raywenderlich.com">http://raywenderlich.com</a>), so any credit for this approach belongs to Ray. The basic design of this contact listener is to get the fixtures that are in contact (that is, colliding), and copy them out to <code class="literal">_contacts</code>, so we can evaluate them in our <code class="literal">BRPlayfieldLayer</code> instead of here. This copying is done in the <a id="id1007" class="indexterm"/>
<a id="id1008" class="indexterm"/>
<code class="literal">BeginContact</code>. <a id="id1009" class="indexterm"/>
<a id="id1010" class="indexterm"/>
<code class="literal">EndContact</code> removes the contact from <code class="literal">_contacts</code>, so <a id="id1011" class="indexterm"/>that we are not evaluating outdated contacts.</p><p>One nice aspect of this approach is that the contact listener itself is general-purpose enough to be used as it is in many projects. If you are less experienced with C++, having boilerplate code like this is always helpful.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec55"/>Losing your ball</h2></div></div></div><p>At this point, we would expect our ball to be lost when it reaches the bottom edge of the screen. But instead, it will simply bounce off because <a id="id1012" class="indexterm"/>we have not defined any custom behavior for when the ball and the fixture at the bottom of the screen collide. If you recall, when we <a id="id1013" class="indexterm"/>defined the edges, we kept a variable, <code class="literal">bottomGutter</code>, for this purpose.</p><p>We will be handling our collisions in our <code class="literal">update</code> method, <a id="id1014" class="indexterm"/>directly after the <code class="literal">for</code> loop from earlier, where we controlled the ball's speed.</p><p>
<strong>Filename:</strong> <a id="id1015" class="indexterm"/>
<a id="id1016" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">  std::vector&lt;b2Body *&gt;toDestroy;
  std::vector&lt;BRContact&gt;::iterator pos;
  for (pos = contactListener-&gt;_contacts.begin();
      pos != contactListener-&gt;_contacts.end(); pos++) {
        BRContact contact = *pos;
    
        // Get the bodies involved in this contact
        b2Body *bodyA = contact.fixtureA-&gt;GetBody();
        b2Body *bodyB = contact.fixtureB-&gt;GetBody();
        
        // Get the sprites attached to these bodies
        PhysicsSprite *spriteA =
                    (PhysicsSprite*)bodyA-&gt;GetUserData();
        PhysicsSprite *spriteB =
                    (PhysicsSprite*)bodyB-&gt;GetUserData();
        
        // Look for lost ball (off the bottom)
        if (spriteA.tag == kBall &amp;&amp;
            contact.fixtureB ==bottomGutter) {
            if (std::find(toDestroy.begin(),
                          toDestroy.end(), bodyA) ==
                          toDestroy.end()) {
                toDestroy.push_back(bodyA);
            }
        }
        // Look for lost ball (off the bottom)
        else if (contact.fixtureA == bottomGutter &amp;&amp;
                 spriteB.tag == kBall) {
            if (std::find(toDestroy.begin(),
                          toDestroy.end(), bodyB) ==
                          toDestroy.end()) {
                toDestroy.push_back(bodyB);
            }
        }</pre></div><p>In this code block we are mostly using C++ structures, but the concepts are straightforward. We begin by defining two vectors, which are a form of dynamic array. The <code class="literal">toDestroy</code> vector will house any objects that need to be destroyed. The vector <code class="literal">pos</code> is an iterator which, as the name suggests, is used to iterate over data elements. We then enter a <code class="literal">for</code> loop, which iterates over the contents of the <a id="id1017" class="indexterm"/>
<a id="id1018" class="indexterm"/>
<code class="literal">_contacts</code> variable that was populated in the contact listener. Inside the loop, we use the variable <code class="literal">contact</code> to represent the current contact/collision from <code class="literal">_contacts</code> that we are evaluating.</p><p>As the contact contains the fixtures that are contacting one another, we use <a id="id1019" class="indexterm"/>
<a id="id1020" class="indexterm"/>the <code class="literal">GetBody()</code> function of the fixtures to get the two bodies involved, naming them <code class="literal">bodyA</code> and <code class="literal">bodyB</code>. We will need to get the tags from the attached <code class="literal">CCSprite</code> objects, so we also create <code class="literal">spriteA</code> and <code class="literal">spriteB</code> to represent the sprites associated with those bodies.</p><p>For now, we only have one type of collision that we need to address: the ball with the <code class="literal">bottomGutter</code> fixture. We identify the ball based on the sprite's tag of <code class="literal">kBall</code>, and we can identify the <a id="id1021" class="indexterm"/>
<a id="id1022" class="indexterm"/>
<code class="literal">bottomGutter</code> fixture because we stored a reference when it was created. To determine if we had a collision, we simply have to evaluate both objects to determine if one is a ball and other is the <code class="literal">bottomGutter</code> fixture. You will see from the code that we evaluate the collision twice, once comparing the "A" object to the ball and the "B" to the fixture, and then we evaluate again, with "A" and "B" swapped. We do this because the contact listener does not provide the fixtures "A" and "B" in <a id="id1023" class="indexterm"/>any particular order. The ball might be "A" this time, and "B" the next time. The only way to reliably evaluate this is to have two checks for each collision in this manner. (You could always create a helper function to evaluate both of these ways for you, but it only results in slightly more compact code, but not necessarily any better performance.)</p><p>In both cases, if we identified a collision between the ball and the <code class="literal">bottomGutter</code>, then the offending body is added to the <code class="literal">toDestroy</code> vector. The additional <code class="literal">if</code> statement wrapped around it is checking to make sure this body is not already in the <code class="literal">toDestroy</code> vector, because we won't be able to destroy the same body twice.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Destruction</h2></div></div></div><p>Now we have identified the objects to be destroyed, but we haven't actually destroyed anything. Just as with Objective-C, you should not attempt to remove objects from an array while iterating through it, and C++ vectors <a id="id1024" class="indexterm"/>are no exception. <a id="id1025" class="indexterm"/>As such, after we have evaluated all of our collisions, we add one more block of code at the bottom of the <code class="literal">update</code> method.</p><p>
<strong>Filename:</strong> <a id="id1026" class="indexterm"/>
<a id="id1027" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">    // Destroy any bodies &amp; sprites we need to get rid of
    std::vector&lt;b2Body *&gt;::iterator pos2;
    for(pos2 = toDestroy.begin(); pos2 != toDestroy.end();
                                            ++pos2) {
        b2Body *body = *pos2;
        if (body-&gt;GetUserData() != NULL) {
            PhysicsSprite *sprite =
                    (PhysicsSprite*)body-&gt;GetUserData();
            [self spriteDestroy:sprite];
        }
        world-&gt;DestroyBody(body);
    }</pre></div><p>We use a similar iterator to loop through the <a id="id1028" class="indexterm"/>
<a id="id1029" class="indexterm"/>
<code class="literal">toDestroy</code> vector. We retrieve each body, check if it has a sprite attached to it (in <code class="literal">userData</code>), and call the <a id="id1030" class="indexterm"/>
<a id="id1031" class="indexterm"/>
<code class="literal">spriteDestroy</code> method if it does. Then we instruct the world to destroy the body of this object. The <code class="literal">spriteDestroy</code> method is used for all of the sprite <a id="id1032" class="indexterm"/>destructions in our game. An abbreviated <a id="id1033" class="indexterm"/>form of it looks as follows:</p><p>
<strong>Filename:</strong> <a id="id1034" class="indexterm"/>
<a id="id1035" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) spriteDestroy:(PhysicsSprite*)sprite {
    switch (sprite.tag) {
        case kBall:
            [[SimpleAudioEngine sharedEngine]
                                playEffect:SND_LOSEBALL];
            [sprite removeFromParentAndCleanup:YES];
            [self loseLife];
            break;
  }
}</pre></div><p>We use the sprite tags here so that we can have custom destruction behavior for each type of object. We could have embedded this in the <code class="literal">update</code> method, but it will get pretty long by the end of this game. Separating the destruction code also keeps our Objective-C and C++ a little better separated in the code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Paddling around</h1></div></div></div><p>Now we have our basic game world, we have walls, and a ball that will drop off of the bottom of the screen. We need to turn our attention to the <a id="id1036" class="indexterm"/>only piece of the <a id="id1037" class="indexterm"/>game the user directly controls: the paddle. Let's look at how we build it:</p><p>
<strong>Filename:</strong> <a id="id1038" class="indexterm"/>
<a id="id1039" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildPaddleAtStartingPosition:(CGPoint)startPos {
    // Create the paddle
    paddle = [PhysicsSprite spriteWithSpriteFrameName:
                                        @"paddle.png"];
    paddle.position = startPos;
    paddle.tag = kPaddle;
    [bricksheet addChild: paddle];
    
    // Create paddle body
    b2BodyDef paddleBodyDef;
    paddleBodyDef.type = b2_dynamicBody;
    paddleBodyDef.position.Set(startPos.x/PTM_RATIO, 
                               startPos.y/PTM_RATIO);
    paddleBodyDef.userData = paddle;
    paddleBody = world-&gt;CreateBody(&amp;paddleBodyDef);
    
    // Connect the body to the sprite
    [paddle setPhysicsBody:paddleBody];
    
    // Build normal size fixure
    [self buildPaddleFixtureNormal];
    
    // Restrict paddle along the x axis
    b2PrismaticJointDef jointDef;
    b2Vec2 worldAxis(1.0f, 0.0f);
    jointDef.collideConnected = true;
    jointDef.Initialize(paddleBody, wallBody,
            paddleBody-&gt;GetWorldCenter(), worldAxis);
    world-&gt;CreateJoint(&amp;jointDef);
}</pre></div><p>Much of this is the same as when we built the ball. We create the <code class="literal">PhysicsSprite</code> first. Then we define the body at the same position, and attach the sprite to the body. You will notice that instead of building the fixture here, we call another method to define the fixture. This is because we will be using different fixtures for the paddle later, when we explore power-ups. We will get to the details of the fixture building in just a moment.</p><p>One new item that we need to build is a prismatic joint for the paddle, which connects the <code class="literal">paddleBody</code>
<a id="id1040" class="indexterm"/>
<a id="id1041" class="indexterm"/> to the <code class="literal">wallBody</code>. <a id="id1042" class="indexterm"/>
<a id="id1043" class="indexterm"/>A prismatic joint <a id="id1044" class="indexterm"/>allows a body to travel along a specific axis only. In our case, we define the <code class="literal">worldAxis</code> as constraining the movement along the x axis only, based on the coordinates we defined. One important flag we set for the paddle is <code class="literal">collideConnected</code> <a id="id1045" class="indexterm"/>
<a id="id1046" class="indexterm"/>to <code class="literal">true</code>. This allows collisions to be detected between bodies connected by the joint. Since we are creating a joint between the paddle and the <code class="literal">wallBody</code>, we need to set this to allow the paddle to collide with the side walls. Without this established, the paddle will pass through the sides of the playfield and leave the game. Just as with other Box2D elements, we create the <a id="id1047" class="indexterm"/>
<a id="id1048" class="indexterm"/>joint by passing the <code class="literal">CreateJoint</code> request to the world itself.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Paddle fixture</h2></div></div></div><p>We will be implementing some power-ups later that will allow the paddle size to be changed. Because of this, we need the ability to change the paddle size. As we discussed earlier, the fixture handles the geometry and the <a id="id1049" class="indexterm"/>
<a id="id1050" class="indexterm"/>physical properties of the body, so we have moved this fixture definition to its own method:</p><p>
<strong>Filename:</strong> <a id="id1051" class="indexterm"/>
<a id="id1052" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildPaddleFixtureNormal {
    // Define the paddle shape
    b2PolygonShape paddleShape;
    int num = 8;
    b2Vec2 verts[] = {
        b2Vec2(31.5f / PTM_RATIO, -7.5f / PTM_RATIO),
        b2Vec2(31.5f / PTM_RATIO, -0.5f / PTM_RATIO),
        b2Vec2(30.5f / PTM_RATIO, 0.5f / PTM_RATIO),
        b2Vec2(22.5f / PTM_RATIO, 6.5f / PTM_RATIO),
        b2Vec2(-24.5f / PTM_RATIO, 6.5f / PTM_RATIO),
        b2Vec2(-31.5f / PTM_RATIO, 1.5f / PTM_RATIO),
        b2Vec2(-32.5f / PTM_RATIO, 0.5f / PTM_RATIO),
        b2Vec2(-32.5f / PTM_RATIO, -7.5f / PTM_RATIO),
    };
    paddleShape.Set(verts, num);
    
    // Build the fixture
    [self buildPaddleFixtureWithShape:paddleShape
                   andSpriteFrameName:@"paddle.png"];
}</pre></div><p>To build a normal paddle, we first define the <a id="id1053" class="indexterm"/>
<a id="id1054" class="indexterm"/>
<code class="literal">b2PolygonShape</code> that matches the paddle. Because we have created a paddle that is not a simple shape (circle or square), we have to define all of the points that define the boundary of the shape. It is important to remember that these coordinates are in points, not pixels. If you are only using non-Retina displays, this makes no difference. Since our project includes both Retina and non-Retina assets, these coordinates must be defined based on the non-Retina sprite. There are many tools to help you define what these points should be, but you can also use most graphics editing programs to identify the points that define the "corners" of the shape. It is important to define the points of the polygon in a counter-clockwise order. If you define them in the other direction, the program will crash, usually when <a id="id1055" class="indexterm"/>
<a id="id1056" class="indexterm"/>Box2D is calculating the area of the shape.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Box2D defaults to a maximum of eight vertices to define a shape. If you need more than that, you can easily change the setting in the <code class="literal">b2Settings.h</code> file. This maximum is defined as <code class="literal">b2_maxPolygonVertices</code>.</p></div></div><p>After the shape has been defined, we call out another method to actually build the fixture.</p><p>
<strong>Filename:</strong> <a id="id1057" class="indexterm"/>
<a id="id1058" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildPaddleFixtureWithShape:(b2PolygonShape)shape
                 andSpriteFrameName:(NSString*)frameName {
    if (paddleFixture != nil) {
        paddleBody-&gt;DestroyFixture(paddleFixture);
    }
    
    // Create the paddle shape definition and add it to the body
    b2FixtureDef paddleShapeDef;
    paddleShapeDef.shape = &amp;shape;
    paddleShapeDef.density = 50.0f;
    paddleShapeDef.friction = 0.0f;
    paddleShapeDef.restitution = 0.0f;
    paddleFixture = paddleBody-&gt;CreateFixture(&amp;paddleShapeDef);
    
    // Swap the sprite image to the normal paddle
    [paddle setDisplayFrame:[[CCSpriteFrameCache
                              sharedSpriteFrameCache]
                             spriteFrameByName:frameName]];
}</pre></div><p>We start this method with a check to make sure we don't already have a <a id="id1059" class="indexterm"/>
<a id="id1060" class="indexterm"/>
<code class="literal">paddleFixture</code> object defined. If we do, we destroy it.</p><p>Most of the fixture definition follows the same pattern we used in the ball definition. We set the <code class="literal">density</code>, <code class="literal">friction</code>, and <code class="literal">restitution</code>, and we attach the shape to the fixture and the fixture to the body. You will notice that we set the <code class="literal">shape</code> to the variable shape that we passed to this method. The final line of this method is redundant and unnecessary the first time we build the paddle. We call <code class="literal">setDisplayFrame</code> to change the sprite frame attached to the paddle. This will come in handy when we <a id="id1061" class="indexterm"/>
<a id="id1062" class="indexterm"/>add the power-ups later.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Touching the paddle</h2></div></div></div><p>To interact with the paddle, we need to create a new type of joint: the mouse joint. The mouse joint tries to make the body move toward the <a id="id1063" class="indexterm"/>
<a id="id1064" class="indexterm"/>target set for it. In our case, the target will be our touched point. This will allow us to drag the paddle around while it is still a part of the Box2D world.</p><p>One approach for using the mouse joint is to detect touches on the paddle itself, and allow the player to move it directly. We will take an alternate approach, and detect any touches in the bottom portion of the screen as the target for the mouse joint. Naturally, we will begin with the <a id="id1065" class="indexterm"/>
<a id="id1066" class="indexterm"/>
<code class="literal">ccTouchesBegan</code> method:</p><p>
<strong>Filename:</strong> <a id="id1067" class="indexterm"/>
<a id="id1068" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void)ccTouchesBegan:(NSSet *)touches
                    withEvent:(UIEvent *)event {
  if (mouseJoint != NULL) return;
  
  UITouch *myTouch = [touches anyObject];
  CGPoint location = [myTouch locationInView:[myTouch view]];
  location = [[CCDirector sharedDirector]
                                convertToGL:location];
  b2Vec2 locationWorld = b2Vec2(location.x/PTM_RATIO,
                                  location.y/PTM_RATIO);
  
  // We want any touches in the bottom part of the
  // screen to control the paddle
  if (location.y &lt; 150) {
    b2MouseJointDef md;
    md.bodyA = wallBody;
    md.bodyB = paddleBody;
    md.target = locationWorld;
    md.collideConnected = true;
    md.maxForce = 1000.0f * paddleBody-&gt;GetMass();
    
    mouseJoint = (b2MouseJoint *)world-&gt;CreateJoint(&amp;md);
    paddleBody-&gt;SetAwake(true);
  }
}</pre></div><p>We begin by checking if there is already a <code class="literal">mouseJoint</code> defined. If there is, that means there is already one touch "in play", and we don't want to interfere with the current touch.</p><p>The next section uses fairly standard conversions from the touch to the OpenGL coordinates. However, here we also define the <code class="literal">locationWorld b2Vec2</code>, which is the Box2D version of the location variable.</p><p>We then check for a touch in the bottom portion of the screen. If the touch is there, we create a new mouse joint, and attach it to the <a id="id1069" class="indexterm"/>
<a id="id1070" class="indexterm"/>
<code class="literal">wallBody</code> and the <code class="literal">paddleBody</code>. The attachment to the <code class="literal">wallBody</code> is basically an anchor, since a joint must connect two bodies. Only the <a id="id1071" class="indexterm"/>
<a id="id1072" class="indexterm"/>
<code class="literal">paddleBody</code> will be moved by this joint. We set the <a id="id1073" class="indexterm"/>
<a id="id1074" class="indexterm"/>
<code class="literal">maxForce</code> variable to 1,000 times the mass of the paddle, so the player's movements completely override any other forces that may be trying to influence the paddle. We create the joint, and then make sure the paddle is awake (in case it was sitting idle long enough to sleep).</p><p>Now that we have the mouse joint instantiated, <a id="id1075" class="indexterm"/>
<a id="id1076" class="indexterm"/>we need to make the mouse joint track the user's movements:</p><p>
<strong>Filename:</strong> <a id="id1077" class="indexterm"/>
<a id="id1078" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void)ccTouchesMoved:(NSSet *)touches
                        withEvent:(UIEvent *)event {
    
  if (mouseJoint == NULL) return;
  
  if (isGameOver) return;
    
  UITouch *myTouch = [touches anyObject];
  CGPoint location = [myTouch locationInView:[myTouch view]];
  location = [[CCDirector sharedDirector]
                convertToGL:location];
  b2Vec2 locationWorld = b2Vec2(location.x/PTM_RATIO,
                                  location.y/PTM_RATIO);
    
  mouseJoint-&gt;SetTarget(locationWorld);
}</pre></div><p>The <a id="id1079" class="indexterm"/>
<a id="id1080" class="indexterm"/>
<code class="literal">ccTouchesMoved</code> method is almost trivial. We determine the current location of the touch, and we set that as the new target for the mouse joint. That's all it takes to move the paddle around. There is one loose end, however. The final step of the touch handling is to handle the cancel and end events.</p><p>
<strong>Filename:</strong> <a id="id1081" class="indexterm"/>
<a id="id1082" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void)ccTouchesCancelled:(NSSet *)touches
                withEvent:(UIEvent *)event {
  if(mouseJoint) {
    world-&gt;DestroyJoint(mouseJoint);
    mouseJoint = NULL;
  }
}

-(void)ccTouchesEnded:(NSSet *)touches
            withEvent:(UIEvent *)event {
    if (mouseJoint) {
        world-&gt;DestroyJoint(mouseJoint);
        mouseJoint = NULL;
    }
}</pre></div><p>As you can see, both of these methods are identical. Because the touch handler is only concerned with moving around the paddle with the mouse joint, all we need to do to end (or cancel) the touch is to destroy the mouse joint. Now that we have completed the touch handler, the game now has enough components to move the paddle around and bounce the ball. Box2D will handle all of the collisions between the <a id="id1083" class="indexterm"/>
<a id="id1084" class="indexterm"/>ball and paddle, without our code needing to do any collision handling of our own.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Storing player data</h1></div></div></div><p>One of the challenges with a multi-level game is keeping the player's information between levels. There are two common approaches. <a id="id1085" class="indexterm"/>One is to pass the player data (usually as a player object) from one scene to the next via the scene <code class="literal">init</code> methods. (<a id="id1086" class="indexterm"/>We used this approach in the snake game in <a class="link" href="ch04.html" title="Chapter 4. Give a Snake a Snack…">Chapter 4</a>, <em>Give a Snake a Snack</em>.) The other is to use a Singleton.</p><p>A Singleton is a design pattern for a class of which there is only one instance allowed. Cocos2D is built on a foundation of Singletons <a id="id1087" class="indexterm"/>
<a id="id1088" class="indexterm"/>like <a id="id1089" class="indexterm"/>
<a id="id1090" class="indexterm"/>
<code class="literal">CCDirector</code>, <code class="literal">CCSpriteFrameCache</code>, and so on. Pretty much anything where you reference a "sharedSomething" (for example, <code class="literal">[CCDirector sharedManager]</code>) is a Singleton. By design, there is a maximum of one "living" version of a Singleton class at any given time.</p><p>We will be using a Singleton class to handle our game <a id="id1091" class="indexterm"/>variables <code class="literal">currentLevel</code>, <code class="literal">currentLives</code>, and <code class="literal">currentScore</code>. Let's take a look:</p><p>
<strong>Filename:</strong> <a id="id1092" class="indexterm"/>
<a id="id1093" class="indexterm"/>
<code class="literal">BRGameHandler.mm</code>
</p><div><pre class="programlisting">static BRGameHandler *gameHandler = nil;

@implementation BRGameHandler

@synthesize currentLevel;
@synthesize currentScore;
@synthesize currentLives;
@synthesize playfieldLayer;

+ (id)sharedManager
{
    // Use Grand Central Dispatch to create it
    static dispatch_once_t pred;
    dispatch_once(&amp;pred, ^{
        gameHandler = [[super allocWithZone:NULL] init];
    });
    return gameHandler;
}

- (id)retain {
  return self;
}

- (unsigned)retainCount {	
  return NSUIntegerMax;
}

-(oneway void)release {
  //do nothing - the singleton is not allowed to release
}

- (id)autorelease {
  return self;
}</pre></div><p>These are the general Singleton methods we will <a id="id1094" class="indexterm"/>use. There are several methods that are not directly called in our game, but this is general enough to be used in many projects (other than the <code class="literal">@synthesize</code> statements). The <code class="literal">sharedManager</code> class method will check if there is a <code class="literal">gameHandler</code> already instantiated. If there is, it returns the existing instance. If not, it creates one. We are using <a id="id1095" class="indexterm"/>
<a id="id1096" class="indexterm"/>
<strong>Grand Central Dispatch</strong> (<strong>GCD</strong>) in the <code class="literal">sharedManager</code> method. It is beyond our scope here to go into detail on GCD, but this method is extremely lightweight and fast, compared to more traditional designs. (If you want to know more, check your favorite search engine for "Grand Central Dispatch Singleton" for further reading.) The first time you call <code class="literal">[BRGameHandler sharedManager]</code>, it will be created. This Singleton <a id="id1097" class="indexterm"/>class <a id="id1098" class="indexterm"/>will remain available for the life of the game, so you can rely on it to hold any variables you need to persist through your game.</p><p>Next we look at the game-specific methods we include in our Singleton:</p><p>
<strong>Filename:</strong> <a id="id1099" class="indexterm"/>
<a id="id1100" class="indexterm"/>
<code class="literal">BRGameHandler.mm</code>
</p><div><pre class="programlisting">-(id) init {
    if (self == [super init]) {
        [self resetGame];
  }
  return self;
}

-(void) resetGame {
    // Start with the defaults
    currentLevel = 1;
    currentLives = 3;
    currentScore = 0;
}

-(void) addToScore:(NSInteger)newPoints {
    currentScore = currentScore + newPoints;
}

-(void) loseLife {
    currentLives--;
}</pre></div><p>We have a couple of helper methods here to make our main code simpler. The first time we instantiate the class, it will call <code class="literal">resetGame</code> to set the <a id="id1101" class="indexterm"/>
<a id="id1102" class="indexterm"/>
<code class="literal">currentLevel</code>, <code class="literal">currentLives</code>
<a id="id1103" class="indexterm"/>
<a id="id1104" class="indexterm"/>, and <a id="id1105" class="indexterm"/>
<a id="id1106" class="indexterm"/>
<code class="literal">currentScore</code> variables to their starting values. As the Singleton instance will not be released, we put the variable initializations in the <code class="literal">resetGame</code> method. In this way, a single call to that method will fully reset the Singleton to a "fresh" state for a new game. The <a id="id1107" class="indexterm"/>
<a id="id1108" class="indexterm"/>
<code class="literal">addToScore</code> and <a id="id1109" class="indexterm"/>
<a id="id1110" class="indexterm"/>
<code class="literal">loseLife</code> methods are for convenience, so we don't have to "bother" our main playfield class with calculating what the new values should be when we score points or lose a life.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Displaying player data</h2></div></div></div><p>We now have a place to store the player data, but we will also need a way to display this for the user. For this game, we are following "best practices" by separating the <a id="id1111" class="indexterm"/>
<a id="id1112" class="indexterm"/>
<strong>Heads-Up Display</strong> (<strong>HUD</strong>) layer from the main playfield layer. <a id="id1113" class="indexterm"/>The HUD is a standard layer, with a <a id="id1114" class="indexterm"/>background box, a place for the score, and a place for lives remaining. One item to be pointed out is that in the HUD interface, we have defined the following variable:</p><div><pre class="programlisting">BRGameHandler *gh;</pre></div><p> And in the <code class="literal">init</code> method of the HUD implementation, we have the paired line:</p><div><pre class="programlisting">gh = [BRGameHandler sharedManager];</pre></div><p>From this point on in this class, any time we want to reference our <code class="literal">BRGameHandler</code> Singleton, we only have to use the variable <code class="literal">gh</code>. (Note: we also have this same variable defined in the <code class="literal">BRPlayfieldLayer</code> class.)</p><p>
<strong>Filename:</strong> <a id="id1115" class="indexterm"/>
<a id="id1116" class="indexterm"/>
<code class="literal">BRHUD.mm</code>
</p><div><pre class="programlisting">-(void) addToScore:(NSInteger)newPoints {
    [gh addToScore:newPoints];
    
    NSString *currScore = [NSString
            stringWithFormat:@"%i", [gh currentScore]];
    
    [scoreDisplay setString:currScore];
}</pre></div><p>The HUD acts as a "bridge" between the playfield layer and the game handler for scoring purposes. In the <a id="id1117" class="indexterm"/>
<a id="id1118" class="indexterm"/>
<code class="literal">addToScore</code> method, we first call out to the game handler to add points to the current score, and then the HUD calls the <a id="id1119" class="indexterm"/>
<a id="id1120" class="indexterm"/>
<code class="literal">setString</code> method on the <code class="literal">scoreDisplay</code> label to update the displayed score. By using a method like this, the playfield layer only has to pass one message to the HUD, and it takes care of the rest.</p><p>We want to get a little fancier with the display of lives remaining, and use <code class="literal">CCSprite</code> images of a ball for each life remaining, and we want a nice animation in the HUD when the player loses a life.</p><p>
<strong>Filename:</strong> <a id="id1121" class="indexterm"/>
<a id="id1122" class="indexterm"/>
<code class="literal">BRHUD.mm</code>
</p><div><pre class="programlisting">-(void) createLifeImages {
    for (int i = 1; i &lt;= gh.currentLives; i++) {
        CCSprite *lifeToken = [CCSprite
                spriteWithSpriteFrameName:@"ball.png"];
        [lifeToken setPosition:ccp(20 + (20 * i), 446)];
        [self addChild:lifeToken z:10];
        [livesArray addObject:lifeToken];
    }
}</pre></div><p>Because we don't want to create a variable for each of the player's "life sprites", we instead opt to use an array to keep those sprites, called <a id="id1123" class="indexterm"/>
<a id="id1124" class="indexterm"/>
<code class="literal">livesArray</code>. When we call the <code class="literal">createLifeImages</code> method, <a id="id1125" class="indexterm"/>
<a id="id1126" class="indexterm"/>it will generate the correct number of sprites, and space them out nicely in the display. It also stores them in the array.</p><p>
<strong>Filename:</strong> <a id="id1127" class="indexterm"/>
<a id="id1128" class="indexterm"/>
<code class="literal">BRHUD.mm</code>
</p><div><pre class="programlisting">-(void) loseLife {
    // Remove a life from the GameHandler variable
    [gh loseLife];

    CCSprite *lifeToRemove = [livesArray lastObject];
    
    CCScaleBy *scaleLife = [CCScaleBy actionWithDuration:0.5
                                    scale:2.0];
    CCFadeOut *fadeLife = [CCFadeOut actionWithDuration:0.5];
    CCSpawn *scaleAndFade = [CCSpawn actionOne:scaleLife
                                    two:fadeLife];
    CCCallFuncND *destroyLife = [CCCallFuncND
                        actionWithTarget:self
                        selector:@selector(destroyLife:)
                        data:lifeToRemove];
    CCSequence *seq = [CCSequence actions:scaleAndFade,
                       destroyLife, nil];
    [lifeToRemove runAction:seq];
    
    [livesArray removeLastObject];
}

-(void) destroyLife:(CCSprite*)lifeToRemove {
    [lifeToRemove removeFromParentAndCleanup:YES];
}</pre></div><p>When the player loses a life, we handle it in the same way we handled the score updates. We send the message to the game handler (which will subtract one from the <code class="literal">currentLives</code> variable). <a id="id1129" class="indexterm"/>
<a id="id1130" class="indexterm"/>Our next step is to add a <a id="id1131" class="indexterm"/>reference to the last sprite in the array with the <code class="literal">lifeToRemove</code> variable. After a little animation, we use <code class="literal">CCCallFuncND</code> to trigger the <code class="literal">destroyLife:</code> method, passing the <code class="literal">CCSprite</code> instance of the "life sprite" we <a id="id1132" class="indexterm"/>want to remove from the game. That method simply removes it and frees up that memory. At the end of the <a id="id1133" class="indexterm"/>
<a id="id1134" class="indexterm"/>
<code class="literal">loseLife</code> method, we remove the sprite from the <code class="literal">livesArray</code>.</p><p>By encapsulating these updates in the HUD, we don't have to clutter up our playfield with methods that don't have anything to do with the core gameplay. If we were to radically alter the appearance and general behavior of the HUD (assuming that <code class="literal">addToScore:</code> and <code class="literal">loseLife</code> were still present), the gameplay layer code would not change at all. This design also means that we could use a completely <a id="id1135" class="indexterm"/>different playfield class with this <a id="id1136" class="indexterm"/>same HUD. That is the flexibility that we strive for in our coding.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Building bricks</h1></div></div></div><p>We are missing one vital piece from our game: bricks to break. We want our game to be flexible enough that we will be able to define new levels without diving too deep into our source code, so we will be storing our levels as a <a id="id1137" class="indexterm"/>
<a id="id1138" class="indexterm"/>
<strong>property list</strong> (<strong>plist</strong>).</p><p>For our game, we want to have unlimited play, so <a id="id1139" class="indexterm"/>we will define a set number of brick patterns, and the game will loop through these in order. When you reach the end, it will go back to the first pattern and repeat the cycle.</p><p>We define the patterns in the plist as an array with the name in the format <code class="literal">P#</code>, so the patterns would be named <code class="literal">P1</code>, <code class="literal">P2</code>, <code class="literal">P3</code>, and so on. Inside each array are the strings representing each row of bricks. The rows begin at the bottom, so <strong>Item 0 </strong>is the lowest row of bricks, and <strong>Item 1</strong> would be above it, and so on.</p><p>If we were to build a level editor for our game, we would be more likely to build a more robust plist structure. Because we are hand coding the level design, the easiest way to organize the data is in strings. For each row of each pattern, we define a string of 13 digits, each digit representing a brick. (Our screen size will only hold 13 bricks wide.) We will represent the bricks based on the numbering in their file names (<code class="literal">brick1.png</code>, <code class="literal">brick2.png</code>, and so on) as well as a zero, representing no brick in that position.</p><p>Let's take a look at one pattern from the plist, and how it will be displayed:</p><div><img src="img/9007_05_02.jpg" alt="Building bricks"/></div><p>In this example showing pattern <strong>P2</strong>, <strong>Item 0</strong> is the bottom-most row of the final grid of bricks, shown to the right. You can see how it <a id="id1140" class="indexterm"/>translates: brick number 3 is green, 4 is grey, 5 is orange, and so on. As long as we keep in mind the "bottom first" nature of the pattern, it becomes very easy to "see" the patterns in the numbers.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Loading a plist</h2></div></div></div><p>So now we have a plist of pattern data, how do we load it? We have chosen to use an <code class="literal">NSDictionary</code> <a id="id1141" class="indexterm"/>
<a id="id1142" class="indexterm"/>as the data structure that we want to hold the plist data once loaded. We add a plist loader into our <code class="literal">BRGameHandler</code> because it is a more <a id="id1143" class="indexterm"/>general method, so we have it centralized if we decide we need to load a plist for some other part of the game.</p><p>
<strong>Filename:</strong> <a id="id1144" class="indexterm"/>
<code class="literal">BRGameHandler.mm</code>
</p><div><pre class="programlisting">-(id) readPlist:(NSString*) fileName {
  NSData *plistData;
  NSString *error;
  NSPropertyListFormat format;
  id plist;
  
    // Assumes filename is part of the main bundle
  NSString *localizedPath = [[NSBundle mainBundle]
            pathForResource:fileName ofType:@"plist"];
  plistData = [NSData dataWithContentsOfFile:localizedPath];
  
  plist = [NSPropertyListSerialization
            propertyListFromData:plistData
            mutabilityOption:NSPropertyListImmutable
            format:&amp;format errorDescription:&amp;error];
  
  if (!plist) {
    NSLog(@"Error reading plist '%s', error '%s'",
        [localizedPath UTF8String], [error UTF8String]);
  }
  return plist;
}</pre></div><p>This code is written with a couple of assumptions. One is that the passed filename will be without an extension (that is, we pass "patterns" if the filename is <code class="literal">patterns.plist</code>). The other assumption is that the plist file is in the main app bundle. You will notice that this method returns a value of type <code class="literal">id</code>. Since it was built as a general-purpose loader, we need one additional helper method to easily get the <a id="id1145" class="indexterm"/>
<code class="literal">NSDictionary</code> we desire for our data.</p><p>
<strong>Filename:</strong> <a id="id1146" class="indexterm"/>
<a id="id1147" class="indexterm"/>
<code class="literal">BRGameHandler.mm</code>
</p><div><pre class="programlisting">-(NSDictionary*)getDictionaryFromPlist:(NSString*)fileName {
    return (NSDictionary*)[self readPlist:fileName];
}</pre></div><p>This simply passes the filename to the <a id="id1148" class="indexterm"/>
<a id="id1149" class="indexterm"/>
<code class="literal">readPlist</code> method, and casts the returned value as an <code class="literal">NSDictionary</code>. (We can also use the same <code class="literal">readPlist</code> method to return an <code class="literal">NSArray</code>, using the same casting approach.)</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Picking a pattern</h2></div></div></div><p>Now that we know how to load the pattern data, let's take a look at the code from the <code class="literal">init</code> method of the <code class="literal">BRPlayfieldLayer</code> where we load the <a id="id1150" class="indexterm"/>patterns, and decide which pattern to use:</p><p>
<strong>Filename:</strong> <a id="id1151" class="indexterm"/>
<a id="id1152" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code> (inside <code class="literal">init</code> method)</p><div><pre class="programlisting">// Load the level patterns
patternDefs = [NSDictionary dictionaryWithDictionary:
[gh getDictionaryFromPlist:@"patterns"]];

// Load the brick pattern
NSInteger uniquePatterns = 4;
NSInteger newPattern =( [gh currentLevel] -1)
                                    % uniquePatterns;
[self buildBricksWithPattern:newPattern];</pre></div><p>We load all of the pattern definitions into <code class="literal">patternDefs</code> using the <code class="literal">dictionaryFromDictionary</code> method. We then identify how many total patterns we have defined in the file. If we add new patterns to the plist, this is the only element of the actual code that needs to be modified.</p><p>The <a id="id1153" class="indexterm"/>
<a id="id1154" class="indexterm"/>
<code class="literal">newPattern</code> calculation uses a modulo operation to give us an endless repeating sequence of patterns. (We subtract one from the current level number because we start with Pattern P0 for Level 1.)</p><p>Now we move to the method that interprets the <a id="id1155" class="indexterm"/>pattern data:</p><p>
<strong>Filename:</strong> <code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildBricksWithPattern:(NSInteger)patternNum {
    // Load in the desired pattern
    NSString *pattID = [NSString stringWithFormat:
                        @"P%i",patternNum];
    NSArray *tmpPattern = [patternDefs objectForKey:pattID];
    
    // We start at row 1
    NSInteger rowNum = 1;
    
    // Build each row of bricks
    for (NSString *aRow in tmpPattern) {
        [self buildBricksForRow:rowNum withString:aRow];
        rowNum++;
    }
}</pre></div><p>Here we hold the array for the currently chosen pattern in the variable <code class="literal">tmpPattern</code>. Since each pattern is an array of strings, we then iterate through the <a id="id1156" class="indexterm"/>
<a id="id1157" class="indexterm"/>
<code class="literal">tmpPattern</code> array, and for each string in the array, we call the method to build the next row of bricks with this data:</p><p>
<strong>Filename:</strong> <a id="id1158" class="indexterm"/>
<a id="id1159" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildBricksForRow:(NSInteger)rowNum
                    withString:(NSString*)brickString {
    for(int i = 0; i &lt; [brickString length]; i++) {
        // Create brick and add it to the layer
        NSRange rng = NSMakeRange(i, 1);
        NSInteger newID = [[brickString
                substringWithRange:rng] integerValue];
        
        if (newID &gt; 0) {
            NSString *newBrickName = [NSString
                stringWithFormat:@"brick%i.png", newID];
            
            PhysicsSprite *brick = [PhysicsSprite
                spriteWithSpriteFrameName:newBrickName];
            CGPoint startPos = [self positionForBrick:brick
                forRow:rowNum andColumn:i];
            
            brick.position = startPos;
            brick.tag = kBrick;
            [bricksheet addChild:brick z:10];
            
            // Create brick body
            b2BodyDef brickBodyDef;
            brickBodyDef.type = b2_dynamicBody;
            brickBodyDef.position.Set(startPos.x/PTM_RATIO,
                                      startPos.y/PTM_RATIO);
            brickBodyDef.userData = brick;
            b2Body *brickBody =
                        world-&gt;CreateBody(&amp;brickBodyDef);
            
            [brick setPhysicsBody:brickBody];
            
            // Create brick shape
            b2PolygonShape brickShape;
            brickShape.SetAsBox(
                brick.contentSize.width/PTM_RATIO/2,
                brick.contentSize.height/PTM_RATIO/2);
            
            //Create shape definition, add to body
            b2FixtureDef brickShapeDef;
            brickShapeDef.shape = &amp;brickShape;
            brickShapeDef.density = 200.0;
            brickShapeDef.friction = 0.0;
            brickShapeDef.restitution = 1.0f;
            brickBody-&gt;CreateFixture(&amp;brickShapeDef);
        }
    }
}</pre></div><p>Because we are <a id="id1160" class="indexterm"/> building an entire row of bricks, we approach this build method a little differently:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are passed the row number and the string representing this row of bricks</li><li class="listitem" style="list-style-type: disc">We iterate through all of the characters of the string, one at a time</li><li class="listitem" style="list-style-type: disc">We call NSMakeRange to substring only one character at a time, and convert that character to an integer value</li><li class="listitem" style="list-style-type: disc">If the value is zero, there is no brick in that position, and no further action is taken for this position</li></ul></div><p>If we need a brick here, we then proceed to build them in the same manner as the other objects. We build a sprite, body, shape, and fixture, and attach them together. When we define the shape of the fixture we use the <code class="literal">SetAsBox</code> function, so we can simply provide half the width of the sprite and half the height of the <a id="id1161" class="indexterm"/>sprite, and Box2D builds the shape.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Breaking bricks, for real</h1></div></div></div><p>Now we have all the core elements of the game defined, we need to add collision handling for the ball hitting the bricks. If we <a id="id1162" class="indexterm"/>were to stop here, the ball would hit the bricks, and the bricks would go flying off from the force of the impact. We really want the brick to be destroyed, so we will revisit the <code class="literal">update</code> method we described earlier in the <em>Losing Your Ball</em> section. Immediately after the <a id="id1163" class="indexterm"/>
<a id="id1164" class="indexterm"/>
<code class="literal">if…else</code> statement in the <code class="literal">update</code> method, we add a couple of clauses:</p><p>
<strong>Filename:</strong> <code class="literal">BRPlayfieldLayer.mm</code> (inside <code class="literal">init</code> method)</p><div><pre class="programlisting">else if (spriteA != NULL &amp;&amp; spriteB != NULL) {
  // Sprite A = ball, Sprite B = Block
  if (spriteA.tag == kBall &amp;&amp; spriteB.tag == kBrick) {
   if (std::find(toDestroy.begin(), toDestroy.end(),
       bodyB) == toDestroy.end()) {
        toDestroy.push_back(bodyB);
   }
  }
  // Sprite B = block, Sprite A = ball
  else if (spriteA.tag == kBrick &amp;&amp; spriteB.tag == kBall) {
    if (std::find(toDestroy.begin(), toDestroy.end(),
      bodyA) == toDestroy.end()) {
        toDestroy.push_back(bodyA);
   }
  }
}</pre></div><p>The outer clause makes sure we have sprites for both bodies involved in the contact. We then check the <code class="literal">tag</code> value for both sprites. If one is the brick and the other is the ball, then we add the brick to the <a id="id1165" class="indexterm"/>
<a id="id1166" class="indexterm"/>
<code class="literal">toDestroy</code> vector. As you recall, this is exactly how we handled the ball versus <code class="literal">bottomGutter</code> collisions earlier. The only primary difference is that we are comparing two sprites this time, and we are destroying the brick, not the ball.</p><p>Because we are using one common path of destruction for objects, we don't have to add anything else to the <code class="literal">update</code> method to make this process work. We only need to add a new case statement in the <a id="id1167" class="indexterm"/>
<a id="id1168" class="indexterm"/>
<code class="literal">spriteDestroy</code> method. <a id="id1169" class="indexterm"/>Let's look at that method again:</p><p>
<strong>Filename:</strong> <a id="id1170" class="indexterm"/>
<a id="id1171" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) spriteDestroy:(PhysicsSprite*)sprite {
    switch (sprite.tag) {
        case kBrick:
            [[SimpleAudioEngine sharedEngine]
                            playEffect:SND_BRICK];
            [self checkForRandomPowerupFromPosition:
                            sprite.position];
            [sprite removeFromParentAndCleanup:YES];
            [self addToScore:1];
            break;
        case kBall:
            [[SimpleAudioEngine sharedEngine]
                                playEffect:SND_LOSEBALL];
            [sprite removeFromParentAndCleanup:YES];
            [self loseLife];
            break;
}
}</pre></div><p>As you may remember, we actually destroy the Box2D body itself at the end of the <code class="literal">update</code> method, so we clean up the sprites here and take care of any additional housekeeping items, such as incrementing the score, playing sound effects, and so forth.</p><p>We have included one method in the <code class="literal">case kBrick</code> section that leads us to our next (and final) topic for this game: implementing power-ups.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Power-ups, good and bad</h1></div></div></div><p>The idea of power-ups is core to the modern brick breaking experience. For our game, we will be implementing three types of <a id="id1172" class="indexterm"/>power-ups: <a id="id1173" class="indexterm"/>
<a id="id1174" class="indexterm"/>paddle expanding, <a id="id1175" class="indexterm"/>
<a id="id1176" class="indexterm"/>paddle contracting, and <a id="id1177" class="indexterm"/>
<a id="id1178" class="indexterm"/>multiball. As we just saw, when a brick is destroyed another method gets called to handle the power-ups.</p><p>
<strong>Filename:</strong> <a id="id1179" class="indexterm"/>
<a id="id1180" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) checkForRandomPowerupFromPosition:(CGPoint)brickPos {
    NSInteger rnd = arc4random() % 100;
    
    if (rnd &lt; 25) {  // 25 % CHANCE
        [self buildPowerupAtPosition:brickPos];
    }
}</pre></div><p>In this method we randomize a number. If it is below 25 percent, we call another method to actually build a power-up. It is important to point out that in the <code class="literal">spriteDestroy</code> method, we must call this method before we <code class="literal">removeFromParentAndCleanup</code> because we will need to use the position of the brick that is being destroyed here. This allows the power-up to drop from "inside" the brick that was <a id="id1181" class="indexterm"/>just destroyed.</p><p>As we follow this code path, we now reach the point where we have decided to generate a power-up. This is another Box2D-enabled body, so let's review the build method for the power-ups:</p><p>
<strong>Filename:</strong> <a id="id1182" class="indexterm"/>
<a id="id1183" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildPowerupAtPosition:(CGPoint)startPos {
    NSInteger powerupType = arc4random() % 3;
    NSString *powerupImageName;
    NSInteger newTag;
    
    switch (powerupType) {
        case 1:
            powerupImageName = @"powerup_contract.png";
            newTag = kPowerupContract;
            break;
        case 2:
            powerupImageName = @"powerup_multi.png";
            newTag = kPowerupMultiball;
            break;
        default:
            powerupImageName = @"powerup_expand.png";
            newTag = kPowerupExpand;
            break;
    }
    
    // Create sprite and add it to layer
    PhysicsSprite *powerup = [PhysicsSprite
            spriteWithSpriteFrameName:powerupImageName];
    powerup.position = startPos;
    powerup.tag = newTag;
    [bricksheet addChild:powerup z:50];
    
    // Create body
    b2BodyDef powerupBodyDef;
    powerupBodyDef.type = b2_dynamicBody;
    powerupBodyDef.position.Set(startPos.x/PTM_RATIO, 
                             startPos.y/PTM_RATIO);
    powerupBodyDef.userData = powerup;
    b2Body *powerupBody = world-&gt;CreateBody(&amp;powerupBodyDef);
    
    // Connect the body to the sprite
    [powerup setPhysicsBody:powerupBody];
    
    // Define the fixture shape
    b2PolygonShape powerupShape;
    int num = 8;
    b2Vec2 verts[] = {
        b2Vec2(-5.6f / PTM_RATIO, 4.3f / PTM_RATIO),
        b2Vec2(-5.6f / PTM_RATIO, -4.6f / PTM_RATIO),
        b2Vec2(-4.3f / PTM_RATIO, -5.8f / PTM_RATIO),
        b2Vec2(4.5f / PTM_RATIO, -5.8f / PTM_RATIO),
        b2Vec2(5.5f / PTM_RATIO, -4.8f / PTM_RATIO),
        b2Vec2(5.5f / PTM_RATIO, 4.4f / PTM_RATIO),
        b2Vec2(4.5f / PTM_RATIO, 5.6f / PTM_RATIO),
        b2Vec2(-4.7f / PTM_RATIO, 5.6f / PTM_RATIO)
    };
    powerupShape.Set(verts, num);
    
    //Create shape definition and add to body
    b2FixtureDef powerupShapeDef;
    powerupShapeDef.shape = &amp;powerupShape;
    powerupShapeDef.isSensor = YES;
    powerupBody-&gt;CreateFixture(&amp;powerupShapeDef);
    
    b2Vec2 force = b2Vec2(0,-3);
    powerupBody-&gt;ApplyLinearImpulse(force,
                     powerupBodyDef.position);
}</pre></div><p>When we call this method, we only have gotten as far as knowing we need to generate a power-up, but we have not yet identified which of the three available power-ups we will generate. To that end, we use <a id="id1184" class="indexterm"/>
<a id="id1185" class="indexterm"/>
<code class="literal">arc4random()</code> to randomly choose which of the power-ups we want to use. The only difference in this build method is different values for the sprite file name and for the sprite's <a id="id1186" class="indexterm"/>
<a id="id1187" class="indexterm"/>
<code class="literal">tag</code> property.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>For mathematical purists, none of the randomizing approaches used in this book are "true randomness". There will be some small imbalance in the frequency of numbers generated. However, this is just a game, so less than perfect randomness is perfectly acceptable.</p></div></div><p>We continue to build the body, shape, and fixture much the same as we did for the paddle body, including defining the polygon shape by its eight points. We could have also gotten by with using a box shape instead, but we wanted to get "pixel-perfect" with the rounded corners on the power-up blocks.</p><p>The fixture is a little different, however. We don't set the <code class="literal">density</code>, <code class="literal">friction</code>, or <code class="literal">restitution</code> for this fixture. Instead, we use a new property, <code class="literal">isSensor</code>. A sensor is a fixture that can take part in collisions, but doesn't actually cause things to impact it. A sensor can pass through another body without any hit-and-bounce-off actions. However, we can detect when a sensor and another fixture come in contact with each other. In our case, the power-ups will be picked up by the paddle, but they shouldn't bounce around and/or get hit by the ball or paddle.</p><p>We finish off the building of the power-up by <a id="id1188" class="indexterm"/>applying a downward linear impulse on the body, so it will drop straight down. This simulates the effect of gravity, even though we have zero gravity for our world.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Picking up power-ups</h2></div></div></div><p>Now we need to handle the collisions between the power-ups and the paddle. We have most of the pieces we need to make this happen already. <a id="id1189" class="indexterm"/>Back in the <code class="literal">update</code> method, we add a few more checks directly after the brick versus ball checks. We need three more pairs of checks between the paddle and each type of power-up. (We only include the first pair for example – the other two are identical, just change the <code class="literal">tag</code> checked for the power-ups.)</p><p>
<strong>Filename:</strong> <a id="id1190" class="indexterm"/>
<a id="id1191" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code> (inside <code class="literal">update</code> method)</p><div><pre class="programlisting">  else if (spriteA.tag == kPowerupContract &amp;&amp;
           spriteB.tag == kPaddle) {
    if (std::find(toDestroy.begin(),toDestroy.end(),
               bodyA) == toDestroy.end()) {
          toDestroy.push_back(bodyA);
    }
  }          
  else if (spriteA.tag == kPaddle &amp;&amp;
          spriteB.tag == kPowerupContract) {
    if (std::find(toDestroy.begin(), toDestroy.end(),
               bodyB) == toDestroy.end()) {
          toDestroy.push_back(bodyB);
    }
  }</pre></div><p>This is almost a direct copy-and-paste from the prior collision checking. Once again, when a power-up is "picked up", we simply add it to the <code class="literal">toDestroy</code> vector. As you have probably guessed, we handle the rest of the power-up <a id="id1192" class="indexterm"/>triggering in the <code class="literal">spriteDestroy</code> method. In that method, we add three more case statements.</p><p>
<strong>Filename:</strong> <a id="id1193" class="indexterm"/>
<a id="id1194" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code> (inside <code class="literal">spriteDestroy</code> method)</p><div><pre class="programlisting">case kPowerupContract:
  [sprite removeFromParentAndCleanup:YES];
  [self buildPaddleFixtureShort];
  paddleTimer = 10; // Set the timer to 10 seconds
  isPaddleDeformed = YES;
  break;
case kPowerupExpand:
  [sprite removeFromParentAndCleanup:YES];
  [self buildPaddleFixtureLong];
  paddleTimer = 10; // Set the timer to 10 seconds
  isPaddleDeformed = YES;
  break;
case kPowerupMultiball:
  [sprite removeFromParentAndCleanup:YES];
  shouldStartMultiball = YES;
  break;  </pre></div><p>For the contract and expand power-ups, we remove the sprite and then call to build a new fixture. The <a id="id1195" class="indexterm"/>
<a id="id1196" class="indexterm"/>
<code class="literal">paddleTimer</code> and <a id="id1197" class="indexterm"/>
<a id="id1198" class="indexterm"/>
<code class="literal">isPaddleDeformed</code> variables will be used to control when the paddle goes back to normal size.</p><p>For the multiball, there is a little more substance to it, so here we simply set the flag <code class="literal">shouldStartMultiball</code> to <code class="literal">YES</code>, so we can deal with it on the next <code class="literal">update</code> loop.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Paddle deformation</h2></div></div></div><p>As you recall when we first build the paddle, we build the fixture itself in a separate method, <a id="id1199" class="indexterm"/>
<code class="literal">buildPaddleFixtureNormal</code>. When the player <a id="id1200" class="indexterm"/>catches a contract or expand power-up, we simply need to destroy the existing fixture and build a new one. Let's look at the expansion:</p><p>
<strong>Filename:</strong> <a id="id1201" class="indexterm"/>
<a id="id1202" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) buildPaddleFixtureLong {
    // Define the paddle shape
    b2PolygonShape paddleShape;
    int num = 6;
    b2Vec2 verts[] = {
        b2Vec2(64.0f / PTM_RATIO, -7.5f / PTM_RATIO),
        b2Vec2(64.0f / PTM_RATIO, -0.5f / PTM_RATIO),
        b2Vec2(45.0f / PTM_RATIO, 6.5f / PTM_RATIO),
        b2Vec2(-48.0f / PTM_RATIO, 6.5f / PTM_RATIO),
        b2Vec2(-65.0f / PTM_RATIO, 0.5f / PTM_RATIO),
        b2Vec2(-65.0f / PTM_RATIO, -7.5f / PTM_RATIO)
    };
    paddleShape.Set(verts, num);
    
    // Build the fixture
    [self buildPaddleFixtureWithShape:paddleShape
                   andSpriteFrameName:@"paddle_wide.png"];
}</pre></div><p>Here we see why we divided the paddle fixture building into two methods. We can leverage all of the setup done by the <code class="literal">buildPaddleFixtureWithShape: andSpriteFrameName:</code> method <a id="id1203" class="indexterm"/>
<a id="id1204" class="indexterm"/>we built earlier. The major differences are that we set a different <code class="literal">spriteFrameName</code>, and we define the <code class="literal">verts[]</code> with the coordinates that match the <code class="literal">paddle_wide.png</code> sprite's geometry.</p><p>The method <a id="id1205" class="indexterm"/>
<a id="id1206" class="indexterm"/>
<code class="literal">buildPaddleFixtureShort</code> follows the same design, using the display frame <code class="literal">paddle_short.png</code> and an alternate set of <code class="literal">verts[]</code> values. All the other code is identical to the "long" method.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Restoring the paddle</h2></div></div></div><p>Now that we have either expanded or contracted the paddle, how do we go back to normal? We have set a 10 second timer value in the <a id="id1207" class="indexterm"/>
<a id="id1208" class="indexterm"/>
<code class="literal">spriteDestroy</code> method, but we need to actually do something with it. At the top of <a id="id1209" class="indexterm"/>the <code class="literal">update</code> method, we add one simple <code class="literal">if</code> clause, as follows:</p><p>
<strong>Filename:</strong> <a id="id1210" class="indexterm"/>
<a id="id1211" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code> (inside <code class="literal">update</code> method)</p><div><pre class="programlisting">    if (isPaddleDeformed) {
        paddleTimer = paddleTimer - dt;
        if (paddleTimer &lt;= 0) {
            paddleTimer = 0;
            isPaddleDeformed = NO;
            [self buildPaddleFixtureNormal];
        }
    }</pre></div><p>We only enter this clause if the <a id="id1212" class="indexterm"/>
<a id="id1213" class="indexterm"/>
<code class="literal">isPaddleDeformed</code> variable is set to <code class="literal">YES</code>. We subtract the current delta from the <code class="literal">paddleTimer</code>, and then check if our time has run out. If it has run out, we set <code class="literal">isPaddleDeformed</code> to <code class="literal">NO</code>, and call to the <code class="literal">buildPaddleFixtureNormal</code> <a id="id1214" class="indexterm"/>
<a id="id1215" class="indexterm"/>method to restore our original paddle sprite and fixture. Thus, we are back to normal gameplay.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Multiball</h2></div></div></div><p>Earlier we saw that the collision with the multiball power-up only sets the <code class="literal">shouldStartMultiball</code> <a id="id1216" class="indexterm"/>
<a id="id1217" class="indexterm"/>variable to <code class="literal">YES</code>, and <a id="id1218" class="indexterm"/>does not take any further action. Instead, we put the actual trigger at the end of the update method.</p><p>
<strong>Filename:</strong> <a id="id1219" class="indexterm"/>
<a id="id1220" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code> (inside <code class="literal">update</code> method)</p><div><pre class="programlisting">    if (shouldStartMultiball) {
        [self startMultiball];
        shouldStartMultiball = NO;
    }</pre></div><p>Why not simply call <code class="literal">startMutiball</code> directly? Because multiball involves the creation of new bodies, we want to make sure that the creation of those bodies does not happen while we are iterating through the world bodies (which we do at the top of the <code class="literal">update</code> method). To avoid this conflict, it is much safer to set triggers as we have done, and take action on them in a portion of the <code class="literal">update</code> method where <a id="id1221" class="indexterm"/>you can be certain to be "in the clear".</p><p>
<strong>Filename:</strong> <code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) startMultiball {
    // Prevent triggering a multiball when the ball is lost
    if (!isBallInPlay) {
        return;
    }
    CGPoint startPos;
    for(b2Body *b = world-&gt;GetBodyList(); b;b=b-&gt;GetNext()) {
    if (b-&gt;GetUserData() != NULL) {
            // Get the sprite for this body
      CCSprite *sprite = (CCSprite *)b-&gt;GetUserData();
            
            if (sprite.tag == kBall) {
                startPos = sprite.position;
                
                // Build 2 new balls at the same position
                [self buildBallAtStartingPosition:startPos
                    withInitialImpulse:b2Vec2(0.2,1.5)];
                [self buildBallAtStartingPosition:startPos
                    withInitialImpulse:b2Vec2(-0.2,1.5)];
                
                multiballCounter = multiballCounter + 2;
                
                // We break out to avoid chain reactions
                break;
            }
        }
    }
}</pre></div><p>The core of this method iterates over the bodies in the world, and looks for a sprite that has the tag <code class="literal">kBall</code>. It then calls the same <code class="literal">buildBall</code> method we used for the "normal" ball, and creates two new balls at the same position, but gives them a different impulse. This set of impulses gives a "popcorn" effect, so the two new balls go slightly up and to each side of the original ball.</p><p>We also have some extra code to prevent "bad behavior". The check of the <code class="literal">isBallInPlay</code> variable <a id="id1222" class="indexterm"/>
<a id="id1223" class="indexterm"/>is to prevent a situation where the <a id="id1224" class="indexterm"/>player catches a multiball right as the only ball in play is destroyed. This can cause a crash, if the sprite and body are destroyed at the same time the multiball is trying to interact with it.</p><p>We also force a break after one ball has been "multiballed". If we were to allow the iterator to continue evaluating other bodies, there is a strong possibility (depending on timing) that the two newly created balls would also be "multiballed" (that is, creating two new balls for each of them), and then those balls would also be "multiballed", and so on. The screen would instantly fill up with dozens of balls, and the game is unplayable.</p><p>Finally, we also keep track of how many "extra" balls we have in play, with the <code class="literal">multiballCounter</code> <a id="id1225" class="indexterm"/>
<a id="id1226" class="indexterm"/>variable. This is <a id="id1227" class="indexterm"/>important, so we don't accidentally trigger losing a life when the player still has balls in play.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Losing lives with multiball</h2></div></div></div><p>Having more than one ball in play at a time makes <a id="id1228" class="indexterm"/>detecting a lost ball a little <a id="id1229" class="indexterm"/>more involved. Let's take a look at the final <a id="id1230" class="indexterm"/>
<a id="id1231" class="indexterm"/>
<code class="literal">loseLife</code> method:</p><p>
<strong>Filename:</strong> <a id="id1232" class="indexterm"/>
<a id="id1233" class="indexterm"/>
<code class="literal">BRPlayfieldLayer.mm</code>
</p><div><pre class="programlisting">-(void) loseLife {
    if (multiballCounter &gt; 0) {
        multiballCounter--;
    } else {
        isBallInPlay = NO;
        
        [hudLayer loseLife];
        // Do we need another ball?
        if ([gh currentLives] &gt; 0) {
            [self scheduleOnce:@selector(newBall) delay:1.0];
        } else {
            // Game over
            [self prepareForGameOver];
        }
    }
}</pre></div><p>We start by evaluating the <a id="id1234" class="indexterm"/>
<a id="id1235" class="indexterm"/>
<code class="literal">multiballCounter</code> variable. If there are any multiballs in play, we will subtract from that variable first, and the player's lives are not affected. If there is no multiball, then we call the HUD to lose a life. As you recall, this updates the HUD as well as updating the <a id="id1236" class="indexterm"/>
<a id="id1237" class="indexterm"/>
<code class="literal">currentLives</code> variable in the <a id="id1238" class="indexterm"/>
<a id="id1239" class="indexterm"/>
<code class="literal">BRGameHandler</code> class. Because of this, we can then evaluate the <code class="literal">[gh currentLives]</code> variable to determine the new number of lives for the player. <a id="id1240" class="indexterm"/>If there are <a id="id1241" class="indexterm"/>lives left, we <a id="id1242" class="indexterm"/>create a new ball, and continue on. Otherwise, we begin the Game Over sequence.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Summary</h1></div></div></div><p>We have covered a lot of (physics enabled) ground here. We have discussed the basics of Box2D, and we have built a pretty good brick breaker. We have focused on the core mechanics of the physics world, and how to translate between the Box2D and cocos2d positioning (using the <code class="literal">PTM_RATIO</code>). We have learned how to implement power-ups that affect the physics of the Box2D world during gameplay, and learned how to use a contact listener, and how to decide which collisions cause destruction.</p><p>In the next chapter, we will explore head-to-head action gaming with two players on the same device as well as our first two device game. Let's roll!</p></div></body></html>