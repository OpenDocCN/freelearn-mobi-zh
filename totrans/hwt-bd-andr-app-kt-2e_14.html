<html><head></head><body>
		<div id="_idContainer217">
			<h1 id="_idParaDest-231" class="chapter number"><a id="_idTextAnchor751"/>14</h1>
			<h1 id="_idParaDest-232">Coroutines and Flow<a id="_idTextAnchor752"/></h1>
			<p>This chapter introduces you to background operations and data manipulations with Coroutines and Flow. You’ll also learn how to manipulate and display the data using <strong class="source inline">LiveData</strong> transformations and Kotlin <span class="No-Break">Flow operators.</span></p>
			<p>By the end of this chapter, you will be able to use Coroutines and Flow to manage network calls in the background. You will also be able to manipulate data with <strong class="source inline">LiveData</strong> transformations and <span class="No-Break">Flow operators.</span><a id="_idTextAnchor753"/></p>
			<p>You learned the basics of Android app development and implemented features such as RecyclerViews, notifications, fetching data from web services, and services. You also gained skills in the best practices for testing and persisting data. In the previous chapter, you learned about dependency injection. Now, you will learn about background operations and <span class="No-Break">data manipulation.</span></p>
			<p>Some Android applications work on their own. However, most apps would need a backend server to retrieve or process data. These operations may take a while, depending on the internet connection, device settings, and server specifications. If long-running operations are run <a id="_idIndexMarker1199"/>in the main <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) thread, the application will be blocked until the tasks are completed. The application might become unresponsive and prompt the user to close and stop <span class="No-Break">using it.</span></p>
			<p>To avoid this, tasks that can take an indefinite amount of time must be run asynchronously. An asynchronous task means it can run in parallel to another task or in the background. For example, while fetching data from a data source asynchronously, your UI can still be displayed and user interaction <span class="No-Break">can occur.</span></p>
			<p>You can use libraries such as Coroutines and Flow for asynchronous operations. We’ll discuss both in <span class="No-Break">this chapter.</span><a id="_idTextAnchor754"/><a id="_idTextAnchor755"/></p>
			<p>We will cover the following key topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Using Coroutines <span class="No-Break">on Android</span></li>
				<li><span class="No-Break">Transforming </span><span class="No-Break"><strong class="source inline">LiveData</strong></span></li>
				<li>Using Flow <span class="No-Break">on Androi<a id="_idTextAnchor756"/>d</span></li>
			</ul>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor757"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/puLUO"><span class="No-Break">https://packt.link/puLUO</span></a></p>
			<p>Let’s get started <span class="No-Break">with Coroutines.</span></p>
			<h1 id="_idParaDest-234">Using Corou<a id="_idTextAnchor758"/>tines on Android</h1>
			<p>Coroutines were added in Kotlin 1.3 to manage background tasks such as making network calls and <a id="_idIndexMarker1200"/>accessing files or databases. Kotlin coroutines are Google’s official recommendation for asynchronous programming on Android. Their <a id="_idIndexMarker1201"/>Jetpack libraries, such as LifeCycle, WorkManager, and Room, now include support <span class="No-Break">for coroutines.</span></p>
			<p>With coroutines, you can write your code in a sequential way. The long-running task can be made into a suspending function, which, when called, can pause the thread without blocking it. When the suspending function is done, the current thread will resume execution. This will make your code easier to read <span class="No-Break">and debug.</span></p>
			<p>To mark a function as a suspending function, you can add the <strong class="source inline">suspend</strong> keyword to it; for example, if you have a function that calls the <strong class="source inline">getMovies</strong> function, which fetches <strong class="source inline">movies</strong> from your endpoint and then <span class="No-Break">displays it:</span></p>
			<pre class="source code">
val movies = getMovies()
displayMovies(movies)</pre>
			<p>You can make the <strong class="source inline">getMovies()</strong> function a suspending function by adding the <span class="No-Break"><strong class="source inline">suspend</strong></span><span class="No-Break"> keyword:</span></p>
			<pre class="source code">
suspend fun getMovies(): List&lt;Movies&gt; { ... }</pre>
			<p>Here, the calling function will invoke <strong class="source inline">getMovies</strong> and pause. After <strong class="source inline">getMovies</strong> returns a list of movies, it will resume its task and display <span class="No-Break">the movies.</span></p>
			<p>Suspending functions can only be called in other suspending functions or from a coroutine. Coroutines have a context, which includes the coroutine dispatcher. Dispatchers specify what thread the coroutine will use. There are three dispatchers you <span class="No-Break">can use:</span></p>
			<ul>
				<li><strong class="source inline">Dispatchers.Main</strong>: Used to run on Android’s <span class="No-Break">main thread</span></li>
				<li><strong class="source inline">Dispatchers.IO</strong>: Used for network, file, or <span class="No-Break">database operations</span></li>
				<li><strong class="source inline">Dispatchers.Default</strong>: Used for <span class="No-Break">CPU-intensive work</span></li>
			</ul>
			<p>To change the context for your coroutine, you can use the <strong class="source inline">withContext</strong> function for the code that you want to use a different thread with. For example, in your suspending function, <strong class="source inline">getMovies</strong>, which gets <a id="_idIndexMarker1202"/>movies from your endpoint, you <a id="_idIndexMarker1203"/>can <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">Dispatchers.IO</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
suspend fun getMovies(): List&lt;Movies&gt;  {
    withContext(Dispatchers.IO) { ... }
}</pre>
			<p>In the next section, we will cover how to <span class="No-Break">create corout<a id="_idTextAnchor759"/>ines.</span></p>
			<h2 id="_idParaDest-235">C<a id="_idTextAnchor760"/>reating coroutines</h2>
			<p>You can create a coroutine with the <strong class="source inline">async</strong> and <strong class="source inline">launch</strong> keywords. The <strong class="source inline">launch</strong> keyword creates a <a id="_idIndexMarker1204"/>coroutine and doesn’t return anything. On the other hand, the <strong class="source inline">async</strong> keyword returns a value that you can get later with the <span class="No-Break"><strong class="source inline">await</strong></span><span class="No-Break"> function.</span></p>
			<p>The <strong class="source inline">async</strong> and <strong class="source inline">launch</strong> keywords must be created from <strong class="source inline">CoroutineScope</strong>, which defines the lifecycle of the coroutine. For example, the coroutine scope for the main thread is <strong class="source inline">MainScope</strong>. You can then create coroutines with <span class="No-Break">the following:</span></p>
			<pre class="source code">
MainScope().async { ... }
MainScope().launch { ... }</pre>
			<p>You can also create your own <strong class="source inline">CoroutineScope</strong> instead of using <strong class="source inline">MainScope</strong> by creating one with <strong class="source inline">CoroutineScope</strong> and passing in the context for the coroutine. For example, to create <strong class="source inline">CoroutineScope</strong> for use on a network call, you can define <span class="No-Break">the following:</span></p>
			<pre class="source code">
val scope = CoroutineScope(Dispatchers.IO)</pre>
			<p>The coroutine can be canceled when the function is no longer needed, such as when you close the activity. You can do that by calling the <strong class="source inline">cancel</strong> function <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">CoroutineScope</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
scope.cancel()</pre>
			<p>A ViewModel also has a default <strong class="source inline">CoroutineScope</strong> for creating coroutines: <strong class="source inline">viewModelScope</strong>. Jetpack’s LifeCycle also has the <strong class="source inline">lifecycleScope</strong> that you can use. <strong class="source inline">viewModelScope</strong> is canceled when the ViewModel has been destroyed; <strong class="source inline">lifecycleScope</strong> is also canceled <a id="_idIndexMarker1205"/>when the lifecycle is destroyed. Thus, you no longer need to <span class="No-Break">cancel them.</span></p>
			<p>In the next section, you will learn how to add coroutines to <span class="No-Break">your p<a id="_idTextAnchor761"/>roject.</span><a id="_idTextAnchor762"/></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor763"/>Adding coroutines to your project</h2>
			<p>You can add <a id="_idIndexMarker1206"/>coroutines to your project by adding the following code to your <strong class="source inline">app/build.gradle</strong> <span class="No-Break">file dependencies:</span></p>
			<pre class="source code">
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-core:1.6.4'
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-android:1.6.4'</pre>
			<p><strong class="source inline">kotlinx-coroutines-core</strong> is the main library for coroutines, while <strong class="source inline">kotlinx-coroutines-android</strong> adds support for the main <span class="No-Break">Android thread.</span></p>
			<p>You can add coroutines in Android when making a network call or fetching data from a <span class="No-Break">local database.</span></p>
			<p>If you’re using Retrofit 2.6.0 or above, you can mark the endpoint function as a suspending function <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">suspend</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@GET("movie/latest")
suspend fun getMovies() : List&lt;Movies&gt;</pre>
			<p>Then, you can create a coroutine to call the suspending <strong class="source inline">getMovies</strong> function and display <span class="No-Break">the list:</span></p>
			<pre class="source code">
CoroutineScope(Dispatchers.IO).launch {
    val movies = movieService.getMovies()
    withContext(Dispatchers.Main) {
        displayMovies(movies)
    }
}</pre>
			<p>You can also use LiveData for the response of your coroutines. <strong class="source inline">LiveData</strong> is a Jetpack class that can hold observable data. You can add <strong class="source inline">LiveData</strong> to your Android project by adding the <a id="_idIndexMarker1207"/><span class="No-Break">following dependency:</span></p>
			<pre class="source code">
implementation 'androidx.lifecycle:
lifecycle-livedata-ktx:2.5.1'</pre>
			<p>Let’s try to use coroutines in an <span class="No-Break">Android<a id="_idTextAnchor764"/> projec<a id="_idTextAnchor765"/>t.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor766"/>Exercise 14.01 – using coroutines in an Android app</h2>
			<p>For this <a id="_idIndexMarker1208"/>chapter, you will work with an application that <a id="_idIndexMarker1209"/>displays popular movies using The Movie Database API. Go to <a href="https://developers.themoviedb.org">https://developers.themoviedb.org</a> and register for an API key. In this exercise, you will be using coroutines to fetch a list of <span class="No-Break">popular movies:</span></p>
			<ol>
				<li>Open the <strong class="source inline">Popular Movies</strong> project in Android Studio in the <strong class="source inline">Chapter14</strong> directory from this book's <span class="No-Break">code repository.</span></li>
				<li>Open the <strong class="source inline">AndroidManifest.xml</strong> file and add the <strong class="source inline">INTERNET</strong> permission inside the manifest tag but outside the <span class="No-Break">application tag:</span><pre class="source code">
&lt;uses-permission android:name="android.permission
.INTERNET" /&gt;</pre></li>
				<li>Open the <strong class="source inline">app/build.gradle</strong> file and add the dependencies for the <span class="No-Break">Kotlin Coroutines:</span><pre class="source code">
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-core:1.6.4'
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-android:1.6.4'</pre></li>
			</ol>
			<p>These will allow you to use coroutines in <span class="No-Break">your project.</span></p>
			<ol>
				<li value="4">Also, add the dependencies for the ViewModel and <strong class="source inline">LiveData</strong> <span class="No-Break">extension libraries:</span><pre class="source code">
implementation 'androidx.lifecycle:
    lifecycle-livedata-ktx:2.5.1'
implementation 'androidx.lifecycle:
    lifecycle-viewmodel-ktx:2.5.1'</pre></li>
				<li>Open the <strong class="source inline">MovieService</strong> interface and replace it with the <span class="No-Break">following code:</span><pre class="source code">
interface MovieService {
    @GET("movie/popular")
    suspend fun getPopularMovies(@Query("api_key")
    apiKey: String): PopularMoviesResponse
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1210"/>mark <strong class="source inline">getPopularMovies</strong> as a <a id="_idIndexMarker1211"/><span class="No-Break">suspending function.</span></p>
			<ol>
				<li value="6">Open <strong class="source inline">MovieRepository</strong> and add <strong class="source inline">apiKey</strong> (with the value from the Movie <span class="No-Break">Database API):</span><pre class="source code">
private val apiKey = "your_api_key_here"</pre></li>
				<li>In the <strong class="source inline">MovieRepository</strong> file, add the movies and error <strong class="source inline">LiveData</strong> for the list <span class="No-Break">of movies:</span><pre class="source code">
    private val movieLiveData =
        MutableLiveData&lt;List&lt;Movie&gt;&gt;()
    private val errorLiveData =
        MutableLiveData&lt;String&gt;()
    val movies: LiveData&lt;List&lt;Movie&gt;&gt;
        get() = movieLiveData
    val error: LiveData&lt;String&gt;
        get() = errorLiveData</pre></li>
				<li>Add the suspending <strong class="source inline">fetchMovies</strong> function to retrieve the list from <span class="No-Break">the endpoint:</span><pre class="source code">
    suspend fun fetchMovies() {
        try {
            val popularMovies =
                movieService.getPopularMovies(apiKey)
            movieLiveData.postValue(popularMovies
                .results)
        } catch (exception: Exception) {
            errorLiveData.postValue(
            "An error occurred: ${exception.message}")
        }
    }</pre></li>
				<li>Open <strong class="source inline">MovieApplication</strong> and <a id="_idIndexMarker1212"/>add a property <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">movieRepository</strong></span><span class="No-Break">:</span><pre class="source code">
class MovieApplication: Application() {
    lateinit var movieRepository: MovieRepository
}</pre></li>
				<li>Override <a id="_idIndexMarker1213"/>the <strong class="source inline">onCreate</strong> function of the <strong class="source inline">MovieApplication</strong> class and <span class="No-Break">initialize </span><span class="No-Break"><strong class="source inline">movie</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">Repository</strong></span><span class="No-Break">:</span><pre class="source code">
override fun onCreate() {
    super.onCreate()
    val retrofit = Retrofit.Builder()
        .baseUrl("https://api.themoviedb.org/3/")
        .addConverterFactory(
        MoshiConverterFactory.create())
        .build()
    val movieService = retrofit.create(
        MovieService::class.java)
    movieRepository = MovieRepository(movieService)
}</pre></li>
				<li>Update <a id="_idIndexMarker1214"/>the contents of <strong class="source inline">MovieViewModel</strong> with <a id="_idIndexMarker1215"/>the <span class="No-Break">following code:</span><pre class="source code">
    init {
        fetchPopularMovies()
    }
    val popularMovies: LiveData&lt;List&lt;Movie&gt;&gt;
    get() = movieRepository.movies
    val error: LiveData&lt;String&gt; =
        movieRepository.error
    private fun fetchPopularMovies() {
        viewModelScope.launch(Dispatchers.IO)  {
            movieRepository.fetchMovies()
        }
    }</pre></li>
			</ol>
			<p>The <strong class="source inline">fetchPopularMovies</strong> function has a coroutine, using <strong class="source inline">viewModelScope</strong>, that will fetch the movies <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">movieRepository</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="12">Open the <strong class="source inline">MainActivity</strong> class. At the end of the <strong class="source inline">onCreate</strong> function, <span class="No-Break">create </span><span class="No-Break"><strong class="source inline">movie</strong></span><strong class="source inline">
Repository</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">movieViewModel</strong></span><span class="No-Break">:</span><pre class="source code">
val movieRepository =
    (application as MovieApplication).movieRepository
val movieViewModel =
    ViewModelProvider(
    this, object: ViewModelProvider.Factory {
    override fun &lt;T : ViewModel&gt; create(modelClass:
    Class&lt;T&gt;): T {
        return MovieViewModel(movieRepository) as T
    }
})[MovieViewModel::class.java]</pre></li>
				<li>After <a id="_idIndexMarker1216"/>that, add <a id="_idIndexMarker1217"/>an observer to <strong class="source inline">popularMovies</strong> and <strong class="source inline">error</strong> <strong class="source inline">LiveData</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">movie</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">:</span><pre class="source code">
        movieViewModel.popularMovies.observe(this) {
        popularMovies -&gt;
            movieAdapter.addMovies(popularMovies
                .filter {
                    it.releaseDate.startsWith(
                        Calendar.getInstance()
                        .get(Calendar.YEAR)
                        .toString()
                    )
                }
                .sortedByDescending { it.popularity }
            )
        }
        movieViewModel.error.observe(this) { error -&gt;
            if (error.isNotEmpty()) Snackbar.make(
            recyclerView, error, Snackbar
            .LENGTH_LONG).show()
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1218"/>update the activity’s RecyclerView with <a id="_idIndexMarker1219"/>the movies fetched. The list of movies is filtered using Kotlin’s <strong class="source inline">filter</strong> function to only include movies released this year. They are then sorted by popularity using Kotlin’s <span class="No-Break"><strong class="source inline">sortedByDescending</strong></span><span class="No-Break"> function.</span></p>
			<ol>
				<li value="14">Run the application. You will see that the app will display a list of popular movie titles from the current year, <a id="_idTextAnchor767"/>sorted <span class="No-Break">by popularity:</span></li>
			</ol>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/B19411_14_01.jpg" alt="Figure 14.1 – The app displaying popular movies released this year, sorted by popularity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The app displaying popular movies released this year, sorted by popularity</p>
			<ol>
				<li value="15">Click on <a id="_idIndexMarker1220"/>a movie, and you will see its details, such as <a id="_idIndexMarker1221"/>its release date and <span class="No-Break">an overview:</span></li>
			</ol>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B19411_14_02.jpg" alt="Figure 14.2 – The movie details screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – The movie details screen</p>
			<p>You have <a id="_idIndexMarker1222"/>used coroutines and <strong class="source inline">LiveData</strong> to retrieve <a id="_idIndexMarker1223"/>and display a list of popular movies from a remote data source without blocking the <span class="No-Break">main thread.</span></p>
			<p>Before passing <strong class="source inline">LiveData</strong> into the UI for display, you can also transform the data first. You will learn about th<a id="_idTextAnchor768"/>at in th<a id="_idTextAnchor769"/>e <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor770"/>Transforming LiveData</h1>
			<p>Sometimes, the <strong class="source inline">LiveData</strong> you pass <a id="_idIndexMarker1224"/>from the ViewModel to the UI layer needs to be processed first before displaying. For example, you can only select a part of the data or do some processing on it first. In the previous exercise, you filtered the data to only select popular movies from the <span class="No-Break">current year.</span></p>
			<p>To modify <strong class="source inline">LiveData</strong>, you can use the <strong class="source inline">Transformations</strong> class. It has two functions, <strong class="source inline">Transformations.map</strong> and <strong class="source inline">Transformations.switchMap</strong>, that you <span class="No-Break">can use.</span></p>
			<p><strong class="source inline">Transformations.map</strong> modifies the value of <strong class="source inline">LiveData</strong> into another value. This can be used for tasks such as filtering, sorting, or formatting the data. For example, you can transform <strong class="source inline">movieLiveData</strong> into string <strong class="source inline">LiveData</strong> from the <span class="No-Break">movie’s title:</span></p>
			<pre class="source code">
private val movieLiveData: LiveData&lt;Movie&gt;
val movieTitleLiveData : LiveData&lt;String&gt; =
    Transformations.map(movieLiveData) { it.title }</pre>
			<p>When <strong class="source inline">movieLiveData</strong> changes value, <strong class="source inline">movieTitleLiveData</strong> will also change based on the <span class="No-Break">movie’s title.</span></p>
			<p>With <strong class="source inline">Transformations.switchMap</strong>, you can transform the value of a <strong class="source inline">LiveData</strong> into another <strong class="source inline">LiveData</strong>. This is used when you want to do a specific task involving a database or network <a id="_idIndexMarker1225"/>operation with the original <strong class="source inline">LiveData</strong>. For example, if you have a <strong class="source inline">LiveData</strong> representing a movie <strong class="source inline">id</strong> object, you can transform that into movie <strong class="source inline">LiveData</strong> by applying the <strong class="source inline">getMovieDetails</strong> function, which returns <strong class="source inline">LiveData</strong> of movie details from the <strong class="source inline">id</strong> object (such as from another network or <span class="No-Break">database call):</span></p>
			<pre class="source code">
private val idLiveData: LiveData&lt;Int&gt; = MutableLiveData()
val movieLiveData : LiveData&lt;Movie&gt; =
    Transformations.switchMap(idLiveData) {
    getMovieDetails(it) }
fun getMovieDetails(id: Int) : LiveData&lt;Movie&gt; = { ... }</pre>
			<p>Let’s use <strong class="source inline">LiveData</strong> transformations on the list of movies <a id="_idTextAnchor771"/>fetched <a id="_idTextAnchor772"/><span class="No-Break">using coroutines.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor773"/>Exercise 14.02 – LiveData transformations</h2>
			<p>In this exercise, you will <a id="_idIndexMarker1226"/>transform the <strong class="source inline">LiveData</strong> list of movies before passing them to the observers in the <span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break"> file:</span></p>
			<ol>
				<li>Open the <strong class="source inline">Popular Movies</strong> project you worked on in the previous exercise in <span class="No-Break">Android Studio.</span></li>
				<li>Open the <strong class="source inline">MainActivity</strong> file. In the <strong class="source inline">movieViewModel.popularMovies</strong> observer <a id="_idIndexMarker1227"/>in the <strong class="source inline">onCreate</strong> function, remove the filter and the <strong class="source inline">sortedByDescending</strong> function calls. The code should look like <span class="No-Break">the following:</span><pre class="source code">
movieViewModel.getPopularMovies().observe(this,
Observer { popularMovies -&gt;
    movieAdapter.addMovies(popularMovies)
})</pre></li>
			</ol>
			<p>This will now display all movies in the list without them being sorted <span class="No-Break">by popularity.</span></p>
			<ol>
				<li value="3">Run the application. You should see all movies (even those from the past year)<a id="_idTextAnchor774"/>, not sorted <span class="No-Break">by popularity:</span></li>
			</ol>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/B19411_14_03.jpg" alt="Figure 14.3 – The app with unsorted popular movies"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – The app with unsorted popular movies</p>
			<ol>
				<li value="4">Open the <strong class="source inline">MovieViewModel</strong> class and update <strong class="source inline">popularMovies</strong> with <strong class="source inline">LiveData</strong> transformations <a id="_idIndexMarker1228"/>to filter and sort <span class="No-Break">the movies:</span><pre class="source code">
        val popularMovies: LiveData&lt;List&lt;Movie&gt;&gt;
        get() = movieRepository.movies.map { list -&gt;
        list.filter {
            val cal = Calendar.getInstance()
            it.releaseDate.startsWith(
                "${cal.get(Calendar.YEAR)}"
            )
        }.sortedByDescending { it.popularity }
    }</pre></li>
			</ol>
			<p>This will select the movies released this year and sort them by title before passing them to the UI observer <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Run the <a id="_idIndexMarker1229"/>application. You will see that the app shows a list of popular movies from the current<a id="_idTextAnchor775"/> year, sorted <span class="No-Break">by popularity:</span></li>
			</ol>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B19411_14_04.jpg" alt="Figure 14.4 – The app with the movies released last month sorted by popularity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – The app with the movies released last month sorted by popularity</p>
			<p>You have used <strong class="source inline">LiveData</strong> transformations to modify the list of movies to select only the ones released in the previous month. They were also sorted by popularity before passing them to the observers in the <span class="No-Break">UI layer.</span></p>
			<p>In the next section, you wil<a id="_idTextAnchor776"/><a id="_idTextAnchor777"/><a id="_idTextAnchor778"/>l learn about <span class="No-Break">Kotlin Flows.</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor779"/>Using Flow on Android</h1>
			<p>In this section, you will look into using Flows for asynchronous programming in Android. Flow, an asynchronous <a id="_idIndexMarker1230"/>stream library built on top of Kotlin <a id="_idIndexMarker1231"/>Coroutines, is ideal for live data updates in your application. Android Jetpack libraries include Room, WorkManager, and Jetpack Compose, and third-party libraries <span class="No-Break">support Flow.</span></p>
			<p>A Flow of data is represented by the <strong class="source inline">kotlinx.coroutines.flow.Flow</strong> interface. Flows emit multiple values of the same type one at a time. For example, <strong class="source inline">Flow&lt;String&gt;</strong> is a Flow that emits <span class="No-Break">string values.</span></p>
			<p>A flow starts to emit values when you call the suspending <strong class="source inline">collect</strong> function from a coroutine or another suspending function. In the following example, the <strong class="source inline">collect</strong> function was called from the coroutine created using the <strong class="source inline">launch</strong> builder <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">lifecycleScope</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            viewModel.fetchMovies().collect { movie -&gt;
                Log.d("movies", "${movie.title}")
            }
        }
    }
}
class MovieViewModel : ViewModel() {
    ...
    fun fetchMovies(): Flow&lt;Movie&gt; { ... }
}</pre>
			<p>Here, the <strong class="source inline">collect{}</strong> function was called on <strong class="source inline">viewModel.fetchMovies()</strong>. This will start the Flow’s emission of movies; each movie title is <span class="No-Break">then logged.</span></p>
			<p>To change the <strong class="source inline">CoroutineContext</strong> where the Flow runs, you can use the <strong class="source inline">flowOn()</strong> function to <a id="_idIndexMarker1232"/>change the Dispatcher. The previous example <a id="_idIndexMarker1233"/>can be updated with a different Dispatcher, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            viewModel.fetchMovies()
            .flowOn(Dispatchers.IO)
            .collect { movie -&gt;
                Log.d("movies", "${movie.title}")
            }
        }
    }</pre>
			<p>In this example, the Dispatcher for the Flow will be changed to <strong class="source inline">Dispatchers.IO</strong>. Calling <strong class="source inline">flowOn</strong> will only change the functions before it, not the functions and <span class="No-Break">operators after.</span></p>
			<p>In the next section, you will learn about collecting Flows <span class="No-Break">on Android.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor780"/>Collecting Flows on Android</h2>
			<p>In Android, Flows are usually collected in the Activity or Fragment for display in the UI. Moving the <a id="_idIndexMarker1234"/>app in the background will not stop the <a id="_idIndexMarker1235"/>data collection. The app must not do so and continue updating the screen to avoid memory leaks and prevent <span class="No-Break">wasting resources.</span></p>
			<p>You can safely collect flows in the UI Iayer by manually handling lifecycle changes or by using <strong class="source inline">Lifecycle.repeatOnLifecycle</strong> and <strong class="source inline">Flow.flowWithLifecycle</strong>, available in the <strong class="source inline">lifecycle-runtime-ktx</strong> library, starting with <span class="No-Break">version 2.4.0.</span></p>
			<p>To use it in your project, add the following to your <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> dependencies:</span></p>
			<pre class="source code">
implementation 'androidx.lifecycle:
    lifecycle-runtime-ktx:2.4.1'</pre>
			<p>This adds the <strong class="source inline">lifecycle-runtime-ktx</strong> library to your project, so you can use both <strong class="source inline">Lifecycle.repeatOnLifecycle</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">Flow.flowWithLifecycle</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source inline">Lifecycle.repeatOnLifecycle(state, block)</strong> will suspend the parent coroutine until the lifecycle is destroyed and executes the suspending <strong class="source inline">block</strong> code when the <a id="_idIndexMarker1236"/>Lifecycle is at least in the <strong class="source inline">state</strong> provided. The flow <a id="_idIndexMarker1237"/>will stop when the Lifecycle moves out of the state and restart when the lifecycle moves back to the state. <strong class="source inline">Lifecycle.repeatOnLifecycle</strong> must be called on Activity’s <strong class="source inline">onCreate</strong> or on <span class="No-Break">Fragment’s </span><span class="No-Break"><strong class="source inline">onViewCreated</strong></span><span class="No-Break">.</span></p>
			<p>When using <strong class="source inline">Lifecycle.State.STARTED</strong> for <strong class="source inline">state</strong>, the <strong class="source inline">repeatOnLifecycle</strong> will start Flow collection when the Lifecycle is started and stop when the Lifecycle is stopped (<strong class="source inline">onStop()</strong> <span class="No-Break">is called).</span></p>
			<p>If you use <strong class="source inline">Lifecycle.State.RESUMED</strong>, the start will be when the Lifecycle is resumed, and the stop will be when <strong class="source inline">onPause</strong> is called or when the Lifecycle <span class="No-Break">is paused.</span></p>
			<p>The following example shows how you can <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">Lifecycle.repeatOnLifecycle</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.fetchMovies()
                    .collect { movie -&gt;
                        Log.d("movies", "${movie.title}")
                    }
            }
        }
    }
}</pre>
			<p>In this class, <strong class="source inline">repeatOnLifecycle</strong> with <strong class="source inline">Lifecycle.State.STARTED</strong> starts collecting the Flow <a id="_idIndexMarker1238"/>of movies when the lifecycle is started and <a id="_idIndexMarker1239"/>stops when the lifecycle <span class="No-Break">is stopped.</span></p>
			<p><strong class="source inline">Flow.flowWithLifecycle</strong> is another way to safely collect Flows in Android. It emits values from the Flow and operators preceding the call (the upstream Flow) when the lifecycle is at least in the state you set or the default, <strong class="source inline">Lifecycle.State.STARTED</strong>. Internally, it uses <strong class="source inline">Lifecycle.repeatOnLifecycle</strong>. The following example shows how you can <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">Flow.flowWithLifecycle</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            viewModel.fetchMovies()
                .flowWithLifecycle(lifecycle,
                Lifecycle.State.STARTED)
                .collect { movie -&gt;
                    Log.d("movies", "${movie.title}")
            }
        }
    }
}</pre>
			<p>Here, we used <strong class="source inline">flowWithLifecycle</strong> with <strong class="source inline">Lifecycle.State.STARTED</strong> to collect the Flow <a id="_idIndexMarker1240"/>of movies when the lifecycle is started and <a id="_idIndexMarker1241"/>stop when the lifecycle <span class="No-Break">is stopped.</span></p>
			<p>In the following section, you will learn how to <span class="No-Break">create Flows.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor781"/>Creating Flows with Flow Builders</h2>
			<p>You can create <a id="_idIndexMarker1242"/>Flows using the Flow Builders <a id="_idIndexMarker1243"/>from the Kotlin Flow API. The following are the Flow Builders you <span class="No-Break">can use:</span></p>
			<ul>
				<li><strong class="source inline">flow{}</strong>: This creates <a id="_idIndexMarker1244"/>a new Flow from a suspendable lambda block. You can send values using the <span class="No-Break"><strong class="source inline">emit</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="source inline">flowOf()</strong>: This creates <a id="_idIndexMarker1245"/>a Flow from the specified value or the <span class="No-Break"><strong class="source inline">vararg</strong></span><span class="No-Break"> values.</span></li>
				<li><strong class="source inline">asFlow()</strong>: This is an <a id="_idIndexMarker1246"/>extension function used to convert a type (sequence, array, range, or collection) into <span class="No-Break">a Flow.</span></li>
			</ul>
			<p>The following example shows how to use the Flow Builders in <span class="No-Break">an application:</span></p>
			<pre class="source code">
class MovieViewModel : ViewModel() {
    ...
    fun fetchMovies: Flow&lt;List&lt;Movie&gt;&gt; = flow {
        fetchMovieList().forEach { movie - &gt; emit(movie) }
    }
    fun fetchTop3Titles: Flow&lt;List&lt;String&gt;&gt; {
        val movies = fetchTopMovies()
        return flowOf(movies[0].title,
            movies[1].title, movies[2].title)
    }
    fun fetchMovieIds: Flow&lt;Int&gt; {
        return fetchMovies().map { it.id }.asFlow()
    }
}</pre>
			<p>In this example, <strong class="source inline">fetchMovies</strong> created a Flow using <strong class="source inline">flow{}</strong> and emitted each movie from <a id="_idIndexMarker1247"/>the list. The <strong class="source inline">fetchTop3Titles</strong> function <a id="_idIndexMarker1248"/>uses <strong class="source inline">flowOf</strong> to create a Flow with the titles of the first three movies. Finally, <strong class="source inline">fetchMovieIds</strong> converted the list of IDs into a Flow of movie IDs using the <span class="No-Break"><strong class="source inline">asFlow</strong></span><span class="No-Break"> function.</span></p>
			<p>In the next section, you will learn about the Kotlin Flow operators you can use <span class="No-Break">with Flows.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor782"/>Using operators with Flows</h2>
			<p>There are built-in Flow operators you can use with Flows. You can collect Flows with terminal operators <a id="_idIndexMarker1249"/>and transform Flows with <span class="No-Break">intermediate operators.</span></p>
			<p>Terminal <a id="_idIndexMarker1250"/>operators, such as the <strong class="source inline">collect</strong> function used in the previous examples, are used to collect Flows. The following are the other terminal operators you <span class="No-Break">can use:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source inline">count</strong></span></li>
				<li><strong class="source inline">first</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">firstOrNull</strong></span></li>
				<li><strong class="source inline">last</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">lastOrNull</strong></span></li>
				<li><span class="No-Break"><strong class="source inline">fold</strong></span></li>
				<li><span class="No-Break"><strong class="source inline">reduce</strong></span></li>
				<li><strong class="source inline">single</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">singleOrNull</strong></span></li>
				<li><strong class="source inline">toCollection</strong>, <strong class="source inline">toList</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">toSet</strong></span></li>
			</ul>
			<p>These operators work similarly to the Kotlin <strong class="source inline">Collection</strong> function with the <span class="No-Break">same name.</span></p>
			<p>You can use <a id="_idIndexMarker1251"/>Intermediate operators to modify a Flow and <a id="_idIndexMarker1252"/>return a new one. They can also be chained. The following Intermediate operators work the same as the Kotlin collection functions with the <span class="No-Break">same name:</span></p>
			<ul>
				<li><strong class="source inline">filter</strong>, <strong class="source inline">filterNot</strong>, <strong class="source inline">filterNotNull</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">filterIsInstance</strong></span></li>
				<li><strong class="source inline">map</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">mapNotNull</strong></span></li>
				<li><span class="No-Break"><strong class="source inline">onEach</strong></span></li>
				<li><strong class="source inline">runningReduce</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">runningFold</strong></span></li>
				<li><span class="No-Break"><strong class="source inline">withIndex</strong></span></li>
			</ul>
			<p>Additionally, there is a <strong class="source inline">transform</strong> operator you can use to apply your own operation. For example, this class has a Flow that uses the <span class="No-Break"><strong class="source inline">transform</strong></span><span class="No-Break"> operator:</span></p>
			<pre class="source code">
class MovieViewModel : ViewModel() {
    ...
    fun fetchTopRatedMovie(): Flow&lt;Movie&gt; {
        return fetchMoviesFlow()
            .transform {
                if(it.voteAverage &gt; 0.6f) emit(it)
            }
    }
}</pre>
			<p>Here, the <strong class="source inline">transform</strong> operator was used in the Flow of movies to only emit the ones whose <strong class="source inline">voteAverage</strong> is higher than <span class="No-Break"><strong class="source inline">0.6</strong></span><span class="No-Break"> (60%).</span></p>
			<p>There are <a id="_idIndexMarker1253"/>also size-limiting Kotlin Flow operators such as <strong class="source inline">drop</strong>, <strong class="source inline">dropWhile</strong>, <strong class="source inline">take</strong>, and <strong class="source inline">takeWhile</strong>, which function similarly to the Kotlin <a id="_idIndexMarker1254"/>collection functions of the <span class="No-Break">same name.</span></p>
			<p>Let’s add Kotlin Flow into an <span class="No-Break">Android project.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor783"/>Exercise 14.03 – using Flow in an Android application</h2>
			<p>In this <a id="_idIndexMarker1255"/>exercise, you will update the Popular Movies <a id="_idIndexMarker1256"/>app to use Kotlin Flow in fetching the list <span class="No-Break">of movies:</span></p>
			<ol>
				<li>Open the Popular Movies project from the previous exercise in <span class="No-Break">Android Studio.</span></li>
				<li>Go to the <strong class="source inline">MovieRepository</strong> class and remove the <strong class="source inline">movies</strong> and <strong class="source inline">error</strong> <strong class="source inline">LiveData</strong>. Then, replace the <strong class="source inline">fetchMovies</strong> function with <span class="No-Break">the following:</span><pre class="source code">
    fun fetchMovies(): Flow&lt;List&lt;Movie&gt;&gt; {
        return flow {
            emit(movieService
            .getPopularMovies(apiKey).results)
        }.flowOn(Dispatchers.IO)
    }</pre></li>
			</ol>
			<p>This changes the <strong class="source inline">fetchMovies</strong> function to use Kotlin Flow. The Flow will emit the list of movies from <strong class="source inline">movieService.getPopularMovies</strong>, and it will flow on the <span class="No-Break"><strong class="source inline">Dispatchers.IO</strong></span><span class="No-Break"> dispatcher.</span></p>
			<ol>
				<li value="3">Open the <strong class="source inline">MovieViewModel</strong> class. In the class declaration, add a dispatcher parameter with a default value <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">Dispatchers.IO</strong></span><span class="No-Break">:</span><pre class="source code">
class MovieViewModel(
    private val movieRepository: MovieRepository,
    private val dispatcher: CoroutineDispatcher =
        Dispatchers.IO
) : ViewModel() {
    ...
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1257"/>be the dispatcher that will be <a id="_idIndexMarker1258"/>used later for <span class="No-Break">the Flow.</span></p>
			<ol>
				<li value="4">Replace the <strong class="source inline">popularMovies</strong> <strong class="source inline">LiveData</strong> with <span class="No-Break">the following:</span><pre class="source code">
private val _popularMovies = MutableStateFlow(
    emptyList&lt;Movie&gt;())
val popularMovies: StateFlow&lt;List&lt;Movie&gt;&gt; =
    _popularMovies</pre></li>
			</ol>
			<p>You will use these for the value of the list of movies from <strong class="source inline">MovieRepository</strong>. <strong class="source inline">StateFlow</strong> is an observable Flow that emits state updates to the collectors, while <strong class="source inline">MutableStateFlow</strong> is a <strong class="source inline">StateFlow</strong> that you can change the value. In Android, <strong class="source inline">StateFlow</strong> can be an alternative <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Remove the <strong class="source inline">error</strong> <strong class="source inline">LiveData</strong> and replace it with <span class="No-Break">the following:</span><pre class="source code">
private val _error = MutableStateFlow("")
val error: StateFlow&lt;List&lt;String&gt;&gt; =_error</pre></li>
			</ol>
			<p>You will use these for handling when the Flow encounters <span class="No-Break">an exception.</span></p>
			<ol>
				<li value="6">Change the content of the <strong class="source inline">fetchPopularMovies</strong> function with <span class="No-Break">the following:</span><pre class="source code">
private fun fetchPopularMovies() {
    viewModelScope.launch(dispatcher) {
        movieRepository.fetchMovies().catch {
            _error.value =
                "An exception occurred:
                ${it.message}"
        }.collect {
            _popularMovies.value = it
        }
    }
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1259"/>collect the list of movies from <strong class="source inline">movieRepository</strong> and set it to <strong class="source inline">MutableStateFlow</strong> in <strong class="source inline">_popularMovies</strong>  (and <strong class="source inline">StateFlow</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">popularMovies</strong></span><span class="No-Break">).</span></p>
			<ol>
				<li value="7">Open <a id="_idIndexMarker1260"/>the <strong class="source inline">app/build.gradle</strong> file and add the following in <span class="No-Break">the dependencies:</span><pre class="source code">
implementation 'androidx.lifecycle:
lifecycle-runtime-ktx:2.5.1'</pre></li>
			</ol>
			<p>This allows you to use <strong class="source inline">lifecycleScope</strong> for collecting the Flows <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">MainActivity</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="8">Go to the <strong class="source inline">MainActivity</strong> file and remove the lines of code for observing <strong class="source inline">popularMovies</strong> and <strong class="source inline">error</strong> from <strong class="source inline">MovieViewModel</strong>. Add the following to collect the Flow <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">MovieViewModel</strong></span><span class="No-Break">:</span><pre class="source code">
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        launch {
            movieViewModel.popularMovies.collect {
                movies -&gt;movieAdapter.addMovies(
                movies)
            }
        }
        launch {
            movieViewModel.error.collect { error -&gt;
                if (error.isNotEmpty()) Snackbar
                .make(recyclerView, error, Snackbar
                .LENGTH_LONG).show()
            }
        }
    }
}</pre></li>
				<li>Run the <a id="_idIndexMarker1261"/>application. The app will display <a id="_idIndexMarker1262"/>the list of movies, as shown in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/B19411_14_011.jpg" alt="Figure 14.5 – The app displaying popular movies"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – The app displaying popular movies</p>
			<p>In this <a id="_idIndexMarker1263"/>exercise, you added Kotlin Flow to an <a id="_idIndexMarker1264"/>Android project. <strong class="source inline">MovieRepository</strong> returns the list of movies as a Flow, which was collected in <strong class="source inline">MovieViewModel</strong>. <strong class="source inline">MovieViewModel</strong> uses <strong class="source inline">StateFlow</strong>, which was then collected in <strong class="source inline">MainActivity</strong> for di<a id="_idTextAnchor784"/><a id="_idTextAnchor785"/>splaying <span class="No-Break">in RecyclerView.</span></p>
			<p>Let’s move on to the <span class="No-Break">next activity.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor786"/>Activity 14.01 – creating a TV Guide app</h2>
			<p>A lot of people watch television. Most of the time, though, they are not sure what TV shows are <a id="_idIndexMarker1265"/>currently airing. Suppose you wanted to develop an app that can display a list of these shows from the Movie Database API’s <strong class="source inline">tv/on_the_air</strong> endpoint using <span class="No-Break">Kotlin Flow.</span></p>
			<p>The app will have two screens: the main screen and the details screen. On the main screen, you will display a list of the TV shows that are on the air. The TV shows will be sorted by name. Clicking on a TV show will open the details screen, which displays more information about the selected <span class="No-Break">TV show.</span></p>
			<p>The following steps are for the completion of <span class="No-Break">the activity:</span></p>
			<ol>
				<li>Create a new project in Android Studio and name it <strong class="source inline">TV Guide</strong>. Set its <span class="No-Break">package name.</span></li>
				<li>Add the <strong class="source inline">INTERNET</strong> permission in the <span class="No-Break"><strong class="source inline">AndroidManifest.xml</strong></span><span class="No-Break"> file.</span></li>
				<li>Add the dependencies for Retrofit, Coroutines, Moshi, Lifecycle, and other libraries in your <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file.</span></li>
				<li>Add a <strong class="source inline">layout_margin</strong> <span class="No-Break">dimension value.</span></li>
				<li>Create a <strong class="source inline">view_tv_show_item.xml</strong> layout file with <strong class="source inline">ImageView</strong> for the poster and <strong class="source inline">TextView</strong> for the name of the <span class="No-Break">TV show.</span></li>
				<li>In the <strong class="source inline">activity_main.xml</strong> file, remove the <strong class="source inline">Hello World</strong> TextView and add a RecyclerView to the list of <span class="No-Break">TV shows.</span></li>
				<li>Create a <strong class="source inline">TVShow</strong> <span class="No-Break">model class.</span></li>
				<li>Create another class named <strong class="source inline">TVResponse</strong> for the response you get from the API endpoint for the TV shows <span class="No-Break">on air.</span></li>
				<li>Create a new activity named <strong class="source inline">DetailsActivity</strong> with <strong class="source inline">activity_details.xml</strong> as the <span class="No-Break">layout file.</span></li>
				<li>Open the <strong class="source inline">AndroidManifest.xml</strong> file and add the <strong class="source inline">parentActivityName</strong> attribute in the <span class="No-Break"><strong class="source inline">DetailsActivity</strong></span><span class="No-Break"> declaration.</span></li>
				<li>In <strong class="source inline">activity_details.xml</strong>, add the views for the details of the <span class="No-Break">TV show.</span></li>
				<li>Open <strong class="source inline">DetailsActivity</strong> and add the code to display the details of the TV <span class="No-Break">show selected.</span></li>
				<li>Create a <strong class="source inline">TVShowAdapter</strong> adapter class for the list of <span class="No-Break">TV shows.</span></li>
				<li>Create a <strong class="source inline">TelevisionService</strong> class for adding the <span class="No-Break"><strong class="source inline">Retrofit</strong></span><span class="No-Break"> method.</span></li>
				<li>Create a <strong class="source inline">TVShowRepository</strong> class with a constructor for <strong class="source inline">tvService</strong>, and properties for <strong class="source inline">apiKey</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">tvShows</strong></span><span class="No-Break">.</span></li>
				<li>Create a <a id="_idIndexMarker1266"/>function to retrieve the list of TV shows from <span class="No-Break">the endpoint.</span></li>
				<li>Create a <strong class="source inline">TVShowViewModel</strong> class with a constructor for <strong class="source inline">TVShowRepository</strong>. Add the <strong class="source inline">tvShows</strong> and <strong class="source inline">error</strong> StateFlow and a <strong class="source inline">fetchTVShows</strong> function that collects the Flow from <span class="No-Break">the repository.</span></li>
				<li>Create an application class named <strong class="source inline">TVApplication</strong> with a property <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">TVShowRepository</strong></span><span class="No-Break">.</span></li>
				<li>Set <strong class="source inline">TVApplication</strong> as the value for the application in the <span class="No-Break"><strong class="source inline">AndroidManifest.xml</strong></span><span class="No-Break"> file.</span></li>
				<li>Open <strong class="source inline">MainActivity</strong> and add the code to update the RecyclerView when the Flow from <strong class="source inline">ViewModel</strong> updates its value. Add a function that will open the details screen when clicking on a TV show from <span class="No-Break">the list.</span></li>
				<li>Run your application. The app will display a list of TV shows. Clicking on a TV show will open the details activity, which displays the show details. The main screen <a id="_idTextAnchor787"/>and details screen will be similar to the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/B19411_14_05.jpg" alt="Figure 14.6 – The main screen and details screen of the TV Guide app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – The main screen and details screen of the TV Guide app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution <a id="_idIndexMarker1267"/>to this activity can be found <span class="No-Break">at </span><a href="https://packt.link/By7eE"><span class="No-Break">https://packt.link/By7eE</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor788"/>Summary</h1>
			<p>This chapter focused on doing background operations with Coroutines and Flow. Background operations are used for long-running tasks such as accessing data from the local database or a <span class="No-Break">remote server.</span></p>
			<p>You started with the basics of using Kotlin coroutines, Google’s recommended solution for asynchronous programming. You learned that you can make a background task into a suspending function with the <strong class="source inline">suspend</strong> keyword. Coroutines can be started with the <strong class="source inline">async</strong> or <span class="No-Break"><strong class="source inline">launch</strong></span><span class="No-Break"> keywords.</span></p>
			<p>You learned how to create suspending functions and how to start coroutines. You also used dispatchers to change the thread where a coroutine runs. Then, you used coroutines for performing network calls and modified the data retrieved with the <strong class="source inline">map</strong> and <strong class="source inline">switchMap</strong> <strong class="source inline">LiveData</strong> <span class="No-Break">transformation functions.</span></p>
			<p>You then moved on to using Kotlin Flow in an Android app to load the data in the background. To safely collect flows in the UI layer, prevent memory leaks, and avoid wasting resources, you can use <strong class="source inline">Lifecycle.repeatOnLifecycle</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">Flow.flowWithLifecycle</strong></span><span class="No-Break">.</span></p>
			<p>You learned about using Flow Builders to create Flows. The <strong class="source inline">flow</strong> builder function creates a new Flow from a suspending lambda block and then you can send values with <strong class="source inline">emit()</strong>. The <strong class="source inline">flowOf</strong> function creates a Flow that emits the value or the <strong class="source inline">vararg</strong> values. You can use the <strong class="source inline">asFlow()</strong> extension function to convert collections and functional types into <span class="No-Break">a Flow.</span></p>
			<p>Finally, you explored Flow operators and learned how to use them with Kotlin Flows. Terminal operators are used to start the collection of the Flow. With Intermediate operators, you can transform a Flow into <span class="No-Break">another Flow.</span></p>
			<p>In the next chapter, you will learn about architecture patterns. You will learn about patterns such as <strong class="bold">Model-View-ViewModel </strong>(<strong class="bold">MVVM</strong>) and how you can improve the architecture of <span class="No-Break">your app.</span></p>
		</div>
	</body></html>