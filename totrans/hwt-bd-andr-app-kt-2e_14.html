<html><head></head><body>
		<div><h1 id="_idParaDest-231" class="chapter number"><a id="_idTextAnchor751"/>14</h1>
			<h1 id="_idParaDest-232">Coroutines and Flow<a id="_idTextAnchor752"/></h1>
			<p>This chapter introduces you to background operations and data manipulations with Coroutines and Flow. You’ll also learn how to manipulate and display the data using <code>LiveData</code> transformations and Kotlin Flow operators.</p>
			<p>By the end of this chapter, you will be able to use Coroutines and Flow to manage network calls in the background. You will also be able to manipulate data with <code>LiveData</code> transformations and Flow operators.<a id="_idTextAnchor753"/></p>
			<p>You learned the basics of Android app development and implemented features such as RecyclerViews, notifications, fetching data from web services, and services. You also gained skills in the best practices for testing and persisting data. In the previous chapter, you learned about dependency injection. Now, you will learn about background operations and data manipulation.</p>
			<p>Some Android applications work on their own. However, most apps would need a backend server to retrieve or process data. These operations may take a while, depending on the internet connection, device settings, and server specifications. If long-running operations are run <a id="_idIndexMarker1199"/>in the main <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) thread, the application will be blocked until the tasks are completed. The application might become unresponsive and prompt the user to close and stop using it.</p>
			<p>To avoid this, tasks that can take an indefinite amount of time must be run asynchronously. An asynchronous task means it can run in parallel to another task or in the background. For example, while fetching data from a data source asynchronously, your UI can still be displayed and user interaction can occur.</p>
			<p>You can use libraries such as Coroutines and Flow for asynchronous operations. We’ll discuss both in this chapter.<a id="_idTextAnchor754"/><a id="_idTextAnchor755"/></p>
			<p>We will cover the following key topics in this chapter:</p>
			<ul>
				<li>Using Coroutines on Android</li>
				<li>Transforming <code>LiveData</code></li>
				<li>Using Flow on Androi<a id="_idTextAnchor756"/>d</li>
			</ul>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor757"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/puLUO">https://packt.link/puLUO</a></p>
			<p>Let’s get started with Coroutines.</p>
			<h1 id="_idParaDest-234">Using Corou<a id="_idTextAnchor758"/>tines on Android</h1>
			<p>Coroutines were added in Kotlin 1.3 to manage background tasks such as making network calls and <a id="_idIndexMarker1200"/>accessing files or databases. Kotlin coroutines are Google’s official recommendation for asynchronous programming on Android. Their <a id="_idIndexMarker1201"/>Jetpack libraries, such as LifeCycle, WorkManager, and Room, now include support for coroutines.</p>
			<p>With coroutines, you can write your code in a sequential way. The long-running task can be made into a suspending function, which, when called, can pause the thread without blocking it. When the suspending function is done, the current thread will resume execution. This will make your code easier to read and debug.</p>
			<p>To mark a function as a suspending function, you can add the <code>suspend</code> keyword to it; for example, if you have a function that calls the <code>getMovies</code> function, which fetches <code>movies</code> from your endpoint and then displays it:</p>
			<pre class="source code">
val movies = getMovies()
displayMovies(movies)</pre>
			<p>You can make the <code>getMovies()</code> function a suspending function by adding the <code>suspend</code> keyword:</p>
			<pre class="source code">
suspend fun getMovies(): List&lt;Movies&gt; { ... }</pre>
			<p>Here, the calling function will invoke <code>getMovies</code> and pause. After <code>getMovies</code> returns a list of movies, it will resume its task and display the movies.</p>
			<p>Suspending functions can only be called in other suspending functions or from a coroutine. Coroutines have a context, which includes the coroutine dispatcher. Dispatchers specify what thread the coroutine will use. There are three dispatchers you can use:</p>
			<ul>
				<li><code>Dispatchers.Main</code>: Used to run on Android’s main thread</li>
				<li><code>Dispatchers.IO</code>: Used for network, file, or database operations</li>
				<li><code>Dispatchers.Default</code>: Used for CPU-intensive work</li>
			</ul>
			<p>To change the context for your coroutine, you can use the <code>withContext</code> function for the code that you want to use a different thread with. For example, in your suspending function, <code>getMovies</code>, which gets <a id="_idIndexMarker1202"/>movies from your endpoint, you <a id="_idIndexMarker1203"/>can use <code>Dispatchers.IO</code>:</p>
			<pre class="source code">
suspend fun getMovies(): List&lt;Movies&gt;  {
    withContext(Dispatchers.IO) { ... }
}</pre>
			<p>In the next section, we will cover how to create corout<a id="_idTextAnchor759"/>ines.</p>
			<h2 id="_idParaDest-235">C<a id="_idTextAnchor760"/>reating coroutines</h2>
			<p>You can create a coroutine with the <code>async</code> and <code>launch</code> keywords. The <code>launch</code> keyword creates a <a id="_idIndexMarker1204"/>coroutine and doesn’t return anything. On the other hand, the <code>async</code> keyword returns a value that you can get later with the <code>await</code> function.</p>
			<p>The <code>async</code> and <code>launch</code> keywords must be created from <code>CoroutineScope</code>, which defines the lifecycle of the coroutine. For example, the coroutine scope for the main thread is <code>MainScope</code>. You can then create coroutines with the following:</p>
			<pre class="source code">
MainScope().async { ... }
MainScope().launch { ... }</pre>
			<p>You can also create your own <code>CoroutineScope</code> instead of using <code>MainScope</code> by creating one with <code>CoroutineScope</code> and passing in the context for the coroutine. For example, to create <code>CoroutineScope</code> for use on a network call, you can define the following:</p>
			<pre class="source code">
val scope = CoroutineScope(Dispatchers.IO)</pre>
			<p>The coroutine can be canceled when the function is no longer needed, such as when you close the activity. You can do that by calling the <code>cancel</code> function from <code>CoroutineScope</code>:</p>
			<pre class="source code">
scope.cancel()</pre>
			<p>A ViewModel also has a default <code>CoroutineScope</code> for creating coroutines: <code>viewModelScope</code>. Jetpack’s LifeCycle also has the <code>lifecycleScope</code> that you can use. <code>viewModelScope</code> is canceled when the ViewModel has been destroyed; <code>lifecycleScope</code> is also canceled <a id="_idIndexMarker1205"/>when the lifecycle is destroyed. Thus, you no longer need to cancel them.</p>
			<p>In the next section, you will learn how to add coroutines to your p<a id="_idTextAnchor761"/>roject.<a id="_idTextAnchor762"/></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor763"/>Adding coroutines to your project</h2>
			<p>You can add <a id="_idIndexMarker1206"/>coroutines to your project by adding the following code to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source code">
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-core:1.6.4'
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-android:1.6.4'</pre>
			<p><code>kotlinx-coroutines-core</code> is the main library for coroutines, while <code>kotlinx-coroutines-android</code> adds support for the main Android thread.</p>
			<p>You can add coroutines in Android when making a network call or fetching data from a local database.</p>
			<p>If you’re using Retrofit 2.6.0 or above, you can mark the endpoint function as a suspending function with <code>suspend</code>:</p>
			<pre class="source code">
@GET("movie/latest")
suspend fun getMovies() : List&lt;Movies&gt;</pre>
			<p>Then, you can create a coroutine to call the suspending <code>getMovies</code> function and display the list:</p>
			<pre class="source code">
CoroutineScope(Dispatchers.IO).launch {
    val movies = movieService.getMovies()
    withContext(Dispatchers.Main) {
        displayMovies(movies)
    }
}</pre>
			<p>You can also use LiveData for the response of your coroutines. <code>LiveData</code> is a Jetpack class that can hold observable data. You can add <code>LiveData</code> to your Android project by adding the <a id="_idIndexMarker1207"/>following dependency:</p>
			<pre class="source code">
implementation 'androidx.lifecycle:
lifecycle-livedata-ktx:2.5.1'</pre>
			<p>Let’s try to use coroutines in an Android<a id="_idTextAnchor764"/> projec<a id="_idTextAnchor765"/>t.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor766"/>Exercise 14.01 – using coroutines in an Android app</h2>
			<p>For this <a id="_idIndexMarker1208"/>chapter, you will work with an application that <a id="_idIndexMarker1209"/>displays popular movies using The Movie Database API. Go to <a href="https://developers.themoviedb.org">https://developers.themoviedb.org</a> and register for an API key. In this exercise, you will be using coroutines to fetch a list of popular movies:</p>
			<ol>
				<li>Open the <code>Popular Movies</code> project in Android Studio in the <code>Chapter14</code> directory from this book's code repository.</li>
				<li>Open the <code>AndroidManifest.xml</code> file and add the <code>INTERNET</code> permission inside the manifest tag but outside the application tag:<pre class="source code">
&lt;uses-permission android:name="android.permission
.INTERNET" /&gt;</pre></li>
				<li>Open the <code>app/build.gradle</code> file and add the dependencies for the Kotlin Coroutines:<pre class="source code">
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-core:1.6.4'
implementation 'org.jetbrains.kotlinx:
    kotlinx-coroutines-android:1.6.4'</pre></li>
			</ol>
			<p>These will allow you to use coroutines in your project.</p>
			<ol>
				<li value="4">Also, add the dependencies for the ViewModel and <code>LiveData</code> extension libraries:<pre class="source code">
implementation 'androidx.lifecycle:
    lifecycle-livedata-ktx:2.5.1'
implementation 'androidx.lifecycle:
    lifecycle-viewmodel-ktx:2.5.1'</pre></li>
				<li>Open the <code>MovieService</code> interface and replace it with the following code:<pre class="source code">
interface MovieService {
    @GET("movie/popular")
    suspend fun getPopularMovies(@Query("api_key")
    apiKey: String): PopularMoviesResponse
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1210"/>mark <code>getPopularMovies</code> as a <a id="_idIndexMarker1211"/>suspending function.</p>
			<ol>
				<li value="6">Open <code>MovieRepository</code> and add <code>apiKey</code> (with the value from the Movie Database API):<pre class="source code">
private val apiKey = "your_api_key_here"</pre></li>
				<li>In the <code>MovieRepository</code> file, add the movies and error <code>LiveData</code> for the list of movies:<pre class="source code">
    private val movieLiveData =
        MutableLiveData&lt;List&lt;Movie&gt;&gt;()
    private val errorLiveData =
        MutableLiveData&lt;String&gt;()
    val movies: LiveData&lt;List&lt;Movie&gt;&gt;
        get() = movieLiveData
    val error: LiveData&lt;String&gt;
        get() = errorLiveData</pre></li>
				<li>Add the suspending <code>fetchMovies</code> function to retrieve the list from the endpoint:<pre class="source code">
    suspend fun fetchMovies() {
        try {
            val popularMovies =
                movieService.getPopularMovies(apiKey)
            movieLiveData.postValue(popularMovies
                .results)
        } catch (exception: Exception) {
            errorLiveData.postValue(
            "An error occurred: ${exception.message}")
        }
    }</pre></li>
				<li>Open <code>MovieApplication</code> and <a id="_idIndexMarker1212"/>add a property for <code>movieRepository</code>:<pre class="source code">
class MovieApplication: Application() {
    lateinit var movieRepository: MovieRepository
}</pre></li>
				<li>Override <a id="_idIndexMarker1213"/>the <code>onCreate</code> function of the <code>MovieApplication</code> class and initialize <code>movie</code><strong class="source inline">
</strong><code>Repository</code>:<pre class="source code">
override fun onCreate() {
    super.onCreate()
    val retrofit = Retrofit.Builder()
        .baseUrl("https://api.themoviedb.org/3/")
        .addConverterFactory(
        MoshiConverterFactory.create())
        .build()
    val movieService = retrofit.create(
        MovieService::class.java)
    movieRepository = MovieRepository(movieService)
}</pre></li>
				<li>Update <a id="_idIndexMarker1214"/>the contents of <code>MovieViewModel</code> with <a id="_idIndexMarker1215"/>the following code:<pre class="source code">
    init {
        fetchPopularMovies()
    }
    val popularMovies: LiveData&lt;List&lt;Movie&gt;&gt;
    get() = movieRepository.movies
    val error: LiveData&lt;String&gt; =
        movieRepository.error
    private fun fetchPopularMovies() {
        viewModelScope.launch(Dispatchers.IO)  {
            movieRepository.fetchMovies()
        }
    }</pre></li>
			</ol>
			<p>The <code>fetchPopularMovies</code> function has a coroutine, using <code>viewModelScope</code>, that will fetch the movies from <code>movieRepository</code>.</p>
			<ol>
				<li value="12">Open the <code>MainActivity</code> class. At the end of the <code>onCreate</code> function, create <code>movie</code><strong class="source inline">
Repository</strong> and <code>movieViewModel</code>:<pre class="source code">
val movieRepository =
    (application as MovieApplication).movieRepository
val movieViewModel =
    ViewModelProvider(
    this, object: ViewModelProvider.Factory {
    override fun &lt;T : ViewModel&gt; create(modelClass:
    Class&lt;T&gt;): T {
        return MovieViewModel(movieRepository) as T
    }
})[MovieViewModel::class.java]</pre></li>
				<li>After <a id="_idIndexMarker1216"/>that, add <a id="_idIndexMarker1217"/>an observer to <code>popularMovies</code> and <code>error</code> <code>LiveData</code> from <code>movie</code><strong class="source inline">
</strong><code>ViewModel</code>:<pre class="source code">
        movieViewModel.popularMovies.observe(this) {
        popularMovies -&gt;
            movieAdapter.addMovies(popularMovies
                .filter {
                    it.releaseDate.startsWith(
                        Calendar.getInstance()
                        .get(Calendar.YEAR)
                        .toString()
                    )
                }
                .sortedByDescending { it.popularity }
            )
        }
        movieViewModel.error.observe(this) { error -&gt;
            if (error.isNotEmpty()) Snackbar.make(
            recyclerView, error, Snackbar
            .LENGTH_LONG).show()
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1218"/>update the activity’s RecyclerView with <a id="_idIndexMarker1219"/>the movies fetched. The list of movies is filtered using Kotlin’s <code>filter</code> function to only include movies released this year. They are then sorted by popularity using Kotlin’s <code>sortedByDescending</code> function.</p>
			<ol>
				<li value="14">Run the application. You will see that the app will display a list of popular movie titles from the current year, <a id="_idTextAnchor767"/>sorted by popularity:</li>
			</ol>
			<div><div><img src="img/B19411_14_01.jpg" alt="Figure 14.1 – The app displaying popular movies released this year, sorted by popularity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The app displaying popular movies released this year, sorted by popularity</p>
			<ol>
				<li value="15">Click on <a id="_idIndexMarker1220"/>a movie, and you will see its details, such as <a id="_idIndexMarker1221"/>its release date and an overview:</li>
			</ol>
			<div><div><img src="img/B19411_14_02.jpg" alt="Figure 14.2 – The movie details screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – The movie details screen</p>
			<p>You have <a id="_idIndexMarker1222"/>used coroutines and <code>LiveData</code> to retrieve <a id="_idIndexMarker1223"/>and display a list of popular movies from a remote data source without blocking the main thread.</p>
			<p>Before passing <code>LiveData</code> into the UI for display, you can also transform the data first. You will learn about th<a id="_idTextAnchor768"/>at in th<a id="_idTextAnchor769"/>e next section.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor770"/>Transforming LiveData</h1>
			<p>Sometimes, the <code>LiveData</code> you pass <a id="_idIndexMarker1224"/>from the ViewModel to the UI layer needs to be processed first before displaying. For example, you can only select a part of the data or do some processing on it first. In the previous exercise, you filtered the data to only select popular movies from the current year.</p>
			<p>To modify <code>LiveData</code>, you can use the <code>Transformations</code> class. It has two functions, <code>Transformations.map</code> and <code>Transformations.switchMap</code>, that you can use.</p>
			<p><code>Transformations.map</code> modifies the value of <code>LiveData</code> into another value. This can be used for tasks such as filtering, sorting, or formatting the data. For example, you can transform <code>movieLiveData</code> into string <code>LiveData</code> from the movie’s title:</p>
			<pre class="source code">
private val movieLiveData: LiveData&lt;Movie&gt;
val movieTitleLiveData : LiveData&lt;String&gt; =
    Transformations.map(movieLiveData) { it.title }</pre>
			<p>When <code>movieLiveData</code> changes value, <code>movieTitleLiveData</code> will also change based on the movie’s title.</p>
			<p>With <code>Transformations.switchMap</code>, you can transform the value of a <code>LiveData</code> into another <code>LiveData</code>. This is used when you want to do a specific task involving a database or network <a id="_idIndexMarker1225"/>operation with the original <code>LiveData</code>. For example, if you have a <code>LiveData</code> representing a movie <code>id</code> object, you can transform that into movie <code>LiveData</code> by applying the <code>getMovieDetails</code> function, which returns <code>LiveData</code> of movie details from the <code>id</code> object (such as from another network or database call):</p>
			<pre class="source code">
private val idLiveData: LiveData&lt;Int&gt; = MutableLiveData()
val movieLiveData : LiveData&lt;Movie&gt; =
    Transformations.switchMap(idLiveData) {
    getMovieDetails(it) }
fun getMovieDetails(id: Int) : LiveData&lt;Movie&gt; = { ... }</pre>
			<p>Let’s use <code>LiveData</code> transformations on the list of movies <a id="_idTextAnchor771"/>fetched <a id="_idTextAnchor772"/>using coroutines.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor773"/>Exercise 14.02 – LiveData transformations</h2>
			<p>In this exercise, you will <a id="_idIndexMarker1226"/>transform the <code>LiveData</code> list of movies before passing them to the observers in the <code>MainActivity</code> file:</p>
			<ol>
				<li>Open the <code>Popular Movies</code> project you worked on in the previous exercise in Android Studio.</li>
				<li>Open the <code>MainActivity</code> file. In the <code>movieViewModel.popularMovies</code> observer <a id="_idIndexMarker1227"/>in the <code>onCreate</code> function, remove the filter and the <code>sortedByDescending</code> function calls. The code should look like the following:<pre class="source code">
movieViewModel.getPopularMovies().observe(this,
Observer { popularMovies -&gt;
    movieAdapter.addMovies(popularMovies)
})</pre></li>
			</ol>
			<p>This will now display all movies in the list without them being sorted by popularity.</p>
			<ol>
				<li value="3">Run the application. You should see all movies (even those from the past year)<a id="_idTextAnchor774"/>, not sorted by popularity:</li>
			</ol>
			<div><div><img src="img/B19411_14_03.jpg" alt="Figure 14.3 – The app with unsorted popular movies"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – The app with unsorted popular movies</p>
			<ol>
				<li value="4">Open the <code>MovieViewModel</code> class and update <code>popularMovies</code> with <code>LiveData</code> transformations <a id="_idIndexMarker1228"/>to filter and sort the movies:<pre class="source code">
        val popularMovies: LiveData&lt;List&lt;Movie&gt;&gt;
        get() = movieRepository.movies.map { list -&gt;
        list.filter {
            val cal = Calendar.getInstance()
            it.releaseDate.startsWith(
                "${cal.get(Calendar.YEAR)}"
            )
        }.sortedByDescending { it.popularity }
    }</pre></li>
			</ol>
			<p>This will select the movies released this year and sort them by title before passing them to the UI observer in <code>MainActivity</code>.</p>
			<ol>
				<li value="5">Run the <a id="_idIndexMarker1229"/>application. You will see that the app shows a list of popular movies from the current<a id="_idTextAnchor775"/> year, sorted by popularity:</li>
			</ol>
			<div><div><img src="img/B19411_14_04.jpg" alt="Figure 14.4 – The app with the movies released last month sorted by popularity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – The app with the movies released last month sorted by popularity</p>
			<p>You have used <code>LiveData</code> transformations to modify the list of movies to select only the ones released in the previous month. They were also sorted by popularity before passing them to the observers in the UI layer.</p>
			<p>In the next section, you wil<a id="_idTextAnchor776"/><a id="_idTextAnchor777"/><a id="_idTextAnchor778"/>l learn about Kotlin Flows.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor779"/>Using Flow on Android</h1>
			<p>In this section, you will look into using Flows for asynchronous programming in Android. Flow, an asynchronous <a id="_idIndexMarker1230"/>stream library built on top of Kotlin <a id="_idIndexMarker1231"/>Coroutines, is ideal for live data updates in your application. Android Jetpack libraries include Room, WorkManager, and Jetpack Compose, and third-party libraries support Flow.</p>
			<p>A Flow of data is represented by the <code>kotlinx.coroutines.flow.Flow</code> interface. Flows emit multiple values of the same type one at a time. For example, <code>Flow&lt;String&gt;</code> is a Flow that emits string values.</p>
			<p>A flow starts to emit values when you call the suspending <code>collect</code> function from a coroutine or another suspending function. In the following example, the <code>collect</code> function was called from the coroutine created using the <code>launch</code> builder of <code>lifecycleScope</code>:</p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            viewModel.fetchMovies().collect { movie -&gt;
                Log.d("movies", "${movie.title}")
            }
        }
    }
}
class MovieViewModel : ViewModel() {
    ...
    fun fetchMovies(): Flow&lt;Movie&gt; { ... }
}</pre>
			<p>Here, the <code>collect{}</code> function was called on <code>viewModel.fetchMovies()</code>. This will start the Flow’s emission of movies; each movie title is then logged.</p>
			<p>To change the <code>CoroutineContext</code> where the Flow runs, you can use the <code>flowOn()</code> function to <a id="_idIndexMarker1232"/>change the Dispatcher. The previous example <a id="_idIndexMarker1233"/>can be updated with a different Dispatcher, as shown in the following code:</p>
			<pre class="source code">
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            viewModel.fetchMovies()
            .flowOn(Dispatchers.IO)
            .collect { movie -&gt;
                Log.d("movies", "${movie.title}")
            }
        }
    }</pre>
			<p>In this example, the Dispatcher for the Flow will be changed to <code>Dispatchers.IO</code>. Calling <code>flowOn</code> will only change the functions before it, not the functions and operators after.</p>
			<p>In the next section, you will learn about collecting Flows on Android.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor780"/>Collecting Flows on Android</h2>
			<p>In Android, Flows are usually collected in the Activity or Fragment for display in the UI. Moving the <a id="_idIndexMarker1234"/>app in the background will not stop the <a id="_idIndexMarker1235"/>data collection. The app must not do so and continue updating the screen to avoid memory leaks and prevent wasting resources.</p>
			<p>You can safely collect flows in the UI Iayer by manually handling lifecycle changes or by using <code>Lifecycle.repeatOnLifecycle</code> and <code>Flow.flowWithLifecycle</code>, available in the <code>lifecycle-runtime-ktx</code> library, starting with version 2.4.0.</p>
			<p>To use it in your project, add the following to your <code>app/build.gradle</code> dependencies:</p>
			<pre class="source code">
implementation 'androidx.lifecycle:
    lifecycle-runtime-ktx:2.4.1'</pre>
			<p>This adds the <code>lifecycle-runtime-ktx</code> library to your project, so you can use both <code>Lifecycle.repeatOnLifecycle</code> and <code>Flow.flowWithLifecycle</code>.</p>
			<p><code>Lifecycle.repeatOnLifecycle(state, block)</code> will suspend the parent coroutine until the lifecycle is destroyed and executes the suspending <code>block</code> code when the <a id="_idIndexMarker1236"/>Lifecycle is at least in the <code>state</code> provided. The flow <a id="_idIndexMarker1237"/>will stop when the Lifecycle moves out of the state and restart when the lifecycle moves back to the state. <code>Lifecycle.repeatOnLifecycle</code> must be called on Activity’s <code>onCreate</code> or on Fragment’s <code>onViewCreated</code>.</p>
			<p>When using <code>Lifecycle.State.STARTED</code> for <code>state</code>, the <code>repeatOnLifecycle</code> will start Flow collection when the Lifecycle is started and stop when the Lifecycle is stopped (<code>onStop()</code> is called).</p>
			<p>If you use <code>Lifecycle.State.RESUMED</code>, the start will be when the Lifecycle is resumed, and the stop will be when <code>onPause</code> is called or when the Lifecycle is paused.</p>
			<p>The following example shows how you can use <code>Lifecycle.repeatOnLifecycle</code>:</p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.fetchMovies()
                    .collect { movie -&gt;
                        Log.d("movies", "${movie.title}")
                    }
            }
        }
    }
}</pre>
			<p>In this class, <code>repeatOnLifecycle</code> with <code>Lifecycle.State.STARTED</code> starts collecting the Flow <a id="_idIndexMarker1238"/>of movies when the lifecycle is started and <a id="_idIndexMarker1239"/>stops when the lifecycle is stopped.</p>
			<p><code>Flow.flowWithLifecycle</code> is another way to safely collect Flows in Android. It emits values from the Flow and operators preceding the call (the upstream Flow) when the lifecycle is at least in the state you set or the default, <code>Lifecycle.State.STARTED</code>. Internally, it uses <code>Lifecycle.repeatOnLifecycle</code>. The following example shows how you can use <code>Flow.flowWithLifecycle</code>:</p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    ...
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        lifecycleScope.launch {
            viewModel.fetchMovies()
                .flowWithLifecycle(lifecycle,
                Lifecycle.State.STARTED)
                .collect { movie -&gt;
                    Log.d("movies", "${movie.title}")
            }
        }
    }
}</pre>
			<p>Here, we used <code>flowWithLifecycle</code> with <code>Lifecycle.State.STARTED</code> to collect the Flow <a id="_idIndexMarker1240"/>of movies when the lifecycle is started and <a id="_idIndexMarker1241"/>stop when the lifecycle is stopped.</p>
			<p>In the following section, you will learn how to create Flows.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor781"/>Creating Flows with Flow Builders</h2>
			<p>You can create <a id="_idIndexMarker1242"/>Flows using the Flow Builders <a id="_idIndexMarker1243"/>from the Kotlin Flow API. The following are the Flow Builders you can use:</p>
			<ul>
				<li><code>flow{}</code>: This creates <a id="_idIndexMarker1244"/>a new Flow from a suspendable lambda block. You can send values using the <code>emit</code> function.</li>
				<li><code>flowOf()</code>: This creates <a id="_idIndexMarker1245"/>a Flow from the specified value or the <code>vararg</code> values.</li>
				<li><code>asFlow()</code>: This is an <a id="_idIndexMarker1246"/>extension function used to convert a type (sequence, array, range, or collection) into a Flow.</li>
			</ul>
			<p>The following example shows how to use the Flow Builders in an application:</p>
			<pre class="source code">
class MovieViewModel : ViewModel() {
    ...
    fun fetchMovies: Flow&lt;List&lt;Movie&gt;&gt; = flow {
        fetchMovieList().forEach { movie - &gt; emit(movie) }
    }
    fun fetchTop3Titles: Flow&lt;List&lt;String&gt;&gt; {
        val movies = fetchTopMovies()
        return flowOf(movies[0].title,
            movies[1].title, movies[2].title)
    }
    fun fetchMovieIds: Flow&lt;Int&gt; {
        return fetchMovies().map { it.id }.asFlow()
    }
}</pre>
			<p>In this example, <code>fetchMovies</code> created a Flow using <code>flow{}</code> and emitted each movie from <a id="_idIndexMarker1247"/>the list. The <code>fetchTop3Titles</code> function <a id="_idIndexMarker1248"/>uses <code>flowOf</code> to create a Flow with the titles of the first three movies. Finally, <code>fetchMovieIds</code> converted the list of IDs into a Flow of movie IDs using the <code>asFlow</code> function.</p>
			<p>In the next section, you will learn about the Kotlin Flow operators you can use with Flows.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor782"/>Using operators with Flows</h2>
			<p>There are built-in Flow operators you can use with Flows. You can collect Flows with terminal operators <a id="_idIndexMarker1249"/>and transform Flows with intermediate operators.</p>
			<p>Terminal <a id="_idIndexMarker1250"/>operators, such as the <code>collect</code> function used in the previous examples, are used to collect Flows. The following are the other terminal operators you can use:</p>
			<ul>
				<li><code>count</code></li>
				<li><code>first</code> and <code>firstOrNull</code></li>
				<li><code>last</code> and <code>lastOrNull</code></li>
				<li><code>fold</code></li>
				<li><code>reduce</code></li>
				<li><code>single</code> and <code>singleOrNull</code></li>
				<li><code>toCollection</code>, <code>toList</code>, and <code>toSet</code></li>
			</ul>
			<p>These operators work similarly to the Kotlin <code>Collection</code> function with the same name.</p>
			<p>You can use <a id="_idIndexMarker1251"/>Intermediate operators to modify a Flow and <a id="_idIndexMarker1252"/>return a new one. They can also be chained. The following Intermediate operators work the same as the Kotlin collection functions with the same name:</p>
			<ul>
				<li><code>filter</code>, <code>filterNot</code>, <code>filterNotNull</code>, and <code>filterIsInstance</code></li>
				<li><code>map</code> and <code>mapNotNull</code></li>
				<li><code>onEach</code></li>
				<li><code>runningReduce</code> and <code>runningFold</code></li>
				<li><code>withIndex</code></li>
			</ul>
			<p>Additionally, there is a <code>transform</code> operator you can use to apply your own operation. For example, this class has a Flow that uses the <code>transform</code> operator:</p>
			<pre class="source code">
class MovieViewModel : ViewModel() {
    ...
    fun fetchTopRatedMovie(): Flow&lt;Movie&gt; {
        return fetchMoviesFlow()
            .transform {
                if(it.voteAverage &gt; 0.6f) emit(it)
            }
    }
}</pre>
			<p>Here, the <code>transform</code> operator was used in the Flow of movies to only emit the ones whose <code>voteAverage</code> is higher than <code>0.6</code> (60%).</p>
			<p>There are <a id="_idIndexMarker1253"/>also size-limiting Kotlin Flow operators such as <code>drop</code>, <code>dropWhile</code>, <code>take</code>, and <code>takeWhile</code>, which function similarly to the Kotlin <a id="_idIndexMarker1254"/>collection functions of the same name.</p>
			<p>Let’s add Kotlin Flow into an Android project.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor783"/>Exercise 14.03 – using Flow in an Android application</h2>
			<p>In this <a id="_idIndexMarker1255"/>exercise, you will update the Popular Movies <a id="_idIndexMarker1256"/>app to use Kotlin Flow in fetching the list of movies:</p>
			<ol>
				<li>Open the Popular Movies project from the previous exercise in Android Studio.</li>
				<li>Go to the <code>MovieRepository</code> class and remove the <code>movies</code> and <code>error</code> <code>LiveData</code>. Then, replace the <code>fetchMovies</code> function with the following:<pre class="source code">
    fun fetchMovies(): Flow&lt;List&lt;Movie&gt;&gt; {
        return flow {
            emit(movieService
            .getPopularMovies(apiKey).results)
        }.flowOn(Dispatchers.IO)
    }</pre></li>
			</ol>
			<p>This changes the <code>fetchMovies</code> function to use Kotlin Flow. The Flow will emit the list of movies from <code>movieService.getPopularMovies</code>, and it will flow on the <code>Dispatchers.IO</code> dispatcher.</p>
			<ol>
				<li value="3">Open the <code>MovieViewModel</code> class. In the class declaration, add a dispatcher parameter with a default value of <code>Dispatchers.IO</code>:<pre class="source code">
class MovieViewModel(
    private val movieRepository: MovieRepository,
    private val dispatcher: CoroutineDispatcher =
        Dispatchers.IO
) : ViewModel() {
    ...
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1257"/>be the dispatcher that will be <a id="_idIndexMarker1258"/>used later for the Flow.</p>
			<ol>
				<li value="4">Replace the <code>popularMovies</code> <code>LiveData</code> with the following:<pre class="source code">
private val _popularMovies = MutableStateFlow(
    emptyList&lt;Movie&gt;())
val popularMovies: StateFlow&lt;List&lt;Movie&gt;&gt; =
    _popularMovies</pre></li>
			</ol>
			<p>You will use these for the value of the list of movies from <code>MovieRepository</code>. <code>StateFlow</code> is an observable Flow that emits state updates to the collectors, while <code>MutableStateFlow</code> is a <code>StateFlow</code> that you can change the value. In Android, <code>StateFlow</code> can be an alternative to <code>LiveData</code>.</p>
			<ol>
				<li value="5">Remove the <code>error</code> <code>LiveData</code> and replace it with the following:<pre class="source code">
private val _error = MutableStateFlow("")
val error: StateFlow&lt;List&lt;String&gt;&gt; =_error</pre></li>
			</ol>
			<p>You will use these for handling when the Flow encounters an exception.</p>
			<ol>
				<li value="6">Change the content of the <code>fetchPopularMovies</code> function with the following:<pre class="source code">
private fun fetchPopularMovies() {
    viewModelScope.launch(dispatcher) {
        movieRepository.fetchMovies().catch {
            _error.value =
                "An exception occurred:
                ${it.message}"
        }.collect {
            _popularMovies.value = it
        }
    }
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1259"/>collect the list of movies from <code>movieRepository</code> and set it to <code>MutableStateFlow</code> in <code>_popularMovies</code>  (and <code>StateFlow</code> in <code>popularMovies</code>).</p>
			<ol>
				<li value="7">Open <a id="_idIndexMarker1260"/>the <code>app/build.gradle</code> file and add the following in the dependencies:<pre class="source code">
implementation 'androidx.lifecycle:
lifecycle-runtime-ktx:2.5.1'</pre></li>
			</ol>
			<p>This allows you to use <code>lifecycleScope</code> for collecting the Flows in <code>MainActivity</code>.</p>
			<ol>
				<li value="8">Go to the <code>MainActivity</code> file and remove the lines of code for observing <code>popularMovies</code> and <code>error</code> from <code>MovieViewModel</code>. Add the following to collect the Flow from <code>MovieViewModel</code>:<pre class="source code">
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        launch {
            movieViewModel.popularMovies.collect {
                movies -&gt;movieAdapter.addMovies(
                movies)
            }
        }
        launch {
            movieViewModel.error.collect { error -&gt;
                if (error.isNotEmpty()) Snackbar
                .make(recyclerView, error, Snackbar
                .LENGTH_LONG).show()
            }
        }
    }
}</pre></li>
				<li>Run the <a id="_idIndexMarker1261"/>application. The app will display <a id="_idIndexMarker1262"/>the list of movies, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19411_14_011.jpg" alt="Figure 14.5 – The app displaying popular movies"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – The app displaying popular movies</p>
			<p>In this <a id="_idIndexMarker1263"/>exercise, you added Kotlin Flow to an <a id="_idIndexMarker1264"/>Android project. <code>MovieRepository</code> returns the list of movies as a Flow, which was collected in <code>MovieViewModel</code>. <code>MovieViewModel</code> uses <code>StateFlow</code>, which was then collected in <code>MainActivity</code> for di<a id="_idTextAnchor784"/><a id="_idTextAnchor785"/>splaying in RecyclerView.</p>
			<p>Let’s move on to the next activity.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor786"/>Activity 14.01 – creating a TV Guide app</h2>
			<p>A lot of people watch television. Most of the time, though, they are not sure what TV shows are <a id="_idIndexMarker1265"/>currently airing. Suppose you wanted to develop an app that can display a list of these shows from the Movie Database API’s <code>tv/on_the_air</code> endpoint using Kotlin Flow.</p>
			<p>The app will have two screens: the main screen and the details screen. On the main screen, you will display a list of the TV shows that are on the air. The TV shows will be sorted by name. Clicking on a TV show will open the details screen, which displays more information about the selected TV show.</p>
			<p>The following steps are for the completion of the activity:</p>
			<ol>
				<li>Create a new project in Android Studio and name it <code>TV Guide</code>. Set its package name.</li>
				<li>Add the <code>INTERNET</code> permission in the <code>AndroidManifest.xml</code> file.</li>
				<li>Add the dependencies for Retrofit, Coroutines, Moshi, Lifecycle, and other libraries in your <code>app/build.gradle</code> file.</li>
				<li>Add a <code>layout_margin</code> dimension value.</li>
				<li>Create a <code>view_tv_show_item.xml</code> layout file with <code>ImageView</code> for the poster and <code>TextView</code> for the name of the TV show.</li>
				<li>In the <code>activity_main.xml</code> file, remove the <code>Hello World</code> TextView and add a RecyclerView to the list of TV shows.</li>
				<li>Create a <code>TVShow</code> model class.</li>
				<li>Create another class named <code>TVResponse</code> for the response you get from the API endpoint for the TV shows on air.</li>
				<li>Create a new activity named <code>DetailsActivity</code> with <code>activity_details.xml</code> as the layout file.</li>
				<li>Open the <code>AndroidManifest.xml</code> file and add the <code>parentActivityName</code> attribute in the <code>DetailsActivity</code> declaration.</li>
				<li>In <code>activity_details.xml</code>, add the views for the details of the TV show.</li>
				<li>Open <code>DetailsActivity</code> and add the code to display the details of the TV show selected.</li>
				<li>Create a <code>TVShowAdapter</code> adapter class for the list of TV shows.</li>
				<li>Create a <code>TelevisionService</code> class for adding the <code>Retrofit</code> method.</li>
				<li>Create a <code>TVShowRepository</code> class with a constructor for <code>tvService</code>, and properties for <code>apiKey</code> and <code>tvShows</code>.</li>
				<li>Create a <a id="_idIndexMarker1266"/>function to retrieve the list of TV shows from the endpoint.</li>
				<li>Create a <code>TVShowViewModel</code> class with a constructor for <code>TVShowRepository</code>. Add the <code>tvShows</code> and <code>error</code> StateFlow and a <code>fetchTVShows</code> function that collects the Flow from the repository.</li>
				<li>Create an application class named <code>TVApplication</code> with a property for <code>TVShowRepository</code>.</li>
				<li>Set <code>TVApplication</code> as the value for the application in the <code>AndroidManifest.xml</code> file.</li>
				<li>Open <code>MainActivity</code> and add the code to update the RecyclerView when the Flow from <code>ViewModel</code> updates its value. Add a function that will open the details screen when clicking on a TV show from the list.</li>
				<li>Run your application. The app will display a list of TV shows. Clicking on a TV show will open the details activity, which displays the show details. The main screen <a id="_idTextAnchor787"/>and details screen will be similar to the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19411_14_05.jpg" alt="Figure 14.6 – The main screen and details screen of the TV Guide app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – The main screen and details screen of the TV Guide app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution <a id="_idIndexMarker1267"/>to this activity can be found at <a href="https://packt.link/By7eE">https://packt.link/By7eE</a>.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor788"/>Summary</h1>
			<p>This chapter focused on doing background operations with Coroutines and Flow. Background operations are used for long-running tasks such as accessing data from the local database or a remote server.</p>
			<p>You started with the basics of using Kotlin coroutines, Google’s recommended solution for asynchronous programming. You learned that you can make a background task into a suspending function with the <code>suspend</code> keyword. Coroutines can be started with the <code>async</code> or <code>launch</code> keywords.</p>
			<p>You learned how to create suspending functions and how to start coroutines. You also used dispatchers to change the thread where a coroutine runs. Then, you used coroutines for performing network calls and modified the data retrieved with the <code>map</code> and <code>switchMap</code> <code>LiveData</code> transformation functions.</p>
			<p>You then moved on to using Kotlin Flow in an Android app to load the data in the background. To safely collect flows in the UI layer, prevent memory leaks, and avoid wasting resources, you can use <code>Lifecycle.repeatOnLifecycle</code> and <code>Flow.flowWithLifecycle</code>.</p>
			<p>You learned about using Flow Builders to create Flows. The <code>flow</code> builder function creates a new Flow from a suspending lambda block and then you can send values with <code>emit()</code>. The <code>flowOf</code> function creates a Flow that emits the value or the <code>vararg</code> values. You can use the <code>asFlow()</code> extension function to convert collections and functional types into a Flow.</p>
			<p>Finally, you explored Flow operators and learned how to use them with Kotlin Flows. Terminal operators are used to start the collection of the Flow. With Intermediate operators, you can transform a Flow into another Flow.</p>
			<p>In the next chapter, you will learn about architecture patterns. You will learn about patterns such as <strong class="bold">Model-View-ViewModel </strong>(<strong class="bold">MVVM</strong>) and how you can improve the architecture of your app.</p>
		</div>
	</body></html>