- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Protocol-Oriented Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议导向设计
- en: When Apple announced Swift 2 at the **World Wide Developers Conference** (**WWDC**)
    in 2016, they also declared that Swift was the world's first **protocol-oriented
    programming** (**POP**) language. From its name, we might assume that POP is all
    about protocol; however, that would be a wrong assumption. POP is about so much
    more than just protocol; it is actually a new way of not only writing applications
    but also thinking about programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当苹果公司在2016年的**全球开发者大会**（**WWDC**）上宣布Swift 2时，他们也宣布Swift是世界上第一个**协议导向编程**（**POP**）语言。从其名称来看，我们可能会认为POP完全是关于协议；然而，这将是错误的假设。POP不仅仅是关于协议；它实际上是一种不仅编写应用程序，而且思考编程的新方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is the difference between OOP and POP design?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象（OOP）和协议导向（POP）设计之间的区别是什么？
- en: What is protocol-oriented design?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议导向设计是什么？
- en: What is protocol composition?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议组合是什么？
- en: What is protocol inheritance?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议继承是什么？
- en: Days after Dave Abrahams did his presentation on POP at WWDC 2016, there were
    numerous tutorials on the internet about POP that took a very object-oriented
    approach to it. With this statement, I mean the approach taken by these tutorials
    focused on replacing the superclass with protocols and protocol extensions. While
    protocols and protocol extensions are arguably two of the more important concepts
    of POP, these tutorials seem to be missing some very important concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dave Abrahams在2016年WWDC上关于POP的演讲之后，互联网上出现了许多关于POP的教程，这些教程采用了非常面向对象的方法。通过这个声明，我的意思是这些教程采取的方法集中在用协议和协议扩展替换超类。虽然协议和协议扩展可能是POP中两个更为重要的概念，但这些教程似乎遗漏了一些非常重要的概念。
- en: In this chapter, we will be comparing a protocol-oriented design with an object-oriented
    design to highlight some of the conceptual differences between the two. We will
    look at how we can use protocols and protocol extensions to replace superclasses,
    and how a protocol-oriented design will give us a cleaner and easier-to-maintain
    code base. To do this, we will look at how to define animal types for a video
    game in both an object-oriented and a protocol-oriented way. Let's start off by
    defining the requirements for our animals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将比较协议导向设计和面向对象设计，以突出两者之间的概念差异。我们将探讨如何使用协议和协议扩展来替换超类，以及协议导向设计将如何为我们提供一个更干净、更容易维护的代码库。为此，我们将探讨如何以面向对象和协议导向的方式为视频游戏定义动物类型。让我们首先定义我们动物的需求。
- en: Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: 'When we develop applications, we usually have a set of requirements that we
    need to develop against. With that in mind, let''s define the requirements for
    the animal types that we will be creating in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发应用程序时，我们通常有一套我们需要针对其进行开发的规范。考虑到这一点，让我们定义我们将在本章中创建的动物类型的规范：
- en: 'We will have three categories of animals: land, sea, and air.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将有三类动物：陆地、海洋和空中。
- en: Animals may be members of multiple categories. For example, an alligator can
    be a member of both the land and sea categories.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动物可能是多个类别的成员。例如，鳄鱼可以是陆地和海洋类别的成员。
- en: Animals may attack and/or move when they are on a tile that matches the categories
    they are in.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当动物位于与它们所在类别匹配的方格上时，它们可能会攻击和/或移动。
- en: Animals will start off with a certain number of hit points, and if those hit
    points reach 0 or less, then they will be considered dead.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动物将开始时拥有一定数量的生命值，如果这些生命值达到0或以下，它们将被视为死亡。
- en: For our example here, we will define two animals, `Lion` and `Alligator`, but
    we know that the number of animal types will grow as we develop the game.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将定义两种动物，`Lion`和`Alligator`，但我们知道随着游戏的开发，动物类型的数量将会增长。
- en: We will start off by looking at how we would design the animal types using an
    object-oriented approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何使用面向对象的方法来设计动物类型。
- en: Object-oriented design
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计
- en: 'Before we start writing code, let''s create a very basic diagram that shows
    how we would design the **Animal** class hierarchy. In this diagram, we will simply
    show the classes without much detail. This diagram will help us picture the class
    hierarchy in our minds. *Figure 10.1* shows the class hierarchy for the object-oriented
    design:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们创建一个非常基本的图表，展示我们将如何设计**动物**类层次结构。在这个图表中，我们将简单地展示类，而不涉及太多细节。这个图表将帮助我们在大脑中形成类层次结构的图像。*图10.1*显示了面向对象设计的类层次结构：
- en: '![A picture containing screenshot, drawing  Description automatically generated](img/B16683_10_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、绘图的图片，自动生成描述](img/B16683_10_01.png)'
- en: 'Figure 10.1: Animal class hierarchy'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：动物类层次结构
- en: '*Figure 10.1* shows that we have one superclass named **Animal**, and two subclasses
    named `Alligator` and `Lion`. We may think with the three categories (land, air,
    and sea) that we would want to create a larger class hierarchy where the middle
    layer would contain the classes for the land, air, and sea animals. This would
    allow us to separate the code for each animal category; however, that is not possible
    with our requirements. The reason this is not possible is that any of the animal
    types can be members of multiple categories, and with a class hierarchy, each
    class can have one and only one superclass. This means that the `Animal` superclass
    will need to contain the code required for each of the three categories.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.1* 显示我们有一个名为**Animal**的超类，以及两个名为`Alligator`和`Lion`的子类。我们可能会认为，根据三个类别（陆地、空中和海洋），我们想要创建一个更大的类层次结构，其中中间层将包含陆地、空中和海洋动物的类。这将使我们能够将每个动物类别的代码分开；然而，根据我们的要求，这是不可能的。这不可能的原因是任何动物类型都可以是多个类别的成员，而在类层次结构中，每个类只能有一个且仅有一个超类。这意味着`Animal`超类将需要包含为三个类别中每一个所需的代码。'
- en: Let's begin by looking at the code for the `Animal` superclass.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看`Animal`超类的代码开始。
- en: We will start the `Animal` superclass by defining 10 properties. These properties
    will define what type of animal it is and what type of attacks/movements it can
    do. We also define a property that will keep track of the remaining hit points
    for the animal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义`Animal`超类的10个属性开始。这些属性将定义动物的类型以及它可以执行的类型攻击/移动。我们还定义了一个属性，它将跟踪动物的剩余生命值。
- en: 'We define these properties as `internal` variables. We will need to set these
    properties in the subclasses; however, we do not want external entities, outside
    of our module that defines the animals, to change them. The preference is for
    these to be constants, but with an object-oriented approach; a subclass cannot
    set/change the value of a constant defined in a superclass. For this to work,
    the subclass will need to be defined in the same module as the `Animal` superclass:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些属性定义为`internal`变量。我们将在子类中设置这些属性；然而，我们不想外部实体（除了定义动物的模块之外）更改它们。首选的是将它们作为常量，但在面向对象的方法中；子类不能设置/更改在超类中定义的常量的值。为了使这可行，子类需要与`Animal`超类定义在同一个模块中：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define an initializer that will set the properties. We will set all
    the properties to `false` by default, and the hit points to `zero`. It will be
    up to the subclasses to set the appropriate properties that apply:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个初始化器，它将设置属性。我们将默认将所有属性设置为`false`，并将生命值设置为`zero`。适当的属性将由子类来设置：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since our properties are internal, we need to create some getter methods so
    that we can retrieve their values. We will also create a couple of additional
    methods that check if the animal is alive. We will need another method that deducts
    hit points when the animal takes a hit:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的属性是内部的，我们需要创建一些获取器方法，以便我们可以检索它们的值。我们还将创建一些额外的方法来检查动物是否存活。当动物受到攻击时，我们还需要另一个方法来扣除生命值：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have our `Animal` superclass, we can create the `Alligator` and
    `Lion` classes, which will be subclasses of the `Animal` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Animal`超类，我们可以创建`Alligator`和`Lion`类，它们将是`Animal`类的子类：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, these classes set the functionality needed for each animal. The
    `Lion` class contains the functionality for a land animal and the `Alligator`
    class contains the functionality for both land and sea animals.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这些类为每个动物设置了所需的功能。`Lion`类包含陆地动物的功能，而`Alligator`类包含陆地和海洋动物的功能。
- en: 'Another disadvantage of this object-oriented design is that we do not have
    a single point that defines what type of animal (air, land, or sea) this is. It
    is very easy to set the wrong flag or add the wrong function when we cut and paste
    or type in the code. This may lead us to have an animal like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种面向对象设计的另一个缺点是我们没有单个点来定义这种动物的类型（空中、陆地或海洋）。当我们复制粘贴或输入代码时，很容易设置错误的标志或添加错误的功能。这可能导致我们拥有像这样的动物：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous code, we set the `landAnimal` property to true; however, we
    accidentally set `airAttack` to true as well. This will give us an animal that
    can move on land but cannot attack, since the `landAttack` property is not set.
    Hopefully, we would catch these types of errors in testing; however, as we will
    see later in this chapter, a protocol-oriented approach would help prevent coding
    errors like this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们将`landAnimal`属性设置为true；然而，我们不小心也将`airAttack`设置为true。这将给我们一个可以在陆地上移动但不能攻击的动物，因为`landAttack`属性没有被设置。希望我们能在测试中捕捉到这类错误；然而，正如我们将在本章后面看到的那样，面向协议的方法将有助于防止这类编码错误。
- en: 'Since both classes have the same `Animal` superclass, we can use polymorphism
    to access them through the interface provided by the `Animal` superclass:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个类都有相同的`Animal`超类，我们可以通过`Animal`超类提供的接口使用多态来访问它们：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The way we designed the animal types here would work; however, there are several
    drawbacks to this design. The first drawback is the large monolithic `Animal`
    superclass. Those who are familiar with designing characters for video games probably
    realize how much functionality is missing from this superclass and its subclasses.
    This is on purpose so that we can focus on the design and not the functionality.
    For those who are not familiar with designing characters for video games, trust
    me when I say that this class may get very large.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里设计的动物类型是可行的；然而，这种设计有几个缺点。第一个缺点是庞大的单体`Animal`超类。那些熟悉为视频游戏设计角色的人可能意识到这个超类及其子类缺少了多少功能。这是故意的，这样我们就可以专注于设计而不是功能。对于那些不熟悉为视频游戏设计角色的人来说，当我说这个类可能会变得非常大时，请相信我。
- en: Another drawback is not being able to define constants in the superclass that
    the subclasses can set. We could define various initializers for the superclass
    that would correctly set the constants for the different animal categories; however,
    these initializers will become pretty complex and hard to maintain as we add more
    animals. The builder pattern could help us with the initialization, but as we
    are about to see, a protocol-oriented design would be even better.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是无法在子类可以设置的父类中定义常量。我们可以为父类定义各种初始化器，这些初始化器将正确设置不同动物类别的常量；然而，随着我们添加更多动物，这些初始化器将变得相当复杂且难以维护。建造者模式可以帮助我们进行初始化，但正如我们即将看到的，面向协议的设计会更好。
- en: One final drawback that I am going to point out is the use of flags (the `landAnimal`,
    `seaAnimal`, and `airAnimal` properties) to define the type of animal, and the
    type of attack and movements an animal can perform. If we do not correctly set
    these flags, then the animal will not behave correctly. As an example, if we set
    the `seaAnimal` flag rather than the `landAnimal` flag in the `Lion` class, then
    the lion will not be able to move or attack on land. Trust me, it is very easy,
    even for the most experienced developers, to set flags wrongly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我要指出的最后一个缺点是使用标志（`landAnimal`、`seaAnimal`和`airAnimal`属性）来定义动物类型，以及动物可以执行攻击和移动的类型。如果我们没有正确设置这些标志，那么动物的行为将不会正确。例如，如果我们把`Lion`类中的`seaAnimal`标志而不是`landAnimal`标志设置，那么狮子将无法在陆地上移动或攻击。相信我，即使是经验最丰富的开发者，也很容易设置错误的标志。
- en: Now let's look at how we would define this same functionality in a protocol-oriented
    way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何以面向协议的方式定义相同的功能。
- en: Protocol-oriented design
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向协议的设计
- en: 'Just like our object-oriented design, we will start off with a diagram that
    shows the types needed and the relationships between them. *Figure 10.2* shows
    our protocol-oriented design:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的面向对象设计一样，我们将从一个显示所需类型及其之间关系的图表开始。*图10.2*展示了我们的面向协议设计：
- en: '![A screenshot of a cell phone  Description automatically generated](img/B16683_10_02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  描述自动生成](img/B16683_10_02.png)'
- en: 'Figure 10.2: Protocol-oriented design'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：面向协议的设计
- en: As we can see, the POP design is quite different from the OOP design. In this
    design, we use three techniques that make POP significantly different from OOP.
    These techniques are protocol inheritance, protocol composition, and protocol
    extensions. We looked at protocol extensions in the previous chapter, but we have
    not covered protocol inheritance or composition yet. It is important to understand
    these concepts, so before we go into the design, let's look at what protocol inheritance
    and protocol composition are.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，POP设计与OOP设计相当不同。在这个设计中，我们使用了三种使POP与OOP显著不同的技术。这些技术是协议继承、协议组合和协议扩展。我们在上一章中讨论了协议扩展，但尚未涉及协议继承或组合。理解这些概念很重要，因此在我们进入设计之前，让我们看看协议继承和协议组合是什么。
- en: Protocol inheritance
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议继承
- en: 'Protocol inheritance is where one protocol can inherit the requirements from
    one or more additional protocols. This is similar to class inheritance in OOP,
    but instead of inheriting functionality, we are inheriting requirements. We can
    also inherit requirements from multiple protocols, whereas a class in Swift can
    have only one superclass. Let''s start off by defining four protocols, named `Name`,
    `Age`, `Fur`, and `Hair`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 协议继承是指一个协议可以继承一个或多个附加协议的要求。这与OOP中的类继承类似，但不同的是，我们继承的是要求，而不是功能。我们还可以从多个协议中继承要求，而Swift中的类只能有一个超类。让我们首先定义四个协议，分别命名为`Name`、`Age`、`Fur`和`Hair`：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each of the four protocols has different requirements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 四个协议各有不同的要求。
- en: There is one thing that I would like to point out. If you find yourself creating
    protocols with single requirements (as shown in this example), you probably want
    to reconsider your overall design. Protocols should not be this granular because
    we end up with too many protocols and they become hard to manage. We are using
    smaller protocols here as examples.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点我想指出。如果你发现自己正在创建具有单一要求的协议（如本例所示），你可能需要重新考虑你的整体设计。协议不应该这样细粒度，因为我们最终会拥有太多的协议，而且它们变得难以管理。我们在这里使用较小的协议作为示例。
- en: 'Now let''s look at how we can use these protocols and protocol inheritance
    to create additional protocols. We will define two more protocols, named `Person`
    and `Dog`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用这些协议和协议继承来创建额外的协议。我们将定义另外两个协议，分别命名为`Person`和`Dog`：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, any type that conforms to the `Person` protocol will need to
    fulfill the requirements of the `Name`, `Age`, and `Hair` protocols, as well as
    the requirements defined within the `Person` protocol itself. Any type that conforms
    to the `Dog` protocol will need to fulfill the requirements of the `Name`, `Age`,
    and `Fur` protocols as well as the requirements defined within the `Dog` protocol
    itself. This is the basis of protocol inheritance, where we can have one protocol
    inherit the requirements of one or more protocols.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，任何符合`Person`协议的类型都需要满足`Name`、`Age`和`Hair`协议的要求，以及`Person`协议本身定义的要求。任何符合`Dog`协议的类型都需要满足`Name`、`Age`和`Fur`协议的要求，以及`Dog`协议本身定义的要求。这是协议继承的基础，其中我们可以有一个协议继承一个或多个协议的要求。
- en: Protocol inheritance is extremely powerful because we can define several smaller
    protocols and mix/match them to create larger protocols. You will want to be careful
    not to create protocols that are too granular because they will become hard to
    maintain and manage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 协议继承非常强大，因为我们可以定义几个较小的协议，并将它们混合/匹配以创建较大的协议。你需要注意不要创建过于细粒度的协议，因为它们将变得难以维护和管理。
- en: Protocol composition
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议组合
- en: Protocol composition allows types to conform to more than one protocol. This
    is one of the many advantages that protocol-oriented design has over object-oriented
    design. With object-oriented design, a class can have only one superclass. This
    can lead to very large, monolithic superclasses, as we saw in the *Object-oriented
    design* section of this chapter. With protocol-oriented design, we are encouraged
    to create multiple smaller protocols with very specific requirements. Let's look
    at how protocol composition works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 协议组合允许类型符合多个协议。这是面向协议设计相对于面向对象设计所具有的许多优势之一。在面向对象设计中，一个类只能有一个超类。这可能导致非常庞大且单一的超级类，正如我们在本章的“面向对象设计”部分所看到的。在面向协议设计中，我们鼓励创建多个具有非常具体要求的较小协议。让我们看看协议组合是如何工作的。
- en: 'Let''s add another protocol, named `Occupation`, to our example from the *Protocol
    inheritance* section:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在“协议继承”部分的示例中添加另一个协议，命名为`Occupation`：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next let''s create a new type named `Programmer` that will conform to both
    the `Person` and `Occupation` protocols:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个新的类型`Programmer`，它将符合`Person`和`Occupation`协议：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the `Programmer` structure conforms to all the requirements
    from both the `Person` and `Occupation` protocols. Keep in mind that the `Person`
    protocol is a composite of the requirements from the `Name`, `Age`, `Hair`, and
    `Person` protocols; therefore, the `Programmer` type will need to conform to all
    those protocols plus the `Occupation` protocol.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`Programmer`结构符合`Person`和`Occupation`协议的所有要求。请记住，`Person`协议是由`Name`、`Age`、`Hair`和`Person`协议的要求组合而成的；因此，`Programmer`类型需要符合所有这些协议以及`Occupation`协议。
- en: Once again, I want to warn you not to make your protocols too granular. Protocol
    inheritance and composition are really powerful features but can also cause problems
    if used wrongly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒大家，不要让你们的协议过于细化。协议继承和组合是非常强大的功能，但如果使用不当也可能导致问题。
- en: Protocol composition and inheritance may not seem that powerful on their own;
    however, when we combine them with protocol extensions, we have a very powerful
    programming paradigm. Let's look at how powerful this paradigm is.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 协议组合和继承本身可能看起来并不那么强大；然而，当我们结合协议扩展时，就形成了一种非常强大的编程范式。让我们看看这种范式有多强大。
- en: Protocol-oriented design – putting it all together
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议式设计——整合一切
- en: 'We will begin by rewriting the `Animal` superclass as a protocol:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将`Animal`超类重写为一个协议：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `Animal` protocol, the only item that we are defining is the `hitPoints`
    property. If we were putting in all the requirements for an animal in a video
    game, this protocol would contain all the requirements that would be common to
    every animal. To be consistent with our object-oriented design, we only need to
    add the `hitPoints` property to this protocol.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Animal`协议中，我们定义的唯一项目是`hitPoints`属性。如果我们在一个视频游戏中为动物添加所有要求，这个协议将包含所有动物共有的要求。为了与我们的面向对象设计保持一致，我们只需要将`hitPoints`属性添加到这个协议中。
- en: 'Next, we need to add an `Animal` protocol extension, which will contain the
    functionality that is common for all types that conform to the protocol. Our `Animal`
    protocol extension would contain the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个`Animal`协议扩展，它将包含所有符合该协议的类型共有的功能。我们的`Animal`协议扩展将包含以下代码：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Animal` protocol extension contains the same `takeHit()`, `hitPointsRemaining()`,
    and `isAlive()` methods that we saw in the `Animal` superclass from the object-oriented
    example. Any type that conforms to the `Animal` protocol will automatically inherit
    these three methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animal`协议扩展包含了我们在面向对象示例中看到的`Animal`超类中的相同`takeHit()`、`hitPointsRemaining()`和`isAlive()`方法。任何符合`Animal`协议的类型将自动继承这三个方法。'
- en: 'Now let''s define our `LandAnimal`, `SeaAnimal`, and `AirAnimal` protocols.
    These protocols will define the requirements for the `land`, `sea`, and `air`
    animals respectively:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的`LandAnimal`、`SeaAnimal`和`AirAnimal`协议。这些协议将分别定义`land`、`sea`和`air`动物的要求：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unlike the `Animal` superclass in the object-oriented design, these three protocols
    only contain the functionality needed for their particular type of animal. Each
    of these protocols only contains four lines of code, while the `Animal` superclass
    from the object-oriented example contains significantly more. This makes our protocol
    design much easier to read and manage. The protocol design is also much safer
    because the functionalities for the various animal types are isolated in their
    own protocols rather than being embedded in a giant superclass. We are also able
    to avoid the use of flags to define the animal category and, instead, define the
    category of the animal by the protocols it conforms to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象设计中的`Animal`超类不同，这三个协议只包含特定类型动物所需的功能。每个协议只包含四行代码，而面向对象示例中的`Animal`超类包含的内容则显著更多。这使得我们的协议设计更容易阅读和管理。协议设计也更为安全，因为各种动物类型的功能被隔离在其各自的协议中，而不是嵌入在一个巨大的超类中。我们还能避免使用标志来定义动物类别，而是通过动物符合的协议来定义类别。
- en: In a full design, we would probably need to add some protocol extensions for
    each of the animal types, but once again, to be consistent with our object-oriented
    design, we do not need them for our example here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整的设计中，我们可能需要为每种动物类型添加一些协议扩展，但再次强调，为了与我们的面向对象设计保持一致，我们在这里的示例中不需要它们。
- en: 'Now, let''s look at how we would create our `Lion` and `Alligator` types using
    protocol-oriented design:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用面向协议的设计来创建我们的`Lion`和`Alligator`类型：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we specify that the `Lion` type conforms to the `LandAnimal` protocol,
    while the `Alligator` type conforms to both the `LandAnimal` and `SeaAnimal` protocols.
    As we saw previously, having a single type that conforms to multiple protocols
    is called **protocol composition** and is what allows us to use smaller protocols,
    rather than one giant monolithic superclass, as we did in the object-oriented
    example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们指定`Lion`类型符合`LandAnimal`协议，而`Alligator`类型符合`LandAnimal`和`SeaAnimal`协议。正如我们之前所看到的，一个类型符合多个协议被称为**协议组合**，这正是我们能够使用较小的协议而不是像面向对象示例中那样使用一个巨大的单体超类的原因。
- en: Both the `Lion` and `Alligator` types originate from the `Animal` protocol;
    therefore, they will inherit the functionality added with the `Animal` protocol
    extension. If our animal type protocols also had extensions, then they would also
    inherit the function added by those extensions. With protocol inheritance, composition,
    and extensions, our concrete types contain only the functionality needed by the
    particular animal types that they conform to, unlike in the object-oriented design,
    where each animal would contain all of the functionality from the huge, single
    superclass.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lion`和`Alligator`类型都源自`Animal`协议；因此，它们将继承`Animal`协议扩展中添加的功能。如果我们的动物类型协议也有扩展，那么它们也会继承那些扩展添加的功能。通过协议继承、组合和扩展，我们的具体类型只包含它们所符合的特定动物类型所需的功能，这与面向对象设计不同，在面向对象设计中，每个动物都会包含从庞大的单一超类中继承的所有功能。'
- en: 'Since the `Lion` and `Alligator` types originate from the `Animal` protocol,
    we can still use polymorphism as we did in the object-oriented example. Let''s
    look at how this works:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Lion`和`Alligator`类型源自`Animal`协议，我们仍然可以使用多态性，就像我们在面向对象示例中所做的那样。让我们看看这是如何工作的：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we create an array that will contain `Animal` types named `animals`.
    We then create two instances of the `Alligator` type and one instance of the `Lion`
    type that are added to the `animals` array. Finally, we use a `for-in` loop to
    loop through the array and print out the animal type based on the protocol that
    the instance conforms to.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个将包含名为`animals`的`Animal`类型的数组。然后我们创建了两个`Alligator`类型的实例和一个`Lion`类型的实例，并将它们添加到`animals`数组中。最后，我们使用`for-in`循环遍历数组，根据实例符合的协议打印出动物类型。
- en: Using the where statement with protocols
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用协议的where语句
- en: 'With protocols, we are able to use the `where` statement to filter the instances
    of our types. For example, if we only want to get the instances that conform to
    the `SeaAnimal` protocol, we can create a `for` loop as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议，我们能够使用`where`语句来过滤我们类型的实例。例如，如果我们只想获取符合`SeaAnimal`协议的实例，我们可以创建一个如下所示的`for`循环：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will retrieve only the animals that conform to the `SeaAnimal` protocol.
    This is a lot safer than using flags as we did in the object-oriented design example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只检索符合`SeaAnimal`协议的动物。这比我们在面向对象设计示例中使用标志更安全。
- en: Structures versus classes
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体与类
- en: You may have noticed that in the object-oriented design we used classes, while
    in the protocol-oriented design example we used structures. Classes, which are
    reference types, are one of the pillars of object-oriented programming and every
    major object-oriented programming language uses them. For Swift, Apple has said
    that we should prefer value types (structures) to reference types (classes). While
    this may seem odd for anyone who has extensive experience with object-oriented
    programming, there are several good reasons for this recommendation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在面向对象设计中我们使用了类，而在面向协议的设计示例中我们使用了结构体。类是引用类型，是面向对象编程的支柱之一，每个主要的面向对象编程语言都使用它们。对于Swift，苹果公司表示我们应该优先选择值类型（结构体）而不是引用类型（类）。虽然对于有丰富面向对象编程经验的人来说这看起来可能有些奇怪，但这个建议有几个很好的理由。
- en: The biggest reason, in my opinion, for using structures (value types) over classes
    is the performance gain we get. Value types do not incur the additional overhead
    for reference counting that reference types incur. Value types are also stored
    on the stack, which provides better performance as compared to reference types,
    which are stored on the heap. It is also worth noting that copying values is relatively
    cheap in Swift.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用结构体（值类型）而不是类的主要原因是我们获得性能提升。值类型不会产生引用类型所承担的额外引用计数开销。值类型也存储在栈上，与存储在堆上的引用类型相比，提供了更好的性能。还值得一提的是，在
    Swift 中复制值相对便宜。
- en: Keep in mind that, as our value types get large, the performance cost of copying
    can negate the other performance gains of value types. In the Swift standard library,
    Apple has implemented copy-on-write behavior to reduce the overhead of copying
    large value types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，随着我们的值类型变得越来越大，复制的性能成本可能会抵消值类型带来的其他性能优势。在 Swift 标准库中，苹果公司已经实现了写时复制行为，以减少复制大型值类型所产生的高额开销。
- en: With copy-on-write behavior, we do not create a new copy of our value type when
    we assign it to a new variable. The copy is postponed until one of the instances
    changes the value. This means that, if we have an array of 1 million numbers,
    when we pass this array to another array, we will not make a copy of the 1 million
    numbers until one of the arrays changes. This can greatly reduce the overhead
    incurred from copying instances of our value types.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用写时复制行为，当我们将值类型赋值给新变量时，并不会立即创建其新副本。复制操作会推迟到其中一个实例改变值时才进行。这意味着，如果我们有一个包含一百万个数字的数组，当我们把该数组传递给另一个数组时，我们不会复制这
    一百万个数字，直到其中一个数组发生变化。这可以大大减少从复制值类型实例所产生的高额开销。
- en: Value types are also a lot safer than reference types, because we do not have
    multiple references pointing to the same instance, as we do with reference types.
    This really becomes apparent when we are dealing with a multithreaded environment.
    Value types are also safer because we do not have memory leaks caused by common
    programming errors, such as the strong reference cycles that we will discuss in
    *Chapter 18*, *Memory Management*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型也比引用类型更安全，因为我们没有多个引用指向同一个实例，正如我们在第 18 章“内存管理”中将要讨论的强引用循环那样。值类型也更安全，因为我们不会因为常见的编程错误（如内存泄漏）而产生内存泄漏，例如我们将要讨论的强引用循环。
- en: Don't worry if you do not understand some of the items discussed in this section.
    The thing to understand is that value types, like structures, are safer, and for
    the most part provide better performance in Swift, as compared to reference types,
    such as classes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本节中讨论的一些项目不理解，请不要担心。需要理解的是，值类型，如结构体，更安全，并且在大多数情况下，与引用类型（如类）相比，在 Swift 中提供更好的性能。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we have read through this chapter and looked at some of the advantages that
    protocol-oriented design has over object-oriented design, we may think that protocol-oriented
    design is clearly superior to object-oriented design. However, this assumption
    would not be entirely correct.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们阅读本章并观察面向协议设计相对于面向对象设计的优势，我们可能会认为面向协议设计明显优于面向对象设计。然而，这个假设并不完全正确。
- en: Object-oriented design has been around since the 1970s and is a tried and true
    programming paradigm. Protocol-oriented design is the new kid on the block and
    was designed to correct some of the issues with object-oriented design.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计自 20 世纪 70 年代以来一直存在，是一种经过验证的编程范式。面向协议的设计是新兴的，旨在纠正面向对象设计的一些问题。
- en: Object-oriented and protocol-oriented design have similar philosophies, such
    as creating custom types that model real-world objects, and polymorphism to use
    a single interface to interact with multiple types. The difference is how these
    philosophies are implemented.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象和面向协议的设计有相似的哲学，例如创建自定义类型来模拟现实世界对象，以及多态性以使用单个接口与多个类型交互。不同之处在于这些哲学是如何实现的。
- en: To me, the code base in a project that uses protocol-oriented design is much
    safer, easier to read, and easier to maintain as compared to a project that uses
    object-oriented design. This does not mean that I am going to stop using object-oriented
    design altogether. I can still see a need for a class hierarchy in certain instances.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，使用面向协议设计的项目代码库比使用面向对象设计的项目更安全、更容易阅读、更容易维护。这并不意味着我将完全停止使用面向对象设计。我仍然可以在某些情况下看到类层次结构的需要。
- en: Remember that when we are designing our application, we should always use the
    right tool for the job. We would not want to use a chainsaw to cut a piece of
    2 x 4 lumber, but we also would not want to use a skill saw to cut down a tree.
    Therefore, the winner is the programmer who has the choice of using different
    programming paradigms rather than being limited to only one. In the next chapter,
    we will look at generics.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们设计我们的应用程序时，我们应该始终使用适合的工具来完成工作。我们不想用链锯来切割一块2 x 4英寸的木材，但同样，我们也不想用电锯来砍伐树木。因此，赢家是那些可以选择使用不同编程范式而不是仅限于一种的程序员。在下一章中，我们将探讨泛型。
