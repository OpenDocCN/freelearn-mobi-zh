- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protocol-Oriented Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Apple announced Swift 2 at the **World Wide Developers Conference** (**WWDC**)
    in 2016, they also declared that Swift was the world's first **protocol-oriented
    programming** (**POP**) language. From its name, we might assume that POP is all
    about protocol; however, that would be a wrong assumption. POP is about so much
    more than just protocol; it is actually a new way of not only writing applications
    but also thinking about programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between OOP and POP design?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is protocol-oriented design?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is protocol composition?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is protocol inheritance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Days after Dave Abrahams did his presentation on POP at WWDC 2016, there were
    numerous tutorials on the internet about POP that took a very object-oriented
    approach to it. With this statement, I mean the approach taken by these tutorials
    focused on replacing the superclass with protocols and protocol extensions. While
    protocols and protocol extensions are arguably two of the more important concepts
    of POP, these tutorials seem to be missing some very important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be comparing a protocol-oriented design with an object-oriented
    design to highlight some of the conceptual differences between the two. We will
    look at how we can use protocols and protocol extensions to replace superclasses,
    and how a protocol-oriented design will give us a cleaner and easier-to-maintain
    code base. To do this, we will look at how to define animal types for a video
    game in both an object-oriented and a protocol-oriented way. Let's start off by
    defining the requirements for our animals.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we develop applications, we usually have a set of requirements that we
    need to develop against. With that in mind, let''s define the requirements for
    the animal types that we will be creating in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have three categories of animals: land, sea, and air.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animals may be members of multiple categories. For example, an alligator can
    be a member of both the land and sea categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animals may attack and/or move when they are on a tile that matches the categories
    they are in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animals will start off with a certain number of hit points, and if those hit
    points reach 0 or less, then they will be considered dead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our example here, we will define two animals, `Lion` and `Alligator`, but
    we know that the number of animal types will grow as we develop the game.
  prefs: []
  type: TYPE_NORMAL
- en: We will start off by looking at how we would design the animal types using an
    object-oriented approach.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing code, let''s create a very basic diagram that shows
    how we would design the **Animal** class hierarchy. In this diagram, we will simply
    show the classes without much detail. This diagram will help us picture the class
    hierarchy in our minds. *Figure 10.1* shows the class hierarchy for the object-oriented
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, drawing  Description automatically generated](img/B16683_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Animal class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.1* shows that we have one superclass named **Animal**, and two subclasses
    named `Alligator` and `Lion`. We may think with the three categories (land, air,
    and sea) that we would want to create a larger class hierarchy where the middle
    layer would contain the classes for the land, air, and sea animals. This would
    allow us to separate the code for each animal category; however, that is not possible
    with our requirements. The reason this is not possible is that any of the animal
    types can be members of multiple categories, and with a class hierarchy, each
    class can have one and only one superclass. This means that the `Animal` superclass
    will need to contain the code required for each of the three categories.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by looking at the code for the `Animal` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the `Animal` superclass by defining 10 properties. These properties
    will define what type of animal it is and what type of attacks/movements it can
    do. We also define a property that will keep track of the remaining hit points
    for the animal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define these properties as `internal` variables. We will need to set these
    properties in the subclasses; however, we do not want external entities, outside
    of our module that defines the animals, to change them. The preference is for
    these to be constants, but with an object-oriented approach; a subclass cannot
    set/change the value of a constant defined in a superclass. For this to work,
    the subclass will need to be defined in the same module as the `Animal` superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define an initializer that will set the properties. We will set all
    the properties to `false` by default, and the hit points to `zero`. It will be
    up to the subclasses to set the appropriate properties that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our properties are internal, we need to create some getter methods so
    that we can retrieve their values. We will also create a couple of additional
    methods that check if the animal is alive. We will need another method that deducts
    hit points when the animal takes a hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `Animal` superclass, we can create the `Alligator` and
    `Lion` classes, which will be subclasses of the `Animal` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, these classes set the functionality needed for each animal. The
    `Lion` class contains the functionality for a land animal and the `Alligator`
    class contains the functionality for both land and sea animals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another disadvantage of this object-oriented design is that we do not have
    a single point that defines what type of animal (air, land, or sea) this is. It
    is very easy to set the wrong flag or add the wrong function when we cut and paste
    or type in the code. This may lead us to have an animal like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we set the `landAnimal` property to true; however, we
    accidentally set `airAttack` to true as well. This will give us an animal that
    can move on land but cannot attack, since the `landAttack` property is not set.
    Hopefully, we would catch these types of errors in testing; however, as we will
    see later in this chapter, a protocol-oriented approach would help prevent coding
    errors like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since both classes have the same `Animal` superclass, we can use polymorphism
    to access them through the interface provided by the `Animal` superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The way we designed the animal types here would work; however, there are several
    drawbacks to this design. The first drawback is the large monolithic `Animal`
    superclass. Those who are familiar with designing characters for video games probably
    realize how much functionality is missing from this superclass and its subclasses.
    This is on purpose so that we can focus on the design and not the functionality.
    For those who are not familiar with designing characters for video games, trust
    me when I say that this class may get very large.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback is not being able to define constants in the superclass that
    the subclasses can set. We could define various initializers for the superclass
    that would correctly set the constants for the different animal categories; however,
    these initializers will become pretty complex and hard to maintain as we add more
    animals. The builder pattern could help us with the initialization, but as we
    are about to see, a protocol-oriented design would be even better.
  prefs: []
  type: TYPE_NORMAL
- en: One final drawback that I am going to point out is the use of flags (the `landAnimal`,
    `seaAnimal`, and `airAnimal` properties) to define the type of animal, and the
    type of attack and movements an animal can perform. If we do not correctly set
    these flags, then the animal will not behave correctly. As an example, if we set
    the `seaAnimal` flag rather than the `landAnimal` flag in the `Lion` class, then
    the lion will not be able to move or attack on land. Trust me, it is very easy,
    even for the most experienced developers, to set flags wrongly.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we would define this same functionality in a protocol-oriented
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol-oriented design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like our object-oriented design, we will start off with a diagram that
    shows the types needed and the relationships between them. *Figure 10.2* shows
    our protocol-oriented design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a cell phone  Description automatically generated](img/B16683_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Protocol-oriented design'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the POP design is quite different from the OOP design. In this
    design, we use three techniques that make POP significantly different from OOP.
    These techniques are protocol inheritance, protocol composition, and protocol
    extensions. We looked at protocol extensions in the previous chapter, but we have
    not covered protocol inheritance or composition yet. It is important to understand
    these concepts, so before we go into the design, let's look at what protocol inheritance
    and protocol composition are.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Protocol inheritance is where one protocol can inherit the requirements from
    one or more additional protocols. This is similar to class inheritance in OOP,
    but instead of inheriting functionality, we are inheriting requirements. We can
    also inherit requirements from multiple protocols, whereas a class in Swift can
    have only one superclass. Let''s start off by defining four protocols, named `Name`,
    `Age`, `Fur`, and `Hair`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each of the four protocols has different requirements.
  prefs: []
  type: TYPE_NORMAL
- en: There is one thing that I would like to point out. If you find yourself creating
    protocols with single requirements (as shown in this example), you probably want
    to reconsider your overall design. Protocols should not be this granular because
    we end up with too many protocols and they become hard to manage. We are using
    smaller protocols here as examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at how we can use these protocols and protocol inheritance
    to create additional protocols. We will define two more protocols, named `Person`
    and `Dog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, any type that conforms to the `Person` protocol will need to
    fulfill the requirements of the `Name`, `Age`, and `Hair` protocols, as well as
    the requirements defined within the `Person` protocol itself. Any type that conforms
    to the `Dog` protocol will need to fulfill the requirements of the `Name`, `Age`,
    and `Fur` protocols as well as the requirements defined within the `Dog` protocol
    itself. This is the basis of protocol inheritance, where we can have one protocol
    inherit the requirements of one or more protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol inheritance is extremely powerful because we can define several smaller
    protocols and mix/match them to create larger protocols. You will want to be careful
    not to create protocols that are too granular because they will become hard to
    maintain and manage.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protocol composition allows types to conform to more than one protocol. This
    is one of the many advantages that protocol-oriented design has over object-oriented
    design. With object-oriented design, a class can have only one superclass. This
    can lead to very large, monolithic superclasses, as we saw in the *Object-oriented
    design* section of this chapter. With protocol-oriented design, we are encouraged
    to create multiple smaller protocols with very specific requirements. Let's look
    at how protocol composition works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another protocol, named `Occupation`, to our example from the *Protocol
    inheritance* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s create a new type named `Programmer` that will conform to both
    the `Person` and `Occupation` protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Programmer` structure conforms to all the requirements
    from both the `Person` and `Occupation` protocols. Keep in mind that the `Person`
    protocol is a composite of the requirements from the `Name`, `Age`, `Hair`, and
    `Person` protocols; therefore, the `Programmer` type will need to conform to all
    those protocols plus the `Occupation` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I want to warn you not to make your protocols too granular. Protocol
    inheritance and composition are really powerful features but can also cause problems
    if used wrongly.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol composition and inheritance may not seem that powerful on their own;
    however, when we combine them with protocol extensions, we have a very powerful
    programming paradigm. Let's look at how powerful this paradigm is.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol-oriented design â€“ putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will begin by rewriting the `Animal` superclass as a protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `Animal` protocol, the only item that we are defining is the `hitPoints`
    property. If we were putting in all the requirements for an animal in a video
    game, this protocol would contain all the requirements that would be common to
    every animal. To be consistent with our object-oriented design, we only need to
    add the `hitPoints` property to this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add an `Animal` protocol extension, which will contain the
    functionality that is common for all types that conform to the protocol. Our `Animal`
    protocol extension would contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Animal` protocol extension contains the same `takeHit()`, `hitPointsRemaining()`,
    and `isAlive()` methods that we saw in the `Animal` superclass from the object-oriented
    example. Any type that conforms to the `Animal` protocol will automatically inherit
    these three methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define our `LandAnimal`, `SeaAnimal`, and `AirAnimal` protocols.
    These protocols will define the requirements for the `land`, `sea`, and `air`
    animals respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the `Animal` superclass in the object-oriented design, these three protocols
    only contain the functionality needed for their particular type of animal. Each
    of these protocols only contains four lines of code, while the `Animal` superclass
    from the object-oriented example contains significantly more. This makes our protocol
    design much easier to read and manage. The protocol design is also much safer
    because the functionalities for the various animal types are isolated in their
    own protocols rather than being embedded in a giant superclass. We are also able
    to avoid the use of flags to define the animal category and, instead, define the
    category of the animal by the protocols it conforms to.
  prefs: []
  type: TYPE_NORMAL
- en: In a full design, we would probably need to add some protocol extensions for
    each of the animal types, but once again, to be consistent with our object-oriented
    design, we do not need them for our example here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how we would create our `Lion` and `Alligator` types using
    protocol-oriented design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we specify that the `Lion` type conforms to the `LandAnimal` protocol,
    while the `Alligator` type conforms to both the `LandAnimal` and `SeaAnimal` protocols.
    As we saw previously, having a single type that conforms to multiple protocols
    is called **protocol composition** and is what allows us to use smaller protocols,
    rather than one giant monolithic superclass, as we did in the object-oriented
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `Lion` and `Alligator` types originate from the `Animal` protocol;
    therefore, they will inherit the functionality added with the `Animal` protocol
    extension. If our animal type protocols also had extensions, then they would also
    inherit the function added by those extensions. With protocol inheritance, composition,
    and extensions, our concrete types contain only the functionality needed by the
    particular animal types that they conform to, unlike in the object-oriented design,
    where each animal would contain all of the functionality from the huge, single
    superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `Lion` and `Alligator` types originate from the `Animal` protocol,
    we can still use polymorphism as we did in the object-oriented example. Let''s
    look at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create an array that will contain `Animal` types named `animals`.
    We then create two instances of the `Alligator` type and one instance of the `Lion`
    type that are added to the `animals` array. Finally, we use a `for-in` loop to
    loop through the array and print out the animal type based on the protocol that
    the instance conforms to.
  prefs: []
  type: TYPE_NORMAL
- en: Using the where statement with protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With protocols, we are able to use the `where` statement to filter the instances
    of our types. For example, if we only want to get the instances that conform to
    the `SeaAnimal` protocol, we can create a `for` loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will retrieve only the animals that conform to the `SeaAnimal` protocol.
    This is a lot safer than using flags as we did in the object-oriented design example.
  prefs: []
  type: TYPE_NORMAL
- en: Structures versus classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that in the object-oriented design we used classes, while
    in the protocol-oriented design example we used structures. Classes, which are
    reference types, are one of the pillars of object-oriented programming and every
    major object-oriented programming language uses them. For Swift, Apple has said
    that we should prefer value types (structures) to reference types (classes). While
    this may seem odd for anyone who has extensive experience with object-oriented
    programming, there are several good reasons for this recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest reason, in my opinion, for using structures (value types) over classes
    is the performance gain we get. Value types do not incur the additional overhead
    for reference counting that reference types incur. Value types are also stored
    on the stack, which provides better performance as compared to reference types,
    which are stored on the heap. It is also worth noting that copying values is relatively
    cheap in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, as our value types get large, the performance cost of copying
    can negate the other performance gains of value types. In the Swift standard library,
    Apple has implemented copy-on-write behavior to reduce the overhead of copying
    large value types.
  prefs: []
  type: TYPE_NORMAL
- en: With copy-on-write behavior, we do not create a new copy of our value type when
    we assign it to a new variable. The copy is postponed until one of the instances
    changes the value. This means that, if we have an array of 1 million numbers,
    when we pass this array to another array, we will not make a copy of the 1 million
    numbers until one of the arrays changes. This can greatly reduce the overhead
    incurred from copying instances of our value types.
  prefs: []
  type: TYPE_NORMAL
- en: Value types are also a lot safer than reference types, because we do not have
    multiple references pointing to the same instance, as we do with reference types.
    This really becomes apparent when we are dealing with a multithreaded environment.
    Value types are also safer because we do not have memory leaks caused by common
    programming errors, such as the strong reference cycles that we will discuss in
    *Chapter 18*, *Memory Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you do not understand some of the items discussed in this section.
    The thing to understand is that value types, like structures, are safer, and for
    the most part provide better performance in Swift, as compared to reference types,
    such as classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have read through this chapter and looked at some of the advantages that
    protocol-oriented design has over object-oriented design, we may think that protocol-oriented
    design is clearly superior to object-oriented design. However, this assumption
    would not be entirely correct.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design has been around since the 1970s and is a tried and true
    programming paradigm. Protocol-oriented design is the new kid on the block and
    was designed to correct some of the issues with object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented and protocol-oriented design have similar philosophies, such
    as creating custom types that model real-world objects, and polymorphism to use
    a single interface to interact with multiple types. The difference is how these
    philosophies are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: To me, the code base in a project that uses protocol-oriented design is much
    safer, easier to read, and easier to maintain as compared to a project that uses
    object-oriented design. This does not mean that I am going to stop using object-oriented
    design altogether. I can still see a need for a class hierarchy in certain instances.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when we are designing our application, we should always use the
    right tool for the job. We would not want to use a chainsaw to cut a piece of
    2 x 4 lumber, but we also would not want to use a skill saw to cut down a tree.
    Therefore, the winner is the programmer who has the choice of using different
    programming paradigms rather than being limited to only one. In the next chapter,
    we will look at generics.
  prefs: []
  type: TYPE_NORMAL
