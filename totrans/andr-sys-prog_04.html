<html><head></head><body>
        

            
                <h1 class="header-title">Customizing the Android Emulator</h1>
            

            
                
<p>In the last chapter, we spent some time exploring the details of the Android system architecture. With our knowledge about kernel, HAL, and system service, we can start to customize the Android system ourselves. In this chapter, we will cover the following topics:</p>
<ul>
<li>Why customize the Android emulator?</li>
<li>Creating a new x86emu device</li>
<li>Building and testing the new x86emu device</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Why customize the Android emulator</h1>
            

            
                
<p>You may be wondering why we want to customize Android emulator. Google already provides it in the Android SDK and we can just use it without any additional effort. However, as a developer, you may find that it may not be good enough to meet your expectations. For example, in the most recent Android Studio or SDK releases, the Intel x86 emulator is recommended for developers, since it is much faster than the ARM version. One problem with using the Intel x86 emulator is that many Android applications with native code cannot run properly, because the x86 native library is not built into these applications.</p>
<p>To resolve this issue, we can integrate Houdini libraries from Intel to the emulator. With Houdini libraries, we can execute ARM native code on the Intel x86 platform. Another common request for Android emulator is that <strong>Google Mobile Services</strong> (<strong>GMS</strong>) is not included in it. Many developers develop applications with the assumption that GMS should be available on the device. In the next few chapters, we will learn how to create a x86emu device to customize Android emulator so that we can integrate components such as Houdini or enable additional hardware interfaces, such as Wi-Fi, in Android emulator. Armed with the knowledge about how to create the x86emu device, you can create your own Android emulator to meet your requirements.</p>
<p>It is possible, we always avoid changing too much AOSP code directly. This is because the more we change, the harder it is for us to port it to the latest version of Android. Google constantly releases new Android code from time to time. Sometime, new releases may be difficult to merge because of the architecture change.</p>
<p>From this chapter to <a href="7ff9a111-96cb-44ed-b92d-435e73821306.xhtml">Chapter 7</a>, <em>Enabling Wi-Fi on the Android Emulator</em>, we will teach a way to customize existing devices with minimal changes to the AOSP source code. From Chapter 8, <em>Creating Your Own Device on VirtualBox</em> to <a href="3c6453e9-98bb-4979-9c61-f0df071b1255.xhtml">Chapter 11</a>, <em>Enabling VirtualBox-Specific Hardware Interfaces</em>, we will discuss the porting to a new platform that we have to change to AOSP code directly. Even in that case, we still have to plan and consider the merge effort to a new Android release.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Understanding build layers</h1>
            

            
                
<p>The AOSP build system includes the abstraction layers to build a device. After we understand the ideas behind these layers, it will help us to understand the relationship of the various Makefiles for a device. It is always good to refer to the original Google document at the following URL, when you start to create a new device. The information will usually be updated when a new Android release is available: <a href="http://source.android.com/source/add-device.html">http://source.android.com/source/add-device.html</a>.</p>
<p>In this section, we will apply the information from the previous Google document to the specific Android emulator virtual hardware that we are going to work on. In this way, we can derive all device-specific Makefiles according to the general guidance from the previous Google document. Throughout the process from generic to specific, we can apply the inheritance of object-oriented concepts to the Makefile system.</p>
<p>There are three layers, <strong>Product</strong>, <strong>Board/Device</strong>, and <strong>Architecture</strong>, in the device build system. These layers can be considered as different dimensions to measure the characteristic of a product. Each layer relates to the one above it in a one-to-many relationship, which is similar to the inheritance or composition relationship in the object-oriented terms. For example, one kind of hardware architecture can have more than one board and each board can have more than one product. We will see how this method works when we create a new device in this chapter later.</p>
<p>The following table is a list of layers used in an AOSP build system. I created this table by modifying the one from the Google document and added my comments specific to the x86emu device, which we are going to work on in this chapter.</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Layer</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Product</p>
</td>
<td>
<p>The Product layer defines the feature specifications of the shipping product such as the modules to build, locales supported, and the configuration for various locales. In other words, this is the name of the overall product. Product-specific variables are defined in <strong>product definition Makefiles</strong>. A product can inherit from other product definitions, which simplifies maintenance. A common method is to create a base product that contains features that apply for all products, then creating product variants based on that base product.</p>
<p>In this chapter, we inherit from a generic device for an Android emulator in AOSP to create our x86emu device. For the x86emu device, we can also create two products that differ only by their architecture variants (we can have different builds for x86 or x86_64).</p>
</td>
</tr>
<tr>
<td>
<p>Board/Device</p>
</td>
<td>
<p>The Board/Device layer represents the physical layer of plastic on the device (that is, the industrial design of the device). For example, North American devices probably include QWERTY keyboards, whereas devices sold in France probably include AZERTY keyboards.</p>
<p>This layer also represents the bare schematics of a product. These include the peripherals on the board and their configuration. In the x86emu device, we need to define the size of the filesystem, the graphics hardware and camera, and so on. In <a href="7ff9a111-96cb-44ed-b92d-435e73821306.xhtml">Chapter 7</a>, <em>Enabling Wi-Fi on the Android Emulator</em>, we want to support Wi-Fi in the emulator. We need to specify it in the board configuration file.</p>
</td>
</tr>
<tr>
<td>
<p>Arch</p>
</td>
<td>
<p>The Architecture layer describes the processor configuration and <strong>Application Binary Interface</strong> (<strong>ABI</strong>) running on the board.</p>
</td>
</tr>
</tbody>
</table>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Build variants</h1>
            

            
                
<p>When building for a particular product, it's often useful to have minor variations on what is ultimately the final release build. By using different build variants, it can help the different parties in the product development cycle. There are primarily three kinds of build variant in the AOSP so far. The <strong>engineering build</strong> is the default one and is suitable for development work. In this type of build, the product security policy is not fully enforced and the debugging mechanisms are turned on. It is easy for engineers to test and fix issues with an engineering build.</p>
<p>The second flavor is <strong>user build</strong>, which is used for the final release. All debugging mechanisms are turned off and the product security policy is fully enforced. The third flavor is <strong>userdebug,</strong> which is in between the engineering build and user build. This type of build can be used in the field test, which is also used by the end users.</p>
<p>All components in the AOSP build are called <strong>modules</strong>. In a module definition, the module can specify tags with <kbd>LOCAL_MODULE_TAGS</kbd>, which can be one or more values of <kbd>optional</kbd> (default), <kbd>debug</kbd>, or <kbd>eng</kbd>. With a tag, we can define the usage of a module. For example, all debug tools will only be included in the engineering build.</p>
<p>If a module doesn't specify a tag (by <kbd>LOCAL_MODULE_TAGS</kbd>), its tag defaults to <kbd>optional</kbd>. An <kbd>optional</kbd> module is installed only if it is required by product configuration with <kbd>PRODUCT_PACKAGES</kbd>. We usually specify packages needed by a product in the device Makefile using the <kbd>PRODUCT_PACKAGES</kbd> variable. This way, we can easily define modules that are only suitable for a particular build.</p>
<p>The following table shows the AOSP-defined build variants documented in the preceding Google URL:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Build variants</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>eng</kbd></p>
</td>
<td>
<p>This is the default flavor:</p>
<ul>
<li>Installs modules tagged with: <kbd>eng</kbd> and/or <kbd>debug</kbd></li>
<li>Installs modules according to the product definition files, in addition to tagged modules</li>
<li><kbd>ro.secure=0</kbd></li>
<li><kbd>ro.debuggable=1</kbd></li>
<li><kbd>ro.kernel.android.checkjni=1</kbd></li>
<li><kbd>adb</kbd> is enabled by default</li>
</ul>
</td>
</tr>
<tr>
<td>
<p><kbd>user</kbd></p>
</td>
<td>
<p>This is the flavor intended to be the final release:</p>
<ul>
<li>Installs modules tagged with <kbd>user</kbd></li>
<li>Installs modules according to the product definition files, in addition to tagged modules.</li>
<li><kbd>ro.secure=1</kbd></li>
<li><kbd>ro.debuggable=0</kbd></li>
<li><kbd>adb</kbd> is disabled by default</li>
</ul>
</td>
</tr>
<tr>
<td>
<p><kbd>userdebug</kbd></p>
</td>
<td>
<p>The same as <kbd>user</kbd>, except:</p>
<ul>
<li>Also installs modules tagged with <kbd>debug</kbd></li>
<li><kbd>ro.debuggable=1</kbd></li>
<li><kbd>adb</kbd> is enabled by default</li>
</ul>
</td>
</tr>
</tbody>
</table>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a new x86emu device</h1>
            

            
                
<p>To customize Android emulator, we need to create a new device based on Android emulator and make our customization on this new device. We will work on this from the original AOSP source code.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Checking out from the AOSP</h1>
            

            
                
<p>As I mentioned before, I try to avoid unnecessary changes to the AOSP source code as much as I can. In this chapter, in order to set up the build environment, you can check out the <kbd>android-7.1.1_r4</kbd> version of the AOSP source code and clone the kernel and x86emu source to the AOSP source tree as follows:</p>
<pre>
<strong>$ mkdir android-x86emu</strong><br/><strong>$ cd android-x86emu</strong><br/><strong>$ repo init -u https://android.googlesource.com/platform/manifest -b android-7.1.1_r4</strong><br/><strong>$ repo sync</strong><br/><strong>$ git clone https://github.com/shugaoye/goldfish.git -b android-7.1.1_r4_x86emu_ch04_r1 kernel</strong><br/><strong>$ cd device/generic</strong><br/><strong>$ git clone https://github.com/shugaoye/x86emu.git -b android-7.1.1_r4_x86emu_ch04_r1</strong>  
</pre>
<p>Now we have retrieved the source code step by step. The project x86emu is the new device that we create in this chapter and can be used to customize Android emulator in the next few chapters. The goldfish project is the kernel that I forked from the AOSP goldfish kernel: <a href="https://android.googlesource.com/kernel/goldfish/">https://android.googlesource.com/kernel/goldfish/</a>.</p>
<p>The <kbd>android-7.1.1_r4_x86emu_ch04_r1</kbd> tag is the baseline of this chapter's source code release. All source code created or changed in this book is baselined using the naming convention <kbd>{Android version}_{project}_{chapter number}_{release number}</kbd>. Here is the explanation of this naming convention: </p>
<ul>
<li><kbd>Android version</kbd> is the original AOSP version number</li>
<li><kbd>project</kbd> can be x86emu or x86vbox</li>
<li><kbd>chapter number</kbd> is what chapter we create a baseline for the source code</li>
<li><kbd>release number</kbd> is used to indicate the number of releases</li>
</ul>
<p>These can work in the simple configuration of this chapter. This method is not good enough when we use source code from multiple sources as we will do in other chapters later in this book. We will use our own manifest file to manage the source code in this book.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Checking out from a local mirror</h1>
            

            
                
<p>To use our own manifest file, we can use either a local mirror or a remote repository. If we use a local mirror, we have to change <kbd>manifest.xml</kbd> of <kbd>android-7.1.1_r4</kbd> a little to make our own. We copy <kbd>.repo/manifest.xml</kbd> to our <kbd>manifests/default.xml</kbd> and make the following changes:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/><strong>  &lt;remote  name="github"<br/></strong><strong>         fetch="." /&gt;</strong> <br/>  &lt;remote  name="aosp" <br/>         fetch="../android" /&gt; <br/>  &lt;default revision="refs/tags/android-7.1.1_r4" <br/>           remote="aosp" <br/>           sync-j="4" /&gt; <br/><br/><strong>  &lt;!-- github/shugaoye --&gt;</strong><strong>  <br/>  &lt;project path="kernel" name="goldfish"   <br/>  remote="github" revision="refs/tags/<br/>  android-7.1.1_r4_x86emu_ch04_r1" /&gt;</strong><strong> <br/>  &lt;project path="device/generic/x86emu" name="x86emu" remote="github"   <br/>  revision="refs/tags/android-7.1.1_r4_x86emu_ch04_r1" /&gt;</strong><strong><br/>  &lt;!-- AOSP --&gt;</strong> <br/>  &lt;project path="build" name="platform/build" groups="pdk" &gt; <br/>    &lt;copyfile src="img/root.mk" dest="Makefile" /&gt; <br/>  &lt;/project&gt; <br/>  &lt;project path="abi/cpp" name="platform/abi/cpp" groups="pdk" /&gt; <br/>... <br/>&lt;/manifest&gt; 
</pre>
<p>This manifest file has an assumption that our local mirror has the following directory structure:</p>
<pre>
<strong>$ ls -F</strong><br/><strong>android/  android-x86/  github/</strong>  
</pre>
<p>The AOSP mirror is created under the <kbd>android</kbd> folder. GitHub mirror is created under the <kbd>github</kbd> folder. We need to use android-x86 source code as well later. We can put it under the <kbd>android-x86</kbd> folder. Our own manifest is stored at <kbd>github/manifests</kbd> and the preceding manifest file is <kbd>github/manifests/default.xml</kbd>. In this file, we add additional lines to retrieve the Android kernel and x86emu device from GitHub.</p>
<p>With this manifest, we can get the source code using the following command:</p>
<pre>
<strong>$ mkdir android-x86emu</strong><br/><strong>$ cd android-x86emu</strong><br/><strong>$ repo init -u {your mirror URL}/github/manifests.git -b <strong>android-7.1.1_r4_</strong><strong>ch04</strong></strong><br/><strong>$ repo sync</strong>  
</pre>
<p>We can also retrieve all source code from the remote repository directly using our own manifest file. With that, we need to change the manifest file a little as follows:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br/>&lt;manifest&gt; <br/><br/>  &lt;remote  name="github" <br/>           fetch="." /&gt; <br/><br/><strong> &lt;remote  name="aosp" </strong><br/><strong>           fetch="https://android.googlesource.com/" /&gt;</strong> <br/>  &lt;default revision="refs/tags/android-7.1.1_r4" <br/>           remote="aosp" <br/>           sync-c="true" <br/>           sync-j="1" /&gt; <br/><br/>  &lt;!-- github/shugaoye --&gt; <br/>  &lt;project path="kernel" name="goldfish" remote="github" <br/>   revision="refs/tags/android-7.1.1_r4_x86emu_ch04_r1" /&gt; <br/>  &lt;project path="device/generic/x86emu" name="x86emu" remote="github" <br/>   revision="refs/tags/android-7.1.1_r4_x86emu_ch04_r1" /&gt; <br/><br/>  &lt;!-- aosp --&gt; <br/>  &lt;project path="build" name="platform/build" groups="pdk,tradefed" &gt; <br/>    &lt;copyfile src="img/root.mk" dest="Makefile" /&gt; <br/>  &lt;/project&gt; <br/>... 
</pre>
<p>As you can see, we changed the URL of the remote <kbd>aosp</kbd> to use the absolute path in this revision of the manifest file. To check out the source code using this revision, we can run the following commands:</p>
<pre>
<strong>$ mkdir android-x86emu</strong><br/><strong>$ cd android-x86emu</strong><br/><strong>$ repo init -u https://github.com/shugaoye/manifests -b <strong>android-7.1.1_r4_ch04_</strong><strong>aosp</strong></strong><br/><strong>$ repo sync</strong>  
</pre>
<p>Because there are multiple repositories involved in this book, I strongly encourage you to use a local mirror. This can make the build and debug process more efficient.</p>
<p>It is also possible to use <kbd>local_manifests</kbd> to set up your workspace. You can refer to Appendix B, <em>Using Repo in This Book</em>, in the book <em>Embedded Programming with Android</em>. A sample file can be found at <a href="https://github.com/shugaoye/build/blob/master/local_manifest.xml">https://github.com/shugaoye/build/blob/master/local_manifest.xml</a>.</p>
<p>In this book, I use branches for the manifest file to manage the different versions of source code. To create a baseline of the source code in a chapter, I use the following naming convention:</p>
<p><kbd>{Android version}_{chapter number}_{remote (optional)}</kbd></p>
<ul>
<li><kbd>Android version</kbd> is the original AOSP version number</li>
<li><kbd>chapter number</kbd> is what chapter we create a baseline for the source code</li>
<li><kbd>remote</kbd> is used to indicate how to check out the source code from the remote repositories</li>
</ul>
<p>For example, from the following screenshot, we can see that the branch <kbd>android-7.1.1_r4_ch04</kbd> is used to check out the source code of chapter 4 from a local mirror. The branch <kbd>android-7.1.1_r4_ch04_aosp</kbd> is used to check out the source code for chapter 4 from the remote repository. Since I am in China, I don't have access to the AOSP source code all the time. I created revisions (<kbd>android-7.1.1_r4_ch04_tuna</kbd> and <kbd>android-7.1.1_r4_ch04_ustc</kbd>) for chapter 4 to check out the source code from AOSP mirrors in China and GitHub. You may change the manifest file according to your needs.</p>
<div><img height="474" width="247" class=" image-border" src="img/image_04_001.png"/></div>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating x86emu device</h1>
            

            
                
<p>After we check out the source code, we can look at how to create a new x86emu device in the <kbd>$AOSP/device</kbd> folder. The hierarchy in the <kbd>device</kbd> folder is in the <kbd>vendor-name/device-name</kbd> format. For example, the Nexus S from Samsung can be found in the <kbd>samsung/crespo</kbd> folder. The device name of Nexus S is <kbd>crespo</kbd>. We can create our device under a common folder, <kbd>generic</kbd>, as follows. The folder name for our device is <kbd>generic<em>/</em>x86emu</kbd>:</p>
<pre>
<strong>$ cd device/generic </strong><br/><strong>$ mkdir x86emu </strong>
</pre>
<p>This is the project that we create in this chapter and you can find the source code at <a href="https://github.com/shugaoye/x86emu.git">https://github.com/shugaoye/x86emu.git</a>.</p>
<p>We will create a list of Makefiles in this folder to build the device. Refer to the build layers in the previous section. Here is a list of Makefiles that need to be included in the device skeleton:</p>
<ul>
<li><kbd>AndroidProducts.mk</kbd>: This is a Makefile to describe the various products that can be built for this device</li>
<li><kbd>BoardConfig.mk</kbd>: This is a board configuration Makefile for the hardware board</li>
<li><kbd>device.mk</kbd>: This is the device Makefile that is used to declare the files and modules needed for the device</li>
<li><kbd>vendorsetup.sh</kbd>: This is a shell script that can be used to add your product (a "lunch combo") to the build along with a build variant separated by a dash</li>
<li><kbd>{Product Makefile}.mk</kbd>: This is the product definition Makefile and it is used to create a specific product based on the device</li>
</ul>
<p>Now we can create Makefiles for our device one by one according to the preceding list.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">AndroidProducts.mk</h1>
            

            
                
<p>We included all product definition Makefiles in this file. The AOSP build system will start to search all product definitions using this file. The following is the content of <kbd>AndroidProducts.mk:</kbd></p>
<pre>
PRODUCT_MAKEFILES := \ <br/>    $(LOCAL_DIR)/x86emu_x86.mk \  <br/>    $(LOCAL_DIR)/x86emu_x86_64.mk \  
</pre>
<p>As we can see, we defined two product variants for x86 and x86_64 builds.</p>
<p>Both <kbd>x86emu_x86.mk</kbd> and <kbd>x86emu_x86_64.mk</kbd> are very similar. They define the same set of product definition variables for 32 bit and 64 bit.</p>
<p>The following table compares the product definition Makefiles for 32-bit and 64-bit build:</p>
<table>
<tbody>
<tr>
<td>
<p><kbd>x86emu_x86.mk</kbd></p>
</td>
<td>
<p><kbd>x86emu_x86_64.mk</kbd></p>
</td>
</tr>
<tr>
<td>
<pre>
$(call inherit-product, device/generic/x86emu/device.mk)<br/>$(call inherit-product, $(SRC_TARGET_DIR)/product/full.mk)<br/># Overrides<br/>PRODUCT_BRAND := x86emu_x86<br/>PRODUCT_NAME := x86emu_x86<br/>PRODUCT_DEVICE = x86emu<br/>PRODUCT_MODEL := x86emu_x86_ch4<br/>TARGET_ARCH := x86<br/>TARGET_KERNEL_CONFIG := i386_ranchu_defconfig<br/>$(call inherit-product, $(LOCAL_PATH)/x86emu_base.mk)
</pre></td>
<td>
<pre>
$(call inherit-product, device/generic/x86emu/device.mk)<br/>$(call inherit-product, $(SRC_TARGET_DIR)/product/full_x86_64.mk)<br/># Overrides<br/>PRODUCT_BRAND := x86emu_x86_64<br/>PRODUCT_NAME := x86emu_x86_64<br/>PRODUCT_DEVICE = x86emu<br/>PRODUCT_MODEL := x86emu_x86_64_ch4<br/>TARGET_SUPPORTS_32_BIT_APPS := true<br/>TARGET_SUPPORTS_64_BIT_APPS := true<br/>TARGET_ARCH := x86_64<br/>TARGET_KERNEL_CONFIG := x86_64_ranchu_defconfig<br/>$(call inherit-product, $(LOCAL_PATH)/x86emu_base.mk)
</pre></td>
</tr>
</tbody>
</table>
<p>You may notice that we inherit the common product definition files for 32-bit and 64-bit first at the beginning:</p>
<pre>
$(call inherit-product, $(SRC_TARGET_DIR)/product/full.mk) 
</pre>
<p>And:</p>
<pre>
$(call inherit-product, $(SRC_TARGET_DIR)/product/full_x86_64.mk) 
</pre>
<p>There are many generic product definitions defined by the AOSP build system. You can find them at <kbd>$AOSP/build/target/product</kbd>:</p>
<pre>
<strong>$ ls build/target/product</strong><br/><strong>AndroidProducts.mk      full_base.mk             sdk_base.mk</strong><br/><strong>aosp_arm64.mk           full_base_telephony.mk   sdk_mips.mk</strong><br/><strong>aosp_arm.mk             full_mips64.mk           sdk.mk</strong><br/><strong>aosp_base.mk            full_mips.mk             sdk_phone_arm64.mk</strong><br/><strong>aosp_base_telephony.mk  full.mk                  sdk_phone_armv7.mk</strong><br/><strong>aosp_mips64.mk          full_x86_64.mk           sdk_phone_mips64.mk</strong><br/><strong>aosp_mips.mk            full_x86.mk              sdk_phone_mips.mk</strong><br/><strong>aosp_x86_64.mk          generic_armv5.mk         sdk_phone_x86_64.mk</strong><br/><strong>aosp_x86.mk             generic_mips.mk          sdk_phone_x86.mk</strong><br/><strong>base.mk                 generic.mk               sdk_x86_64.mk</strong><br/><strong>core_64_bit.mk          generic_no_telephony.mk  sdk_x86.mk</strong><br/><strong>core_base.mk            generic_x86.mk           security</strong><br/><strong>core_minimal.mk         languages_full.mk        telephony.mk</strong><br/><strong>core.mk                 languages_small.mk       vboot.mk</strong><br/><strong>core_tiny.mk            locales_full.mk          verity.mk</strong><br/><strong>embedded.mk             runtime_libart.mk</strong><br/><strong>emulator.mk             sdk_arm64.mk</strong>  
</pre>
<p>After that, a set of product definition variables <kbd>PRODUCT_BRAND</kbd>, <kbd>PRODUCT_NAME</kbd>, <kbd>PRODUCT_DEVICE</kbd>, and <kbd>PRODUCT_MODEL</kbd> are defined with different values. <kbd>TARGET_ARCH</kbd> and <kbd>TARGET_KERNEL_CONFIG</kbd> are also defined for 32 bit and 64 bit separately. Pay attention to <kbd>PRODUCT_MODEL</kbd>. Since we will change Makefiles in each chapter, in this book we use <kbd>PRODUCT_MODEL</kbd> to indicate the build for each chapter. In this chapter, we define <kbd>PRODUCT_MODEL</kbd> as <kbd>x86emu_x86_ch4</kbd> for the build in this chapter. At the end of the file, we also include a common <kbd>Makefile x86emu_base.mk</kbd> for both 32-bit and 64-bit products. This file includes additional configurations for the kernel build:</p>
<pre>
TARGET_KERNEL_SOURCE := kernel <br/><br/>PRODUCT_OUT ?= out/target/product/x86emu <br/><br/>include $(TARGET_KERNEL_SOURCE)/AndroidKernel.mk <br/><br/># define build targets for kernel <br/>.PHONY: $(TARGET_PREBUILT_KERNEL) <br/><br/>LOCAL_KERNEL := $(TARGET_PREBUILT_KERNEL) <br/><br/>PRODUCT_COPY_FILES += \ <br/>     $(LOCAL_KERNEL):kernel \ 
</pre>
<p>The kernel build is usually not included in the AOSP build. You have to build them separately according to the instructions from Google. In this book, we integrate the kernel build in our own Makefile here. The kernel <kbd>AndroidKernel.mk</kbd> Makefile is created based on the Makefile of the Qualcomm kernel source at <a href="https://android.googlesource.com/kernel/msm/">https://android.googlesource.com/kernel/msm/</a>.</p>
<p>There are many product definition variables used in the preceding Makefiles. Let's review the product definition variables that we used here. Refer to the Google documents for the complete list:</p>
<ul>
<li><kbd>PRODUCT_BRAND</kbd>: This is the brand that the software is customized for. We just defined it as our device name.</li>
<li><kbd>PRODUCT_NAME</kbd>: This is the product name that we give to the device. We set it to <kbd>x86emu_x86</kbd> in this book. It is also the prefix that we can select in the lunch combo, such as <kbd>x86emu_x86-eng</kbd>. The suffix is the build variants.</li>
<li><kbd>PRODUCT_DEVICE</kbd>: The name of the actual product. <kbd>TARGET_DEVICE</kbd> derives from this variable. This is also the board name that the build system uses to locate <kbd>BoardConfig.mk</kbd>. It is the x86emu for our device and it is also the directory name of our device at <kbd>$AOSP/device/generic/x86emu</kbd>.</li>
<li><kbd>PRODUCT_MODEL</kbd>: This is the name that we can see in the settings in Model. As I mentioned earlier, we use this variable to differentiate the build of each chapter in this book.</li>
<li><kbd>PRODUCT_OUT</kbd>: This is the output folder of the build result. It is the same as the environment variable <kbd>$OUT</kbd>.</li>
<li><kbd>PRODUCT_COPY_FILES</kbd>: This is a list of specific files that we would like to copy to the target's filesystem. The list of words looks like <kbd>source_path:destination_path</kbd>. The file at the source path should be copied to the destination path during the build process.</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">BoardConfig.mk</h1>
            

            
                
<p><kbd>BoardConfig.mk</kbd> defines the board-specific configurations. We define CPU/ABI, the target architecture, OpenGLES configurations, and so on in this file. We also define the image file size, format, and so on:</p>
<pre>
TARGET_NO_BOOTLOADER := true <br/>TARGET_NO_KERNEL := true <br/>TARGET_CPU_ABI := x86 <br/>TARGET_ARCH := x86 <br/>TARGET_ARCH_VARIANT := x86 <br/>TARGET_PRELINK_MODULE := false <br/><br/># The IA emulator (qemu) uses the Goldfish devices <br/>HAVE_HTC_AUDIO_DRIVER := true <br/>BOARD_USES_GENERIC_AUDIO := true <br/><br/># no hardware camera <br/>USE_CAMERA_STUB := true <br/><br/># customize the malloced address to be 16-byte aligned <br/>BOARD_MALLOC_ALIGNMENT := 16 <br/><br/># Enable dex-preoptimization to speed up the first boot sequence <br/># of an SDK AVD. Note that this operation only works on Linux for now <br/>ifeq ($(HOST_OS),linux) <br/>WITH_DEXPREOPT := true <br/>endif <br/><br/># Build OpenGLES emulation host and guest libraries <br/>BUILD_EMULATOR_OPENGL := true <br/><br/># Build and enable the OpenGL ES View renderer. When running on the emulator, <br/># the GLES renderer disables itself if host GL acceleration isn't available. <br/>USE_OPENGL_RENDERER := true <br/><br/>TARGET_USERIMAGES_USE_EXT4 := true <br/>BOARD_SYSTEMIMAGE_PARTITION_SIZE := 1342177280 <br/>BOARD_USERDATAIMAGE_PARTITION_SIZE := 576716800 <br/>BOARD_CACHEIMAGE_PARTITION_SIZE := 69206016 <br/>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4 <br/>BOARD_FLASH_BLOCK_SIZE := 512 <br/>TARGET_USERIMAGES_SPARSE_EXT_DISABLED := true <br/><br/>BOARD_SEPOLICY_DIRS += \ <br/>        build/target/board/generic/sepolicy \ <br/>        build/target/board/generic_x86/sepolicy 
</pre>
<p>This file is copied from a predefined AOSP board configuration at <kbd>$AOSP/build/target/board/generic_x86/BoardConfig.mk</kbd> with minor changes.</p>
<p>We can also use the system-defined board configuration directly and overwrite predefined variables as follows:</p>
<pre>
include $(SRC_TARGET_DIR)/board/generic_x86/BoardConfig.mk <br/><br/># <br/># Overwrite predefined variables. <br/># <br/><br/>TARGET_USERIMAGES_USE_EXT4 := true <br/>BOARD_SYSTEMIMAGE_PARTITION_SIZE := 1610612736 <br/>BOARD_USERDATAIMAGE_PARTITION_SIZE := 576716800 <br/>BOARD_CACHEIMAGE_PARTITION_SIZE := 69206016 <br/>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4 <br/>BOARD_FLASH_BLOCK_SIZE := 512 <br/>TARGET_USERIMAGES_SPARSE_EXT_DISABLED := true <br/><br/>BOARD_KERNEL_CMDLINE += androidboot.selinux=permissive 
</pre>
<p>If we look at the folder of <kbd>$AOSP/build/target/board/generic_x86</kbd>, it contains a few other files:</p>
<pre>
<strong>$ ls -F</strong><br/><strong>BoardConfig.mk  device.mk  README.txt  sepolicy/  system.prop</strong>  
</pre>
<p>We need to copy <kbd>system.prop</kbd> to our <kbd>device</kbd> folder as well, since this file defines the <strong>Radio Interface Layer</strong> (<strong>RIL</strong>) configuration for the emulator as follows:</p>
<pre>
rild.libpath=/system/lib/libreference-ril.so <br/>rild.libargs=-d /dev/ttyS0 
</pre>
<p>Without this, you will find that the data connection cannot work properly in the build.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">device.mk</h1>
            

            
                
<p>You may notice that there is a <kbd>device.mk</kbd> file in the <kbd>generic_x86</kbd> folder. Yes, we can reuse that file directly. The following is our <kbd>device.mk</kbd> file:</p>
<pre>
$(call inherit-product, $(SRC_TARGET_DIR)/board/generic_x86/device.mk) 
</pre>
<p>As we can see, in our <kbd>device.mk</kbd> file, we simply inherit the common <kbd>device.mk</kbd> from the <kbd>generic_x86</kbd> device.</p>
<p>We can look at the <kbd>device.mk</kbd> file for the <kbd>generic_x86</kbd> device as follows:</p>
<pre>
PRODUCT_PROPERTY_OVERRIDES := \ <br/>    ro.ril.hsxpa=1 \ <br/>    ro.ril.gprsclass=10 \  <br/>    ro.adb.qemud=1 <br/><br/>PRODUCT_COPY_FILES := \ <br/>device/generic/goldfish/data/etc/apns-conf.xml:system/etc/<br/>apns-conf.xml \  <br/>device/generic/goldfish/camera/media_profiles.xml:system/etc/<br/>media_profiles.xml \  <br/>frameworks/av/media/libstagefright/data/media_codecs_google_audio.xml:system/etc/media_codecs_google_audio.xml \  <br/>frameworks/av/media/libstagefright/data/media_codecs_google_telephony.xml:system/etc/media_codecs_google_telephony.xml \ <br/>frameworks/av/media/libstagefright/data/media_codecs_google_video.xml:system/etc/media_codecs_google_video.xml \  <br/>device/generic/goldfish/camera/media_codecs.xml:system/etc/media_codecs.xml <br/><br/>PRODUCT_PACKAGES := \ <br/>    audio.primary.goldfish \ <br/>    vibrator.goldfish 
</pre>
<p>In the preceding <kbd>device.mk</kbd> file for the <kbd>generic_x86</kbd> device, it overwrites a few properties and copies configuration files to the <kbd>system</kbd> folder. It also includes the HAL layers for the goldfish device.</p>
<p>Now we can add our device build to the build system using the following command:</p>
<pre>
$ add_lunch_combo &lt;product_name&gt;-&lt;build_variant&gt; <br/>$ lunch &lt;product_name&gt;-&lt;build_variant&gt; 
</pre>
<p>Such as:</p>
<pre>
$ add_lunch_combo x86emu_x86-eng <br/>$ lunch x86emu_x86-eng 
</pre>
<p>To automatically add this to the build system, we can add a script <kbd>vendorsetup.sh</kbd>. In this script, we can create all the build variants for <kbd>x86emu_x86</kbd>:</p>
<pre>
for i in eng userdebug user; do <br/>        add_lunch_combo x86emu_x86-${i} <br/>done 
</pre>
<p>Be aware that the 64-bit build for the x86emu device is not tested in this book. You must make the necessary changes by yourself if you want to test a 64-bit build.</p>
<p>In this section, besides product-level variables as I explained before, there are also variables for the target device and board-level variables. The following is a list of variables for the target devices that are defined in <kbd>BoardConfig.mk</kbd>, <kbd>device.mk</kbd>, or product definition Makefiles:</p>
<ul>
<li><kbd>TARGET_ARCH</kbd>: This is the architecture of the device. It is usually something such as <kbd>arm</kbd>, <kbd>x86</kbd>, and so on.</li>
<li><kbd>TARGET_USERIMAGES_USE_EXT4</kbd>: This variable needs to be set as <kbd>true</kbd> to build a filesystem in ext4 format. The filesystem can be built into other formats such as yaffs2 in the older Android version prior to Android 4.4.</li>
<li><kbd>TARGET_KERNEL_SOURCE</kbd>: This is the path for the kernel source code. In our case, the kernel source code can be found at <kbd>$AOSP/kernel</kbd>.</li>
<li><kbd>TARGET_KERNEL_CONFIG</kbd> : The kernel configuration file that we use to build the kernel source.</li>
</ul>
<p>The following is a list of board-level variables that we used in this chapter:</p>
<ul>
<li><kbd>BOARD_SYSTEMIMAGE_PARTITION_SIZE</kbd>: The size of the filesystem partition for the system image (<kbd>system.img</kbd>)</li>
<li><kbd>BOARD_USERDATAIMAGE_PARTITION_SIZE</kbd>: The size of the filesystem partition for the user data (<kbd>userdata.img</kbd>)</li>
<li><kbd>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE</kbd>: The filesystem format of cache partition</li>
<li><kbd>BOARD_FLASH_BLOCK_SIZE</kbd>: The block size of the flash device</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Building and testing x86emu</h1>
            

            
                
<p>Once we have the source code, we can start to build and test our x86emu device in this section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Building x86emu</h1>
            

            
                
<p>Before we start to build x86emu, let's have a quick look at the Android build system first. The major difference between the Android build system from other make-based build systems is that the Android build system doesn't rely on recursive Makefiles. Android Makefiles end in the extension <kbd>.mk</kbd>; the main Makefile for a particular source directory is named <kbd>Android.mk</kbd>. The build system imports all <kbd>Android.mk</kbd> from various folders to create one large Makefile to start the build, as we can see from the following code snippet:</p>
<pre>
$ make -j4 <br/>============================================ <br/>PLATFORM_VERSION_CODENAME=REL <br/>PLATFORM_VERSION=7.1.1 <br/>TARGET_PRODUCT=x86emu <br/>TARGET_BUILD_VARIANT=eng <br/>TARGET_BUILD_TYPE=release <br/>TARGET_BUILD_APPS= <br/>... <br/>HOST_BUILD_TYPE=release <br/>BUILD_ID=MOB30Z <br/>OUT_DIR=out <br/>============================================ <br/>including ./abi/cpp/Android.mk ... <br/>including ./art/Android.mk ... <br/>including ./bionic/Android.mk ... <br/>... 
</pre>
<p>Before we start the build, we must set up the build environment first. The Android build system provides a <kbd>build/envsetup.sh</kbd> script for the build environment setup. We can set up the build environment by running the following command:</p>
<pre>
<strong>$ source build/envsetup.sh</strong>  
</pre>
<p>After this, we need to specify the target that we want to build. In Android build system terms, this is called a lunch-combo. We can specify a lunch-combo directly:</p>
<pre>
<strong>$ lunch x86emu_x86-eng</strong>  
</pre>
<p>Or select it from a list in a menu:</p>
<pre>
<strong>$ lunch</strong><br/><br/><strong>You're building on Linux</strong><br/><br/><strong>Lunch menu... pick a combo:</strong><br/><strong>     1. aosp_arm-eng</strong><br/><strong>     2. aosp_arm64-eng</strong><br/><strong>     3. aosp_mips-eng</strong><br/><strong>     4. aosp_mips64-eng</strong><br/><strong>     5. aosp_x86-eng</strong><br/><strong>     6. aosp_x86_64-eng</strong><br/><strong>     7. x86emu_x86-eng</strong><br/><strong>     8. x86emu_x86-userdebug</strong><br/><strong>     9. x86emu_x86-user</strong><br/><br/><strong>Which would you like? [aosp_arm-eng] 7</strong><br/><br/><strong>============================================</strong><br/><strong>PLATFORM_VERSION_CODENAME=REL</strong><br/><strong>PLATFORM_VERSION=7.1.1</strong><br/><strong>TARGET_PRODUCT=x86emu_x86</strong><br/><strong>TARGET_BUILD_VARIANT=eng</strong><br/><strong>TARGET_BUILD_TYPE=release</strong><br/><strong>TARGET_BUILD_APPS=</strong><br/><strong>TARGET_ARCH=x86</strong><br/><strong>TARGET_ARCH_VARIANT=x86</strong><br/><strong>TARGET_CPU_VARIANT=</strong><br/><strong>TARGET_2ND_ARCH=</strong><br/><strong>TARGET_2ND_ARCH_VARIANT=</strong><br/><strong>TARGET_2ND_CPU_VARIANT=</strong><br/><strong>HOST_ARCH=x86_64</strong><br/><strong>HOST_2ND_ARCH=x86</strong><br/><strong>HOST_OS=linux</strong><br/><strong>HOST_OS_EXTRA=Linux-4.2.0-27-generic-x86_64-with-Ubuntu-14.04-trusty</strong><br/><strong>HOST_CROSS_OS=windows</strong><br/><strong>HOST_CROSS_ARCH=x86</strong><br/><strong>HOST_CROSS_2ND_ARCH=x86_64</strong><br/><strong>HOST_BUILD_TYPE=release</strong><br/><strong>BUILD_ID=NMF26O</strong><br/><strong>OUT_DIR=out</strong><br/><strong>============================================</strong>  
</pre>
<p>We learnt this in <a href="984e0cef-7bf6-4454-bede-bb34c553be12.xhtml">Chapter 2</a>, <em>Setting Up the Development Environment</em>, when we built the Android emulator image. You may notice that the difference here in the menu items is that the menu includes the device configurations added by us in this chapter.</p>
<p>The lunch-combo that we select here is <kbd>x86emu_x86-eng</kbd>. We can start to build the target now using the following command:</p>
<pre>
<strong>$ make -j4</strong>  
</pre>
<p>Or:</p>
<pre>
<strong>$ m -j4</strong>  
</pre>
<p>The <kbd>-j4</kbd> option is used to specify the number of concurrent make sessions. It is related to the number of CPU cores that you have on your system, for example, you may choose <kbd>-j8</kbd> in a more powerful hardware platform. The <kbd>m</kbd> command is available after we execute <kbd>source build/envsetup.sh</kbd>. It is equivalent to <kbd>croot; make -j4</kbd>.</p>
<p>If you want to see the actual commands in the build, you can use the <kbd>showcommands</kbd> option on the command line:</p>
<pre>
<strong>$ make -j4 showcommands</strong>  
</pre>
<p>You may use other frequently used build targets. Here is a list of them that you may refer to in your build:</p>
<ul>
<li><kbd>make sdk</kbd>: Build the tools that are part of an SDK (<kbd>adb</kbd>, <kbd>fastboot</kbd>, and so on).</li>
<li><kbd>make snod</kbd>: Build the system image from the current software binaries.</li>
<li><kbd>make all</kbd>: Make everything, whether it is included in the product definition or not.</li>
<li><kbd>make clean</kbd>: Remove all built files (prepare for a new build). It is the same as <kbd>rm -rf out/&lt;configuration&gt;/</kbd>.</li>
<li><kbd>make modules</kbd>: Shows a list of submodules that can be built (a list of all <kbd>LOCAL_MODULE</kbd> definitions).</li>
<li><kbd>make &lt;local_module&gt;</kbd>: Make a specific module (note that this is not the same as the directory name. It is the <kbd>LOCAL_MODULE</kbd> definition in the <kbd>Android.mk</kbd> file).</li>
<li><kbd>make clean-&lt;local_module&gt;</kbd>: Clean a specific module.</li>
<li><kbd>make bootimage TARGET_PREBUILT_KERNEL=/path/to/bzImage</kbd>: Create a new boot image with custom <kbd>bzImage</kbd>.</li>
<li><kbd>make recoveryimage</kbd>: Make the recovery in <kbd>bootable/recovery/</kbd>.</li>
</ul>
<p>Besides the build targets, there are some helper macros and functions that are installed when you source <kbd>envsetup.sh</kbd>. You can find out what they are by using the <kbd>hmm</kbd> command:</p>
<pre>
<strong>$ hmm</strong><br/><strong>Invoke ". build/envsetup.sh" from your shell to add the following functions to your environment:</strong><br/><strong>- lunch:   lunch &lt;product_name&gt;-&lt;build_variant&gt;</strong><br/><strong>- tapas:   tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips|armv5|arm64|x86_64|mips64] [eng|userdebug|user]</strong><br/><strong>- croot:   Changes directory to the top of the tree.</strong><br/><strong>- m:       Makes from the top of the tree.</strong><br/><strong>- mm:      Builds all of the modules in the current directory, but not their dependencies.</strong><br/><strong>- mmm:     Builds all of the modules in the supplied directories, but not their dependencies.</strong><br/><strong>           To limit the modules being built use the syntax: mmm dir/:target1,target2.</strong><br/><strong>- mma:     Builds all of the modules in the current directory, and their dependencies.</strong><br/><strong>- mmma:    Builds all of the modules in the supplied directories, and their dependencies.</strong><br/><strong>- cgrep:   Greps on all local C/C++ files.</strong><br/><strong>- ggrep:   Greps on all local Gradle files.</strong><br/><strong>- jgrep:   Greps on all local Java files.</strong><br/><strong>- resgrep: Greps on all local res/*.xml files.</strong><br/><strong>- mangrep: Greps on all local AndroidManifest.xml files.</strong><br/><strong>- sepgrep: Greps on all local sepolicy files.</strong><br/><strong>- sgrep:   Greps on all local source files.</strong><br/><strong>- godir:   Go to the directory containing a file.</strong><br/><br/><strong>Environemnt options:</strong><br/><strong>- SANITIZE_HOST: Set to 'true' to use ASAN for all host modules. Note that</strong><br/><strong>                 ASAN_OPTIONS=detect_leaks=0 will be set by default until </strong><br/><strong>                 the build is leak-check clean.</strong><br/><br/><strong>Look at the source to view more functions. The complete list is:</strong><br/><strong>addcompletions add_lunch_combo cgrep check_product check_variant choosecombo chooseproduct choosetype choosevariant core coredump_enable coredump_setup cproj croot findmakefile get_abs_build_var getbugreports get_build_var getdriver getlastscreenshot get_make_command getprebuilt getscreenshotpath getsdcardpath gettargetarch gettop ggrep godir hmm is isviewserverstarted jgrep key_back key_home key_menu lunch _lunch m make mangrep mgrep mm mma mmm mmma pez pid printconfig print_lunch_menu qpid rcgrep resgrep runhat runtest sepgrep set_java_home setpaths set_sequence_number set_stuff_for_environment settitle sgrep smoketest stacks startviewserver stopviewserver systemstack tapas tracedmdump treegrep</strong>  
</pre>
<p>After we build the target successfully, we can find the images at <kbd>out/target/product/x86emu</kbd> in our case. We can also use the environment variable <kbd>$OUT</kbd> as follows to list the build output:</p>
<pre>
<strong>$ ls -F $OUT</strong><br/><strong>Android-info.txt  dex_bootjars/             ramdisk.img           symbols/</strong><br/><strong>boot.img          gen/                      ramdisk-recovery.img  system/</strong><br/><strong>cache/            installed-files.txt       recovery/             system.img</strong><br/><strong>cache.img         kernel                    recovery.id           userdata.img</strong><br/><strong>clean_steps.mk    obj/                      recovery.img</strong><br/><strong>data/             previous_build_config.mk  root/</strong>  
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Testing x86emu</h1>
            

            
                
<p>To test x86emu, we can use the AVD <kbd>a25x86</kbd> that we created in <a href="984e0cef-7bf6-4454-bede-bb34c553be12.xhtml">Chapter 2</a>, <em>Setting Up the Development Environment</em>. To use our own system images, we can create a shell script <kbd>~/bin/test-ch04.sh</kbd> as follows:</p>
<pre>
#!/bin/sh <br/><br/>emulator @a25x86 -verbose -show-kernel -shell -selinux disabled -system ${OUT}/system.img -ramdisk ${OUT}/ramdisk.img -initdata ${OUT}/userdata.img -kernel ${OUT}/kernel 
</pre>
<p>You can see from the preceding shell script that the images for x86emu are used to start the AVD <kbd>a25x86</kbd>. You need to set your Android SDK path so you can use the emulator from Android SDK:</p>
<pre>
<strong>$ test-ch04.sh</strong>  
</pre>
<p>After you start the emulator, you can go to Settings | About phone to check the build information, as shown in the following screenshot:</p>
<div><img height="459" width="267" class="image-border" src="img/6099_04_01.png"/></div>
<p>x86emu build information</p>
<p>We can see from About phone that Model is x86emu_android-7.1.1_r4_ch04, which we specified in the product definition Makefile <kbd>x86emu_x86.mk</kbd>. Kernel version is 3.10.0 and Build number is the build target x86emu_x86-eng.</p>
<p>If you want to test the images in this chapter without setting up your own build, you can download the images from SourceForge at <a href="https://sourceforge.net/projects/Android-system-programming/files/android-7/ch04/">https://sourceforge.net/projects/Android-system-programming/files/android-7/ch04/</a>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Integrating with Eclipse</h1>
            

            
                
<p>You may use an <strong>Integrated Development Environment</strong> (<strong>IDE</strong>) for your development work. It is possible to integrate the AOSP build environment and selected projects into your favorite IDE. Here, I will use Eclipse as an example to explain how to integrate our projects and AOSP build environment in Eclipse. Be aware that since AOSP can only be built in the Linux environment, this can only work for Linux as well.</p>
<p>Even though Android Studio is the default IDE for Android application development, I prefer Eclipse for Android system programming. With Eclipse, we can build both native and Java applications. We can also integrate AOSP builds in Eclipse projects.</p>
<p>To set up the Eclipse environment, you can use the latest Eclipse with ADT plugin or you can download an old ADT bundle from Google.</p>
<p>For Linux x86 or x86_64:</p>
<ul>
<li><a href="http://dl.google.com/Android/adt/adt-bundle-linux-x86_64-20140702.zip">http://dl.google.com/Android/adt/adt-bundle-linux-x86_64-20140702.zip</a></li>
<li><a href="http://dl.google.com/Android/adt/adt-bundle-linux-x86-20140702.zip">http://dl.google.com/Android/adt/adt-bundle-linux-x86-20140702.zip</a></li>
</ul>
<p>To use Eclipse, we need to create a Makefile for our x86emu device build as follows:</p>
<pre>
all: <br/>   cd ../../..;make -j8 showcommands 2&gt;&amp;1 | tee x86emu-`date +%Y%m%d`.txt <br/><br/>x86emu: <br/>   cd ../../..;make -j4 <br/><br/>snod: <br/>   cd ../../..;make snod <br/><br/>initrd: <br/>   cd ../../..;make initrd USE_SQUASHFS=0 <br/><br/>ramdisk: <br/>   cd ../../..;make -j4 <br/><br/>clean-ramdisk: <br/>   rm ${OUT}/ramdisk.img <br/>   rm -rf ${OUT}/root <br/><br/>clean-initrd: <br/>   rm ${OUT}/initrd.img <br/>   rm -rf ${OUT}/installer 
</pre>
<p>We need to define a few build targets that can be used in Eclipse. Let's see how to import an x86emu device build into the Eclipse project. We will use Eclipse from the ADT bundle to explain the process. To integrate the AOSP build with Eclipse, we must launch Eclipse in the AOSP build environment. Let's start Eclipse as follows:</p>
<pre>
<strong>$ source build/envsetup.sh</strong><br/><strong>$ lunch x86emu_x86-eng</strong><br/><strong>${SDK_ROOT}/eclipse/eclipse</strong>  
</pre>
<p>After we have installed the ADT bundle, we can find Eclipse in the preceding directory under the SDK installation path. After we launch Eclipse, select the C/C++ Perspective, as shown in the following screenshot:</p>
<div><img height="328" width="257" class=" image-border" src="img/image_04_003.png"/></div>
<p>Select the C/C++ perspective</p>
<p>We can import the x86emu directory as an existing Makefile project to Eclipse by selecting File | Import... | Existing Code as Makefile Project, as shown in the following screenshot:</p>
<div><img height="458" width="510" class=" image-border" src="img/image_04_004.png"/></div>
<p>Importing existing code as a Makefile project</p>
<p>Click on Next and navigate to the <kbd>$AOSP/device/generic/x86emu</kbd> folder to import the source code, as shown in the following screenshot:</p>
<div><img height="470" width="489" class=" image-border" src="img/image_04_005.png"/></div>
<p>Import existing code</p>
<p>Once we import the project, we should be able to see that all files under the <kbd>x86emu</kbd> folder are shown on the right-hand side in Project Explorer, as we can see in the following screenshot. Then we can click the right mouse button to see the menu list for the project and select Make Targets | Create... | Create Make Target. We can add the build target that we defined in the Makefile in the Target name field. If we define the default build target <kbd>all</kbd>, the default build in Eclipse will trigger the build target <kbd>all</kbd> in our <kbd>Makefile</kbd>. This is what we defined for build target <kbd>all</kbd>:</p>
<pre>
all: <br/>   cd ../../..;make -j8 showcommands 2&gt;&amp;1 | tee x86emu-`date +%Y%m%d`.txt 
</pre>
<p>What we do here is launch the AOSP build at the AOSP root directory. We also generate a log file for the build using a naming convention, <kbd>x86emu-{$DATE}.txt</kbd>, and you can find this log file at the AOSP root folder after the build is completed.</p>
<div><img height="397" width="670" class=" image-border" src="img/image_04_006.png"/></div>
<p>Creating a Make Target in Eclipse</p>
<p>After we create all build targets, we can build AOSP from Eclipse by selecting Project | Build All or use the shortcut <em>Ctrl</em> + <em>B</em> to launch the build.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we learnt how to create a new device based on the Android emulator build for Intel x86 architecture. We explained the different build layers in the AOSP built system and how these build layers associate with Makefiles for a device. After that, we build and tested the new x86emu device. Finally, to improve the efficiency of development work, we integrated the AOSP build in Eclipse. In the next chapter, we will extend Android emulator to support ARM binary translation using the x86emu device.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>