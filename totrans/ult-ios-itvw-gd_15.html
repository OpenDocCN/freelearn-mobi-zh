<html><head></head><body>
		<div><h1 id="_idParaDest-212" class="chapter-number"><a id="_idTextAnchor329" class="calibre6 pcalibre pcalibre1"/>11</h1>
			<h1 id="_idParaDest-213" class="calibre5"><a id="_idTextAnchor330" class="calibre6 pcalibre pcalibre1"/>Design Patterns to Solve Complex Questions</h1>
			<p class="calibre3">In previous chapters, we discussed different aspects of iOS development. We covered UIKit, Swift, reactive programming, SwiftUI, Core Data, and many more. These building blocks help us achieve our next level – design patterns.</p>
			<p class="calibre3">Design patterns are like tools. Each one of them solves a different problem or a different need, such as the following:</p>
			<ul class="calibre10">
				<li class="calibre11">Do we need to change the behavior of a particular instance? We can use <strong class="bold">dependency </strong><strong class="bold">injection</strong> (<strong class="bold">DI</strong>).</li>
				<li class="calibre11">Do we have a complex state to manage? We can use <strong class="bold">Model-View-ViewModel </strong>(<strong class="bold">MVVM</strong>).</li>
				<li class="calibre11">Do we need to define communication between objects? We can use delegation.</li>
			</ul>
			<p class="calibre3">The more we expand our toolbox with design patterns, the more problems we can solve. <a id="_idTextAnchor331" class="calibre6 pcalibre pcalibre1"/><a id="_idTextAnchor332" class="calibre6 pcalibre pcalibre1"/>We should remember that design patterns alone are not our goal – they are tools to accomplish our tasks. We should remember that we’ll have to pick a particular design pattern or talk about it in our interviews.</p>
			<p class="calibre3">In this chapter, we’ll cover some commonly used design patterns in iOS development. We’ll do the following:</p>
			<ul class="calibre10">
				<li class="calibre11">Discuss <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) and MVVM, including some interview questions</li>
				<li class="calibre11">Decouple our code using DI</li>
				<li class="calibre11">Improve communication with delegation</li>
				<li class="calibre11">Share a state with Singletons</li>
				<li class="calibre11">Improve performance using Concurrency</li>
			</ul>
			<p class="calibre3">One of the most commonly asked topics in interviews is the first on the list – MVC and MVVM. So, let’s dive right into it.</p>
			<h1 id="_idParaDest-214" class="calibre5"><a id="_idTextAnchor333" class="calibre6 pcalibre pcalibre1"/>Building a UI with MVC/MVVM</h1>
			<p class="calibre3">Several known <a id="_idIndexMarker818" class="calibre6 pcalibre pcalibre1"/>design patterns can help us build stable and<a id="_idIndexMarker819" class="calibre6 pcalibre pcalibre1"/> complex screens, but MVC <a id="_idIndexMarker820" class="calibre6 pcalibre pcalibre1"/>and MVVM are the most common and famous patterns.</p>
			<p class="calibre3">Like many development areas, the topic of MVC and MVVM can be subject to personal preferences and opinions and may not always align with practical considerations. We always need to be careful with that, especially when interviewing for a job. Let me explain what I mean.</p>
			<h2 id="_idParaDest-215" class="calibre7"><a id="_idTextAnchor334" class="calibre6 pcalibre pcalibre1"/>Solving different problems with MVC and MVVM</h2>
			<p class="calibre3">I want to<a id="_idIndexMarker821" class="calibre6 pcalibre pcalibre1"/> go over<a id="_idIndexMarker822" class="calibre6 pcalibre pcalibre1"/> several sentences I suggest avoiding when having a professional discussion with an interviewer or even colleagues:</p>
			<ul class="calibre10">
				<li class="calibre11">“My app is built with MVVM architecture.”</li>
				<li class="calibre11">“MVC is antique and a horrible architecture. I never use it.”</li>
				<li class="calibre11">“This is not how MVVM works. Let me show you.”</li>
			</ul>
			<p class="calibre3">Remember what I’ve said multiple times throughout the book – we should avoid dichotomous thinking as developers. MVC and MVVM solve different problems, and we should think of both patterns as different solutions to various issues.</p>
			<p class="calibre3">In fact, we can use different design patterns in the same app, in the same feature, or even on the same screen.</p>
			<p class="calibre3">Additionally, there is more than one way to implement MVC and MVVM. What’s more important is to follow the different principles and explain them.</p>
			<p class="calibre3">Let’s start with the more straightforward pattern – MVC.</p>
			<h2 id="_idParaDest-216" class="calibre7"><a id="_idTextAnchor335" class="calibre6 pcalibre pcalibre1"/>Learning MVC</h2>
			<p class="calibre3">MVC stands for <a id="_idIndexMarker823" class="calibre6 pcalibre pcalibre1"/>Model-View-Controller. When the iOS development era started, Apple used MVC to demonstrate best practices for building UI screens, and it was the primary design pattern for building apps.</p>
			<p class="calibre3">The basic principle of MVC is a separation between the <em class="italic">View,</em> which is what the user sees and interacts with, and the <em class="italic">Model,</em> which represents the business logic and the data layer.</p>
			<p class="calibre3">In MVC, there’s no direct connection between the View and the Model, and all the data flow is done using the <em class="italic">Controller</em>.</p>
			<p class="calibre3">Let’s have a look at a classic MVC pattern (<em class="italic">Figure 11</em><em class="italic">.1</em>):</p>
			<div><div><img src="img/Figure_11.01_B18653.jpg" alt="Figure 11.1 – MVC design pattern" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.1 – MVC design pattern</p>
			<p class="calibre3">In <em class="italic">Figure 11</em><em class="italic">.1</em>, we can see that the View and the Model communicate with each other using the controller. This separation allows us to reuse each component in different use cases across our project.</p>
			<p class="calibre3">How can we implement MVC in the iOS world? Let’s see:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">View</strong>: The View<a id="_idIndexMarker824" class="calibre6 pcalibre pcalibre1"/> represents the UI displayed on the screen. Therefore, we typically implement it with one of the UIKit view elements, such as buttons, labels, and text fields (we’ll talk about SwiftUI in a second).</li>
				<li class="calibre11"><strong class="bold">Model</strong>: The Model is our data and business logic. We implement it using data structures, persistent storage, different algorithms, and network requests.</li>
				<li class="calibre11"><strong class="bold">Controller</strong>: The controller in iOS development is mostly <strong class="source-inline1">UIViewController</strong> and its<a id="_idIndexMarker825" class="calibre6 pcalibre pcalibre1"/> different subclasses, such as <strong class="source-inline1">UITableViewController</strong> and <strong class="source-inline1">UIAlertController</strong>.</li>
			</ul>
			<p class="calibre3">One thing to notice is how Apple implements the MVC pattern in iOS. <code>UIViewController</code> is not really a pure controller like we saw in <em class="italic">Figure 11</em><em class="italic">.1</em>. It has a view of its own and is responsible for user interaction. In a way, <code>UIViewController</code> is part of the UI, not just a controller.</p>
			<p class="calibre3">Things are a little different with SwiftUI – the SwiftUI pattern resembles MVVM rather than MVC. We'll examine this more closely when we get to MVVM.</p>
			<p class="calibre3">Let’s see how to<a id="_idIndexMarker826" class="calibre6 pcalibre pcalibre1"/> implement MVC in iOS. Here is the Model part:</p>
			<pre class="source-code">
class Person {    var name: String
    var age: Int
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    func canVote() -&gt; Bool {
        return age &gt;= 18
    }
}</pre>
			<p class="calibre3"><code>Person</code> represents the data structure and has a logic function (<code>canVote()</code>). It doesn’t have any reference to the view or even to the controller.</p>
			<p class="calibre3">And here’s the View:</p>
			<pre class="source-code">
class PersonView: UIView {    var nameLabel: UILabel
    var ageLabel: UILabel
    var canVoteLabel: UILabel
    init(frame: CGRect) {
        super.init(frame: frame)
        nameLabel = UILabel()
        ageLabel = UILabel()
        canVoteLabel = UILabel()
    }
    func configure(with person: Person) {
        nameLabel.text = person.name
        ageLabel.text = "\(person.age)"
        canVoteLabel.text = person.canVote() ? "Can vote" :
            "Can't vote"
    }
}</pre>
			<p class="calibre3">We can see that the <code>PersonView</code> class has nothing to do with logic and focuses purely on UI presentation. This <a id="_idIndexMarker827" class="calibre6 pcalibre pcalibre1"/>allows it to be reusable with other logic and models.</p>
			<p class="calibre3">Notice that <code>PersonView</code> has a <code>configure(with person:Person)</code> function. This common practice helps us load the view with a specific model. We can move this code to an extension and increase the code separation.</p>
			<p class="calibre3">Now, let’s move on to the controller:</p>
			<pre class="source-code">
class PersonViewController: UIViewController {    var person: Person
    var personView: PersonView
    init(person: Person) {
        self.person = person
        personView = PersonView()
        super.init(nibName: nil, bundle: nil)
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        view.addSubview(personView)
        personView.configure(with: person)
    }
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}</pre>
			<p class="calibre3"><code>PersonViewController</code> has a <a id="_idIndexMarker828" class="calibre6 pcalibre pcalibre1"/>reference to both <code>Person</code> and <code>PersonView</code> and is responsible for linking between them and loading the view with data from <code>Person</code>. Notice that <code>PersonView</code> and <code>Person</code> don’t have a reference to each other – <code>PersonViewController</code> acts as the controller and sets up what is needed in the <code>viewDidLoad</code> function.</p>
			<p class="calibre3">Earlier, we discussed how MVC improves our code to make it reusable, as we can reuse the Model and View components. In iOS development, we should also consider MVC as a self-contained unit we can reuse.</p>
			<p class="calibre3">For example, we can have a screen that is built upon two embedded view controllers, each one of which is an MVC unit. Look at <em class="italic">Figure 11</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/Figure_11.02_B18653.jpg" alt="Figure 11.2 – Two embedded MVC units" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Two embedded MVC units</p>
			<p class="calibre3">An MVC unit doesn’t have to be a whole screen – this approach can help us reuse part of the screen and extend our project’s flexibility.</p>
			<p class="calibre3">The MVC pattern is <a id="_idIndexMarker829" class="calibre6 pcalibre pcalibre1"/>excellent for simple screens that don’t require complex state and data manipulation. In this case, we must move to a more complex pattern – MVVM.</p>
			<h2 id="_idParaDest-217" class="calibre7"><a id="_idTextAnchor336" class="calibre6 pcalibre pcalibre1"/>Exploring MVVM</h2>
			<p class="calibre3">I believe this is a<a id="_idIndexMarker830" class="calibre6 pcalibre pcalibre1"/> critical checkpoint in the chapter (and maybe even in the whole book). Developers tend to be attached to a specific pattern, especially related to the UI. MVVM is not “better” than “MVC” and vice versa. They are both patterns for different use cases, which is crucial to explain in an interview. We should never be tied to a specific technology or pattern, especially not in interviews.</p>
			<p class="calibre3">We said that MVC is not the best pattern for complex state and data management. But why?</p>
			<p class="calibre3">Complex screens require state management – to show/hide certain UI elements, update text, change colors, and present dynamic information on the screen. All of this can make our view controller bloated.</p>
			<p class="calibre3">That’s why iOS developers used to rely on MVC in the first era of the App Store but quickly moved on to a more suitable pattern – MVVM.</p>
			<p class="calibre3">MVVM stands for Model-View-ViewModel. The idea is that the View is connected to the Model using a <strong class="bold">ViewModel</strong> – another component that can help us manage the state and manipulate data.</p>
			<p class="calibre3">Look at <em class="italic">Figure 11</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_11.03_B18653.jpg" alt="Figure 11.3 – The MVVM design pattern" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The MVVM design pattern</p>
			<p class="calibre3">In <em class="italic">Figure 11</em><em class="italic">.3</em>, we can see that the ViewModel stands between the View and Model like the controller in the MVC pattern.</p>
			<p class="calibre3">But in MVVM, the<a id="_idIndexMarker831" class="calibre6 pcalibre pcalibre1"/> responsibilities of the different components are much more transparent and intuiitive.</p>
			<p class="calibre3">Let’s go over the <a id="_idIndexMarker832" class="calibre6 pcalibre pcalibre1"/>different components now:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">View</strong>: The View is responsible for presenting the information and responding to user interaction. It’s the only component with access to the UIKit framework (we’ll talk about SwiftUI shortly), which is a significant difference from the MVC pattern we discussed earlier.</li>
				<li class="calibre11"><strong class="bold">ViewModel</strong>: The ViewModel handles the state and prepares data for presentation. Also, the ViewModel decides on user interaction and moves the requests forward to the Model layer.</li>
				<li class="calibre11"><strong class="bold">Model</strong>: The Model layer is the actual business logic and is responsible for accessing the persistent<a id="_idIndexMarker833" class="calibre6 pcalibre pcalibre1"/> store and performing network requests.</li>
			</ul>
			<p class="calibre3">Notice that the View and the ViewModel communicate<a id="_idIndexMarker834" class="calibre6 pcalibre pcalibre1"/> using <strong class="bold">data binding</strong>, which connects the input field to the corresponding data model. In fact, the ViewModel doesn’t even have a reference to the view – the view observes changes in the ViewModel and refreshes itself accordingly.</p>
			<p class="calibre3">That’s where SwiftUI and Combine come in handy. In SwiftUI, for example, the ViewModel is usually derived<a id="_idIndexMarker835" class="calibre6 pcalibre pcalibre1"/> from the <code>@ObservableObject</code> class with <code>@</code><code>Published</code> properties.</p>
			<p class="callout-heading">Forgot about SwiftUI and Combine?</p>
			<p class="callout">Now is a good time to return to <a href="B18653_08.xhtml#_idTextAnchor249" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 8</em></a> and refresh your memory regarding SwiftUI and Combine. It looks like Apple took a close look at how developers develop screens and built a dedicated framework for MVVM.</p>
			<p class="calibre3">Now, let’s see MVVM in practice.</p>
			<h3 class="calibre9">Going over some code examples</h3>
			<p class="calibre3">Let’s see a code <a id="_idIndexMarker836" class="calibre6 pcalibre pcalibre1"/>example of the MVVM design pattern. In our example, we have a screen with a label that shows the status of a loading request (<strong class="bold">Loading…</strong>, <strong class="bold">Ready</strong>, or <strong class="bold">Error</strong>). The label is bound to a specific ViewModel that communicates with the Model and updates its View.</p>
			<p class="calibre3">Let’s start with the ViewModel:</p>
			<pre class="source-code">
import Foundationimport Combine
class StatusViewModel {
    private let networkService: NetworkService
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private let statusDidChange = PassthroughSubject
        &lt;String, Never&gt;()
    var status: String = "Loading..." {
        didSet {
            statusDidChange.send(status)
        }
    }
    init(networkService: NetworkService) {
        self.networkService = networkService
    }
    func fetchStatus() {
        networkService.fetchStatus()
            .sink { completion in
                switch completion {
                case .failure(let error):
                    self.status = "Error: \
                        (error.localizedDescription)"
                case .finished:
                    break
                }
            } receiveValue: { isReady in
                self.status = isReady ? "Ready" : "Not ready"
            }
            .store(in: &amp;cancellables)
    }</pre>
			<p class="calibre3">And now, let’s<a id="_idIndexMarker837" class="calibre6 pcalibre pcalibre1"/> observe the status change:</p>
			<pre class="source-code">
    func observeStatusChange(handler: @escaping (String) -&gt;        Void) {
        statusDidChange
            .receive(on: RunLoop.main)
            .sink { status in
                handler(status)
            }
            .store(in: &amp;cancellables)
    }
}</pre>
			<p class="calibre3">The code example is a bit long, yet simple to understand. The ViewModel observes a network request-response and updates its values using a Combine pattern. The combine stream starts with the network service and forwards the results to the <code>status</code> property, which can be observed by the view. Notice that the ViewModel doesn’t deal with any UI elements – that’s<a id="_idIndexMarker838" class="calibre6 pcalibre pcalibre1"/> the View’s job.</p>
			<p class="calibre3">Now, let’s see the View:</p>
			<pre class="source-code">
import UIKitclass StatusLabel: UILabel {
    var viewModel: StatusViewModel? {
        didSet {
            viewModel?.observeStatusChange { [weak self]
                status in
                self?.text = status
            }
            viewModel?.fetchStatus()
        }
    }
}</pre>
			<p class="calibre3">The <code>StatusLabel</code> class has a direct reference to the ViewModel, and it observes changes to refresh itself.</p>
			<p class="calibre3">The only thing left to do is to connect the view with the ViewModel, and that’s the only job of the view <a id="_idIndexMarker839" class="calibre6 pcalibre pcalibre1"/>controller in this case:</p>
			<pre class="source-code">
import UIKitclass ViewController: UIViewController {
    let networkService = NetworkService()
    let statusViewModel = StatusViewModel(networkService:
        NetworkService())
    let statusLabel = StatusLabel()
    override func viewDidLoad() {
        super.viewDidLoad()
        statusLabel.frame = CGRect(x: 50, y: 50, width:
            200, height: 50)
        statusLabel.textAlignment = .center
        view.addSubview(statusLabel)
        statusLabel.viewModel = statusViewModel
    }
}</pre>
			<p class="calibre3"><code>ViewController</code> injects the ViewModel into the view and <code>NetworkService</code> into the ViewModel. Imagine doing that with MVC, with several components and complex data manipulation; you’d get 3,000 lines of code with a view controller.</p>
			<p class="calibre3">MVVM is a modern design pattern compared to MVC and can help us separate our concerns more efficiently and handle much more complex state management and data manipulation. We can create a ViewModel for each view that we think needs one and organize our <a id="_idIndexMarker840" class="calibre6 pcalibre pcalibre1"/>presentation logic however we want.</p>
			<p class="calibre3">Now let’s move on to some questions about MVC/MVVM design patterns.</p>
			<h2 id="_idParaDest-218" class="calibre7"><a id="_idTextAnchor337" class="calibre6 pcalibre pcalibre1"/>“How would you implement navigation in an MVVM architecture, considering that the ViewModel should not have know<a id="_idTextAnchor338" class="calibre6 pcalibre pcalibre1"/>ledge of the View?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Learning MVVM<a id="_idIndexMarker841" class="calibre6 pcalibre pcalibre1"/> is easy in theory. Binding ViewModel properties to UI elements is simple, but applying it to <em class="italic">real-world problems is the real challenge</em>. One of the most common real-world problems in iOS and mobile is navigation combined with state and logic.</p>
			<p class="calibre3">What is the solution to the navigation problem when the ViewModel lacks a direct reference to the View and the View cannot handle na<a id="_idTextAnchor339" class="calibre6 pcalibre pcalibre1"/>vigation on its own?</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">When discussing navigation, we need to decide on three things:</p>
			<ul class="calibre10">
				<li class="calibre11">How to <em class="italic">trigger</em> the navigation action</li>
				<li class="calibre11">How to <em class="italic">choose</em> where to navigate</li>
				<li class="calibre11">How to <em class="italic">navigate</em></li>
			</ul>
			<p class="calibre3">These are three different responsibilities that can be separated into various components. For example, we can decide that the ViewModel can trigger the navigation action and also choose where to go, while the View can handle the navigation action itself.</p>
			<p class="calibre3">Another option is to decide that the ViewModel triggers the navigation. Still, where to go can be part of the View or another object explicitly dedicated to that.</p>
			<p class="calibre3">Let’s look at <em class="italic">Figure 11</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/Figure_11.04_B18653.jpg" alt="Figure 11.4 – Simple navigation pattern using MVVM" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Simple navigation pattern using MVVM</p>
			<p class="calibre3">In <em class="italic">Figure 11</em><em class="italic">.4</em>, the ViewModel triggers the navigations and notifies the View using a delegate pattern<a id="_idIndexMarker842" class="calibre6 pcalibre pcalibre1"/> or <strong class="bold">Combine</strong>. The View then asks the navigation controller to navigate to a specific <a id="_idIndexMarker843" class="calibre6 pcalibre pcalibre1"/>destination, which is part of the reason view controllers have a reference to the navigation controller. This simple navigation pattern puts the navigation responsibility on the View.</p>
			<p class="calibre3">Here’s how to implement that in code. This is what the ViewModel looks like:</p>
			<pre class="source-code">
import Foundationimport Combine
class MyViewModel {
    private let navigationSubject = PassthroughSubject
        &lt;Void, Never&gt;()
    var navigation: AnyPublisher&lt;Void, Never&gt; {
        return navigationSubject.eraseToAnyPublisher()
    }
    func didTapButton() {
        navigationSubject.send(())
    }
}</pre>
			<p class="calibre3">We can see that the ViewModel has a <code>didTapButton()</code> method and decides to send a message using <code>navigationSubject</code>.</p>
			<p class="calibre3">Now, let’s go<a id="_idIndexMarker844" class="calibre6 pcalibre pcalibre1"/> over the view controller:</p>
			<pre class="source-code">
import UIKitimport Combine
class MyViewController: UIViewController {
    var viewModel: MyViewModel!
    private var cancellables = Set&lt;AnyCancellable&gt;()
    let button = UIButton()
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        viewModel.navigation
            .sink { [weak self] in
                self?.navigateToDetails()
            }
            .store(in: &amp;cancellables)
    }
    private func setupUI() {
        button.addTarget(self, action: #selector
            (didTapButton), for: .touchUpInside)
    }
    @objc private func didTapButton() {
        viewModel.didTapButton()
    }
    private func navigateToDetails() {
        let detailsViewController = DetailsViewController()
        navigationController?.pushViewController
        (detailsViewController, animated: true)
    }
}</pre>
			<p class="calibre3">The ViewModel<a id="_idIndexMarker845" class="calibre6 pcalibre pcalibre1"/> navigation subject triggers the navigation according to its own logic, which in this case is tapping the button.</p>
			<p class="calibre3"><code>ViewController</code> observes the ViewModel navigation publishers and pushes <code>detailsViewcontroller</code> using the navigation controller.</p>
			<p class="calibre3">As mentioned, this pattern is simple and puts a lot of responsibility on the view controller. If we want to separate our code, we can delegate the navigation responsibility to another class (<strong class="bold">Coordinator</strong>). See <em class="italic">Figure 11</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/Figure_11.05_B18653.jpg" alt="Figure 11.5 – MVVM and coordinator pattern" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.5 – MVVM and coordinator pattern</p>
			<p class="calibre3">In the coordinator pattern, the ViewModel notifies the coordinator about a navigation intent, which pushes<a id="_idIndexMarker846" class="calibre6 pcalibre pcalibre1"/> a new screen. See how the ViewModel looks now:</p>
			<pre class="source-code">
import Foundationimport Combine
class MyViewModel {
    private let didTapButtonSubject = PassthroughSubject
        &lt;Void, Never&gt;()
    var didTapButtonPublisher: AnyPublisher&lt;Void, Never&gt; {
        return didTapButtonSubject.eraseToAnyPublisher()
    }
    func didTapButton() {
        didTapButtonSubject.send(())
    }
}</pre>
			<p class="calibre3">The ViewModel sends a message with the button tap, and the coordinator can subscribe to it and respond. This<a id="_idIndexMarker847" class="calibre6 pcalibre pcalibre1"/> is what the coordinator looks like:</p>
			<pre class="source-code">
class MyMainCoordinator: MyCoordinator {    private var cancellables = Set&lt;AnyCancellable&gt;()
    func start() {
        let viewModel = MyViewModel()
        viewModel.didTapButtonPublisher
            .sink { [weak self] _ in self?.didTapButton()
            }
            .store(in: &amp;cancellables)
        let viewController = MyViewController()
        viewController.viewModel = viewModel
        navigationController.pushViewController
            (viewController, animated: true)
    }
    func didTapButton() {
        let detailsViewController = DetailsViewController()
        navigationController.pushViewController
            (detailsViewController,<a id="_idTextAnchor340" class="pcalibre pcalibre1 calibre17"/> animated: true)
    }
}</pre>
			<p class="calibre3">We can see that the coordinator creates the ViewModel and the view, then wires everything together. In the previous example, the view controller observed the ViewModel events and pushed a new view controller. Similarly, in this case, the coordinator observes <code>didTapButtonPublisher</code> and decides to push a new view controller – <code>DetailsViewController</code>. The view and ViewModel are unaware of this transition as it is managed entirely by the coordinator.</p>
			<p class="calibre3">In general, both ways have their pros and cons. Using a coordinator is a powerful and complex pattern. Still, there is little overhead for simpler cases, where we can connect the navigation <a id="_idIndexMarker848" class="calibre6 pcalibre pcalibre1"/>controller to the view controller. What’s important is to understand the navigation principles and balance the responsibilities.</p>
			<h2 id="_idParaDest-219" class="calibre7"><a id="_idTextAnchor341" class="calibre6 pcalibre pcalibre1"/>“Why is the MVVM architecture considered good for testability in iOS app development?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">When designing <a id="_idIndexMarker849" class="calibre6 pcalibre pcalibre1"/>code, tests have become increasingly important in recent years. It’s not just about being able to test the code but also about writing high-quality code that is well structured and easy to maintain. With this in mind, the interviewer wants us to consider the importance of writing testable code in our response.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The MVVM design pattern is suitable for testing because it separates the concerns in an easy way. The state and the data manipulation code, which is the most important part we want to test, is part of the ViewModel. We can set up the ViewModel easily without handling the UI and simply test it by mocking the View.</p>
			<p class="calibre3">We can also test an MVC unit, but since the state management is part of the View Controller or the View, it is more complex than testing an MVVM pattern.</p>
			<p class="calibre3">Here’s a code example of how to test a ViewModel. Let’s start with defining a standard ViewModel:</p>
			<pre class="source-code">
import Foundationimport Combine
class MyViewModel {
    let didTapButton = PassthroughSubject&lt;Void, Never&gt;()
    @Published var labelValue: String = ""
    private var cancellables = Set&lt;AnyCancellable&gt;()
    init() {
        didTapButton
            .map { "Ready" }
            .assign(to: \.labelValue, on: self)
            .store(in: &amp;cancellables)
    }
}</pre>
			<p class="calibre3">We created a ViewModel that handles a tap button and updates a label. Notice that there is no UIKit-related<a id="_idIndexMarker850" class="calibre6 pcalibre pcalibre1"/> code here, so it should be reasonably easy to test. Now, let’s see the test itself:</p>
			<pre class="source-code">
import XCTestimport Combine
@testable import MyProject
class MyViewModelTests: XCTestCase {
    func testLabelValue() {
        let viewModel = MyViewModel()
        let labelValueExpectation = viewModel.$labelValue
            .dropFirst() // Ignore initial value
            .sink { labelValue in XCTAssertEqual(labelValue, "Ready")
            }
        viewModel.didTapButton.send(())
        labelValueExpectation.cancel()
    }
}</pre>
			<p class="calibre3">The <code>testLabelValue()</code> function observes the ViewModel’s <code>labelValue</code> to see whether it equals <code>"Ready"</code> when tapping the button. We did all that without setting up the View, which <a id="_idIndexMarker851" class="calibre6 pcalibre pcalibre1"/>only handles UI logic in this case.</p>
			<h1 id="_idParaDest-220" class="calibre5"><a id="_idTextAnchor342" class="calibre6 pcalibre pcalibre1"/>Decoupling with Dependency Injection</h1>
			<p class="calibre3">DI is a powerful<a id="_idIndexMarker852" class="calibre6 pcalibre pcalibre1"/> pattern that helps us to create modular and testable code. It’s another tool in our toolbox that can help us make our code flexible and decoupled.</p>
			<p class="calibre3">There are several ways to implement DI in iOS, which are discussed next.</p>
			<h2 id="_idParaDest-221" class="calibre7"><a id="_idTextAnchor343" class="calibre6 pcalibre pcalibre1"/>Using constructor injection</h2>
			<p class="calibre3">This is the<a id="_idIndexMarker853" class="calibre6 pcalibre pcalibre1"/> most common form <a id="_idIndexMarker854" class="calibre6 pcalibre pcalibre1"/>of DI in iOS. In constructor injection, dependencies are passed into an object through its initializer. For example, if we have a view controller that depends on a data manager, we can inject the data manager into the view controller’s initializer.</p>
			<p class="calibre3">In the following code example, we created a custom <code>init()</code> function and a private variable to hold the injected data manager:</p>
			<pre class="source-code">
class MyViewController: UIViewController {    private let dataManager: DataManager
    init(dataManager: DataManager) {
        self.dataManager = dataManager
        super.init(nibName: nil, bundle: nil)
    }
}
let viewController = MyViewController
    (dataManager: dataManager)</pre>
			<p class="calibre3">The main advantage of constructor DI is that we have a clear interface with the required dependencies for<a id="_idIndexMarker855" class="calibre6 pcalibre pcalibre1"/> the class, as we<a id="_idIndexMarker856" class="calibre6 pcalibre pcalibre1"/> must pass them in our <code>init()</code> method.</p>
			<h2 id="_idParaDest-222" class="calibre7"><a id="_idTextAnchor344" class="calibre6 pcalibre pcalibre1"/>Simplifying things with setter injection</h2>
			<p class="calibre3">In setter <a id="_idIndexMarker857" class="calibre6 pcalibre pcalibre1"/>injection, setter methods<a id="_idIndexMarker858" class="calibre6 pcalibre pcalibre1"/> pass dependencies into the object. The object declares its dependencies as public properties, and the DI framework sets those properties with the appropriate dependencies. Setter injection is less common than constructor injection but can be helpful when changing the object’s dependencies at runtime.</p>
			<p class="calibre3">Here’s a code example of setter injection:</p>
			<pre class="source-code">
// Define a view controller that depends on a data managerclass MyViewController: UIViewController {
    var dataManager: DataManager?
    }
}
let dataManager = ConcreteDataManager()
let viewController = MyViewController()
viewController.dataManager = dataManager</pre>
			<p class="calibre3">In this example, we haven’t changed the <code>init</code> function of the view controller. After we created the view controller, we passed <code>dataManager</code> using the built-in setter property method.</p>
			<p class="calibre3">The primary advantage of using setter injection is simplicity; we don’t have to modify the <code>init</code> function and <a id="_idIndexMarker859" class="calibre6 pcalibre pcalibre1"/>decoupling. On <a id="_idIndexMarker860" class="calibre6 pcalibre pcalibre1"/>the other hand, this approach is not suitable for the required dependencies.</p>
			<h2 id="_idParaDest-223" class="calibre7"><a id="_idTextAnchor345" class="calibre6 pcalibre pcalibre1"/>Using pure functions with method injection</h2>
			<p class="calibre3">In method injection, dependencies <a id="_idIndexMarker861" class="calibre6 pcalibre pcalibre1"/>are <a id="_idIndexMarker862" class="calibre6 pcalibre pcalibre1"/>passed into an object’s<a id="_idIndexMarker863" class="calibre6 pcalibre pcalibre1"/> methods as parameters. This is similar to constructor injection but allows for more fine-grained control over when and how dependencies are injected.</p>
			<p class="calibre3">The <code>fetchData()</code> method is an example of a pure function:</p>
			<pre class="source-code">
// Define a view controller that depends on a data managerclass MyViewController: UIViewController {
    func fetchData(dataManager: DataManager) {
        let data = dataManager.fetchData()
    }
}
let dataManager = ConcreteDataManager()
let viewController = MyViewController()
viewController.fetchData(dataManager: dataManager)</pre>
			<p class="calibre3">In this code example, we have the same view controller and data manager, but this time we don’t have an instance variable for the data manager. We pass the data manager as part of the <code>fetchData</code> method and make the function pure.</p>
			<p class="callout-heading">What is a pure function?</p>
			<p class="callout">A pure function is a function that does not rely on instance variables or any state outside of its scope and only operates on its input parameters. It produces the same output for the same input and has no side effects on the program or environment. A pure function can rely on method injection to use external dependencies, where dependencies are passed in as parameters rather than depending on global or instance variables.</p>
			<p class="calibre3">Method injection is excellent for testability as it increases the decoupling of the class from the dependency. It also decouples the class from the method (that’s part of the “pure” definition we discussed), but it also requires our method signatures to be more complex and manage states outside the class.</p>
			<p class="calibre3">These three<a id="_idIndexMarker864" class="calibre6 pcalibre pcalibre1"/> ways of DI <a id="_idIndexMarker865" class="calibre6 pcalibre pcalibre1"/>are <a id="_idIndexMarker866" class="calibre6 pcalibre pcalibre1"/>great to improve decoupling and testability. But we can make all these ways much more decoupled. How? Easily, using protocols.</p>
			<h2 id="_idParaDest-224" class="calibre7"><a id="_idTextAnchor346" class="calibre6 pcalibre pcalibre1"/>Decoupling our code using protocols</h2>
			<p class="calibre3">We discussed <a id="_idIndexMarker867" class="calibre6 pcalibre pcalibre1"/>protocols in <a href="B18653_05.xhtml#_idTextAnchor163" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 5</em></a> when<a id="_idIndexMarker868" class="calibre6 pcalibre pcalibre1"/> we talked about the Swift language features. Protocols play a significant role in design patterns, especially in DI.</p>
			<p class="calibre3">We can inject different objects with different behavior using protocols as long as they conform to the protocol interface.</p>
			<p class="calibre3">Here’s an example of using a protocol to inject a different object with a different implementation:</p>
			<pre class="source-code">
protocol DataManager {    func fetchData() -&gt; [String]
}
class ConcreteDataManager: DataManager {
    func fetchData() -&gt; [String] {
        return ["Item 1", "Item 2", "Item 3"]
    }
}
class OtherDataManager: DataManager {
    func fetchData() -&gt; [String] {
        return ["Item A", "Item B", "Item C"]
    }
}
class MyViewController: UIViewController {
    let dataManager: DataManager
    init(dataManager: DataManager) {
        self.dataManager = dataManager
        super.init(nibName: nil, bundle: nil)
    }
}
let concreteDataManager = ConcreteDataManager()
let viewController1 = MyViewController
    (dataManager: concreteDataManager)
let otherDataManager = OtherDataManager()
let viewController2 = MyViewController
    (dataManager: otherDataManager)</pre>
			<p class="calibre3">In this example, we <a id="_idIndexMarker869" class="calibre6 pcalibre pcalibre1"/>have two instances of <code>MyViewController</code>. We inject <code>concreteDataManager</code>, an instance of the <code>DataManager</code> protocol, into the first instance, and we inject <code>otherDataManager</code>, another instance of the <code>DataManager</code> protocol, into the second <code>MyViewController</code> instance. They both have the same interface but different implementations. In this case, they return other elements in their <code>fetchData()</code> method. This technique allows us to inject whatever implementation we want with any object. It is especially powerful with testing and helps us to use mocks in our code.</p>
			<p class="calibre3">To summarize DI, we <a id="_idIndexMarker870" class="calibre6 pcalibre pcalibre1"/>can pick any pattern we want <a id="_idIndexMarker871" class="calibre6 pcalibre pcalibre1"/>out of the three I mentioned – constructor, setter, or method – and expand its capabilities with a protocol. It all depends on the level of simplicity and coupling we want.</p>
			<h1 id="_idParaDest-225" class="calibre5"><a id="_idTextAnchor347" class="calibre6 pcalibre pcalibre1"/>Communicating using delegation</h1>
			<p class="calibre3">Delegation is a <a id="_idIndexMarker872" class="calibre6 pcalibre pcalibre1"/>simple pattern that allows objects to communicate with each other in a loosely coupled interface. Delegation is also based on a protocol that allows classes to communicate with different types of objects.</p>
			<p class="calibre3">Let’s see a small example of delegation:</p>
			<pre class="source-code">
protocol MyViewDelegate: AnyObject {    func didTapButton()
}
class MyView: UIView {
    weak var delegate: MyViewDelegate?
    private let button = UIButton(type: .system)
    override init(frame: CGRect) {
        super.init(frame: frame)
        button.addTarget(self, action: #selector
            (buttonTapped), for: .touchUpInside)
        addSubview(button)
    }
    override func layoutSubviews() {
        super.layoutSubviews()
        button.frame = bounds
    }
    @objc private func buttonTapped() {
        delegate?.didTapButton()
    }
}
class MyViewController: UIViewController, MyViewDelegate {
    private let myView = MyView()
    override func viewDidLoad() {
        super.viewDidLoad()
        myView.delegate = self
        view.addSubview(myView)
    }
    func didTapButton() {
        print("Button tapped!")
    }
}</pre>
			<p class="calibre3">The <code>MyViewController</code> class has a view named <code>MyView</code> and conforms to a protocol named <code>MyViewDelegate</code>. This protocol has a method called <code>didTapButton()</code>.</p>
			<p class="calibre3"><code>MyView</code> needs to communicate with <code>MyViewController</code> but doesn’t have a direct reference. Instead, it has a delegate property of the <code>MyViewDelegate</code> type. This delegate property creates a loosely coupled interface between the view and its view controller (its “delegate”).</p>
			<p class="calibre3">Here are two <a id="_idIndexMarker873" class="calibre6 pcalibre pcalibre1"/>takeaways from this code sample:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">We need to create a delegate property</em>: The object that communicates with the delegate needs to have a delegate property, and the delegate property is obtained from the type of the protocol we just declared. This ensures a loosely coupled relationship; every object can conform to that protocol, even mocks for testing purposes.</li>
				<li class="calibre11"><em class="italic">We must mark the delegate as weak</em>: This is a critical point. Based on our code, the view controller has a strong reference to the view, and the view has a reference to the view controller through the delegate property. This means that the delegate property must be weak, and that’s a common mistake many developers make. In fact, the weak reference to the delegate property is a common topic in interviews, and we should remember that when asked about it.</li>
			</ul>
			<p class="calibre3">Even though delegation is a widely used pattern, it has some drawbacks compared to modern patterns such as Combine, and many developers consider it a little bit outdated.</p>
			<p class="calibre3">To begin with, when using delegation to pass a message between multiple objects, the code can become cumbersome and difficult to read. This is especially true when each object must act as the delegate of the previous object, as it requires the creation of multiple protocols and delegates properties. As a result, the code can become boilerplate and challenging to follow and maintain.</p>
			<p class="calibre3">Creating protocols can decrease our coupling, but our delegate must conform to a specific interface. With reactive programming, the subscriber observes updates without being tied to a particular interface, making the communication even more loosely coupled.</p>
			<p class="calibre3">So, what can be a reason to choose delegation over Combine? With delegation, we can define a clear interface and even a complex one, which is not always true with Combine. But more than that – delegation<a id="_idIndexMarker874" class="calibre6 pcalibre pcalibre1"/> clearly separates concerns and helps us keep our code modular and easy to maintain.</p>
			<p class="calibre3">Let’s go over a common interview question about the delegate design pattern.</p>
			<h2 id="_idParaDest-226" class="calibre7"><a id="_idTextAnchor348" class="calibre6 pcalibre pcalibre1"/>“How does the delegation pattern differ from other communication patterns, such as notifications or closures, in Swift?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">A delegate<a id="_idIndexMarker875" class="calibre6 pcalibre pcalibre1"/> design pattern is just one way for an object to communicate with another object. Over the years, new ways of communication have been added – notifications, closures, and, of course, reactive approaches such as Combine and RxSwift.</p>
			<p class="calibre3">Each of these options has its pros and cons and we should match the pattern to the problem we are trying to solve. Therefore, it is important to understand the practical differences between these options.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The delegate design pattern is different from notifications, closures, and Combine in several key ways:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">One-to-one communication relationship</em>: While the notifications pattern and a Combine publisher can send a message to an unlimited number of instances, the delegate pattern typically communicates with a single object. This might initially seem like a disadvantage, but it also simplifies complex situations where we need more control over our code coupling.</li>
				<li class="calibre11"><em class="italic">Formalized protocol</em>: In a delegate pattern, there’s a clear interface to work with the delegate, thanks to the use of protocols. The protocol formalizes the communication and provides clear expectations for both the delegate and the owner. This is extremely important when the communication becomes complex – for example, several functions to implement with multiple parameters.</li>
				<li class="calibre11"><em class="italic">More complex to set up</em>: Using the delegate pattern becomes more complex to set up when we want to pass a value or an event between different layers and components of our app. But it’s not just the setup – following the data flow becomes cumbersome, as you have to jump between one protocol implementation and another. It’s another example of a flexibility versus simplicity use case.</li>
			</ul>
			<p class="calibre3">Overall, the delegate pattern is great for certain use cases and choosing the right communication option depends on the specific requirements of our problem.</p>
			<p class="calibre3">As for interview<a id="_idIndexMarker876" class="calibre6 pcalibre pcalibre1"/> questions, especially related to design patterns, we must remember that “better” relies on the context.</p>
			<p class="calibre3">I think the next topic describes that perfectly.</p>
			<h1 id="_idParaDest-227" class="calibre5"><a id="_idTextAnchor349" class="calibre6 pcalibre pcalibre1"/>Sharing a state using Singleton</h1>
			<p class="calibre3">There are <a id="_idIndexMarker877" class="calibre6 pcalibre pcalibre1"/>two <a id="_idIndexMarker878" class="calibre6 pcalibre pcalibre1"/>questions that interviewers love to ask:</p>
			<ul class="calibre10">
				<li class="calibre11">“How do we create a Singleton?”</li>
				<li class="calibre11">“Is it good to have singletons in our app?”</li>
			</ul>
			<p class="calibre3">The first question is technical, but the second one is tricky.</p>
			<p class="calibre3">Let’s start with the definition of a Singleton.</p>
			<p class="callout-heading">What is a Singleton?</p>
			<p class="callout">In the Singleton design pattern, there is only one instance of a class that can be globally accessed through a <strong class="source-inline1">static</strong> property. It is often used to manage shared resources or states in a program where multiple instances could cause issues with synchronization or consistency. To implement a Singleton, a class typically has a private constructor and a static method or property that returns the single instance of the class.</p>
			<p class="calibre3">In Swift, it is simple to create a Singleton. We use a static property for that task:</p>
			<pre class="source-code">
final class MySingleton {    static let shared = MySingleton()
    private init() {}
    func doSomething() {
        print("Doing something...")
    }
}
MySingleton.shared.doSomething()</pre>
			<p class="calibre3">Note that the Singleton is defined with one line only:</p>
			<pre class="source-code">
static let shared = Singleton()</pre>			<p class="calibre3">The critical thing is<a id="_idIndexMarker879" class="calibre6 pcalibre pcalibre1"/> to<a id="_idIndexMarker880" class="calibre6 pcalibre pcalibre1"/> always access the Singleton using the <code>shared</code> property, as seen in the preceding code example. To prevent creating another instance of the <code>MySingleton</code> class, we can mark the <code>init()</code> method as private and ensure there is only one instance.</p>
			<p class="calibre3">But that was the easy question. The real question is – should we use a Singleton in our projects? Is it considered a legit pattern or an anti-pattern?</p>
			<p class="calibre3">There are a couple of reasons why a Singleton can be an anti-pattern for many developers. Let’s discuss some of them:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Having a global state</em>: Singletons provide a global state for the app, and multiple app components can manipulate this global state. As a result, it can be hard to track down where and when these changes are made. In a way, the main problem of having a global state that can be accessed from everywhere in the code, is when the app gets more extensive.</li>
				<li class="calibre11"><em class="italic">Coupling increasing</em>: We build a modular app with great code separations. But once our different app components access a shared instance (aka Singleton), the coupling between these components increases. Tight coupling becomes more of a concern as the number of Singletons in a program increases.</li>
				<li class="calibre11"><em class="italic">Challenge multithreading</em>: Because the Singleton can be accessed from everywhere, it also means that we can modify and read values from a shared instance from different threads. This can lead to race conditions and other synchronization issues.</li>
			</ul>
			<p class="calibre3">So, what is the answer? Well, there are cases where having a Singleton is perfectly legit. For example, there<a id="_idIndexMarker881" class="calibre6 pcalibre pcalibre1"/> should be only one instance of a particular object<a id="_idIndexMarker882" class="calibre6 pcalibre pcalibre1"/> in the app – a configuration manager or database connection.</p>
			<p class="calibre3">But we should try to avoid using a Singleton whenever possible. How? Let’s answer that with an interview question.</p>
			<h2 id="_idParaDest-228" class="calibre7"><a id="_idTextAnchor350" class="calibre6 pcalibre pcalibre1"/>“How would you avoid using a Singleton in your code? Can you describe some of the alternative approaches you might consider?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">At this point, we<a id="_idIndexMarker883" class="calibre6 pcalibre pcalibre1"/> should already be familiar with the different design patterns and can come up with a suitable alternative. And that’s the goal of the question – to test the ability to take your experience and knowledge and provide a good, acceptable solution.</p>
			<p class="calibre3">If finding an alternative is possible, the general guideline regarding Singletons is to avoid them.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The most common way to avoid a Singleton is using DI to inject services used within the class or the function.</p>
			<p class="calibre3">Instead of creating a static constant (Singleton), we can approach the <code>Service</code> instance from the <code>Client</code> class:</p>
			<pre class="source-code">
class Service {    static let shared = Service()
    func doSomething() {}
}
class Client {
    func useService() {
        Service.shared.doSomething()
    }
}</pre>
			<p class="calibre3">We can create an<a id="_idIndexMarker884" class="calibre6 pcalibre pcalibre1"/> instance and inject it into the <code>Client</code> class:</p>
			<pre class="source-code">
class Service {    func doSomething() {}
}
class Client {
    let service: Service
    init(service: Service) {
        self.service = service
    }
    func useService() {
        service.doSomething()
    }
}
let service = Service()
let client = Client(service: service)</pre>
			<p class="calibre3">If a global state is not required, injecting a new instance (or passing an existing instance) instead of using a Singleton is better.</p>
			<p class="calibre3">We can improve that example by converting <code>Service</code> into a protocol:</p>
			<pre class="source-code">
protocol Service {    func doSomething()
}
class ServiceImpl: Service {
    func doSomething() {}
}
let service = ServiceImpl()
let client = Client(service: service)</pre>
			<p class="calibre3">Now that <code>Service</code> is a <a id="_idIndexMarker885" class="calibre6 pcalibre pcalibre1"/>protocol, it makes our coupling even looser. That’s a nice code modification we can make.</p>
			<h2 id="_idParaDest-229" class="calibre7"><a id="_idTextAnchor351" class="calibre6 pcalibre pcalibre1"/>“Can you describe the potential issues with using Singletons in a multithreaded environment, and how can these be addressed?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">We briefly <a id="_idIndexMarker886" class="calibre6 pcalibre pcalibre1"/>mentioned multi-threading issues when we discussed Singleton’s disadvantages earlier in this section. A Singleton is a shared resource, and as such, we must understand how it fits in a multithreaded environment.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Here are some of the potential issues we can encounter with Singleton in a multithreaded environment:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Having race conditions</em>: If multiple threads try to access and modify the same Singleton instance simultaneously, it can result in race conditions that can cause unpredictable behavior and data corruption</li>
				<li class="calibre11"><em class="italic">Encountering deadlocks</em>: If multiple threads try to access a Singleton instance in a different order, it can lead to deadlocks where one thread waits for another to release a lock on the Singleton</li>
				<li class="calibre11"><em class="italic">Having an inconsistent state</em>: If a Singleton instance is modified by one thread while another thread is reading or using it, it can result in an unstable state and unexpected behavior</li>
			</ul>
			<p class="calibre3">As developers, unpredictable behavior is one of the most challenging things to encounter, making debugging and investigation more difficult.</p>
			<p class="calibre3">The simplest <a id="_idIndexMarker887" class="calibre6 pcalibre pcalibre1"/>solution is to assume the Singleton is not a thread-safe object and can be accessed only from the same thread. Take the following example:</p>
			<pre class="source-code">
<strong class="bold1">MySingleton.shared.doSomething()</strong>DispatchQueue.global().async {
    DispatchQueue.main.async {
        <strong class="bold1">MySingleton.shared.doSomething()</strong>
    }
}</pre>
			<p class="calibre3">In this example, we assume the Singleton can only be accessed from the main thread. We’re using<a id="_idIndexMarker888" class="calibre6 pcalibre pcalibre1"/> the <strong class="bold">Grand Central Dispatch</strong> (<strong class="bold">GCD</strong>) API to move to the main thread to ensure the Singleton is always accessed from the main thread.</p>
			<p class="calibre3">Another option is to<a id="_idIndexMarker889" class="calibre6 pcalibre pcalibre1"/> make the Singleton a thread-safe object by locking access using <strong class="bold">NSLock</strong>:</p>
			<pre class="source-code">
class MySingleton {    static private var privateShared: MySingleton?
    static private let lock = NSLock()
    private init() {
        // Perform any necessary setup or initialization
    }
    static func threadSafeShared() -&gt; MySingleton {
        lock.lock()
        defer {
            lock.unlock()
        }
        if privateShared == nil {
            privateShared = MySingleton()
        }
        return privateShared!
    }
    func doSomething() {
        // Perform some action or logic
    }
}</pre>
			<p class="calibre3">In this example, we make the shared instance a private property and add a static method that ensures locking and unlocking before returning the Singleton instance. This is a common practice to lock an object and make it thread-safe.</p>
			<p class="calibre3">To summarize the topic – there is an ongoing debate and discussion in the iOS developer community. Some developers find Singleton a helpful tool that simplifies sharing states and resources, while<a id="_idIndexMarker890" class="calibre6 pcalibre pcalibre1"/> others see Singleton as an anti-pattern that has the potential to cause problems. The truth, as always, is somewhere in the middle.</p>
			<h1 id="_idParaDest-230" class="calibre5"><a id="_idTextAnchor352" class="calibre6 pcalibre pcalibre1"/>Improving performance with Concurrency</h1>
			<p class="calibre3">Concurrency is<a id="_idIndexMarker891" class="calibre6 pcalibre pcalibre1"/> a complex computer science topic, not only in iOS development. A bad design can lead to crashes, race conditions, deadlocks, and lags.</p>
			<p class="calibre3">But don’t worry – do you remember what we said about design patterns in this chapter’s introduction? They are here to solve our problems. So, let’s review some of the design patterns and best practices for concurrency to see what tools we can add to our toolbox.</p>
			<h2 id="_idParaDest-231" class="calibre7"><a id="_idTextAnchor353" class="calibre6 pcalibre pcalibre1"/>Working with GCD</h2>
			<p class="calibre3">GCD is a powerful <a id="_idIndexMarker892" class="calibre6 pcalibre pcalibre1"/>concurrency framework that enables the efficient and<a id="_idIndexMarker893" class="calibre6 pcalibre pcalibre1"/> scalable execution of tasks. GCD provides a simple way to create queues of tasks and schedule them for execution without managing threads manually. This makes it easy to write efficient and responsive code that takes full advantage of the available system resources.</p>
			<p class="calibre3">Here is an example of how to use GCD to download an image asynchronously in the background:</p>
			<pre class="source-code">
func downloadImage(url: URL, completion: @escaping    (UIImage?) -&gt; Void) {
    let queue = DispatchQueue.global(qos: .background)
    queue.async {
        if let data = try? Data(contentsOf: url),
           let image = UIImage(data: data) {completion(image)
        } else {
            completion(nil)
        }
    }
}</pre>
			<p class="calibre3">In this example, we define a function, <code>downloadImage</code>, which takes a URL and a completion handler as parameters. The function creates a global background queue using the <code>DispatchQueue.global</code> method and then calls the async method to add a task to the queue. The task downloads the image data from the URL, converts it into a an image, and then calls the completion handler with the result. Because the task is executed<a id="_idIndexMarker894" class="calibre6 pcalibre pcalibre1"/> asynchronously<a id="_idIndexMarker895" class="calibre6 pcalibre pcalibre1"/> in the background, it does not block the main thread and allows the app to remain responsive.</p>
			<h2 id="_idParaDest-232" class="calibre7"><a id="_idTextAnchor354" class="calibre6 pcalibre pcalibre1"/>Creating advanced queues with OperationQueue</h2>
			<p class="calibre3">An operation queue is<a id="_idIndexMarker896" class="calibre6 pcalibre pcalibre1"/> a higher-level<a id="_idIndexMarker897" class="calibre6 pcalibre pcalibre1"/> concurrency mechanism that manages tasks and executes them concurrently, like the GCD API we just discussed. <strong class="bold">OperationQueue</strong> provides advanced features and a simple interface for managing queues.</p>
			<p class="calibre3">The basic unit of <code>OperationQueue</code> is <code>Operation</code>, which can perform a specific task. The operation queue’s job is to take an operation and perform it simultaneously or one after the other.</p>
			<p class="calibre3">We simply subclass the <code>Operation</code> class and implement the <code>main()</code> function to create an operation.</p>
			<p class="calibre3">Here’s an example of how to download multiple images using Operation Queue:</p>
			<pre class="source-code">
class ImageDownloadOperation: Operation {    let url: URL
    var result: UIImage?
    init(url: URL) {
        self.url = url
    }
    override func main() {
        if let data = try? Data(contentsOf: url),
           let image = UIImage(data: data) {
            result = image
        }
    }
}
let urls: [URL] = // an array of image URLs
let queue = OperationQueue()
let downloadOperations = urls.map { url in
    ImageDownloadOperation(url: url)
}
queue.addOperations(downloadOperations,
    waitUntilFinished: true)
let images = downloadOperations.compactMap { $0.result }</pre>
			<p class="calibre3">In this<a id="_idIndexMarker898" class="calibre6 pcalibre pcalibre1"/> example, we<a id="_idIndexMarker899" class="calibre6 pcalibre pcalibre1"/> subclassed <code>Operation</code> by creating the <code>ImageDownloadOperation</code> class, which has a <code>url</code> property and performs a download operation in its main method.</p>
			<p class="calibre3">Right after that, we create an operation queue called <code>queue</code> and an array of download operations. We add the operations array to our created queue and collect them by calling the <code>result</code> property.</p>
			<p class="calibre3">One of Operation Queue’s best features is the ability to configure how it works. If we want the queue to perform a maximum of three operations at the same time, we can set its <code>maxConcurrentOperationCount</code> value:</p>
			<pre class="source-code">
queue.maxConcurrentOperationCount = 3</pre>			<p class="calibre3">If we set that property to <code>1</code>, our queue will perform the operations one after the other.</p>
			<p class="calibre3">Another exciting option is <em class="italic">adding dependencies between the queue operations</em> – we can define that a specific operation cannot start before another operation ends.</p>
			<p class="calibre3">Here’s an example:</p>
			<pre class="source-code">
let downloadOp1 = ImageDownloadOperation(url: url1)let downloadOp2 = ImageDownloadOperation(url: url2)
downloadOp2.addDependency(downloadOp1)</pre>
			<p class="calibre3">In this example, <code>downloadOp2</code> cannot start before <code>downloadOp1</code> ends.</p>
			<p class="calibre3">Operation<a id="_idIndexMarker900" class="calibre6 pcalibre pcalibre1"/> Queue<a id="_idIndexMarker901" class="calibre6 pcalibre pcalibre1"/> generally provides advanced capabilities and patterns to perform complex background operations with more control.</p>
			<h2 id="_idParaDest-233" class="calibre7"><a id="_idTextAnchor355" class="calibre6 pcalibre pcalibre1"/>Blocking threads with NSLock</h2>
			<p class="calibre3"><code>NSLock</code> is a <a id="_idIndexMarker902" class="calibre6 pcalibre pcalibre1"/>synchronization mechanism for managing <a id="_idIndexMarker903" class="calibre6 pcalibre pcalibre1"/>access to shared resources in a multi-threaded environment. <code>NSLock</code> provides a simple way to block threads that attempt to access a locked resource, allowing only one thread to access the resource at a time.</p>
			<p class="calibre3">Here’s an example of how to use <code>NSLock</code> to protect a shared resource:</p>
			<pre class="source-code">
class SharedResource {    private var count = 0
    private let lock = NSLock()
    func increment() {
        lock.lock()
        count += 1
        lock.unlock()
    }
    func getCount() -&gt; Int {
        lock.lock()
        let result = count
        lock.unlock()
        return result
    }
}</pre>
			<p class="calibre3">Let’s assume that <code>SharedResource</code> can be used in different threads. This can cause race conditions and deadlocks in trying to access and modify the <code>count</code> variable simultaneously.</p>
			<p class="calibre3">To handle<a id="_idIndexMarker904" class="calibre6 pcalibre pcalibre1"/> that, we “lock” the read and write access<a id="_idIndexMarker905" class="calibre6 pcalibre pcalibre1"/> with <code>NSLock</code> – we call <code>lock()</code> before the read/write operation and release it by calling <code>unlock()</code> afterward.</p>
			<h2 id="_idParaDest-234" class="calibre7"><a id="_idTextAnchor356" class="calibre6 pcalibre pcalibre1"/>Using the Combine Future publisher to implement async operations</h2>
			<p class="calibre3">We already<a id="_idIndexMarker906" class="calibre6 pcalibre pcalibre1"/> discussed <a id="_idIndexMarker907" class="calibre6 pcalibre pcalibre1"/>Combine <a id="_idIndexMarker908" class="calibre6 pcalibre pcalibre1"/>earlier in <a href="B18653_08.xhtml#_idTextAnchor249" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 8</em></a>, but now let’s discuss integrating async operations into the Combine stream.</p>
			<p class="calibre3">The <code>Future</code> publisher for any action whose value is not received immediately. For example, the <code>Future</code> type can include opening a modal, selecting an item, and dismissing it.</p>
			<p class="calibre3">But let’s see how we can use <code>Future</code> for async operations.</p>
			<p class="calibre3">The <code>Future</code> publisher has a<a id="_idIndexMarker910" class="calibre6 pcalibre pcalibre1"/> closure with a <code>promise</code> parameter with either success or failure depending on the operation result.</p>
			<p class="calibre3">Let’s see an example:</p>
			<pre class="source-code">
func loadJSONFile() -&gt; Future&lt;Data, Error&gt; {    return Future { promise in
        DispatchQueue.global().async {
            let fileURL = FileManager.default.urls(for:
                .libraryDirectory, in: .userDomainMask)[0].
                    appendingPathComponent("articles.json")
            do {
                let data = try Data(contentsOf: fileURL)
                promise(.success(data))
            } catch {
                promise(.failure(error))
            }
        }
    }
}</pre>
			<p class="calibre3">In this example, the <code>loadJSONFile</code> function returns a <code>Future</code> publisher. Inside, it creates<a id="_idIndexMarker911" class="calibre6 pcalibre pcalibre1"/> a<a id="_idIndexMarker912" class="calibre6 pcalibre pcalibre1"/> background <a id="_idIndexMarker913" class="calibre6 pcalibre pcalibre1"/>queue and loads a big JSON file. It calls the promise type with success and data if everything works fine. If not, it sends a failure and an error.</p>
			<p class="calibre3">Now let’s see how to use that function in a Combine stream:</p>
			<pre class="source-code">
let newArticles = loadJSONFile()    .decode(type: [Article].self, decoder: JSONDecoder())
    .map { articles -&gt; [Article] in
        let lastUpdate = UserDefaults.standard.object(
         forKey: "lastUpdate") as? Date ?? Date.distantPast
        return articles.filter { $0.publishedAt &gt; lastUpdate }
    }
    .eraseToAnyPublisher()</pre>
			<p class="calibre3">Now, we can integrate the JSON loading operation in one line, decode its data, and map and filter it, as part of a Combine stream.</p>
			<p class="calibre3">We can see how the <code>Future</code> publisher makes it very easy to integrate async operations in the <a id="_idIndexMarker914" class="calibre6 pcalibre pcalibre1"/>Combine <a id="_idIndexMarker915" class="calibre6 pcalibre pcalibre1"/>stream. We<a id="_idIndexMarker916" class="calibre6 pcalibre pcalibre1"/> can also include more complex async operations in Combine by combining <code>OperationQueue</code> and <code>Future</code>.</p>
			<h2 id="_idParaDest-235" class="calibre7"><a id="_idTextAnchor357" class="calibre6 pcalibre pcalibre1"/>Going over concurrency development best practices</h2>
			<p class="calibre3">Regardless of the <a id="_idIndexMarker917" class="calibre6 pcalibre pcalibre1"/>different techniques we just learned, there are some best practices we should follow to keep our code safe from race conditions and deadlocks.</p>
			<p class="calibre3">Some of them are derived from what we’ve learned till now. Also, these best practices are excellent for interview discussions about concurrency:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Avoid blocking the main thread</em>: The main thread handles UI updates, so blocking it can cause the app to become unresponsive. To avoid blocking the main thread, use background threads or operation queues to perform long-running or CPU-intensive tasks.</li>
				<li class="calibre11"><em class="italic">Use structs for safety</em>: Structs are value types, which means they’re thread-safe by default. If we need to pass data between threads or queues, using structs can help prevent race conditions and other concurrency issues.</li>
				<li class="calibre11"><em class="italic">Avoid shared state</em>: Shared state between threads or queues can lead to race conditions and other concurrency issues. Instead, try to keep the state local to each thread or queue and use message passing or other communication mechanisms to share data between them.</li>
				<li class="calibre11"><em class="italic">Use Combine</em>: Combine is a robust framework for reactive programming in iOS and can help simplify concurrency by allowing you to define data streams and transformations that operate on those streams. By using Combine, you can avoid complex thread management and synchronization issues.</li>
				<li class="calibre11"><em class="italic">Always return a closure in the same thread</em>: When performing asynchronous operations, it’s essential to ensure that any closures or callbacks are executed in the same thread or queue where they were initially created. This helps avoid race conditions and<a id="_idIndexMarker918" class="calibre6 pcalibre pcalibre1"/> other concurrency issues when executing code across multiple threads.</li>
			</ul>
			<h1 id="_idParaDest-236" class="calibre5"><a id="_idTextAnchor358" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">This chapter was long, and this topic could be a book of its own. In fact, many books focus solely on design patterns, and it’s obvious why – design patterns are our toolbox for everything we do in iOS development.</p>
			<p class="calibre3">This chapter taught us about MVC/MVVM, DI, delegation, singletons, and concurrency patterns<a id="_idTextAnchor359" class="calibre6 pcalibre pcalibre1"/> and tools. By now, we should have a great understanding of the primary design patterns in iOS.</p>
			<p class="calibre3">This knowledge of design patterns is a great foundation to prepare us for the next chapter, which will focus on app architecture and development.</p>
		</div>
	</body></html>