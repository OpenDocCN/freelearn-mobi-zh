- en: Chapter 6. Using Protocols and Protocol Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While watching the presentations from WWDC 2015 about protocol extensions and
    protocol-oriented programming, I will admit that I was very skeptical. I have
    worked with object-oriented programming for so long that I was unsure if this
    new programming paradigm would solve all of the problems that Apple was claiming
    it would. Since I am not one to let my skepticism get in the way of trying something
    new, I set up a new project that mirrored the one I was currently working on,
    but wrote the code using Apple's recommendations for protocol-oriented programming
    and used protocol extensions extensively in the code. I can honestly say that
    I was amazed with how much cleaner the new project was compared to the original
    one. I believe that protocol extensions is going to be one of those defining features
    that set one programming language apart from the rest. I also believe that many
    major languages will soon have similar features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How protocols are used as a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement polymorphism in Swift using protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use protocol extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why we would want to use protocol extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol extensions are the backbone for Apple's new protocol-oriented programming
    paradigm and are arguably one of the most important additions to the Swift programming
    language. With protocol extensions, we are able to provide method and property
    implementations to any type that conforms to a protocol. To really understand
    how useful protocols and protocol extensions are, let's get a better understanding
    of protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While classes, structs, and enums can all conform to protocols in Swift, for
    this chapter, we will be focusing on classes and structs. Enums are used when
    we need to represent a finite number of cases and while there are valid use cases
    where we would have an enum conform to a protocol, they are very rare in my experience.
    Just remember that anywhere that we refer to a class or struct, we can also use
    an enum.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin exploring protocols by seeing how they are full-fledged types in
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols as types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though no functionality is implemented in a protocol, they are still considered
    a full-fledged type in the Swift programming language and can be used like any
    other type. What this means is we can use protocols as a parameter type or a return
    type in a function. We can also use them as the type for variables, constants,
    and collections. Let''s take a look at some examples. For these few examples,
    we will use the `PersonProtocol` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this first example, we will see how we would use protocols as a parameter
    type or return type in functions, methods, or initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `updatePerson()` function accepts one parameter of the
    `PersonProtocol` protocol type and then returns a value of the `PersonProtocol`
    protocol type. Now let''s see how we can use protocols as a type for constants,
    variables, or properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create a variable of the `PersonProtocol` protocol type
    that is named `myPerson`. We can also use protocols as the item type to store
    in collection such as arrays, dictionaries, or sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this final example, we create an array of `PersonProtocol` protocol types.
    As we can see from these three examples, even though the `PersonProtocol` protocol
    does not implement any functionality, we can still use protocols when we need
    to specify a type. We cannot, however, create an instance of a protocol. This
    is because no functionality is implemented in a protocol. As an example, if we
    tried to create an instance of the `PersonProtocol` protocol, we would be receiving
    the `error: protocol type ''PersonProtocol'' cannot be instantiated error`, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the instance of any class or struct that conforms to our protocol
    anywhere that the protocol type is required. As an example, if we defined a variable
    to be of the `PersonProtocol` protocol type, we could then populate that variable
    with any class or struct that conforms to the `PersonProtocol` protocol. For this
    example, let''s assume that we have two types named `SwiftProgrammer` and `FootballPlayer`,
    which conform to the `PersonProtocol` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start off by creating the `myPerson` variable of the `PersonProtocol`
    protocol type. We then set the variable with an instance of the `SwiftProgrammer`
    type and print out the first and last names. Next, we set the `myPerson` variable
    to an instance of the `FootballPlayer` type and print out the first and last names
    again. One thing to note is that Swift does not care if the instance is a class
    or struct. It only matters that the type conforms to the `PersonProtocol` protocol
    type. Therefore, if our `SwiftProgrammer` type was a struct and the `FootballPlayer`
    type was a class, our previous example would be perfectly valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, we can use our `PersonProtocol` protocol as the type for
    an array. This means that we can populate the array with instances of any type
    that conforms to the `PersonProtocol` protocol. Once again, it does not matter
    if the type is a class or a struct as long as it conforms to the `PersonProtocol`
    protocol. Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create an instance of the `SwiftProgrammer` type and an
    instance of the `FootballPlayer` type. We then add both instances to the `people`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism with protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we were seeing in the previous examples is a form of polymorphism. The
    word polymorphism comes from the Greek roots *Poly*, meaning many and *morphe*,
    meaning form. In programming languages, polymorphism is a single interface to
    multiple types (many forms). In the previous example, the single interface was
    the `PersonProtocol` protocol and the multiple types were any type that conforms
    to that protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism gives us the ability to interact with multiple types in a uniform
    manner. To illustrate this, we can extend our previous example where we created
    an array of the `PersonProtocol` types and loop through the array. We can then
    access each item in the array using the properties and methods define in the `PersonProtocol`
    protocol, regardless of the actual type. Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran this example, the output would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have mentioned a few times in this chapter that when we define the type of
    a variable, constant, collection type, and so on to be a protocol type, we can
    then use the instance of any type that conforms to that protocol. This is a very
    important concept to understand and it is what makes protocols and protocol extensions
    so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: When we use a protocol to access instances, as shown in the previous example,
    we are limited to using only properties and methods that are defined in the protocol.
    If we want to use properties or methods that are specific to the individual types,
    we would need to cast the instance to that type.
  prefs: []
  type: TYPE_NORMAL
- en: Type casting with protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type casting is a way to check the type of the instance and/or to treat the
    instance as a specified type. In Swift, we use the `is` keyword to check if an
    instance is a specific type and the `as` keyword to treat the instance as a specific
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s see how we would check the instance type using the `is`
    keyword. The following example shows how would we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we use the `if` conditional statement to check whether each
    element in the people array is an instance of the `SwiftProgrammer` type and if
    so, we print that the person is a Swift programmer to the console. While this
    is a good method to check whether we have an instance of a specific class or struct,
    it is not very efficient if we wanted to check for multiple types. It is a lot
    more efficient to use the `switch` statement, as shown in the next example, if
    we want to check for multiple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we showed how to use the `switch` statement to check
    the instance type for each element of the array. To do this check, we use the
    `is` keyword in each of the `case` statements in an attempt to match the instance
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Control Flow and Functions"), *Control
    Flow and Functions*, we saw how to filter conditional statements with the `where`
    statement. We can also use the `where` statement with the `is` keyword to filter
    the array, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at how we can cast an instance of a class or struct to a specific
    type. To do this, we can use the `as` keyword. Since the cast can fail if the
    instance is not of the specified type, the `as` keyword comes in two forms: `as?`
    and `as!`. With the `as?` form, if the casting fails, it returns a nil, and with
    the `as!` form, if the casting fails, we get a runtime error; therefore, it is
    recommended to use the `as?` form unless we are absolutely sure of the instance
    type or we perform a check of the instance type prior to doing the cast.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would use the `as?` keyword to cast an instance of a
    class or struct to a specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `as?` keyword returns an optional, we can use optional binding to
    perform the cast, as shown in this example. If we are sure of the instance type,
    we can use the `as!` keyword. The following example shows how to use the `as!`
    keyword when we filter the results of the array to only return instances of the
    `SwiftProgrammer` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered the basics of protocols, that is, how polymorphism
    works and type casting, let's dive into one of the most exciting new features
    of Swift protocol extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protocol extensions allow us to extend a protocol to provide method and property
    implementations to conforming types. They also allow us to provide common implementations
    to all the confirming types eliminating the need to provide an implementation
    in each individual type or the need to create a class hierarchy. While protocol
    extensions may not seem too exciting, once you see how powerful they really are,
    they will transform the way you think about and write code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by looking at how we would use protocol extension with a very
    simplistic example. We will start off by defining a protocol called `DogProtocol`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With this protocol, we are saying that any type that conforms to the `DogProtocol`
    protocol, must have the two properties of the String type, namely, `name` and
    `color`. Now let''s define the three types that conform to this protocol. We will
    name these types `JackRussel`, `WhiteLab`, and `Mutt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We purposely created the `JackRussel` and `Mutt` types as structs and the `WhiteLab`
    type as a class to show the differences between how the two types are set up and
    to illustrate how they are treated in the same way when it comes to protocols
    and protocol extensions. The biggest difference that we can see in this example
    is the struct types provide a default initiator, but in the class, we must provide
    the initiator to populate the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s say that we want to provide a method named `speak` to each type
    that conforms to the `DogProtocol` protocol. Prior to protocol extensions, we
    would start off by adding the method definition to the protocol, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the method is defined in the protocol, we would then need to provide an
    implementation of the method in every type that conforms to the protocol. Depending
    on the number of types that conformed to this protocol, this could take a bit
    of time to implement. The following code sample shows how we might implement this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: While this method works, it is not very efficient because anytime we update
    the protocol, we would need to update all the types that conform to it and we
    may be duplicating a lot of code, as shown in this example. Another concern is,
    if we need to change the default behavior of the `speak()` method, we would have
    to go in each implementation and change the `speak()` method. This is where protocol
    extensions come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'With protocol extensions, we could take the `speak()` method definition out
    of the protocol itself and define it with the default behavior, in protocol extension.
    The following code shows how we would define the protocol and the protocol extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by defining `DogProtocol` with the original two properties. We then
    create a protocol extension that extends `DogProtocol` and contains the default
    implementation of the `speak()` method. With this code, there is no need to provide
    an implementation of the `speak()` method in each of the types that conform to
    `DogProtocol` because they automatically receive the implementation as part of
    the protocol. Let''s see how this works by setting our three types that conform
    to `DogProtocol` back to their original implementations and they should receive
    the `speak()` method from the protocol extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use each of the types as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in this example, by adding the `speak()` method to the `DogProtocol`
    protocol extension, we are automatically adding that method to all the types that
    conform to `DogProtocol`. The `speak()` method in the `DogProtocol` protocol extension
    can be considered a default implementation of the `speak()` method because we
    are able to override it in the type implementations. As an example, we could override
    the `speak()` method in the `Mutt` struct, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we call the `speak()` method for an instance of the `Mutt` type, it will
    return the string, `"I am hungry"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how we would use protocols and protocol extensions, let's
    look at a more real-world example. In numerous apps across multiple platforms
    (iOS, Android, and Windows), I have had the requirement to validate user input
    as it is entered. This validation can be done very easily with regular expressions;
    however, we do not want various regular expressions littered throughout our code.
    It is very easy to solve this problem by creating different classes or structs
    that contains the validation code; however, we would have to organize these classes
    to make them easy to use and maintain. Prior to protocol extensions in Swift,
    I would use protocols to define the validation requirements and then create a
    struct that would conform to the protocol for each validation that I needed. Let's
    take a look at this preprotocol extension method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A regular expression is a sequence of characters that define a particular pattern.
    This pattern can then be used to search a string to see whether the string matches
    the pattern or contains a match of the pattern. Most major programming languages
    contain a regular expression parser, and if you are not familiar with regular
    expressions, it may be worthwhile to learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `TextValidationProtocol` protocol that defines
    the requirements for any type that we want to use for text validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this protocol, we define three properties and two methods that any type
    that conforms to `TextValidationProtocol` must implement. The three properties
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`regExMatchingString`: This is a regular expression string used to verify that
    the input string contains only valid characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regExFindMatchString`: This is a regular expression string used to retrieve
    a new string from the input string that contains only valid characters. This regular
    expression is generally used when we need to validate the input in real time,
    as the user enters information, because it will find the longest matching prefix
    of the input string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validationMessage`: This is the error message to display if the input string
    contains non-valid characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two methods for this protocol are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validateString`: This method will return `true` if the input string contains
    only valid characters. The `regExMatchingString` property will be used in this
    method to perform the match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMatchingString`: This method will return a new string that contains only
    valid characters. This method is generally used when we need to validate the input
    real time as the user enters information because it will find the longest matching
    prefix of the input string. We will use the `regExFindMatchString` property in
    this method to retrieve the new string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s see how we would create a struct that conforms to this protocol.
    The following struct would be used to verify that the input string contains only
    alpha characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, the `regExFindMatchString` and `validationMessage` properties
    are stored properties, and the `regExMatchingString` property is a computed property.
    We also implement the `validateString()` and `getMatchingString()` methods within
    the struct.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we would have several different types that conform to `TextValidationProtocol`
    where each one would validate a different type of input. As we can see from the
    `AlphaValidation1` struct, there is a bit of code involved with each validation
    type. A lot of the code would also be duplicated in each type. The code for both
    methods (`validateString()` and `getMatchingString()`) and the `regExMatchingString`
    property would be duplicated in every validation class. This is not ideal, but
    if we wanted to avoid creating a class hierarchy with a super class that contains
    the duplicate code (I personally prefer using value types over classes), we would
    have no other choice. Now let's see how we would implement this using protocol
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With protocol extensions, we need to think about the code a little differently.
    The big difference is, we neither need, nor want to define everything in the protocol.
    With standard protocols or when we use class hierarchy, all the methods and properties
    that you would want to access using the generic superclass or protocol would have
    to be defined within the superclass or protocol. With protocol extensions, it
    is preferable for us not to define a property or method in the protocol if we
    are going to be defining it within the protocol extension. Therefore, when we
    rewrite our text validation types with protocol extensions, `TextValidationProtocol`
    would be greatly simplified to look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In original `TextValidationProtocol`, we defined three properties and two methods.
    As we can see in this new protocol, we are only defining two properties. Now that
    we have our `TextValidationProtocol` defined, let''s create the protocol extension
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `TextValidationProtocol` protocol extension, we define the two methods
    and the third property that were defined in original `TextValidationProtocol`,
    but were not defined in the new one. Now that we have created our protocol and
    protocol extension, we are able to define our text validation types. In the following
    code, we define three structs that we will use to validate text when a user types
    it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In each one of the text validation structs, we create a static constant and
    a private initiator so that we can use the struct as a singleton. For more information
    on the singleton pattern, please see the *The Singleton design pattern* section
    of [Chapter 17](ch17.html "Chapter 17. Adopting Design Patterns in Swift"), *Adopting
    Design Patterns in Swift*.
  prefs: []
  type: TYPE_NORMAL
- en: After we define the singleton pattern, all we do in each type is set the values
    for the `regExFindMatchString` and `validationMessage` properties. Now, we have
    not duplicated the code virtually because even if we could, we would not want
    to define the singleton code in the protocol extension because we would not want
    to force that pattern on all the conforming types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the text validation classes, we would want to create a dictionary object
    that would map the `UITextField` objects to the validation class to use it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then populate the `validators` dictionary as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now set the `EditingChanged` event of the text fields to a single method
    named `keyPressed()`. To set the edition changed event for each field, we would
    add the following code to the `viewDidLoad()` method of our view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the `keyPressed()` method that each text field calls when
    a user types a character into the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we use the `if let validator = validators[textField]` statement
    to retrieve the validator for the particular text field and then we use the `where
    !validator.validateString(textField.text!)` statement to validate the string that
    the user has entered. If the string fails validation, we use the `getMatchingString()`
    method to update the text in the text field by removing all the characters from
    the input string, starting with the first invalid character and then displaying
    the error message from the text validation class. If the string passes validation,
    the text in the text field is left unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: In the downloadable code for this book, you will find a sample project that
    demonstrates how to use the text validation types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that protocols are treated as full-fledged types by
    Swift. We also saw how polymorphism can be implemented in Swift with protocols.
    We concluded this chapter with an in-depth look at protocol extensions and saw
    how we would use them in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols and protocol extensions are the backbone of Apple's new protocol-oriented
    programming paradigm. This new model for programming has the potential to change
    the way we write and think about code. While we did not specifically cover protocol-oriented
    programming in this chapter, understanding the topics in this chapter gives us
    the solid understanding of protocols and protocol extensions needed to learn about
    this new programming model.
  prefs: []
  type: TYPE_NORMAL
