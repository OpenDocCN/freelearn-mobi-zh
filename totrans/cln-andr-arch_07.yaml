- en: '*Chapter 5*: Building the Domain of an Android Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will analyze what the architecture of an Android application
    typically looks like and its three main layers (**presentation**, **domain**,
    and **data**). Then, we will learn how we can translate it into clean architecture
    and focus on the domain layer, which sits at the center of the architecture. Next,
    we will look at the role it plays in the architecture of an application and what
    its entities and use cases are. Finally, we will look at an exercise, in which
    we are going to see how we can set up an Android Studio project with multiple
    modules and use them to structure the domain layer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the app's architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the domain layer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with the domain layer of an
    application, domain entities, and use cases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the hardware and software requirements:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio – Arctic Fox | 2020.3.1 Patch 3
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3826FH6](https://bit.ly/3826FH6)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the app's architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the most common architecture that can be applied
    to an Android application and how it can be combined with **clean architecture**
    principles, and see how we should ideally structure our code base.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'In the exercises from the previous chapters, we saw how, for an application
    that requires the integration of multiple data sources for networking and persistence,
    we had to put a lot of logic inside the `ViewModel` class. In those examples,
    `ViewModel` had multiple responsibilities, including fetching the data from the
    internet, persisting it locally, and holding the required information in the user
    interface. On top of these extra responsibilities, `ViewModel` also had many dependencies
    on the different data sources; this means that a change in the networking or persistence
    libraries would require a change in `ViewModel`. To solve this problem, our code
    would need to be split into separate layers with different responsibilities. Typically,
    the layers would look like the following figure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – An app architecture diagram'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B18320.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – An app architecture diagram
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.1*, we can see that there are three layers with different responsibilities:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModels`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain layer**: This layer is responsible for fetching data from the data
    layer and performing business logic that can be reused across an app.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data layer**: This layer is responsible for handling the business logic of
    an application that deals with the managing of data.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can apply the *clean architecture* principles on top of the layered architecture
    by placing the domain layer at the center, as shown in *Figure 5.2*, and making
    it the place to store our *entities* and *use cases*. At the outer layers are
    the presentation and data layers, which are represented by the `ViewModels` and
    `Repositories`) and the **framework layer** (represented by the user interface
    and persistence and networking frameworks):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在分层架构之上应用*清洁架构*原则，通过将领域层置于中心，如图*5.2*所示，并使其成为存储我们的*实体*和*用例*的地方。在外层是表示层和数据层，它们由`ViewModels`和`Repositories`表示，以及**框架层**（由用户界面、持久化和网络框架表示）：
- en: '![Figure 5.2 – An app layer dependency diagram'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 应用层依赖关系图'
- en: '](img/Figure_5.02_B18320.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.02_B18320.jpg)'
- en: Figure 5.2 – An app layer dependency diagram
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 应用层依赖关系图
- en: In the preceding figure, we can see that the dependencies between the domain
    layer and the data layer are inverted. The domain layer will still draw data from
    the data layer, but because it has inverted dependencies, it will be less impacted
    by any changes to that layer, just as if any changes occur to the presentation
    layer, they will not impact the domain layer. If the app suffers from any changes
    to the use cases, then it will drive the changes in both the presentation and
    data layer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到领域层和数据层之间的依赖关系是反转的。领域层仍然会从数据层获取数据，但由于它具有反转的依赖关系，它将受到该层任何变化的较小影响，就像任何变化发生在表示层，它们不会影响领域层一样。如果应用程序受到用例变化的任何影响，那么它将驱动表示层和数据层的变更。
- en: 'To separate the layers, we can use **Android modules**. This will help us impose
    further rigor on the project by avoiding unwanted dependencies between the layers.
    This also helps improve build times in large applications because of Gradle build
    caching, which will only rebuild modules that had code changes. This will look
    something like the following figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离层，我们可以使用**Android模块**。这将帮助我们通过避免层之间的不必要依赖来对项目施加进一步的严谨性。这也帮助提高了大型应用程序的构建时间，因为Gradle构建缓存只会重新构建有代码更改的模块。这看起来可能像以下图示：
- en: '![Figure 5.3 – An app module diagram'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 应用模块图'
- en: '](img/Figure_5.03_B18320.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B18320.jpg)'
- en: Figure 5.3 – An app module diagram
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 应用模块图
- en: We can see that there isn't a limited number of modules we need for each layer
    or that we should have corresponding modules between the three layers. The expansion
    of each layer can be driven by different factors such as the data sources, the
    uses of the app, the technologies, and protocols used in those data sources (using
    REST APIs for certain data and Bluetooth or Near-field communication for other
    data types). The usage of the use cases might be another factor (such as having
    a certain set of use cases for use with multiple applications). We might want
    to expand the presentation layer because of how certain screens are grouped to
    form certain isolated features and flows inside an application (such as a settings
    section of the application, or a login/sign-up flow). One interesting aspect to
    note is the `:app` module, which has the role of combining all of the dependencies
    and assembling them together. Here, we will gather all the required dependencies
    and initialize them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对于每一层，我们并不需要有限数量的模块，或者我们不需要在三层之间有对应的模块。每一层的扩展可以由不同的因素驱动，例如数据源、应用程序的使用、在数据源中使用的技术和协议（对于某些数据使用REST
    API，对于其他数据类型使用蓝牙或近场通信）。用例的使用可能也是一个因素（例如，为多个应用程序使用的一组特定用例）。我们可能想要扩展表示层，因为某些屏幕是如何分组以形成应用程序内部某些隔离的功能和流程的（例如，应用程序的设置部分或登录/注册流程）。一个值得注意的有趣方面是`:app`模块，它具有组合所有依赖项并将它们组装在一起的作用。在这里，我们将收集所有必需的依赖项并初始化它们。
- en: An important thing to note here is that the modules aren't equivalent to the
    layers themselves; data modules can have dependencies to lower-level data modules.
    In fact, this situation will occur in scenarios when a module from a layer will
    need to have a dependency on another module from the same layer. If we were to
    create a dependency between the two, we might end up with a cyclical dependency,
    which is not wanted. In that situation, we will need to create a common module
    between the two that will hold the required dependencies. For example, if we want
    to navigate from a screen in `:presentation1` to a screen in `:presentation2`
    or any of the other ones, we will need to create a new module on which all of
    the presentation modules will depend and which will store the data or logic required
    to handle the navigation. We will look at this issue in more detail when we discuss
    the presentation layer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事项是，模块本身并不等同于层；数据模块可以依赖于较低级别的数据模块。实际上，这种情况会在一个层的模块需要依赖于同一层的另一个模块时发生。如果我们在这两个模块之间创建依赖关系，我们可能会得到一个循环依赖关系，这是我们不希望的。在这种情况下，我们需要在这两个模块之间创建一个公共模块，该模块将包含所需的依赖项。例如，如果我们想从`:presentation1`中的一个屏幕导航到`:presentation2`中的屏幕或任何其他屏幕，我们需要创建一个新的模块，所有展示模块都将依赖于它，并且将存储处理导航所需的数据或逻辑。当讨论展示层时，我们将更详细地探讨这个问题。
- en: 'To create a new Android Studio module, you need to right-click the project
    in Android Studio, select **New**, and then **Module**, as shown in the following
    figure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Android Studio 中创建一个新的模块，您需要在 Android Studio 中右键单击项目，选择**新建**，然后选择**模块**，如图所示：
- en: '![Figure 5.4 – Creating a new Android Studio module'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 创建新的 Android Studio 模块'
- en: '](img/Figure_5.04_B18320.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B18320.jpg)'
- en: Figure 5.4 – Creating a new Android Studio module
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 创建新的 Android Studio 模块
- en: 'You will then be prompted to select the type of module, and depending on the
    functionality, you can select `build.gradle` file. The plugin section in the file
    will indicate that an Android library was created:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将被提示选择模块类型，根据功能，您可以选择`build.gradle`文件。文件中的插件部分将指示已创建 Android 库：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we want to add a dependency to the newly created module, we can use the
    following in the `app` module:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向新创建的模块添加依赖项，我们可以在`app`模块中使用以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The syntax to add a dependency to a module is similar to the syntax to add an
    external dependency and it's through the Gradle `implementation` method. The rest
    indicates that the `app` module will depend on another module inside the same
    project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向模块添加依赖项的语法类似于添加外部依赖项的语法，并且是通过 Gradle 的`implementation`方法实现的。其余部分表示`app`模块将依赖于同一项目内的另一个模块。
- en: In this section, we have analyzed the layers of Android app architecture and
    how we can apply clean architecture principles to these layers. In the following
    section, we will look at how we can build a domain layer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了 Android 应用架构的层级以及如何将这些层应用于清洁架构原则。在下一节中，我们将探讨如何构建领域层。
- en: Creating the domain layer
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建领域层
- en: In this section, we will discuss how to build the domain layer and what goes
    into it through certain examples. Finally, we will look at an exercise in which
    a domain layer is created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何构建领域层以及它包含的内容，并通过某些示例进行说明。最后，我们将查看一个创建领域层的练习。
- en: Because the domain layer sits at the center of the application, it will need
    to have a minimal number of dependencies. This means that the Gradle modules that
    form the domain layer will need to be the most stable modules in the project.
    This is to avoid causing other modules to change because of a change that occurred
    in a dependency that the domain modules use. The domain should be responsible
    for defining the entities and use cases for the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为领域层位于应用程序的中心，它将需要最少的依赖项。这意味着构成领域层的 Gradle 模块将是项目中最稳定的模块。这是为了避免因为领域模块使用的依赖项中发生的变化而导致其他模块发生变化。领域应该负责定义应用程序的实体和用例。
- en: 'Entities are represented by objects that hold data and are mainly immutable.
    Let''s assume we want to represent a user as an entity. We might end up with something
    like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实体由包含数据的主要不可变对象表示。假设我们想将用户表示为一个实体。我们可能会得到以下内容：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we use a simple `data class`, and we declare all our fields immutable
    with the `val` keyword. We also have a business logic function for this object,
    which will return the full name of the user.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了一个简单的`data class`，并使用`val`关键字声明所有字段为不可变。我们还有一个针对此对象的业务逻辑函数，它将返回用户的完整名称。
- en: 'Next, we need to define our use cases. Because the use cases will need to get
    data from the data layer, we will first need to create an abstraction for our
    repository, and we will end up with the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们的用例。因为用例将需要从数据层获取数据，我们首先需要为我们的存储库创建一个抽象，最终我们会得到以下内容：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we just have a simple method that will return a user based on `id`. We
    can now create a use case for retrieving the user:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只有一个简单的方法，它将根据`id`返回一个用户。现在，我们可以创建一个用于检索用户的用例：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we define a use case to retrieve the user, which will
    have a dependency on the `UserRepository`, which will be used to retrieve the
    user information. If we look at the preceding example, we can see a bit of redundancy
    because the use case doesn't have any extra logic and just returns the value of
    the repository. The benefit of use cases comes when we want to combine multiple
    results of multiple repositories.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个用于检索用户的用例，它将依赖于`UserRepository`来检索用户信息。如果我们查看前面的例子，我们可以看到一些冗余，因为用例没有任何额外的逻辑，只是返回存储库的值。用例的好处在于，当我们想要组合多个存储库的多个结果时。
- en: 'Let''s assume that we want to associate the user with a particular location,
    defined as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将用户与特定的位置关联起来，如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we just keep the latitude and longitude associated with a particular
    user. Now, let''s assume that we would have a repository for the different locations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只保留与特定用户关联的纬度和经度。现在，假设我们会有一个用于不同位置的存储库：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we again have an abstraction of a repository with a method to get a specific
    location based on `userId`. If we want to get a user and an associated location,
    we will need to create a specific use case for this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们再次有一个存储库的抽象，它有一个根据`userId`获取特定位置的方法。如果我们想获取一个用户及其关联的位置，我们需要为这个创建一个特定的用例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we create a new entity called `UserWithLocation`,
    which will store `User` and `Location`. `UserWithLocation` will then be used as
    a result for the `getUser` method in `GetUserWithLocationUseCase`. This will depend
    on both `UserRepository` and `LocationRepository` to fetch the relevant data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个新的实体`UserWithLocation`，它将存储`User`和`Location`。`UserWithLocation`将随后用作`GetUserWithLocationUseCase`中`getUser`方法的返回结果。这将依赖于`UserRepository`和`LocationRepository`来获取相关数据。
- en: 'We can further improve the use cases by handling the threading as well. Because
    use cases will mainly deal with retrieving and managing data, which needs to be
    asynchronous, we should handle this on a separate thread. We can use **Kotlin
    flows** to manage this, and we might end up with something like this for the repositories:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过处理线程来进一步改进用例。因为用例将主要处理检索和管理数据，这需要异步处理，所以我们应该在单独的线程上处理。我们可以使用**Kotlin
    flows**来管理这个，我们最终可能会得到如下所示的存储库：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we change the return types of the methods to a Kotlin flow, which might
    emit a stream of data or a single item. Now, we can combine the different flows
    in the stream in the use case:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将方法的返回类型更改为Kotlin flow，它可能会发出数据流或单个项目。现在，我们可以在用例中组合流中的不同流：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we combine the `User` and `Location` flows into a `UserWithLocation` flow,
    and we will execute the data fetching on the `IO` dispatcher.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`User`和`Location`流组合成一个`UserWithLocation`流，并将数据检索操作在`IO`调度器上执行。
- en: 'Often, when dealing with data loading and management, especially from the internet,
    we can encounter different errors, which we will have to factor into our use cases.
    To solve this, we can define error entities. There are many possibilities to define
    them, including extending the `Throwable` class, defining a particular data class,
    a combination of the two, or combining them with sealed classes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 经常在处理数据加载和管理时，尤其是从互联网上，我们可能会遇到不同的错误，这些错误我们必须考虑在我们的用例中。为了解决这个问题，我们可以定义错误实体。定义它们有很多可能性，包括扩展`Throwable`类、定义特定的数据类、两者的组合，或者将它们与密封类结合：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have created a sealed class that will have as subclasses a dedicated
    error for each entity, plus an unknown error that will deal with errors we haven''t
    accounted for, and a companion method that will check a `Throwable` object and
    return `UnknownException` for any `Throwable` that isn''t `UseCaseException`.
    We will need to make sure that the error is propagated through the flow stream,
    but first, we can combine the entity for success with the entity for error to
    ensure that the consumer of the use case will not need to check the type of `Throwable`
    again and make a cast. We can do this with the following approach:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个密封类，它将作为子类为每个实体提供一个专用错误，以及一个未知错误来处理我们没有考虑到的错误，还有一个伴随方法，该方法将检查一个 `Throwable`
    对象，并返回 `UnknownException` 以处理任何不是 `UseCaseException` 的 `Throwable`。我们需要确保错误通过流程流传播，但首先，我们可以将成功实体与错误实体组合起来，以确保用例的消费者不需要再次检查
    `Throwable` 的类型并进行类型转换。我们可以使用以下方法来实现：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we defined a `Result` sealed class, which will have two subclasses for
    success and error. The `Success` class will hold the relevant data for the use
    case, and the `Error` class will contain the exceptions defined before. The `Error`
    class can be further expanded if needed to hold data as well as the error if we
    want to display the cached or persisted data as a placeholder. We can now modify
    the use case to incorporate the `Result` class and the error state:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个 `Result` 密封类，它将有两个子类用于成功和错误。`Success` 类将包含用例的相关数据，而 `Error` 类将包含之前定义的异常。如果需要，`Error`
    类可以进一步扩展以包含数据以及错误，如果我们想显示缓存的或持久化的数据作为占位符。现在我们可以修改用例以包含 `Result` 类和错误状态：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we return `Result.Success`, which will hold the `UserWithLocation` object
    if no errors occur, and add use the `catch` operator to emit `Result.Error` with
    `UseCaseException` that occurred while fetching the data. Because these operations
    will repeat for multiple use cases, we can use abstraction to create a template
    for how each use case behaves and let the implementations deal with only processing
    the necessary data. An example might look like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回 `Result.Success`，如果没有发生错误，它将包含 `UserWithLocation` 对象，并使用 `catch` 操作符来发出带有在获取数据时发生的
    `UseCaseException` 的 `Result.Error`。因为这些操作将在多个用例中重复，我们可以使用抽象来创建一个模板，说明每个用例的行为，并让实现只处理必要的数据。一个例子可能如下所示：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we have defined an abstract class that will contain
    the `execute` method, which will invoke the abstract `executeData` method and
    then map the result of that method into a `Result` object, followed by setting
    the flow on a `CoroutineDispatcher`, and finally, handling the errors in the `catch`
    operator. The implementation of this will look like the following. Note that the
    `internal` keyword for the `executeData` method will only make the method accessible
    in the current module. This is because we only want the `execute` method to be
    called by the users of this use case:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个抽象类，它将包含 `execute` 方法，该方法将调用抽象的 `executeData` 方法，然后将该方法的输出映射到
    `Result` 对象中，接着在 `CoroutineDispatcher` 上设置流程，最后在 `catch` 操作符中处理错误。这个实现的代码如下。请注意，`executeData`
    方法的 `internal` 关键字将只使该方法在当前模块中可访问。这是因为我们只想让用例的用户调用 `execute` 方法：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, `GetUserWithLocationUseCase` will only have to deal with returning
    the necessary data relevant to the use case in the `executeData` method. We can
    use generics to bind the types of data we want the use case to process by introducing
    further abstractions for the required input and output of it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`GetUserWithLocationUseCase` 只需要在 `executeData` 方法中处理与用例相关的必要数据。我们可以通过引入对所需输入和输出的进一步抽象来使用泛型来绑定用例要处理的数据类型：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we have bound the generics in the `UseCase` class to two interfaces –
    `Request` and `Response`. The former is represented by the input data required
    by the use case, and the latter is represented by the output of the use case.
    The implementation will now look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `UseCase` 类中的泛型绑定到了两个接口——`Request` 和 `Response`。前者由用例所需的输入数据表示，后者由用例的输出表示。实现现在看起来像这样：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we provided the implementations for the `Request` and `Response` classes
    and used them when extending from the base class. In this case, the `Request`
    and `Response` classes represent **data transport objects**. When we create templates
    for use cases, it is important to observe their evolution because as the complexity
    increases, the template may become inadequate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了`Request`和`Response`类的实现，并在扩展基类时使用了它们。在这种情况下，`Request`和`Response`类代表**数据传输对象**。当我们为用例创建模板时，观察它们的演变非常重要，因为随着复杂性的增加，模板可能变得不适用。
- en: 'Often, we will have the opportunity to build a new use case from existing smaller
    use cases. Let''s assume that for retrieving a user and retrieving a location,
    we have two separate use cases:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将有机会从现有的较小用例中构建一个新的用例。假设在检索用户和位置时，我们有两个独立的用例：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding examples, we have two classes for each use case to retrieve
    a user and a location.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为每个用例检索用户和位置创建了两个类。
- en: 'We can modify `GetUserWithLocationUseCase` to instead use the existing use
    cases, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`GetUserWithLocationUseCase`修改为使用现有的用例，如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we changed the dependencies to instead use two existing use cases instead
    of the repositories, invoked the `executeData` method from each one, and then
    built a new `Response` using the responses from both use cases.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将依赖关系更改为使用两个现有的用例而不是仓库，从每个用例中调用`executeData`方法，然后使用这两个用例的响应构建一个新的`Response`。
- en: In this section, we looked at how to build a domain layer with entities, use
    cases, and abstractions for repositories. In the section that follows, we will
    look at an exercise related to building a domain layer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用实体、用例和抽象为仓库构建领域层。在接下来的章节中，我们将探讨与构建领域层相关的练习。
- en: Exercise 05.01 – Building a domain layer
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 05.01 – 构建领域层
- en: 'In this exercise, we will create a new project in `domain` will be created.
    This module will contain entities containing the following data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的项目，`domain`模块将被创建。此模块将包含包含以下数据的实体：
- en: '`User`: This will have an ID of the `Long` type and a name, username, and email.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`: 这将有一个`Long`类型的ID和一个名字、用户名和电子邮件。'
- en: '`Post`: This will have an ID and a user ID as a `Long` type, a title, and body.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Post`: 这将有一个ID和一个用户ID，类型为`Long`，标题和正文。'
- en: '`Interaction`: This will contain the total number of interactions with the
    app.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interaction`: 这将包含与该应用的总交互次数。'
- en: '`Errors`: This is for when posts or users cannot be loaded.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Errors`: 这是在帖子或用户无法加载时使用的。'
- en: 'The following use cases will need to be defined for the application:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要定义以下用例：
- en: Retrieving a list containing posts with user information, grouped with the interaction
    data
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据ID检索包含用户信息的帖子列表，并按交互数据分组
- en: Retrieving information about a particular user based on the ID
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据ID检索特定用户的信息
- en: Retrieving information about a particular post based on the ID
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据ID检索特定帖子的信息
- en: Updating the interaction data
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新交互数据
- en: 'To complete this exercise, you will need to do the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此练习，您需要执行以下操作：
- en: Create a new project in Android Studio.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目。
- en: Create a mapping of all the library dependencies and the versions in the root
    `build.gradle` file.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根`build.gradle`文件中创建所有库依赖项及其版本的映射。
- en: Create the `domain` module in Android Studio.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建`domain`模块。
- en: Create the required entities for the data and errors.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建所需的数据和错误实体。
- en: Create the `Result` class, which will hold the success and error scenario.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Result`类，它将包含成功和错误场景。
- en: Create the repository abstractions to obtain the user, post, and interaction
    information.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于获取用户、帖子和信息交互的仓库抽象。
- en: Create the four required use cases.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建所需的四个用例。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: Create a new project in Android Studio and select **Empty Compose Activity**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目并选择**Empty Compose Activity**。
- en: 'In the root `build.gradle` file, add the following configurations that will
    be used for all the modules in the project:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根`build.gradle`文件中，添加以下配置，这些配置将用于项目中的所有模块：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same file, add the versions of the libraries that will be used by the
    Gradle modules:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加Gradle模块将使用的库版本：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the same file, add a mapping for the plugin dependencies that the entire
    project will use:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加整个项目将使用的插件依赖项的映射。
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, you will need to add the dependencies to the `androidx` libraries:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要将`androidx`库的依赖项添加到`androidx`库中：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the remaining libraries for material design, dependency injection,
    and tests:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加剩余的用于材料设计、依赖注入和测试的库：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the same file, you will need to replace the previous mappings as plugin
    dependencies:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，您需要将之前的映射替换为插件依赖项：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, you need to switch to the `build.gradle` file in the app module and change
    the existing configurations with the ones defined in the top-level `build.gradle`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要切换到应用模块中的`build.gradle`文件，并将现有的配置更改为顶级`build.gradle`文件中定义的配置：
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the same file, you will need to replace the dependencies with the ones defined
    in the top-level `build.gradle` file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，您需要将依赖项替换为顶级`build.gradle`文件中定义的依赖项：
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In Android Studio, execute **Sync Project with Gradle Files** command and then
    the **Make Project** command to make sure that the project builds without any
    errors.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，执行**同步项目与Gradle文件**命令，然后执行**构建项目**命令以确保项目构建时没有错误。
- en: Create a new module for the project named `domain`, which will be an Android
    library module.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目创建一个名为`domain`的新模块，该模块将是一个Android库模块。
- en: 'In the `build.gradle` file of the `domain` module, make sure you have the following
    plugins:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`domain`模块的`build.gradle`文件中，确保您有以下插件：
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the same file, make sure you use the configurations defined in the top-level
    `build.gradle` file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，确保您使用顶级`build.gradle`文件中定义的配置：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the same file, you will need to add the following dependencies:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，您需要添加以下依赖项：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sync the project with Gradle files and build the project again to make sure
    that the Gradle configuration is correct.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Gradle文件同步项目，并再次构建项目以确保Gradle配置正确。
- en: In the `domain` module, create a new package named `entity`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`domain`模块中，创建一个名为`entity`的新包。
- en: 'In the `entity` package, create a class named `Post`, which will have `id`,
    `userId`, `title`, and `body`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`entity`包中，创建一个名为`Post`的类，该类将包含`id`、`userId`、`title`和`body`：
- en: '[PRE30]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the same package, create the `User` class, which will have `id`, `name`,
    `username`, and `email`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个名为`User`的类，该类将包含`id`、`name`、`username`和`email`：
- en: '[PRE31]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, create a class named `PostWithUser`, which will contain the `post` and
    `user` information:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`PostWithUser`的类，该类将包含`post`和`user`信息：
- en: '[PRE32]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the same package, create a class called `Interaction`, which will contain
    the total number of clicks:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个名为`Interaction`的类，该类将包含总点击次数：
- en: '[PRE33]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we need to create the error entities:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建错误实体：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we have exceptions defined for when there will be an issue with loading
    the post and user information, and `UnknownException`, which will be emitted when
    something else goes wrong.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了当加载帖子信息或用户信息出现问题时抛出的异常，以及当其他事情出错时抛出的`UnknownException`。
- en: 'Next, let''s create the `Result` class, which will hold the success and error
    information:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`Result`类，该类将包含成功和错误信息：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we need to move on to defining the abstractions for the repositories, and
    to do so, we create a new package named `repository`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要继续定义存储库的抽象，为此，我们创建一个名为`repository`的新包。
- en: 'In the `repository` package, create an interface for managing the post data:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`repository`包中，创建一个用于管理帖子数据的接口：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the same package, create an interface for managing the user data:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个用于管理用户数据的接口：
- en: '[PRE37]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the same package, create an interface for managing the interaction data:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个用于管理交互数据的接口：
- en: '[PRE38]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we move on to the use cases and start by creating a new package named `usecase`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续到用例部分，首先创建一个名为`usecase`的新包。
- en: 'In this package, create the `UseCase` template:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此包中，创建`UseCase`模板：
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this template, we have defined the data transfer objects' abstraction, as
    well as a `Configuration` class that holds `CoroutineDispatcher`. The reason for
    this `Configuration` class is to be able to add other parameters for the use case
    without modifying the `UseCase` subclasses. We have one `abstract` method, which
    will be implemented by the subclasses to retrieve the data from the repositories,
    and the `execute` method, which will take the data and convert it to `Result`,
    handle the error scenarios, and set the proper `CoroutineDispatcher`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，我们定义了数据传输对象的抽象，以及一个包含`CoroutineDispatcher`的`Configuration`类。创建此`Configuration`类的原因是能够在不修改`UseCase`子类的情况下添加其他参数用于用例。我们有一个`abstract`方法，该方法将由子类实现以从存储库中检索数据，以及一个`execute`方法，该方法将数据转换为`Result`，处理错误场景，并设置适当的`CoroutineDispatcher`。
- en: 'In the `usecase` package, create the use case to retrieve the list of posts
    with the user information and the interaction data:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`usecase`包中，创建一个用于检索包含用户信息和交互数据的帖子列表的用例：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this class, we extend the `UseCase` class, and in the `process` method, we
    combine the posts, users, and interaction flows. Because there is no input required,
    the `Request` class will have to be empty, and the `Response` class will contain
    a list of combined user and post information as well as the interaction data.
    The `@Inject` annotation will help us inject this use case later in the presentation
    layer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们扩展了`UseCase`类，并在`process`方法中结合了帖子、用户和交互流程。因为没有输入要求，`Request`类将必须为空，而`Response`类将包含一个包含组合用户和帖子信息以及交互数据的列表。`@Inject`注解将帮助我们在此演示层中注入此用例。
- en: 'In the same package, create the use case to retrieve a post by ID:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个用于通过ID检索帖子的用例：
- en: '[PRE41]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the same package, create the use case to retrieve a user by ID:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个用于通过ID检索用户的用例：
- en: '[PRE42]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we move on to the last use case for updating the interaction data:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续到最后一个用例，用于更新交互数据：
- en: '[PRE43]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To unit-test the code, we need to create a new folder called `resources` in
    the `test` folder of the `domain` module.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了单元测试代码，我们需要在`domain`模块的`test`文件夹中创建一个名为`resources`的新文件夹。
- en: Inside the `resources` folder, create a subfolder called `mockito-extensions`;
    inside this folder, create a file named `org.mockito.plugins.MockMaker`; and inside
    this file, add the following text – `mock-maker-inline`. This allows the Mockito
    testing library to mock the `final` Java class, which in Kotlin means all classes
    without the `open` keyword.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources`文件夹内，创建一个名为`mockito-extensions`的子文件夹；在这个文件夹内，创建一个名为`org.mockito.plugins.MockMaker`的文件；并在该文件内添加以下文本——`mock-maker-inline`。这允许Mockito测试库模拟`final`
    Java类，在Kotlin中意味着所有不带`open`关键字的类。
- en: 'Create a new class named `UseCaseTest` in the test folder of the `domain` module:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`domain`模块的测试文件夹中创建一个名为`UseCaseTest`的新类：
- en: '[PRE44]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we provide an implementation for the `UseCase` class, which will return
    a mocked response.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们为`UseCase`类提供了一个实现，它将返回一个模拟的响应。
- en: 'Next, create a test method that will verify the successful scenario for the
    `execute` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个测试方法来验证`execute`方法的成功场景：
- en: '[PRE45]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we assert that the result of the `execute` method is `Success` and that
    it contains the mocked response.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们断言`execute`方法的结果是`Success`并且它包含模拟的响应。
- en: 'Next, create a new test class named `GetPostsWithUsersWithInteractionUseCaseTest`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`GetPostsWithUsersWithInteractionUseCaseTest`的新测试类：
- en: '[PRE46]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we mock all the repositories and inject the mocks into the class we want
    to test.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们模拟了所有仓库并将模拟注入我们想要测试的类中。
- en: 'Finally, create a test method that will verify the `process` method from the
    use case we are testing:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个测试方法来验证我们正在测试的用例中的`process`方法：
- en: '[PRE47]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we provide mock lists of users and posts and a mock interaction, then
    we return these for each of the repository calls, and then we assert that the
    result is a list of four posts, written by two users and the mock interaction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们提供了模拟的用户和帖子列表以及一个模拟的交互，然后我们为每个仓库调用返回这些，然后断言结果是包含四个帖子、由两个用户编写以及模拟交互的列表。
- en: 'If we run the tests for these two methods, they should pass. To test the remaining
    use cases, the same principles can be applied that we used for `GetPostsWithUsersWithInteractionUseCaseTest`
    – create mock repositories, inject them into the object we wish to test, and then
    define the mocks for the input of the `process` method and the results we should
    expect, which will give us output as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这两个方法的测试，它们应该会通过。为了测试剩余的用例，我们可以应用与`GetPostsWithUsersWithInteractionUseCaseTest`相同的原理——创建模拟仓库，将它们注入我们希望测试的对象中，然后定义`process`方法的输入模拟和预期的结果，这将给我们以下截图所示输出：
- en: '![Figure 5.5 – Output of the use case unit tests'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 用例单元测试的输出'
- en: '](img/Figure_5.05_B18320.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.05_B18320.jpg]'
- en: Figure 5.5 – Output of the use case unit tests
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 用例单元测试的输出
- en: In this section, we performed an exercise in which we created a simple domain
    that contained entities, a few simple use cases, and a particular use case that
    combined multiple data sources. The domain module has dependencies on flows and
    Hilt. This means that changes to these libraries might cause changes to our domain
    module. This decision was made because of the benefits that these libraries provide
    when it comes to reactive programming and dependency injection. Because we considered
    dependency injection when defining the use cases, this made them more testable,
    as we could inject mock objects into the tested objects very easily.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们进行了一个练习，创建了一个简单的领域，其中包含实体、几个简单的用例以及一个结合了多个数据源的特定用例。领域模块依赖于flows和Hilt。这意味着这些库的更改可能会影响我们的领域模块。这个决定是因为这些库在响应式编程和依赖注入方面提供的优势。由于我们在定义用例时考虑了依赖注入，这使得它们更容易测试，因为我们能够非常容易地将模拟对象注入到测试对象中。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how the architecture of an Android app is layered
    and focused on the domain layer, discussing the topics of entities and use cases.
    We also learned how to use dependency inversion to place use cases and entities
    at the center of our architecture. We did this by creating repository abstractions
    that can be implemented in the lower layers. We also learned how to use library
    modules to enforce separations between layers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Android应用程序架构的分层结构，并专注于领域层，讨论了实体和用例的主题。我们还学习了如何使用依赖倒置将用例和实体置于我们架构的中心。我们通过创建可以在底层实现的仓库抽象来实现这一点。我们还学习了如何使用库模块来强制层之间的分离。
- en: In the chapter's exercise, we created a domain module for an Android application,
    providing an example of what a domain layer might look like. In the next chapter,
    we will focus on the data layer, in which we will provide implementations for
    the repository abstractions we defined in the domain layer, and discuss how we
    can use these repositories to manage an application's data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习中，我们为Android应用程序创建了一个领域模块，提供了一个领域层可能的样子示例。在下一章中，我们将专注于数据层，我们将提供在领域层定义的仓库抽象的实现，并讨论我们如何使用这些仓库来管理应用程序的数据。
