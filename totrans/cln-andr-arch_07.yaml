- en: '*Chapter 5*: Building the Domain of an Android Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will analyze what the architecture of an Android application
    typically looks like and its three main layers (**presentation**, **domain**,
    and **data**). Then, we will learn how we can translate it into clean architecture
    and focus on the domain layer, which sits at the center of the architecture. Next,
    we will look at the role it plays in the architecture of an application and what
    its entities and use cases are. Finally, we will look at an exercise, in which
    we are going to see how we can set up an Android Studio project with multiple
    modules and use them to structure the domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the app's architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the domain layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with the domain layer of an
    application, domain entities, and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the hardware and software requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio – Arctic Fox | 2020.3.1 Patch 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter5).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3826FH6](https://bit.ly/3826FH6)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the app's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the most common architecture that can be applied
    to an Android application and how it can be combined with **clean architecture**
    principles, and see how we should ideally structure our code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the exercises from the previous chapters, we saw how, for an application
    that requires the integration of multiple data sources for networking and persistence,
    we had to put a lot of logic inside the `ViewModel` class. In those examples,
    `ViewModel` had multiple responsibilities, including fetching the data from the
    internet, persisting it locally, and holding the required information in the user
    interface. On top of these extra responsibilities, `ViewModel` also had many dependencies
    on the different data sources; this means that a change in the networking or persistence
    libraries would require a change in `ViewModel`. To solve this problem, our code
    would need to be split into separate layers with different responsibilities. Typically,
    the layers would look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – An app architecture diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – An app architecture diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.1*, we can see that there are three layers with different responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModels`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain layer**: This layer is responsible for fetching data from the data
    layer and performing business logic that can be reused across an app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data layer**: This layer is responsible for handling the business logic of
    an application that deals with the managing of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can apply the *clean architecture* principles on top of the layered architecture
    by placing the domain layer at the center, as shown in *Figure 5.2*, and making
    it the place to store our *entities* and *use cases*. At the outer layers are
    the presentation and data layers, which are represented by the `ViewModels` and
    `Repositories`) and the **framework layer** (represented by the user interface
    and persistence and networking frameworks):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – An app layer dependency diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – An app layer dependency diagram
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that the dependencies between the domain
    layer and the data layer are inverted. The domain layer will still draw data from
    the data layer, but because it has inverted dependencies, it will be less impacted
    by any changes to that layer, just as if any changes occur to the presentation
    layer, they will not impact the domain layer. If the app suffers from any changes
    to the use cases, then it will drive the changes in both the presentation and
    data layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To separate the layers, we can use **Android modules**. This will help us impose
    further rigor on the project by avoiding unwanted dependencies between the layers.
    This also helps improve build times in large applications because of Gradle build
    caching, which will only rebuild modules that had code changes. This will look
    something like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – An app module diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – An app module diagram
  prefs: []
  type: TYPE_NORMAL
- en: We can see that there isn't a limited number of modules we need for each layer
    or that we should have corresponding modules between the three layers. The expansion
    of each layer can be driven by different factors such as the data sources, the
    uses of the app, the technologies, and protocols used in those data sources (using
    REST APIs for certain data and Bluetooth or Near-field communication for other
    data types). The usage of the use cases might be another factor (such as having
    a certain set of use cases for use with multiple applications). We might want
    to expand the presentation layer because of how certain screens are grouped to
    form certain isolated features and flows inside an application (such as a settings
    section of the application, or a login/sign-up flow). One interesting aspect to
    note is the `:app` module, which has the role of combining all of the dependencies
    and assembling them together. Here, we will gather all the required dependencies
    and initialize them.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note here is that the modules aren't equivalent to the
    layers themselves; data modules can have dependencies to lower-level data modules.
    In fact, this situation will occur in scenarios when a module from a layer will
    need to have a dependency on another module from the same layer. If we were to
    create a dependency between the two, we might end up with a cyclical dependency,
    which is not wanted. In that situation, we will need to create a common module
    between the two that will hold the required dependencies. For example, if we want
    to navigate from a screen in `:presentation1` to a screen in `:presentation2`
    or any of the other ones, we will need to create a new module on which all of
    the presentation modules will depend and which will store the data or logic required
    to handle the navigation. We will look at this issue in more detail when we discuss
    the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new Android Studio module, you need to right-click the project
    in Android Studio, select **New**, and then **Module**, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Creating a new Android Studio module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Creating a new Android Studio module
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be prompted to select the type of module, and depending on the
    functionality, you can select `build.gradle` file. The plugin section in the file
    will indicate that an Android library was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to add a dependency to the newly created module, we can use the
    following in the `app` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The syntax to add a dependency to a module is similar to the syntax to add an
    external dependency and it's through the Gradle `implementation` method. The rest
    indicates that the `app` module will depend on another module inside the same
    project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have analyzed the layers of Android app architecture and
    how we can apply clean architecture principles to these layers. In the following
    section, we will look at how we can build a domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the domain layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how to build the domain layer and what goes
    into it through certain examples. Finally, we will look at an exercise in which
    a domain layer is created.
  prefs: []
  type: TYPE_NORMAL
- en: Because the domain layer sits at the center of the application, it will need
    to have a minimal number of dependencies. This means that the Gradle modules that
    form the domain layer will need to be the most stable modules in the project.
    This is to avoid causing other modules to change because of a change that occurred
    in a dependency that the domain modules use. The domain should be responsible
    for defining the entities and use cases for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entities are represented by objects that hold data and are mainly immutable.
    Let''s assume we want to represent a user as an entity. We might end up with something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use a simple `data class`, and we declare all our fields immutable
    with the `val` keyword. We also have a business logic function for this object,
    which will return the full name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define our use cases. Because the use cases will need to get
    data from the data layer, we will first need to create an abstraction for our
    repository, and we will end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just have a simple method that will return a user based on `id`. We
    can now create a use case for retrieving the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we define a use case to retrieve the user, which will
    have a dependency on the `UserRepository`, which will be used to retrieve the
    user information. If we look at the preceding example, we can see a bit of redundancy
    because the use case doesn't have any extra logic and just returns the value of
    the repository. The benefit of use cases comes when we want to combine multiple
    results of multiple repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to associate the user with a particular location,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just keep the latitude and longitude associated with a particular
    user. Now, let''s assume that we would have a repository for the different locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we again have an abstraction of a repository with a method to get a specific
    location based on `userId`. If we want to get a user and an associated location,
    we will need to create a specific use case for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a new entity called `UserWithLocation`,
    which will store `User` and `Location`. `UserWithLocation` will then be used as
    a result for the `getUser` method in `GetUserWithLocationUseCase`. This will depend
    on both `UserRepository` and `LocationRepository` to fetch the relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further improve the use cases by handling the threading as well. Because
    use cases will mainly deal with retrieving and managing data, which needs to be
    asynchronous, we should handle this on a separate thread. We can use **Kotlin
    flows** to manage this, and we might end up with something like this for the repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we change the return types of the methods to a Kotlin flow, which might
    emit a stream of data or a single item. Now, we can combine the different flows
    in the stream in the use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we combine the `User` and `Location` flows into a `UserWithLocation` flow,
    and we will execute the data fetching on the `IO` dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, when dealing with data loading and management, especially from the internet,
    we can encounter different errors, which we will have to factor into our use cases.
    To solve this, we can define error entities. There are many possibilities to define
    them, including extending the `Throwable` class, defining a particular data class,
    a combination of the two, or combining them with sealed classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a sealed class that will have as subclasses a dedicated
    error for each entity, plus an unknown error that will deal with errors we haven''t
    accounted for, and a companion method that will check a `Throwable` object and
    return `UnknownException` for any `Throwable` that isn''t `UseCaseException`.
    We will need to make sure that the error is propagated through the flow stream,
    but first, we can combine the entity for success with the entity for error to
    ensure that the consumer of the use case will not need to check the type of `Throwable`
    again and make a cast. We can do this with the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined a `Result` sealed class, which will have two subclasses for
    success and error. The `Success` class will hold the relevant data for the use
    case, and the `Error` class will contain the exceptions defined before. The `Error`
    class can be further expanded if needed to hold data as well as the error if we
    want to display the cached or persisted data as a placeholder. We can now modify
    the use case to incorporate the `Result` class and the error state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we return `Result.Success`, which will hold the `UserWithLocation` object
    if no errors occur, and add use the `catch` operator to emit `Result.Error` with
    `UseCaseException` that occurred while fetching the data. Because these operations
    will repeat for multiple use cases, we can use abstraction to create a template
    for how each use case behaves and let the implementations deal with only processing
    the necessary data. An example might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have defined an abstract class that will contain
    the `execute` method, which will invoke the abstract `executeData` method and
    then map the result of that method into a `Result` object, followed by setting
    the flow on a `CoroutineDispatcher`, and finally, handling the errors in the `catch`
    operator. The implementation of this will look like the following. Note that the
    `internal` keyword for the `executeData` method will only make the method accessible
    in the current module. This is because we only want the `execute` method to be
    called by the users of this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `GetUserWithLocationUseCase` will only have to deal with returning
    the necessary data relevant to the use case in the `executeData` method. We can
    use generics to bind the types of data we want the use case to process by introducing
    further abstractions for the required input and output of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have bound the generics in the `UseCase` class to two interfaces –
    `Request` and `Response`. The former is represented by the input data required
    by the use case, and the latter is represented by the output of the use case.
    The implementation will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we provided the implementations for the `Request` and `Response` classes
    and used them when extending from the base class. In this case, the `Request`
    and `Response` classes represent **data transport objects**. When we create templates
    for use cases, it is important to observe their evolution because as the complexity
    increases, the template may become inadequate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, we will have the opportunity to build a new use case from existing smaller
    use cases. Let''s assume that for retrieving a user and retrieving a location,
    we have two separate use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, we have two classes for each use case to retrieve
    a user and a location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify `GetUserWithLocationUseCase` to instead use the existing use
    cases, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we changed the dependencies to instead use two existing use cases instead
    of the repositories, invoked the `executeData` method from each one, and then
    built a new `Response` using the responses from both use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how to build a domain layer with entities, use
    cases, and abstractions for repositories. In the section that follows, we will
    look at an exercise related to building a domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 05.01 – Building a domain layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a new project in `domain` will be created.
    This module will contain entities containing the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`User`: This will have an ID of the `Long` type and a name, username, and email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Post`: This will have an ID and a user ID as a `Long` type, a title, and body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Interaction`: This will contain the total number of interactions with the
    app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Errors`: This is for when posts or users cannot be loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following use cases will need to be defined for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a list containing posts with user information, grouped with the interaction
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving information about a particular user based on the ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving information about a particular post based on the ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the interaction data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To complete this exercise, you will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a mapping of all the library dependencies and the versions in the root
    `build.gradle` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `domain` module in Android Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the required entities for the data and errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `Result` class, which will hold the success and error scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the repository abstractions to obtain the user, post, and interaction
    information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the four required use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio and select **Empty Compose Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the root `build.gradle` file, add the following configurations that will
    be used for all the modules in the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, add the versions of the libraries that will be used by the
    Gradle modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, add a mapping for the plugin dependencies that the entire
    project will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you will need to add the dependencies to the `androidx` libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the remaining libraries for material design, dependency injection,
    and tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, you will need to replace the previous mappings as plugin
    dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you need to switch to the `build.gradle` file in the app module and change
    the existing configurations with the ones defined in the top-level `build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, you will need to replace the dependencies with the ones defined
    in the top-level `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Android Studio, execute **Sync Project with Gradle Files** command and then
    the **Make Project** command to make sure that the project builds without any
    errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new module for the project named `domain`, which will be an Android
    library module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `build.gradle` file of the `domain` module, make sure you have the following
    plugins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, make sure you use the configurations defined in the top-level
    `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, you will need to add the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sync the project with Gradle files and build the project again to make sure
    that the Gradle configuration is correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `domain` module, create a new package named `entity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `entity` package, create a class named `Post`, which will have `id`,
    `userId`, `title`, and `body`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same package, create the `User` class, which will have `id`, `name`,
    `username`, and `email`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a class named `PostWithUser`, which will contain the `post` and
    `user` information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same package, create a class called `Interaction`, which will contain
    the total number of clicks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create the error entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have exceptions defined for when there will be an issue with loading
    the post and user information, and `UnknownException`, which will be emitted when
    something else goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the `Result` class, which will hold the success and error
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to move on to defining the abstractions for the repositories, and
    to do so, we create a new package named `repository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `repository` package, create an interface for managing the post data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same package, create an interface for managing the user data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same package, create an interface for managing the interaction data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we move on to the use cases and start by creating a new package named `usecase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this package, create the `UseCase` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this template, we have defined the data transfer objects' abstraction, as
    well as a `Configuration` class that holds `CoroutineDispatcher`. The reason for
    this `Configuration` class is to be able to add other parameters for the use case
    without modifying the `UseCase` subclasses. We have one `abstract` method, which
    will be implemented by the subclasses to retrieve the data from the repositories,
    and the `execute` method, which will take the data and convert it to `Result`,
    handle the error scenarios, and set the proper `CoroutineDispatcher`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `usecase` package, create the use case to retrieve the list of posts
    with the user information and the interaction data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this class, we extend the `UseCase` class, and in the `process` method, we
    combine the posts, users, and interaction flows. Because there is no input required,
    the `Request` class will have to be empty, and the `Response` class will contain
    a list of combined user and post information as well as the interaction data.
    The `@Inject` annotation will help us inject this use case later in the presentation
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same package, create the use case to retrieve a post by ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same package, create the use case to retrieve a user by ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we move on to the last use case for updating the interaction data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To unit-test the code, we need to create a new folder called `resources` in
    the `test` folder of the `domain` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `resources` folder, create a subfolder called `mockito-extensions`;
    inside this folder, create a file named `org.mockito.plugins.MockMaker`; and inside
    this file, add the following text – `mock-maker-inline`. This allows the Mockito
    testing library to mock the `final` Java class, which in Kotlin means all classes
    without the `open` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class named `UseCaseTest` in the test folder of the `domain` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we provide an implementation for the `UseCase` class, which will return
    a mocked response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a test method that will verify the successful scenario for the
    `execute` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we assert that the result of the `execute` method is `Success` and that
    it contains the mocked response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new test class named `GetPostsWithUsersWithInteractionUseCaseTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we mock all the repositories and inject the mocks into the class we want
    to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create a test method that will verify the `process` method from the
    use case we are testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we provide mock lists of users and posts and a mock interaction, then
    we return these for each of the repository calls, and then we assert that the
    result is a list of four posts, written by two users and the mock interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the tests for these two methods, they should pass. To test the remaining
    use cases, the same principles can be applied that we used for `GetPostsWithUsersWithInteractionUseCaseTest`
    – create mock repositories, inject them into the object we wish to test, and then
    define the mocks for the input of the `process` method and the results we should
    expect, which will give us output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Output of the use case unit tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Output of the use case unit tests
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we performed an exercise in which we created a simple domain
    that contained entities, a few simple use cases, and a particular use case that
    combined multiple data sources. The domain module has dependencies on flows and
    Hilt. This means that changes to these libraries might cause changes to our domain
    module. This decision was made because of the benefits that these libraries provide
    when it comes to reactive programming and dependency injection. Because we considered
    dependency injection when defining the use cases, this made them more testable,
    as we could inject mock objects into the tested objects very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how the architecture of an Android app is layered
    and focused on the domain layer, discussing the topics of entities and use cases.
    We also learned how to use dependency inversion to place use cases and entities
    at the center of our architecture. We did this by creating repository abstractions
    that can be implemented in the lower layers. We also learned how to use library
    modules to enforce separations between layers.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapter's exercise, we created a domain module for an Android application,
    providing an example of what a domain layer might look like. In the next chapter,
    we will focus on the data layer, in which we will provide implementations for
    the repository abstractions we defined in the domain layer, and discuss how we
    can use these repositories to manage an application's data.
  prefs: []
  type: TYPE_NORMAL
