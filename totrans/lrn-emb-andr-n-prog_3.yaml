- en: Chapter 3\. Set up and Build – the Emulator Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to retrieve the source code and we had
    an overview of the folder's structure. We now know how the branching model works
    and how to contribute to the project. This is an important topic, because Android
    is an open source prot, but it's managed in a very different way compared to other
    popular open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will set up the whole environment to get ready to build
    our first Android system and flash it to a real target. Our efforts will be focused
    to create a fully-working version for the official Android emulator.
  prefs: []
  type: TYPE_NORMAL
- en: The user will learn how to use tools such as `adb` and `fastboot`, two of the
    most important tools that Google provides.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the host system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a complex system such as Android, we need to satisfy a few hardware
    and software requirements. First of all the host system.
  prefs: []
  type: TYPE_NORMAL
- en: The official Linux distribution supporting the Android build environment is
    `Ubuntu Linux`. Google periodically releases new Android builds for its devices
    and all of them are created using Ubuntu. Currently, Google is using Ubuntu 14.04
    even if this is not the latest version available.
  prefs: []
  type: TYPE_NORMAL
- en: Every example in this book will be developed and executed on a common notebook,
    with an Intel i5 CPU and 4 GB of RAM, running Ubuntu Linux 15.05, that's the latest
    available version. Using a different Linux version proves that if all the requirements
    are satisfied, you could build Android with any Linux distribution or even Mac
    OS X— if you can't set up Ubuntu, trying with a different version will be challenging,
    but will be worth trying, as a learning experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a Microsoft Windows user, it is sad to say, you won't be able to
    build Android using the native operative system. A possible solution is using
    a virtual machine running Ubuntu, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Digging into hardware requirements, you will just need a recent personal computer.
    As anticipated in the previous section, we are going to use a middle-end notebook
    for our examples. It''s a Lenovo x220, with Intel i5 CPU and 4GB of RAM: it''s
    enough to do the job and it''s affordable, but the build time won''t be small.'
  prefs: []
  type: TYPE_NORMAL
- en: To speed up the build time, using a high-end PC is advisable. A faster CPU,
    with more cores, and more RAM will take advantage of multithreading and parallel
    building and will significantly reduce the build time, allowing you to experiment
    more during the journey.
  prefs: []
  type: TYPE_NORMAL
- en: A critical point of the environment setup is the necessary hard disk free space.
    The required amount is considerable—the source code alone needs approximately
    100 GB to be stored. The whole build process will require approximately 150GB.
    If we are trying to build as fast as possible, probably we will enable the building
    system caching option, `ccache`. The caching system will require even more free
    space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table will give you a rough estimation about minimum and recommended
    hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_34.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Software requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we are going to build the system using Ubuntu Linux 15.04\. If
    you cannot obtain this version, you can successfully use an older version, like
    the guys at Google, a totally different distribution or even a Virtual Machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the basic requirements, when it comes to the operating system, is the
    architecture: if we are planning to build Android 2.3 or greater, we will need
    a 64-bit system. Older versions of Android will do fine with a 32-bit system,
    but that''s an improbable scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Java JDK
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Oracle''s *Java Development Kit* is a crucial requirement, essential to be
    able to build Android. Every Android version needs a specific JDK version. According
    to what version we want to build, we are going to install:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 5 for Cupcake to Froyo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK 6 for Gingerbread to KitKat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK 7 for KitKat, Lollipop, and Marshmallow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to build Android Lollipop 5.1.1 and we are going to need at least
    JDK 7\. Installing JDK on Ubuntu is quite straightforward. Let''s start by opening
    a Terminal and firing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apt-get` command will resolve all the dependencies, download all the required
    packages and install them. If you are a *Mouse and icons* user, you can achieve
    the same goal using **Ubuntu Software Center**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_35.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are a Java developer or you plan to build different Android versions
    for specific reasons, Ice Cream Sandwich and Lollipop, for instance, you could
    end up having more than just one version of the Java Development Kit. This multipurpose
    scenario brings a few more steps of configuration. We need to specify which JDK
    version will be used as the default one in the system. Using our trusted Terminal,
    let''s run these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the output. As you can see, it lists all the
    available JDK versions and lets you pick the one to set as default. In our scenario,
    we are using JDK 7 because we are planning to build Android 5 or greater.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_36.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installing system dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even if Java is a key player in the Android world, we also need a few *low-level*
    tools to satisfy all the Android build system requirements. Some of them are common
    tools and there is a chance that they are already installed, but our goal is to
    set up a whole system from scratch: we can''t risk missing a dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your Terminal, run the following `apt-get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, `apt-get` will resolve all the dependencies and install all the required
    packages. The following screenshot shows the output of the command in the scenario
    in which you already have all the required packages, lucky you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_37.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, your Ubuntu contains all the required packages and applications
    to build the world's most popular mobile operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Mac OS X environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important requirements to build Android is a case-sensitive
    filesystem. If you are planning to build Android using OS X, the most practical
    way to satisfy this requirement is to create a partition or a disk image containing
    a case-sensitive filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a case-sensitive disk image
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'OS X provides a handy graphical utility to create a new disk image. Fire up
    `Spotlight` and launch `Disk Utility`. The upper toolbar contains a **New Image**
    button that takes you to the disk image creation screen, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_38.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding screenshot, the crucial setting is the **Format**:
    it has to be `Case-sensitive, Journaled`. For the **Size** setting, the larger
    the better, keeping in mind that an Android build could use hundreds of gigabytes
    in no time. As minimal size, we suggest at least 50 GB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are more a *command line* type, it''s possible to create this disk image
    using the Terminal and `hdiutil`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the disk image creation succeeded, we now have a `.dmg` or `.dmg.sparsefile`
    file on our disk. Once we have mounted it, we can use it as a normal hark disk—downloading
    Android source code and proceeding with the building procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two following commands will give you the ability to mount and unmount the
    disk image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you run out of space, the following command will give you the opportunity
    to resize the disk image and allow you to continue working on your desired Android
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Installing the required software
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we have our installation disk image, the same as for Linux, we need to
    install all those software requirements we need to properly build the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the Java Development Kit is very straightforward: just download
    the proper `.dmg` file from [http://www.oracle.com](http://www.oracle.com) and
    install it. The same rules about Android target version and required Java version
    apply here too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Xcod**e: The installation is well documented at [https://developer.apple.com](https://developer.apple.com)
    as Xcode is the main player of iOS development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MacPorts**: It''s an open source project that will help us to install lots
    of useful tools. You can install it following the installation info at [http://www.macports.org/install.php](http://www.macports.org/install.php).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have these two main pieces of the puzzle in place, we need to install
    `make`, `git`, `bison`, and `GPG` packages, using MacPorts, with the following
    command on your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we need to increase the maximum number of possible file
    descriptors. OS X comes with a tiny value—the average user does not need all those
    file descriptors, but we are going to need a bigger amount due to the hundreds
    of files involved in the Android build procedure. To increase this value, we will
    need to launch our Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, the limit is up to 1,024 files. We can make this value persistent by adding
    this to the `~/.bash_profile` file, in your `home` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The Android build system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before digging into configuring and building your first Android system, we will
    have an overview of the build system itself, the tools involved, and the unique
    approach to the whole process Google has.
  prefs: []
  type: TYPE_NORMAL
- en: There is very little official documentation available about creating new modules
    and about the build system itself. Most of your knowledge at the end of this journey
    will come from your own hands-on experience and from our experience that we put
    in these pages.
  prefs: []
  type: TYPE_NORMAL
- en: An overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with lots of projects out there, open source or closed source, Android uses
    the powerful tool `make` to build the whole system, but compared to all other
    projects, Android uses it in a completely different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common approach of using `make` would be to use a hierarchy of Makefiles:
    one single root Makefile retrieves and runs every other Makefile, contained in
    some of the subfolders of the project. Usually, every subfolder represents a submodule
    of the main project and it can be built alone or could depend upon other modules.
    Unlike other projects, Android has no `menuconfig` or any other graphical configuration
    utility to customize the build system, enable or disable modules. Every sort of
    build configuration is done using environment variables that we will show in the
    next sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the whole module building is unconventional. Taking the Linux kernel
    as an example, usually, when a module is built, in the same folder with the source
    code, we have the compiled files. Module after module, the build system compiles
    everything and, at the very end, it retrieves the required files, links them together,
    and generates the final output. Android works in a different way. As you will
    notice approaching the build completion, Android tries to keep every module folder
    as clean as possible—every compiled file ends up in the `/out` folder, so that
    it's easier to clean everything, just delete this folder and have everything perfectly
    in order in a blink of an eye.
  prefs: []
  type: TYPE_NORMAL
- en: As you could guess at this point, the build system is completely custom made
    by Google. Everything has been designed and developed from scratch, using existent
    tools, but approaching the problem in an unusual way. Android developers created
    a single huge Makefile, containing all the needed information to build every single
    module and to assemble the final system image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole build system is contained in the `build/` folder. This folder contains:'
  prefs: []
  type: TYPE_NORMAL
- en: Utility shell scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility Python scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of .`mk` files containing all the necessary information to create all
    the system modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every single module has its own folder. This folder contains the most important
    file to build the module `Android.mk`. This file contains all the information
    needed to perform a smooth compilation of the module source code and generate
    a binary file.
  prefs: []
  type: TYPE_NORMAL
- en: Module `Android.mk` files are the first step of the building procedure—the build
    system scans every folder looking for these files and includes them into the single
    huge Makefile that it will use for further steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code root folder contains a Makefile with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The file looks pretty empty, but it contains the most important `.mk` file of
    all—`main.mk`. This file, located in `build/core`, contains a sequence of checks
    and all the needed operations to retrieve all the `Android.mk` files to build
    all the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Without special configuration, the Android build system only creates the Android
    system image. To generate CTS, NDK, and SDK, we will need a bit more setup effort
    as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The whole build system is fired up, thanks to a single shell script—`build/envsetup.sh`.
    As you can see in the following screenshot, this script is in charge of preparing
    the building environment. It sets up a few configurations and provides useful
    tools that make our work much easier: it''s the Swiss Army knife of the Android
    build system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fire up your Terminal and run the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_39.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot shows the output of `envsetup.sh`, that brings the
    system to be fully operational and ready to build. To have a list of all the commands
    that we now have available, on your Terminal, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/epub_36702041_40.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot shows the output of the `hmm` command. We will have
    a look at lots of them later, but as a yummy anticipation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lunch`: This command helps you configure everything we need for a specific
    target with one single command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mm`: This command lets you compile just the module contained in your current
    folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A proper configuration environment is one of the most important things for
    a build system. Every build system provides a clear way to specify, for instance,
    which module to build of which platform we are targeting. Having the Linux kernel
    as a great example, we can say that it provides a handy graphical menu to perform
    all the necessary configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Menuconfig lets you enable or disable modules to be built, select the desired
    platform, and tons of other different possible configurations. Every single configuration
    bit is saved in a `.config` file that can be easily read or edited and reused
    for the build procedure.
  prefs: []
  type: TYPE_NORMAL
- en: As we anticipated, Android is based on something completely different. There
    is no graphical interface to perform the configuration. The only sort of interactive
    or automatic configuration system is `envsetup.sh`, which we already learned about.
    So why does Android not have any cool tools to configure the build system? Simply,
    because it does not need one! We are not supposed to disable all the modules we
    don't want to build, so Android just does not provide an easy way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we are building Android for a new device we have just created
    and it does not have a camera on-board. We might want to remove that part of the
    system that manages the camera. There is no official way to do it. If we want
    to do it, we need to get our hands dirty and with time and pages we will be able
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: We can safely say that the whole Android build system configuration can be stripped
    down to setting a few environment variables. The build system will use these variables
    to figure out which device we are targeting or which toolchain it is supposed
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: TARGET_PRODUCT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TARGET_BUILD_VARIANT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TARGET_BUILD_TYPE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TARGET_TOOLS_PREFIX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TARGET_PREBUILT_KERNEL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OUT_DIR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming sections, we are going to learn all about these variables we
    can manipulate to perfect our build.
  prefs: []
  type: TYPE_NORMAL
- en: The TARGET_PRODUCT variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This variable contains the information to specify the device we are preparing
    the system for. We are currently targeting the official emulator, so we are going
    to set the variable as `aosp_arm`. If we want to build the system for Google's
    Nexus 6, we will set the variable to `aosp_shamu`, or to `aosp_hummerhead` for
    Google's Nexus 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'For quick access to all the values, specific for all the supported devices,
    we have provided a handy table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_41.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can imagine, every device supports a specific version of the system.
    For instance, with our current downloaded source base, tag android-5.1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: aosp_arm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_arm64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_mips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_mips64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_x86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_x86_64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_manta
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_flounder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mini_emulator_x86_64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mini_emulator_mips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mini_emulator_x86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mini_emulator_arm64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: m_e_arm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_mako
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_hammerhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_shamu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: full_fugu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_fugu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_deb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_tilapia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_flo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aosp_grouper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have decided on the target device, fire up a Terminal and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The TARGET_BUILD_VARIANT variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every `Android.mk` file refers to this variable to enable and disable the sections
    of its codebase to be compiled or not. This variable has three possible values
    and it specifies the build variant. We can set it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eng`: Here, every module tagged with user, debug, and `eng` is enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userdebug`: Here, every module tagged with the user and debug is enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: Here, every module tagged with the user is enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The TARGET_BUILD_TYPE variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This variable specifies which type of build we are going to perform for every
    module. If we are going to create a development system, we are going to need more
    logging information, for instance. For this scenario, we are going to set this
    variable as `debug`, build, and test our system. After this phase, we will rebuild
    the system with this variable set to `release`, to disable the verbose logging
    and all the development perks.
  prefs: []
  type: TYPE_NORMAL
- en: The TARGET_TOOLS_PREFIX variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This variable specifies the path for a custom toolchain to be used during the
    build process. Usually, it stays empty, but, gaining experience, you should try
    different toolchains, freely available on the Internet. One of the most famous
    and optimized custom toolchains is developed and distributed by the `Linaro` team.
  prefs: []
  type: TYPE_NORMAL
- en: The OUT_DIR variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If for some specific reason we want to override the default path of the `out/`
    folder, we can use this variable to specify a custom path. This variable is extremely
    useful in all the scenarios that have multiple hard drives or network shares.
    For instance, we could run the build process on a fast SSD disk and store the
    output on a standard old-fashioned disk or even a network disk, to share it with
    our teammates.
  prefs: []
  type: TYPE_NORMAL
- en: The TARGET_PREBUILT_KERNEL variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a quite advanced variable. It allows us to provide the system with a
    kernel different from the default one. Every target device comes with a precompiled
    default kernel because the Android build system is not going to build it—it's
    already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Injecting a custom kernel is a very interesting topic that opens lots of interesting
    scenarios. In Chapter 5, *Customizing Kernel and Boot Sequence*, we are going
    to build a custom kernel and inject it into our Android system, to create a fully
    customized Android experience: this variable will be one of the most important
    pieces of the puzzle.'
  prefs: []
  type: TYPE_NORMAL
- en: The buildspec.mk file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we want to persist these variables, we can add them to a `buildspec.mk` file.
    Every time we will run `make`, the system will check this file, evaluate all the
    variables, and move forward accordingly. The `buildspec.mk` file comes in a handy
    template version in the `build/` folder as `buildspec.mk.default`. This template
    file contains every available variable. Every variable is commented, disabled
    by default, and comes with a small note about its purpose and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: We could consider this file the equivalent of the Linux kernel `.config` file,
    even if we have a smaller amount of possible configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The lunch command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A few sections ago, we had a first bite at `lunch` already. If we don't want
    to manually set all those environment variables or we don't want to use
  prefs: []
  type: TYPE_NORMAL
- en: '`buildspec.mk`, we can use `lunch`. We can find it available in the system,
    after we have executed `envsetup.sh`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the command. Open a Terminal and reach your `WORKING_DIRECTORY`.
    Be sure to have launched `envsetup.sh` and then run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/epub_36702041_42.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the output of the command and, as you can easily
    see, it helps us to pick the exact combination on the variable we want. Every
    specific Android version has its own `lunch` command and every lunch command version
    has its output. The preceding screenshot shows the output for tag android-5.1.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have picked the desired configuration, `lunch` will show a summary
    of every variable it''s going to set up and goes back to the Terminal, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_43.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are now ready to fire out the `make` command and build our first Android
    version!
  prefs: []
  type: TYPE_NORMAL
- en: Building the system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have downloaded the source code, initialized the whole environment using
    `envsetup.sh` and configured every system variable with `lunch`. You are now ready
    to build the system. Open a Terminal and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The building system will fire up, looking for all those modules and `Android.mk`
    files to include into the build process and perform the compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to enjoy a more verbose compilation output, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this extra parameter, the build system will print all *GCC* compilation
    logs and all `javac` compilation logs, to give you as much information as possible
    during the building process.
  prefs: []
  type: TYPE_NORMAL
- en: More about make
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `make` command offers a few interesting options that come handy in specific
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Building a module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For instance, if you want to build just one single module, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are building only `art`. The module name is contained in
    the `Android.mk` file of the `module` folder. Just scroll the file and you will
    find a variable `LOCAL_MODULE` that represents the exact module name to use with
    `make`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the module name also using the `mm` command. With a Terminal,
    just reach the module folder and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning a module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we are not satisfied after the module building is completed, we can clean
    all the compilation files and have a fresh start. Open a Terminal, reach the module
    folder, and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning everything
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want to clean the whole project and prepare the system for a new from-scratch
    build, open a Terminal, reach the `WORKING_DIRECTORY`, and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command removes every compilation file from the folder we have specified
    in the `OUT_DIR` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Listing modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command shows the list of every module available in the AOSP architecture.
    The amount of available modules is massive: we will have to wait for a few seconds
    to see any output from this command.'
  prefs: []
  type: TYPE_NORMAL
- en: Recreating an image
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This command recreates the system images, based on the current status of the
    source base, using an incremental building approach, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a crucial command during development. Think about developing a single
    module. When you reach a development milestone, you build the module with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is working, you might like to inject your brand new module into
    your Android system image. You can achieve this with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Building tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following command will create and provide us with two of the most important
    tools for an Android expert—`adb` and `fastboot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We will have plenty of time to learn about them in the next pages.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the system image
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are currently building a system image ready to be flashed to a device. Unfortunately,
    this procedure keeps out a few useful tools that we want to build as well: NDK,
    SDK, and CTS.'
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Google provides the official Android SDK via the Android Developers website.
    It''s already compiled for every platform and ready to be downloaded. In a more
    advanced scenario, you might need to extend the SDK and redistribute it as your
    own. Building a custom SDK is a three command job, with those we already learned
    about in the previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The output of this procedure will be a brand new custom Android SDK in `out/host/linux-x86/sdk/`.
  prefs: []
  type: TYPE_NORMAL
- en: Android NDK
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Android NDK is the native equivalent, based on C/C++, of the Android SDK, based
    on Java. To build the NDK, open a Terminal, reach `WORKING_DIRECTORY`, and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The system will alert you about the possible long duration of the process. Just
    accept the message and prepare some coffee in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Android CTS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'CTS is a well-known tool. We learned everything about it in the previous chapters.
    To build our own version, we need only one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside an AOSP module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The AOSP project is incredibly huge. The amount of modules contained in the
    source base is massive. Android 5 Lollipop contains about 4,000 different modules.
    They go from native modules, written in C/C++, to providing system components:
    daemons, libraries, and Java modules, to provide everything that is needed from
    APKs to JAR files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every module contains an Android.mk file. This file contains every single piece
    of information needed to build the module. The Android build system does not use
    a recursive-make approach, but merges every Android.mk file to create one single
    huge Makefile to build the system: every Android.mk file is a piece of the puzzle.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to Android.mk, the module folder also contains `CleanSpeck.mk`.
    This file helps the system to properly clean every compiled file when we execute
    a module clean command.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into Android.mk
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The quickest path to knowledge is getting your hands dirty. We are going to
    analyze a real Android.mk file from the Android source code to understand structure
    and purpose. In the previous chapter, we learned that the `external/` folder contains
    lots of third-party tools that enrich the Android system. One of these tools is
    `netcat`. Let''s see its Android.mk file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A few cryptic lines that need more detailed study:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This line specifies the `LOCAL_PATH` variable and sets it to the current module
    path. As you can guess, the `$(call my-dir)` function returns the current module
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is part of a collection of useful functions that the system provides
    to be used during the development of new modules. The whole list is contained
    in `build/core/definitions.mk`. Every function comes with code, obviously, and
    a tiny, but effective description of its purpose, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_44.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This line solves one big issue due to the nature of the Android build system—having
    all the Android.mk files merged into one single Makefile creates a dangerous scenario
    in which `LOCAL_` variables from module A could be improperly used by module B.
    The `$(CLEAR_VARS)` function resets all the previously set variables and allows
    the current module to safely access its local variables, using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line specifies the source files contained in the current module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line specifies which argument we are going to pass to the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This line specifies which variant this module belongs to. This is closely related
    to the environment variable `TARGET_BUILD_VARIANT` we learned about in the previous
    sections. Specifying `eng` here will make this module available when we will build
    the `eng` build variant of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This line specifies where to install the compiled executable file when the
    build process succeeds. In this specific case, the final file will be placed in
    the `xbin/` folder of the system image. This variable is optional. The system
    will act based on default values, already specified in the global configuration.
    We can use this variable to specify a *different* destination folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This line has been anticipated a few sections ago. This specifies the module
    name. It has to be unique and it will also be the executable file''s final name.
    In this case, our `netcat` utility will become the `nc` exectutable, as commonly
    seen on `*nix` systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the compiler also, the linker will have its set of specific arguments.
    This line specifies which options the linker will operate according to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This line specifies which type of module we are trying to build. Our current
    module is an executable utility, so we are going to specify `$(BUILD_EXECUTABLE)`
    and the system will properly produce an executable file from all the module source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Android.mk variables ecosystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section, we analyzed a real-world Android.mk. This gave us a
    bit of confidence about creating our own Android module. In this section, we will
    continue our journey with an overview about all the variables we can use in our
    Android.mk.
  prefs: []
  type: TYPE_NORMAL
- en: '`LOCAL_` variables are all those variables necessary to achieve the proper
    module configuration and compilation. These kinds of variables get canceled by
    `$(CLEAN_VARS)` and are by far the most common kind in all Android.mk files.'
  prefs: []
  type: TYPE_NORMAL
- en: The `INTERNAL_`, `HOST_`, and `TARGET_` variables should not be used for custom
    purposes because they are commonly used by the build system itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `BUILD_` variables specify the build type, as we already saw in a previous
    example where we used `BUILD_EXECUTABLE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically speaking, we could use any kind of variable, but that''s a dangerous
    game. It is hard to predict how the build system will manipulate our Android.mk
    files to create its Makefile: order might be not respected, names could be overridden,
    and scopes could be invalidated. To play safely and rely on the build system architecture,
    let''s focus on using only `LOCAL_` variables for our tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no official documentation about these variables. The upcoming list
    is the result of hard work, taking risks, guessing, and scavenging bits of information
    from all around the build system.
  prefs: []
  type: TYPE_NORMAL
- en: The LOCAL_ variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When it comes to `LOCAL_` variables, we can customize our module according
    to this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LOCAL_PATH`: This specifies the path of the module. Usually, the value is
    retrieved using the `$(call my-dir)` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE`: This specifies the name of the module and, if we are dealing
    with an executable module, the name of the executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE_CLASS`: This specifies the class the module belongs to. Based
    on its class, every result of the module building process will be placed in the
    proper folder. The examples of possible classes are `EXECUTABLE`, `ETC`, `SHARED_LIBRARY`,
    `STATIC_LIBRARY`, and `APPS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_SRC_FILES`: This specifies the list of all source files contained in
    the module, separated by whitespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_PACKAGE_NAME`: This specifies the name of the app, for instance: Contacts,
    Phone, Calculator, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_SHARED_LIBRARIES`: This specifies the shared libraries that may be required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE_TAGS`: This specifies a tag, such as `eng`, and the system will
    include this module in every build that will target the `eng` type as `TARGET_BUILD_VARIANT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE_PATH`: This specifies a custom installation path to override
    the one specified in the `BUILD_` template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_CC`: This specifies a different C compiler to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_CXX`: This specifies a different C++ compiler to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_CFLAGS`: This helps to add mode flags to the C compiler command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_CPPFLAGS`: This helps to add mode flags to the C++ compiler command
    line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_CPP_EXTENSION`: This specifies a custom extension for C++ files, if
    for some reason the actual extension is not `.cpp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_C_INCLUDE`: This specifies the path for custom C header files needed
    to build the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_LDFLAGS`: This helps to add mode flags to the linker command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_PREBUILT_EXECUTABLES`: During the creation of a `BUILD_PREBUILD` kind
    of module, this variable will contain every binary executable that will be part
    of the final system image. We are going to learn more about this in the next chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_PREBUILT_LIBS`: During the creation of a `BUILD_PREBUILD` kind of module,
    this variable will contain every library that will be part of the final system
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_PREBUILT_PACKAGE`: During the creation of a `BUILD_PREBUILD` kind of
    module, this variable will contain every prebuild APK that will be part of the
    final system image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BUILD_ variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following list contains the most common `BUILD_` variables available during
    the development of a custom module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUILD_EXECUTABLE`: When necessary to build using native C/C++ code, we can
    add this line to our configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BUILD_PREBUILT`: This allows us to add binary components to our final image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_MULTI_PREBUILT`: This allows us to create modules that inject the final
    image with binarie components of the same category. It''s usually used with `LOCAL_MODULE_CLASS`
    to specify the class and the position to place the binary files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_PACKAGE`: This allows us to create modules that generate APK files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_SHARED_LIBRARY`: This allows us to create modules that generate shared
    library files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_STATIC_LIBRARY`: This allows us to create modules that generate static
    library files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_JAVA_LIBRARY`: This allows us to create modules that generate Java library
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module template examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we are going to analyze real-world module template snippets,
    to have a clear idea about what a fully operational module template looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The native executable template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are going to work on a generic native single-file executable application,
    for example, `your_executable.c`, you can use the following snippet to build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The shared library template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This snippet comes in handy if you are working with a so-called shared library:
    your library would be composed of a set of files, that is, `foo.c` and `bar.c`,
    and would be built accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The application template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you are going to work on a whole application, you could use the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This snippet will build every `.java` file in the specified path and package
    everything as `MyApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During our journey, you learned how to retrieve the source code and how to set
    up the build system. In this section, you are going to learn how to create a new
    target device and add it to the build system. The device we are going to create
    now has specific hardware features. It's a proof-of-concept device, with the only
    purpose of showing you how easily and quickly you can create a brand new device
    and then customize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every device definition is contained in the `device/` folder. First level folders
    contains all the manufacturer''s folders. Every manufacturer folder contains its
    own devices. Let''s create our own manufacturer and device folders: our brand
    is Irarref and our model is an F488\. Open a Terminal, reach the `WORKING_DIRECTORY`
    folder, and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the folder structure in place, we need to create all those files
    that will allow the build system to detect our device and make it available as
    a target for the build system. We are going to create the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Android.mk`: Describes in a generic way how to compile the source files. Essentially,
    it represents a snippet of the global Makefile that will be later incorporated
    by the build system at the appropriate time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndroidProducts.mk`: This file contains a `PRODUCS_MAKEFILEs` variable, with
    a list of all the available products. In our scenario, we only have one device
    and it''s represented by these files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`full_f488.mk`: This file specifies any relevant information about the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BoardConfig.mk`: This file specifies any relevant information about the device
    board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vendorsetup.sh`: This script makes the device available to `envsetup.sh` and
    `lunch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into device configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we know, our first device is quite simple, but very instructive. Let''s
    see how our device specification is spread inside all our configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Android.mk`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AndroidProducts.mk`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`full_f488.mk`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`BoardConfig.mk`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`vendorsetup.sh`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `Android.mk` is pretty standard and completely based on what we have learned
    in the previous sections. `AndroidProducts.mk` just includes `full_f488.mk`, as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: The `full_f488.mk` file contains a few interesting lines. First of all, it includes
    `aosp_base.mk`, a configuration file provided by the system, common to lots of
    real devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we found a few interesting variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEVICE_PACKAGE_OVERLAY:=`: This variable allows us to create a custom overlay,
    customizing, for instance, some settings of specific modules in the AOSP system.
    If you check, for instance, this variable in the equivalent file for the `shamu`
    device, you can notice that they are using it to customize a few settings in the
    launcher application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRODUCT_PACKAGE+=`: This variable allows us to add packages to the compilation
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRODUCT_COPY_FILES+=`: This variable performs a file copy operation. The syntax
    is pretty straight forward: `source_file:dest_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRODUCT_NAME:= full_f488`: This variable specifies the product name. This
    is the exact same value that `lunch` will print as `TARGET_PRODUCT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRODUCT_DEVICE:= f488`: This variable specifies the device name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRODUCT_MODEL:=`: Android for Irarref F488: This variable specifies the device
    model label that we will find in our Android system under **Settings** | **About
    phone** | **Model Number**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all these files in place, you can now relaunch `envsetup.sh` and our brand
    new proof-of-concept device will be in the list of the available devices.
  prefs: []
  type: TYPE_NORMAL
- en: From zero to the screenlock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we have gathered an incredible amount of information about the architecture,
    about how to configure the build system, and our PoC device. It''s time to create
    our first image for a real device and use it! We want to keep away all the possible
    hardware-related issues, so we will target the simplest nonhardware Android device:
    the Android emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to build the latest available Android Lollipop source code. As
    we learned, we are going to download it, configure it to target the emulator,
    build it, and try it on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s set up our `WORKING_DIRECTORY` and download our precious source code.
    Open a Terminal and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After the download is completed, we can configure the environment. Let''s run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create all those handy tools we will need during the work. We now
    have `lunch`, for instance, and running it we can keep on configuring the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s choose a target device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lunch` command will set up everything and show us a configuration report,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_45.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Everything is in place. We need only one command to launch the build procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build process is over, head to `out/target/product/generic/`. This
    folder will contain our built images. The following screenshot shows the result
    of the build process: a folder full of `.img` files, ready to be flashed into
    the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_46.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To launch the emulator, Android provides the `emulator` command. This command
    will be available the moment the compilation ends. Using the `.img` files, we
    have in the `out/` folder, we can run it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few moments, the emulator window will pop up and you will see something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_47.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use the emulator with mouse and keyboard, performing the same operations
    you would do on a real device. Android emulator is a powerful tool and the amount
    of possibilities is almost endless. If you would like to dig into the topic, the
    Android Developers website provides a specific page for it: [http://developer.android.com/tools/help/emulator.html](http://developer.android.com/tools/help/emulator.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter was a great run! You prepared your system to build your first Android
    system. You learned how to configure and customize the build system. You learned
    the basic skills to create a custom module and include it into your system image.
    You created a system image from scratch and tested it on the Android emulator.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will raise the bar. We are going to move our efforts
    to a real hardware device. We will work with a smartphone, the Nexus 5, and a
    development board, the UDOO. We will manipulate the bootloader and the recovery
    partition to take complete control of the system.
  prefs: []
  type: TYPE_NORMAL
