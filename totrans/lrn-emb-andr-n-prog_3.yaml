- en: Chapter 3\. Set up and Build – the Emulator Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章\. 设置和构建 – 模拟器方法
- en: In the previous chapter, we learned how to retrieve the source code and we had
    an overview of the folder's structure. We now know how the branching model works
    and how to contribute to the project. This is an important topic, because Android
    is an open source prot, but it's managed in a very different way compared to other
    popular open source projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何检索源代码，并对文件夹结构有了概述。现在我们知道了分支模型的工作原理以及如何为项目做出贡献。这是一个重要的话题，因为Android是一个开源协议，但它的管理方式与其他流行的开源项目大相径庭。
- en: In this chapter, we will set up the whole environment to get ready to build
    our first Android system and flash it to a real target. Our efforts will be focused
    to create a fully-working version for the official Android emulator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置整个环境，为构建我们的第一个Android系统并将其闪存到实际目标设备做准备。我们的努力将集中在创建一个完全工作的官方Android模拟器版本。
- en: The user will learn how to use tools such as `adb` and `fastboot`, two of the
    most important tools that Google provides.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将学习如何使用`adb`和`fastboot`等工具，这两者都是谷歌提供的最重要的工具之一。
- en: Preparing the host system
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备主机系统
- en: To build a complex system such as Android, we need to satisfy a few hardware
    and software requirements. First of all the host system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建像Android这样的复杂系统，我们需要满足一些硬件和软件要求。首先，是主机系统。
- en: The official Linux distribution supporting the Android build environment is
    `Ubuntu Linux`. Google periodically releases new Android builds for its devices
    and all of them are created using Ubuntu. Currently, Google is using Ubuntu 14.04
    even if this is not the latest version available.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Android构建环境的官方Linux发行版是`Ubuntu Linux`。谷歌定期为其设备发布新的Android构建版本，所有这些版本都是使用Ubuntu创建的。目前，谷歌正在使用Ubuntu
    14.04，尽管这不是最新可用的版本。
- en: Every example in this book will be developed and executed on a common notebook,
    with an Intel i5 CPU and 4 GB of RAM, running Ubuntu Linux 15.05, that's the latest
    available version. Using a different Linux version proves that if all the requirements
    are satisfied, you could build Android with any Linux distribution or even Mac
    OS X— if you can't set up Ubuntu, trying with a different version will be challenging,
    but will be worth trying, as a learning experience.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每个示例都将在一个常见的笔记本电脑上开发和执行，该笔记本电脑配备英特尔i5 CPU和4GB的RAM，运行Ubuntu Linux 15.05，这是最新可用的版本。使用不同的Linux版本可以证明，如果所有要求都得到满足，你可以使用任何Linux发行版甚至Mac
    OS X来构建Android——如果你无法设置Ubuntu，尝试不同的版本将具有挑战性，但作为一个学习经验，值得一试。
- en: If you are a Microsoft Windows user, it is sad to say, you won't be able to
    build Android using the native operative system. A possible solution is using
    a virtual machine running Ubuntu, for instance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名Microsoft Windows用户，遗憾的是，你将无法使用原生操作系统构建Android。一个可能的解决方案是使用运行Ubuntu的虚拟机，例如。
- en: Hardware requirements
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件要求
- en: 'Digging into hardware requirements, you will just need a recent personal computer.
    As anticipated in the previous section, we are going to use a middle-end notebook
    for our examples. It''s a Lenovo x220, with Intel i5 CPU and 4GB of RAM: it''s
    enough to do the job and it''s affordable, but the build time won''t be small.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解硬件要求，你只需要一台最新的个人电脑。正如前文所预期的那样，我们将使用一款中端笔记本电脑作为我们的示例。它是一款联想x220，配备英特尔i5 CPU和4GB的RAM：这足以完成工作，而且价格合理，但构建时间不会太短。
- en: To speed up the build time, using a high-end PC is advisable. A faster CPU,
    with more cores, and more RAM will take advantage of multithreading and parallel
    building and will significantly reduce the build time, allowing you to experiment
    more during the journey.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快构建时间，使用高端PC是可取的。更快的CPU、更多核心和更多RAM将利用多线程和并行构建，并将显著减少构建时间，让你在旅程中能够进行更多实验。
- en: A critical point of the environment setup is the necessary hard disk free space.
    The required amount is considerable—the source code alone needs approximately
    100 GB to be stored. The whole build process will require approximately 150GB.
    If we are trying to build as fast as possible, probably we will enable the building
    system caching option, `ccache`. The caching system will require even more free
    space.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 环境设置的一个关键点是必要的硬盘空闲空间。所需的空间相当大——仅源代码就需要大约100GB的存储空间。整个构建过程将需要大约150GB。如果我们试图尽可能快地构建，可能我们会启用构建系统缓存选项`ccache`。缓存系统将需要更多的空闲空间。
- en: 'The following table will give you a rough estimation about minimum and recommended
    hardware:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将为您提供关于最低和推荐硬件的粗略估计：
- en: '![](img/epub_36702041_34.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_34.jpeg)'
- en: Software requirements
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件要求
- en: In this book, we are going to build the system using Ubuntu Linux 15.04\. If
    you cannot obtain this version, you can successfully use an older version, like
    the guys at Google, a totally different distribution or even a Virtual Machine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 Ubuntu Linux 15.04 构建系统。如果您无法获得这个版本，您可以使用较旧版本，例如谷歌的团队，一个完全不同的发行版，甚至是一个虚拟机。
- en: 'One of the basic requirements, when it comes to the operating system, is the
    architecture: if we are planning to build Android 2.3 or greater, we will need
    a 64-bit system. Older versions of Android will do fine with a 32-bit system,
    but that''s an improbable scenario.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到操作系统时，一个基本的要求是架构：如果我们计划构建 Android 2.3 或更高版本，我们需要一个 64 位系统。较旧的 Android 版本可以使用
    32 位系统，但这不太可能。
- en: Installing Java JDK
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 Java JDK
- en: 'Oracle''s *Java Development Kit* is a crucial requirement, essential to be
    able to build Android. Every Android version needs a specific JDK version. According
    to what version we want to build, we are going to install:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 的 *Java 开发工具包* 是构建 Android 的关键要求，是必不可少的。每个 Android 版本都需要特定的 JDK 版本。根据我们想要构建的版本，我们将安装：
- en: JDK 5 for Cupcake to Froyo
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cupcake 到 Froyo 的 JDK 5
- en: JDK 6 for Gingerbread to KitKat
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gingerbread 到 KitKat 的 JDK 6
- en: JDK 7 for KitKat, Lollipop, and Marshmallow
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KitKat、Lollipop 和 Marshmallow 的 JDK 7
- en: 'We are going to build Android Lollipop 5.1.1 and we are going to need at least
    JDK 7\. Installing JDK on Ubuntu is quite straightforward. Let''s start by opening
    a Terminal and firing the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建 Android Lollipop 5.1.1，并且我们需要至少 JDK 7。在 Ubuntu 上安装 JDK 非常简单。让我们先打开一个终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `apt-get` command will resolve all the dependencies, download all the required
    packages and install them. If you are a *Mouse and icons* user, you can achieve
    the same goal using **Ubuntu Software Center**, as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`apt-get` 命令将解决所有依赖，下载所有必需的软件包并安装它们。如果您是 *鼠标和图标* 用户，您可以使用 **Ubuntu 软件中心** 实现相同的目标，如下面的截图所示：'
- en: '![](img/epub_36702041_35.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_35.jpeg)'
- en: 'If you are a Java developer or you plan to build different Android versions
    for specific reasons, Ice Cream Sandwich and Lollipop, for instance, you could
    end up having more than just one version of the Java Development Kit. This multipurpose
    scenario brings a few more steps of configuration. We need to specify which JDK
    version will be used as the default one in the system. Using our trusted Terminal,
    let''s run these commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Java 开发者或者出于特定原因计划构建不同的 Android 版本，比如冰淇淋三明治和棒棒糖，您可能会拥有不止一个版本的 Java 开发工具包。这种多用途场景需要更多的配置步骤。我们需要指定哪个
    JDK 版本将作为系统中的默认版本。使用我们信任的终端，让我们运行以下命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following screenshot shows the output. As you can see, it lists all the
    available JDK versions and lets you pick the one to set as default. In our scenario,
    we are using JDK 7 because we are planning to build Android 5 or greater.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出。如您所见，它列出了所有可用的 JDK 版本，并允许您选择一个设置为默认版本。在我们的场景中，我们使用 JDK 7，因为我们计划构建
    Android 5 或更高版本。
- en: '![](img/epub_36702041_36.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_36.jpeg)'
- en: Installing system dependencies
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装系统依赖
- en: 'Even if Java is a key player in the Android world, we also need a few *low-level*
    tools to satisfy all the Android build system requirements. Some of them are common
    tools and there is a chance that they are already installed, but our goal is to
    set up a whole system from scratch: we can''t risk missing a dependency.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Java 在 Android 世界中是关键玩家，我们还需要一些 *低级* 工具来满足所有 Android 构建系统要求。其中一些是通用工具，它们可能已经安装，但我们的目标是从头开始设置整个系统：我们不能冒险遗漏一个依赖项。
- en: 'Using your Terminal, run the following `apt-get` command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的终端，运行以下 `apt-get` 命令：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As usual, `apt-get` will resolve all the dependencies and install all the required
    packages. The following screenshot shows the output of the command in the scenario
    in which you already have all the required packages, lucky you:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，`apt-get` 将解决所有依赖并安装所有必需的软件包。以下截图显示了在您已经拥有所有必需软件包的情况下的命令输出，真幸运：
- en: '![](img/epub_36702041_37.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_37.jpeg)'
- en: At this point, your Ubuntu contains all the required packages and applications
    to build the world's most popular mobile operating system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的 Ubuntu 已经包含了构建世界上最受欢迎的移动操作系统所需的所有软件包和应用程序。
- en: Setting up a Mac OS X environment
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Mac OS X 环境
- en: One of the most important requirements to build Android is a case-sensitive
    filesystem. If you are planning to build Android using OS X, the most practical
    way to satisfy this requirement is to create a partition or a disk image containing
    a case-sensitive filesystem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Android最重要的要求之一是大小写敏感的文件系统。如果你计划使用OS X构建Android，满足这一要求的最实际方法是创建一个包含大小写敏感文件系统的分区或磁盘镜像。
- en: Creating a case-sensitive disk image
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建大小写敏感的磁盘镜像
- en: 'OS X provides a handy graphical utility to create a new disk image. Fire up
    `Spotlight` and launch `Disk Utility`. The upper toolbar contains a **New Image**
    button that takes you to the disk image creation screen, as shown in the following
    screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OS X提供了一个方便的图形工具来创建新的磁盘镜像。打开`Spotlight`并启动`Disk Utility`。上面的工具栏中有一个**新建镜像**按钮，它会带你到磁盘镜像创建屏幕，如下面的截图所示：
- en: '![](img/epub_36702041_38.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_38.jpeg)'
- en: 'As you can see from the preceding screenshot, the crucial setting is the **Format**:
    it has to be `Case-sensitive, Journaled`. For the **Size** setting, the larger
    the better, keeping in mind that an Android build could use hundreds of gigabytes
    in no time. As minimal size, we suggest at least 50 GB.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，关键设置是**格式**：它必须是`Case-sensitive, Journaled`。对于**大小**设置，越大越好，考虑到Android构建可能很快就会使用数百GB。我们建议的最小大小至少为50
    GB。
- en: 'If you are more a *command line* type, it''s possible to create this disk image
    using the Terminal and `hdiutil`, as shown in the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于使用**命令行**，可以使用Terminal和`hdiutil`创建这个磁盘镜像，如下面的命令所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the disk image creation succeeded, we now have a `.dmg` or `.dmg.sparsefile`
    file on our disk. Once we have mounted it, we can use it as a normal hark disk—downloading
    Android source code and proceeding with the building procedure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果磁盘镜像创建成功，我们现在磁盘上有一个`.dmg`或`.dmg.sparsefile`文件。一旦我们挂载它，我们就可以像正常硬盘一样使用它——下载Android源代码并继续构建过程。
- en: 'The two following commands will give you the ability to mount and unmount the
    disk image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个命令将给你提供挂载和卸载磁盘镜像的能力：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you run out of space, the following command will give you the opportunity
    to resize the disk image and allow you to continue working on your desired Android
    build:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用完了空间，以下命令将给你机会调整磁盘镜像的大小，并允许你继续你的Android构建工作：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Installing the required software
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装所需的软件
- en: Once we have our installation disk image, the same as for Linux, we need to
    install all those software requirements we need to properly build the system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了安装磁盘镜像，就像Linux一样，我们需要安装所有那些我们需要正确构建系统的软件要求。
- en: 'Installing the Java Development Kit is very straightforward: just download
    the proper `.dmg` file from [http://www.oracle.com](http://www.oracle.com) and
    install it. The same rules about Android target version and required Java version
    apply here too.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Java开发工具包非常简单：只需从[http://www.oracle.com](http://www.oracle.com)下载适当的`.dmg`文件并安装它。关于Android目标版本和所需Java版本的规定在这里同样适用。
- en: 'Further, we will need:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要：
- en: '**Xcod**e: The installation is well documented at [https://developer.apple.com](https://developer.apple.com)
    as Xcode is the main player of iOS development.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xcode**：Xcode的安装有很好的文档记录，可以在[https://developer.apple.com](https://developer.apple.com)找到，因为Xcode是iOS开发的主要参与者。'
- en: '**MacPorts**: It''s an open source project that will help us to install lots
    of useful tools. You can install it following the installation info at [http://www.macports.org/install.php](http://www.macports.org/install.php).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MacPorts**：这是一个开源项目，将帮助我们安装许多有用的工具。你可以按照[http://www.macports.org/install.php](http://www.macports.org/install.php)上的安装信息进行安装。'
- en: 'Once we have these two main pieces of the puzzle in place, we need to install
    `make`, `git`, `bison`, and `GPG` packages, using MacPorts, with the following
    command on your Terminal:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两个主要拼图，我们需要使用MacPorts安装`make`、`git`、`bison`和`GPG`软件包，在你的Terminal上使用以下命令：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Last but not least, we need to increase the maximum number of possible file
    descriptors. OS X comes with a tiny value—the average user does not need all those
    file descriptors, but we are going to need a bigger amount due to the hundreds
    of files involved in the Android build procedure. To increase this value, we will
    need to launch our Terminal and run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要增加可能的最大文件描述符数。OS X自带一个非常小的值——普通用户不需要所有这些文件描述符，但鉴于Android构建过程中涉及数百个文件，我们将需要更多的数量。为了增加这个值，我们需要启动我们的Terminal并运行以下命令：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, the limit is up to 1,024 files. We can make this value persistent by adding
    this to the `~/.bash_profile` file, in your `home` folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，限制已提升至1,024个文件。我们可以通过将以下内容添加到`~/.bash_profile`文件中，在您的`home`文件夹中，使这个值保持持久。
- en: The Android build system
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android构建系统
- en: Before digging into configuring and building your first Android system, we will
    have an overview of the build system itself, the tools involved, and the unique
    approach to the whole process Google has.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入配置和构建您的第一个Android系统之前，我们将概述构建系统本身、涉及的工具以及谷歌对整个过程的独特方法。
- en: There is very little official documentation available about creating new modules
    and about the build system itself. Most of your knowledge at the end of this journey
    will come from your own hands-on experience and from our experience that we put
    in these pages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建新模块以及构建系统本身的官方文档非常少。您在这个旅程结束时的大部分知识将来自您自己的动手经验以及我们放入这些页面中的经验。
- en: An overview
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: As with lots of projects out there, open source or closed source, Android uses
    the powerful tool `make` to build the whole system, but compared to all other
    projects, Android uses it in a completely different way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多其他项目一样，开源或闭源，Android使用强大的工具`make`来构建整个系统，但与其他所有项目相比，Android使用它的方式完全不同。
- en: 'The common approach of using `make` would be to use a hierarchy of Makefiles:
    one single root Makefile retrieves and runs every other Makefile, contained in
    some of the subfolders of the project. Usually, every subfolder represents a submodule
    of the main project and it can be built alone or could depend upon other modules.
    Unlike other projects, Android has no `menuconfig` or any other graphical configuration
    utility to customize the build system, enable or disable modules. Every sort of
    build configuration is done using environment variables that we will show in the
    next sections.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make`的常见方法将是使用Makefile的层次结构：一个单一的根Makefile检索并运行包含在项目某些子文件夹中的其他所有Makefile。通常，每个子文件夹代表主项目的一个子模块，它可以独立构建或依赖于其他模块。与其他项目不同，Android没有`menuconfig`或其他任何图形配置实用程序来定制构建系统、启用或禁用模块。所有类型的构建配置都是通过环境变量完成的，我们将在下一节中展示。
- en: Moreover, the whole module building is unconventional. Taking the Linux kernel
    as an example, usually, when a module is built, in the same folder with the source
    code, we have the compiled files. Module after module, the build system compiles
    everything and, at the very end, it retrieves the required files, links them together,
    and generates the final output. Android works in a different way. As you will
    notice approaching the build completion, Android tries to keep every module folder
    as clean as possible—every compiled file ends up in the `/out` folder, so that
    it's easier to clean everything, just delete this folder and have everything perfectly
    in order in a blink of an eye.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，整个模块构建是非传统的。以Linux内核为例，通常，当构建一个模块时，在源代码相同的文件夹中，我们会得到编译文件。模块一个接一个，构建系统编译一切，最后，它检索所需的文件，将它们链接在一起，并生成最终输出。Android以不同的方式工作。正如您在接近构建完成时会注意到的那样，Android试图尽可能保持每个模块文件夹的清洁——每个编译文件最终都会进入`/out`文件夹，这样就可以更容易地清理一切，只需删除这个文件夹，一切就可以在一瞬间变得井然有序。
- en: As you could guess at this point, the build system is completely custom made
    by Google. Everything has been designed and developed from scratch, using existent
    tools, but approaching the problem in an unusual way. Android developers created
    a single huge Makefile, containing all the needed information to build every single
    module and to assemble the final system image.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜的那样，构建系统完全是谷歌定制的。所有东西都是从零开始设计和开发的，使用现有工具，但以不寻常的方式处理问题。Android开发者创建了一个巨大的Makefile，其中包含构建每个模块和组装最终系统映像所需的所有信息。
- en: 'The whole build system is contained in the `build/` folder. This folder contains:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 整个构建系统都包含在`build/`文件夹中。这个文件夹包含：
- en: Utility shell scripts
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具shell脚本
- en: Utility Python scripts
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具Python脚本
- en: A set of .`mk` files containing all the necessary information to create all
    the system modules
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组包含创建所有系统模块所需信息的`.mk`文件
- en: Every single module has its own folder. This folder contains the most important
    file to build the module `Android.mk`. This file contains all the information
    needed to perform a smooth compilation of the module source code and generate
    a binary file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有自己的文件夹。这个文件夹包含构建模块最重要的文件`Android.mk`。这个文件包含了构建模块源代码和生成二进制文件所需的所有信息。
- en: Module `Android.mk` files are the first step of the building procedure—the build
    system scans every folder looking for these files and includes them into the single
    huge Makefile that it will use for further steps.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 模块“`Android.mk`”文件是构建过程的第一步——构建系统会扫描每个文件夹以查找这些文件，并将它们包含到它将用于后续步骤的单个巨大的Makefile中。
- en: 'The source code root folder contains a Makefile with the following content:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码根目录包含一个包含以下内容的Makefile：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The file looks pretty empty, but it contains the most important `.mk` file of
    all—`main.mk`. This file, located in `build/core`, contains a sequence of checks
    and all the needed operations to retrieve all the `Android.mk` files to build
    all the modules.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件看起来很空，但它包含了所有最重要的“.mk”文件——“`main.mk`”。这个文件位于“`build/core`”，包含了一系列检查和所有必要的操作，以检索构建所有模块所需的全部“`Android.mk`”文件。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Without special configuration, the Android build system only creates the Android
    system image. To generate CTS, NDK, and SDK, we will need a bit more setup effort
    as we will see later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特殊的配置，Android构建系统只创建Android系统镜像。要生成CTS、NDK和SDK，我们需要更多的设置工作，正如我们稍后将会看到的。
- en: Bootstrap
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导
- en: 'The whole build system is fired up, thanks to a single shell script—`build/envsetup.sh`.
    As you can see in the following screenshot, this script is in charge of preparing
    the building environment. It sets up a few configurations and provides useful
    tools that make our work much easier: it''s the Swiss Army knife of the Android
    build system.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 整个构建系统都是通过一个单一的shell脚本——“`build/envsetup.sh`”来启动的。正如您在下面的屏幕截图中所看到的，这个脚本负责准备构建环境。它设置了一些配置并提供了一些有用的工具，使我们的工作变得更加容易：它是Android构建系统的瑞士军刀。
- en: 'Fire up your Terminal and run the script as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的终端并按照以下方式运行脚本：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![](img/epub_36702041_39.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_39.jpeg)'
- en: 'The previous screenshot shows the output of `envsetup.sh`, that brings the
    system to be fully operational and ready to build. To have a list of all the commands
    that we now have available, on your Terminal, run:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的屏幕截图显示了“`envsetup.sh`”的输出，它使系统完全运行并准备好构建。要获取我们现在可用的所有命令列表，请在您的终端中运行：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/epub_36702041_40.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_40.jpeg)'
- en: 'The previous screenshot shows the output of the `hmm` command. We will have
    a look at lots of them later, but as a yummy anticipation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的屏幕截图显示了“`hmm`”命令的输出。我们稍后会看到很多这样的命令，但作为一个美味的期待：
- en: '`lunch`: This command helps you configure everything we need for a specific
    target with one single command'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`lunch`”：这个命令可以帮助您通过一个命令配置针对特定目标所需的所有内容
- en: '`mm`: This command lets you compile just the module contained in your current
    folder'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`mm`”：这个命令允许您仅编译当前文件夹中包含的模块
- en: Setup
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: 'A proper configuration environment is one of the most important things for
    a build system. Every build system provides a clear way to specify, for instance,
    which module to build of which platform we are targeting. Having the Linux kernel
    as a great example, we can say that it provides a handy graphical menu to perform
    all the necessary configurations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 合适的配置环境是构建系统最重要的因素之一。每个构建系统都提供了一种明确的方式来指定，例如，我们要构建哪个平台上的哪个模块。以Linux内核为例，它提供了一个方便的图形菜单来执行所有必要的配置：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Menuconfig lets you enable or disable modules to be built, select the desired
    platform, and tons of other different possible configurations. Every single configuration
    bit is saved in a `.config` file that can be easily read or edited and reused
    for the build procedure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Menuconfig允许您启用或禁用要构建的模块，选择所需的平台，以及许多其他可能的配置。每个单独的配置位都保存在一个“.config”文件中，可以轻松读取或编辑，并用于构建过程。
- en: As we anticipated, Android is based on something completely different. There
    is no graphical interface to perform the configuration. The only sort of interactive
    or automatic configuration system is `envsetup.sh`, which we already learned about.
    So why does Android not have any cool tools to configure the build system? Simply,
    because it does not need one! We are not supposed to disable all the modules we
    don't want to build, so Android just does not provide an easy way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，Android基于完全不同的东西。没有图形界面来执行配置。唯一的交互式或自动配置系统是“`envsetup.sh`”，我们之前已经学过了。那么为什么Android没有提供任何酷炫的工具来配置构建系统呢？简单地说，因为它不需要！我们不应该禁用我们不希望构建的所有模块，所以Android并没有提供一种简单的方法。
- en: Let's say that we are building Android for a new device we have just created
    and it does not have a camera on-board. We might want to remove that part of the
    system that manages the camera. There is no official way to do it. If we want
    to do it, we need to get our hands dirty and with time and pages we will be able
    to do it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为刚刚创建的新设备构建Android，而这个设备没有内置摄像头。我们可能想要移除管理摄像头的系统部分。没有官方的方法来做这件事。如果我们想这么做，我们需要亲自动手，随着时间的推移和页面的积累，我们将能够做到这一点。
- en: We can safely say that the whole Android build system configuration can be stripped
    down to setting a few environment variables. The build system will use these variables
    to figure out which device we are targeting or which toolchain it is supposed
    to use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地说，整个Android构建系统配置可以简化为设置几个环境变量。构建系统将使用这些变量来确定我们针对哪个设备，或者它应该使用哪个工具链。
- en: 'The most important variables are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的变量是：
- en: TARGET_PRODUCT
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TARGET_PRODUCT
- en: TARGET_BUILD_VARIANT
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TARGET_BUILD_VARIANT
- en: TARGET_BUILD_TYPE
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TARGET_BUILD_TYPE
- en: TARGET_TOOLS_PREFIX
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TARGET_TOOLS_PREFIX
- en: TARGET_PREBUILT_KERNEL
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TARGET_PREBUILT_KERNEL
- en: OUT_DIR
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OUT_DIR
- en: In the upcoming sections, we are going to learn all about these variables we
    can manipulate to perfect our build.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习所有可以操纵以完善构建的变量。
- en: The TARGET_PRODUCT variable
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TARGET_PRODUCT变量
- en: This variable contains the information to specify the device we are preparing
    the system for. We are currently targeting the official emulator, so we are going
    to set the variable as `aosp_arm`. If we want to build the system for Google's
    Nexus 6, we will set the variable to `aosp_shamu`, or to `aosp_hummerhead` for
    Google's Nexus 5.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量包含指定我们为哪个设备准备系统的信息。我们目前的目标是官方模拟器，所以我们将设置这个变量为`aosp_arm`。如果我们想为Google的Nexus
    6构建系统，我们将设置变量为`aosp_shamu`，或者为Google的Nexus 5设置变量为`aosp_hummerhead`。
- en: 'For quick access to all the values, specific for all the supported devices,
    we have provided a handy table as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速访问所有针对所有支持设备的特定值，我们提供了一个方便的表格，如下所示：
- en: '![](img/epub_36702041_41.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_41.jpeg)'
- en: 'As you can imagine, every device supports a specific version of the system.
    For instance, with our current downloaded source base, tag android-5.1.1:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，每个设备都支持特定版本的系统。例如，使用我们当前下载的源代码库，标记android-5.1.1：
- en: aosp_arm
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_arm
- en: aosp_arm64
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_arm64
- en: aosp_mips
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_mips
- en: aosp_mips64
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_mips64
- en: aosp_x86
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_x86
- en: aosp_x86_64
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_x86_64
- en: aosp_manta
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_manta
- en: aosp_flounder
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_flounder
- en: mini_emulator_x86_64
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mini_emulator_x86_64
- en: mini_emulator_mips
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mini_emulator_mips
- en: mini_emulator_x86
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mini_emulator_x86
- en: mini_emulator_arm64
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mini_emulator_arm64
- en: m_e_arm
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: m_e_arm
- en: aosp_mako
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_mako
- en: aosp_hammerhead
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_hammerhead
- en: aosp_shamu
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_shamu
- en: full_fugu
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: full_fugu
- en: aosp_fugu
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_fugu
- en: aosp_deb
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_deb
- en: aosp_tilapia
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_tilapia
- en: aosp_flo
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_flo
- en: aosp_grouper
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: aosp_grouper
- en: 'Once we have decided on the target device, fire up a Terminal and run:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了目标设备，打开终端并运行：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The TARGET_BUILD_VARIANT variable
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TARGET_BUILD_VARIANT变量
- en: 'Every `Android.mk` file refers to this variable to enable and disable the sections
    of its codebase to be compiled or not. This variable has three possible values
    and it specifies the build variant. We can set it to:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Android.mk`文件都引用这个变量来启用或禁用其代码库的编译部分。这个变量有三个可能的值，它指定了构建变体。我们可以将其设置为：
- en: '`eng`: Here, every module tagged with user, debug, and `eng` is enabled'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eng`: 在这里，每个标记为用户、调试和`eng`的模块都被启用'
- en: '`userdebug`: Here, every module tagged with the user and debug is enabled'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userdebug`: 在这里，每个标记为用户和调试的模块都被启用'
- en: '`user`: Here, every module tagged with the user is enabled'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`: 在这里，每个标记为用户的模块都被启用'
- en: 'We can use the variable as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用变量如下：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The TARGET_BUILD_TYPE variable
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TARGET_BUILD_TYPE变量
- en: This variable specifies which type of build we are going to perform for every
    module. If we are going to create a development system, we are going to need more
    logging information, for instance. For this scenario, we are going to set this
    variable as `debug`, build, and test our system. After this phase, we will rebuild
    the system with this variable set to `release`, to disable the verbose logging
    and all the development perks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量指定了我们将为每个模块执行哪种类型的构建。如果我们打算创建一个开发系统，我们可能需要更多的日志信息，例如。对于这种情况，我们将设置这个变量为`debug`，构建并测试我们的系统。在这个阶段之后，我们将使用这个变量设置为`release`来重建系统，以禁用冗长的日志记录和所有开发特性。
- en: The TARGET_TOOLS_PREFIX variable
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TARGET_TOOLS_PREFIX变量
- en: This variable specifies the path for a custom toolchain to be used during the
    build process. Usually, it stays empty, but, gaining experience, you should try
    different toolchains, freely available on the Internet. One of the most famous
    and optimized custom toolchains is developed and distributed by the `Linaro` team.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量指定了在构建过程中使用自定义工具链的路径。通常，它保持为空，但随着经验的积累，你应该尝试不同的工具链，这些工具链在互联网上免费提供。最著名且经过优化的自定义工具链之一是由`Linaro`团队开发和分发的。
- en: The OUT_DIR variable
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`OUT_DIR`变量'
- en: If for some specific reason we want to override the default path of the `out/`
    folder, we can use this variable to specify a custom path. This variable is extremely
    useful in all the scenarios that have multiple hard drives or network shares.
    For instance, we could run the build process on a fast SSD disk and store the
    output on a standard old-fashioned disk or even a network disk, to share it with
    our teammates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某些特定原因我们想要覆盖`out/`文件夹的默认路径，我们可以使用这个变量来指定一个自定义路径。这个变量在所有有多个硬盘或网络共享的场景中都非常有用。例如，我们可以在快速的SSD磁盘上运行构建过程，并将输出存储在标准的旧式磁盘上，甚至是一个网络磁盘，以便与我们的队友共享。
- en: The TARGET_PREBUILT_KERNEL variable
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`TARGET_PREBUILT_KERNEL`变量'
- en: This is a quite advanced variable. It allows us to provide the system with a
    kernel different from the default one. Every target device comes with a precompiled
    default kernel because the Android build system is not going to build it—it's
    already there.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当高级的变量。它允许我们向系统提供一个与默认不同的内核。每个目标设备都附带一个预编译的默认内核，因为Android构建系统不会构建它——它已经存在了。
- en: 'Injecting a custom kernel is a very interesting topic that opens lots of interesting
    scenarios. In Chapter 5, *Customizing Kernel and Boot Sequence*, we are going
    to build a custom kernel and inject it into our Android system, to create a fully
    customized Android experience: this variable will be one of the most important
    pieces of the puzzle.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注入自定义内核是一个非常有趣的话题，它打开了众多有趣的场景。在第5章“自定义内核和引导序列”中，我们将构建一个自定义内核并将其注入到我们的Android系统中，以创建一个完全定制的Android体验：这个变量将是拼图中最重要的部分之一。
- en: The buildspec.mk file
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`buildspec.mk`文件'
- en: If we want to persist these variables, we can add them to a `buildspec.mk` file.
    Every time we will run `make`, the system will check this file, evaluate all the
    variables, and move forward accordingly. The `buildspec.mk` file comes in a handy
    template version in the `build/` folder as `buildspec.mk.default`. This template
    file contains every available variable. Every variable is commented, disabled
    by default, and comes with a small note about its purpose and how to use it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要持久化这些变量，我们可以将它们添加到`buildspec.mk`文件中。每次我们运行`make`时，系统都会检查这个文件，评估所有变量，然后相应地继续。`buildspec.mk`文件在`build/`文件夹中以`buildspec.mk.default`为名的方便模板版本提供。这个模板文件包含所有可用的变量。每个变量都有注释，默认禁用，并附带关于其用途和如何使用的简要说明。
- en: We could consider this file the equivalent of the Linux kernel `.config` file,
    even if we have a smaller amount of possible configurations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个文件视为Linux内核`.config`文件的等价物，即使我们可能有更少的配置选项。
- en: The lunch command
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`lunch`命令'
- en: A few sections ago, we had a first bite at `lunch` already. If we don't want
    to manually set all those environment variables or we don't want to use
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几个部分中，我们已经对`lunch`有了一个初步的了解。如果我们不想手动设置所有这些环境变量，或者我们不想使用
- en: '`buildspec.mk`, we can use `lunch`. We can find it available in the system,
    after we have executed `envsetup.sh`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`buildspec.mk`，我们可以使用`lunch`。在我们执行了`envsetup.sh`之后，我们可以在系统中找到它。
- en: 'Let''s have a look at the command. Open a Terminal and reach your `WORKING_DIRECTORY`.
    Be sure to have launched `envsetup.sh` and then run:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个命令。打开一个终端并进入你的`WORKING_DIRECTORY`。确保你已经启动了`envsetup.sh`，然后运行：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/epub_36702041_42.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_42.jpeg)'
- en: The preceding screenshot shows the output of the command and, as you can easily
    see, it helps us to pick the exact combination on the variable we want. Every
    specific Android version has its own `lunch` command and every lunch command version
    has its output. The preceding screenshot shows the output for tag android-5.1.1.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了命令的输出，正如你很容易看到的，它帮助我们选择我们想要的变量的确切组合。每个特定的Android版本都有自己的`lunch`命令，每个`lunch`命令版本都有自己的输出。前面的截图显示了android-5.1.1标签的输出。
- en: 'Once you have picked the desired configuration, `lunch` will show a summary
    of every variable it''s going to set up and goes back to the Terminal, as shown
    in the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了所需的配置，`lunch`将显示它将要设置的每个变量的摘要，然后返回终端，如下面的截图所示：
- en: '![](img/epub_36702041_43.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_43.jpeg)'
- en: We are now ready to fire out the `make` command and build our first Android
    version!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行`make`命令并构建我们的第一个Android版本了！
- en: Building the system
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建系统
- en: 'You have downloaded the source code, initialized the whole environment using
    `envsetup.sh` and configured every system variable with `lunch`. You are now ready
    to build the system. Open a Terminal and run:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经下载了源代码，使用`envsetup.sh`初始化了整个环境，并使用`lunch`配置了每个系统变量。你现在可以构建系统了。打开一个终端并运行：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The building system will fire up, looking for all those modules and `Android.mk`
    files to include into the build process and perform the compilation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统将启动，寻找所有那些模块和`Android.mk`文件以包含在构建过程中并执行编译。
- en: 'If you want to enjoy a more verbose compilation output, you can run:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要享受更详细的编译输出，你可以运行：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this extra parameter, the build system will print all *GCC* compilation
    logs and all `javac` compilation logs, to give you as much information as possible
    during the building process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个额外参数，构建系统将打印所有*GCC*编译日志和所有`javac`编译日志，以便在构建过程中尽可能提供更多信息。
- en: More about make
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多关于make的信息
- en: The `make` command offers a few interesting options that come handy in specific
    scenarios.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`命令提供了一些在特定场景下很有用的有趣选项。'
- en: Building a module
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建模块
- en: 'For instance, if you want to build just one single module, you can run:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想只构建一个单独的模块，你可以运行：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we are building only `art`. The module name is contained in
    the `Android.mk` file of the `module` folder. Just scroll the file and you will
    find a variable `LOCAL_MODULE` that represents the exact module name to use with
    `make`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只构建`art`。模块名称包含在`module`文件夹中的`Android.mk`文件中。只需滚动文件，你就会找到一个表示要使用`make`的精确模块名称的变量`LOCAL_MODULE`。
- en: 'We can retrieve the module name also using the `mm` command. With a Terminal,
    just reach the module folder and run:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`mm`命令检索模块名称。在终端中，只需到达模块文件夹并运行：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Cleaning a module
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理模块
- en: 'If we are not satisfied after the module building is completed, we can clean
    all the compilation files and have a fresh start. Open a Terminal, reach the module
    folder, and run:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块构建完成后我们还不满意，我们可以清理所有编译文件并从头开始。打开一个终端，到达模块文件夹，并运行：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Cleaning everything
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理所有内容
- en: 'If you want to clean the whole project and prepare the system for a new from-scratch
    build, open a Terminal, reach the `WORKING_DIRECTORY`, and run:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要清理整个项目并为从头开始的新构建准备系统，打开一个终端，到达`WORKING_DIRECTORY`，并运行：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command removes every compilation file from the folder we have specified
    in the `OUT_DIR` variable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从我们在`OUT_DIR`变量中指定的文件夹中删除所有编译文件。
- en: Listing modules
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列出模块
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command shows the list of every module available in the AOSP architecture.
    The amount of available modules is massive: we will have to wait for a few seconds
    to see any output from this command.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示AOSP架构中每个模块的列表。可用的模块数量庞大：我们可能需要等待几秒钟才能看到此命令的任何输出。
- en: Recreating an image
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新创建镜像
- en: 'This command recreates the system images, based on the current status of the
    source base, using an incremental building approach, as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令根据当前源代码库的状态，使用增量构建方法重新创建系统镜像，如下所示：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a crucial command during development. Think about developing a single
    module. When you reach a development milestone, you build the module with:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开发过程中的关键命令。想想只开发一个模块。当你达到一个开发里程碑时，你可以使用以下命令构建模块：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If everything is working, you might like to inject your brand new module into
    your Android system image. You can achieve this with:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你可能想将你的全新模块注入到Android系统镜像中。你可以通过以下方式实现：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Building tools
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建工具
- en: 'The following command will create and provide us with two of the most important
    tools for an Android expert—`adb` and `fastboot`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将创建并提供给我们两个对Android专家来说最重要的工具——`adb`和`fastboot`：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will have plenty of time to learn about them in the next pages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一页有足够的时间了解它们。
- en: Beyond the system image
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超越系统镜像
- en: 'We are currently building a system image ready to be flashed to a device. Unfortunately,
    this procedure keeps out a few useful tools that we want to build as well: NDK,
    SDK, and CTS.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前正在构建一个准备闪存到设备上的系统镜像。不幸的是，这个程序排除了我们想要构建的一些有用工具：NDK、SDK和CTS。
- en: Android SDK
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Android SDK
- en: 'Google provides the official Android SDK via the Android Developers website.
    It''s already compiled for every platform and ready to be downloaded. In a more
    advanced scenario, you might need to extend the SDK and redistribute it as your
    own. Building a custom SDK is a three command job, with those we already learned
    about in the previous sections:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Google通过Android开发者网站提供官方的Android SDK。它已经为每个平台编译好，可供下载。在更高级的场景中，你可能需要扩展SDK并将其重新分发为你的版本。构建自定义SDK是一个三步命令的工作，这些命令我们在前面的章节中已经学过：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The output of this procedure will be a brand new custom Android SDK in `out/host/linux-x86/sdk/`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的输出将是一个全新的自定义Android SDK，位于`out/host/linux-x86/sdk/`。
- en: Android NDK
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Android NDK
- en: 'Android NDK is the native equivalent, based on C/C++, of the Android SDK, based
    on Java. To build the NDK, open a Terminal, reach `WORKING_DIRECTORY`, and run:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK是基于C/C++的本地等效物，基于Java的Android SDK。要构建NDK，打开终端，到达`WORKING_DIRECTORY`，然后运行：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The system will alert you about the possible long duration of the process. Just
    accept the message and prepare some coffee in the meantime.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将提醒你关于过程可能的长持续时间。只需接受消息，同时准备一些咖啡。
- en: Android CTS
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Android CTS
- en: 'CTS is a well-known tool. We learned everything about it in the previous chapters.
    To build our own version, we need only one command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: CTS是一个知名的工具。我们在前面的章节中学到了关于它的所有内容。要构建我们自己的版本，我们只需要一个命令：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside an AOSP module
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在AOSP模块内部
- en: 'The AOSP project is incredibly huge. The amount of modules contained in the
    source base is massive. Android 5 Lollipop contains about 4,000 different modules.
    They go from native modules, written in C/C++, to providing system components:
    daemons, libraries, and Java modules, to provide everything that is needed from
    APKs to JAR files.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP项目极其庞大。源代码库中包含的模块数量巨大。Android 5 Lollipop大约包含4,000个不同的模块。它们从用C/C++编写的本地模块，到提供系统组件：守护进程、库和Java模块，以提供从APK到JAR文件所需的一切。
- en: 'Every module contains an Android.mk file. This file contains every single piece
    of information needed to build the module. The Android build system does not use
    a recursive-make approach, but merges every Android.mk file to create one single
    huge Makefile to build the system: every Android.mk file is a piece of the puzzle.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都包含一个Android.mk文件。这个文件包含构建模块所需的所有信息。Android构建系统不使用递归make方法，而是将每个Android.mk文件合并为一个单一的巨大Makefile来构建系统：每个Android.mk文件都是拼图的一部分。
- en: In addition to Android.mk, the module folder also contains `CleanSpeck.mk`.
    This file helps the system to properly clean every compiled file when we execute
    a module clean command.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Android.mk，模块文件夹还包含`CleanSpeck.mk`文件。这个文件帮助我们正确清理在执行模块清理命令时编译的每个文件。
- en: Diving into Android.mk
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深入Android.mk
- en: 'The quickest path to knowledge is getting your hands dirty. We are going to
    analyze a real Android.mk file from the Android source code to understand structure
    and purpose. In the previous chapter, we learned that the `external/` folder contains
    lots of third-party tools that enrich the Android system. One of these tools is
    `netcat`. Let''s see its Android.mk file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 获取知识的最快途径是亲自动手。我们将分析Android源代码中的一个真实的Android.mk文件，以了解其结构和目的。在上一章中，我们了解到`external/`文件夹包含许多第三方工具，这些工具丰富了Android系统。其中之一是`netcat`。让我们看看它的Android.mk文件：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A few cryptic lines that need more detailed study:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 几行需要更详细研究的神秘代码：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This line specifies the `LOCAL_PATH` variable and sets it to the current module
    path. As you can guess, the `$(call my-dir)` function returns the current module
    path.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行指定了`LOCAL_PATH`变量并将其设置为当前模块路径。正如你所猜到的，`$(call my-dir)`函数返回当前模块路径。
- en: 'This function is part of a collection of useful functions that the system provides
    to be used during the development of new modules. The whole list is contained
    in `build/core/definitions.mk`. Every function comes with code, obviously, and
    a tiny, but effective description of its purpose, as shown in the next screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是系统提供的一组有用的函数之一，用于在开发新模块期间使用。整个列表包含在`build/core/definitions.mk`中。每个函数显然都带有代码，以及一个微小但有效的目的描述，如下一张截图所示：
- en: '![](img/epub_36702041_44.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_44.jpeg)'
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This line solves one big issue due to the nature of the Android build system—having
    all the Android.mk files merged into one single Makefile creates a dangerous scenario
    in which `LOCAL_` variables from module A could be improperly used by module B.
    The `$(CLEAR_VARS)` function resets all the previously set variables and allows
    the current module to safely access its local variables, using this code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行解决了由于 Android 构建系统的特性而产生的一个大问题——将所有的 Android.mk 文件合并成一个单独的 Makefile，会创建一个危险的场景，其中模块
    A 的 `LOCAL_` 变量可能会被模块 B 错误地使用。`$(CLEAR_VARS)` 函数重置了之前设置的变量，并允许当前模块安全地访问其本地变量，使用以下代码：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following line specifies the source files contained in the current module:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行指定了当前模块中包含的源文件：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following line specifies which argument we are going to pass to the compiler:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行指定了我们将要传递给编译器的参数：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This line specifies which variant this module belongs to. This is closely related
    to the environment variable `TARGET_BUILD_VARIANT` we learned about in the previous
    sections. Specifying `eng` here will make this module available when we will build
    the `eng` build variant of the system:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行指定了该模块属于哪个变体。这与我们在前几节中了解到的环境变量 `TARGET_BUILD_VARIANT` 密切相关。在这里指定 `eng` 将使此模块在构建系统的
    `eng` 构建变体时可用：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This line specifies where to install the compiled executable file when the
    build process succeeds. In this specific case, the final file will be placed in
    the `xbin/` folder of the system image. This variable is optional. The system
    will act based on default values, already specified in the global configuration.
    We can use this variable to specify a *different* destination folder:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行指定了在构建过程成功时编译的可执行文件安装的位置。在这种情况下，最终文件将被放置在系统镜像的 `xbin/` 文件夹中。这个变量是可选的。系统将根据全局配置中已指定的默认值进行操作。我们可以使用这个变量来指定一个
    *不同的* 目标文件夹：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This line has been anticipated a few sections ago. This specifies the module
    name. It has to be unique and it will also be the executable file''s final name.
    In this case, our `netcat` utility will become the `nc` exectutable, as commonly
    seen on `*nix` systems:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行在几节前就已经被预期到了。它指定了模块名称。它必须是唯一的，它也将是可执行文件的最终名称。在这种情况下，我们的 `netcat` 工具将成为 `nc`
    可执行文件，正如在 `*nix` 系统中常见的那样：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As for the compiler also, the linker will have its set of specific arguments.
    This line specifies which options the linker will operate according to:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器来说，链接器也将有一组特定的参数。这一行指定了链接器将根据以下选项进行操作：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line specifies which type of module we are trying to build. Our current
    module is an executable utility, so we are going to specify `$(BUILD_EXECUTABLE)`
    and the system will properly produce an executable file from all the module source
    code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行指定了我们正在尝试构建的模块类型。我们当前的模块是一个可执行实用程序，因此我们将指定 `$(BUILD_EXECUTABLE)`，系统将正确地从所有模块源代码生成可执行文件。
- en: Android.mk variables ecosystem
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Android.mk 变量生态系统
- en: In the previous section, we analyzed a real-world Android.mk. This gave us a
    bit of confidence about creating our own Android module. In this section, we will
    continue our journey with an overview about all the variables we can use in our
    Android.mk.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们分析了一个实际的 Android.mk。这让我们在创建自己的 Android 模块时获得了一些信心。在本节中，我们将继续我们的旅程，概述我们可以在
    Android.mk 中使用的所有变量：
- en: '`LOCAL_` variables are all those variables necessary to achieve the proper
    module configuration and compilation. These kinds of variables get canceled by
    `$(CLEAN_VARS)` and are by far the most common kind in all Android.mk files.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOCAL_` 变量是所有必要的变量，用于实现适当的模块配置和编译。这类变量会被 `$(CLEAN_VARS)` 取消，并且在所有 Android.mk
    文件中是最常见的类型。'
- en: The `INTERNAL_`, `HOST_`, and `TARGET_` variables should not be used for custom
    purposes because they are commonly used by the build system itself.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`INTERNAL_`、`HOST_` 和 `TARGET_` 变量不应用于自定义目的，因为它们通常由构建系统本身使用。'
- en: The `BUILD_` variables specify the build type, as we already saw in a previous
    example where we used `BUILD_EXECUTABLE`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`BUILD_` 变量指定了构建类型，正如我们在之前的示例中看到的，我们使用了 `BUILD_EXECUTABLE`。'
- en: 'Technically speaking, we could use any kind of variable, but that''s a dangerous
    game. It is hard to predict how the build system will manipulate our Android.mk
    files to create its Makefile: order might be not respected, names could be overridden,
    and scopes could be invalidated. To play safely and rely on the build system architecture,
    let''s focus on using only `LOCAL_` variables for our tasks.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，我们可以使用任何类型的变量，但这是一场危险的游戏。很难预测构建系统将如何操纵我们的 Android.mk 文件来创建其 Makefile：顺序可能不被尊重，名称可能被覆盖，作用域可能被无效化。为了安全地玩耍并依赖于构建系统架构，让我们专注于只使用
    `LOCAL_` 变量来完成我们的任务。
- en: There is no official documentation about these variables. The upcoming list
    is the result of hard work, taking risks, guessing, and scavenging bits of information
    from all around the build system.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些变量没有官方文档。即将到来的列表是辛勤工作、冒险、猜测以及从整个构建系统中搜集信息的结果。
- en: The LOCAL_ variables
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LOCAL_ 变量
- en: 'When it comes to `LOCAL_` variables, we can customize our module according
    to this list:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 `LOCAL_` 变量时，我们可以根据此列表自定义我们的模块：
- en: '`LOCAL_PATH`: This specifies the path of the module. Usually, the value is
    retrieved using the `$(call my-dir)` function.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PATH`: 这指定了模块的路径。通常，该值是通过使用 `$(call my-dir)` 函数检索的。'
- en: '`LOCAL_MODULE`: This specifies the name of the module and, if we are dealing
    with an executable module, the name of the executable.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE`: 这指定了模块的名称，如果我们在处理可执行模块，则指定可执行文件的名称。'
- en: '`LOCAL_MODULE_CLASS`: This specifies the class the module belongs to. Based
    on its class, every result of the module building process will be placed in the
    proper folder. The examples of possible classes are `EXECUTABLE`, `ETC`, `SHARED_LIBRARY`,
    `STATIC_LIBRARY`, and `APPS`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE_CLASS`: 这指定了模块所属的类别。根据其类别，模块构建过程的每个结果都将放置在正确的文件夹中。可能的类别的例子有 `EXECUTABLE`、`ETC`、`SHARED_LIBRARY`、`STATIC_LIBRARY`
    和 `APPS`。'
- en: '`LOCAL_SRC_FILES`: This specifies the list of all source files contained in
    the module, separated by whitespace.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`: 这指定了模块中包含的所有源文件列表，由空格分隔。'
- en: '`LOCAL_PACKAGE_NAME`: This specifies the name of the app, for instance: Contacts,
    Phone, Calculator, and so on.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PACKAGE_NAME`: 这指定了应用程序的名称，例如：联系人、电话、计算器等等。'
- en: '`LOCAL_SHARED_LIBRARIES`: This specifies the shared libraries that may be required.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SHARED_LIBRARIES`: 这指定了可能需要的共享库。'
- en: '`LOCAL_MODULE_TAGS`: This specifies a tag, such as `eng`, and the system will
    include this module in every build that will target the `eng` type as `TARGET_BUILD_VARIANT`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE_TAGS`: 这指定了一个标签，例如 `eng`，系统将包括此模块在所有以 `eng` 类型作为 `TARGET_BUILD_VARIANT`
    的目标构建中。'
- en: '`LOCAL_MODULE_PATH`: This specifies a custom installation path to override
    the one specified in the `BUILD_` template.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE_PATH`: 这指定了一个自定义安装路径，以覆盖 `BUILD_` 模板中指定的路径。'
- en: '`LOCAL_CC`: This specifies a different C compiler to be used.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_CC`: 这指定了要使用的不同 C 编译器。'
- en: '`LOCAL_CXX`: This specifies a different C++ compiler to be used.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_CXX`: 这指定了要使用的不同 C++ 编译器。'
- en: '`LOCAL_CFLAGS`: This helps to add mode flags to the C compiler command line.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_CFLAGS`: 这有助于向 C 编译器命令行添加模式标志。'
- en: '`LOCAL_CPPFLAGS`: This helps to add mode flags to the C++ compiler command
    line.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_CPPFLAGS`: 这有助于向 C++ 编译器命令行添加模式标志。'
- en: '`LOCAL_CPP_EXTENSION`: This specifies a custom extension for C++ files, if
    for some reason the actual extension is not `.cpp`.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_CPP_EXTENSION`: 这指定了 C++ 文件的自定义扩展，如果由于某种原因实际扩展不是 `.cpp`。'
- en: '`LOCAL_C_INCLUDE`: This specifies the path for custom C header files needed
    to build the module.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_C_INCLUDE`: 这指定了构建模块所需的自定义 C 头文件路径。'
- en: '`LOCAL_LDFLAGS`: This helps to add mode flags to the linker command line.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_LDFLAGS`: 这有助于向链接器命令行添加模式标志。'
- en: '`LOCAL_PREBUILT_EXECUTABLES`: During the creation of a `BUILD_PREBUILD` kind
    of module, this variable will contain every binary executable that will be part
    of the final system image. We are going to learn more about this in the next chapters.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PREBUILT_EXECUTABLES`: 在创建 `BUILD_PREBUILD` 类型的模块期间，此变量将包含将成为最终系统镜像一部分的所有二进制可执行文件。我们将在下一章中了解更多关于这一点。'
- en: '`LOCAL_PREBUILT_LIBS`: During the creation of a `BUILD_PREBUILD` kind of module,
    this variable will contain every library that will be part of the final system
    image.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PREBUILT_LIBS`: 在创建 `BUILD_PREBUILD` 类型的模块期间，此变量将包含将成为最终系统镜像一部分的所有库。'
- en: '`LOCAL_PREBUILT_PACKAGE`: During the creation of a `BUILD_PREBUILD` kind of
    module, this variable will contain every prebuild APK that will be part of the
    final system image.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_PREBUILT_PACKAGE`：在创建 `BUILD_PREBUILD` 类型的模块期间，此变量将包含将成为最终系统映像一部分的所有预构建
    APK。'
- en: The BUILD_ variables
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BUILD_ 变量
- en: 'The following list contains the most common `BUILD_` variables available during
    the development of a custom module:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含在自定义模块开发过程中可用的最常见 `BUILD_` 变量：
- en: '`BUILD_EXECUTABLE`: When necessary to build using native C/C++ code, we can
    add this line to our configuration:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_EXECUTABLE`：当需要使用原生 C/C++ 代码进行构建时，我们可以在配置中添加此行：'
- en: '[PRE39]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`BUILD_PREBUILT`: This allows us to add binary components to our final image.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_PREBUILT`：这允许我们将二进制组件添加到我们的最终映像中。'
- en: '`BUILD_MULTI_PREBUILT`: This allows us to create modules that inject the final
    image with binarie components of the same category. It''s usually used with `LOCAL_MODULE_CLASS`
    to specify the class and the position to place the binary files.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_MULTI_PREBUILT`：这允许我们创建将具有相同类别二进制组件的最终映像注入模块。它通常与 `LOCAL_MODULE_CLASS`
    一起使用，以指定类别和放置二进制文件的位置。'
- en: '`BUILD_PACKAGE`: This allows us to create modules that generate APK files.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_PACKAGE`：这允许我们创建生成 APK 文件的模块。'
- en: '`BUILD_SHARED_LIBRARY`: This allows us to create modules that generate shared
    library files.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_SHARED_LIBRARY`：这允许我们创建生成共享库文件的模块。'
- en: '`BUILD_STATIC_LIBRARY`: This allows us to create modules that generate static
    library files.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_STATIC_LIBRARY`：这允许我们创建生成静态库文件的模块。'
- en: '`BUILD_JAVA_LIBRARY`: This allows us to create modules that generate Java library
    files.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_JAVA_LIBRARY`：这允许我们创建生成 Java 库文件的模块。'
- en: Module template examples
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块模板示例
- en: In this section, we are going to analyze real-world module template snippets,
    to have a clear idea about what a fully operational module template looks like.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析现实世界的模块模板代码片段，以便清楚地了解一个完全运行的模块模板看起来像什么。
- en: The native executable template
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原生可执行文件模板
- en: 'If you are going to work on a generic native single-file executable application,
    for example, `your_executable.c`, you can use the following snippet to build it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算对一个通用的原生单文件可执行应用程序进行工作，例如，`your_executable.c`，你可以使用以下代码片段来构建它：
- en: '[PRE40]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The shared library template
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享库模板
- en: 'This snippet comes in handy if you are working with a so-called shared library:
    your library would be composed of a set of files, that is, `foo.c` and `bar.c`,
    and would be built accordingly:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理所谓的共享库，这个代码片段会很有用：你的库将由一组文件组成，即 `foo.c` 和 `bar.c`，并将相应地构建：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The application template
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用程序模板
- en: 'If you are going to work on a whole application, you could use the following
    snippet:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算对一个完整的应用程序进行工作，你可以使用以下代码片段：
- en: '[PRE42]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This snippet will build every `.java` file in the specified path and package
    everything as `MyApplication`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将构建指定路径和包中的每个 `.java` 文件，并将所有内容打包为 `MyApplication`。
- en: Creating a custom device
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义设备
- en: During our journey, you learned how to retrieve the source code and how to set
    up the build system. In this section, you are going to learn how to create a new
    target device and add it to the build system. The device we are going to create
    now has specific hardware features. It's a proof-of-concept device, with the only
    purpose of showing you how easily and quickly you can create a brand new device
    and then customize it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅程中，你学习了如何检索源代码以及如何设置构建系统。在本节中，你将学习如何创建一个新的目标设备并将其添加到构建系统中。我们现在要创建的设备具有特定的硬件功能。这是一个概念验证设备，其唯一目的是向你展示你可以多么容易和快速地创建一个全新的设备，然后对其进行定制。
- en: 'Every device definition is contained in the `device/` folder. First level folders
    contains all the manufacturer''s folders. Every manufacturer folder contains its
    own devices. Let''s create our own manufacturer and device folders: our brand
    is Irarref and our model is an F488\. Open a Terminal, reach the `WORKING_DIRECTORY`
    folder, and run:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备定义都包含在 `device/` 文件夹中。第一级文件夹包含所有制造商的文件夹。每个制造商文件夹包含其自己的设备。让我们创建我们自己的制造商和设备文件夹：我们的品牌是
    Irarref，我们的型号是 F488。打开终端，到达 `WORKING_DIRECTORY` 文件夹，并运行：
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once we have the folder structure in place, we need to create all those files
    that will allow the build system to detect our device and make it available as
    a target for the build system. We are going to create the following files:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了文件夹结构，我们需要创建所有那些允许构建系统检测我们的设备并将其作为构建系统的目标使其可用的文件。我们将创建以下文件：
- en: '`Android.mk`: Describes in a generic way how to compile the source files. Essentially,
    it represents a snippet of the global Makefile that will be later incorporated
    by the build system at the appropriate time.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android.mk`: 以通用方式描述如何编译源文件。本质上，它代表了一个将被构建系统在适当时间合并的全球Makefile的片段。'
- en: '`AndroidProducts.mk`: This file contains a `PRODUCS_MAKEFILEs` variable, with
    a list of all the available products. In our scenario, we only have one device
    and it''s represented by these files.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidProducts.mk`: 这个文件包含一个`PRODUCS_MAKEFILEs`变量，列出了所有可用的产品。在我们的场景中，我们只有一个设备，它由这些文件表示。'
- en: '`full_f488.mk`: This file specifies any relevant information about the device.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full_f488.mk`: 这个文件指定了关于设备的相关信息。'
- en: '`BoardConfig.mk`: This file specifies any relevant information about the device
    board.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoardConfig.mk`: 这个文件指定了关于设备板的相关信息。'
- en: '`vendorsetup.sh`: This script makes the device available to `envsetup.sh` and
    `lunch`.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendorsetup.sh`: 这个脚本使设备对`envsetup.sh`和`lunch`可用。'
- en: Diving into device configuration
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入设备配置
- en: 'As we know, our first device is quite simple, but very instructive. Let''s
    see how our device specification is spread inside all our configuration files:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们的第一个设备相当简单，但非常有教育意义。让我们看看我们的设备规范是如何分布在我们所有的配置文件中的：
- en: '`Android.mk`:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android.mk`:'
- en: '[PRE44]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`AndroidProducts.mk`:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidProducts.mk`:'
- en: '[PRE45]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`full_f488.mk`:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full_f488.mk`:'
- en: '[PRE46]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`BoardConfig.mk`:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoardConfig.mk`:'
- en: '[PRE47]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`vendorsetup.sh`:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendorsetup.sh`:'
- en: '[PRE48]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Our `Android.mk` is pretty standard and completely based on what we have learned
    in the previous sections. `AndroidProducts.mk` just includes `full_f488.mk`, as
    expected.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Android.mk`相当标准，完全基于我们在前面的章节中学到的内容。`AndroidProducts.mk`正如预期的那样，只包括了`full_f488.mk`。
- en: The `full_f488.mk` file contains a few interesting lines. First of all, it includes
    `aosp_base.mk`, a configuration file provided by the system, common to lots of
    real devices.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`full_f488.mk`文件包含了一些有趣的行。首先，它包括了`aosp_base.mk`，这是一个由系统提供的配置文件，对于许多真实设备来说是通用的。'
- en: 'Moving on, we found a few interesting variables:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们发现了一些有趣的变量：
- en: '`DEVICE_PACKAGE_OVERLAY:=`: This variable allows us to create a custom overlay,
    customizing, for instance, some settings of specific modules in the AOSP system.
    If you check, for instance, this variable in the equivalent file for the `shamu`
    device, you can notice that they are using it to customize a few settings in the
    launcher application.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEVICE_PACKAGE_OVERLAY:=`: 这个变量允许我们创建一个自定义覆盖，例如，自定义AOSP系统中特定模块的一些设置。例如，如果你检查`shamu`设备的等效文件中的这个变量，你可以注意到他们正在使用它来自定义启动器应用程序中的几个设置。'
- en: '`PRODUCT_PACKAGE+=`: This variable allows us to add packages to the compilation
    process.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_PACKAGE+=`: 这个变量允许我们在编译过程中添加包。'
- en: '`PRODUCT_COPY_FILES+=`: This variable performs a file copy operation. The syntax
    is pretty straight forward: `source_file:dest_file`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_COPY_FILES+=`: 这个变量执行文件复制操作。语法相当直接：`source_file:dest_file`'
- en: '`PRODUCT_NAME:= full_f488`: This variable specifies the product name. This
    is the exact same value that `lunch` will print as `TARGET_PRODUCT`.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_NAME:= full_f488`: 这个变量指定了产品名称。这是`lunch`将打印为`TARGET_PRODUCT`的确切相同值。'
- en: '`PRODUCT_DEVICE:= f488`: This variable specifies the device name.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_DEVICE:= f488`: 这个变量指定了设备名称。'
- en: '`PRODUCT_MODEL:=`: Android for Irarref F488: This variable specifies the device
    model label that we will find in our Android system under **Settings** | **About
    phone** | **Model Number**.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRODUCT_MODEL:=`: Irarref F488的Android：这个变量指定了设备型号标签，我们将在Android系统中的**设置**
    | **关于手机** | **型号**下找到。'
- en: With all these files in place, you can now relaunch `envsetup.sh` and our brand
    new proof-of-concept device will be in the list of the available devices.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些文件就绪后，你现在可以重新启动`envsetup.sh`，我们全新的原型设备将出现在可用设备列表中。
- en: From zero to the screenlock
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从零到屏幕锁定
- en: 'So far we have gathered an incredible amount of information about the architecture,
    about how to configure the build system, and our PoC device. It''s time to create
    our first image for a real device and use it! We want to keep away all the possible
    hardware-related issues, so we will target the simplest nonhardware Android device:
    the Android emulator.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经收集了关于架构、如何配置构建系统以及我们的原型设备的大量信息。是时候为真实设备创建我们的第一个镜像并使用它了！我们希望避免所有可能的硬件相关的问题，因此我们将目标定位在最简单的非硬件Android设备上：Android模拟器。
- en: We are going to build the latest available Android Lollipop source code. As
    we learned, we are going to download it, configure it to target the emulator,
    build it, and try it on the device.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建最新可用的Android Lollipop源代码。正如我们所学的，我们将下载它，配置它以针对模拟器，构建它，并在设备上尝试它。
- en: Setup
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: 'Let''s set up our `WORKING_DIRECTORY` and download our precious source code.
    Open a Terminal and run the following commands:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置我们的`WORKING_DIRECTORY`并下载我们宝贵的源代码。打开终端并运行以下命令：
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After the download is completed, we can configure the environment. Let''s run:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，我们可以配置环境。让我们运行：
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will create all those handy tools we will need during the work. We now
    have `lunch`, for instance, and running it we can keep on configuring the environment:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们在工作中需要的所有实用工具。现在我们有`lunch`，例如，运行它我们可以继续配置环境：
- en: '[PRE51]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s choose a target device:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一个目标设备：
- en: '[PRE52]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `lunch` command will set up everything and show us a configuration report,
    as shown in the next screenshot:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`lunch`命令将设置一切并显示一个配置报告，如下一个截图所示：'
- en: '![](img/epub_36702041_45.jpeg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_45.jpeg)'
- en: Build
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: 'Everything is in place. We need only one command to launch the build procedure:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪。我们只需要一个命令来启动构建过程：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once the build process is over, head to `out/target/product/generic/`. This
    folder will contain our built images. The following screenshot shows the result
    of the build process: a folder full of `.img` files, ready to be flashed into
    the device:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程完成后，前往`out/target/product/generic/`。这个文件夹将包含我们构建的镜像。以下截图显示了构建过程的结果：一个充满`.img`文件的文件夹，准备闪存到设备中：
- en: '![](img/epub_36702041_46.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_46.jpeg)'
- en: Run
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行
- en: 'To launch the emulator, Android provides the `emulator` command. This command
    will be available the moment the compilation ends. Using the `.img` files, we
    have in the `out/` folder, we can run it like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动模拟器，Android提供了`emulator`命令。这个命令将在编译结束时可用。使用我们`out/`文件夹中的`.img`文件，我们可以这样运行它：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After a few moments, the emulator window will pop up and you will see something
    like the following screenshot:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，模拟器窗口将弹出，你将看到如下截图所示的内容：
- en: '![](img/epub_36702041_47.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_47.jpeg)'
- en: 'You can use the emulator with mouse and keyboard, performing the same operations
    you would do on a real device. Android emulator is a powerful tool and the amount
    of possibilities is almost endless. If you would like to dig into the topic, the
    Android Developers website provides a specific page for it: [http://developer.android.com/tools/help/emulator.html](http://developer.android.com/tools/help/emulator.html).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用鼠标和键盘使用模拟器，执行你会在真实设备上做的相同操作。Android模拟器是一个强大的工具，其可能性几乎是无穷无尽的。如果你想深入了解这个话题，Android开发者网站提供了一个专门的页面：[http://developer.android.com/tools/help/emulator.html](http://developer.android.com/tools/help/emulator.html)。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a great run! You prepared your system to build your first Android
    system. You learned how to configure and customize the build system. You learned
    the basic skills to create a custom module and include it into your system image.
    You created a system image from scratch and tested it on the Android emulator.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一次精彩的运行！你为构建你的第一个Android系统准备好了系统。你学习了如何配置和定制构建系统。你学习了创建自定义模块并将其包含到系统镜像中的基本技能。你从头开始创建了一个系统镜像，并在Android模拟器上进行了测试。
- en: In the next chapter, we will raise the bar. We are going to move our efforts
    to a real hardware device. We will work with a smartphone, the Nexus 5, and a
    development board, the UDOO. We will manipulate the bootloader and the recovery
    partition to take complete control of the system.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将提高标准。我们将把我们的努力转移到真实的硬件设备上。我们将使用智能手机Nexus 5和开发板UDOOU。我们将操作引导加载程序和恢复分区，以完全控制系统。
