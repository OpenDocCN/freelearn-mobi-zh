<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. APIs Introduced in iOS 7</h1></div></div></div><p>
<strong>API</strong> stands for <strong>application programming interface</strong>. An API is a set of commands, functions, sections of code, and protocols that programmers can use in their applications. They are predefined functions available <a class="indexterm" id="id213"/>for programmers to use instead of writing them from scratch. While APIs make a programmer's task easier, an API is a software-to-software interface, not a user interface. With APIs, applications communicate with each other without any user intervention. Some popular APIs are Google Map APIs, Twitter APIs, YouTube APIs, and so on.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using AirDrop to remotely send/receive files</li><li class="listitem" style="list-style-type: disc">iOS's first native game engine</li><li class="listitem" style="list-style-type: disc">Text kit to manage your typography</li><li class="listitem" style="list-style-type: disc">Sample projects</li></ul></div><p>There are a lot of major updates done by Apple for developers to incorporate into their app. The user interface has been completely redesigned. iOS 7 introduces a new animation system to create 2D and 2.5D games. Multitasking enhancements, peer-to-peer connectivity, and many other important features have been added.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Using AirDrop</h1></div></div></div><p>Apple <a class="indexterm" id="id214"/>introduced a new feature in iOS 7 called <strong>AirDrop</strong>. AirDrop is used to easily share pictures, contacts, notes, and more with other nearby iOS devices. It uses Bluetooth to detect nearby devices. When a connection is established via Bluetooth, it'll create an ad hoc Wi-Fi network to link the two devices together. There is a class called <code class="literal">UIActivityViewController</code> available to integrate AirDrop in our apps. We just <a class="indexterm" id="id215"/>need to tell this class which objects we want to share, and it handles the rest. The <code class="literal">UIActivityViewController</code> class is a standard view controller class that provides several standard services, such as copying items to the clipboard, sharing content on social media sites, sending items via messages, and so on. In iOS 7 SDK, this class is served with the built-in AirDrop feature:</p><div><pre class="programlisting">UIImage *Image1  = [UIImage imageNamed:@"Image.png"];

UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:[NSArray arrayWithObjects:@"Share Image", Image1, nil] applicationActivities:nil];</pre></div><p>Let's understand <a class="indexterm" id="id216"/>this feature with a small activity:</p><div><ol class="orderedlist arabic"><li class="listitem">Open Xcode and make a new project.</li><li class="listitem">Drag the image view and button into the storyboard from the interface builder. Our storyboard will look like the following screenshot:<div><img alt="Using AirDrop" src="img/1829OT_04_01.jpg"/></div></li><li class="listitem">Drag any image in Xcode below the class files that you want to use.</li><li class="listitem">Select the image view from the storyboard and move to the Attribute Inspector. Then, in the <strong>Image</strong> textbox, give it the same name as that of the image we dragged in Xcode, as shown in the following screenshot:<div><img alt="Using AirDrop" src="img/1829OT_04_02.jpg"/></div></li><li class="listitem">Now, link the image view and the button to <code class="literal">viewcontroller.h</code> and create one array in <a class="indexterm" id="id217"/>which we will store the content that we want to transfer from AirDrop.<div><pre class="programlisting">- (IBAction)share:(id)sender;
@property (weak, nonatomic) IBOutlet UIImageView *image;
@property (nonatomic,strong) NSArray *activityItems;</pre></div><p>The following screenshot will show the content that we want to transfer:</p><div><img alt="Using AirDrop" src="img/1829OT_04_03.jpg"/></div></li><li class="listitem">Move <a class="indexterm" id="id218"/>to <code class="literal">viewController.m</code> and add the following code to the <code class="literal">viewDidLoad</code> method:<div><pre class="programlisting">  NSString *shareString = @"This is my Development Machine.";
  UIImage *shareImage = [UIImage imageNamed:@"image.jpg"];
  self.activityItems = @[shareString,shareImage];</pre></div><p>In the preceding code, we created one string that we want to share and created one <code class="literal">UIImage</code> object that stores our image.</p><p>Then, we added both of them to our defined array. Now, let's add some code in our button event as follows:</p><div><pre class="programlisting">UIActivityViewController *avController = [[UIActivityViewController alloc]initWithActivityItems:self.activityItemsapplicationActivities:nil];

NSArray *excludedActivities =  @[ UIActivityTypePostToTwitter,
                                 UIActivityTypePostToFacebook,
                                 UIActivityTypePostToWeibo,
                                 UIActivityTypeMessage,
                                 UIActivityTypeMail,
                                 UIActivityTypePrint,
                                 UIActivityTypePrint,
                                 UIActivityTypeCopyToPasteboard,
                                 UIActivityTypeAssignToContact,
                                 UIActivityTypeSaveToCameraRoll,
                                 UIActivityTypeAddToReadingList,
                                 UIActivityTypePostToFlickr,
                                 UIActivityTypePostToVimeo, 
                                 UIActivityTypePostToTencentWeibo];

avController.excludedActivityTypes = excludedActivities;

[self presentViewController:avController animated:YES completion:nil];
}</pre></div><p>In the preceding code, we created <code class="literal">UIActivityViewController</code> with our <code class="literal">activityItems</code> array. With the <code class="literal">excludedActivityTypes</code> property, we excluded <a class="indexterm" id="id219"/>all the activities that are not needed, leaving AirDrop as the only sharing option. Finally, we presented the activity view controller. The following screenshot illustrates the preceding code snippet:</p><div><img alt="Using AirDrop" src="img/1829OT_04_04.jpg"/></div></li><li class="listitem">It is now time <a class="indexterm" id="id220"/>to compile and run our program. After execution, our simulator will look like the following screenshot:<div><img alt="Using AirDrop" src="img/1829OT_04_05.jpg"/></div></li><li class="listitem">Tap on the <a class="indexterm" id="id221"/><strong>Share With Air Drop</strong> button. Our simulator will now look like this:<div><img alt="Using AirDrop" src="img/1829OT_04_06.jpg"/></div><p>Here, no options are available because we have excluded all the options except the <a class="indexterm" id="id222"/>AirDrop option, and the simulator does not support AirDrop. When we put this code on the real device, it will show us the devices that are available for sharing and the devices that have AirDrop.</p></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>SpriteKit</h1></div></div></div><p>Apple has <a class="indexterm" id="id223"/>launched its first game engine, SpriteKit, that allows us to create games for iOS without being dependent on third-party game libraries. It is very powerful and inclined towards the traditional iOS framework approach when it comes to its usage. It's also very easy to adopt and learn. In addition to this, it supports lots of features such as physics <a class="indexterm" id="id224"/>simulations, a texture atlas, gravity, restitution, and game center support. Moreover, it comes with very rich developer documentation at the <strong>Apple Development Center</strong>. It's very useful and well written. You might need to understand the anatomy of game development first to get started in SpriteKit. So, there are two basic and most important terms here: one is Scenes, and the other one is Sprites. Scenes can be considered as the levels in the games. So, in any <a class="indexterm" id="id225"/>game, the score layer, the <strong>HUD</strong> (<strong>Heads-Up Display</strong>) layer, and the gameplay layer can act as different scenes. However, any object in the scene, such as the player or enemy, can be considered as a sprite.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>The iOS native game framework</h2></div></div></div><p>Apple has <a class="indexterm" id="id226"/>introduced its own native 2D game <a class="indexterm" id="id227"/>framework called SpriteKit. SpriteKit is a great 2D game engine that offers support for sprites, animations, filters, and masking. Most importantly, it also offers support for the physics engine to provide a real-world simulation for the game.</p><p>Apple <a class="indexterm" id="id228"/>provides a sample game called <em>Adventure Game</em> to get started with SpriteKit. You can check out the sample SpriteKit game project at <a class="ulink" href="https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture">https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/CodeExplainedAdventure/AdventureArchitecture/AdventureArchitecture</a>. This sample project provides a glimpse into the capability of this framework. However, the project is complicated to understand; for learning purposes, you just want to create something simple to understand and learn. To have a deeper understanding of SpriteKit-based games, we will build a bunch of mini games in this book. To understand the basics of SpriteKit game programming, we will build a mini <em>AntKilling</em> game in this chapter.</p><p>Let's start <a class="indexterm" id="id229"/>building the <em>AntKilling</em> game by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start your Xcode. Navigate to <strong>File</strong> | <strong>New</strong> | <strong>Project</strong>. Then, in the prompt window, navigate to <strong>iOS</strong> | <strong>Application</strong> | <strong>SpriteKit Game</strong> and click on <strong>Next</strong>, as shown in the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_07.jpg"/></div></li><li class="listitem">Fill <a class="indexterm" id="id230"/>in all the project details in the prompt window and enter <code class="literal">AntKilling</code> as <strong>Product Name</strong>. Also provide the name of your organization and select the device name as <strong>iPhone</strong> and <strong>Class Prefix</strong> as <strong>AK</strong>. Click on <strong>Next</strong> as shown in the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_08.jpg"/></div></li><li class="listitem">Select a location on your drive to save the project and then click on <strong>Create</strong>.</li><li class="listitem">Then, build <a class="indexterm" id="id231"/>the sample project to check its <a class="indexterm" id="id232"/>output. Once you build and run the project with the Play button, you will see the following screen on your device:<div><img alt="The iOS native game framework" src="img/1829OT_04_09.jpg"/></div></li></ol></div><p>As you can see, the sample SpriteKit project plays a label with a background color. SpriteKit works on the concept of scenes, which can be understood as the levels or screens of the game. There can be multiple scenes working at the same time; for example, there can be a gameplay scene, HUD scene, and the score scene running at the same time in the game.</p><p>Now, we <a class="indexterm" id="id233"/>can look at more <a class="indexterm" id="id234"/>detailed arrangements for the starter project by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the main directory, you already have one scene created by default; this scene is called <code class="literal">AKMyScene</code>. Now, click on <code class="literal">AKMyScene.m</code> to explore the code for adding the label on the screen. You should see something similar to following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_10.jpg"/></div><p>Now, we have to update this file with our code to create our <em>AntKilling</em> game. We have to fulfill a few prerequisites to get started with the code; for example, we have to lock the orientation to landscape <a class="indexterm" id="id235"/>as we want a landscape-orientation game.</p></li><li class="listitem">To <a class="indexterm" id="id236"/>change the orientation of the game, open the <strong>AntKilling</strong> project settings and navigate to <strong>TARGETS</strong> | <strong>General</strong>. You will see something similar to the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_11.jpg"/></div></li><li class="listitem">Now, in <a class="indexterm" id="id237"/>the <strong>General</strong> tab, uncheck <a class="indexterm" id="id238"/><strong>Portrait</strong> under the <strong>Device Orientation</strong> option so that the final settings look similar to the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_12.jpg"/></div></li><li class="listitem">Now, build <a class="indexterm" id="id239"/>and run the project. You <a class="indexterm" id="id240"/>will be able to see the app started in the landscape orientation.<div><img alt="The iOS native game framework" src="img/1829OT_04_13.jpg"/></div></li><li class="listitem">Now, it's time to update <code class="literal">AKMyScene</code> to hold our ant sprites. Just download and open all the resources you got for this chapter and add them to your Xcode project.</li><li class="listitem">While adding the resources to the Xcode project, make sure that the selected target is <strong>AntKilling</strong> and that the <strong>Copy items into destination group folder</strong> is checked, if needed.</li><li class="listitem">Now, delete <a class="indexterm" id="id241"/>all the existing code from <a class="indexterm" id="id242"/><code class="literal">AKMyScene.m</code> and make it look similar to following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_14.jpg"/></div><p>Now, here is the explanation of what we did so far:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we created a private interface to declare the private variables:<div><pre class="programlisting">@interface AKMyScene ()
@property (nonatomic) SKSpriteNode *ant;
@end</pre></div></li><li class="listitem">Then, in the <code class="literal">init</code> method, we printed a log to print the size of the screen:<div><pre class="programlisting">NSLog(@"Size: %@", NSStringFromCGSize(size));</pre></div></li><li class="listitem">We changed the screen background color to white using the following line of code:<div><pre class="programlisting">self.backgroundColor = [SKColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:1.0];</pre></div></li><li class="listitem">In the following line of code, we created a sprite object using the <code class="literal">spriteNodeWithImageNamed</code> method and passed the image name to it. Then, we positioned the sprite object to <code class="literal">(100, 100)</code> of the screen, which is in the bottom-left corner of the screen. Then, finally, we added it as a child method:<div><pre class="programlisting">self.ant = [SKSpriteNode spriteNodeWithImageNamed:@"ant.jpg"];
self.ant.position = CGPointMake(100, 100);
[self addChild:self.ant];</pre></div></li></ol></div></li><li class="listitem">Now, build <a class="indexterm" id="id243"/>and run your application. You <a class="indexterm" id="id244"/>will see something similar to the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_15.jpg"/></div><p>Now, as you can see, the screen color has changed to white, but there is no ant on the screen. This means there is something wrong with the code. So now, let's check our logs, which should print the following:</p><div><pre class="programlisting">
<strong>2014-07-22 19:13:27.019 AntKilling[1437:60b] Size: {320, 568}</strong>
</pre></div><p>So, we found out that the scene size is wrong; it should print <code class="literal">568</code> as the width and <code class="literal">320</code> as the height, and it is printing the opposite.</p></li><li class="listitem">To debug this, navigate to the <code class="literal">viewDidLoad</code> method of your <code class="literal">AKViewController.m</code>. This will be something similar to the one shown in the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_16.jpg"/></div><p>So, from this method, we can see that our scene absorbs the size from the bounds of the view, and this <code class="literal">viewDidLoad</code> method is invoked even before the view has been added to the view hierarchy. Thus, it has not responded to the layout changes. As a result  of the inconsistent view bounds, our scene is getting started with the wrong bounds.</p></li><li class="listitem">To solve <a class="indexterm" id="id245"/>this issue, we have to move the scene startup code in the <code class="literal">viewWillLayoutSubviews</code> method.</li><li class="listitem">After <a class="indexterm" id="id246"/>removing the code from the <code class="literal">viewDidLoad</code> method and pasting it to <code class="literal">viewWillLayoutSubviews</code>, the code file will look similar to the one shown in the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_17.jpg"/></div></li><li class="listitem">Now, again, build and run the app. You will see the following output:<div><img alt="The iOS native game framework" src="img/1829OT_04_18.jpg"/></div><p>Congrats! You have fixed the issue; now, your ant has appeared on the screen at your given location. If you observe closely, you can see that the status bar is coming on the top of the game, and this is not looking great.</p></li><li class="listitem">To <a class="indexterm" id="id247"/>remove the status bar from the <a class="indexterm" id="id248"/>screen, open your <code class="literal">AntKilling-Info.plist</code> file and add the <code class="literal">UIViewControllerBasedStatusBarAppearance</code> attribute and the value as <code class="literal">NO</code>. Your <code class="literal">.plist</code> file should be similar to following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_19.jpg"/></div></li><li class="listitem">Build and run your project again. You should be able to see the game without the <a class="indexterm" id="id249"/>status bar now, as shown in the following screenshot:<div><img alt="The iOS native game framework" src="img/1829OT_04_20.jpg"/></div><p>This looks perfect now; our ant is residing on the screen as expected. So now, our next objective is to animate the ant when we tap on it.</p></li><li class="listitem">To <a class="indexterm" id="id250"/>accomplish this, we need to add the following code in the <code class="literal">AKMyScene.m</code> file just below our <code class="literal">initWithSize</code> method:<div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    UITouch *touch = [touches anyObject];
    CGPoint positionInScene = [touch locationInNode:self];
    SKSpriteNode *touchedNode = (SKSpriteNode *)[self nodeAtPoint:positionInScene];
    if (touchedNode == self.ant) {
        SKAction *sequence = [SKAction sequence:@[[SKAction rotateByAngle:degreeToRadian(-3.0f) duration:0.2],
                             [SKAction rotateByAngle:0.0 duration:0.1],
                             [SKAction rotateByAngle:degreeToRadian(3.0f) duration:0.2]]];
        
        [touchedNode runAction:[SKAction repeatActionForever:sequence]];
    }    
}
float degreeToRadian(float degree) {
    return degree / 180.0f * M_PI;
}</pre></div><p>The final code file will look similar to the one shown in the following screenshot:</p><div><img alt="The iOS native game framework" src="img/1829OT_04_21.jpg"/></div><p>Let's <a class="indexterm" id="id251"/>go through it line-by-line to understand <a class="indexterm" id="id252"/>what we have done so far:</p><div><ol class="orderedlist arabic"><li class="listitem">To begin with, we added the <code class="literal">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</code> method to the grab all the touches on the scene.</li><li class="listitem">Now, in the function the first line allowed us to grab the <code class="literal">UITouch *touch = [touches anyObject];</code> touch.</li><li class="listitem">In the next line, we grabbed the touch and converted it to the <code class="literal">CGPoint positionInScene = [touch locationInNode:self];</code> location.</li><li class="listitem">Using the following line, we fetched the sprite that was touched:<div><pre class="programlisting">SKSpriteNode *touchedNode = (SKSpriteNode *)[self nodeAtPoint:positionInScene];</pre></div></li><li class="listitem">Once you have the sprite object, compare and check whether the selected object is the ant bug. If it's the ant bug, then animate the object by adding the following line of code:<div><pre class="programlisting">SKAction *sequence = [SKAction sequence:@[[SKAction rotateByAngle:degreeToRadian(-3.0f) duration:0.2],
                                          [SKAction rotateByAngle:0.0 duration:0.1],
                                          [SKAction rotateByAngle:degreeToRadian(3.0f) duration:0.2]]];
[touchedNode runAction:[SKAction repeatActionForever:sequence]];</pre></div></li></ol></div></li><li class="listitem">Now, this code will animate the selected sprite. Build and run the project, and you will see the ant animating when we tap on it.</li></ol></div><p>You will <a class="indexterm" id="id253"/>soon notice that, on tapping on the ant, it <a class="indexterm" id="id254"/>starts animating, but there is no way to stop this. So, let's add a way to stop this animation once you click anywhere on the scene. Go to the <code class="literal">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</code> method and update it to the following code:</p><div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    UITouch *touch = [touches anyObject];
    CGPoint positionInScene = [touch locationInNode:self];
    SKSpriteNode *touchedNode = (SKSpriteNode *)[self nodeAtPoint:positionInScene];
    if (touchedNode == self.ant) {
        SKAction *sequence = [SKAction sequence:@[[SKAction rotateByAngle:degreeToRadian(-3.0f) duration:0.2],
                                                  [SKAction rotateByAngle:0.0 duration:0.1],
                                                  [SKAction rotateByAngle:degreeToRadian(3.0f) duration:0.2]]];
        
        [touchedNode runAction:[SKAction repeatActionForever:sequence]];
    } else {
        [self.ant removeAllActions];
    }
}</pre></div><p>If you observe closely, you can see that we have added an <code class="literal">if</code>/<code class="literal">else</code> condition to check whether the ant animates when we tap on it and whether all actions stop when we tap anywhere <a class="indexterm" id="id255"/>outside the screen. To stop all the <a class="indexterm" id="id256"/>actions on the sprite, we can use the <code class="literal">removeAllActions</code> method on the sprite.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Text Kit</h1></div></div></div><p>The <code class="literal">UIKit</code> <a class="indexterm" id="id257"/>framework includes several classes whose purpose is to display text in a user's app, such as <code class="literal">UITextView</code>, <code class="literal">UITextField</code>, <code class="literal">UILabel</code>, and <code class="literal">UIWebView</code>. Text views, created from the <code class="literal">UITextView</code> class, are meant to display different types of text on screen. <code class="literal">UITextView</code> is a powerful layout engine called <strong>Text Kit</strong>. Text Kit is built on <a class="indexterm" id="id258"/>top of <strong>Core Text</strong>, so it provides the same speed and power as that of Core Text. <code class="literal">UITextView</code> is fully integrated with Text Kit; it provides editing and display capabilities that enable users to input text, specify formatting attributes, and view the results. The other Text Kit classes provide text storage and layout capabilities. The following diagram shows the position of Text Kit among other iOS text and graphic frameworks:</p><div><img alt="Text Kit" src="img/1829OT_04_22.jpg"/></div><p>We know that Text Kit is a collection of many classes and functions. However, there are three primary classes of Text Kit:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSTextStorage</code> (text storage class)</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSLayoutManager</code> (layout manager class)</li><li class="listitem" style="list-style-type: disc"><code class="literal">NSTextContainer</code> (text container class)</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>NSTextStorage</h2></div></div></div><p>The <code class="literal">NSTextStorage</code> <a class="indexterm" id="id259"/>class is responsible for storing all <a class="indexterm" id="id260"/>text attribute-related information, such as font, size, or paragraph information. The <code class="literal">NSTextStorage</code> class is a subclass of the <code class="literal">NSMutableAttributedString</code> class, and that's why it is responsible for keeping all text attributes. Besides this, its role also lies in making sure that all the edited text attribute data will remain consistent throughout all the management and editing operations that might be performed.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>NSLayoutManager</h2></div></div></div><p>The <code class="literal">NSLayoutManager</code> class, as its name implies, manages the way in which the text data stored in a <a class="indexterm" id="id261"/><code class="literal">NSTextStorage</code> object will be displayed <a class="indexterm" id="id262"/>in a view. Its job is to handle and support any view object that the text can be displayed in and perform any required conversions of Unicode characters to glyphs so that each character properly appears on screen. An object of this class is notified by <code class="literal">NSTextStorage</code> about any modifications made to the text and its attributes, so every change immediately gets reflected in the corresponding view.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>NSTextContainer</h2></div></div></div><p>The <code class="literal">NSTextContainer</code> <a class="indexterm" id="id263"/>class actually specifies the view <a class="indexterm" id="id264"/>where the text will appear, and it handles information regarding this view (such as its frame or shape). However, a quite important characteristic of this class is its ability to keep an array of Bezier paths that define areas that should be excluded from the allowed region where the text will appear. This gives Text Kit the unique possibility of letting text flow around images or other non-text objects and allowing developers to display text in an impressive or demanding manner.</p><p>Text Kit is a set of classes and protocols in the <code class="literal">UIKit</code> framework that provide high-quality typographical services that enable apps to store, layout, and display text with all kinds of typesetting: kerning, ligatures, line breaking, and justification.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Kerning</h2></div></div></div><p>All characters have <a class="indexterm" id="id265"/>different and irregular shapes, and these shapes must be placed exactly adjacent to each other. Text kit layout takes this into account; for <a class="indexterm" id="id266"/>example, a capital letter, <em>T</em>, has a lot of free space under its "wings" and moves the following lowercase letters closer. This results in significantly improved legibility of text, especially in longer pieces of writing. The following screenshot illustrates kerning:</p><div><img alt="Kerning" src="img/1829OT_04_23.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Ligatures</h2></div></div></div><p>This is an artistic feature <a class="indexterm" id="id267"/>of Text Kit. Some characters look nice when <a class="indexterm" id="id268"/>they are combined, for example when <em>f</em> is combined with <em>l</em>. These combined symbols are called glyphs.</p><div><img alt="Ligatures" src="img/1829OT_04_24.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Line breaking</h2></div></div></div><p>To create <a class="indexterm" id="id269"/>lines from a string of glyphs, the layout engine must <a class="indexterm" id="id270"/>perform line breaking by finding a point at which to end one line and begin the next. In the text system, you can specify line breaking at either word or glyph boundaries. In Roman text, a word broken between glyphs requires the insertion of a hyphen glyph at the breakpoint.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Justification</h2></div></div></div><p>Lines of text <a class="indexterm" id="id271"/>can also be justified; for horizontal text, the lines are aligned on both right and left margins by varying interword and interglyph spacing, as <a class="indexterm" id="id272"/>shown in the following screenshot. The system performs alignment and justification, if requested, after the text stream has been broken into lines, hyphens have been added, and other glyph substitutions have been made.</p><div><img alt="Justification" src="img/1829OT_04_25.jpg"/></div><p>Let's move to exclusion paths again. We know that Text Kit contains many classes, and Text Container is one of them. One great feature of it is that it can store an array of <code class="literal">UIBezierPath</code> and force text to flow around these paths; as they are excluded from <a class="indexterm" id="id273"/>the text draw region, they are called <strong>exclusion paths</strong>. Let's understand how they work by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open Xcode and create a new project. Go to the storyboard, drag a <strong>Text Field</strong> to view, and edit the text as you want (as shown in the following screenshot):<div><img alt="Justification" src="img/1829OT_04_26.jpg"/></div></li><li class="listitem">Drag <a class="indexterm" id="id274"/>an <a class="indexterm" id="id275"/>image view on the text view, as follows:<div><img alt="Justification" src="img/1829OT_04_27.jpg"/></div></li><li class="listitem">Add an image on the image view, as we did earlier. Drag any image in Xcode, as <a class="indexterm" id="id276"/>shown in the following screenshot, and <a class="indexterm" id="id277"/>give the same name to the image view via the Attribute Inspector as that of the dragged image:<div><img alt="Justification" src="img/1829OT_04_28.jpg"/></div></li><li class="listitem">Compile <a class="indexterm" id="id278"/>and run the code; our simulator will look like <a class="indexterm" id="id279"/>the following screenshot. It's cutting our text part below the image; this is not the output that we expected.<div><img alt="Justification" src="img/1829OT_04_31.jpg"/></div></li><li class="listitem">To <a class="indexterm" id="id280"/>implement the exclusive path text, we need to add <a class="indexterm" id="id281"/>some code. First of all, link the text field and image view to the <code class="literal">viewController.h</code> file, as shown in the following screenshot:<div><img alt="Justification" src="img/1829OT_04_29.jpg"/></div></li><li class="listitem">In <a class="indexterm" id="id282"/>the <code class="literal">viewController.m</code> file, write the following <a class="indexterm" id="id283"/>code in the <code class="literal">viewDidLoad</code> method:<div><pre class="programlisting">[_imageView setHidden:YES];
    if ([_imageView isHidden]) {
      CGRect convertedFrame = [_textView convertRect:_imageView.frame fromView:self.view];
      [[_textView textContainer] setExclusionPaths:@[[UIBezierPath bezierPathWithRect:convertedFrame]]];
    }
    else{
      [[_textView textContainer] setExclusionPaths:nil];
    }
    [_imageView setHidden:![_imageView isHidden]];</pre></div><p>In the preceding code, we first checked whether the image view is hidden or not (<code class="literal">_propertyName</code> is also a way to access any property other than <code class="literal">self.property</code>). If it's hidden (the initial state), then we have to set the exclusion path to the text container object of the text view so that the text flows around the image view and, of course, to make the image view visible:</p><div><pre class="programlisting">CGRect convertedFrame = [_textView convertRect:_imageView.frame fromView:self.view];</pre></div><p>This line is used to convert the image view coordinates from the <code class="literal">self.view</code> view to the text view, so both the image view and the floating text exist in the same area. Next, using the <code class="literal">bezierPathWithRect:</code> class method of the <code class="literal">UIBezierPath</code> class, we created the Bezier path by the frame specified by its parameter; in our case, this is the frame (converted to the text view's coordinates) of the image view. We added this Bezier path to <code class="literal">NSArray</code>, and finally, we set the <a class="indexterm" id="id284"/>exclusion path. Note that, in the <code class="literal">else</code> case, we set the exclusion path to <code class="literal">nil</code>, because we don't want our text to flow <a class="indexterm" id="id285"/>when the image view is not there.</p><p>Our <code class="literal">viewController.m</code> file will look like the one shown in the following screenshot:</p><div><img alt="Justification" src="img/1829OT_04_30.jpg"/></div></li><li class="listitem">Run the code. Now, our text will not be cut because of the image. Look at the following <a class="indexterm" id="id286"/>screenshot; it's not cutting our text, and our text <a class="indexterm" id="id287"/>continues after the image in each line. Text gives space to the image through the <code class="literal">UIBezierPath</code> class and makes a different class for the image view. So, now, you can try it for round-shaped images or other images of any shape.<div><img alt="Justification" src="img/1829OT_04_32.jpg"/></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we learned a lot of interesting things, including how to create a game, add an image between text, and share it with AirDrop. All these APIs are introduced in iOS 7. After this chapter, try to extend all the activities performed here. This will clarify your concepts. In the next chapter, we will learn iOS 8 APIs, including PhotoKit, manual camera control, and the Handoff concept.</p></div></body></html>