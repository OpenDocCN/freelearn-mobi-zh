<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Wi-Fi Power Plug" id="aid-OPEK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Wi-Fi Power Plug</h1></div></div></div><p>The Wi-Fi Power Plug is a device through which you can control electrical appliances hooked <a id="id156" class="indexterm"/>up to it, turning them on and off in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Manually from your iOS device</li><li class="listitem">Automatically setting timers</li></ul></div><p>For example, you can turn on your irrigation system every day at 6 P.M. for 30 minutes, but if you see that your grass is turning yellow you can manually turn on the system for an additional watering.</p><p>Nowadays, this kind of device is available on the market for a reasonable price but building one yourself will allow you to understand how it works and adapt it to your own needs.</p><p>In comparison with the project in <a class="link" title="Chapter 1. Arduino and iOS – Platforms and Integration" href="part0014.xhtml#aid-DB7S2">Chapter 1</a>, <span class="emphasis"><em>Arduino and iOS – Platforms and Integration</em></span>, we are going to use Wi-Fi as the communication protocol. This will allow you to access the device even when you are not at home.</p><p>The chapter is organized in the following sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Wi-Fi power plug requirements: We will briefly set the project requirements</li><li class="listitem">Hardware: We will describe the hardware and the electronic circuit needed for the project</li><li class="listitem">Arduino code: We will write the code for Arduino to control the external appliance and to communicate with the iOS device</li><li class="listitem">iOS code: We will write the code for the iOS device</li><li class="listitem">How to access your power plug from anywhere in the world</li><li class="listitem">How to go further: More ideas to improve the project and learn more</li></ul></div><div class="section" title="Wi-Fi power plug requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Wi-Fi power plug requirements</h1></div></div></div><p>We <a id="id157" class="indexterm"/>are going to build a device that will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Turn an electric appliance hooked up to it on and off by receiving a command from the iOS device</li><li class="listitem">Turn on and off an electrical appliance on and off at specific times for a predefined lasting</li></ul></div><p>The accompanying iOS application has to manually control the power plug and manage the timers.</p></div></div>
<div class="section" title="Hardware" id="aid-PNV61"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Hardware</h1></div></div></div><p>As <a id="id158" class="indexterm"/>we mentioned in <a class="link" title="Chapter 1. Arduino and iOS – Platforms and Integration" href="part0014.xhtml#aid-DB7S2">Chapter 1</a>, <span class="emphasis"><em>Arduino and iOS – Platforms and Integration</em></span>, we <a id="id159" class="indexterm"/>need a Wi-Fi shield (<a class="ulink" href="http://www.arduino.cc/en/Main/ArduinoWiFiShield">http://www.arduino.cc/en/Main/ArduinoWiFiShield</a>) and a micro SD card formatted <a id="id160" class="indexterm"/>with FAT16 (take a look here for<a id="id161" class="indexterm"/> more details: <a class="ulink" href="http://www.arduino.cc/en/Reference/SDCardNotes">http://www.arduino.cc/en/Reference/SDCardNotes</a>). The SD card is used to permanently store the activation times when Arduino is powered off, so its size is not so important.</p><div class="section" title="Additional electronics components"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Additional electronics components</h2></div></div></div><p>In <a id="id162" class="indexterm"/>this project we need some additional components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Optoisolator MOC3041</li><li class="listitem">330 Ω resistor, 0.5 W</li><li class="listitem">330 Ω resistor, 0.25 W</li><li class="listitem">Red LED</li><li class="listitem">TRIAC BTA08-600</li></ul></div><p>The TRIAC is capable of 8 Amperes RMS at 600 V, which is about 1700 watts at 220 V. You can use another TRIAC model of the same family (for example, BTA16) if you have a more powerful external appliance.</p></div><div class="section" title="Electronic circuit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Electronic circuit</h2></div></div></div><p>The<a id="id163" class="indexterm"/> following picture shows the electric diagram of the electronic circuit that we need for the project:</p><div class="mediaobject"><img src="../Images/image00175.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>The<a id="id164" class="indexterm"/> following picture shows how to mount the circuit on a breadboard.</p><div class="note" title="Note"><h3 class="title"><a id="tip25"/>Tip</h3><p>Don't forget to mount the Wi-Fi shield, and insert a micro SD card into it.</p></div><div class="mediaobject"><img src="../Images/image00176.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="tip26"/>Tip</h3><p>This<a id="id165" class="indexterm"/> circuit works with the power line (120 V or 220 V). Touching any part with power line voltage can be extremely dangerous and can kill you. Even professionals with years of experience have been injured or killed, so <span class="emphasis"><em>please</em></span> be extremely careful. This means that if you have never worked with power line voltage, you need to do that under the control of a skilled person.</p><p>
<span class="emphasis"><em>Again, avoid working with the power line yourself if you have not done it before. You are the only one responsible for any damage you may cause to yourself, your relatives and your stuff. You have been warned!</em></span>
</p><p>If you don't feel safe handling the power line, you can still enjoy the project by replacing the power circuit with just the LED and the resistor.</p></div><p>To <a id="id166" class="indexterm"/>power the external appliance we use <a id="id167" class="indexterm"/>a TRIAC (<a class="ulink" href="http://bit.ly/1MzmIYs">http://bit.ly/1MzmIYs</a>), which allows you to control an AC load using a small current. Since the power plug uses the power line, the voltages around are high (120-220 V) and they can burn your Arduino. For that reason, an optoisolator is placed between the low voltage circuit (Arduino) and the high voltage circuit (TRIAC) (<a class="ulink" href="http://bit.ly/1TV1JFc">http://bit.ly/1TV1JFc</a>). Basically, it is an LED and a low power TRIAC in<a id="id168" class="indexterm"/> the same small package. When the LED is on, a small current is generated for photoelectric effect and it polarizes the gate of the low power TRIAC switching it. The main point here is that the light electrically isolates the LED and the TRIAC.</p><p>A transistor and a relay can replace the TRIAC and the optoisolator, but a relay is an electromechanical device, which is subject to failures in short time.</p><p>Turning the optoisolator LED from Arduino on and off is pretty easy, as it is wired to a digital pin (number 8 in our case) and controlled with <code class="literal">digitalWrite(&lt;PIN&gt;, HIGH | LOW)</code>. The external LED in series with the optoisolator has monitoring purpose only.</p><div class="note" title="Note"><h3 class="title"><a id="tip27"/>Tip</h3><p>
<span class="strong"><strong>Controlling more appliances</strong></span>
</p><p>If you <a id="id169" class="indexterm"/>need to control more appliances, you can replicate the power circuit (Optoisolator and TRIAC) and wire it to another digital pin. Then you need to adapt both the Arduino code and the iOS code.</p></div></div></div>
<div class="section" title="Arduino code" id="aid-QMFO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Arduino code</h1></div></div></div><p>The<a id="id170" class="indexterm"/> full code of this project can be downloaded from<a id="id171" class="indexterm"/> here:</p><p>
<a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>
</p><p>For a <a id="id172" class="indexterm"/>better understanding of the explanations in the next paragraphs, you should open the downloaded code while reading.</p><p>The power plug has to activate the external appliance at different times for a different lasting and then<a id="id173" class="indexterm"/> deactivate it. We are going to call <span class="strong"><strong>activation</strong></span> a turn on-turn off cycle. Each activation can be represented by a square wave (see the following diagram).</p><div class="mediaobject"><img src="../Images/image00177.jpeg" alt="Arduino code"/></div><p style="clear:both; height: 1em;"> </p><p>Each <a id="id174" class="indexterm"/>activation starts at its <span class="strong"><strong>Start Time</strong></span>, lasts for a <span class="strong"><strong>Length</strong></span> (during which the appliance is on) and repeats exactly after a <span class="strong"><strong>Period</strong></span> of time. A one-off <a id="id175" class="indexterm"/>activation has a period equal to 0.</p><p>We will use this diagram for understanding the Arduino code.</p><p>The application can manage the <code class="literal">NUMBER_OF_ACTIVATIONS</code> activations stored in the global array <code class="literal">activations</code>. Each activation is a new type, defined as follows:</p><div class="informalexample"><pre class="programlisting">typedef struct  {
  char                name[21];
  unsigned long       startTime;      // seconds since midnight 1/1/1970
  uint16_t       length;         // minutes
  uint16_t       period;         // minutes
} activation;</pre></div><p>To make the code as simple as possible (and to save the flash memory) we save the entire array to the SD file, even if not all the activations are set. An activation is set if its name is set.</p><div class="note" title="Note"><h3 class="title"><a id="tip28"/>Tip</h3><p>
<span class="strong"><strong>Flash memory</strong></span>
</p><p>Flash memory <a id="id176" class="indexterm"/>stores the program running on Arduino. Arduino UNO has 32 K of flash memory of which 0.5 K is used for the bootloader. The bootloader is a small code that allows programming UNO via USB instead of using an external in-circuit programmer (for example, an AVR-ISP or STK500).</p></div><div class="section" title="Setup code"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Setup code</h2></div></div></div><p>Please <a id="id177" class="indexterm"/>refer to the downloaded code, since the setup code is quite simple and doesn't require a detailed explanation.</p><p>Because we are handling time and Arduino does not have a real-time clock, we need to get the <a id="id178" class="indexterm"/>current time from a Network Time Protocol server on the net (<a class="ulink" href="http://bit.ly/1NyCVM7">http://bit.ly/1NyCVM7</a>); this is what the function <code class="literal">askTime</code> does. The<a id="id179" class="indexterm"/> request is sent via UPD (<a class="ulink" href="http://bit.ly/1MzmQHb">http://bit.ly/1MzmQHb</a>) and the answer is received on port 2390. When a data packet is<a id="id180" class="indexterm"/> received, it is transformed into Unix time with the function <code class="literal">readTime </code>(see the <code class="literal">loop</code> function).</p><div class="note" title="Note"><h3 class="title"><a id="tip29"/>Tip</h3><p>
<span class="strong"><strong>Unix time</strong></span>
</p><p>Unix time<a id="id181" class="indexterm"/> or Posix time is defined as the number of seconds<a id="id182" class="indexterm"/> that have elapsed since <a id="id183" class="indexterm"/>00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970 (<a class="ulink" href="http://bit.ly/1E6LP3m">http://bit.ly/1E6LP3m</a>).</p></div></div><div class="section" title="Main program"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Main program</h2></div></div></div><p>Let's <a id="id184" class="indexterm"/>start with a simplified version of the main loop:</p><div class="informalexample"><pre class="programlisting">void loop() {

  WiFiClient client;

  client = server.available();

  if (client) {
    Serial.println(F("iOS Device connected"));

    // Waits for client disconnection
    while (client.connected()) {

      // Waits for data and process them

      while (client.available()) {


      }

    }

    Serial.println(F("iOS Device disconnected"));
  }


  //Serial.println(millis() / 1000 - lastActivation);
  if (millis() / 1000 - lastActivation &gt;= ACTIVATION_CHECK_INTERVAL &amp;&amp; !manualMode) {

    lastActivation = millis() / 1000;
    checkActivations();
  }

  delay(50);
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip30"/>Tip</h3><p>
<span class="strong"><strong>Strings in flash memory</strong></span>
</p><p>Usually <a id="id185" class="indexterm"/>Arduino stores static strings in RAM. Since RAM is also used for storing variables, we can move static strings to flash memory with the F() notation. For example, <code class="literal">Serial.println("iOS Device disconnected")</code>, wastes 23 bytes of RAM for storing the string <code class="literal">"iOS Device disconnected"</code>. Instead, writing <code class="literal">Serial.println(F("iOS Device disconnected"))</code> will let the string be stored in flash.</p></div><p>The<a id="id186" class="indexterm"/> variable <code class="literal">server</code> represents the TCP server listening for connections. If a new client is connected and has data available for reading, <code class="literal">available</code> returns an instance of <code class="literal">WiFiClient</code> (<code class="literal">client</code>), which can be used for reading data. While the client is connected, (function <code class="literal">connected</code> returns true), we check if data is available. The function <code class="literal">available</code> returns the number of bytes available for reading, so while it returns a number greater than 0, we can read data and process them.</p><p>The function <code class="literal">millis</code> returns the number of milliseconds since the board has been turned on, with the following instructions:</p><div class="informalexample"><pre class="programlisting">if (millis() / 1000 - lastActivation &gt;= ACTIVATION_CHECK_INTERVAL &amp;&amp; !manualMode) {

    lastActivation = millis() / 1000;
    checkActivations();
  }</pre></div><p>The function <code class="literal">checkActivations</code> is called every <code class="literal">ACTIVATION_CHECK_INTERVAL</code> seconds.</p><p>The <code class="literal">checkActivations</code> function checks each activation (which has a name) and based on the current time, turns the appliance on or off.</p><p>If the current time is between the activation start time and activation start time plus the activation length, the appliance has to be powered up.</p><p>Please, note that the start time is in seconds since 1 January 1970. On the other hand, the length is in minutes.</p><p>If the<a id="id187" class="indexterm"/> appliance is turned on and the current time is greater than the start time plus the activation length, it has to be turned off. Then the activation is scaled of one period in order to be ready for the next activation.</p><div class="informalexample"><pre class="programlisting">activations[i].startTime += 60 * activations[i].period;</pre></div><div class="note" title="Note"><h3 class="title"><a id="note08"/>Note</h3><p>Since <code class="literal">checkActivations</code> is called every <code class="literal">ACTIVATION_CHECK_INTERVAL</code> seconds, an activation may be delayed by <code class="literal">ACTIVATION_CHECK_INTERVAL</code> with respect to its original time.</p></div><p>Now we can take a look at the commands received from the iOS device (refer to the downloaded code).</p><p>Each command starts with a byte, which represents the code of the command, and is followed by any additional data.</p><p>If the first byte is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">'A'</code>: Arduino sends all the activations to the iOS devices, using the function <code class="literal">sendActivations</code>.</li><li class="listitem"><code class="literal">'U'</code>: It's followed by one byte that represents the index of the activation (idx) to update, and by <code class="literal">sizeof(activation)</code> bytes, which represent the activation to update. Those bytes are copied on the existing activation with <code class="literal">memcpy((uint8_t *)&amp;activations[idx], (uint8_t *)&amp;inBuffer[2], sizeof(activation))</code>.</li><li class="listitem"><code class="literal">'D'</code>: It's followed by one byte that represents the index of the activation (idx) to delete.</li><li class="listitem"><code class="literal">'S'</code>: It's followed by one byte that represents the new state of the appliance which is set with <code class="literal">digitalWrite(PHOTOISOLATOR_PIN, HIGH)</code> or <code class="literal">digitalWrite(PHOTOISOLATOR_PIN, LOW)</code>. If the user forces on the state of the appliance, the program enters in manual mode and activations are ignored.</li></ul></div><p>Moreover, until the iOS device is connected, Arduino sends its status using the function <code class="literal">sendStatus</code>, the first byte is the operation mode (manual or automatic) and the second one is the status of appliance (turned on or off).</p><p>The last function we have to look at is <code class="literal">updateActivations</code>. Let's suppose that we have set an activation at 1:00 P.M. which lasts for 1 minute and repeats every 2 minutes. At 12:59 P.M. we turn off the Arduino and then restart it at 2 P.M. Since 2 P.M. &gt; 1:02 P.M. (now &gt; <code class="literal">startTime</code> + 60 *period) the activation doesn't start anymore. <code class="literal">updateActivations</code> has exactly the purpose to shift in time the repeating activation, so that they can be fired properly.</p><p>
<code class="literal">updateActivations</code> is then called from the setup function and when the user gets back to automatic operations because during manual operations the activations are not checked and <a id="id188" class="indexterm"/>properly updated.</p><p>Using function <code class="literal">millis</code> to calculate current time may lead to significant errors after few days, so we periodically update time via the NTP Server with:</p><div class="informalexample"><pre class="programlisting">  // Time synchronization
  if (millis() / 1000 &gt; TIME_SYNC_INTERVAL &amp;&amp; !updatingTime) {

    updatingTime = true;
    askTime();
  }</pre></div><p>The predefined value for <code class="literal">TIME_SYNC_INTERVAL</code> updates the current time every 24 hours.</p></div></div>
<div class="section" title="iOS code"><div class="titlepage" id="aid-RL0A2"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>iOS code</h1></div></div></div><p>In this <a id="id189" class="indexterm"/>chapter, we are going to look at the iOS application<a id="id190" class="indexterm"/> to manually turn on and off the electrical appliance and managing the activations for the automatic operations.</p><p>The full<a id="id191" class="indexterm"/> code of this project can be downloaded from here:</p><p>
<a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>
</p><p>To better understand the explanations in the next paragraphs, you should open the downloaded code while reading.</p><div class="section" title="Creating the Xcode project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Creating the Xcode project</h2></div></div></div><p>The first step<a id="id192" class="indexterm"/> is to create a new project. We are going to use the template Tabbed Application again, because it provides two view controllers. In this project, we will also add another one.</p><p>Let's create a new Tabbed Application project exactly as you did in the previous chapter and name it <code class="literal">PowerPlug</code>. Then:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Rename <code class="literal">FirstViewController</code> as <code class="literal">PowerPlugViewController</code>.</li><li class="listitem">Rename <code class="literal">SecondViewController</code> as <code class="literal">WiFiConnectionViewController</code>.</li></ol><div style="height:10px; width: 1px"/></div><p>In this <a id="id193" class="indexterm"/>chapter we are going to use an additional library (<code class="literal">CocoaAsyncSocket</code> see <a class="ulink" href="http://bit.ly/1NGHDHE">http://bit.ly/1NGHDHE</a>), which simplifies the communication over a TCP/IP socket. To install the library you can follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the URL <a class="ulink" href="http://bit.ly/1NGHDHE">http://bit.ly/1NGHDHE</a>.</li><li class="listitem">Click on the <span class="strong"><strong>Download ZIP</strong></span> button (right side of the page). The file <code class="literal">CocoaAsyncSocket-master.zip</code> is downloaded into the <code class="literal">Downloads</code> folder.</li><li class="listitem">Unzip the downloaded file.</li><li class="listitem">Locate <code class="literal">GCDAsyncSocket.h</code> and <code class="literal">GCDAsyncSocket.m</code>.</li><li class="listitem">Drag these files and drop them to the Xcode project into the <span class="strong"><strong>PowerPlug</strong></span> group.</li><li class="listitem">Be sure that this option is set <span class="strong"><strong>Copy Items if needed</strong></span> (see the following screenshot) and click <span class="strong"><strong>Next</strong></span>.<div class="mediaobject"><img src="../Images/image00178.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="Adding a new view controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Adding a new view controller</h2></div></div></div><p>We now <a id="id194" class="indexterm"/>add the additional view controller class and the additional view controller graphical container that we need, using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the <code class="literal">PowerPlug</code> folder in the left panel and right click on it.</li><li class="listitem">Select <span class="strong"><strong>New File…</strong></span>.</li><li class="listitem">In the left pane select <span class="strong"><strong>iOS Source</strong></span> and in the right one select <span class="strong"><strong>Cocoa Touch Class</strong></span>, then click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Subclass</strong></span> of the list box, select <span class="strong"><strong>UITableViewController</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Class</strong></span> field enter <code class="literal">ActivationsTableViewController</code> (refer to the next screenshot) and click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>Save</strong></span> on the next window.<div class="mediaobject"><img src="../Images/image00179.jpeg" alt="Adding a new view controller"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Select <span class="strong"><strong>Main.storyboard</strong></span> in the left panel.</li><li class="listitem">Open the Utilities panel (<span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Utilities</strong></span> | <span class="strong"><strong>Show Utilities</strong></span>).</li><li class="listitem">In the Utilities panel's search field enter <code class="literal">UIViewController</code>.</li><li class="listitem">Drag the UIViewController to the storyboard.</li><li class="listitem">Select the just added view controller.</li><li class="listitem">Open the Identity Inspector (<span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Utilities</strong></span> | <span class="strong"><strong>Show</strong></span> <span class="strong"><strong>Identity inspector</strong></span>, or click on the icon circled in red in the next picture).<div class="mediaobject"><img src="../Images/image00180.jpeg" alt="Adding a new view controller"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">In <a id="id195" class="indexterm"/>the <span class="strong"><strong>Class</strong></span> list box, select <span class="strong"><strong>ActivationsTableViewController</strong></span>. View controller's class and the GUI are now tied together.</li><li class="listitem">We now have to add the new view controller into the Tab Bar of the main view controller. Pressing the <span class="emphasis"><em>Control</em></span> key, drag your mouse pointer from the <span class="strong"><strong>Tab Bar Controller</strong></span> to the <span class="strong"><strong>ActivationsTableViewController</strong></span> and then release (see the next screenshot).<div class="mediaobject"><img src="../Images/image00181.jpeg" alt="Adding a new view controller"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">When <a id="id196" class="indexterm"/>the small dialog shown in the next screenshot appears, select <span class="strong"><strong>Relationship</strong></span> <span class="strong"><strong>Segues</strong></span> | <span class="strong"><strong>view controllers</strong></span>.<div class="mediaobject"><img src="../Images/image00182.jpeg" alt="Adding a new view controller"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>Now<a id="id197" class="indexterm"/> the new view controller is added to the <span class="strong"><strong>Tab Bar</strong></span> (see next screenshot).</p><div class="mediaobject"><img src="../Images/image00183.jpeg" alt="Adding a new view controller"/></div><p style="clear:both; height: 1em;"> </p><p>We need the new view control to be the second one in the Tab Bar. To move it, you can click and drag it to the desired position.</p><p>Don't <a id="id198" class="indexterm"/>forget to change the text in the Tool Bar, respectively to <code class="literal">PowerPlug</code>, <code class="literal">Activations</code>, and <code class="literal">Configuration</code>.</p><div class="note" title="Note"><h3 class="title"><a id="note09"/>Note</h3><p>In the downloaded code, you find three icons to use with each view controller.</p></div><p>Since we need to show details of the elements in the table, we need to embed the ActivationsTableViewController in a navigation controller:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>ActivationsTableViewController</strong></span>.</li><li class="listitem">Select <span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>Embed in…</strong></span> | <span class="strong"><strong>Navigation Controller</strong></span>.</li></ol><div style="height:10px; width: 1px"/></div><p>You should end up with a structure similar to the one shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00184.jpeg" alt="Adding a new view controller"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Adding a class for storing the information of each activation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Adding a class for storing the information of each activation</h2></div></div></div><p>To<a id="id199" class="indexterm"/> store information about each activation, we need a class <code class="literal">Activation</code>.</p><div class="note" title="Note"><h3 class="title"><a id="tip31"/>Tip</h3><p>
<span class="strong"><strong>Model View Controller</strong></span>
</p><p>Technically speaking, we are now creating the "Model" of the Model View Controller<a id="id200" class="indexterm"/> pattern. You can find a brief introduction <a id="id201" class="indexterm"/>of the MVC pattern here: <a class="ulink" href="http://apple.co/1hkUDbU">http://apple.co/1hkUDbU</a> and a complete discussion here: <a class="ulink" href="http://apple.co/1EEpNzL">http://apple.co/1EEpNzL</a>.</p></div><p>To create the class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the <span class="strong"><strong>PowerPlug</strong></span> group in the left panel, right-click it and then select <span class="strong"><strong>New File…</strong></span>.</li><li class="listitem">In the left panel, select <span class="strong"><strong>Source</strong></span> and in the right panel, select <span class="strong"><strong>Cocoa Touch Class</strong></span>, then click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Select <span class="strong"><strong>NSObject</strong></span> in the <span class="strong"><strong>Subclass</strong></span> list box.</li><li class="listitem">Enter <code class="literal">Activation</code> in <span class="strong"><strong>Class Text Field</strong></span> (see next picture) and click <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>Save</strong></span>.<div class="mediaobject"><img src="../Images/image00185.jpeg" alt="Adding a class for storing the information of each activation"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Open the <code class="literal">Activation.h</code> file and <a id="id202" class="indexterm"/>enter the following code:<div class="informalexample"><pre class="programlisting">@interface Activation : NSObject

@property (nonatomic,strong) NSString   *name;
@property (nonatomic,strong) NSDate     *start;
@property                    NSInteger  length;   // minutes
@property                    NSInteger  period;   // minutes

@end</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>The project is now ready for the next steps, and we can start working on the view controllers.</p></div><div class="section" title="Designing the application user interface for WiFiConnectionViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Designing the application user interface for WiFiConnectionViewController</h2></div></div></div><p>As we did in the previous project, we<a id="id203" class="indexterm"/> start from the view controller, which allows us to enter the connection information.</p><p>It is made of two labels, two fields to enter the IP address, the IP port assigned to the Arduino and a button to update the connection information.</p><p>Please refer to the following screenshot to design it:</p><div class="mediaobject"><img src="../Images/image00186.jpeg" alt="Designing the application user interface for WiFiConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Since both fields accept only numbers and periods, we can make a properly set keyboard to help the user. To do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select a field.</li><li class="listitem">Open the Identity<a id="id204" class="indexterm"/> Inspector (<span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Utilities</strong></span> | <span class="strong"><strong>Show</strong></span> <span class="strong"><strong>Identity inspector</strong></span>).</li><li class="listitem">Select <span class="strong"><strong>Numbers and Punctuation</strong></span> in the <span class="strong"><strong>Keyboard Type</strong></span> list box.</li></ol><div style="height:10px; width: 1px"/></div><p>Now, link the user interface components to the code ending with the following in <code class="literal">WiFiConnectionViewController.m</code>:</p><div class="informalexample"><pre class="programlisting">@interface WiFiConnectionViewController ()

@property (strong, nonatomic) IBOutlet UITextField *ipField;
@property (strong, nonatomic) IBOutlet UITextField *portField;

@end

and:

- (IBAction)updateConnectionInformation:(UIButton *)sender {
    
}</pre></div><p>Don't forget to link the <code class="literal">UITextFields</code> delegate to the view controller.</p><p>Refer to the downloaded code for more details and compare your results with the provided application.</p></div><div class="section" title="Designing the application user interface for PowerPlugViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Designing the application user interface for PowerPlugViewController</h2></div></div></div><p>This view<a id="id205" class="indexterm"/> controller manages the manual operation with the power plug that is capable of manually switching on and off the power to the hooked device.</p><p>The final layout of this view controller is shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00187.jpeg" alt="Designing the application user interface for PowerPlugViewController"/></div><p style="clear:both; height: 1em;"> </p><p>The component <a id="id206" class="indexterm"/>numbered <span class="strong"><strong>1</strong></span> is a <code class="literal">UIImageView</code> and its purpose is to show if the hooked appliance is powered on or off. To add this component, just drag and drop it and select the image (<code class="literal">LEDdisabled.png</code> that you can find in the downloaded project) to to be displayed, using the <span class="strong"><strong>Attributes Inspector</strong></span>. The size of the image view is 60 × 60, which can be set adding the proper layout constraints.</p><p>The component numbered <span class="strong"><strong>2</strong></span> is a switch button (<code class="literal">UISwitch</code>) to actually switch the appliance on and off manually. We can add this component to the container like we did with the others.</p><p>The component numbered <span class="strong"><strong>3</strong></span> is a button (<code class="literal">UIButton</code>) to reconnect to Arduino in case the connection is lost and the component numbered <span class="strong"><strong>4</strong></span> is a <code class="literal">UIView</code>, which shows if the Arduino is connected or not by the means of its color (light gray: disconnected, green: connected).</p><p>Once you have added the components and the required Auto Layout constraints, you can link the components to the <a id="id207" class="indexterm"/>code ending with:</p><div class="informalexample"><pre class="programlisting">@interface PowerPlugViewController ()

@property (strong, nonatomic) IBOutlet UIImageView  *applianceStatus;
@property (strong, nonatomic) IBOutlet UIView       *connectionStatus;
@property (strong, nonatomic) IBOutlet UISwitch     *manualOperationButton;

@end</pre></div></div><div class="section" title="Designing the application user interface for ActivationsTableViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Designing the application user interface for ActivationsTableViewController</h2></div></div></div><p>The <a id="id208" class="indexterm"/>ActivationsTableViewController view controller shows all the existing activations in a table.</p><p>First, we have to add a class to store information about the cell of each row in the table. To add this class, follow the same steps used in the previous chapters subclassing from <code class="literal">UITableViewCell</code> and calling the class <code class="literal">ActivationTableViewCell</code> (see next screenshot).</p><div class="mediaobject"><img src="../Images/image00188.jpeg" alt="Designing the application user interface for ActivationsTableViewController"/></div><p style="clear:both; height: 1em;"> </p><p>In the <code class="literal">ActivationTableViewCell.h</code> file, change the code as follows:</p><div class="informalexample"><pre class="programlisting">@interface ActivationTableViewCell : UITableViewCell

@property (strong, nonatomic) IBOutlet UILabel *name;
@property (strong, nonatomic) IBOutlet UILabel *start;
@property (strong, nonatomic) IBOutlet UILabel *end;
@property (strong, nonatomic) IBOutlet UILabel *period;


@end</pre></div><p>We are <a id="id209" class="indexterm"/>now ready to create the custom cell to show each activation information of the power plug, and link it with the ActivationTableViewCell. We are going to show only the main steps, but you can refer to the downloaded code for all the details.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <span class="strong"><strong>Main.storyboard</strong></span>, select the <span class="strong"><strong>ActivationsTableViewController</strong></span> and then the <span class="strong"><strong>Prototypes Cells</strong></span> in it.</li><li class="listitem">Open the Identity Inspector and select <span class="strong"><strong>ActivationTableViewCell</strong></span> in the <span class="strong"><strong>Class</strong></span> list box.</li><li class="listitem">Select the Attribute Inspector.</li><li class="listitem">Enter <code class="literal">activationCell</code> in the <span class="strong"><strong>Identifier</strong></span> field.</li><li class="listitem">Select the Size Inspector and 66 in the <span class="strong"><strong>Row Height</strong></span> field.</li><li class="listitem">Now you can enter the labels (UILabel) to show the different information of each activation, change colors and font sizes, and add the layout constraints ending with a cell prototype like that shown in the next screenshot:<div class="mediaobject"><img src="../Images/image00189.jpeg" alt="Designing the application user interface for ActivationsTableViewController"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>We now have to link <a id="id210" class="indexterm"/>the cell components to the class ActivationTableViewCell.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to <span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>Show Document Outline</strong></span> (you can also open this panel using the icon circled red in the next screenshot).</li><li class="listitem">Locate the <span class="strong"><strong>Activations Table View Controller</strong></span> <span class="strong"><strong>Scene</strong></span> and expand it (see next screenshot).<div class="mediaobject"><img src="../Images/image00190.jpeg" alt="Designing the application user interface for ActivationsTableViewController"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Select<a id="id211" class="indexterm"/> the <span class="strong"><strong>activationCell</strong></span> and right-click on it.</li><li class="listitem">Keeping the <span class="emphasis"><em>Control</em></span> key pressed, drag each property of the class to the related graphical component (see the next screenshot).<div class="mediaobject"><img src="../Images/image00191.jpeg" alt="Designing the application user interface for ActivationsTableViewController"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>We need to <a id="id212" class="indexterm"/>complete the last step: creating the view controller for entering and editing each activation (ActivationViewController).</p><p>We start adding a new class inherited from UIViewController called <code class="literal">ActivationViewController</code>, then we drag and drop a new view controller into the <span class="strong"><strong>Main.Storyboard</strong></span>, and we change its class to <code class="literal">ActivationViewController</code>
<span class="strong"><strong> </strong></span>in the <span class="strong"><strong>Identity Inspector</strong></span>.</p><p>This<a id="id213" class="indexterm"/> view controller uses two new components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">UIDatePicker: It allows the user to choose a date. In our case, the date at which<a id="id214" class="indexterm"/> the activation has to start.</li><li class="listitem">UISegmentControl: It<a id="id215" class="indexterm"/> allows the user to easily choose the length of activation and how often the activation has to be started.</li></ul></div><p>The final layout of the controller is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00192.jpeg" alt="Designing the application user interface for ActivationsTableViewController"/></div><p style="clear:both; height: 1em;"> </p><p>The component <a id="id216" class="indexterm"/>can be dropped into the container as we already have learned, and we can set their layout constraints as we did in the other view controllers. The components are linked to the code as usual:</p><div class="informalexample"><pre class="programlisting">@property (nonatomic,weak) Activation *activation;

@property (strong, nonatomic) IBOutlet UITextField          *nameField;
@property (strong, nonatomic) IBOutlet UIDatePicker         *date;
@property (strong, nonatomic) IBOutlet UITextField          *length;
@property (strong, nonatomic) IBOutlet UISegmentedControl   *lengthScale;
@property (strong, nonatomic) IBOutlet UITextField          *period;
@property (strong, nonatomic) IBOutlet UISegmentedControl   *periodScale;

@end</pre></div><p>In order to <a id="id217" class="indexterm"/>edit activations, we need the ActivationViewController to show when the user taps on a row of the table. To do this, we have to create a segue from the cell to the view controller with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Keeping <span class="emphasis"><em>Control</em></span> pressed, drag your mouse pointer from the cell to the ActivationViewController (see the following screenshot).<div class="mediaobject"><img src="../Images/image00193.jpeg" alt="Designing the application user interface for ActivationsTableViewController"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">When the black dialog appears, select <span class="strong"><strong>show</strong></span>:<div class="mediaobject"><img src="../Images/image00194.jpeg" alt="Designing the application user interface for ActivationsTableViewController"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>You can <a id="id218" class="indexterm"/>find all the details about the ActivationViewController in the downloaded code.</p><p>This ActivationsTableViewController is finally completed. Let's take a breath and sip a cup of coffee before getting into writing the code of our view controllers. It has been a long and complex run, and we actually deserve a cup of coffee (or tea if you prefer!).</p></div><div class="section" title="Writing code for the WiFiConnectionViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Writing code for the WiFiConnectionViewController</h2></div></div></div><p>This <a id="id219" class="indexterm"/>view controller has the purpose to make sure the user enters the IP address and IP port assigned to Arduino in order to connect to it.</p><p>In this project, we are going to store this information in a file, instead of storing it in User Preferences as we did in the Pet Door Locker.</p><p>When the update button is tapped, this code is executed:</p><div class="informalexample"><pre class="programlisting">- (IBAction)updateConnectionInformation:(UIButton *)sender {
    
    if (![self validateIpAddress:_ipField.text]) {
        
        
        …
        
        return;
    }
    
    if ([_portField.text integerValue]&lt;0 || [_portField.text integerValue]&gt;65535) {
        
        …
        
        return;
    }
    
    NSMutableDictionary *connectionInformation = [[NSMutableDictionary alloc] init];
    
    [connectionInformation setValue:_ipField.text forKey:@"IP"];
    [connectionInformation setValue:_portField.text forKey:@"PORT"];
    
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths objectAtIndex:0];
    NSString *path = [documentsDirectory stringByAppendingPathComponent:@"connection.plist"];
    
    [connectionInformation writeToFile:path atomically:YES];
}</pre></div><p>The values of the two fields <a id="id220" class="indexterm"/>are stored in an NSMutableDictionary (<code class="literal">connectionInformation</code>) and stored into a file called <code class="literal">writeToFile</code>. This file is saved into a directory <code class="literal">documentsDirectory</code> that is accessible by the application only.</p><p>Before saving the information, we need to check that the IP address is properly formatted, and that the port is in the allowed range (see the downloaded code for all the details).</p><p>Since we set the text field's delegate properties, each time the user is done editing the field, one of the following methods is called and we can make the keyboard disappear using <code class="literal">resignFirstResponder</code>.</p><div class="informalexample"><pre class="programlisting">- (void)textFieldDidEndEditing:(UITextField *)textField {
    
    [textField resignFirstResponder];
}

- (BOOL)textFieldShouldReturn:(UITextField *)textField {
    
    [textField resignFirstResponder];
    
    return YES;
}</pre></div><p>When we tap on the text field<a id="id221" class="indexterm"/> Period, the keyboard covers it (at least on smaller devices like the iPhone). To avoid this issue, we can shift up the entire view, using a couple of delegate methods of UITextView. When we tap the field, the <code class="literal">textFieldDidBeginEditing</code> method is called, and when we exit the field or tap return, the <code class="literal">textFieldDidBeginEditing</code> method is called.</p><p>In the <code class="literal">textFieldDidBeginEditing</code> method we can translate the field, assigning a translation transformation to the field with:</p><div class="informalexample"><pre class="programlisting">self.view.transform = CGAffineTransformMakeTranslation(0, -100);</pre></div><p>Then we end with these two additional methods:</p><div class="informalexample"><pre class="programlisting">- (void)textFieldDidBeginEditing:(UITextField *)textField {
    
    if ([textField isEqual:_period]) {
        
        self.view.transform = CGAffineTransformMakeTranslation(0, -100);
    }
    
}

- (void)textFieldDidEndEditing:(UITextField *)textField {
    
    if ([textField isEqual:_period]) {
        
        self.view.transform = CGAffineTransformMakeTranslation(0, 0);
    }
}</pre></div><p>Each time this view controller is shown, both fields are filled in with the existing values.</p><div class="informalexample"><pre class="programlisting">- (void)viewDidLoad {
    [super viewDidLoad];
    
    
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths objectAtIndex:0];
    NSString *path = [documentsDirectory stringByAppendingPathComponent:@"connection.plist"];
    
    NSDictionary *connectionInformation = [NSDictionary dictionaryWithContentsOfFile:path];
    
    if (connectionInformation != nil) {
        _ipField.text = [connectionInformation objectForKey:@"IP"];
        _portField.text = [connectionInformation objectForKey:@"PORT"];
    }

}</pre></div></div><div class="section" title="Writing code for AppDelegate"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Writing code for AppDelegate</h2></div></div></div><p>In this<a id="id222" class="indexterm"/> project, the connection to Arduino and the communication is managed into <code class="literal">AppDelegate</code>.</p><p>For this purpose, we need some properties:</p><div class="informalexample"><pre class="programlisting">@interface AppDelegate ()

@property (strong, nonatomic) GCDAsyncSocket                    *socket;
@property (strong, nonatomic) NSMutableArray                    *activations;

@property (strong, nonatomic) PowerPlugViewController           *powerPlugViewController;
@property (strong, nonatomic) ActivationsTableViewController    *activationsViewController;

@end</pre></div><p>The <code class="literal">socket</code> property (provided by the library we added) is a channel used for sending and receiving data from Arduino. The array <code class="literal">activations</code> stores all the activations the user creates.</p><p>When the app starts or enters in the foreground, it starts a connection with Arduino:</p><div class="informalexample"><pre class="programlisting">-(void)connect {
    
    NSError *err = nil;
    
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths objectAtIndex:0];
    NSString *path = [documentsDirectory stringByAppendingPathComponent:@"connection.plist"];
    
    NSDictionary *connectionInformation = [NSDictionary dictionaryWithContentsOfFile:path];
    
    if (![_socket connectToHost:[connectionInformation objectForKey:@"IP"]
                         onPort:[[connectionInformation objectForKey:@"PORT"] integerValue]
                          error:&amp;err]) {
        NSLog(@"Connection Failed %@", [err localizedDescription]);
        
        return;
    }
    
    [_socket readDataWithTimeout:5 tag:0];
}</pre></div><p>If the <a id="id223" class="indexterm"/>connection to Arduino is successful, the delegate method <code class="literal">didConnectToHost</code> is called.</p><p>The method <code class="literal">readDataWithTimeout</code> allows you to receive data from the counterpart: when data is available, the method <code class="literal">didReadData</code> is called.</p><p>Since we have set a timeout (5 seconds), if no data is received within this time interval, the method <code class="literal">socketDidDisconnect</code> is called.</p><p>Let's take a look at each method.</p><div class="informalexample"><pre class="programlisting">- (void)socket:(GCDAsyncSocket *)sender didConnectToHost:(NSString *)host port:(UInt16)port {
    
    [_powerPlugViewController arduinoConnected];
}</pre></div><p>Here, we just notify the <code class="literal">PowerPlugViewController</code> instance that the connection was successful.</p><div class="informalexample"><pre class="programlisting">- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)error {
    
    [_powerPlugViewController arduinoDisconnected];
    _activations = nil;
}</pre></div><p>Here, we<a id="id224" class="indexterm"/> just notify the <code class="literal">PowerPlugViewController</code> instance that the Arduino has disconnected, and we release the activations we were using.</p><p>From Arduino we can receive two kinds of messages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Status</strong></span>: It starts <a id="id225" class="indexterm"/>with character <code class="literal">'S'</code> and it's followed by two bytes:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">First byte is 1 if the appliance has been turned on manually, 0 otherwise</li><li class="listitem">Second byte is the status of the appliance: 0 if it's switched off, 1 if it is switched on</li></ul></div></li><li class="listitem"><span class="strong"><strong>Activations</strong></span>: It <a id="id226" class="indexterm"/>starts with character <code class="literal">'A'</code> and it's followed by <code class="literal">ACTIVATION_SIZE_ON_ARDUINO * NUMBER_OF_ACTIVATIONS</code> bytes which represent activations</li></ul></div><p>Messages coming from Arduino are received in the following method, and are processed following the previous rules.</p><div class="informalexample"><pre class="programlisting">- (void)socket:(GCDAsyncSocket *)sender didReadData:(NSData *)data withTag:(long)tag {
    
    NSLog(@"Bytes received %lu",(unsigned long)[data length]);

    if ([data length]&lt;3) {
        return;
    }
    
    NSString* answerType = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 1)]
                                             encoding:NSASCIIStringEncoding];
    
    // S&lt;manual&gt;&lt;appliance status&gt;
    // A&lt;activations&gt;
    
    
    if ([answerType isEqualToString:@"S"]) {
        
        BOOL manual;
        BOOL status;
        
        [[data subdataWithRange:NSMakeRange(1, 1)] getBytes: &amp;manual length: 1];
        [[data subdataWithRange:NSMakeRange(2, 1)] getBytes: &amp;status length: 1];
        
        [_powerPlugViewController updateStatus:manual applianceStatus:status];
    }
    
    if ([answerType isEqualToString:@"A"]) {
        
        if (data.length &lt; (ACTIVATION_SIZE_ON_ARDUINO * NUMBER_OF_ACTIVATIONS + 1)) {
            
            NSLog(@"Error reading data");
            
            return;
        }
        
        for (int i=0; i&lt;NUMBER_OF_ACTIVATIONS; i++) {
            
            NSData *nameData = [data subdataWithRange:NSMakeRange(1+ACTIVATION_SIZE_ON_ARDUINO*i, 21)];
            NSString *name = [NSString stringWithCString:nameData.bytes encoding:NSASCIIStringEncoding];
            
            if (name.length&gt;0) {
                
                NSData *startData = [data subdataWithRange:NSMakeRange(1+ACTIVATION_SIZE_ON_ARDUINO*i+21, 4)];
                
                NSInteger start=0;
                [startData getBytes: &amp;start length: 4];
                
                NSData *lengthData = [data subdataWithRange:NSMakeRange(1+ACTIVATION_SIZE_ON_ARDUINO*i+21+4, 2)];
                
                NSInteger length=0;
                [lengthData getBytes: &amp;length length: 2];
                
                NSData *periodData = [data subdataWithRange:NSMakeRange(1+ACTIVATION_SIZE_ON_ARDUINO*i+21+4+2, 2)];
                
                NSInteger period=0;
                [periodData getBytes: &amp;period length: 2];
                
                Activation *activation = [[Activation alloc] init];
                activation.name = name;
                activation.start = [NSDate dateWithTimeIntervalSince1970:start];
                activation.length = length;
                activation.period = period;
                
                [_activations addObject:activation];
            }
        }
        
        [_activationsViewController dataReceived];
    }
    
    [sender readDataWithTimeout:5 tag:0];
}</pre></div><p>If a<a id="id227" class="indexterm"/> Status message is received, the <code class="literal">PowerPlugViewController</code> instance is notified:</p><div class="informalexample"><pre class="programlisting"> [_powerPlugViewController updateStatus:manual applianceStatus:status];</pre></div><p>If an Activations message is received, each activation is added to <code class="literal">_activations</code>:</p><div class="informalexample"><pre class="programlisting">[_activations addObject:activation];</pre></div><p>In the end, the instance of ActivationsViewController is notified that all the activations are available:</p><div class="informalexample"><pre class="programlisting">[_activationsViewController dataReceived];</pre></div><p>AppDelegate also implements delegate methods for PowerPlugViewController and ActivationsViewController view controllers.</p><p>For ActivationsViewController, the implemented methods are <code class="literal">getActivations</code>, <code class="literal">updateActivationOfIndex</code>, and <code class="literal">deleteActivationOfIndex</code>.</p><p>The method <code class="literal">getActivations</code> is called by the ActivationsViewController when it needs to show the list of configured activations.</p><div class="informalexample"><pre class="programlisting">-(NSMutableArray *)getActivations {
    
    if (_activations == nil) {
    
        _activations = [[NSMutableArray alloc] init];
        
        NSString *message = @"A";
        [_socket writeData:[message dataUsingEncoding:NSASCIIStringEncoding] withTimeout:-1 tag:0];
        
        [_activationsViewController dataRequested];
        
        return _activations;
    }
    
    return _activations;
}</pre></div><p>If <code class="literal">_activations</code> is nil, a message to Arduino is sent which will respond with the list of all the activations. The message is very easy: only one byte with the value <code class="literal">'A'</code> (Activations).</p><p>The<a id="id228" class="indexterm"/> message is actually sent to Arduino calling:</p><div class="informalexample"><pre class="programlisting">[_socket writeData:[message dataUsingEncoding:NSASCIIStringEncoding] withTimeout:-1 tag:0];</pre></div><p>The method <code class="literal">updateActivationOfIndex</code> is called by ActivationsViewController when an activation has been updated (or added). The method <code class="literal">deleteActivationOfIndex</code> is called by ActivationsViewController when an activation has to be deleted.</p><p>For the complete implementation of these two methods, look at the downloaded code.</p><p>Methods implemented for PowerPlugViewController are <code class="literal">sendSwitchCommand</code> and <code class="literal">reconnect</code>, which are very easy and you can understand them directly from the downloaded code.</p></div><div class="section" title="Writing code for PowerPlugViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Writing code for PowerPlugViewController</h2></div></div></div><p>This view controller manages <a id="id229" class="indexterm"/>manual operations of the appliance attached to the power plug.</p><p>First, we need to declare the delegate methods and messages to which this view controller responds.</p><div class="informalexample"><pre class="programlisting">@protocol PowerPlugViewControllerDelegate &lt;NSObject&gt;

-(void)sendSwitchCommand:(BOOL)on;
-(void)reconnect;

@end

@interface PowerPlugViewController : UIViewController 

-(void)arduinoConnected;
-(void)arduinoDisconnected;
-(void)updateStatus:(BOOL)manual applianceStatus:(BOOL)applianceStatus;

@property (strong, nonatomic) id&lt;PowerPlugViewControllerDelegate&gt; delegate;

@end</pre></div><p>This view controller is very <a id="id230" class="indexterm"/>easy and its methods are quite auto explicative and self explanatory. We just need to take a look at <code class="literal">updateStatus</code>:</p><div class="informalexample"><pre class="programlisting">-(void)updateStatus:(BOOL)manual applianceStatus:(BOOL)applianceStatus {
    
    _manualOperationButton.on = manual;
    
    if (applianceStatus)
        _applianceStatus.image = [UIImage imageNamed:@"LEDon.png"];
    else
        _applianceStatus.image = [UIImage imageNamed:@"LEDoff.png"];
}</pre></div><p>When the <code class="literal">applianceStatus</code> is true, the appliance is turned on, and we set the image <code class="literal">LEDon.png</code> to the imageView (<code class="literal">_applianceStatus</code>). This image simulates an LED turned on. When the appliance is turned off, the image shown is <code class="literal">LEDoff.png</code>, which simulates an LED being turned off.</p></div><div class="section" title="Writing code for ActivationsTableViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Writing code for ActivationsTableViewController</h2></div></div></div><p>This view controller<a id="id231" class="indexterm"/> manages the list of activations, allowing the user to add, delete, and update each activation. It is based on the UITableView component, which is one of the most used and powerful components of the UIKit.</p><p>Let's start from <code class="literal">ActivationsTableViewController.h</code>:</p><div class="informalexample"><pre class="programlisting">@protocol ActivationsTableViewControllerDelegate &lt;NSObject&gt;

-(NSMutableArray *)getActivations;
-(void)updateActivationOfIndex:(uint8_t)index;
-(void)deleteActivationOfIndex:(uint8_t)index;

@end

@interface ActivationsTableViewController : UITableViewController &lt;ActivationViewControllerDelegate&gt;

@property (strong, nonatomic) id&lt;ActivationsTableViewControllerDelegate&gt; delegate;

-(void)dataRequested;
-(void)dataReceived;

@end</pre></div><p>By now, you should be <a id="id232" class="indexterm"/>able to recognize the delegate protocol and messages to which the view controller responds.</p><p>Let's start from the implementation of the UITableView delegate methods. The first is <code class="literal">numberOfRowsInSection</code>, which is called from the table when it needs to know how many items it has to show:</p><div class="informalexample"><pre class="programlisting">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    
    return [_delegate getActivations].count;
}</pre></div><p>It doesn't require many explanations. The method <code class="literal">cellForRowAtIndexPath</code> is called by the UIViewTable for each row to be shown:</p><div class="informalexample"><pre class="programlisting">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    ActivationTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"activationCell"];
    if (cell == nil) {
        cell = [[ActivationTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"activationCell"];
    }
    
    Activation *activation = [_delegate getActivations][indexPath.row];
    
    cell.name.text = activation.name;
    
    NSDateFormatter *dateFormatter =  [[NSDateFormatter alloc] init];
    [dateFormatter setDateStyle:NSDateFormatterShortStyle];
    [dateFormatter setTimeStyle:NSDateFormatterMediumStyle];
    
    NSDate *endDate = [activation.start dateByAddingTimeInterval:60*activation.length];
    cell.start.text = [dateFormatter stringFromDate:activation.start];
    cell.end.text = [dateFormatter stringFromDate:endDate];
    
    ….

    return cell;
}</pre></div><p>Calling the method <code class="literal">[tableView dequeueReusableCellWithIdentifier:@"activationCell"]</code> we get a cell and we fill it with the values of one activation.</p><p>If the previous function <a id="id233" class="indexterm"/>returns nil, there is not an available cell, and one has to be created with:</p><div class="informalexample"><pre class="programlisting">cell = [[ActivationTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"activationCell"];</pre></div><p>Take a look at the downloaded code to see the full method implementation.</p><p>When a row is deleted from the UITableView, the following method is called:</p><div class="informalexample"><pre class="programlisting">- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
    
    
    if (editingStyle == UITableViewCellEditingStyleDelete) {
        
        [[_delegate getActivations] removeObjectAtIndex:indexPath.row];
        
        [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];
        
        [_delegate deleteActivationOfIndex:indexPath.row];
    }
}</pre></div><p>Method <code class="literal">deleteRowsAtIndexPaths</code> removes the row from the table and the delegate method <code class="literal">deleteActivationOfIndex</code> creates a message that is then sent to Arduino for deleting an activation.</p><p>When designing the <a id="id234" class="indexterm"/>interface we created a segue from the table cell to the ActivationViewController in order that when the user taps a table row, the ActivationViewController appears.</p><p>Before the ActivationViewController is started, the method <code class="literal">prepareForSegue</code> is called:</p><div class="informalexample"><pre class="programlisting">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    
    ActivationViewController *activationViewController = (ActivationViewController *)[segue destinationViewController];
    activationViewController.delegate = self;
    
    NSIndexPath *p = [self.tableView indexPathForSelectedRow];
    
    NSMutableArray *activations = [_delegate getActivations];
    if (activations==nil)
        return;
    
    _selectedActivationIndex = p.row;
    
    [self.tableView deselectRowAtIndexPath:p animated:NO];
}</pre></div><p>Here we set the delegate property of ActivationViewController and we store the index of the selected row.</p><div class="note" title="Note"><h3 class="title"><a id="tip32"/>Tip</h3><p>
<span class="strong"><strong>Segue identifier</strong></span>
</p><p>The<a id="id235" class="indexterm"/> method <code class="literal">prepareForSegue</code> is called for each segue that starts from the view controller. Usually, different target view controllers require different initialization code. In the Interface Builder you can set the <span class="strong"><strong>Identifier</strong></span> of each segue, and use these instructions for distinguishing between segues:</p><div class="informalexample"><pre class="programlisting">if ([segue.identifier isEqualToString:"&lt;identifier&gt;"]) {
….
}</pre></div></div><p>The ActivationViewController requires two delegate methods, which don't require any explanation:</p><p>The first is <code class="literal">getActivation</code>:</p><div class="informalexample"><pre class="programlisting">-(Activation *)getActivation {
    
    return [_delegate getActivations][_selectedActivationIndex];
}</pre></div><p>The second is <code class="literal">update</code>:</p><div class="informalexample"><pre class="programlisting">-(void)update {
    
    [self.delegate updateActivationOfIndex:_selectedActivationIndex];
    [self.tableView reloadData];
}</pre></div><p>We just point <a id="id236" class="indexterm"/>out that <code class="literal">[self.tableView reloadData]</code> forces the table view to reload data, starting from calling <code class="literal">numberOfRowsInSection</code> and then calling <code class="literal">cellForRowAtIndexPath</code> for each row.</p></div><div class="section" title="Writing code for ActivationTableViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Writing code for ActivationTableViewController</h2></div></div></div><p>This view <a id="id237" class="indexterm"/>controller doesn't do much more than getting the user entered values and updating the selected activation.</p><p>To understand the details, refer to the code provided with the book.</p></div><div class="section" title="Testing and tuning"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Testing and tuning</h2></div></div></div><p>When<a id="id238" class="indexterm"/> you have completed your application, you can<a id="id239" class="indexterm"/> test the system following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change IP information (IP, gateway, and so on) and network information (SSID, pass) in the Arduino sketch to adapt them to your own network configuration. You may need to access your router configuration page to get this information.</li><li class="listitem">Upload the sketch to Arduino.</li><li class="listitem">Check the Arduino console for any error messages.</li><li class="listitem">Connect the driver circuit to the power line and to an external appliance (a lamp can do the job). Please, follow all the required security measures to avoid any electric shocks.</li><li class="listitem">Run the iOS application on your device or in the simulator.</li><li class="listitem">Tap on Configuration and enter the IP address and port you have set in the Arduino sketch.</li><li class="listitem">Tap<a id="id240" class="indexterm"/> on the power plug, connect and<a id="id241" class="indexterm"/> switch the button on and off. You should see the external appliance turning on and off accordingly. Then turn off your appliance.</li><li class="listitem">Tap on Activations and enter an activation. You should see your appliance automatically turning on and then off accordingly with the time and values you have entered.</li></ol><div style="height:10px; width: 1px"/></div><p>If you <a id="id242" class="indexterm"/>are not able to get the time from the NTP server, you may try to change the address. To find a new address, you can look at the link <a class="ulink" href="http://tf.nist.gov/tf-cgi/servers.cgi">http://tf.nist.gov/tf-cgi/servers.cgi</a> or send a <code class="literal">ping</code> to the address <code class="literal">time.nist.gov</code> and use the returning address.</p></div></div>
<div class="section" title="How to access the power plug from anywhere in the world" id="aid-SJGS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>How to access the power plug from anywhere in the world</h1></div></div></div><p>In this<a id="id243" class="indexterm"/> section, you will learn the basics to access your Arduino board from outside your home network. In other words, you will be able to use the iOS application through the mobile network to access your power plug behind your home router/firewall.</p><div class="note" title="Note"><h3 class="title"><a id="note10"/>Note</h3><p>This section is provided for reference only because there are so many routers available in the market, and there are so many network configurations, that it is actually impossible to provide a complete guide. Anyway, with this brief overview of the matter, you should be able to configure your own devices.</p></div><div class="section" title="Port forwarding"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Port forwarding</h2></div></div></div><p>The<a id="id244" class="indexterm"/> next picture shows the typical configuration of a domestic network.</p><div class="mediaobject"><img src="../Images/image00195.jpeg" alt="Port forwarding"/></div><p style="clear:both; height: 1em;"> </p><p>Let's <a id="id245" class="indexterm"/>suppose that your IP addresses are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Router WAN IP: 82.61.147.56</li><li class="listitem">Router LAN IP: 192.168.1.1</li><li class="listitem">Arduino Board IP: 192.168.1.4</li></ul></div><p>Typically, the IP address of the Arduino board on your internal network is not visible from the external network, at least unless you don't explicitly configure your router. This configuration is called IP port forwarding.</p><p>Basically, this configuration instructs the router to transfer the traffic it receives on a specific port to another IP address on a specific port.</p><p>That said, your port forwarding configuration has to be something like this:</p><p>(82.61.147.56, 230) --&gt; (192.168.1.4, 230)</p><p>Accessing your router configuration page (usually via browser), you should be able to get the current IP that your Internet service provider has assigned to your router and configure the port forwarding. Read your router manual to learn how to set up this configuration.</p><p>Once you have configured port forwarding, you can access the Arduino board using:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>IP</strong></span>: 82.61.147.56 (or better, the actual IP address assigned your own router)</li><li class="listitem"><span class="strong"><strong>Port</strong></span>: 230</li></ul></div><div class="note" title="Note"><h3 class="title"><a id="tip33"/>Tip</h3><p>
<span class="strong"><strong>Pay attention to security!</strong></span>
</p><p>Once<a id="id246" class="indexterm"/> you enable the port forwarding, anyone can access it. This means that anyone can easily get access to your power plug and control it. We should implement a protocol, which authenticates the iOS device, and encrypts all the messages exchanged. Unfortunately, Arduino does not have enough processing power and memory for this task. If you want to keep communication between an iOS device and Arduino<a id="id247" class="indexterm"/> secure, you have to set up a Virtual Private Network (<a class="ulink" href="http://bit.ly/1ENoe3o">http://bit.ly/1ENoe3o</a>). There are many routers that provide a VPN, and iOS supports it natively.</p></div></div><div class="section" title="Dynamic DNS"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Dynamic DNS</h2></div></div></div><p>Typically, each <a id="id248" class="indexterm"/>time your router connects to the Internet, it gets a different public IP address. So, you need to change the IP address of Arduino Manager each time your router is restarted. This is not practical.</p><p>Many <span class="strong"><strong>Dynamic Domain Name Services</strong></span> (<span class="strong"><strong>DDNS</strong></span>) are available to dynamically associate the same <a id="id249" class="indexterm"/>name to your router IP address, even if the address changes. Most are available for free, among them: NoIP, yDNS, and FreeDNS.</p><p>Most routers have DDNS client ready to use and easy to configure, otherwise, you may need to install simple software on a computer connected to your network.</p><p>Please visit the service provider's site to sign up and get installation and configuration procedures. Moreover, check your router for DDNS service availability.</p><p>Once you have configured the Dynamic DNS service of your choice and supposing that you have chosen a domain like <code class="literal">powerplug.something.com</code>, you can access the Arduino with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>IP</strong></span>: <code class="literal">powerplug.something.com</code></li><li class="listitem"><span class="strong"><strong>Port</strong></span>: 230</li></ul></div><p>And you don't need to change them when you reboot your router.</p></div></div>
<div class="section" title="How to go further" id="aid-TI1E1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>How to go further</h1></div></div></div><p>The <a id="id250" class="indexterm"/>project we have developed can be improved in many ways, some improvements that you can try yourself:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Control more external appliances using more Arduino pins, and more driver circuits.</li><li class="listitem">Check and report to the user any conflicts between different activations.</li></ul></div></div>
<div class="section" title="Summary" id="aid-UGI01"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, you have built a device that allows you to control an external device (a lamp, a washing machine, a coffee kettle, and so on) manually or automatically, turning it on and off as you like, and/or at a specific time.</p><p>You have learned to make a power circuit without using a relay and manage it from Arduino.</p><p>On Arduino, you have learned to write a program that reads and writes on the SD card, uses the Wi-Fi shield to communicate to iOS devices and to an external service (to get the current time), and manages an external power circuit for controlling the external device.</p><p>On iOS, you have learned how to design the user interface for a medium complex application also using the UITableView that is one of the most used components to interact with the user. You are now able to understand the MVC pattern and take advantage of it in your own programs. Moreover, you have learned to handle TCP/IP communication via TCP socket.</p><p>The next chapter will be about coding Arduino and iOS for controlling a rover robot using the hardware features provided by the iOS devices (accelerometer).</p></div></body></html>