["```swift\n    import MapKit\n    ```", "```swift\n    class RestaurantItem: NSObjectcoordinate property, which is required to conform to MKAnnotation. You will do so shortly.\n    ```", "```swift\n    let name: String?\n    let cuisines: [String]\n    let lat: Double?\n    let long: Double?\n    let address: String?\n    let postalCode: String?\n    let state: String?\n    let imageURL: String?\n    let restaurantID: Int?\n    ```", "```swift\n    init(dict: [String: AnyObject]) {\n       self.lat = dict[\"lat\"] as? Double\n       self.long = dict[\"long\"] as? Double \n       self.name = dict[\"name\"] as? String  \n       self.cuisines = dict[\"cuisines\"] as? [String] ?? []\n       self.address = dict[\"address\"] as? String\n       self.postalCode = dict[\"postalCode\"] as? String\n       self.state = dict[\"state\"] as? String \n       self.imageURL = dict[\"image_url\"] as? String\n       self.restaurantID = dict[\"id\"] as? Int\n    }\n    ```", "```swift\n    var coordinate: CLLocationCoordinate2D {\n       guard let lat = lat, let long = long else { \n          return CLLocationCoordinate2D() \n       }\n       return CLLocationCoordinate2D(latitude: lat,\n       longitude: long)\n    }\n    ```", "```swift\n    var title: String? {\n       name\n    }\n    ```", "```swift\n    var subtitle: String? {\n       if cuisines.isEmpty { \n          return \"\" \n       } else if cuisines.count == 1 { \n          return cuisines.first \n       } else { \n          return cuisines.joined(separator: \", \") \n       }\n    }\n    ```", "```swift\n    import UIKit \n    import MapKit\n    class RestaurantItem: NSObject, MKAnnotation {\n       let name: String?\n       let cuisines: [String]\n       let lat: Double?\n       let long: Double?\n       let address: String?\n       let postalCode: String?\n       let state: String?\n       let imageURL: String?\n       let restaurantID: Int?\n       init(dict: [String: AnyObject]) {\n          self.lat = dict[\"lat\"] as? Double\n          self.long = dict[\"long\"] as? Double \n          self.name = dict[\"name\"] as? String  \n          self.cuisines = dict[\"cuisines\"] as? [String] \n          ?? []\n          self.address = dict[\"address\"] as? String\n          self.postalCode = dict[\"postalCode\"] as? String\n          self.state = dict[\"state\"] as? String \n          self.imageURL = dict[\"image_url\"] as? String\n          self.restaurantID = dict[\"id\"] as? Int\n       }\n       var coordinate: CLLocationCoordinate2D {\n          guard let lat = lat, let long = long else {\n             return CLLocationCoordinate2D() \n          }\n          return CLLocationCoordinate2D(latitude: lat,\n          longitude: long)\n       }\n       var title: String? {\n          name\n       }\n       var subtitle: String? {\n          if cuisines.isEmpty { \n             return \"\" \n          } else if cuisines.count == 1 { \n             return cuisines.first \n          } else { \n             return cuisines.joined(separator: \", \") \n          }\n       }\n    }\n    ```", "```swift\n    class MapDataManager {\n\n    }\n    ```", "```swift\n    private var items: [RestaurantItem] = []\n    var annotations: [RestaurantItem] {\n       items \n    }\n    ```", "```swift\n    private func loadData() -> [[String: AnyObject]] {\n       guard let path = Bundle.main.path(forResource:\n       \"MapLocations\", ofType: \"plist\"), \n       let itemsData = FileManager.default.contents(\n       atPath: path),\n       let items = try! PropertyListSerialization\n       .propertyList(from: itemsData, format: nil) as? \n       [[String: AnyObject]] else {\n          return [[:]]\n       }\n       return items\n    } \n    func fetch(completion: (_ annotations: \n    [RestaurantItem]) -> ()){\n       if !items.isEmpty { \n          items.removeAll() \n       }\n       for data in loadData() {\n          items.append(RestaurantItem(dict: data))\n       }\n       completion(items)\n    }\n    ```", "```swift\n(_ annotations:[RestaurantItem]) -> ())\n```", "```swift\n    import Foundation\n    loadPlist(file:) that takes a string as a parameter and returns an array of dictionaries. The string will hold the name of the .plist file to be loaded.\n    ```", "```swift\n    import Foundation\n    protocol DataManager {\n       func loadPlist(file name: String) -> \n       [[String: AnyObject]]\n    }\n    loadPlist(file:) method. This method looks for a .plist file specified in the name parameter inside the application bundle. If the file is not found, an empty array of dictionaries is returned. Otherwise, the contents of the .plist file are loaded into an array of dictionaries of type [String: AnyObject] and returned. \n    ```", "```swift\n    class MapDataManagerloadPlist(file:) method available to the MapDataManager class.\n    ```", "```swift\n    for data in MapDataManager class should look like this:\n\n    ```", "```swift\n\n    ```", "```swift\n    class ExploreDataManagerloadPlist(file:) method available to the ExploreDataManager class.\n    ```", "```swift\n       func fetch() {\n          for data in data is cast as [String: String] so that it can be used to initialize instances of the ExploreItem class.You can now make any class that needs to load a `.plist` file containing an array of dictionaries adopt the `DataManager` protocol, as you did here with the `MapDataManager` and `ExploreDataManager` classes. It's not always clear when you should refactor, but the more experience you have, the easier it becomes. One indication that you need to refactor is when you are writing the same code in more than one class.\n    ```", "```swift\n    import MapKit\n    ```", "```swift\n    class MapViewController: UIViewController, \n    MKMapViewDelegate {\n    ```", "```swift\n    func initialRegion(latDelta: CLLocationDegrees, \n    longDelta: CLLocationDegrees) -> MKCoordinateRegion {\n       guard let item = items.first else {\n          return MKCoordinateRegion()\n       }\n       let span = MKCoordinateSpan(latitudeDelta: \n       latDelta, longitudeDelta: longDelta)\n       return MKCoordinateRegion(center: item.coordinate,\n       span: span)\n    }\n    ```", "```swift\n    func initialRegion(latDelta: CLLocationDegrees, longDelta: CLLocationDegrees) -> MKCoordinateRegion\n    ```", "```swift\n    guard let item = items.first else { return MKCoordinateRegion() }\n    ```", "```swift\n    let span = MKCoordinateSpan(latitudeDelta: latDelta, longitudeDelta: longDelta)\n    ```", "```swift\n    return MKCoordinateRegion(center: item.coordinate, span: span)\n    ```", "```swift\n    private let manager = MapDataManager() \n    ```", "```swift\n    func setupMap(_ annotations: [RestaurantItem]) {\n       mapView.setRegion(manager.initialRegion(\n       latDelta: 0.5, longDelta: 0.5), animated: true)\n       mapView.addAnnotations(manager.annotations)\n    }\n    ```", "```swift\n    func initialize() {\n       manager.fetch {(annotations) in\n       setupMap(annotations)}\n    }\n    ```", "```swift\n    override func viewDidLoad() { \n       super.viewDidLoad() \n       initialize()\n    }\n    ```", "```swift\n    func initialize() {\n       mapView.delegate = self\n    ```", "```swift\n    func mapView(_ mapView: MKMapView, viewFor annotation:\n    MKAnnotation) -> MKAnnotationView? {\n       let identifier = \"custompin\"\n       guard !annotation.isKind(of: MKUserLocation.self)\n       else { \n          return nil \n       }\n       let annotationView: MKAnnotationView\n       if let customAnnotationView = \n       mapView.dequeueReusableAnnotationView(\n       withIdentifier: identifier) {\n          annotationView = customAnnotationView \n          annotationView.annotation = annotation\n       } else {\n          let av = MKAnnotationView(annotation: \n          annotation, reuseIdentifier: identifier)\n          av.rightCalloutAccessoryView = \n          UIButton(type: .detailDisclosure)\n          annotationView = av\n       }\n       annotationView.canShowCallout = true \n       if let image = UIImage(named: \n            \"custom-annotation\") {\n                annotationView.image = image \n                annotationView.centerOffset = CGPoint(\n                x: -image.size.width / 2, \n                y: -image.size.height / 2)\n       }\n       return annotationView\n    }\n    ```", "```swift\n    func mapView(_ mapView: MKMapView, viewFor \n    annotation: MKAnnotation) -> MKAnnotationView?\n    ```", "```swift\n    let identifier = \"custompin\"\n    ```", "```swift\n    guard !annotation.isKind(of: MKUserLocation.self) \n    else { \n       return nil \n    }\n    ```", "```swift\n    let annotationView: MKAnnotationView\n    ```", "```swift\n    if let customAnnotationView = \n    mapView.dequeueReusableAnnotationView (withIdentifier:\n    identifier) { \n       annotationView = customAnnotationView \n       annotationView.annotation = annotation\n    }\n    ```", "```swift\n    else {\n       let av = MKAnnotationView(annotation: annotation, \n       reuseIdentifier: identifier) \n       av.rightCalloutAccessoryView = \n       UIButton(type: .detailDisclosure)\n       annotationView = av\n    }\n    ```", "```swift\n    return annotationView\n    ```", "```swift\n    enum Segue: String { \n       case showDetail \n       case showRating \n       case showReview\n       case showAllReviews \n       case restaurantList \n       case locationList \n       case showPhotoReview \n       case showPhotoFilter\n    }\n    ```", "```swift\nfunc mapView(_ mapView: MKMapView, annotationView view: \nMKAnnotationView, calloutAccessoryControlTapped control: \nUIControl) {\n   self.performSegue(withIdentifier: \n   Segue.showDetail.rawValue, sender: self)\n}\n```", "```swift\n    import UIKit\n    class RestaurantDetailViewController: \n    UITableViewController {\n       override func viewDidLoad() {\n          super.viewDidLoad()\n       }\n    }\n    ```", "```swift\n    var selectedRestaurant: RestaurantItem?\n    ```", "```swift\n    dump(selectedRestaurant as Any)\n    ```", "```swift\n    import UIKit\n    class RestaurantDetailViewController: UITableViewController {\n       var selectedRestaurant: RestaurantItem?\n       override func viewDidLoad() { \n          super.viewDidLoad() \n          dump(selectedRestaurant as Any)\n       }\n    }\n    ```", "```swift\n    var selectedRestaurant: RestaurantItem?\n    ```", "```swift\n    func mapView(_ mapView: MKMapView, annotationView \n    view: MKAnnotationView, calloutAccessoryControlTapped \n    control: UIControl){\n    RestaurantItem instance associated with MKAnnotationView instance that was tapped and assigns it to selectedRestaurant.\n    ```", "```swift\n    override func prepare(for segue: UIStoryboardSegue, sender: Any?){\n       switch segue.identifier! {\n          case Segue.showDetail.rawValue:\n             showRestaurantDetail(segue: segue)\n          default:\n             print(\"Segue not added\")\n       }\n    }\n    ```", "```swift\n    func showRestaurantDetail(segue: UIStoryboardSegue) {\n       if let viewController = segue.destination as? \n       RestaurantDetailViewController, let restaurant = \n       selectedRestaurant {\n          viewController.selectedRestaurant = restaurant\n       }\n    }\n    ```", "```swift\n    // MARK: Private Extension\n    private extension ExploreViewController {\n       // code goes here\n    }\n    // MARK: UICollectionViewDataSource\n    extension ExploreViewController: \n    UICollectionViewDataSource {\n       // code goes here\n    }\n    ```", "```swift\n    class ExploreViewController: UIViewController, UICollectionViewDelegate {\n    ```", "```swift\n    // MARK: UICollectionViewDataSource\n    extension ExploreViewController: \n    UICollectionViewDataSource {\n       viewDidLoad() as clean as possible, you will create an initialize() method inside the private extension, and put everything you need to initialize the view controller in there. After that, you will call initialize() in viewDidLoad(). \n    ```", "```swift\n    func initialize() {\n       manager.fetch()\n    }\n    ```", "```swift\n    // MARK: Private Extension\n    private extension ExploreViewController {\n       func initialize() {\n          manager.fetch()\n       }\n       @IBAction func unwindLocationCancel(segue:\n       UIStoryboardSegue) {\n       }\n    }\n    ```", "```swift\n    override func viewDidLoad() { \n       super.viewDidLoad() \n       initialize()\n    }\n    ```", "```swift\n    // MARK: Private Extension\n    private extension RestaurantListViewController {\n       // code goes here\n    }\n    // MARK: UICollectionViewDataSource \n    extension RestaurantListViewController: \n    UICollectionViewDataSource {\n       // code goes here\n    }\n    ```", "```swift\n    class RestaurantListViewController: UIViewController, UICollectionViewDelegate {\n    ```", "```swift\n    // MARK: UICollectionViewDataSource extension \n    RestaurantListViewController: \n    UICollectionViewDataSource {\n    func collectionView(_ collectionView: \n    UICollectionView, numberOfItemsInSection \n       section: Int) -> Int {\n          1\n       }\n    func collectionView(_ collectionView: \n    UICollectionView, cellForItemAt indexPath: \n       IndexPath) -> UICollectionViewCell {\n          collectionView.dequeueReusableCell(\n    withReuseIdentifier: \"restaurantCell\", \n          for: indexPath)\n       }\n    }\n    ```", "```swift\n    // MARK: Private Extension\n    private extension LocationViewController {\n       // code goes here\n    }\n    // MARK: UITableViewDataSource\n    extension LocationViewController: \n    UITableViewDataSource {\n       // code goes here\n    }\n    ```", "```swift\n    class LocationViewController: UIViewController {\n    ```", "```swift\n    // MARK: UITableViewDataSource\n    extension LocationViewController: UITableViewDataSource \n    {\n       func tableView(_ tableView: UITableView, \n       numberOfRowsInSection section: Int) -> Int {\n          manager.numberOfLocationItems()\n       }\n       func tableView(_ tableView: UITableView, \n    cellForRowAt indexPath: IndexPath) -> \n       UITableViewCell {\n          let cell = tableView.dequeueReusableCell(\n          withIdentifier: \"locationCell\", for: indexPath)\n    cell.textLabel?.text = \n          manager.locationItem(at: indexPath.row)\n          return cell\n       }\n    }\n    ```", "```swift\n    // MARK: Private Extension\n    private extension LocationViewController {\n       func initialize() {\n          manager.fetch()\n       }\n    }\n    ```", "```swift\n    override func viewDidLoad() { \n       super.viewDidLoad() \n       initialize()\n    }\n    ```", "```swift\n    // MARK: Private Extension\n    private extension MapViewController {\n       // code goes here\n    }\n    // MARK: MKMapViewDelegate\n    extension MapViewController: MKMapViewDelegate {\n       // code goes here\n    }\n    ```", "```swift\n    class MapViewController: UIViewController {\n    ```", "```swift\n    // MARK: MKMapViewDelegate\n    extension MapViewController: MKMapViewDelegate {\n    func mapView(_ mapView: MKMapView, annotationView \n    view: MKAnnotationView, \n       calloutAccessoryControlTapped control: UIControl){\n    guard let annotation = \n    mapView.selectedAnnotations.first else \n    { \n    return \n          }\n    selectedRestaurant = annotation as? \n    RestaurantItem \n    self.performSegue(withIdentifier: \n          Segue.showDetail.rawValue, sender: self)\n       }\n    func mapView(_ mapView: MKMapView, viewFor \n       annotation:MKAnnotation) -> MKAnnotationView? {\n          let identifier = \"custompin\"\n    guard !annotation.isKind(of: \n    MKUserLocation.self) else { \n    return nil \n          }\n          let annotationView: MKAnnotationView\n          if let customAnnotationView = mapView.\n    dequeueReusableAnnotationView(withIdentifier: \n    identifier) { \n    annotationView = customAnnotationView \n             annotationView.annotation = annotation\n          } else {\n    let av = MKAnnotationView(annotation: \n             annotation, reuseIdentifier: identifier)\n    av.rightCalloutAccessoryView = \n             UIButton(type: .detailDisclosure)\n             annotationView = av\n          }\n          annotationView.canShowCallout = true\n          if let image = UIImage(named: \"custom-\n    annotation\") { \n             annotationView.image = image\n    annotationView.centerOffset = \n    CGPoint(x: -image.size.width / 2, \n             y: -image.size height / 2 )\n          }\n          return annotationView\n       }\n    }\n    ```", "```swift\n    // MARK: Private Extension\n    private extension MapViewController {\n    func initialize() { \n    mapView.delegate = self \n    manager.fetch { (annotations) in \n          setupMap(annotations) }\n       }\n       func setupMap(_ annotations: [RestaurantItem]) {\n          mapView.setRegion(manager.currentRegion(\n          latDelta: 0.5, longDelta: 0.5), animated: true)\n          mapView.addAnnotations(manager.annotations)\n       }\n       func showRestaurantDetail(segue:UIStoryboardSegue){\n          if let viewController = segue.destination as?\n    RestaurantDetailViewController, let restaurant \n          = selectedRestaurant {\n    viewController.selectedRestaurant \n             = restaurant\n          }\n       }\n    }\n    ```"]