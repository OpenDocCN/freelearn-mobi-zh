<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Dealing with Optionals"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Dealing with Optionals</h1></div></div></div><p>In day-to-day Swift application development, we need to deal with optionals as some of the methods that we need to call may return some values or none. This chapter explores the concept of optionals and provides different techniques to deal with them.</p><p>This chapter will cover the following topics with coding examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Optional types</li><li class="listitem" style="list-style-type: disc">Unwrapping optionals</li><li class="listitem" style="list-style-type: disc">Optional binding</li><li class="listitem" style="list-style-type: disc">Guard</li><li class="listitem" style="list-style-type: disc">Coalescing</li><li class="listitem" style="list-style-type: disc">Optional chaining</li><li class="listitem" style="list-style-type: disc">Optional mapping</li><li class="listitem" style="list-style-type: disc">Dealing with optionals functionally</li><li class="listitem" style="list-style-type: disc"><code class="literal">fmap</code> and <code class="literal">apply</code> for multiple functional mapping</li></ul></div><div class="section" title="Optional types"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Optional types</h1></div></div></div><p>In our day-to-day application development, we encounter situations where we expect to receive a value but we do not receive it. For instance, suppose that we have a list of items and we need to search for a particular value in the list. The particular value that we are looking for might not be in the list. We have already encountered a lot of these scenarios.</p><p>Other examples can be calling a web service and receiving a JSON payload without the fields that we are looking for or querying a database and not receiving the expected values.</p><p>What are we going to receive when the value is not there and how will we handle it?</p><p>In programming languages such as C, it is possible to create a variable without giving it a value. If we try to use the variable before assigning a value, we would get an undefined value.</p><p>In Swift, we can define a variable without giving it a value, but we cannot use it without assigning some value to it. In other words, we need to initialize it before being able to use it. This feature of Swift ensures that we will not receive undefined values.</p><p>What about the scenarios where we need to define a variable and we do not know what is going to be the value?</p><p>To overcome these kinds of scenarios, Swift provides <code class="literal">Optional</code> types that can have <code class="literal">Some</code> or <code class="literal">None</code> values and can be used in situations where a value may be absent.</p><p>A question mark (<code class="literal">
?
</code>) is used to define a variable as optional. The following example presents an example of optional definition:</p><pre class="programlisting">// Optional value either contains a value or contains nil&#13;
var optionalString: String? = "A String literal"&#13;
optionalString = nil&#13;
</pre><p>In this example, we have defined a variable that is of an optional type. The <code class="literal">String?</code> type is an optional type that may wrap a <code class="literal">String</code> value in it.</p><p>We were able to assign <code class="literal">nil</code> to <code class="literal">optionalString</code>. If we try to assign <code class="literal">nil</code> to any non-optional type in Swift, the compiler will complain about it unlike other languages such as Objective-C.</p><p>For instance, in the following example, the compiler will complain that <code class="literal">nil cannot be assigned to type 'String'</code>:</p><pre class="programlisting">var aString: String = "A String literal"&#13;
aString = nil&#13;
</pre><p>The compile time checking of non-existent values in Swift to prevent runtime errors is one of the features of type safety in Swift. Type safety makes it easier to catch problems in the earlier stages of development. Let's examine an example in Objective-C to see the real value of optionals:</p><pre class="programlisting">NSString *searchedItem = [self searchItem:@"an item"];&#13;
NSString *text = @"Found item: ";&#13;
NSString *message = [text stringByAppendingString:searchedItem];&#13;
</pre><p>Suppose that we have a list for which we initiate a search by calling <code class="literal">searchItem</code>. In this case, our <code class="literal">searchItem</code> method takes <code class="literal">NSString</code> and returns <code class="literal">NSString</code>. The result of this call can be <code class="literal">nil</code>. If we use the returned <code class="literal">NSString</code> and try to append it to another <code class="literal">NSString</code>, it will compile but may crash the application if <code class="literal">searchItem</code> is <code class="literal">nil</code>.</p><p>We could remedy this problem by checking whether <code class="literal">searchedItem</code> is not <code class="literal">nil</code> before using it. However, there might be some cases where other developers forgot to do it or did not see the necessity of it.</p><p>For sure, it is safer to receive compile time complaints about these kinds of usages. As Swift is type-safe, we will not encounter any such surprises during runtime.</p><p>So, we have understood why we need an optional type, but what is it and how is it defined?</p><p>Under the hood, <code class="literal">Optional</code> is an <code class="literal">enum</code> with two cases in it—one is <code class="literal">None</code> and the other one is <code class="literal">Some</code> with its associated generic value as follows:</p><pre class="programlisting">enum Optional&lt;T&gt; {&#13;
    case None&#13;
    case Some(T)&#13;
}&#13;
</pre></div></div>
<div class="section" title="Unwrapping optionals"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Unwrapping optionals</h1></div></div></div><p>So far, we know that optionals wrap values in themselves. Wrapping means that the actual data is stored within an outer structure.</p><p>For instance, we print <code class="literal">optionalString</code> as follows:</p><pre class="programlisting">print(optionalString)&#13;
</pre><p>The result will be <code class="literal">Optional("A String literal")</code>.</p><p>How will we unwrap optionals and use the values that we need? There are different methods to unwrap optionals that we will go through in the following sections.</p><div class="section" title="Force unwrapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>Force unwrapping</h2></div></div></div><p>To unwrap optionals, the easiest and most dangerous method that we can use is force unwrapping. In short, <code class="literal">!</code> can be used to force unwrap the value from <code class="literal">Optional</code>.</p><p>The following example forcefully unwraps <code class="literal">optionalString</code>:</p><pre class="programlisting">optionalString = "An optional String"&#13;
print(optionalString!)&#13;
</pre><p>Force unwrapping the optionals may cause errors if the optional does not have a value, so it is not recommended to use this approach as it is very hard to be sure if we are going to have values in optionals in different circumstances.</p><p>In fact, force unwrapping eliminates the benefits of type safety and may cause our applications to crash during runtime.</p></div><div class="section" title="nil checking"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>nil checking</h2></div></div></div><p>Force unwrapping an <code class="literal">Optional</code> could crash our applications; to eliminate the crashing problem, we can check whether the variable is not <code class="literal">nil</code> before unwrapping it.</p><p>The following example presents a simple <code class="literal">nil</code> checking approach:</p><pre class="programlisting">if optionalString != nil {&#13;
    print(optionalString!)&#13;
}&#13;
</pre><p>This approach is safe in compile and runtime but may cause problems during editing. For instance, if we accidentally move the <code class="literal">print</code> line outside the <code class="literal">if</code> block, the compiler is not going to complain and it may crash our application during runtime.</p></div><div class="section" title="Optional binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>Optional binding</h2></div></div></div><p>The better approach would be to use the Optional binding technique to find out whether an <code class="literal">Optional</code> contains a value or not. If it contains a value, we will be able to unwrap it and put it into a temporary constant or variable.</p><p>The following example presents optional binding:</p><pre class="programlisting">let nilName: String? = nil&#13;
if let familyName = nilName {&#13;
    greetingfamilyName = "Hello, Mr. \(familyName)"&#13;
} else {&#13;
    // Optional does not have a value&#13;
}&#13;
</pre><p>The <code class="literal"> if let familyName = nilName</code> statement will assign the <code class="literal">Optional</code> value to a new variable named <code class="literal">familyName</code>. The right-hand side of the assignment has to be an <code class="literal">Optional</code>, otherwise, the compiler will issue an error. Also, this approach ensures that we are using the unwrapped temporary version so it is safe.</p><p>This approach is also called if-let binding and is useful to unwrap <code class="literal">Optionals</code> and access the underlying values, but if we get into a complex structure of nested objects such as a <code class="literal">JSON</code> payload, the syntax becomes cumbersome.</p><p>We will need to have lots of nested <code class="literal">if-let</code> expressions in these cases:</p><pre class="programlisting">let dict = ["One": 1, "Two": 2, "Three": 3]&#13;
&#13;
if let firstValue = dict["One"] {&#13;
    if let secondValue = dict["Two"] {&#13;
        if let thirdValue = dict["Three"] {&#13;
            // Do something with three values&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>To overcome this issue, we can use multiple Optional bindings as follows:</p><pre class="programlisting">if let&#13;
firstValue = dict["One"],&#13;
secondValue = dict["Two"],&#13;
thirdValue = dict["Three"] {&#13;
    // Do something with three values&#13;
}&#13;
</pre><p>This syntax makes the code more readable but still is not the best approach when we need to bind multiple levels of optionals. In the following sections, we will look at different methods to further improve the readability and maintainability of our optional handlings.</p></div></div>
<div class="section" title="Guard"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Guard</h1></div></div></div><p>The <code class="literal"> guard</code> is another method provided in the Swift library to handle <code class="literal">Optionals</code>. The <code class="literal">guard</code> method differs from the <code class="literal">Optional if-let</code> binding in that the <code class="literal">guard</code> statement can be used for early exits. We can use a <code class="literal">guard</code> statement to require that a condition must be <code class="literal">true</code> in order for the code after the <code class="literal">
guard
</code> statement to be executed.</p><p>The following example presents the guard statement usage:</p><pre class="programlisting">func greet(person: [String: String]) {&#13;
    guard let name = person["name"] else {&#13;
        return&#13;
    }&#13;
    print("Hello Ms \(name)!")&#13;
}&#13;
&#13;
greet(person: ["name": "Neco"]) // prints "Hello Ms Neco!"&#13;
</pre><p>In this example, the <code class="literal">greet</code> function requires a value for a person's name; therefore, it checks whether it is present with the <code class="literal">guard</code> statement. Otherwise, it will return and not continue to execute.</p><p>Using <code class="literal">guard</code> statements, we can check for failure scenarios first and return if it fails. Unlike <code class="literal">if-let</code> statements, <code class="literal">guard</code> does not provide a new scope, so in the preceding example, we were able to use <code class="literal">name</code> in our <code class="literal">print</code> statement, which is not inside <code class="literal">{ }</code>.</p><p>Similar to <code class="literal">if-let</code> statements, we can use multiple <code class="literal">guard</code> statements as follows:</p><pre class="programlisting">func extractValue(dict: [String: Int]) {&#13;
    guard let&#13;
    firstValue = dict["One"],&#13;
    secondValue = dict["Two"],&#13;
    thirdValue = dict["Three"]&#13;
    else {&#13;
        return&#13;
    }&#13;
    // Do something with three values&#13;
} &#13;
</pre></div>
<div class="section" title="Implicitly unwrapped optionals"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Implicitly unwrapped optionals</h1></div></div></div><p>We can define implicitly unwrapped optionals by appending an exclamation mark (<code class="literal">!</code>) to the end of the type. These types of optionals will unwrap themselves.</p><p>The following example presents two ways to get a value from a dictionary. In the first example, the resulting value will be an optional. The second example will implicitly unwrap the value:</p><pre class="programlisting">let one = "One" &#13;
let firstValue = dict["One"] &#13;
let implictlyUnwrappedFirstValue: Int! = dict["One"]&#13;
</pre><p>Like forcefully unwrapping, implicitly unwrapped <code class="literal">Optionals</code> may cause runtime crashes in our applications, so we need to be cautious when we use them.</p></div>
<div class="section" title="Error handling to avoid optionals"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Error handling to avoid optionals</h1></div></div></div><p>In our day-to-day application development, we might need to develop some functions that return <code class="literal">Optionals</code>. For instance, suppose that we need to read a file and return the content of that file. Using optionals, we can develop it as follows:</p><pre class="programlisting">func checkForPath(path: String) -&gt; String? {&#13;
    // check for the path&#13;
    return "path"&#13;
}&#13;
&#13;
func readFile(path: String) -&gt; String? {&#13;
    if let restult = checkForPath(path: path) {&#13;
        return restult&#13;
    } else {&#13;
        return nil&#13;
    }&#13;
}&#13;
</pre><p>Here, <code class="literal">checkForPath</code> is an incomplete function that checks for file existence.</p><p>When we call the <code class="literal">readFile</code> function, we will need to check for the resulting optional:</p><pre class="programlisting">if let result = readFile(path: "path/to") {&#13;
    // Do something with result&#13;
}&#13;
</pre><p>Instead of using optionals in this scenario, we can use error handling to redirect the flow of control to eliminate errors and provide recoveries:</p><pre class="programlisting">enum Result: ErrorProtocol {&#13;
    case failure&#13;
    case success&#13;
}&#13;
&#13;
func readFile(path: String) throws -&gt; String {&#13;
    if let restult = checkForPath(path: path) {&#13;
        return restult&#13;
    } else {&#13;
        throw Result.failure&#13;
    }&#13;
}&#13;
</pre><p>When we call this function, we will need to wrap it inside a <code class="literal">do</code> block and <code class="literal">catch</code> the <code class="literal">exception</code>:</p><pre class="programlisting">do {&#13;
    let result = try readFile(path: "path/to")&#13;
} catch {&#13;
    print(error)&#13;
}&#13;
</pre><div class="section" title="try!"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>try!</h2></div></div></div><p>We can use <code class="literal">try!</code> if we know that there is no way a method call will fail, or if it fails then our code will be broken and we should crash the application.</p><p>When we use the <code class="literal">try!</code> keyword, we do not need to have <code class="literal">do</code> and <code class="literal">catch</code> around our code block because we promise it will never fail! It is a big promise that we should avoid.</p><p>In case we have to bypass error handling such as checking whether a database file exists, we can do the following:</p><pre class="programlisting">do {&#13;
    let result = try readFile(path: "path/to")&#13;
} catch {&#13;
    print(error)&#13;
}&#13;
</pre></div><div class="section" title="try?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>try?</h2></div></div></div><p>We can use <code class="literal">try?</code> to handle an error by converting it to an <code class="literal">Optional</code> value.</p><p>If an error is thrown while evaluating the <code class="literal">try?</code> expression, the value of the expression is going to be <code class="literal">nil</code>. For instance, in the following example, the result is going to be <code class="literal">nil</code> if we cannot read the file:</p><pre class="programlisting">let result = try? readFile(path: "path/to")&#13;
</pre></div></div>
<div class="section" title="Nil-coalescing"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Nil-coalescing</h1></div></div></div><p>Swift provides the <code class="literal">??</code> operator for nil-coalescing. It unwraps <code class="literal">Optionals</code> and provides fallback or default values for the <code class="literal">nil</code> case. For instance, <code class="literal">a ?? b</code> unwraps optional <code class="literal">a</code> if it has a value and returns a default value <code class="literal">b</code> if <code class="literal">a</code> is <code class="literal">nil</code>.</p><p>In this example, if <code class="literal">Optional</code>
<code class="literal">a</code> is not <code class="literal">nil</code>, the expression after the nil-coalescing operator is not going to be evaluated. Nil-coalescing is proper for scenarios where we can provide a fallback or default value.</p></div>
<div class="section" title="Optional chaining"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Optional chaining</h1></div></div></div><p>Optional chaining is a process to query and call properties, methods, and subscripts on an optional that may currently be <code class="literal">nil</code>. Optional chaining in Swift is similar to messaging <code class="literal">nil</code> in Objective-C but in a way that works for any type and can be checked for success or failure.</p><p>The following example presents two different classes. One of the classes <code class="literal">Person</code> has a property of type of <code class="literal">Optional</code> (<code class="literal">residence</code>), which wraps the other class type <code class="literal">Residence</code>:</p><pre class="programlisting">class Residence {&#13;
    var numberOfRooms = 1&#13;
}&#13;
&#13;
class Person {&#13;
    var residence: Residence?&#13;
}&#13;
</pre><p>We will create an instance of the <code class="literal">Person</code> class, <code class="literal">sangeeth</code>:</p><pre class="programlisting">let residence = Residence()&#13;
residence.numberOfRooms = 5&#13;
let sangeeth = Person()&#13;
sangeeth.residence = residence&#13;
</pre><p>To check for <code class="literal">numberOfRooms</code>, we need to use the residence property of the <code class="literal">Person</code> class, which is an optional. Optional chaining enables us to go through optionals as follows:</p><pre class="programlisting">if let roomCount = sangeeth.residence?.numberOfRooms {&#13;
    // Use the roomCount&#13;
    print(roomCount)&#13;
}&#13;
</pre><p>The <code class="literal"> roomCount</code> variable will be five, as expected.</p><p>This can be used to call methods and subscripts through optional chaining.</p><p>We can add force unwrapping to any chain items by replacing the question mark with an exclamation mark as follows:</p><pre class="programlisting">let roomCount = sangeeth.residence!.numberOfRooms&#13;
</pre><p>Again, we need to be cautious when we use force unwrapping in optional chains.</p></div>
<div class="section" title="Dealing with optionals functionally"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Dealing with optionals functionally</h1></div></div></div><p>We have covered a lot of different approaches and tools to deal with optionals so far. Let's examine if we can use functional programming paradigms to simplify the process.</p><div class="section" title="Optional mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Optional mapping</h2></div></div></div><p>Mapping over an array would generate one element for each element in the array. Can we map over an optional to generate non-optional values? If we have <code class="literal">Some</code>, map it; otherwise, return <code class="literal">None</code>. Let's examine this:</p><pre class="programlisting">func mapOptionals&lt;T, V&gt;(transform: (T) -&gt; V, input: T?) -&gt; V? {&#13;
    switch input {&#13;
        case .some(let value): return transform(value)&#13;
        case .none: return .none&#13;
    }&#13;
}&#13;
</pre><p>Our <code class="literal">input</code> variable is a generic <code class="literal">optional</code> and we have a transform function that takes <code class="literal">input</code> and transforms it into a generic type. The end result will be a generic <code class="literal">optional</code> type. In the function body, we use pattern matching to return the respective values. Let's test this function:</p><pre class="programlisting">class User {&#13;
    var name: String?&#13;
}&#13;
</pre><p>We create a dummy class named <code class="literal">User</code> with an <code class="literal">Optional</code> variable. We use the variable as follows:</p><pre class="programlisting">func extractUserName(name: String) -&gt; String {&#13;
    return "\(name)"&#13;
}&#13;
&#13;
var nonOptionalUserName: String {&#13;
    let user = User()&#13;
    user.name = "John Doe"&#13;
    let someUserName = mapOptionals(transform: extractUserName,&#13;
      input: user.name)&#13;
    return someUserName ?? ""&#13;
}&#13;
</pre><p>The end result will be a non-optional String. Our <code class="literal">mapOptionals</code> function is similar to the <code class="literal">fmap</code> function in Haskell, which is defined as the <code class="literal">&lt;^&gt;</code> operator.</p><p>Let's convert this function to the operator:</p><pre class="programlisting">infix operator &lt;^&gt; { associativity left }&#13;
&#13;
func &lt;^&gt;&lt;T, V&gt;(transform: (T) -&gt; V, input: T?) -&gt; V? {&#13;
    switch input {&#13;
        case .some(let value): return transform(value)&#13;
        case .none: return .none&#13;
    }&#13;
}&#13;
</pre><p>Here, we just defined an infix operator and defined the respective function. Let's try this function to see if it provides the same result:</p><pre class="programlisting">var nonOptionalUserName: String {&#13;
    let user = User()&#13;
    user.name = "John Doe"&#13;
    let someUserName = extractUserName &lt;^&gt; user.name&#13;
    return someUserName ?? ""&#13;
}&#13;
</pre><p>The result is identical to our previous example, but the code is more readable, so we may prefer to use it instead.</p></div><div class="section" title="Multiple optional value mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Multiple optional value mapping</h2></div></div></div><p>Our previous example demonstrated single <code class="literal">optional</code> value mapping using functional programming techniques. What if we need to map multiple optional values together? In the <span class="emphasis"><em>Optional binding</em></span> section, we covered a non-functional way to handle multiple <code class="literal">Optional</code> value binding, and in this section, we will look at multiple optional value mapping. As optionals are instances of <span class="emphasis"><em>applicative functors</em></span>, we will develop an <code class="literal">apply</code> function to use over optionals:</p><pre class="programlisting">func apply&lt;T, V&gt;(transform: ((T) -&gt; V)?, input: T?) -&gt; V? {&#13;
    switch transform {&#13;
        case .some(let fx): return fx &lt;^&gt; input&#13;
        case .none: return .none&#13;
    }&#13;
}&#13;
</pre><p>The <code class="literal"> apply</code> function is very similar to the <code class="literal">fmap</code> function. The <code class="literal">transform</code> function is optional and we use pattern matching to return <code class="literal">none</code> or <code class="literal">some</code> over it.</p><p>In Haskell, the <code class="literal">apply</code> function is represented as the <code class="literal">&lt;*&gt;</code> operator. This operator has been adopted by the Swift functional programming community as well, so we use it as the <code class="literal">apply</code> function:</p><pre class="programlisting">infix operator &lt;*&gt; { associativity left }&#13;
&#13;
func &lt;*&gt;&lt;T, V&gt;(transform: ((T) -&gt; V)?, input: T?) -&gt; V? {&#13;
    switch transform {&#13;
        case .some(let fx): return fx &lt;^&gt; input&#13;
        case .none: return .none&#13;
    }&#13;
}&#13;
</pre><p>We can test our <code class="literal">apply</code> function as follows:</p><pre class="programlisting">func extractFullUserName(firstName: String)(lastName: String) -&gt; String {&#13;
    return "\(firstName) \(lastName)"&#13;
}&#13;
</pre><p>The <code class="literal"> extractFullUserName</code> function is a curried function that should be converted to return a closure explicitly because Apple deprecated function currying in Swift 2.2 and removed it from Swift 3.0.</p><p>Let's convert it to the Swift 3.0 version:</p><pre class="programlisting">func extractFullUserName(firstName: String) -&gt; (String) -&gt; String { &#13;
    return { (lastName: String) -&gt; String in&#13;
        return "\(firstName) \(lastName)"&#13;
    }&#13;
}&#13;
</pre><p>Now we can use this function to extract the full username:</p><pre class="programlisting">class User { &#13;
    var firstName: String? &#13;
    var lastName: String? &#13;
} &#13;
var fullName: String { &#13;
    let user = User() &#13;
    user.firstName = "John" &#13;
    user.lastName = "Doe"&#13;
    let fullUserName = extractFullUserName &lt;^&gt; user.firstName &lt;*&gt; &#13;
      user.lastName&#13;
    return fullUserName ?? "" &#13;
}&#13;
</pre><p>Combining <code class="literal">fmap</code> and <code class="literal">apply</code> functions, we were able to <code class="literal">map</code> two optionals.</p><p>In fact, the <code class="literal">Optional</code> type is a <code class="literal">monad</code>, so it implements the <code class="literal">map</code> and <code class="literal">flatMap</code> methods and we do not need to develop it ourselves.</p><p>The following example presents calling the <code class="literal">map</code> method on an <code class="literal">optional</code> type:</p><pre class="programlisting">let optionalString: String? = "A String literal" &#13;
let result = optionalString.map { "\($0) is mapped" }&#13;
</pre><p>The result will be an <code class="literal">Optional String</code> with the following value:</p><p>
<code class="literal">A String literal is mapped</code>.</p><p>Also, we can use <code class="literal">flatMap</code> to filter <code class="literal">nil</code> values and convert an array of optionals to an array of unwrapped values.</p><p>In the following example, calling <code class="literal">flatMap</code> on our <code class="literal">optional Array</code> will eliminate the third element (index: 2) of our <code class="literal">Array</code>:</p><pre class="programlisting">let optionalArray: [String?] = ["First", "Second", nil, "Fourth"] &#13;
let nonOptionalArray = optionalArray.flatMap { $0 } &#13;
print(nonOptionalArray) &#13;
</pre><p>The result is going to be <code class="literal">["First", "Second", "Fourth"]</code>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Summary</h1></div></div></div><p>In this chapter, we got familiar with different techniques to deal with optionals. We talked about built-in techniques to deal with optionals such as optional binding, guard, coalescing, and optional chaining. Then we explored functional programming techniques to deal with optionals. We created <code class="literal">fmap</code> and <code class="literal">apply</code> functions and related operators to tackle multiple optional binding problems. Even though some developers may prefer to use built-in multiple optional binding, exploring functional programming techniques practically provides a better understanding of concepts that we will be able to apply to other problems.</p><p>In the following chapter, we will explore some examples of functional data structures such as Semigroup, Monoid, Binary Search Tree, Linked List, Stack, and Lazy List.</p></div></body></html>