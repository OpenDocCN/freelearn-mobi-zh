<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Debugging with OpenGL ES</h1></div></div></div><p>The<strong> Open Graphics Library</strong> (<strong>OpenGL</strong>) can be simply defined as a<em> software interface to the graphics hardware</em>. It is a 3D graphics and modeling library that is highly portable and extremely fast. Using the OpenGL graphics API, you can create some brilliant graphics that are capable of representing 2D and 3D data.</p><p>The OpenGL library is a multi-purpose, open-source graphics library that supports applications for 2D and 3D digital content creation, mechanical and architectural design, virtual prototyping, flight simulation, and video games, and allows application developers to configure a 3D graphics pipeline, and submit data to it.</p><p>An object is defined by connected vertices. The vertices of the object are then transformed, lit, and assembled into primitives, and rasterized to create a 2D image that can be directly sent to the underlying graphics hardware to render the drawing, which is deemed to be typically very fast, due to the hardware being dedicated to processing graphics commands.</p><p>
<strong>OpenGL for Embedded Systems</strong> (<strong>OpenGL ES</strong>) is a simplified version of the popular OpenGL framework that has been developed to be much easier to learn and implement, eliminating the need for redundant functionality within the iOS graphics hardware. This framework has been optimized to take full advantage of hardware-accelerated mathematical operations, so that developers can get the best performance.<a id="id110" class="indexterm"/>
</p><p>In this chapter, we will be focusing on the new debugging features that come with the OpenGL ES debugger that enables developers to track down issues specific to OpenGL ES in your code.</p><p>In this chapter we will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn about the new workflow feature within Xcode 4</li><li class="listitem" style="list-style-type: disc">Create a simple project to debug an OpenGL ES application</li><li class="listitem" style="list-style-type: disc">Familiarize ourselves with the OpenGL ES 2.0 programmable pipeline</li><li class="listitem" style="list-style-type: disc">Compile and link shaders into an OpenGL ES program</li><li class="listitem" style="list-style-type: disc">Pass data from an application to shaders, using uniforms and attributes</li><li class="listitem" style="list-style-type: disc">Detect OpenGL ES State information (view textures and shaders)</li><li class="listitem" style="list-style-type: disc">Set and use breakpoints to catch OpenGL ES errors</li><li class="listitem" style="list-style-type: disc">Set conditional OpenGL ES entry point breakpoints</li><li class="listitem" style="list-style-type: disc">Break on frame boundaries</li></ul></div><p>We have some fantastic stuff to cover in this chapter, so let's get started.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Understanding the new workflow feature within Xcode</h1></div></div></div><p>In this section, we will be taking a look at the improvements that have been made to the Xcode 4 development environment, and how this can enable us to debug OpenGL ES applications much easier, compared to the previous versions of Xcode.</p><p>We will look at how we can use the frame capture feature of the debugger to capture all frame objects that are included within an OpenGL ES application. This tool enables you to list all the frame objects that are currently used by your application at a given point of time.<a id="id111" class="indexterm"/>
</p><p>We will familiarize ourselves with the new OpenGL ES debugger within Xcode, to enable us to track down specific issues relating to OpenGL ES within the code.<a id="id112" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec01"/>Creating a simple project to debug an OpenGL ES application</h2></div></div></div><p>Before we can proceed, we first need to create our<code class="literal"> OpenGLESExample</code> project. To refresh your memory, you can refer to the section that we covered in<a class="link" href="ch02.html" title="Chapter 2. Using iCloud and the Storage APIs"> Chapter 2</a>, under the section<em> Creating the iCloudExample application:</em>
<a id="id113" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Launch Xcode from the<code class="literal"> /Developer/Applications</code> folder.</li><li class="listitem"> Select the<strong> OpenGL Game</strong> template from the<strong> Project</strong> template dialog box.<div><img src="img/2267EXP_03_01.jpg" alt="Creating a simple project to debug an OpenGL ES application"/></div></li><li class="listitem"> Then, click on the<strong> Next</strong> button to proceed to the next step in the wizard. This will allow you to enter in the<strong> Product Name</strong> and your<strong> Company Identifier</strong>.<a id="id114" class="indexterm"/><div><img src="img/2267EXP_03_02.jpg" alt="Creating a simple project to debug an OpenGL ES application"/></div></li><li class="listitem"> Enter in<code class="literal"> OpenGLESExample</code> for the<strong> Product Name</strong>, and ensure that you have selected<strong> iPhone</strong> from the<strong> Device Family</strong> dropdown box.</li><li class="listitem"> Next, click on the<strong> Next</strong> button to proceed to the final step in the wizard.<a id="id115" class="indexterm"/></li><li class="listitem">6 Choose the folder location where you would like to save your project.</li><li class="listitem"> Then, click on the<strong> Create</strong> button to save your project at the location specified.</li></ol></div><p>Once your project has been created, you will be presented with the Xcode development interface, along with the project files that the template created for you within the Project<strong> Navigator</strong> window.</p><p>Now that we have our project created, we need to configure our project to enable us to debug the state of the objects.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec02"/>Detecting OpenGL ES state information and objects</h2></div></div></div><p>To enable us to detect and monitor the state of the objects within our application, we need to enable this feature through the<strong> Edit Scheme…</strong> section of our project, as shown in the following screenshot:<a id="id116" class="indexterm"/>
</p><div><img src="img/2267EXP_03_03.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>From the<strong> Edit Scheme</strong> section, as shown in the following screenshot, select the<strong> Run OpenGLESExampleDebug</strong> action, then click on the<strong> Options</strong> tab, and then select the<strong> OpenGL ES Enable</strong> frame capture checkbox.<a id="id117" class="indexterm"/>
</p><div><h3 class="title"><a id="note14"/>Note</h3><p>For this feature to work, you must run the application on an iOS device, and the device must be running iOS 5.0 or later. This feature will not work within the iOS simulator. You will need to ensure that after you have attached your device, you will then need to restart Xcode for this option to become available.</p></div><div><img src="img/2267EXP_03_04.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>When you have configured your project correctly, click on the<strong> OK</strong> button to accept the changes made, and close the dialog box. Next, build and run your OpenGL ES application. When you run your application, you will see two three-dimensional and colored box cubes.<a id="id118" class="indexterm"/>
</p><div><img src="img/2267EXP_03_05.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>When you run your application on the iOS device, you will notice that the frame capture appears within the Xcode 4 debug bar, as shown in the following screenshot:<a id="id119" class="indexterm"/>
</p><div><img src="img/2267EXP_03_06.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>When using the OpenGL ES features of Xcode 4.2, these debugging features enable you to do the following:<a id="id120" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Inspect OpenGL ES state information.</li><li class="listitem"> Introspect OpenGL ES objects such as view textures and shaders.</li><li class="listitem"> Step through draw calls and watch changes with each call.</li><li class="listitem"> Step through the state calls that proceed each draw call to see exactly how the image is constructed.</li></ol></div><p>The following screenshot displays the captured frame of our sample application. The debug navigator contains a list of every draw call and state call associated with that particular frame.</p><p>The buffers that are associated with the frame are shown within the editor pane, and the state information is shown in the debug windowpane. The default view when the OpenGL ES frame capture is launched is displayed in the<strong> Auto</strong> view. This view displays the color portion, which is the<code class="literal"> Renderbuffer #1</code>, as well as its grayscale equivalent of the image, that being<code class="literal"> Renderbuffer #2</code>.</p><div><img src="img/2267EXP_03_07.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>You can also toggle the visibility between each of the channels for red, green and blue, as well as the alpha channels, and then use the<strong> Range</strong> scroll to adjust the color range. This can be done easily by selecting each of the cog buttons, shown in the previous screenshot.<a id="id121" class="indexterm"/>
</p><div><img src="img/2267EXP_03_08.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>You also have the ability to step through each of the draw calls in the debug navigator, or by using the double arrows and slider in the debug bar.</p><div><img src="img/2267EXP_03_09.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>When using the draw call arrows or sliders, you can have Xcode select the stepped-to draw call from the debug navigator. This can be achieved by<em> Control</em> + clicking below the captured frame, and choosing the<strong> Reveal in Debug Navigator</strong> from the shortcut menu.<a id="id122" class="indexterm"/>
</p><div><img src="img/2267EXP_03_10.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>You can also use the shortcut menu to toggle between the standard view of drawing the image, as well as showing the wireframe view of the object, by selecting the<strong> Show Wireframe</strong> option from the pop-up menu, as shown in the previous screenshot.<a id="id123" class="indexterm"/>
</p><p>When using the wireframe view of an object, it highlights the element that is being drawn by the selected draw call. To turn off the wireframe feature and have the image return back to the normal state, select the<strong> Hide Wireframe</strong> option from the pop-up menu, as shown in the following screenshot:<a id="id124" class="indexterm"/>
</p><div><img src="img/2267EXP_03_11.jpg" alt="Detecting OpenGL ES state information and objects"/></div><p>Now that you have a reasonable understanding of debugging through an OpenGL ES application and its draw calls, let's take a look at how we can view the textures associated with an OpenGL ES application.<a id="id125" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec01"/>View textures</h3></div></div></div><p>When referring to textures in OpenGL ES 2.0, this is basically an image that can be sampled by the graphics engine pipeline, and is used to map a colored image onto a mapping surface. To view objects that have been captured by the frame capture button, follow these simple steps:<a id="id126" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"> Open the<strong> Assistant Editor</strong> to see the objects associated with the captured frame. In this view, you can choose to see all of the objects, only bound objects, or the stack. This can be accessed from the<strong> View | Assistant Editor | Show Assistant Editor</strong> menu, as shown in the following screenshot:<div><img src="img/2267EXP_03_12.jpg" alt="View textures"/></div></li><li class="listitem"> Open a secondary assistant editor pane, so that you can see both the objects and the stack frame at the same time. This can be accessed from the<strong> View | Assistant Editor | Add Assistant Editor</strong> menu shown previously, or by clicking on the<strong> +</strong> symbol, as shown in the following screenshot:<a id="id127" class="indexterm"/></li></ol></div><div><img src="img/2267EXP_03_14.jpg" alt="View textures"/></div><p>To see details about any object contained within the OpenGL ES assistant editor, double-click on the object, or choose the item from the pop-up list, as shown in the following screenshot:<a id="id128" class="indexterm"/>
</p><p>It is worth mentioning that, from within this view, you have the ability to change the orientation of any object that has been captured and has been rendered to the view. To change the orientation, locate the<strong> Orientation</strong> options shown at the bottom-right hand of the screen. Objects can be changed to appear in one or more views as needed, and these are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rotate clockwise</li><li class="listitem" style="list-style-type: disc">Rotate counter-clockwise</li><li class="listitem" style="list-style-type: disc">Flip orientation vertically</li><li class="listitem" style="list-style-type: disc">Flip orientation horizontally</li></ul></div><div><img src="img/2267EXP_03_13.jpg" alt="View textures"/></div><p>For example, if you want to see information about the<strong> vertex array object</strong> (VAO), you would double-click on it to see it in more detail, as shown in the following screenshot.<a id="id129" class="indexterm"/>
</p><div><img src="img/2267EXP_03_15.jpg" alt="View textures"/></div><p>This displays all the<code class="literal"> X, Y</code>, and<code class="literal"> Z-axes</code> required to construct each of our objects. Next, we will take a look into how shaders are constructed.<a id="id130" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Shaders</h3></div></div></div><p>There are two types of shaders that you can write for OpenGL ES; these are<strong> Vertex shaders</strong> and<strong> Fragment shaders</strong>.<a id="id131" class="indexterm"/>
</p><p>These two shaders make up what is known as the<strong> Programmable</strong> portion of the OpenGL ES 2.0 programmable pipeline, and are written in a C-like language syntax, called<strong> The OpenGL ES Shading Language</strong> (GLSL).<a id="id132" class="indexterm"/>
</p><p>The following screenshot outlines the OpenGL ES 2.0 programmable pipeline, and combines a version of the OpenGL Shading Language for programming<strong> Vertex Shader</strong> and<strong> Fragment Shader</strong> that has been adapted for embedded platforms for iOS devices:<a id="id133" class="indexterm"/>
</p><div><img src="img/2267EXP_03_17.jpg" alt="Shaders"/></div><p>Shaders are not new, these have been used in a variety of games that use OpenGL. Such games that come to mind are: Doom 3 and Quake 4, or several flight simulators, such as Microsoft's Flight Simulator X.<a id="id134" class="indexterm"/>
</p><div><h3 class="title"><a id="tip02"/>Tip</h3><p>Once thing to note about shaders, is that they are not compiled when your application is built. The source code of the shader gets stored within your application bundle as a text file, or defined within your code as a string literal, that is,<code class="literal"> vertShaderPathname = [[NSBundlemainBundle] pathForResource:@"Shader" ofType:@"vsh"]</code>;</p></div><p>Before you can use your shaders, your application has to load and compile each of them. This is done to preserve device independence.</p><p>Let's take for example, if Apple decided to change to a different GPU manufacturer, for future releases of its iPhone, the compiled shaders may not work on the new GPU. Having your application deferring the compilation to runtime will avoid this problem, and any latest versions of the GPU will be fully supported without a need for you to rebuild your application.</p><p>The following table explains the differences between the two shaders.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p><strong>Shader type</strong></p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Vertex shaders</p>
</td><td style="text-align: left" valign="top">
<p>These are programs that get called once-per-vertex in your scene. An example to explain this better would be - if you were rendering a simple scene with a single square, with one vertex at each corner, this would be called four times.</p>
<p>Their job is to perform some calculations such as lighting, geometry transforms, moving, scaling and rotating of objects, to simulate realism.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Fragment shaders</p>
</td><td style="text-align: left" valign="top">
<p>These are programs that get called once-per-pixel in your scene. So, if you're rendering that same simple scene with a single square, it will be called once for each pixel that the square covers. Fragment shaders can also perform lighting calculations, and so on, but their most important job is to set the final color for the pixel.</p>
</td></tr></tbody></table></div><p>Next, we will start by examining the implementation of the vertex shader that the OpenGL template created for us. You will notice that these shaders are code files that have been implemented using C-Syntax like instructions. Lets, start by examining each section of the vertex shader file, by following these simple steps:</p><div><ol class="orderedlist"><li class="listitem"> Open the<code class="literal"> Shader.vsh</code> vertex shader file located within the<code class="literal"> OpenGLESExample</code> folder of the<strong> Project Navigator</strong> window, and examine the following code snippet.<div><pre class="programlisting">attribute vec4 position;
attribute vec3 normal;
varying lowp vec4 colorVarying;
uniform mat4 modelViewProjectionMatrix;
uniform mat3 normalMatrix;
void main(){
vec3 eyeNormal = normalize(normalMatrix * normal);
vec3 lightPosition = vec3(0.0, 0.0, 1.0);
vec4 diffuseColor = vec4(0.4, 0.4, 1.0, 1.0);
floatnDotVP = max(0.0, dot(eyeNormal, normalize(lightPosition)));
colorVarying = diffuseColor * nDotVP;
gl_Position = modelViewProjectionMatrix * position;
}
</pre></div></li><li class="listitem"> Next, we will take a look at what this piece of code is doing and explain what is actually going on. So let's start.<p>The attribute keyword declares that this shader is going to be passed in an input variable called <code class="literal">position</code>. This will be used to indicate the position of the vertex. You will notice that the <code class="literal">position</code> variable has been declared of type <code class="literal">vec4</code>, which means that each vertex contains four floating-point values. The second attribute input variable that is declared with the variable name <code class="literal">normal</code>, has been declared of type <code class="literal">vec3</code>, which means that the vertex contains three floating-point values that are used for the rotational aspect around the <code class="literal">x</code>,<code class="literal"> y</code>, and <code class="literal">z</code> axes.
</p><p>The third attribute input variable that is declared with the variable name diffuseColor, defines the color to be used for the vertex. We declare another variable called colorVarying. You will notice that it doesn't contain the attribute keyword. This is because it is an output variable that will be passed to the fragment shader.
<a id="id135" class="indexterm"/>
</p><p>The varying keyword tells us the value for a particular vertex. This basically means that you can specify a different color for each vertex, and it will make all the values in-between a neat gradient that you will see in the final output. We have declared this as vec4, because colors are comprised of four component values.
</p></li><li class="listitem"> Finally, we declare two uniform keyword variables called<code class="literal"> modelViewProjectionMatrix and normalMatrix</code>. The model, view, and projection matrices are three separate matrices. Model maps from an object's local coordinate space into world space, view from world space to camera space, and projection from camera to screen.<p>When all three are used, you can then use the one result to map all the way from object space to screen space, enabling you to work out what you need to pass on to the next stage of a programmable pipeline from the incoming vertex positions.
</p><p>The normal matrix vectors are used to determine how much light is received at the specified vertex or surface. Uniforms are a second form of data that allow you to pass from your application code to the shaders. Uniform types are available to both vertex and fragment shaders, which, unlike attributes, are only available to the vertex shader.
</p><div><h3 class="title"><a id="note15"/>Note</h3><p>The value of a uniform cannot be changed by the shaders, and will have the same value every time a shader runs for a given trip through the pipeline. Uniforms can also contain any kind of data that you want to pass along for use in your shader.</p></div></li><li class="listitem"> Next, we assign the value from the color per-vertex attribute to the varying variable<code class="literal"> colorVarying</code>. This value will then be available in the fragment shader in interpolated form.</li><li class="listitem"> Finally, we modify the<code class="literal"> gl_Position</code> output variable, using the floating point translate variable to move the vertex along the<code class="literal"> X, Y</code>, and<code class="literal"> Z-axes</code>, based on the value of the translate uniform.<p>Next, we will take a look at the fragment shader that the OpenGL ES template created for us.
</p></li><li class="listitem"> Open the<code class="literal"> Shader.fsh</code> fragment shader file located within the<strong> OpenGLESExample</strong> folder of the<strong> Project Navigator</strong> window, and examine the following code snippet.<div><pre class="programlisting"><strong>varying lowp vec4 colorVarying;</strong>
void main(){
gl_FragColor = colorVarying;
}
</pre></div></li></ol></div><p>We will now take a look at this code snippet, and explain what is actually going on here.</p><p>You will notice that within the fragment shader, the declaration of the varying type variable<code class="literal"> colorVarying</code>, as highlighted in the code, has the same name as it did in the vertex shader. This is very important; if these names were different, OpenGL ES won't realize it's the same variable, and your program will produce unexpected results.</p><p>The type is also very important, and it has to be the same data type as it was declared within the vertex shader. This is a GLSL keyword that is used to specify the precision of the number of bytes used to represent a number.</p><p>From a programming point of view, the more bytes that are used to represent a number, the fewer problems you will be likely to have with the rounding of floating point calculations. GLSL allows the user to precision modifiers any time a variable is declared, and it must be declared within this file. Failure to declare it within the fragment shader, will result in your shader failing to compile.</p><p>The<code class="literal"> lowp</code> keyword is going to give you the best performance with the least accuracy during interpolation. This is the better option when dealing with colors, where small rounding errors don't matter. Should you find the need to increase the precision, it is better to use the<code class="literal"> mediump</code> or<code class="literal"> highp</code>, if the lack of precision causes you problems within your application.<a id="id136" class="indexterm"/>
</p><div><h3 class="title"><a id="note16"/>Note</h3><p>For more information on the<strong> OpenGL ES Shading Language</strong> (GLSL) or the<strong> Precision modifiers</strong>, refer to the following documentation located at:<a class="ulink" href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf"> http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf</a>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Error handling in OpenGL ES</h1></div></div></div><p>OpenGL provides simple error-handling routines for the base GL and GLU libraries. You can use the function<code class="literal"> glGetError</code> to check for errors. OpenGL only records the first error to occur. All subsequent errors are ignored, until the error buffer is cleared by a call to<code class="literal"> glGetError</code>.<a id="id137" class="indexterm"/>
</p><p>The command that caused the error is ignored, so it has no effect on OpenGL state or on the frame buffer contents. Once recorded, the current error code isn't cleared and additional errors aren't recorded until you call the query command<code class="literal"> glGetError()</code>, which returns the current error code. After you've queried and cleared the current error code, or if there's no error to begin with,<code class="literal"> glGetError()</code> returns<code class="literal"> GL_NO_ERROR</code>. The syntax of the<code class="literal"> glGetError</code> function is defined as follows:</p><div><pre class="programlisting">GLenum glGetError (void);
</pre></div><p>The<code class="literal"> glGetError</code> function returns the value of the error flag. When an error has been detected in either the GL or GLU libraries, the error flag is set to the appropriate error code value.<a id="id138" class="indexterm"/>
</p><div><h3 class="title"><a id="note17"/>Note</h3><p>If<code class="literal"> GL_NO_ERROR</code> is returned, there has been no detectable error since the last call to<code class="literal"> glGetError()</code>, or since the GL was initialized.</p><p>If no other errors are recorded until the<code class="literal"> glGetError()</code> method is called, the error code is returned, and the flag is reset to<code class="literal"> GL_NO_ERROR</code>.</p></div><p>The following table lists the basic defined OpenGL error codes and their descriptions that are returned by the<code class="literal"> glGetError</code> method call.<a id="id139" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p><strong>Error code</strong></p>
</th><th style="text-align: left" valign="bottom">
<p><strong>Description</strong></p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GL_INVALID_ENUM</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">GLenum</code> argument out of range</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GL_INVALID_VALUE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Numeric argument out of range</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GL_INVALID_OPERATION</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Operation illegal in current state</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GL_STACK_OVERFLOW</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Command would cause a stack overflow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GL_STACK_UNDERFLOW</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Command would cause a stack underflow</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GL_OUT_OF_MEMORY</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Not enough memory left to execute command</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GL_NO_ERROR</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No error has occurred.</p>
</td></tr></tbody></table></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec03"/>Detecting errors by setting up breakpoints</h2></div></div></div><p>Setting breakpoints within your code gives you the flexibility to stop execution at any point within your code, so that you can investigate and step through to find out why a piece of code is not working correctly. This is particularly handy if you want to step through specific OpenGL functions. These breakpoints should be set immediately before calling the function, and your program will be stopped and the status bar will indicate which function caused the breakpoint.<a id="id140" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec04"/>Setting up breakpoints in your code</h2></div></div></div><p>Although you can use the debugger to pause execution of your program at any time and view the state of the running code, it's usually helpful to set breakpoints before running your executable so that you can stop at known points, and view the values of variables in your source code.<a id="id141" class="indexterm"/>
</p><p>A breakpoint is basically an instruction in your code that tells the application to<em> stop</em> when the breakpoint is reached, and execution of the program pauses, waiting for further instructions as to what to do next. During this phase, you have the opportunity to either inspect the current values of any of the properties, or step through the code.</p><p>Let's take a look at the following routine that uses the<code class="literal"> glGetError</code> method.<a id="id142" class="indexterm"/>
</p><div><pre class="programlisting">- (void)startAnimation{
if (!animating) {
CADisplayLink *aDisplayLink = [[UIScreenmainScreen] displayLinkWithTarget:self selector:@selector(drawFrame)];
[aDisplayLinksetFrameInterval:animationFrameInterval];
[aDisplayLinkaddToRunLoop:[NSRunLoopcurrentRunLoop] forMode:NSDefaultRunLoopMode];
self.displayLink = aDisplayLink;
<strong>GLenum err;
err = glGetError();
while ( GL_NO_ERROR != err ) {
NSLog(@"Error. glError: 0x%04X", err);
err = glGetError();
}</strong>
animating = YES;
}
}
</pre></div><p>You will notice that we have declared a variable<code class="literal"> err</code>, which will be used to store the error number that will be returned by the<code class="literal"> glGetError</code> method. We then cycle through and output each error message's details to the debug console window until no more errors exist, upon which, we exit from the loop. Although you can use the Xcode 4 debugger to pause execution of your program at any time to view the state of your running code, it is more helpful to set breakpoints at those areas prior to running your application.<a id="id143" class="indexterm"/>
</p><p>To set breakpoints, open any source implementation file, and click within the gutter pane section of the Xcode source editor, next to the spot to where you would like your program to stop. When you add a breakpoint, Xcode will automatically enable it and this will be indicated by a light blue color as shown in the screenshot below. Breakpoints can also be toggled to be switched off, by clicking on the breakpoint again, having this turn to more of a transparent color.<a id="id144" class="indexterm"/>
</p><p>The<strong> Breakpoint Navigator</strong> window shows all current breakpoints that have been set within your project, and will display all active as well as inactive breakpoints.<a id="id145" class="indexterm"/>
</p><div><img src="img/2267EXP_03_18.jpg" alt="Setting up breakpoints in your code"/></div><p>This view contains several options that can be configured for each breakpoint, and a breakpoint can contain multiple conditions. You can choose to log messages out to the Xcode console window, or execute a<code class="literal"> debug</code> command. To access this view, hold down the<em> control</em> key, and right-click with the mouse.<a id="id146" class="indexterm"/>
</p><p>A new feature that comes with Xcode 4.2, is the ability to capture OpenGL frames, so that you can debug your code right within the Xcode development environment, and scroll through each of your OpenGL ES method calls, as well as viewing state and objects.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec05"/>Setting conditional OpenGL ES entry point breakpoints</h2></div></div></div><p>We have looked at setting breakpoints within your code in the event that you want your application to stop whenever that particular line is hit. Another way in which you can use breakpoints, is to have them stop when a particular condition has been met, and then have it perform a particular action, as shown in following example:<a id="id147" class="indexterm"/>
</p><div><img src="img/2267EXP_03_19.jpg" alt="Setting conditional OpenGL ES entry point breakpoints"/></div><p>You have the ability to either have it stop when the condition has been met, as seen in this screenshot, or you can choose to ignore the condition altogether and have it fire after a specified number of times the method gets called.</p><p>You can then choose to have it fire of a particular action. As you can see from this screenshot, we set up a condition to capture the current frame when the variable<code class="literal"> transY</code> is greater than or equal to<code class="literal"> 2</code>. This will then launch the<strong> OpenGL Frame Capture</strong> section, so that we can step through and debug our code further, to see what is going on.</p><p>There are other ways in which we can debug OpenGL ES projects through the use of<strong> Instruments</strong>, which we will be covering in<a class="link" href="ch06.html" title="Chapter 6. Xcode Tools - Improvements"> Chapter 6</a>,<em>Xcode Tools Improvements</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec06"/>Breaking on frame boundaries</h2></div></div></div><p>The<strong> OpenGL ES Debugger</strong> allows you to see all of the frames that are being drawn within your application. You can have your application break at a certain point within your program, and then use the debug navigator to navigate to the area within your code to where the frame has been drawn. In the following screenshot, it displays the instance of the captured frame, and displays the state calls associated within that frame:<a id="id148" class="indexterm"/>
</p><div><img src="img/2267EXP_03_20.jpg" alt="Breaking on frame boundaries"/></div><p>Selecting the<code class="literal"> glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)</code> option, as shown in the previous screenshot, will allow you to see a list of all of the associated draw calls that have been made. You can also cycle through the frames that have been captured by using the scrub bar, as highlighted in the previous screenshot.</p><div><img src="img/2267EXP_03_21.jpg" alt="Breaking on frame boundaries"/></div><p>Clicking on the<strong> [OpenGLESExampleViewController drawframe]</strong> method , as shown in the previous screenshot, will open the Xcode development IDE and take you directly to the area to where your code is located, as shown in the following screenshot:<a id="id149" class="indexterm"/>
</p><div><img src="img/2267EXP_03_16.jpg" alt="Breaking on frame boundaries"/></div><p>By using the OpenGL ES debugger, you can step through each of your frames within your application, to help you track-down and debug when textures are not rendering properly, or if the colors on your object look odd.<a id="id150" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Summary</h1></div></div></div><p>In this chapter, we learned about the differences between vertex shaders and fragment shaders, and their relation to one another. We then looked at the new debugging features of OpenGL ES, and how this new debugger in Xcode allows you to track down issues specific to OpenGL ES within your code, right within the Xcode IDE.</p><p>We familiarized ourselves with the OpenGL ES frame capture tool, its ability to stop execution of a program, and grab the current frame contents that are being rendered on the iOS device. This is so that we are able to easily track-down and correct program issues, by taking a closer look at the program state information of objects, by scrolling through the debug navigator stack trace, as well as the ability to see all of the textures and shaders currently being used by the application.</p><p>We also learned about the OpenGL ES<code class="literal"> glGetError</code> method call, and how we can use this to provide us with a list of errors that have been detected. To end the chapter, we looked at how we can break on frame boundaries within OpenGL and see the values of the current program frame state, as defined by the objects.</p><p>In the next chapter, we will gain an understanding of what<strong> Storyboards</strong> are, and how we can apply the various transitions between views, as well as how to create and configure scenes and storyboard files, to present these programmatically. We will also look at how to build and integrate Twitter capabilities into our application, to tweet photos and standard messages.</p></div></body></html>