<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-135"><a id="_idTextAnchor238"/>5</h1>
<h1 id="_idParaDest-136"><a id="_idTextAnchor239"/>Using DataStore to Store Data and Testing</h1>
<p>Modern Android Development practices help Android developers create better applications. DataStore is a data storage solution provided by the Android Jetpack library. It allows developers to store key-value pairs or complex objects asynchronously and with consistency guarantees. Data is critical in Android development, and how we save and persist data matters. In this chapter, we will explore using DataStore to persist our data and look at best practices using DataStore.</p>
<p>In this chapter, we’ll be covering the following recipes:</p>
<ul>
<li>Implementing DataStore</li>
<li>Adding Dependency Injection to DataStore</li>
<li>Using Android Proto DataStore versus DataStore</li>
<li>Handling data migration with DataStore</li>
<li>Writing tests for our DataStore instance</li>
</ul>
<h1 id="_idParaDest-137"><a id="_idTextAnchor240"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five</a>.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor241"/>Implementing DataStore</h1>
<p>When building <a id="_idIndexMarker338"/>mobile applications, it is critical to ensure that you persist your data in order to allow for smooth loading, reduce network issues, or even handle data entirely offline. In this recipe, we will look at how to store data in our Android applications using the Modern Android Development Jetpack library called DataStore.</p>
<p>DataStore is<a id="_idIndexMarker339"/> a data storage solution for Android applications that enables you to store key-value pairs or any typed objects with protocol buffers. Moreover, DataStore uses Kotlin coroutines and flows to store data consistently, transactionally, and asynchronously.</p>
<p>If you have built Android applications before, you might have used <code>SharedPreferences</code>. The new Preferences DataStore aims to replace this old method. It is also fair to say that Preferences DataStore harnesses the power of <code>SharedPreferences</code> since they are pretty similar. In addition, Google’s documentation recommends that if you’re currently using <code>SharedPreferences</code> in your project to store data, you consider migrating to the latest DataStore version.</p>
<p>Another way to store data in Android is by using Room. This will be covered in <a href="B18827_06.xhtml#_idTextAnchor283"><em class="italic">Chapter 6</em></a>, <em class="italic">Using the Room Database and Testing</em>; for now, we will just look at DataStore. Moreover, it is essential to note that DataStore is ideal for simple or small datasets and does not have support for partial updates or referential integrity<a id="_idTextAnchor242"/>.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor243"/>How to do it…</h2>
<p>Let’s go ahead and create a new, empty Compose project and call it <code>DataStoreSample</code>. In our example project, we will create a task entry app where users can save tasks. We will allow users to enter only three tasks, then use DataStore to store the tasks and later log the data and see whether it was inserted correctly. An additional exercise to try is to display data when users want to see it:</p>
<ol>
<li>In our newly created project, let’s go ahead and delete code that we don’t need. In this case, we’re referring to the <code>Greeting(name: String)</code> that comes with all empty Compose projects. Keep the Preview function since we will use it to view the screen we create.</li>
<li>Now, let’s go on and add the required dependencies for DataStore and sync the project. Also, note that there are versions of the DataStore library that are specific to RxJava 2 and 3:<pre class="source-code">
dependencies {</pre><pre class="source-code">
implementation "androidx.DataStore:DataStore-preferences:1.x.x"</pre><pre class="source-code">
}</pre></li>
<li>Create a new package and call it <code>data</code>. Inside <code>data</code>, create a new Kotlin data class and call it <code>Tasks</code>.</li>
<li>Let’s<a id="_idIndexMarker340"/> now go ahead and construct our data class with the expected input fields:<pre class="source-code">
data class Tasks(</pre><pre class="source-code">
    val firstTask: String,</pre><pre class="source-code">
    val secondTask: String,</pre><pre class="source-code">
    val thirdTask: String</pre><pre class="source-code">
)</pre></li>
<li>Inside the same package, let’s add a <code>TaskDataSource</code> enum since we will reuse this project to showcase saving data using Proto DataStore in the <em class="italic">Using Android Proto DataStore versus </em><em class="italic">DataStore</em> recipe:<pre class="source-code">
enum class TaskDataSource {</pre><pre class="source-code">
    PREFERENCES_DATA_STORE</pre><pre class="source-code">
}</pre></li>
<li>Inside our package, let’s go ahead and add a <code>DataStoreManager</code> interface. Inside our class, we will have a <code>saveTasks()</code> function to save the data and a <code>getTasks()</code> function to help us retrieve the saved data. A <code>suspend</code> function in Kotlin is simply a function that can be paused and resumed later.</li>
</ol>
<p>In addition, the suspend functions can execute long-running operations and await completion without blocking:</p>
<pre class="source-code">
interface DataStoreManager {
    suspend fun saveTasks(tasks: Tasks)
    fun getTasks(): Flow&lt;Tasks&gt;
}</pre>
<ol>
<li value="7">Next, we need to implement our interface, so let’s go ahead and create a <code>DataStoreManagerImpl</code> class and implement the <code>DataStoreManager</code>. To <a id="_idIndexMarker341"/>refresh your knowledge of Flows, refer to <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and </em><em class="italic">Using Hilt</em>:<pre class="source-code">
class DataStoreManagerImpl(): DataStoreManager {</pre><pre class="source-code">
    override suspend fun saveTasks(tasks: Tasks) {</pre><pre class="source-code">
        TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override fun getTasks(): Flow&lt;Tasks&gt; {</pre><pre class="source-code">
        TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>You will notice that once we’ve implemented the interface, we brought a view to the function, but it says <code>TODO</code>, and nothing has been implemented. To continue with this step, let’s go ahead and add DataStore and pass <code>Preference</code> in our constructor. We will also need to create the string preference key for each task:<pre class="source-code">
class DataStoreManagerImpl(</pre><pre class="source-code">
    private val tasksPreferenceStore:</pre><pre class="source-code">
        DataStore&lt;Preferences&gt;</pre><pre class="source-code">
) : DataStoreManager {</pre><pre class="source-code">
    private val FIRST_TASK =</pre><pre class="source-code">
        stringPreferencesKey("first_task")</pre><pre class="source-code">
    private val SECOND_TASK =</pre><pre class="source-code">
        stringPreferencesKey("second_task")</pre><pre class="source-code">
    private val THIRD_TASK =</pre><pre class="source-code">
        stringPreferencesKey("third_task")</pre><pre class="source-code">
    override suspend fun saveTasks(tasks: Tasks) {</pre><pre class="source-code">
        tasksPreferenceStore.edit {</pre><pre class="source-code">
        taskPreferenceStore -&gt;</pre><pre class="source-code">
            taskPreferenceStore[FIRST_TASK] =</pre><pre class="source-code">
                tasks.firstTask</pre><pre class="source-code">
            taskPreferenceStore[SECOND_TASK] =</pre><pre class="source-code">
                tasks.secondTask</pre><pre class="source-code">
            taskPreferenceStore[THIRD_TASK] =</pre><pre class="source-code">
                tasks.thirdTask</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override fun getTasks(): Flow&lt;Tasks&gt; {</pre><pre class="source-code">
        TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, let’s finish our implementation of the <code>DataStore</code> section by adding functionality to the <code>getTasks</code> function:<pre class="source-code">
override fun getTasks(): Flow&lt;Tasks&gt; = tasksPreferenceStore.data.map { taskPreference -&gt;</pre><pre class="source-code">
    Tasks(</pre><pre class="source-code">
        firstTask = taskPreference[FIRST_TASK] ?: "",</pre><pre class="source-code">
        secondTask = taskPreference[SECOND_TASK] ?:</pre><pre class="source-code">
        "",</pre><pre class="source-code">
        thirdTask = taskPreference[THIRD_TASK] ?: ""</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>In <a id="_idIndexMarker342"/>our <code>MainActivity</code> class, let’s go on and create a simple UI: three <code>TextField</code> and a <strong class="bold">Save</strong> button. The <strong class="bold">Save</strong> button will save our data, and we can try to log data once everything works as expected. Refer to the <em class="italic">Technical requirements</em> section of this chapter to get the UI code.</li>
</ol>
<div><div><img alt="Figure 5.1 – The DataStore UI exam﻿ple" src="img/Figure_5.1_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The DataStore UI exam<a id="_idTextAnchor244"/>ple</p>
<p>Now that we <a id="_idIndexMarker343"/>have our implementation ready, in the following recipe, <em class="italic">Adding Dependency Injection to DataStore</em>, we will add Dependency Injection and then glue everything together.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor245"/>How it works…</h2>
<p>The new<a id="_idIndexMarker344"/> Modern Android Development Jetpack library called Preferences DataStore’s main objective is to replace <code>SharedPreferences</code>. To implement Preferences DataStore, as you have seen in the recipe, we use a DataStore interface that takes in a <code>Preference</code> abstract class, and we can use this to edit and map the entry data. Furthermore, we create keys for the crucial parts of the key-value pairs:</p>
<pre class="source-code">
private val FIRST_TASK = stringPreferencesKey("first_task")
private val SECOND_TASK = stringPreferencesKey("second_task")
private val THIRD_TASK = stringPreferencesKey("third_task")</pre>
<p>To save<a id="_idIndexMarker345"/> our data in DataStore, we use <code>edit()</code>, which is a suspend function that needs to be called from <code>CoroutineContext</code>. A key difference in using Preferences DataStore compared to <code>SharedPreferences</code> is that DataStore is safe to call on the UI thread since it uses <code>dispatcher.IO</code> under the hood.</p>
<p>You also do not need to use <code>apply{} </code>or <code>commit</code> functions to save the changes, as is required in <code>SharedPreferences</code>. Moreover, it handles data updates transactionally. More features are listed in <em class="italic">Figure 5</em><em class="italic">.2</em>.</p>
<div><div><img alt="Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com" src="img/Figure_5.2_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com</p>
<p>There is more to learn, and it is fair to acknowledge that what we covered in this recipe is just a tiny part of what you can do with DataStore. We will cover more features in the following rec<a id="_idTextAnchor246"/>ipes.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor247"/>Adding Dependency Injection to DataStore</h1>
<p>Dependency Injection<a id="_idIndexMarker346"/> is an important design pattern in software engineering, and its use in Android app development can lead to cleaner and more maintainable code. When it comes to DataStore in Android, which is a modern data storage solution introduced in Android Jetpack, adding <a id="_idIndexMarker347"/>Dependency Injection <a id="_idIndexMarker348"/>can bring several benefits:</p>
<ul>
<li>By using Dependency Injection, you can separate the concerns of creating an instance of DataStore from the code that uses it. This means that your business logic code will not have to worry about how to create a DataStore instance and can instead focus on what it needs to do with the data.</li>
<li>Dependency Injection makes it easier to write unit tests for your app. By injecting a mock DataStore instance into your tests, you can ensure that your tests are not affected by the actual state of the DataStore.</li>
<li>Dependency Injection can help you break down your code into smaller, more manageable modules. This makes it easier to add new features or modify existing ones without affecting the entire code base.</li>
<li>By using Dependency Injection, you can easily switch between different implementations of DataStore. This can be useful when testing different types of data storage or when migrating from one storage solution to <a id="_idTextAnchor248"/><a id="_idTextAnchor249"/>another.</li>
</ul>
<h2 id="_idParaDest-142"><a id="_idTextAnchor250"/>How to do it…</h2>
<p>You need to have completed the previous recipe to continue with this one by executing the following steps:</p>
<ol>
<li>Open your project and add the necessary Hilt dependency. See the <em class="italic">Handling the UI State in Jetpack Compose and Using Hilt</em> recipe in <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a> if you need help setting it up.</li>
<li>Next, let’s go ahead and add our <code>@HiltAndroidApp</code> class, and in our <code>Manifest</code> folder, add the <code>.name = </code><code>TaskApp: android:name=".TaskApp"</code>:<pre class="source-code">
@HiltAndroidApp</pre><pre class="source-code">
class TaskApp : Application()</pre><pre class="source-code">
&lt;application</pre><pre class="source-code">
    android:allowBackup="true"</pre><pre class="source-code">
    android:name=".TaskApp"</pre><pre class="source-code">
    tools:targetApi="31"&gt;</pre><pre class="source-code">
...</pre></li>
<li>Now <a id="_idIndexMarker349"/>that we have implemented Dependency <a id="_idIndexMarker350"/>Injection, let’s go ahead and add <code>@AndroidEntryPoint</code> to the <code>MainActivity</code> class, and in <code>DataStoreManagerImpl</code>, let’s go ahead and add the <code>@Inject constructor</code>. We should have something similar to the following code snippet:<pre class="source-code">
class DataStoreManagerImpl @Inject constructor(</pre><pre class="source-code">
    private val tasksPreferenceStore:</pre><pre class="source-code">
    DataStore&lt;Preferences&gt;</pre><pre class="source-code">
) : DataStoreManager {</pre></li>
<li>Now, we need to create a new folder and call it <code>di</code>; this is where we will put our <code>DataStoreModule</code> class. We create a file called <code>store_tasks</code> to store the Preference values:<pre class="source-code">
@Module</pre><pre class="source-code">
@InstallIn(SingletonComponent::class)</pre><pre class="source-code">
class DataStoreModule {</pre><pre class="source-code">
    private val Context.tasksPreferenceStore :</pre><pre class="source-code">
    DataStore&lt;Preferences&gt; by</pre><pre class="source-code">
    preferencesDataStore(name = "store_tasks")</pre><pre class="source-code">
    @Singleton</pre><pre class="source-code">
    @Provides</pre><pre class="source-code">
    fun provideTasksPreferenceDataStore(</pre><pre class="source-code">
        @ApplicationContext context: Context</pre><pre class="source-code">
    ): DataStore&lt;Preferences&gt; =</pre><pre class="source-code">
       context.tasksPreferenceStore</pre><pre class="source-code">
}</pre></li>
<li>We <a id="_idIndexMarker351"/>will also need to create an <code>abstract</code> class for <code>DataStoreManagerModule</code> inside our <code>di</code> package. In order to reduce the<a id="_idIndexMarker352"/> boilerplate code using manual Dependency Injection, our application also supplies the required dependencies to the classes that need them. You can learn more about this in <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and </em><em class="italic">Using Hilt</em>:<pre class="source-code">
@Module</pre><pre class="source-code">
@InstallIn(SingletonComponent::class)</pre><pre class="source-code">
abstract class DataStoreManagerModule {</pre><pre class="source-code">
    @Singleton</pre><pre class="source-code">
    @Binds</pre><pre class="source-code">
    abstract fun</pre><pre class="source-code">
        bindDataStoreRepository(DataStoreManagerImpl:</pre><pre class="source-code">
            DataStoreManagerImpl): DataStoreManager</pre><pre class="source-code">
}</pre></li>
<li>Let’s now <a id="_idIndexMarker353"/>go ahead and create a new package and call it <code>service</code>:<pre class="source-code">
interface TaskService {</pre><pre class="source-code">
    fun getTasksFromPrefDataStore(): Flow&lt;Tasks&gt;</pre><pre class="source-code">
    suspend fun addTasks(tasks: Tasks)</pre><pre class="source-code">
}</pre><pre class="source-code">
class TaskServiceImpl @Inject constructor(</pre><pre class="source-code">
    private val DataStoreManager: DataStoreManager</pre><pre class="source-code">
) : TaskService {</pre><pre class="source-code">
    override fun getTasksFromPrefDataStore() =</pre><pre class="source-code">
             DataStoreManager.getTasks()</pre><pre class="source-code">
    override suspend fun addTasks(tasks: Tasks) {</pre><pre class="source-code">
        DataStoreManager.saveTasks(tasks)</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Let’s also<a id="_idIndexMarker354"/> ensure we have the required dependencies  for the newly created service:<pre class="source-code">
    @Singleton</pre><pre class="source-code">
    @Binds</pre><pre class="source-code">
    abstract fun bindTaskService(taskServiceImpl:</pre><pre class="source-code">
    TaskServiceImpl): TaskService</pre><pre class="source-code">
}</pre></li>
<li>Now that we are done with Dependency Injection and adding all the functionalities required for DataStore, we will go ahead and add a <code>ViewModel</code> class and<a id="_idIndexMarker355"/> implement functionality <a id="_idIndexMarker356"/>to save the data once the user clicks the Save button:<pre class="source-code">
fun saveTaskData(tasks: Tasks) {</pre><pre class="source-code">
    viewModelScope.launch {</pre><pre class="source-code">
        Log.d("Task", "asdf Data was inserted</pre><pre class="source-code">
               correctly")</pre><pre class="source-code">
        taskService.addTasks(tasks)</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Call the <code>saveTaskData</code> function inside the Compose Save button in the Compose view to save our data:<pre class="source-code">
TaskButton(onClick = {</pre><pre class="source-code">
    val tasks = Tasks(</pre><pre class="source-code">
        firstTask = firstText.value,</pre><pre class="source-code">
        secondTask = secondText.value,</pre><pre class="source-code">
        thirdTask = thirdText.value</pre><pre class="source-code">
    )</pre><pre class="source-code">
    taskViewModel.saveTaskData(tasks)},</pre><pre class="source-code">
    text = stringResource(id = R.string.save))</pre></li>
<li>Lastly, we will need to verify that everything is working, that is, our UI and data storing process. We can verify this, by typing input data in our TextFields and clicking the Save button, and when we log the message it confirms the data is indeed saved.</li>
</ol>
<div><div><img alt="Figure 5.3 – The entry of tasks" src="img/Figure_5.3_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The entry of tasks</p>
<ol>
<li value="11">If you <a id="_idIndexMarker357"/>missed it initially, the code for this<a id="_idIndexMarker358"/> view can be found in the <em class="italic">Technical requirement</em> section. Now, you will notice that when we enter the data, as in <em class="italic">Figure 5</em><em class="italic">.4</em>, we should be able to log the data on our Logcat and verify that our data was inserted correctly.</li>
</ol>
<div><div><img alt="Figure 5.4 – The entry of tasks through debugging" src="img/Figure_5.4_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The entry of tasks through debugging</p>
<ol>
<li value="12">A log <a id="_idIndexMarker359"/>message should also be displayed <a id="_idIndexMarker360"/>in the Logcat tab if all is working as expected.</li>
</ol>
<div><div><img alt="Figure 5.5 – The debug log indicating that data was i﻿nserted correctly" src="img/Figure_5.5_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The debug log indicating that data was i<a id="_idTextAnchor251"/>nserted correctly</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor252"/>How it works…</h2>
<p>In this recipe, we opted to use Dependency Injection to supply the required dependencies to specific classes. We’ve already covered what Dependency Injection is in depth, so we will not explain it again but instead talk about the modules we created.</p>
<p>In our project, we created <code>DataStoreManagerModule</code> and <code>DataStoreModule</code>, and all we did was supply the required dependencies. We created a file and called it <code>store_tasks</code>, which helps us store the Preference values:</p>
<pre class="source-code">
private val Context.tasksPreferenceStore : DataStore&lt;Preferences&gt; by preferencesDataStore(name = "store_tasks")</pre>
<p>By default, DataStore uses<a id="_idIndexMarker361"/> coroutines and returns a<a id="_idIndexMarker362"/> flow value. Some important rules to remember while using DataStore, as per the documentation, are as follows:</p>
<ul>
<li>DataStore requires only one instance for a given file in the same process. Hence, we should never create more than one instance of DataStore.</li>
<li>Always have the generic <code>DataStore</code> type be immutable to reduce unnecessary and hard-to-trace bugs.</li>
<li>You should never mix the usage of a single-process DataStore and multi-process DataStore in the same file.</li>
</ul>
<h2 id="_idParaDest-144"><a id="_idTextAnchor253"/>There’s more…</h2>
<p>As an exercise, you can try to add another button and display the saved data in a lazy colu<a id="_idTextAnchor254"/>mn or a t<a id="_idTextAnchor255"/>ext field.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor256"/>See also</h2>
<p>There is more to learn about DataStore, and this recipe has only given you an overview of what you can do with DataStore. You can learn more by following the link at <a href="https://developer.android.com/topic/libraries/architecture/datastore">https://developer.android.com/topic/libraries/architecture/datastore</a>.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor257"/>Using Android Proto DataStore versus DataStore</h1>
<p><em class="italic">Figure 5</em><em class="italic">.2</em> shows the<a id="_idIndexMarker363"/> differences between <code>PreferencesDataStore</code>, <code>SharedPreferences</code>, and <code>ProtoDataStore</code>. In this recipe, we will explore how we can use Proto DataStore. The Proto DataStore implementation uses DataStore and Protocol Buffers to persist typed objects to the disk.</p>
<p>Proto DataStore is<a id="_idIndexMarker364"/> similar to Preferences DataStore, but unlike Preferences DataStore, Proto does not use key-value pairs and just returns the generated object in the flow. The file types and structure of the data depend on the schema o<a id="_idTextAnchor258"/>f the <code>.</code><code>protoc</code> files.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor259"/>Getting ready</h2>
<p>We will use our already created project to show how you can use Proto DataStore in Android. We will also use already created classes and just give the funct<a id="_idTextAnchor260"/>ions different names.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor261"/>How to do it…</h2>
<ol>
<li>We <a id="_idIndexMarker365"/>will need to start by setting up the required<a id="_idIndexMarker366"/> dependencies, so let’s go ahead and add the following to our Gradle app-level file:<pre class="source-code">
implementation "androidx.DataStore:DataStore:1.x.x</pre><pre class="source-code">
implementation "com.google.protobuf:protobuf-javalite:3.x.x"</pre></li>
<li>Next, we will need to add <code>protobuf</code> to <code>plugins</code> in our <code>build.gradle</code> file:<pre class="source-code">
plugins {</pre><pre class="source-code">
...</pre><pre class="source-code">
    id "com.google.protobuf" version "0.8.12"</pre><pre class="source-code">
}</pre></li>
<li>We will need to add the <code>protobuf</code> configuration to our <code>build.gradle</code> file to finalize our setup:<pre class="source-code">
protobuf {</pre><pre class="source-code">
    protoc {</pre><pre class="source-code">
        artifact = "com.google.protobuf:protoc:3.11.0"</pre><pre class="source-code">
    }</pre><pre class="source-code">
    generateProtoTasks {</pre><pre class="source-code">
        all().each { task -&gt;</pre><pre class="source-code">
            task.builtins {</pre><pre class="source-code">
                 java {</pre><pre class="source-code">
                     option 'lite'</pre><pre class="source-code">
                 }</pre><pre class="source-code">
            }</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now, inside our <code>package</code> folder, we will need to add our <code>proto</code> file under <code>app/src/main/</code>, then<a id="_idIndexMarker367"/> create a new directory <a id="_idIndexMarker368"/>and call it <code>proto</code>. You should now have this in your <code>app/src/main/proto</code> file directory:<pre class="source-code">
syntax = "proto3";</pre><pre class="source-code">
option java_package =</pre><pre class="source-code">
    "com.madonasyombua.DataStoreexample";</pre><pre class="source-code">
option java_multiple_files = true;</pre><pre class="source-code">
message TaskPreference {</pre><pre class="source-code">
    string first_task = 1;</pre><pre class="source-code">
    string second_task = 2;</pre><pre class="source-code">
    string third_task = 3;</pre><pre class="source-code">
}</pre></li>
</ol>
<p>That was a lot to set up. We can now start adding code to hook everything up.</p>
<ol>
<li value="5">Let’s modify classes that might need <code>ProtoDataStore</code>. First, let’s add <code>PROTO_DATA_STORE</code> to the <code>TaskDataSource</code> enum class:<pre class="source-code">
enum class TaskDataSource {</pre><pre class="source-code">
    PREFERENCES_DATA_STORE,</pre><pre class="source-code">
    PROTO_DATA_STORE</pre><pre class="source-code">
}</pre></li>
<li>In <code>DataStoreManager</code>, let’s add <code>saveTaskToProtoStore()</code> and <code>getUserFromProtoStore()</code>, and our <a id="_idIndexMarker369"/>new interface will look like this:<pre class="source-code">
interface DataStoreManager {</pre><pre class="source-code">
    suspend fun saveTasks(tasks: Tasks)</pre><pre class="source-code">
    fun getTasks(): Flow&lt;Tasks&gt;</pre><pre class="source-code">
    suspend fun saveTasksToProtoStore(tasks: Tasks)</pre><pre class="source-code">
    fun getTasksFromProtoStore(): Flow&lt;Tasks&gt;</pre><pre class="source-code">
}</pre></li>
<li>Since we <a id="_idIndexMarker370"/>just modified our interface, we will need to go ahead and add new functionalities to the implementation class. You will also notice that the project will complain once you add the functions:<pre class="source-code">
override suspend fun saveTasksToProtoStore(tasks: Tasks) {</pre><pre class="source-code">
    TODO("Not yet implemented")</pre><pre class="source-code">
}</pre><pre class="source-code">
override fun getTasksFromProtoStore(): Flow&lt;Tasks&gt; {</pre><pre class="source-code">
    TODO("Not yet implemented")</pre><pre class="source-code">
}</pre></li>
<li>As recommended, we will need to define a class that implements <code>Serializer&lt;Type&gt;</code>, where the type is defined in the Proto file. The purpose of this serializer class is to <a id="_idIndexMarker371"/>tell DataStore how to read and write our data type. So, let’s <a id="_idIndexMarker372"/>create a new object and call it <code>TaskSerializer()</code>:<pre class="source-code">
object TaskSerializer : Serializer&lt;TaskPreference&gt; {</pre><pre class="source-code">
    override val defaultValue: TaskPreference =</pre><pre class="source-code">
        TaskPreference.getDefaultInstance()</pre><pre class="source-code">
    override suspend fun readFrom(input: InputStream):</pre><pre class="source-code">
        TaskPreference{</pre><pre class="source-code">
            try {</pre><pre class="source-code">
                return TaskPreference.parseFrom(input)</pre><pre class="source-code">
            } catch (exception:</pre><pre class="source-code">
            InvalidProtocolBufferException) {</pre><pre class="source-code">
              throw CorruptionException("Cannot read</pre><pre class="source-code">
              proto.", exception)</pre><pre class="source-code">
            }</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override suspend fun writeTo(t: TaskPreference,</pre><pre class="source-code">
        output: OutputStream) = t.writeTo(output)</pre><pre class="source-code">
}</pre></li>
<li>The <code>TaskPreference</code> class is auto-generated, and you can access it directly by clicking on it but cannot edit it. Auto-generated files are not editable unless you change the original file.</li>
</ol>
<div><div><img alt="Figure 5.6 – A screenshot showing the auto-generated TaskPreference class" src="img/Figure_5.6_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – A screenshot showing the auto-generated TaskPreference class</p>
<ol>
<li value="10">Now that we<a id="_idIndexMarker373"/> have created our data type class, we need<a id="_idIndexMarker374"/> to create a <code>taskProtoDataStore: DataStore&lt;TaskPreference&gt;</code> with the context used with DataStore. Hence, inside <code>DataStoreModule</code>, let’s go ahead and add this code:<pre class="source-code">
private val Context.taskProtoDataStore: DataStore&lt;TaskPreference&gt; by DataStore(</pre><pre class="source-code">
    fileName = "task.pd",</pre><pre class="source-code">
    serializer = TaskSerializer</pre><pre class="source-code">
)</pre><pre class="source-code">
@Singleton</pre><pre class="source-code">
@Provides</pre><pre class="source-code">
fun provideTasksProtoDataStore(</pre><pre class="source-code">
    @ApplicationContext context: Context</pre><pre class="source-code">
):DataStore&lt;TaskPreference&gt; = context.taskProtoDataStore</pre></li>
<li>Now, let’s<a id="_idIndexMarker375"/> go back to <code>DataStoreManagerImpl</code> and work on the functions that we are <a id="_idIndexMarker376"/>yet to implement:<pre class="source-code">
override suspend fun saveTasksToProtoStore(tasks: Tasks) {</pre><pre class="source-code">
    taskProtoDataStore.updateData { taskData -&gt;</pre><pre class="source-code">
        taskData.toBuilder()</pre><pre class="source-code">
            .setFirstTask(tasks.firstTask)</pre><pre class="source-code">
            .setSecondTask(tasks.secondTask)</pre><pre class="source-code">
            .setThirdTask(tasks.thirdTask)</pre><pre class="source-code">
            .build()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre><pre class="source-code">
override fun getTasksFromProtoStore(): Flow&lt;Tasks&gt; =</pre><pre class="source-code">
    taskProtoDataStore.data.map { tasks -&gt;</pre><pre class="source-code">
        Tasks(</pre><pre class="source-code">
            tasks.firstTask,</pre><pre class="source-code">
            tasks.secondTask,</pre><pre class="source-code">
            tasks.thirdTask</pre><pre class="source-code">
        )</pre></li>
<li>In <code>TaskService</code>, we will also go ahead and add <code>getTasksFromProto</code>, and <code>getTasks()</code>:<pre class="source-code">
interface TaskService {</pre><pre class="source-code">
    fun getTasksFromPrefDataStore() : Flow&lt;Tasks&gt;</pre><pre class="source-code">
    suspend fun addTasks(tasks: Tasks)</pre><pre class="source-code">
    fun getTasks(): Flow&lt;Tasks&gt;</pre><pre class="source-code">
    fun getTasksFromProtoDataStore(): Flow&lt;Tasks&gt;</pre><pre class="source-code">
}</pre></li>
<li>When you<a id="_idIndexMarker377"/> implement an interface, at first the class <a id="_idIndexMarker378"/>that is being implemented will might show compile error, which will prompt you to override the interface functionalities into the class. Hence, inside the <code>TaskServiceImpl</code> class, add the following code:<pre class="source-code">
class TaskServiceImpl @Inject constructor(</pre><pre class="source-code">
    private val DataStoreManager: DataStoreManager</pre><pre class="source-code">
) : TaskService {</pre><pre class="source-code">
    override fun getTasksFromPrefDataStore() =</pre><pre class="source-code">
        DataStoreManager.getTasks()</pre><pre class="source-code">
    override suspend fun addTasks(tasks: Tasks) {</pre><pre class="source-code">
        DataStoreManager.saveTasks(tasks)</pre><pre class="source-code">
        DataStoreManager.saveTasksToProtoStore(tasks)</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override fun getTasks(): Flow&lt;Tasks&gt; =</pre><pre class="source-code">
        getTasksFromProtoDataStore()</pre><pre class="source-code">
    override fun getTasksFromProtoDataStore():</pre><pre class="source-code">
        Flow&lt;Tasks&gt; =</pre><pre class="source-code">
        DataStoreManager.getTasksFromProtoStore()</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Finally, now that we<a id="_idIndexMarker379"/> have all our data saved, we can Log to ensure the<a id="_idIndexMarker380"/> data is as expected on the UI; check out the link with the code in the <em class="italic">Technical requirements</em> section to see how<a id="_idTextAnchor262"/> this is implemented.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Apple M1 has a reported problem with proto. There is an issue open for this; follow this link to resolve the issue: <a href="https://github.com/grpc/grpc-java/issues/7690">https://github.com/grpc/grpc-java/issues/7690</a>. Hopefully, it will be fixed by the time the book is published. It is important to note that if you use the <code>DataStore-preferences-core</code> artifact with Proguard, you have to manually add Proguard rules to your rule file to prevent your already written fields from being deleted. Also, you can follow the same process to Log and check wheth<a id="_idTextAnchor263"/>er the data is inserted as expected.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor264"/>How it works…</h2>
<p>You might have <a id="_idIndexMarker381"/>noticed that we stored our custom data type as an instance. That is what Proto DataStore does; it stores data as instances of custom data types. The implementations require us to define a schema using protocol buffers, but it provides type safety.</p>
<p>In Android's Proto Datastore library, the <code>Serializer&lt;Type&gt;</code> interface converts objects of a specific type (<code>Type</code>) into their corresponding protocol buffer format and vice versa. This interface provides methods for serializing objects to bytes and deserializing bytes back into objects.</p>
<p>Protocol buffers in Android is a language and platform-neutral extensible mechanism for serializing your structured data. Protocol buffers encodes and decodes your data in a binary stream that is really lightweight.</p>
<p>The override val defaultValue is used when defining a property in a data class or a serialized model class. It is part of the Kotlin Serialization library, which is commonly used for serializing and deserializing objects to and from different data formats such as JSON or protocol buffers.</p>
<p>We expose the appropriate property by exposing the flow DataStore data from our stored object and writing a proto DataStore that provides us with an <code>updateData()</code> function that<a id="_idIndexMarker382"/> tra<a id="_idTextAnchor265"/>nsactionally updates a stored object.</p>
<p>The <code>updateData</code> function gives us the current state of the data as an instance of our data type and updates it in an atomic read-write-modify operation.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor266"/>See also</h2>
<p>There is more to learn about how to create defined schemas. You can check out the protobuf language guide here: <a href="https://protobuf.dev/programming-guides/proto3/">https://developers.google.com/protocol-buffers/docs/proto3</a>.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor268"/>Handling data migration with DataStore</h1>
<p>If you have <a id="_idIndexMarker383"/>built Android applications before, you <a id="_idIndexMarker384"/>might have used <code>SharedPreferences</code>; the good news now is that there is support for migration, and you can migrate from <code>SharedPreferences</code> to DataStore using <code>SharedPreferenceMigration</code>. As with any data, we will always modify our dataset; for instance, we might want to rename our data model values or even change their type.</p>
<p>In such a scenario, we will need a DataStore to DataStore migration; that is what we will be working on in this recipe. The process is pretty similar to the migration from <code>SharedPreferences</code>; as a matter of fact, <code>SharedPreferencesMigration</code> is an implementati<a id="_idTextAnchor269"/>on of the <code>DataMigration</code> interface class.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor270"/>Getting ready</h2>
<p>Since we just created a new <code>PreferenceDataStore</code>, we will not need to migrate it, but we can look at ways to impl<a id="_idTextAnchor271"/>ement a migration in case a need arises.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor272"/>How to do it…</h2>
<p>In this recipe, we will look at how you can utilize the knowledge learned to help you when a need to migrate to DataStore arises:</p>
<ol>
<li>Let’s start by looking at the interface that helps with migration. The following code section showcases the <code>DataMigration</code> interface, which <code>SharedPreferencesMigration</code> implements:<pre class="source-code">
/* Copyright 2022 Google LLC.</pre><pre class="source-code">
   SPDX-License-Identifier: Apache-2.0 */</pre><pre class="source-code">
public interface DataMigration&lt;T&gt; {</pre><pre class="source-code">
    public suspend fun shouldMigrate(currentData: T): Boolean</pre><pre class="source-code">
    public suspend fun migrate(currentData: T): T</pre><pre class="source-code">
        public suspend fun cleanUp()</pre><pre class="source-code">
}</pre></li>
<li>In the <code>Tasks</code> data, we <a id="_idIndexMarker385"/>might want to change the entries to <code>Int</code>; this means changing <a id="_idIndexMarker386"/>one of our data types. We will imagine this scenario and try to create a migration based on this. We can start by creating a new <code>migrateOnePreferencesDataStore</code>:<pre class="source-code">
private val Context.migrateOnePreferencesDataStore : DataStore&lt;Preferences&gt; by preferencesDataStore(</pre><pre class="source-code">
    name = "store_tasks"</pre><pre class="source-code">
)</pre></li>
<li>Now, let’s go on to implement <code>DataMigration</code> and override its functions. You will need to specify your condition for whether the migration should happen. The migration data shows instructions on how exactly the old data is transformed into new data. Then, once the migration is over, clean up the old storage:<pre class="source-code">
private val Context.migrationTwoPreferencesDataStore by preferencesDataStore(</pre><pre class="source-code">
    name = NEW_DataStore,</pre><pre class="source-code">
    produceMigrations = { context -&gt;</pre><pre class="source-code">
        listOf(object : DataMigration&lt;Preferences&gt; {</pre><pre class="source-code">
            override suspend fun</pre><pre class="source-code">
                shouldMigrate(currentData:</pre><pre class="source-code">
                    Preferences) = true</pre><pre class="source-code">
            override suspend fun migrate(currentData:</pre><pre class="source-code">
            Preferences): Preferences {</pre><pre class="source-code">
                val oldData = context</pre><pre class="source-code">
                    .migrateOnePreferencesDataStore</pre><pre class="source-code">
                        .data.first().asMap()</pre><pre class="source-code">
                val currentMutablePrefs =</pre><pre class="source-code">
                    currentData.toMutablePreferences()</pre><pre class="source-code">
                oldToNew(oldData, currentMutablePrefs)</pre><pre class="source-code">
                return</pre><pre class="source-code">
                   currentMutablePrefs.toPreferences()</pre><pre class="source-code">
            }</pre><pre class="source-code">
            override suspend fun cleanUp() {</pre><pre class="source-code">
                context.migrateOnePreferencesDataStore</pre><pre class="source-code">
                    .edit { it.clear() }</pre><pre class="source-code">
            }</pre><pre class="source-code">
        })</pre><pre class="source-code">
    }</pre><pre class="source-code">
)</pre></li>
<li>Finally, let’s <a id="_idIndexMarker387"/>create the <code>oldToNew()</code> function, which is where we can add the data we <a id="_idIndexMarker388"/>want to migrate:<pre class="source-code">
private fun oldToNew(</pre><pre class="source-code">
    oldData: Map&lt;Preferences.Key&lt;*&gt;, Any&gt;,</pre><pre class="source-code">
    currentMutablePrefs: MutablePreferences</pre><pre class="source-code">
) {</pre><pre class="source-code">
    oldData.forEach { (key, value) -&gt;</pre><pre class="source-code">
        when (value) {</pre><pre class="source-code">
            //migrate data types you wish <a id="_idTextAnchor273"/>to migrate</pre><pre class="source-code">
            ...</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
</ol>
<h2 id="_idParaDest-154"><a id="_idTextAnchor274"/>How it works…</h2>
<p>To better understand how <code>DataMigration</code> works, we will need to look into the functions that are in the <code>DataMigration</code> interface. In our interface, we have three functions, as shown in the following code block:</p>
<pre class="source-code">
    public suspend fun shouldMigrate(currentData: T):
        Boolean
    public suspend fun migrate(currentData: T): T
    public suspend fun cleanUp()</pre>
<p>The <code>shouldMigrate()</code> function, as the name suggests, establishes whether the migration needs to be performed or not. If, for instance, no migration is done, which means this will return <code>false</code>, then no migration or cleanup will occur. Also, it is crucial to note that this function is initialized every time we call our DataStore instance. <code>Migrate()</code>, on the other hand, performs the migration.</p>
<p>By chance, if<a id="_idIndexMarker389"/> the action fails or does not work as <a id="_idIndexMarker390"/>expected, DataStore will not commit any data to the disk. Furthermore, the cleanup process will not occur, and an exception will be thrown. Finally, <code>cleanUp()</code>, as it suggests, just cl<a id="_idTextAnchor275"/>ears any old data from previous data storage.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor276"/>Writing tests for our DataStore instance</h1>
<p>Writing tests <a id="_idIndexMarker391"/>is crucial in Android development, and in this recipe, we will write some tests for our DataStore instance. To test our<a id="_idIndexMarker392"/> DataStore instance or any DataStore instance, we first need to have instrumentation testing set up since we will be reading and writing in actual files (DataStore), and it is vital<a id="_idTextAnchor277"/> to verify that accurate updates are being made.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor278"/>How to do it…</h2>
<p>We will start by creating a simple unit test to test our view model function:</p>
<ol>
<li>In our unit test folder, create a new folder and call it <code>test</code>, and inside it, go ahead and create a new class called <code>TaskViewModelTest</code>:<pre class="source-code">
  class TaskViewModelTest {}</pre></li>
<li>Next, we will need to add some testing dependencies:<pre class="source-code">
testImplementation "io.mockk:mockk:1.13.3"</pre><pre class="source-code">
androidTestImplementation "io.mockk:mockk-android:1.13.3"</pre><pre class="source-code">
testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.5.2"</pre></li>
<li>Now that we have added the required dependencies, let’s go ahead and create our mock <a id="_idIndexMarker393"/>task service class and mock it, then<a id="_idIndexMarker394"/> initialize it in the setup:<pre class="source-code">
private lateinit var classToTest: TaskViewModel</pre><pre class="source-code">
private val mockTaskService = mockk&lt;TaskService&gt;()</pre><pre class="source-code">
private val dispatcher = TestCoroutineDispatcher()</pre><pre class="source-code">
@Before</pre><pre class="source-code">
fun setUp(){</pre><pre class="source-code">
    classToTest = TaskViewModel(mockTaskService)</pre><pre class="source-code">
}</pre></li>
<li>Since we use a coroutine, we will set up our dispatcher in @<code>Before annotation</code> and clear any stored data in the <code>@After</code> annotation using the <code>Dispatchers.resetMain()</code>. If you run your tests without setting up a coroutine, they will fail with an error. The module with the <code>Main</code> dispatcher failed to initialize. For tests, <code>Dispatchers.setMain</code> from the <code>kotlinx-coroutines-test</code> module can be used:<pre class="source-code">
@Before</pre><pre class="source-code">
fun setUp(){</pre><pre class="source-code">
    classToTest = TaskViewModel(mockTaskService)</pre><pre class="source-code">
    Dispatchers.setMain(dispatcher)</pre><pre class="source-code">
}</pre><pre class="source-code">
@After</pre><pre class="source-code">
fun tearDown() {</pre><pre class="source-code">
    Dispatchers.resetMain()</pre><pre class="source-code">
}</pre></li>
<li>After that is<a id="_idIndexMarker395"/> completed, let’s go on and create a new test called <code>Verify add tasks function adds tasks as needed</code>. In this test, we will create a <code>fakeTask</code>, add those tasks to <code>saveTaskData</code>, and ensure data is inserted as expected by <a id="_idIndexMarker396"/>checking that we did not store <code>null</code>:<pre class="source-code">
@Test</pre><pre class="source-code">
fun  `Verify add tasks function adds tasks as needed`() = runBlocking {</pre><pre class="source-code">
    val fakeTasks = Tasks(</pre><pre class="source-code">
        firstTask = "finish school work",</pre><pre class="source-code">
        secondTask = "buy gifts for the holiday",</pre><pre class="source-code">
        thirdTask = "finish work"</pre><pre class="source-code">
    )</pre><pre class="source-code">
    val expected = classToTest.saveTaskData(fakeTasks)</pre><pre class="source-code">
    Assert.assertNotNull(expected)</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Finally, when you run the unit test, it should pass, and you will see a green check mark<a id="_idTextAnchor279"/>.</p>
<div><div><img alt="Figure 5.7 – The test passing in the view model" src="img/Figure_5.7_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The test passing in the view model</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor280"/>How it works…</h2>
<p>There are<a id="_idIndexMarker397"/> different mocking libraries used in Android: <code>Mockito</code>, <code>Mockk</code>, and more. In this recipe, we used <code>Mockk</code>, a user-friendly mocking library for Android. <code>testImplementation "io.mockk:mockk:1.13.3"</code> is used for unit tests, and <code>androidTestImplementation "io.mockk:mockk-android:1.13.3"</code> is used for UI tests.</p>
<p>To test the UI, we will need to follow a pattern, creating a test DataStore instance with default values stored inside it. Then, we create the test subject and verify that the test DataStore values coming from our function match the expected results. We will also need to use <code>TestCoroutineDispatcher</code>:</p>
<pre class="source-code">
private val coroutineDispatcher: TestCoroutineDispatcher =
    TestCoroutineDispatcher()</pre>
<p>The preceding<a id="_idIndexMarker398"/> code performs the execution of the coroutines, which is, by default, immediate. This simply means any tasks scheduled to be run without delays are executed immediately. We also use the same coroutines for our view models. That is also because DataStore is based on Kotlin coroutines; hen<a id="_idTextAnchor281"/>ce we need to ensure our tests have the right setup.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor282"/>See also</h2>
<p>There is more to learn about DataStore. We cannot cover it all in just one chapter. For more information on DataStore, that is, Preference and Proto, you can check out this link: <a href="https://developer.android.com/topic/libraries/architecture/datastore">https://developer.android.com/topic/libraries/architecture/datastore</a>.</p>
</div>
</body></html>