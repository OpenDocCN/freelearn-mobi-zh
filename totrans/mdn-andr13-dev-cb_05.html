<html><head></head><body>
<div id="_idContainer068">
<h1 class="chapter-number" id="_idParaDest-135"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-136"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.2.1">Using DataStore to Store Data and Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Modern Android Development practices help Android developers create better applications. </span><span class="koboSpan" id="kobo.3.2">DataStore is a data storage solution provided by the Android Jetpack library. </span><span class="koboSpan" id="kobo.3.3">It allows developers to store key-value pairs or complex objects asynchronously and with consistency guarantees. </span><span class="koboSpan" id="kobo.3.4">Data is critical in Android development, and how we save and persist data matters. </span><span class="koboSpan" id="kobo.3.5">In this chapter, we will explore using DataStore to persist our data and look at best practices </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">using DataStore.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following recipes:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Implementing DataStore</span></span></li>
<li><span class="koboSpan" id="kobo.8.1">Adding Dependency Injection </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">to DataStore</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Using Android Proto DataStore </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">versus DataStore</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Handling data migration </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">with DataStore</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Writing tests for our </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">DataStore instance</span></span></li>
</ul>
<h1 id="_idParaDest-137"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">The complete source code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_five</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.20.1">.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.21.1">Implementing DataStore</span></h1>
<p><span class="koboSpan" id="kobo.22.1">When building </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.23.1">mobile applications, it is critical to ensure that you persist your data in order to allow for smooth loading, reduce network issues, or even handle data entirely offline. </span><span class="koboSpan" id="kobo.23.2">In this recipe, we will look at how to store data in our Android applications using the Modern Android Development Jetpack library </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">called DataStore.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">DataStore is</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.26.1"> a data storage solution for Android applications that enables you to store key-value pairs or any typed objects with protocol buffers. </span><span class="koboSpan" id="kobo.26.2">Moreover, DataStore uses Kotlin coroutines and flows to store data consistently, transactionally, </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">and asynchronously.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">If you have built Android applications before, you might have used </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">The new Preferences DataStore aims to replace this old method. </span><span class="koboSpan" id="kobo.30.3">It is also fair to say that Preferences DataStore harnesses the power of </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.32.1"> since they are pretty similar. </span><span class="koboSpan" id="kobo.32.2">In addition, Google’s documentation recommends that if you’re currently using </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.34.1"> in your project to store data, you consider migrating to the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">DataStore version.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Another way to store data in Android is by using Room. </span><span class="koboSpan" id="kobo.36.2">This will be covered in </span><a href="B18827_06.xhtml#_idTextAnchor283"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.38.1">, </span><em class="italic"><span class="koboSpan" id="kobo.39.1">Using the Room Database and Testing</span></em><span class="koboSpan" id="kobo.40.1">; for now, we will just look at DataStore. </span><span class="koboSpan" id="kobo.40.2">Moreover, it is essential to note that DataStore is ideal for simple or small datasets and does not have support for partial updates or </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">referential integrity</span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.42.1">.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.43.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.44.1">Let’s go ahead and create a new, empty Compose project and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">DataStoreSample</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">In our example project, we will create a task entry app where users can save tasks. </span><span class="koboSpan" id="kobo.46.3">We will allow users to enter only three tasks, then use DataStore to store the tasks and later log the data and see whether it was inserted correctly. </span><span class="koboSpan" id="kobo.46.4">An additional exercise to try is to display data when users want to </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">see it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.48.1">In our newly created project, let’s go ahead and delete code that we don’t need. </span><span class="koboSpan" id="kobo.48.2">In this case, we’re referring to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">Greeting(name: String)</span></strong><span class="koboSpan" id="kobo.50.1"> that comes with all empty Compose projects. </span><span class="koboSpan" id="kobo.50.2">Keep the Preview function since we will use it to view the screen </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">we create.</span></span></li>
<li><span class="koboSpan" id="kobo.52.1">Now, let’s go on and add the required dependencies for DataStore and sync the project. </span><span class="koboSpan" id="kobo.52.2">Also, note that there are versions of the DataStore library that are specific to RxJava 2 </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">and 3:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.54.1">
dependencies {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.55.1">
implementation "androidx.DataStore:DataStore-preferences:1.x.x"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.56.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.57.1">Create a new package and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">data</span></strong><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">data</span></strong><span class="koboSpan" id="kobo.61.1">, create a new Kotlin data class and call </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">Tasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">Let’s</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.66.1"> now go ahead and construct our data class with the expected </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">input fields:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.68.1">
data class Tasks(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.69.1">
    val firstTask: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.70.1">
    val secondTask: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.71.1">
    val thirdTask: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.72.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.73.1">Inside the same package, let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">TaskDataSource</span></strong><span class="koboSpan" id="kobo.75.1"> enum since we will reuse this project to showcase saving data using Proto DataStore in the </span><em class="italic"><span class="koboSpan" id="kobo.76.1">Using Android Proto DataStore versus </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.77.1">DataStore</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.78.1"> recipe:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.79.1">
enum class TaskDataSource {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.80.1">
    PREFERENCES_DATA_STORE</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.81.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.82.1">Inside our package, let’s go ahead and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">DataStoreManager</span></strong><span class="koboSpan" id="kobo.84.1"> interface. </span><span class="koboSpan" id="kobo.84.2">Inside our class, we will have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">saveTasks()</span></strong><span class="koboSpan" id="kobo.86.1"> function to save the data and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">getTasks()</span></strong><span class="koboSpan" id="kobo.88.1"> function to help us retrieve the saved data. </span><span class="koboSpan" id="kobo.88.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">suspend</span></strong><span class="koboSpan" id="kobo.90.1"> function in Kotlin is simply a function that can be paused and </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">resumed later.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.92.1">In addition, the suspend functions can execute long-running operations and await completion </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">without blocking:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
interface DataStoreManager {
    suspend fun saveTasks(tasks: Tasks)
    fun getTasks(): Flow&lt;Tasks&gt;
}</span></pre>
<ol>
<li value="7"><span class="koboSpan" id="kobo.95.1">Next, we need to implement our interface, so let’s go ahead and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">DataStoreManagerImpl</span></strong><span class="koboSpan" id="kobo.97.1"> class and implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">DataStoreManager</span></strong><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">To </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.100.1">refresh your knowledge of Flows, refer to </span><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.101.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.102.1">, </span><em class="italic"><span class="koboSpan" id="kobo.103.1">Handling the UI State in Jetpack Compose and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.104.1">Using Hilt</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.106.1">
class DataStoreManagerImpl(): DataStoreManager {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.107.1">
    override suspend fun saveTasks(tasks: Tasks) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.108.1">
        TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.109.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.110.1">
    override fun getTasks(): Flow&lt;Tasks&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.111.1">
        TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.112.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.113.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.114.1">You will notice that once we’ve implemented the interface, we brought a view to the function, but it says </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">TODO</span></strong><span class="koboSpan" id="kobo.116.1">, and nothing has been implemented. </span><span class="koboSpan" id="kobo.116.2">To continue with this step, let’s go ahead and add DataStore and pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">Preference</span></strong><span class="koboSpan" id="kobo.118.1"> in our constructor. </span><span class="koboSpan" id="kobo.118.2">We will also need to create the string preference key for </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">each task:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.120.1">
class DataStoreManagerImpl(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.121.1">
    private val tasksPreferenceStore:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.122.1">
        DataStore&lt;Preferences&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.123.1">
) : DataStoreManager {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.124.1">
    private val FIRST_TASK =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.125.1">
        stringPreferencesKey("first_task")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.126.1">
    private val SECOND_TASK =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.127.1">
        stringPreferencesKey("second_task")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.128.1">
    private val THIRD_TASK =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.129.1">
        stringPreferencesKey("third_task")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.130.1">
    override suspend fun saveTasks(tasks: Tasks) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.131.1">
        tasksPreferenceStore.edit {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.132.1">
        taskPreferenceStore -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.133.1">
            taskPreferenceStore[FIRST_TASK] =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.134.1">
                tasks.firstTask</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.135.1">
            taskPreferenceStore[SECOND_TASK] =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.136.1">
                tasks.secondTask</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.137.1">
            taskPreferenceStore[THIRD_TASK] =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.138.1">
                tasks.thirdTask</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.139.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.140.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.141.1">
    override fun getTasks(): Flow&lt;Tasks&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.142.1">
        TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.143.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.144.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.145.1">Finally, let’s finish our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">DataStore</span></strong><span class="koboSpan" id="kobo.147.1"> section by adding functionality to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">getTasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.149.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.150.1">
override fun getTasks(): Flow&lt;Tasks&gt; = tasksPreferenceStore.data.map { taskPreference -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.151.1">
    Tasks(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.152.1">
        firstTask = taskPreference[FIRST_TASK] ?: "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.153.1">
        secondTask = taskPreference[SECOND_TASK] ?:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
        "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.155.1">
        thirdTask = taskPreference[THIRD_TASK] ?: ""</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.157.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.158.1">In </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.159.1">our </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">MainActivity</span></strong><span class="koboSpan" id="kobo.161.1"> class, let’s go on and create a simple UI: three </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">TextField</span></strong><span class="koboSpan" id="kobo.163.1"> and a </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">Save</span></strong><span class="koboSpan" id="kobo.165.1"> button. </span><span class="koboSpan" id="kobo.165.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Save</span></strong><span class="koboSpan" id="kobo.167.1"> button will save our data, and we can try to log data once everything works as expected. </span><span class="koboSpan" id="kobo.167.2">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Technical requirements</span></em><span class="koboSpan" id="kobo.169.1"> section of this chapter to get the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">UI code.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 5.1 – The DataStore UI exam﻿ple" src="image/Figure_5.1_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 5.1 – The DataStore UI exam</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.173.1">ple</span></p>
<p><span class="koboSpan" id="kobo.174.1">Now that we </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.175.1">have our implementation ready, in the following recipe, </span><em class="italic"><span class="koboSpan" id="kobo.176.1">Adding Dependency Injection to DataStore</span></em><span class="koboSpan" id="kobo.177.1">, we will add Dependency Injection and then glue </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">everything together.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.179.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.180.1">The new</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.181.1"> Modern Android Development Jetpack library called Preferences DataStore’s main objective is to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">To implement Preferences DataStore, as you have seen in the recipe, we use a DataStore interface that takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Preference</span></strong><span class="koboSpan" id="kobo.185.1"> abstract class, and we can use this to edit and map the entry data. </span><span class="koboSpan" id="kobo.185.2">Furthermore, we create keys for the crucial parts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">key-value pairs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
private val FIRST_TASK = stringPreferencesKey("first_task")
private val SECOND_TASK = stringPreferencesKey("second_task")
private val THIRD_TASK = stringPreferencesKey("third_task")</span></pre>
<p><span class="koboSpan" id="kobo.188.1">To save</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.189.1"> our data in DataStore, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">edit()</span></strong><span class="koboSpan" id="kobo.191.1">, which is a suspend function that needs to be called from </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">CoroutineContext</span></strong><span class="koboSpan" id="kobo.193.1">. </span><span class="koboSpan" id="kobo.193.2">A key difference in using Preferences DataStore compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.195.1"> is that DataStore is safe to call on the UI thread since it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">dispatcher.IO</span></strong><span class="koboSpan" id="kobo.197.1"> under </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the hood.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">You also do not need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">apply{} </span></strong><span class="koboSpan" id="kobo.201.1">or </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">commit</span></strong><span class="koboSpan" id="kobo.203.1"> functions to save the changes, as is required in </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.205.1">. </span><span class="koboSpan" id="kobo.205.2">Moreover, it handles data updates transactionally. </span><span class="koboSpan" id="kobo.205.3">More features are listed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.206.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.207.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.209.1"><img alt="Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com" src="image/Figure_5.2_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.210.1">Figure 5.2 – A list of a sample of Datastore’s features taken from developers.android.com</span></p>
<p><span class="koboSpan" id="kobo.211.1">There is more to learn, and it is fair to acknowledge that what we covered in this recipe is just a tiny part of what you can do with DataStore. </span><span class="koboSpan" id="kobo.211.2">We will cover more features in the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">following rec</span><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.213.1">ipes.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.214.1">Adding Dependency Injection to DataStore</span></h1>
<p><span class="koboSpan" id="kobo.215.1">Dependency Injection</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.216.1"> is an important design pattern in software engineering, and its use in Android app development can lead to cleaner and more maintainable code. </span><span class="koboSpan" id="kobo.216.2">When it comes to DataStore in Android, which is a modern data storage solution introduced in Android Jetpack, adding </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.217.1">Dependency Injection </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.218.1">can bring </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">several benefits:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.220.1">By using Dependency Injection, you can separate the concerns of creating an instance of DataStore from the code that uses it. </span><span class="koboSpan" id="kobo.220.2">This means that your business logic code will not have to worry about how to create a DataStore instance and can instead focus on what it needs to do with </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the data.</span></span></li>
<li><span class="koboSpan" id="kobo.222.1">Dependency Injection makes it easier to write unit tests for your app. </span><span class="koboSpan" id="kobo.222.2">By injecting a mock DataStore instance into your tests, you can ensure that your tests are not affected by the actual state of </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">the DataStore.</span></span></li>
<li><span class="koboSpan" id="kobo.224.1">Dependency Injection can help you break down your code into smaller, more manageable modules. </span><span class="koboSpan" id="kobo.224.2">This makes it easier to add new features or modify existing ones without affecting the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">code base.</span></span></li>
<li><span class="koboSpan" id="kobo.226.1">By using Dependency Injection, you can easily switch between different implementations of DataStore. </span><span class="koboSpan" id="kobo.226.2">This can be useful when testing different types of data storage or when migrating from one storage solution </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">to </span><a id="_idTextAnchor248"/><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.228.1">another.</span></span></li>
</ul>
<h2 id="_idParaDest-142"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.229.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.230.1">You need to have completed the previous recipe to continue with this one by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.232.1">Open your project and add the necessary Hilt dependency. </span><span class="koboSpan" id="kobo.232.2">See the </span><em class="italic"><span class="koboSpan" id="kobo.233.1">Handling the UI State in Jetpack Compose and Using Hilt</span></em><span class="koboSpan" id="kobo.234.1"> recipe in </span><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.235.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.236.1"> if you need help setting </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">it up.</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">Next, let’s go ahead and add our </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">@HiltAndroidApp</span></strong><span class="koboSpan" id="kobo.240.1"> class, and in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Manifest</span></strong><span class="koboSpan" id="kobo.242.1"> folder, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">.name = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">TaskApp: android:name=".TaskApp"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.246.1">
@HiltAndroidApp</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
class TaskApp : Application()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.248.1">
&lt;application</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.249.1">
    android:allowBackup="true"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.250.1">
    android:name=".TaskApp"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
    tools:targetApi="31"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.252.1">
...</span></pre></li>
<li><span class="koboSpan" id="kobo.253.1">Now </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.254.1">that we have implemented Dependency </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.255.1">Injection, let’s go ahead and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">@AndroidEntryPoint</span></strong><span class="koboSpan" id="kobo.257.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">MainActivity</span></strong><span class="koboSpan" id="kobo.259.1"> class, and in </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">DataStoreManagerImpl</span></strong><span class="koboSpan" id="kobo.261.1">, let’s go ahead and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">@Inject constructor</span></strong><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">We should have something similar to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.265.1">
class DataStoreManagerImpl @Inject constructor(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.266.1">
    private val tasksPreferenceStore:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.267.1">
    DataStore&lt;Preferences&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.268.1">
) : DataStoreManager {</span></pre></li>
<li><span class="koboSpan" id="kobo.269.1">Now, we need to create a new folder and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">di</span></strong><span class="koboSpan" id="kobo.271.1">; this is where we will put our </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">DataStoreModule</span></strong><span class="koboSpan" id="kobo.273.1"> class. </span><span class="koboSpan" id="kobo.273.2">We create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">store_tasks</span></strong><span class="koboSpan" id="kobo.275.1"> to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">Preference values:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.277.1">
@Module</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.278.1">
@InstallIn(SingletonComponent::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.279.1">
class DataStoreModule {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.280.1">
    private val Context.tasksPreferenceStore :</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.281.1">
    DataStore&lt;Preferences&gt; by</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
    preferencesDataStore(name = "store_tasks")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.283.1">
    @Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.284.1">
    @Provides</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.285.1">
    fun provideTasksPreferenceDataStore(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.286.1">
        @ApplicationContext context: Context</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.287.1">
    ): DataStore&lt;Preferences&gt; =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.288.1">
       context.tasksPreferenceStore</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.289.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.290.1">We </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.291.1">will also need to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">abstract</span></strong><span class="koboSpan" id="kobo.293.1"> class for </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">DataStoreManagerModule</span></strong><span class="koboSpan" id="kobo.295.1"> inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">di</span></strong><span class="koboSpan" id="kobo.297.1"> package. </span><span class="koboSpan" id="kobo.297.2">In order to reduce the</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.298.1"> boilerplate code using manual Dependency Injection, our application also supplies the required dependencies to the classes that need them. </span><span class="koboSpan" id="kobo.298.2">You can learn more about this in </span><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.299.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.300.1">, </span><em class="italic"><span class="koboSpan" id="kobo.301.1">Handling the UI State in Jetpack Compose and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.302.1">Using Hilt</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.304.1">
@Module</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.305.1">
@InstallIn(SingletonComponent::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.306.1">
abstract class DataStoreManagerModule {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.307.1">
    @Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.308.1">
    @Binds</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.309.1">
    abstract fun</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.310.1">
        bindDataStoreRepository(DataStoreManagerImpl:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
            DataStoreManagerImpl): DataStoreManager</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.312.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.313.1">Let’s now </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.314.1">go ahead and create a new package and call </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.318.1">
interface TaskService {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.319.1">
    fun getTasksFromPrefDataStore(): Flow&lt;Tasks&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.320.1">
    suspend fun addTasks(tasks: Tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.321.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.322.1">
class TaskServiceImpl @Inject constructor(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
    private val DataStoreManager: DataStoreManager</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.324.1">
) : TaskService {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.325.1">
    override fun getTasksFromPrefDataStore() =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.326.1">
             DataStoreManager.getTasks()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.327.1">
    override suspend fun addTasks(tasks: Tasks) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.328.1">
        DataStoreManager.saveTasks(tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.329.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.330.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.331.1">Let’s also</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.332.1"> ensure we have the required dependencies  for the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">created service:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.334.1">
    @Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.335.1">
    @Binds</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.336.1">
    abstract fun bindTaskService(taskServiceImpl:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.337.1">
    TaskServiceImpl): TaskService</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.338.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.339.1">Now that we are done with Dependency Injection and adding all the functionalities required for DataStore, we will go ahead and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">ViewModel</span></strong><span class="koboSpan" id="kobo.341.1"> class and</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.342.1"> implement functionality </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.343.1">to save the data once the user clicks the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">Save button:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.345.1">
fun saveTaskData(tasks: Tasks) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.346.1">
    viewModelScope.launch {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.347.1">
        Log.d("Task", "asdf Data was inserted</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.348.1">
               correctly")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.349.1">
        taskService.addTasks(tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.350.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.351.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.352.1">Call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">saveTaskData</span></strong><span class="koboSpan" id="kobo.354.1"> function inside the Compose Save button in the Compose view to save </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">our data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
TaskButton(onClick = {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.357.1">
    val tasks = Tasks(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.358.1">
        firstTask = firstText.value,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.359.1">
        secondTask = secondText.value,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
        thirdTask = thirdText.value</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.361.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.362.1">
    taskViewModel.saveTaskData(tasks)},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
    text = stringResource(id = R.string.save))</span></pre></li>
<li><span class="koboSpan" id="kobo.364.1">Lastly, we will need to verify that everything is working, that is, our UI and data storing process. </span><span class="koboSpan" id="kobo.364.2">We can verify this, by typing input data in our TextFields and clicking the Save button, and when we log the message it confirms the data is </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">indeed saved.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.366.1"><img alt="Figure 5.3 – The entry of tasks" src="image/Figure_5.3_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.367.1">Figure 5.3 – The entry of tasks</span></p>
<ol>
<li value="11"><span class="koboSpan" id="kobo.368.1">If you </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.369.1">missed it initially, the code for this</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.370.1"> view can be found in the </span><em class="italic"><span class="koboSpan" id="kobo.371.1">Technical requirement</span></em><span class="koboSpan" id="kobo.372.1"> section. </span><span class="koboSpan" id="kobo.372.2">Now, you will notice that when we enter the data, as in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.373.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.374.1">.4</span></em><span class="koboSpan" id="kobo.375.1">, we should be able to log the data on our Logcat and verify that our data was </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">inserted correctly.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.377.1"><img alt="Figure 5.4 – The entry of tasks through debugging" src="image/Figure_5.4_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.378.1">Figure 5.4 – The entry of tasks through debugging</span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.379.1">A log </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.380.1">message should also be displayed </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.381.1">in the Logcat tab if all is working </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">as expected.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.383.1"><img alt="Figure 5.5 – The debug log indicating that data was i﻿nserted correctly" src="image/Figure_5.5_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.384.1">Figure 5.5 – The debug log indicating that data was i</span><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.385.1">nserted correctly</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.386.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.387.1">In this recipe, we opted to use Dependency Injection to supply the required dependencies to specific classes. </span><span class="koboSpan" id="kobo.387.2">We’ve already covered what Dependency Injection is in depth, so we will not explain it again but instead talk about the modules </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">we created.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">In our project, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">DataStoreManagerModule</span></strong><span class="koboSpan" id="kobo.391.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">DataStoreModule</span></strong><span class="koboSpan" id="kobo.393.1">, and all we did was supply the required dependencies. </span><span class="koboSpan" id="kobo.393.2">We created a file and called it </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">store_tasks</span></strong><span class="koboSpan" id="kobo.395.1">, which helps us store the </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">Preference values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
private val Context.tasksPreferenceStore : DataStore&lt;Preferences&gt; by preferencesDataStore(name = "store_tasks")</span></pre>
<p><span class="koboSpan" id="kobo.398.1">By default, DataStore uses</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.399.1"> coroutines and returns a</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.400.1"> flow value. </span><span class="koboSpan" id="kobo.400.2">Some important rules to remember while using DataStore, as per the documentation, are </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.402.1">DataStore requires only one instance for a given file in the same process. </span><span class="koboSpan" id="kobo.402.2">Hence, we should never create more than one instance </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">of DataStore.</span></span></li>
<li><span class="koboSpan" id="kobo.404.1">Always have the generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">DataStore</span></strong><span class="koboSpan" id="kobo.406.1"> type be immutable to reduce unnecessary and </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">hard-to-trace bugs.</span></span></li>
<li><span class="koboSpan" id="kobo.408.1">You should never mix the usage of a single-process DataStore and multi-process DataStore in the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">same file.</span></span></li>
</ul>
<h2 id="_idParaDest-144"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.410.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.411.1">As an exercise, you can try to add another button and display the saved data in a lazy colu</span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.412.1">mn or a </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">t</span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.414.1">ext field.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.415.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.416.1">There is more to learn about DataStore, and this recipe has only given you an overview of what you can do with DataStore. </span><span class="koboSpan" id="kobo.416.2">You can learn more by following the link </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">at </span></span><a href="https://developer.android.com/topic/libraries/architecture/datastore"><span class="No-Break"><span class="koboSpan" id="kobo.418.1">https://developer.android.com/topic/libraries/architecture/datastore</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.419.1">.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.420.1">Using Android Proto DataStore versus DataStore</span></h1>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.421.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.422.1">.2</span></em><span class="koboSpan" id="kobo.423.1"> shows the</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.424.1"> differences between </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">PreferencesDataStore</span></strong><span class="koboSpan" id="kobo.426.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.428.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">ProtoDataStore</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">In this recipe, we will explore how we can use Proto DataStore. </span><span class="koboSpan" id="kobo.430.3">The Proto DataStore implementation uses DataStore and Protocol Buffers to persist typed objects to </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the disk.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">Proto DataStore is</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.433.1"> similar to Preferences DataStore, but unlike Preferences DataStore, Proto does not use key-value pairs and just returns the generated object in the flow. </span><span class="koboSpan" id="kobo.433.2">The file types and structure of the data depend on the schema o</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.434.1">f the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">protoc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> files.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.438.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.439.1">We will use our already created project to show how you can use Proto DataStore in Android. </span><span class="koboSpan" id="kobo.439.2">We will also use already created classes and just give the funct</span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.440.1">ions </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">different names.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.442.1">How to do it…</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.443.1">We </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.444.1">will need to start by setting up the required</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.445.1"> dependencies, so let’s go ahead and add the following to our Gradle </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">app-level file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.447.1">
implementation "androidx.DataStore:DataStore:1.x.x</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.448.1">
implementation "com.google.protobuf:protobuf-javalite:3.x.x"</span></pre></li>
<li><span class="koboSpan" id="kobo.449.1">Next, we will need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">protobuf</span></strong><span class="koboSpan" id="kobo.451.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">plugins</span></strong><span class="koboSpan" id="kobo.453.1"> in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
plugins {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
    id "com.google.protobuf" version "0.8.12"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.459.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.460.1">We will need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">protobuf</span></strong><span class="koboSpan" id="kobo.462.1"> configuration to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">build.gradle</span></strong><span class="koboSpan" id="kobo.464.1"> file to finalize </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">our setup:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.466.1">
protobuf {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.467.1">
    protoc {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.468.1">
        artifact = "com.google.protobuf:protoc:3.11.0"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.469.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
    generateProtoTasks {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
        all().each { task -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
            task.builtins {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
                 java {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
                     option 'lite'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.475.1">
                 }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.477.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.478.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.479.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.480.1">Now, inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">package</span></strong><span class="koboSpan" id="kobo.482.1"> folder, we will need to add our </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">proto</span></strong><span class="koboSpan" id="kobo.484.1"> file under </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">app/src/main/</span></strong><span class="koboSpan" id="kobo.486.1">, then</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.487.1"> create a new directory </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.488.1">and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">proto</span></strong><span class="koboSpan" id="kobo.490.1">. </span><span class="koboSpan" id="kobo.490.2">You should now have this in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">app/src/main/proto</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.492.1">file directory:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.493.1">
syntax = "proto3";</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.494.1">
option java_package =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.495.1">
    "com.madonasyombua.DataStoreexample";</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.496.1">
option java_multiple_files = true;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.497.1">
message TaskPreference {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.498.1">
    string first_task = 1;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.499.1">
    string second_task = 2;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.500.1">
    string third_task = 3;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.501.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.502.1">That was a lot to set up. </span><span class="koboSpan" id="kobo.502.2">We can now start adding code to hook </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">everything up.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.504.1">Let’s modify classes that might need </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">ProtoDataStore</span></strong><span class="koboSpan" id="kobo.506.1">. </span><span class="koboSpan" id="kobo.506.2">First, let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">PROTO_DATA_STORE</span></strong><span class="koboSpan" id="kobo.508.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">TaskDataSource</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.510.1">enum class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.511.1">
enum class TaskDataSource {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.512.1">
    PREFERENCES_DATA_STORE,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.513.1">
    PROTO_DATA_STORE</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.514.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.515.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">DataStoreManager</span></strong><span class="koboSpan" id="kobo.517.1">, let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">saveTaskToProtoStore()</span></strong><span class="koboSpan" id="kobo.519.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">getUserFromProtoStore()</span></strong><span class="koboSpan" id="kobo.521.1">, and our </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.522.1">new interface will look </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.524.1">
interface DataStoreManager {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.525.1">
    suspend fun saveTasks(tasks: Tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.526.1">
    fun getTasks(): Flow&lt;Tasks&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.527.1">
    suspend fun saveTasksToProtoStore(tasks: Tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.528.1">
    fun getTasksFromProtoStore(): Flow&lt;Tasks&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.529.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.530.1">Since we </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.531.1">just modified our interface, we will need to go ahead and add new functionalities to the implementation class. </span><span class="koboSpan" id="kobo.531.2">You will also notice that the project will complain once you add </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">the functions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.533.1">
override suspend fun saveTasksToProtoStore(tasks: Tasks) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.534.1">
    TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.535.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.536.1">
override fun getTasksFromProtoStore(): Flow&lt;Tasks&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.537.1">
    TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.538.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.539.1">As recommended, we will need to define a class that implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Serializer&lt;Type&gt;</span></strong><span class="koboSpan" id="kobo.541.1">, where the type is defined in the Proto file. </span><span class="koboSpan" id="kobo.541.2">The purpose of this serializer class is to </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.542.1">tell DataStore how to read and write our data type. </span><span class="koboSpan" id="kobo.542.2">So, let’s </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.543.1">create a new object and call </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">TaskSerializer()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
object TaskSerializer : Serializer&lt;TaskPreference&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
    override val defaultValue: TaskPreference =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.549.1">
        TaskPreference.getDefaultInstance()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.550.1">
    override suspend fun readFrom(input: InputStream):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.551.1">
        TaskPreference{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.552.1">
            try {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.553.1">
                return TaskPreference.parseFrom(input)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.554.1">
            } catch (exception:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
            InvalidProtocolBufferException) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
              throw CorruptionException("Cannot read</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
              proto.", exception)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.558.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.559.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.560.1">
    override suspend fun writeTo(t: TaskPreference,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
        output: OutputStream) = t.writeTo(output)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.563.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">TaskPreference</span></strong><span class="koboSpan" id="kobo.565.1"> class is auto-generated, and you can access it directly by clicking on it but cannot edit it. </span><span class="koboSpan" id="kobo.565.2">Auto-generated files are not editable unless you change the </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">original file.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.567.1"><img alt="Figure 5.6 – A screenshot showing the auto-generated TaskPreference class" src="image/Figure_5.6_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.568.1">Figure 5.6 – A screenshot showing the auto-generated TaskPreference class</span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.569.1">Now that we</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.570.1"> have created our data type class, we need</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.571.1"> to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">taskProtoDataStore: DataStore&lt;TaskPreference&gt;</span></strong><span class="koboSpan" id="kobo.573.1"> with the context used with DataStore. </span><span class="koboSpan" id="kobo.573.2">Hence, inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">DataStoreModule</span></strong><span class="koboSpan" id="kobo.575.1">, let’s go ahead and add </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">this code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
private val Context.taskProtoDataStore: DataStore&lt;TaskPreference&gt; by DataStore(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.578.1">
    fileName = "task.pd",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.579.1">
    serializer = TaskSerializer</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.580.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
@Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
@Provides</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.583.1">
fun provideTasksProtoDataStore(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.584.1">
    @ApplicationContext context: Context</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.585.1">
):DataStore&lt;TaskPreference&gt; = context.taskProtoDataStore</span></pre></li>
<li><span class="koboSpan" id="kobo.586.1">Now, let’s</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.587.1"> go back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">DataStoreManagerImpl</span></strong><span class="koboSpan" id="kobo.589.1"> and work on the functions that we are </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.590.1">yet </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">to implement:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.592.1">
override suspend fun saveTasksToProtoStore(tasks: Tasks) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.593.1">
    taskProtoDataStore.updateData { taskData -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.594.1">
        taskData.toBuilder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.595.1">
            .setFirstTask(tasks.firstTask)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
            .setSecondTask(tasks.secondTask)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
            .setThirdTask(tasks.thirdTask)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.598.1">
            .build()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
override fun getTasksFromProtoStore(): Flow&lt;Tasks&gt; =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.602.1">
    taskProtoDataStore.data.map { tasks -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.603.1">
        Tasks(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.604.1">
            tasks.firstTask,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.605.1">
            tasks.secondTask,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.606.1">
            tasks.thirdTask</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.607.1">
        )</span></pre></li>
<li><span class="koboSpan" id="kobo.608.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">TaskService</span></strong><span class="koboSpan" id="kobo.610.1">, we will also go ahead and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">getTasksFromProto</span></strong><span class="koboSpan" id="kobo.612.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">getTasks()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.616.1">
interface TaskService {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.617.1">
    fun getTasksFromPrefDataStore() : Flow&lt;Tasks&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.618.1">
    suspend fun addTasks(tasks: Tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.619.1">
    fun getTasks(): Flow&lt;Tasks&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.620.1">
    fun getTasksFromProtoDataStore(): Flow&lt;Tasks&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.621.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.622.1">When you</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.623.1"> implement an interface, at first the class </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.624.1">that is being implemented will might show compile error, which will prompt you to override the interface functionalities into the class. </span><span class="koboSpan" id="kobo.624.2">Hence, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">TaskServiceImpl</span></strong><span class="koboSpan" id="kobo.626.1"> class, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.628.1">
class TaskServiceImpl @Inject constructor(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.629.1">
    private val DataStoreManager: DataStoreManager</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.630.1">
) : TaskService {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.631.1">
    override fun getTasksFromPrefDataStore() =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
        DataStoreManager.getTasks()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.633.1">
    override suspend fun addTasks(tasks: Tasks) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
        DataStoreManager.saveTasks(tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.635.1">
        DataStoreManager.saveTasksToProtoStore(tasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.637.1">
    override fun getTasks(): Flow&lt;Tasks&gt; =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.638.1">
        getTasksFromProtoDataStore()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.639.1">
    override fun getTasksFromProtoDataStore():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.640.1">
        Flow&lt;Tasks&gt; =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.641.1">
        DataStoreManager.getTasksFromProtoStore()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.642.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.643.1">Finally, now that we</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.644.1"> have all our data saved, we can Log to ensure the</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.645.1"> data is as expected on the UI; check out the link with the code in the </span><em class="italic"><span class="koboSpan" id="kobo.646.1">Technical requirements</span></em><span class="koboSpan" id="kobo.647.1"> section to see how</span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.648.1"> this </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">is implemented.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.650.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.651.1">Apple M1 has a reported problem with proto. </span><span class="koboSpan" id="kobo.651.2">There is an issue open for this; follow this link to resolve the issue: </span><a href="https://github.com/grpc/grpc-java/issues/7690"><span class="koboSpan" id="kobo.652.1">https://github.com/grpc/grpc-java/issues/7690</span></a><span class="koboSpan" id="kobo.653.1">. </span><span class="koboSpan" id="kobo.653.2">Hopefully, it will be fixed by the time the book is published. </span><span class="koboSpan" id="kobo.653.3">It is important to note that if you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">DataStore-preferences-core</span></strong><span class="koboSpan" id="kobo.655.1"> artifact with Proguard, you have to manually add Proguard rules to your rule file to prevent your already written fields from being deleted. </span><span class="koboSpan" id="kobo.655.2">Also, you can follow the same process to Log and check wheth</span><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.656.1">er the data is inserted </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">as expected.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.658.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.659.1">You might have </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.660.1">noticed that we stored our custom data type as an instance. </span><span class="koboSpan" id="kobo.660.2">That is what Proto DataStore does; it stores data as instances of custom data types. </span><span class="koboSpan" id="kobo.660.3">The implementations require us to define a schema using protocol buffers, but it provides </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">type safety.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">In Android's Proto Datastore library, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">Serializer&lt;Type&gt;</span></strong><span class="koboSpan" id="kobo.664.1"> interface converts objects of a specific type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">Type</span></strong><span class="koboSpan" id="kobo.666.1">) into their corresponding protocol buffer format and vice versa. </span><span class="koboSpan" id="kobo.666.2">This interface provides methods for serializing objects to bytes and deserializing bytes back </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">into objects.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">Protocol buffers in Android is a language and platform-neutral extensible mechanism for serializing your structured data. </span><span class="koboSpan" id="kobo.668.2">Protocol buffers encodes and decodes your data in a binary stream that is </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">really lightweight.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">The override val defaultValue is used when defining a property in a data class or a serialized model class. </span><span class="koboSpan" id="kobo.670.2">It is part of the Kotlin Serialization library, which is commonly used for serializing and deserializing objects to and from different data formats such as JSON or </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">protocol buffers.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">We expose the appropriate property by exposing the flow DataStore data from our stored object and writing a proto DataStore that provides us with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">updateData()</span></strong><span class="koboSpan" id="kobo.674.1"> function that</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.675.1"> tra</span><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.676.1">nsactionally updates a </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">stored object.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">updateData</span></strong><span class="koboSpan" id="kobo.680.1"> function gives us the current state of the data as an instance of our data type and updates it in an atomic </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">read-write-modify operation.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.682.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.683.1">There is more to learn about how to create defined schemas. </span><span class="koboSpan" id="kobo.683.2">You can check out the protobuf language guide </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">here: </span></span><a href="https://protobuf.dev/programming-guides/proto3/"><span class="No-Break"><span class="koboSpan" id="kobo.685.1">https://developers.go</span><span id="_idTextAnchor267"/><span class="koboSpan" id="kobo.686.1">ogle.com/protocol-buffers/docs/proto3</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.687.1">.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.688.1">Handling data migration with DataStore</span></h1>
<p><span class="koboSpan" id="kobo.689.1">If you have </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.690.1">built Android applications before, you </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.691.1">might have used </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.693.1">; the good news now is that there is support for migration, and you can migrate from </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.695.1"> to DataStore using </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">SharedPreferenceMigration</span></strong><span class="koboSpan" id="kobo.697.1">. </span><span class="koboSpan" id="kobo.697.2">As with any data, we will always modify our dataset; for instance, we might want to rename our data model values or even change </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">their type.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">In such a scenario, we will need a DataStore to DataStore migration; that is what we will be working on in this recipe. </span><span class="koboSpan" id="kobo.699.2">The process is pretty similar to the migration from </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">SharedPreferences</span></strong><span class="koboSpan" id="kobo.701.1">; as a matter of fact, </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">SharedPreferencesMigration</span></strong><span class="koboSpan" id="kobo.703.1"> is an implementati</span><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.704.1">on of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">DataMigration</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.706.1">interface class.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.707.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.708.1">Since we just created a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">PreferenceDataStore</span></strong><span class="koboSpan" id="kobo.710.1">, we will not need to migrate it, but we can look at ways to impl</span><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.711.1">ement a migration in case a </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">need arises.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.713.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.714.1">In this recipe, we will look at how you can utilize the knowledge learned to help you when a need to migrate to </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">DataStore arises:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.716.1">Let’s start by looking at the interface that helps with migration. </span><span class="koboSpan" id="kobo.716.2">The following code section showcases the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">DataMigration</span></strong><span class="koboSpan" id="kobo.718.1"> interface, which </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">SharedPreferencesMigration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.720.1"> implements:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.721.1">
/* Copyright 2022 Google LLC.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.722.1">
   SPDX-License-Identifier: Apache-2.0 */</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.723.1">
public interface DataMigration&lt;T&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.724.1">
    public suspend fun shouldMigrate(currentData: T): Boolean</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.725.1">
    public suspend fun migrate(currentData: T): T</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.726.1">
        public suspend fun cleanUp()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.727.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.728.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">Tasks</span></strong><span class="koboSpan" id="kobo.730.1"> data, we </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.731.1">might want to change the entries to </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">Int</span></strong><span class="koboSpan" id="kobo.733.1">; this means changing </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.734.1">one of our data types. </span><span class="koboSpan" id="kobo.734.2">We will imagine this scenario and try to create a migration based on this. </span><span class="koboSpan" id="kobo.734.3">We can start by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">new </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">migrateOnePreferencesDataStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.738.1">
private val Context.migrateOnePreferencesDataStore : DataStore&lt;Preferences&gt; by preferencesDataStore(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.739.1">
    name = "store_tasks"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.740.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.741.1">Now, let’s go on to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">DataMigration</span></strong><span class="koboSpan" id="kobo.743.1"> and override its functions. </span><span class="koboSpan" id="kobo.743.2">You will need to specify your condition for whether the migration should happen. </span><span class="koboSpan" id="kobo.743.3">The migration data shows instructions on how exactly the old data is transformed into new data. </span><span class="koboSpan" id="kobo.743.4">Then, once the migration is over, clean up the </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">old storage:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.745.1">
private val Context.migrationTwoPreferencesDataStore by preferencesDataStore(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.746.1">
    name = NEW_DataStore,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.747.1">
    produceMigrations = { context -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.748.1">
        listOf(object : DataMigration&lt;Preferences&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.749.1">
            override suspend fun</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.750.1">
                shouldMigrate(currentData:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.751.1">
                    Preferences) = true</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
            override suspend fun migrate(currentData:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.753.1">
            Preferences): Preferences {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.754.1">
                val oldData = context</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.755.1">
                    .migrateOnePreferencesDataStore</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.756.1">
                        .data.first().asMap()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.757.1">
                val currentMutablePrefs =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.758.1">
                    currentData.toMutablePreferences()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.759.1">
                oldToNew(oldData, currentMutablePrefs)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.760.1">
                return</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.761.1">
                   currentMutablePrefs.toPreferences()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.762.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.763.1">
            override suspend fun cleanUp() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.764.1">
                context.migrateOnePreferencesDataStore</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.765.1">
                    .edit { it.clear() }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.766.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.767.1">
        })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.768.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.769.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.770.1">Finally, let’s </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.771.1">create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">oldToNew()</span></strong><span class="koboSpan" id="kobo.773.1"> function, which is where we can add the data we </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.774.1">want </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">to migrate:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.776.1">
private fun oldToNew(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.777.1">
    oldData: Map&lt;Preferences.Key&lt;*&gt;, Any&gt;,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.778.1">
    currentMutablePrefs: MutablePreferences</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.779.1">
) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.780.1">
    oldData.forEach { (key, value) -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.781.1">
        when (value) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.782.1">
            //migrate data types you wish </span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.783.1">to migrate</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.784.1">
            ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.785.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.786.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
}</span></pre></li>
</ol>
<h2 id="_idParaDest-154"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.788.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.789.1">To better understand how </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">DataMigration</span></strong><span class="koboSpan" id="kobo.791.1"> works, we will need to look into the functions that are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">DataMigration</span></strong><span class="koboSpan" id="kobo.793.1"> interface. </span><span class="koboSpan" id="kobo.793.2">In our interface, we have three functions, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
    public suspend fun shouldMigrate(currentData: T):
        Boolean
    public suspend fun migrate(currentData: T): T
    public suspend fun cleanUp()</span></pre>
<p><span class="koboSpan" id="kobo.796.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">shouldMigrate()</span></strong><span class="koboSpan" id="kobo.798.1"> function, as the name suggests, establishes whether the migration needs to be performed or not. </span><span class="koboSpan" id="kobo.798.2">If, for instance, no migration is done, which means this will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">false</span></strong><span class="koboSpan" id="kobo.800.1">, then no migration or cleanup will occur. </span><span class="koboSpan" id="kobo.800.2">Also, it is crucial to note that this function is initialized every time we call our DataStore instance. </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">Migrate()</span></strong><span class="koboSpan" id="kobo.802.1">, on the other hand, performs </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">the migration.</span></span></p>
<p><span class="koboSpan" id="kobo.804.1">By chance, if</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.805.1"> the action fails or does not work as </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.806.1">expected, DataStore will not commit any data to the disk. </span><span class="koboSpan" id="kobo.806.2">Furthermore, the cleanup process will not occur, and an exception will be thrown. </span><span class="koboSpan" id="kobo.806.3">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">cleanUp()</span></strong><span class="koboSpan" id="kobo.808.1">, as it suggests, just cl</span><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.809.1">ears any old data from previous </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">data storage.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.811.1">Writing tests for our DataStore instance</span></h1>
<p><span class="koboSpan" id="kobo.812.1">Writing tests </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.813.1">is crucial in Android development, and in this recipe, we will write some tests for our DataStore instance. </span><span class="koboSpan" id="kobo.813.2">To test our</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.814.1"> DataStore instance or any DataStore instance, we first need to have instrumentation testing set up since we will be reading and writing in actual files (DataStore), and it is vital</span><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.815.1"> to verify that accurate updates are </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">being made.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.817.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.818.1">We will start by creating a simple unit test to test our view </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">model function:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.820.1">In our unit test folder, create a new folder and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">test</span></strong><span class="koboSpan" id="kobo.822.1">, and inside it, go ahead and create a new class </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">TaskViewModelTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.826.1">
  class TaskViewModelTest {}</span></pre></li>
<li><span class="koboSpan" id="kobo.827.1">Next, we will need to add some </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">testing dependencies:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.829.1">
testImplementation "io.mockk:mockk:1.13.3"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.830.1">
androidTestImplementation "io.mockk:mockk-android:1.13.3"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.831.1">
testImplementation "org.jetbrains.kotlinx:kotlinx-coroutines-test:1.5.2"</span></pre></li>
<li><span class="koboSpan" id="kobo.832.1">Now that we have added the required dependencies, let’s go ahead and create our mock </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.833.1">task service class and mock it, then</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.834.1"> initialize it in </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">the setup:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.836.1">
private lateinit var classToTest: TaskViewModel</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.837.1">
private val mockTaskService = mockk&lt;TaskService&gt;()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.838.1">
private val dispatcher = TestCoroutineDispatcher()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.839.1">
@Before</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.840.1">
fun setUp(){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.841.1">
    classToTest = TaskViewModel(mockTaskService)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.842.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.843.1">Since we use a coroutine, we will set up our dispatcher in @</span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Before annotation</span></strong><span class="koboSpan" id="kobo.845.1"> and clear any stored data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">@After</span></strong><span class="koboSpan" id="kobo.847.1"> annotation using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">Dispatchers.resetMain()</span></strong><span class="koboSpan" id="kobo.849.1">. </span><span class="koboSpan" id="kobo.849.2">If you run your tests without setting up a coroutine, they will fail with an error. </span><span class="koboSpan" id="kobo.849.3">The module with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">Main</span></strong><span class="koboSpan" id="kobo.851.1"> dispatcher failed to initialize. </span><span class="koboSpan" id="kobo.851.2">For tests, </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">Dispatchers.setMain</span></strong><span class="koboSpan" id="kobo.853.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">kotlinx-coroutines-test</span></strong><span class="koboSpan" id="kobo.855.1"> module can </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">be used:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.857.1">
@Before</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.858.1">
fun setUp(){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.859.1">
    classToTest = TaskViewModel(mockTaskService)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.860.1">
    Dispatchers.setMain(dispatcher)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.861.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.862.1">
@After</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.863.1">
fun tearDown() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.864.1">
    Dispatchers.resetMain()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.865.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.866.1">After that is</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.867.1"> completed, let’s go on and create a new test called </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">Verify add tasks function adds tasks as needed</span></strong><span class="koboSpan" id="kobo.869.1">. </span><span class="koboSpan" id="kobo.869.2">In this test, we will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">fakeTask</span></strong><span class="koboSpan" id="kobo.871.1">, add those tasks to </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">saveTaskData</span></strong><span class="koboSpan" id="kobo.873.1">, and ensure data is inserted as expected by </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.874.1">checking that we did not </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">store </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.878.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.879.1">
fun  `Verify add tasks function adds tasks as needed`() = runBlocking {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.880.1">
    val fakeTasks = Tasks(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.881.1">
        firstTask = "finish school work",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.882.1">
        secondTask = "buy gifts for the holiday",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.883.1">
        thirdTask = "finish work"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.884.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.885.1">
    val expected = classToTest.saveTaskData(fakeTasks)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.886.1">
    Assert.assertNotNull(expected)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.887.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.888.1">Finally, when you run the unit test, it should pass, and you will see a green </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">check mark</span><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.890.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.891.1"><img alt="Figure 5.7 – The test passing in the view model" src="image/Figure_5.7_B18827.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.892.1">Figure 5.7 – The test passing in the view model</span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.893.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.894.1">There are</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.895.1"> different mocking libraries used in Android: </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">Mockito</span></strong><span class="koboSpan" id="kobo.897.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">Mockk</span></strong><span class="koboSpan" id="kobo.899.1">, and more. </span><span class="koboSpan" id="kobo.899.2">In this recipe, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">Mockk</span></strong><span class="koboSpan" id="kobo.901.1">, a user-friendly mocking library for Android. </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">testImplementation "io.mockk:mockk:1.13.3"</span></strong><span class="koboSpan" id="kobo.903.1"> is used for unit tests, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">androidTestImplementation "io.mockk:mockk-android:1.13.3"</span></strong><span class="koboSpan" id="kobo.905.1"> is used for </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">UI tests.</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">To test the UI, we will need to follow a pattern, creating a test DataStore instance with default values stored inside it. </span><span class="koboSpan" id="kobo.907.2">Then, we create the test subject and verify that the test DataStore values coming from our function match the expected results. </span><span class="koboSpan" id="kobo.907.3">We will also need to </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">TestCoroutineDispatcher</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.911.1">
private val coroutineDispatcher: TestCoroutineDispatcher =
    TestCoroutineDispatcher()</span></pre>
<p><span class="koboSpan" id="kobo.912.1">The preceding</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.913.1"> code performs the execution of the coroutines, which is, by default, immediate. </span><span class="koboSpan" id="kobo.913.2">This simply means any tasks scheduled to be run without delays are executed immediately. </span><span class="koboSpan" id="kobo.913.3">We also use the same coroutines for our view models. </span><span class="koboSpan" id="kobo.913.4">That is also because DataStore is based on Kotlin coroutines; hen</span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.914.1">ce we need to ensure our tests have the </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">right setup.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.916.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.917.1">There is more to learn about DataStore. </span><span class="koboSpan" id="kobo.917.2">We cannot cover it all in just one chapter. </span><span class="koboSpan" id="kobo.917.3">For more information on DataStore, that is, Preference and Proto, you can check out this </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">link: </span></span><a href="https://developer.android.com/topic/libraries/architecture/datastore"><span class="No-Break"><span class="koboSpan" id="kobo.919.1">https://developer.android.com/topic/libraries/architecture/datastore</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.920.1">.</span></span></p>
</div>
</body></html>