<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Applying Contexts to Files</h1></div></div></div><p>In the last chapter, we upgraded our system, collected the audit logs, and started to analyze the audit records. We discovered that some objects on the filesystem were unlabeled. In this chapter, we will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn how filesystems and filesystem objects get their labels</li><li class="listitem" style="list-style-type: disc">Demonstrate techniques to change labels</li><li class="listitem" style="list-style-type: disc">Introduce extended attributes for labeling</li><li class="listitem" style="list-style-type: disc">Investigate file contexts and dynamic type transitions</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Labeling filesystems</h1></div></div></div><p>Filesystems<a id="id214" class="indexterm"/> on Linux originate from mount, with the exception of <code class="literal">ramdisk rootfs</code> on Android. Filesystems on Linux vary drastically. In general, in order to support all the features of SELinux, you need a filesystem with the support for <code class="literal">xattr</code> and the <code class="literal">security</code> namespace. We saw this requirement when we were setting up the kernel configuration.</p><p>Filesystem objects, as they are created, all start with an initial context, just like all other kernel objects. Contexts on files simply inherit from their parent, so if the parent is unlabeled, then the child is unlabeled, with the exception of a type transition rule. Typically, if the context is unlabeled, it infers that the data was created on a filesystem prior to enabling SELinux support, or the type label in the <code class="literal">xattr</code> does not exist in the currently loaded policy.</p><p>The initial <a id="id215" class="indexterm"/>label or initial <strong>security id</strong> (<strong>sid</strong>), is in the <code class="literal">sepolicy</code> file <code class="literal">initial_sid_contexts</code>. Each object class has its associated initial <code class="literal">sid</code> present. For example, let's take a look at the following code snippet:</p><div><pre class="programlisting">...
sid fs u:object_r:labeledfs:s0
sid file u:object_r:unlabeled:s0
...</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec30"/>fs_use</h2></div></div></div><p>Filesystems <a id="id216" class="indexterm"/>can be labeled in a variety of ways. The best case scenario is <a id="id217" class="indexterm"/>when the filesystem supports <code class="literal">xattrs</code>. In that case, an <code class="literal">fs_use_xattr</code> statement should appear in the policy. These statements appear in the <code class="literal">fs_use</code> file in the <code class="literal">sepolicy</code> directory. The syntax for <code class="literal">fs_use_xattr</code> is:</p><div><pre class="programlisting">
<strong>fs_use_xattr &lt;fstype&gt; &lt;context&gt;</strong>
</pre></div><p>To look at <code class="literal">fs_use</code> from <code class="literal">sepolicy</code>, we can refer to an example for the <code class="literal">ext4</code> filesystems:</p><div><pre class="programlisting">...
fs_use_xattr ext3 u:object_r:labeledfs:s0;
fs_use_xattr ext4 u:object_r:labeledfs:s0;
fs_use_xattr xfs u:object_r:labeledfs:s0;
...</pre></div><p>This tells SELinux that when it encounters an <code class="literal">ext4</code> <code class="literal">fs</code> object; look in the extended attributes for the label or file context.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec31"/>fs_task_use</h2></div></div></div><p>The <a id="id218" class="indexterm"/>other way a filesystem can be labeled is by using the process' context <a id="id219" class="indexterm"/>while creating objects. This makes sense for pseudo filesystems where the objects are really process contexts, such as <code class="literal">pipefs</code> and <code class="literal">sockfs</code>. These pseudo filesystems manage the pipe and socket syscalls and are not really mounted to userspace. They exist internally to the kernel, for the kernels use. However, they do have objects, and like any other object, they need to be labeled. This is the context in which the <code class="literal">fs_task_use</code> policy statement makes sense. These internal filesystems can only be accessed by processes directly, and provide services to those processes. Hence, labeling them with the creator makes sense. The syntax is as follows:</p><div><pre class="programlisting">
<strong>fs_task_use &lt;fstype&gt; &lt;context&gt;</strong>
</pre></div><p>Examples from the <code class="literal">sepolicy</code> file <code class="literal">fs_use</code> are as follows:</p><div><pre class="programlisting">...
# Label inodes from task label.
fs_use_task pipefs u:object_r:pipefs:s0;
fs_use_task sockfs u:object_r:sockfs:s0;
...</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec32"/>fs_use_trans</h2></div></div></div><p>The next <a id="id220" class="indexterm"/>way you might wish to set labels on pseudo filesystems <a id="id221" class="indexterm"/>that are actually mounted, is by using <code class="literal">fs_use_trans</code>. This sets a filesystem wide label on the pseudo filesystem. The syntax for this is as follows:</p><div><pre class="programlisting">
<strong>fs_use_trans &lt;fstype&gt; &lt;context&gt;</strong>
</pre></div><p>Example <a id="id222" class="indexterm"/>from <a id="id223" class="indexterm"/>the <code class="literal">sepolicy</code> file <code class="literal">fs_use</code> is as follows:</p><div><pre class="programlisting">...
fs_use_trans devpts u:object_r:devpts:s0;
fs_use_trans tmpfs u:object_r:tmpfs:s0;
...</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec33"/>genfscon</h2></div></div></div><p>If none <a id="id224" class="indexterm"/>of the <code class="literal">fs_use_*</code> statements meet your use cases, which<a id="id225" class="indexterm"/> would be the case for <code class="literal">vfat</code> filesystems and <code class="literal">procfs</code>, then you would use the <code class="literal">genfscon</code> statement. The label specified for <code class="literal">genfscon</code> applies to <em>all</em> instances of that filesystem mount. For instance, you might wish to use <code class="literal">genfscon</code> with the <code class="literal">vfat</code> filesystems. If you have two <code class="literal">vfat</code> mounts, they will use the same <code class="literal">genfscon</code> statement for each mount. However, <code class="literal">genfscon</code> behaves differently with <code class="literal">procfs</code>, and lets you label each file or directory within the filesystem.</p><p>The syntax of <code class="literal">genfscon</code> is as follows:</p><div><pre class="programlisting">
<strong>genfscon &lt;fstype&gt; &lt;path&gt; &lt;context&gt;</strong>
</pre></div><p>Examples from <code class="literal">sepolicy genfs_contexts</code> are as follows:</p><div><pre class="programlisting">...
# Label inodes with the fs label.
genfscon rootfs / u:object_r:rootfs:s0
# proc labeling can be further refined (longest matching prefix).
genfscon proc / u:object_r:proc:s0
genfscon proc /net/xt_qtaguid/ctrl u:object_r:qtaguid_proc:s0
...</pre></div><p>Note that the <code class="literal">rootfs</code> partial path is <code class="literal">/</code>. It's not <code class="literal">procfs</code>, so it doesn't support any fine granularity to its labeling; so <code class="literal">/</code> is the only thing you can use. However, you can get wild with <code class="literal">procfs</code> and set to any granularity you desire.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec34"/>Mount options</h2></div></div></div><p>Another<a id="id226" class="indexterm"/> option, if none of those fit your needs, is to pass<a id="id227" class="indexterm"/> the <code class="literal">context</code> option via the <code class="literal">mount</code> command line. This sets a filesystem wide mount context, such as <code class="literal">genfscon</code>, but is useful in the case of multiple filesystems that need to have separate labels. For instance, if you have two <code class="literal">vfat</code> filesystems mounted, you might wish to separate accesses to them. With <code class="literal">genfscon</code> statements, both filesystems would use the same label provided by <code class="literal">genfscon</code>. By specifying the label at mount time, you can have two <code class="literal">vfat</code> filesystems mounted with different labels.</p><p>Take the following command as an example:</p><div><pre class="programlisting">
<strong>mount -ocontext=u:object_r:vfat1:s0 /dev/block1 /mnt/vfat1</strong>
<strong>mount -ocontext=u:object_r:vfat2:s0 /dev/block1 /mnt/vfat2</strong>
</pre></div><p>Additional to<a id="id228" class="indexterm"/> the context as a mount option are: <code class="literal">fscontext</code> and <code class="literal">defcontext</code>. These options are mutually exclusive from context. The <code class="literal">fscontext</code> option <a id="id229" class="indexterm"/>sets the meta filesystem type that is used for certain operations, such as mount, but does not change the per file labels. The <code class="literal">defcontext</code> sets the default context for unlabeled files overriding the <code class="literal">initial_sid</code> statements. Lastly, another option, <code class="literal">rootcontext</code> allows you to set the root inode context in the filesystem, but only for that object. According to the man page mount (<code class="literal">man 8 mount</code>), it was found useful in stateless Linux.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec35"/>Labeling with extended attributes</h2></div></div></div><p>Lastly, and<a id="id230" class="indexterm"/> probably the most frequently used way<a id="id231" class="indexterm"/> of labeling, is by using the extended attributes support also known as <code class="literal">xattr</code> or EA support. Even with <code class="literal">xattr</code> support, new objects inherit the context of their parent directory; however, these labels have the granularity of being per filesystem object-based or inode-based. If you remember, we had to turn on or verify that <code class="literal">XATTR(CONFIG_EXT4_FS_XATTR)</code> support was enabled for our filesystems on Android as well as configuring SELinux to use it via the config option <code class="literal">CONFIG_EXT4_FS_SECURITY</code>.</p><p>Extended attributes are a key-value metadata stores for files. SELinux security contexts use the <code class="literal">security.selinux</code> key, and the value is a string that is the security context or label.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec36"/>The file_contexts file</h2></div></div></div><p>Within<a id="id232" class="indexterm"/> the <code class="literal">sepolicy</code> directory, you will find the <code class="literal">file_contexts</code> file. This file is consulted to set the attributes on filesystems that support <a id="id233" class="indexterm"/>per file security labels. Note that a couple of pseudo filesystems support this as well, such as <code class="literal">tmpfs</code>, <code class="literal">sysfs</code>, and recently <code class="literal">rootfs</code>. The <code class="literal">file_context</code> file has a regular expression-based syntax as follows, where <code class="literal">regexp</code> is the regular expression for the path:</p><div><pre class="programlisting">
<strong>regexp &lt;type&gt; ( &lt;file label&gt; | &lt;&lt;none&gt;&gt; )</strong>
</pre></div><p>If multiple regular expressions are defined for a file, the last match is used, so order is important.</p><p>The following <a id="id234" class="indexterm"/>list shows each type field value for the type of filesystem object, their meanings, and syscall interface:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">--</code>: This <a id="id235" class="indexterm"/>denotes a regular file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-d</code>: This <a id="id236" class="indexterm"/>denotes a directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-b</code>: This<a id="id237" class="indexterm"/> denotes a block file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-s</code>: This<a id="id238" class="indexterm"/> denotes a socket file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-c</code>: This<a id="id239" class="indexterm"/> denotes a character file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-l</code>: This<a id="id240" class="indexterm"/> denotes a link file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-p</code>: This <a id="id241" class="indexterm"/>denotes a named pipe file.</li></ul></div><p>As you <a id="id242" class="indexterm"/>can see, the type is essentially the mode as output<a id="id243" class="indexterm"/> by <code class="literal">ls -la</code> command. If it's not specified, it matches everything.</p><p>The next field is the file label or the special identifier <code class="literal">&lt;&lt;none&gt;&gt;</code>. Either one would supply a context or the identifier <code class="literal">&lt;&lt;none&gt;&gt;</code>. If you specify the context, the SELinux tools that consult <code class="literal">file_contexts</code> use the last match to the specified context. If the context specified is <code class="literal">&lt;&lt;none&gt;&gt;</code>, it means that no context is assigned. So, leave the one that we have found. The keyword <code class="literal">&lt;&lt;none&gt;&gt;</code> is not used in the AOSP reference, <code class="literal">sepolicy</code>.</p><p>It's important to note that the preceding paragraph explicitly states that SELinux tools use the <code class="literal">file_contexts</code> policy. The kernel is not aware that this file exists. SELinux labels all its objects by explicitly setting them from userspace with tools that look up the context in <code class="literal">file_context</code> or via the <code class="literal">fs_use_*</code> and <code class="literal">genfs</code> policy statements. In other words, <code class="literal">file_contexts</code> is not built in the core policy file, and it is not loaded or used directly by the kernel. At build time, the <code class="literal">file_contexts</code> file is built in the ramdisk rootfs and can be found at <code class="literal">/file_contexts</code>. Also, during build time, the system image is labeled, freeing the device itself from this burden.</p><p>In Android, <code class="literal">init</code>, <code class="literal">ueventd</code>, and <code class="literal">installd</code> have all been modified to look up the contexts of objects they are creating; so that they can label them properly. Thus, all the init built ins that create filesystem objects, such as <code class="literal">mkdir</code>, have been modified to make use of the <code class="literal">file_contexts</code> file if it exists, and the same goes for <code class="literal">installd</code> and <code class="literal">ueventd</code>.</p><p>Let's take a look at some snippets from the <code class="literal">file_context</code> file located in <code class="literal">sepolicy</code>:</p><div><pre class="programlisting">...
/dev(/.*)? u:object_r:device:s0
/dev/accelerometer u:object_r:sensors_device:s0
/dev/alarm u:object_r:alarm_device:s0
...</pre></div><p>Here, we are setting up the contexts for files in <code class="literal">/dev</code>. Note how the entries are in order from most generic to more specific <code class="literal">dev</code> files. Thus, any files not covered by the more specific entries will end up with the context <code class="literal">u:object_r:device:s0</code>, and the files that match further down, end up with a more specific label. For instance, the accelerometer at <code class="literal">/dev/accelerometer</code> will get the context <code class="literal">u:object_r:sensors_device:s0</code>. Note that the type field was omitted, which means that it matches on <em>all</em> filesystem objects, such as directories (<code class="literal">type -d</code>).</p><p>You<a id="id244" class="indexterm"/> might be wondering how <code class="literal">/dev</code>, the directory itself, gets <a id="id245" class="indexterm"/>a file context. Looking at some of the snippets, we say the <code class="literal">/</code> or root, got labeled via the statement <code class="literal">genfscon rootfs / u:object_r:rootfs:s0</code> in the <code class="literal">genfs_context</code> file. This chapter stated earlier that, "new objects inherit the context of their parent directory." Hence, we can reason that <code class="literal">/dev</code> is of context <code class="literal">u:object_r:rootfs:s0</code> since that is the label <code class="literal">/</code> has. We can test this by passing the <code class="literal">-Z</code> flag to <code class="literal">ls</code> to show us the label of <code class="literal">/dev</code>. On the UDOO serial connection, execute the following command:</p><div><pre class="programlisting">
<strong>130|root@udoo:/ # ls -laZ / </strong>
<strong>...</strong>
<strong>drwxr-xr-x root root u:object_r:device:s0 dev</strong>
<strong>...</strong>
</pre></div><p>It seems that the hypothesis is incorrect, but note that it is true that everything has a label, and if it's not specified, then it inherits from the parent. Looking back at <code class="literal">sepolicy</code>, we can see that the <code class="literal">dev</code> filesystem was initially set with a <code class="literal">fs_use_trans devtmpfs u:object_r:device:s0;</code> policy statement. So when the filesystem is mounted, it is set filesystem wide. Later, when entries are added by <code class="literal">init</code> or <code class="literal">ueventd</code>, they use <code class="literal">file_contexts</code> entries to set the context of the newly created filesystem object to what is specified in the <code class="literal">file_contexts</code> file. The filesystem at<code class="literal"> /dev</code>, which is a <code class="literal">devtmps</code> pseudo filesystem, is an example of a filesystem that has both a filesystem-wide label via the <code class="literal">fs_use_trans</code> statement, but can also support fine grained labeling via <code class="literal">file_contexts;</code>. Filesystems are not very consistent in capabilities on Linux.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec37"/>Dynamic type transitions</h2></div></div></div><p>Dynamic<a id="id246" class="indexterm"/> type transitions indicated by the SELinux <a id="id247" class="indexterm"/>policy statement <code class="literal">type_transition</code> are a way to allow files to dynamically determine their types. Because these are compiled into the policy, these do not have any relation to the <code class="literal">file_contexts</code> file. These policy statements allow the policy author to dynamically dictate the context of a file based on the context in which the file is created. These are useful in situations where you don't control source code, or do not wish to couple SELinux in any way. For instance, the <code class="literal">wpa</code> supplicant, which is a service that runs for Wi-Fi support and creates a socket file in its data directory. Its data directory is labeled with the type <code class="literal">wifi_data_file</code> and as expected, the socket ends up with that label. However, this socket is shared by the system server. Now, we can allow just the system server to access the type and object class, however, <code class="literal">hostapd</code> and other things are creating sockets and other objects in that directory and thus the objects also have this type. We really want to ensure that the two sockets in question, the one used by <code class="literal">hostapd</code> and the other by system server, are kept exclusive from each other. To do this, we need to be able <a id="id248" class="indexterm"/>to label one of the sockets at a finer granularity, and <a id="id249" class="indexterm"/>to do so, we can either modify the code or use a dynamic type transition. Rather than mucking with the code, let's use a type transition, as follows:</p><div><pre class="programlisting">
<strong>type_transition wpa wifi_data_file:sock_file wpa_socket;</strong>
</pre></div><p>This is an actual statement from the <code class="literal">sepolicy</code> file, <code class="literal">wpa_supplicant.te</code>. It says that, when a process of the type <code class="literal">wpa</code> creates a file of the type <code class="literal">wifi_data_file</code> and the object class is <code class="literal">sock_file</code> to label it as <code class="literal">wpa_socket</code> on creation. The statement syntax is as follows:</p><div><pre class="programlisting">type_transition &lt;creating type&gt; &lt;created type&gt;:&lt;class&gt; &lt;new type&gt;;</pre></div><p>As of SELinux policy version 25, the <code class="literal">type_transition</code> statement can support named type transitions where a fourth argument exists and is the name of the file:</p><div><pre class="programlisting">type_transition &lt;creating type&gt; &lt;created type&gt;:&lt;class&gt; &lt;new type&gt; &lt;file name&gt;;</pre></div><p>We will see an example use of this filename in the <code class="literal">sepolicy</code> file, <code class="literal">system_server.te</code>:</p><div><pre class="programlisting">type_transition system_server system_data_file:sock_file system_ndebug_socket "ndebugsocket";</pre></div><p>Note the filename or basename and not the path, and it must match exactly. Regex is not supported. It's also interesting to note that the dynamic transitions are not limited to file objects, but any object class event processes. We will see how dynamic process transitions are used in <a class="link" href="ch09.html" title="Chapter 9. Adding Services to Domains">Chapter 9</a>, <em>Adding Services to Domains</em>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Examples and tools</h1></div></div></div><p>With the <a id="id250" class="indexterm"/>theory behind us, let's look at the tools and techniques to label files in the system. Let's start by mounting a <code class="literal">ramfs</code> filesystem. We will start by remounting <code class="literal">/</code> since it is read only and create a mount point for the filesystem. Via the UDOO serial console, execute:</p><div><pre class="programlisting">
<strong>root@udoo:/ # mount -oremount,rw /</strong>
<strong>root@udoo:/ # mkdir /ramdisk</strong>
<strong>root@udoo:/ # mount -t ramfs -o size=20m ramfs /ramdisk</strong>
</pre></div><p>Now, we want to see which label the filesystem has:</p><div><pre class="programlisting">
<strong># ls -laZ / | grep ramdisk </strong>
<strong>drwxr-xr-x root root u:object_r:unlabeled:s0 ramdisk</strong>
</pre></div><p>As you can recall, the <code class="literal">initial_sid_context</code> file had this initial <code class="literal">sid</code> set for the filesystem:</p><div><pre class="programlisting">sid file u:object_r:unlabeled:s0</pre></div><p>If we want to get this ramdisk in a new label, we need to create the type in the policy, and set a new <code class="literal">genfscon</code> statement to use it. We will declare the new type in the sepolicy file <code class="literal">file.te</code>:</p><div><pre class="programlisting">type ramdisk, file_type, fs_type;</pre></div><p>The type policy statement syntax is as follows:</p><div><pre class="programlisting">type &lt;new type&gt;, &lt;attribute0,attribute1…attributeN&gt;;</pre></div><p>Attributes<a id="id251" class="indexterm"/> in SELinux are statements that let you define common groups. They are defined via the <code class="literal">attribute</code> statement. In Android SELinux policy, we have <code class="literal">file_type</code> and <code class="literal">fs_type</code> defined for us already. We will use them here because this new type, which we're creating, has the attributes <code class="literal">file_type</code> and <code class="literal">fs_type</code>. The <code class="literal">file_type</code> attribute is associated with a type for a file, and the <code class="literal">fs_type</code> attribute means that this type is also associated with filesystems. Attributes, right now, are not of great importance; so don't get caught up in the detail.</p><p>The next thing to modify is the <code class="literal">sepolicy</code> file, <code class="literal">genfs_context</code> by adding the following:</p><div><pre class="programlisting">genfscon ramfs / u:object_r:ramdisk:s0</pre></div><p>Now, we will compile the boot image and flash it to the device, or better yet, let's use the dynamic policy reload support like the following.</p><p>From the root of the UDOO project tree build just the <code class="literal">sepolicy</code> project:</p><div><pre class="programlisting">
<strong>$ mmm external/sepolicy/</strong>
</pre></div><p>Push the new policy over <code class="literal">adb</code>, as follows:</p><div><pre class="programlisting">
<strong>$ adb push $OUT/root/sepolicy /data/security/current/sepolicy</strong>
<strong>544 KB/s (86409 bytes in 0.154s)</strong>
</pre></div><p>Trigger a reload by using the <code class="literal">setprop</code> command:</p><div><pre class="programlisting">
<strong>$ adb shell setprop selinux.reload_policy 1</strong>
</pre></div><p>If you have the serial console connected, you should see:</p><div><pre class="programlisting">
<strong>SELinux: Loaded policy from /data/security/current/sepolicy</strong>
</pre></div><p>If you don't, and just have <code class="literal">adb</code>, check <code class="literal">dmesg</code>:</p><div><pre class="programlisting">
<strong>$ adb shell dmesg | grep "SELinux: Loaded"</strong>
<strong>&lt;4&gt;SELinux: Loaded policy from /sepolicy</strong>
<strong>&lt;6&gt;init: SELinux: Loaded property contexts from /property_contexts</strong>
<strong>&lt;4&gt;SELinux: Loaded policy from /data/security/current/sepolicy</strong>
</pre></div><p>A successful load should use our policy at the path, <code class="literal">/data/security/current/sepolicy</code>. Let's unmount the ramdisk and remount it to check out its type:</p><div><pre class="programlisting">
<strong>root@udoo:/ # umount /ramdisk </strong>
<strong>root@udoo:/ # mount -t ramfs -o size=20m ramfs /ramdisk</strong>
<strong>root@udoo:/ # ls -laZ / | grep ramdisk</strong>
<strong>drwxr-xr-x root root u:object_r:ramdisk:s0 ramdisk</strong>
</pre></div><p>We were<a id="id252" class="indexterm"/> able to modify the policy and use <code class="literal">genfscon</code> to change the filesystem type, and now to show inheritance, let's go ahead and create a file on the filesystem with <code class="literal">touch</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/ # cd /ramdisk</strong>
<strong>root@udoo:/ramdisk # touch hello</strong>
<strong>root@udoo:/ramdisk # ls -Z</strong>
<strong>-rw------- root root u:object_r:ramdisk:s0 hello</strong>
</pre></div><p>As we expected, the new file is labeled with the type ramdisk. Now, suppose when we do touch from the shell, we want the file to be of a different type, such as <code class="literal">ramdisk_newfile</code>; how can we do this? We can do this by modifying touch itself to consult <code class="literal">file_contexts</code>, or we can define a dynamic type transition; let us try the dynamic type transition approach. The first argument to the <code class="literal">type_transition</code> statement is the creating type; so what type is our shell in? You can get this by performing:</p><div><pre class="programlisting">
<strong>root@udoo:/ramdisk # echo `cat /proc/self/attr/current`</strong>
<strong>u:r:init_shell:s0</strong>
</pre></div><p>A simpler way is to run the <code class="literal">id -Z</code> command, which uses the aforementioned <code class="literal">proc</code> file. For a serial console, execute:</p><div><pre class="programlisting">
<strong>root@udoo:/ramdisk # id -Z</strong>
<strong>uid=0(root) gid=0(root) context=u:r:init_shell:s0</strong>
</pre></div><p>And to run the same command for the <code class="literal">adb</code> shell:</p><div><pre class="programlisting">
<strong>$ adb shell id -Z</strong>
<strong>uid=0(root) gid=0(root) context=u:r:shell:s0</strong>
</pre></div><p>Note the discrepancy between our serial console shell and the <code class="literal">adb</code> shell, in <a class="link" href="ch09.html" title="Chapter 9. Adding Services to Domains">Chapter 9</a>, <em>Adding Services to Domains</em>; we will fix this. Because of this, the policy we author now will address both cases.</p><p>Start by opening the <code class="literal">sepolicy</code> file, <code class="literal">init_shell.te</code> and append the following to the end of the file:</p><div><pre class="programlisting">type_transition init_shell ramdisk:file ramdisk_newfile;</pre></div><p>Do this for the <code class="literal">sepolicy</code> file, <code class="literal">shell.te</code>:</p><div><pre class="programlisting">type_transition shell ramdisk:file ramdisk_newfile;</pre></div><p>Now, we need to declare the new type; so open up the <code class="literal">sepolicy</code> file, <code class="literal">file.te</code> and append the following:</p><div><pre class="programlisting">type ramdisk_newfile, file_type;</pre></div><p>Note that we have only used the <code class="literal">file_type</code> attribute. This is because a filesystem should never have the type <code class="literal">ramdisk_newfile</code>, only a file residing within that file system should.</p><p>Now, build <a id="id253" class="indexterm"/>the <code class="literal">adb</code> policy, push it to the device, and trigger a reload. With that done, create the file and check the results:</p><div><pre class="programlisting">
<strong>$ adb shell 'touch /ramdisk/shell_newfile'</strong>
<strong>$ adb shell 'ls -laZ /ramdisk'</strong>
<strong>-rw-rw-rw- root root u:object_r:ramdisk:s0 shell_newfile</strong>
</pre></div><p>So it didn't work. Let's investigate the reason by trying on an example of an <code class="literal">ext4</code> filesystem. Let's use the following commands:</p><div><pre class="programlisting">
<strong>root@udoo:/ # cd /data/</strong>
<strong>root@udoo:/data # mkdir ramdisk</strong>
</pre></div><p>Now, check its context:</p><div><pre class="programlisting">
<strong>root@udoo:/data # ls -laZ | grep ramdisk</strong>
<strong>drwx------ root rootu:object_r:system_data_file:s0 ramdisk</strong>
</pre></div><p>The label is <code class="literal">system_data_file</code>. This is not helpful, as it doesn't apply to our type transition rule; to fix this, we can use the <code class="literal">chcon</code> command to explicitly change the files context:</p><div><pre class="programlisting">
<strong>root@udoo:/data # chcon u:object_r:ramdisk:s0 ramdisk</strong>
<strong>root@udoo:/data # ls -laZ | grep ramdisk</strong>
<strong>drwx------ root root u:object_r:ramdisk:s0 ramdisk</strong>
</pre></div><p>Now with the context changed to match what we were trying earlier with the ramdisk, let's try to create a file within this directory:</p><div><pre class="programlisting">
<strong>root@udoo:/data/ramdisk # touch newfile</strong>
<strong>root@udoo:/data/ramdisk # ls -laZ</strong>
<strong>-rw------- root root u:object_r:ramdisk_newfile:s0 newfile</strong>
</pre></div><p>As you can see, the type transition has occurred. This was meant to illustrate the issues you may find while working with SELinux and Android. Now that we have shown that our <code class="literal">type_transition</code> statement is valid, there are only two possibilities why this is failing: the filesystem doesn't support it or we're missing something somewhere to "turn it on". It turns out that the latter is the case; we were missing our <code class="literal">fs_use_trans</code> statements. So go ahead and open up the <code class="literal">sepolicy</code> file, <code class="literal">fs_use</code> and add the following line:</p><div><pre class="programlisting">fs_use_trans ramfs u:object_r:ramdisk:s0;</pre></div><p>This statement enables SELinux dynamic transitions on this filesystem. Now, rebuild the <code class="literal">sepolicy</code> project, <code class="literal">adb push</code> the policy file, and enable a dynamic reload via <code class="literal">setprop</code>:</p><div><pre class="programlisting">
<strong>$ mmm external/sepolicy</strong>
<strong>$ adb push $OUT/root/sepolicy /data/security/current/sepolicy546 KB/s (86748 bytes in 0.154s)</strong>
<strong>$ adb shell setprop selinux.reload_policy 1</strong>
<strong>root@udoo:/ # cd ramdisk</strong>
<strong>root@udoo:/ramdisk # touch foo</strong>
<strong>root@udoo:/ramdisk # ls -Z</strong>
<strong>-rw------- root root u:object_r:ramdisk_newfile:s0 foo</strong>
</pre></div><p>There you<a id="id254" class="indexterm"/> have it, the object has the right value determined by a dynamic type transition. We were missing <code class="literal">fs_use_trans</code>, which enabled type transitions on filesystems that don't support <code class="literal">xattrs</code>.</p><p>Now, suppose we want to mount another ramdisk, what would happen? Well since it was labeled with the <code class="literal">genfscon</code> statement, all filesystems mounted with that type should get the context, <code class="literal">u:object_r:ramdisk:s0</code>. We will mount this filesystem at <code class="literal">/ramdisk2</code>, and verify this behavior:</p><div><pre class="programlisting">
<strong>root@udoo:/ # mkdir ramdisk2</strong>
<strong>root@udoo:/ # mount -t ramfs -o size=20m ramfs /ramdisk2</strong>
</pre></div><p>Also, check the contexts:</p><div><pre class="programlisting">
<strong>root@udoo:/ # ls -laZ | grep ramdisk</strong>
<strong>drwxr-xr-x root root u:object_r:ramdisk:s0 ramdisk</strong>
<strong>drwxr-xr-x root root u:object_r:ramdisk:s0 ramdisk2</strong>
</pre></div><p>If we want to write allow rules to separate accesses to these file systems, we will need to have their target files in separate types. To do this, we can mount the new ramdisk with the context option. But first, we need to create the new type; lets go to the <code class="literal">sepolicy</code> file, <code class="literal">file.te</code> and add a new type called <code class="literal">ramdisk2</code>:</p><div><pre class="programlisting">type ramdisk2, file_type, fs_type;</pre></div><p>Now, build the <code class="literal">sepolicy</code> with the command <code class="literal">mmm</code>, followed be using the command <code class="literal">abd push</code> to push the policy, and trigger a reload with the <code class="literal">setprop</code> command:</p><div><pre class="programlisting">
<strong>$ mmm external/sepolicy/</strong>
<strong>$ adb push out/target/product/udoo/root/sepolicy /data/security/current/sepolicy542 KB/s (86703 bytes in 0.155s)</strong>
<strong>$ adb shell setprop selinux.reload_policy 1</strong>
</pre></div><p>At this point, let's umount <code class="literal">/ramdisk2</code> and remount it with the <code class="literal">context=</code> option:</p><div><pre class="programlisting">
<strong>root@udoo:/ # umount /ramdisk2/ </strong>
<strong>root@udoo:/ # mount -t ramfs -osize=20m,context=u:object_r:ramdisk2:s0 ramfs /ramdisk2</strong>
</pre></div><p>Now, verify the contexts:</p><div><pre class="programlisting">
<strong>root@udoo:/ # ls -laZ | grep ramdisk </strong>
<strong>drwxr-xr-x root root u:object_r:ramdisk:s0 ramdisk</strong>
<strong>drwxr-xr-x root root u:object_r:ramdisk2:s0 ramdisk2</strong>
</pre></div><p>We can override the <code class="literal">genfscon</code> context with the <code class="literal">mount</code> option, <code class="literal">context=&lt;context&gt;</code>. In fact, if we look at <code class="literal">dmesg</code>, we can see some great messages. When we mounted <code class="literal">ramfs</code> without the context option, we got:</p><div><pre class="programlisting">
<strong>&lt;7&gt;SELinux: initialized (dev ramfs, type ramfs), uses genfs_contexts</strong>
</pre></div><p>When we mounted it with the <code class="literal">context=&lt;context&gt;</code> option, we got:</p><div><pre class="programlisting">
<strong>&lt;7&gt;SELinux: initialized (dev ramfs, type ramfs), uses mountpoint labeling</strong>
</pre></div><p>We can<a id="id255" class="indexterm"/> see that SELinux gives us some helpful messages while trying to figure out from where it sources its labels.</p><p>Now, let's go onto labeling filesystems with the <code class="literal">xattr</code> support, such as <code class="literal">ext4</code>. We will start with <a id="id256" class="indexterm"/>the toolbox command, <code class="literal">chcon</code>. The <code class="literal">chcon</code> command allows you to set the context of a file system object explicitly, it does not consult <code class="literal">file_contexts</code>.</p><p>Let's take a look at <code class="literal">/system/bin</code> and in it, at the first 10 files:</p><div><pre class="programlisting">
<strong>$ adb shell ls -laZ /system/bin | head -n10</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 InputDispatcher_test</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 InputReader_test</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 abcc</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 adb</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 am</strong>
<strong>-rwxr-xr-x root shell u:object_r:zygote_exec:s0 app_process</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 applypatch</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 applypatch_static</strong>
<strong>drwxr-xr-x root shell u:object_r:system_file:s0 asan</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 asanwrappe</strong>
</pre></div><p>We can see that many of them have the <code class="literal">system_file</code> label, which is the default label for that filesystem; let's change the <code class="literal">am</code> type to <code class="literal">am_exec</code>. Again, we need to create a new type by adding the following to <code class="literal">sepolicy</code> file, <code class="literal">file.te</code>:</p><div><pre class="programlisting">type am_exec, file_type;</pre></div><p>Now, rebuild the policy file, push it to the UDOO, and trigger a reload. After that, let's start remounting the system, since it is read only:</p><div><pre class="programlisting">
<strong>root@udoo:/ # mount -orw,remount /system</strong>
</pre></div><p>Now perform <code class="literal">chcon</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/ # chcon u:object_r:am_exec:s0 /system/bin/am </strong>
</pre></div><p>Verify the result:</p><div><pre class="programlisting">
<strong>root@udoo:/ # la -laZ /system/bin/am </strong>
<strong>-rwxr-xr-x root shell u:object_r:am_exec:s0 am</strong>
</pre></div><p>Additionally, the <code class="literal">restorecon</code> command will use <code class="literal">file_contexts</code>, and restore that file to what is set in the <code class="literal">file_contexts</code> file, which should be <code class="literal">system_file</code>:</p><div><pre class="programlisting">
<strong>root@udoo:/ # restorecon /system/bin/am </strong>
<strong>root@udoo:/ # la -laZ /system/bin/am </strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 am</strong>
</pre></div><p>As you can see, <code class="literal">restorecon</code> was able to consult <code class="literal">file_contexts</code> and restore the specified context on that object.</p><p>The Android <a id="id257" class="indexterm"/>system's filesystem gets constructed during the build time, and consequently, all its file objects are labeled during that process. We can also change this at build time by changing <code class="literal">file_contexts</code>. With this changed, the system partition rebuilt, and after reflashing the system, we should see the <code class="literal">am</code> file with the <code class="literal">am_exec</code> type. We can test this by amending the <code class="literal">sepolicy</code> file, <code class="literal">file_contexts</code> by adding this line at the end of the <code class="literal">system/bin</code> section:</p><div><pre class="programlisting">/system/bin/am u:object_r:am_exec:s0</pre></div><p>Rebuild the whole system with:</p><div><pre class="programlisting">
<strong>$ make -j8 2&gt;&amp;1 | tee logz</strong>
</pre></div><p>Now flash and reboot, and let's take a look at the <code class="literal">/system/bin/am</code> context as follows:</p><div><pre class="programlisting">
<strong>root@udoo:/ # ls -laZ /system/bin/am </strong>
<strong>-rwxr-xr-x root shell u:object_r:am_exec:s0 am</strong>
</pre></div><p>This shows that the system partition respects the file contexts for build-time labeling, and how we can control these labels.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec38"/>Fixing up /data</h2></div></div></div><p>Additionally <a id="id258" class="indexterm"/>in the audit logs, we have seen<a id="id259" class="indexterm"/> a bunch of unlabeled files, for instance, the following denial:</p><div><pre class="programlisting">type=1400 msg=audit(86559.780:344): avc: denied { append } for pid=2668 comm="UsbDebuggingHan" name="adb_keys" dev=mmcblk0p4 ino=42 scontext=u:r:system_server:s0 tcontext=u:object_r:unlabeled:s0 tclass=file</pre></div><p>We can see that the device is <code class="literal">mmcblk0p4</code>, which mount commands and will tell us what filesystem this is mounted to, in its output:</p><div><pre class="programlisting">
<strong>root@udoo:/ # mount | grep mmcblk0p4</strong>
<strong>/dev/block/mmcblk0p4 /data ext4 rw,seclabel,nosuid,nodev,noatime,nodiratime,errors=panic,user_x0</strong>
</pre></div><p>So why does the <code class="literal">/data</code> filesystem have so many unlabeled files? The reason is that SELinux is meant to be turned on from an empty device, that is, from first boot. Android builds the data directory structures on demand. Thus, all the labels for the <code class="literal">/data</code> are handled by the <code class="literal">file_contexts</code> file since it is <code class="literal">ext4</code>. Also, it is handled by the systems that create the <code class="literal">/data</code> files and directories. These systems have been modified to label the data partition based on the <code class="literal">file_contexts</code> specifications. So this presents two options: wipe <code class="literal">/data</code> and reboot, or <code class="literal">restorecon -R /data</code>.</p><p>Option one is a bit harsh, but if you eject the SD card and remove all the files on the data partition, <code class="literal">partition 4</code>, Android will rebuild and you won't see any more unlabeled issues. However, this is not recommended for deployed devices when you upgrade; you will destroy all of the users' data.</p><p>Option<a id="id260" class="indexterm"/> two is more palatable in deployed <a id="id261" class="indexterm"/>scenarios, but has its limitations. Notably, executing <code class="literal">restorecon -R /data</code> will take a long time and must be done early in boot, right after the mount. However, this is really the only option at this point. Google, however, has done a lot of work in this area, and created a system that intelligently relabels <code class="literal">/data</code> on policy updates. For our use, we will choose a variant of option two, especially after considering how sparsely populated the <code class="literal">/data</code> filesystem is; we really haven't installed or generated a lot of user data yet. With that stated, execute:</p><div><pre class="programlisting">
<strong>root@udoo:/ # restorecon -R /data</strong>
<strong>root@udoo:/ # reboot</strong>
</pre></div><p>We don't have to execute <code class="literal">restorecon</code> early in boot since our system is in permissive mode, and we're not in a deployed scenario. Now, let's pull the <code class="literal">audit.log</code> file and compare it to the already pulled <code class="literal">audit.log</code>:</p><div><pre class="programlisting">
<strong>$ adb pull /data/misc/audit/audit.log audit_data_relabel.log</strong>
<strong>170 KB/s (14645 bytes in 0.084s)</strong>
</pre></div><p>Let's use <code class="literal">grep</code> to count the number of occurrences in each file:</p><div><pre class="programlisting">
<strong>$ grep -c unlabeled audit.log </strong>
<strong>185</strong>
<strong>$ grep -c unlabeled audit_data_relabel.log </strong>
<strong>0</strong>
</pre></div><p>Great, we fixed up all of our unlabeled issues on <code class="literal">/data</code>!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec47"/>A side note on security</h1></div></div></div><p>Note that<a id="id262" class="indexterm"/> even though we are running all these commands and changing all these things, this is not a security vulnerability within SELinux. Being able to change type labels, mounting filesystems, and associating filesystems with a type, all require allow rules. If you look through the audit logs, you'll see a slew of denials; a sample is provided:</p><div><pre class="programlisting">type=1400 msg=audit(90074.080:192): avc: denied { associate } for pid=3211 comm="touch" name="foo" scontext=u:object_r:ramdisk_newfile:s0 tcontext=u:object_r:ramdisk:s0 tclass=filesystem
type=1400 msg=audit(90069.120:187): avc: denied { mount } for pid=3205 comm="mount" name="/" dev=ramfs ino=1992 scontext=u:r:init_shell:s0 tcontext=u:object_r:ramdisk:s0 tclass=filesystem</pre></div><p>If we <a id="id263" class="indexterm"/>were in an enforcing mode, we wouldn't have been able to perform any of the experiments shown here.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we saw how to get files into contexts by relabeling them. We used a variety of techniques to accomplish this task, from toolbox commands such as <code class="literal">chcon</code> and <code class="literal">restorecon</code>, to mount options and dynamic transitions. With these tools, we can ensure that all filesystem objects are labeled correctly. This way, we end up with the right target contexts so that the policies we author are effective. In the next chapter, we will focus on the processes, making sure that they are in the right domain or context.</p></div></body></html>