<html><head></head><body>
        

                            
                    <h1 class="header-title">Using the Touchscreen and Sensors</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Listening for click and long-press events</li>
<li>Recognizing tap and other common gestures</li>
<li>Pinch-to-zoom with multi-touch gestures</li>
<li>Swipe-to-refresh</li>
<li>Listing available sensors—an introduction to the Android Sensor Framework</li>
<li>Reading sensor data—using Android Sensor Framework events</li>
<li>Reading device orientation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>These days, mobile devices are packed with sensors, often including a gyroscope, magnetic, gravity, pressure, and/or temperature sensors, not to mention the touchscreen. This provides many new and exciting options to interact with your user. Through the sensors, you can determine three-dimensional device location and how the device is being used, such as shaking, rotation, tilt, and so on. Even the touchscreen offers many new input methods from just the simple click to gestures and multi-touch.</p>
<p>We'll start this chapter by exploring touchscreen interactions, starting with a simple click and long-press, then move on to detecting common gestures using the <kbd>SimpleOnGestureListener</kbd> class. Next, we'll look at multi-touch using the<br/>
pinch-to-zoom gesture with <kbd>ScaleGestureDetector</kbd>.</p>
<p>This book is meant to offer a quick guide to adding features and functionality to your own applications. As such, the focus is on the code required but it's highly recommended that you become familiar with the design guidelines as well. </p>
<p class="mce-root"/>
<p>Check out the Google Gesture Design Guidelines at <a href="https://www.google.com/design/spec/patterns/gestures.html" target="_blank">https://www.google.com/design/spec/patterns/gestures.html</a>.</p>
<p>In the latter part of this chapter, we'll look at sensor abilities in Android, using the Android Sensor Framework. We'll demonstrate how to obtain a list of all available sensors, plus how to check for a specific sensor. Once we identify a sensor, we'll demonstrate setting up a listener to read the sensor data. Finally, we'll end the chapter with a demonstration of how to determine the device orientation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Listening for click and long-press events</h1>
                
            
            
                
<p>Almost every application needs to recognize and respond to basic events such as clicks and long-presses. It's so basic, in most recipes we use the XML <kbd>onClick</kbd> attribute, but more advanced listeners require to be set up through code.</p>
<p>Android provides an Event Listener interface for receiving a single notification when certain actions occur, as shown in the following list:</p>
<ul>
<li><kbd>onClick()</kbd>: It's called when a View is pressed</li>
<li><kbd>onLongClick()</kbd>: It's called when the View is long-pressed</li>
<li><kbd>onFocusChange()</kbd>: It's called when the user navigates to or from the View</li>
<li><kbd>onKey()</kbd>: It's called when a hardware key is pressed or released</li>
<li><kbd>onTouch()</kbd>: It's called when a touch event occurs</li>
</ul>
<p>This recipe will demonstrate responding to a click event, as well as a long-press event.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>PressEvents</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity on the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Setting up to receive basic View events is very simple. First, we will create a View; we'll use a button for our example, then set the Event Listener in the Activity's <kbd>onCreate()</kbd> method. Following are the steps:</p>
<ol>
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>TextView</kbd> with the following <kbd>Button</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;Button<br/>    android:id="@+id/button"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Button"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="2">
<li>Now open <kbd>MainActivy.java</kbd> and add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">Button button = findViewById(R.id.button);<br/>button.setOnClickListener(new View.OnClickListener() {<br/>    @Override<br/>    public void onClick(View v) {<br/>        Toast.makeText(MainActivity.this, "Click", Toast.LENGTH_SHORT).show();<br/>    }<br/>});<br/>button.setOnLongClickListener(new View.OnLongClickListener() {<br/>    @Override<br/>    public boolean onLongClick(View v) {<br/>        Toast.makeText(MainActivity.this, "Long Press", Toast.LENGTH_SHORT).show();<br/>        return true;<br/>    }<br/>});</pre>
<ol start="3">
<li>Run the application on a device or emulator and try a regular click and long-press.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In most examples used in this book, we set up the <kbd>onClick</kbd> listener in XML using the following attribute:</p>
<pre>android:onClick="" </pre>
<p>You may notice the XML <kbd>onClick()</kbd> method callback requires the same method signature as the <kbd>setOnClickListener</kbd> .<kbd>onClick()</kbd> callback:</p>
<pre>public void onClick(View v) {} </pre>
<p>That's because Android automatically sets up the callback for us when we use the XML <kbd>onClick</kbd> attribute. This example also demonstrates that we can have multiple listeners on a single View.</p>
<p>The last point to note is that the <kbd>onLongClick()</kbd> method returns a Boolean, as do most of the other event listeners. <kbd>true</kbd> is returned to indicate the event has been handled.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Although a button is typically used to indicate where a user should press, we could have used both <kbd>setOnClickListener()</kbd> and <kbd>setOnLongClickListener()</kbd> with any View, or even a <kbd>TextView</kbd>.</p>
<p>As mentioned in the introduction, there are other Event Listeners. You can use Android Studio's auto-complete feature to bring up a list of available listeners by typing the following:</p>
<pre>button.setOn </pre>
<p>As you start typing, you'll see a list of available choices with Android Studio's auto-complete list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Recognizing tap and other common gestures</h1>
                
            
            
                
<p>Unlike the Event Listeners described in the previous recipe, gestures require a two-step process:</p>
<ol>
<li>Gather movement data</li>
<li>Analyze the data to determine whether it matches a known gesture</li>
</ol>
<p>Step 1 begins when the user touches the screen, which fires the <kbd>onTouchEvent()</kbd> callback with the movement data sent in a <kbd>MotionEvent</kbd> object. Fortunately, Android makes step 2, analyzing the data, easier with the <kbd>GestureDetector</kbd> class, which detects the following gestures:</p>
<ul>
<li><kbd>onTouchEvent()</kbd></li>
<li><kbd>onDown()</kbd></li>
<li><kbd>onFling()</kbd></li>
<li><kbd>onLongPress()</kbd></li>
<li><kbd>onScroll()</kbd></li>
<li><kbd>onShowPress()</kbd></li>
<li><kbd>onDoubleTap()</kbd></li>
<li><kbd>onDoubleTapEvent()</kbd></li>
<li><kbd>onSingleTapConfirmed()</kbd></li>
</ul>
<p>This recipe will demonstrate using <kbd>GestureDetector.SimpleOnGestureListener </kbd>to recognize the touch and double tap gestures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>CommonGestureDetector</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will be using the activity itself to detect gestures, so we don't need to add any Views to the layout. Open <kbd>MainActivity.java</kbd> and perform the following steps:</p>
<ol>
<li>Add the following global variable:</li>
</ol>
<pre style="padding-left: 60px">private GestureDetectorCompat mGestureDetector; </pre>
<ol start="2">
<li>Add the following <kbd>GestureListener</kbd> class within the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private class GestureListener extends GestureDetector.SimpleOnGestureListener {<br/>    @Override<br/>    public boolean onSingleTapConfirmed(MotionEvent e) {<br/>        Toast.makeText(MainActivity.this, "onSingleTapConfirmed", Toast.LENGTH_SHORT).show();<br/>        return super.onSingleTapConfirmed(e);<br/>    }<br/>    @Override<br/>    public boolean onDoubleTap(MotionEvent e) {<br/>        Toast.makeText(MainActivity.this, "onDoubleTap", Toast.LENGTH_SHORT).show();<br/>        return super.onDoubleTap(e);<br/>    }<br/>}</pre>
<ol start="3">
<li>Add the following <kbd>onTouchEvent()</kbd> method to the <kbd>MainActivity</kbd> class to handle touch event notifications:</li>
</ol>
<pre style="padding-left: 60px">public boolean onTouchEvent(MotionEvent event) {<br/>    mGestureDetector.onTouchEvent(event);<br/>    return super.onTouchEvent(event);<br/>}</pre>
<ol start="4">
<li>Lastly, add the following line of code to <kbd>onCreate()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">mGestureDetector = new GestureDetectorCompat(this, new  GestureListener());</pre>
<ol start="5">
<li>Run this application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We're using <kbd>GestureDetectorCompat</kbd>, which is from the support library that allows gesture support on devices running Android 1.6 and later.</p>
<p>As mentioned in the recipe introduction, detecting gestures is a two-step process. To gather movement or gesture data, we start tracking movement with the touch event. Every time the <kbd>onTouchEvent()</kbd> is called, we send that data to the <kbd>GestureDetector</kbd>. The <kbd>GestureDetector</kbd> handles the second step, analyzing the data. Once a gesture has been detected, the appropriate callback is made. Our example handles both single and double tap gestures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Your application can easily add support for the remaining gestures detected by the <kbd>GestureDetector</kbd> simply by overriding the appropriate callback.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>See the next recipe, <em>Pinch-to-zoom with multi-touch gestures</em>, for multi-touch gestures</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Pinch-to-zoom with multi-touch gestures</h1>
                
            
            
                
<p>The previous recipe used <kbd>SimpleOnGestureListener</kbd> to provide detection of simple, one-finger gestures. In this recipe, we'll use the <kbd>SimpleOnScaleGestureListener</kbd> class to detect the common multi-touch gesture "pinch to zoom".</p>
<p>Here are two screenshots from the application we'll create in this recipe. The first shows the icon zoomed out:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0bed65a1-eeca-4669-9847-c0ef32116f29.png" style="width:15.42em;height:27.33em;"/></p>
<p>This second screenshot shows the icon zoomed in:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/38cd3bce-80d7-4e42-8bb5-572bb44fe95f.png" style="width:13.08em;height:23.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>MultiTouchZoom</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To provide a visual indication of pinch-to-zoom, we'll use an <kbd>ImageView</kbd> with the application icon. Open <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing <kbd>TextView</kbd> with the following <kbd>ImageView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.AppCompatImageView<br/>    android:id="@+id/imageView"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:src="img/ic_launcher"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="2">
<li>Now, open <kbd>MainActivity.java</kbd> and add the following global variables to the class:</li>
</ol>
<pre style="padding-left: 60px">private ScaleGestureDetector mScaleGestureDetector;<br/>private float mScaleFactor = 1.0f;<br/>private AppCompatImageView mImageView;</pre>
<ol start="3">
<li>Add the following <kbd>onTouchEvent()</kbd> implementation to the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">public boolean onTouchEvent(MotionEvent motionEvent) { 
    mScaleGestureDetector.onTouchEvent(motionEvent); 
    return true; 
} </pre>
<ol start="4">
<li>Add the following <kbd>ScaleListener</kbd> class to the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {<br/>    @Override<br/>    public boolean onScale(ScaleGestureDetector scaleGestureDetector) {<br/>        mScaleFactor *= scaleGestureDetector.getScaleFactor();<br/>        mScaleFactor = Math.max(0.1f, Math.min(mScaleFactor, 10.0f));<br/>        mImageView.setScaleX(mScaleFactor);<br/>        mImageView.setScaleY(mScaleFactor);<br/>        return true;<br/>    }<br/>} </pre>
<ol start="5">
<li>Add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">mImageView=findViewById(R.id.imageView);<br/>mScaleGestureDetector = new ScaleGestureDetector(this, new ScaleListener());</pre>
<ol start="6">
<li>To experiment with the pinch-to-zoom functionality, run the application on a device with a touchscreen.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>ScaleGestureDetector</kbd> does all the work by analyzing gesture data and reporting the final scale factor through the <kbd>onScale()</kbd> callback. We get the actual scale factor by calling <kbd>getScaleFactor()</kbd> on <kbd>ScaleGestureDetector</kbd>.</p>
<p class="mce-root"/>
<p>We use an <kbd>ImageView</kbd> with the application icon to provide a visual representation of the scaling by setting the <kbd>ImageView</kbd> scale, using the scale factor returned from <kbd>ScaleGestureDetector</kbd>. We use the following code to prevent the scaling from becoming too large or too small:</p>
<pre>mScaleFactor = Math.max(0.1f, Math.min(mScaleFactor, 10.0f)); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Swipe-to-Refresh</h1>
                
            
            
                
<p>Pulling down a list to indicate a manual refresh is known as the Swipe-to-Refresh gesture. It's such a common feature that this functionality has been encapsulated in a single widget called <kbd>SwipeRefreshLayout</kbd>.</p>
<p>This recipe will add Swipe-to-Refresh functionality with a <kbd>ListView</kbd>. The following screenshot shows the refresh in action:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a8f6f355-f15d-4a23-9ac6-ccc38021df31.png" style="width:17.58em;height:33.67em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>SwipeToRefresh</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity on the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we need to add the <kbd>SwipeRefreshLayout</kbd> widget and <kbd>ListView</kbd> to the activity layout, then we will implement the refresh listener in the Java code. Here are the detailed steps:</p>
<ol>
<li>Open <kbd>activity_main.xml</kbd> and replace the existing constraint layout with the following:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&gt;<br/>    &lt;android.support.v4.widget.SwipeRefreshLayout<br/>        android:id="@+id/swipeRefresh"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"&gt;<br/>        &lt;ListView<br/>            android:id="@android:id/list"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="match_parent" /&gt;<br/>    &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;<br/>&lt;/RelativeLayout&gt;</pre>
<ol start="2">
<li>Now open <kbd>MainActivity.java</kbd> and add the following global variables to the class:</li>
</ol>
<pre style="padding-left: 60px">SwipeRefreshLayout mSwipeRefreshLayout;<br/>ListView mListView;<br/>List mArrayList = new ArrayList&lt;&gt;();<br/>private int mRefreshCount=0;</pre>
<ol start="3">
<li>Add the following method to the <kbd>MainActivity</kbd> class to handle the refresh:</li>
</ol>
<pre style="padding-left: 60px">private void refreshList() {<br/>    mRefreshCount++;<br/>    mArrayList.add("Refresh: " + mRefreshCount);<br/>    ListAdapter countryAdapter = new ArrayAdapter&lt;String&gt;(this, <br/>            android.R.layout.simple_list_item_1, mArrayList);<br/>    mListView.setAdapter(countryAdapter);<br/>    mSwipeRefreshLayout.setRefreshing(false);<br/>}</pre>
<ol start="4">
<li>Add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">mSwipeRefreshLayout = findViewById(R.id.swipeRefresh);<br/>mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {<br/>    @Override<br/>    public void onRefresh() {<br/>        refreshList();<br/>    }<br/>});<br/>mListView = findViewById(android.R.id.list);<br/>final String[] countries = new String[]{"China", "France", "Germany", "India",<br/>        "Russia", "United Kingdom", "United States"};<br/>mArrayList = new ArrayList&lt;&gt;(Arrays.asList(countries));<br/>ListAdapter countryAdapter = new ArrayAdapter&lt;String&gt;(this,<br/>        android.R.layout.simple_list_item_1, mArrayList);<br/>mListView.setAdapter(countryAdapter);</pre>
<ol start="5">
<li>Run the application on a device or an emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Most of the code for this recipe simulates a refresh by adding items to the <kbd>ListView</kbd> each time the refresh method is called. The main steps for implementing Swipe-to-Refresh include:</p>
<ol>
<li>Add the <kbd>SwipeRefreshLayout</kbd> widget</li>
<li>Include the <kbd>ListView</kbd> within the <kbd>SwipeRefreshLayout</kbd></li>
<li>Add the <kbd>OnRefreshListener</kbd> to call your refresh method</li>
<li>Call <kbd>setRefreshing(false)</kbd> after completing your update</li>
</ol>
<p>That's it. The widget makes adding Swipe-to-Refresh very easy!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Although the Swipe-to-Refresh gesture is a common feature these days, it's still good practice to include a menu item (especially for accessibility reasons). Following is a snippet of XML for the menu layout:</p>
<pre>&lt;menu  &gt; 
    &lt;item 
        android:id="@+id/menu_refresh" 
        android:showAsAction="never" 
        android:title="@string/menu_refresh"/&gt; 
&lt;/menu&gt; </pre>
<p>Call your refresh method in the <kbd>onOptionsItemSelected()</kbd> callback. When performing a refresh from code, such as from the menu item event, you want to notify <kbd>SwipeRefreshLayout</kbd> of the refresh so it can update the UI. Do this with the following code:</p>
<pre>SwipeRefreshLayout.setRefreshing(true); </pre>
<p>This tells the <kbd>SwipeRefreshLayout</kbd> that a refresh is starting so it can display the in-progress indicator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing available sensors – an introduction to the Android Sensor Framework</h1>
                
            
            
                
<p>Android includes support for hardware sensors using the Android Sensor Framework. The framework includes the following classes and interfaces:</p>
<ul>
<li><kbd>SensorManager</kbd></li>
<li><kbd>Sensor</kbd></li>
<li><kbd>SensorEventListener</kbd></li>
<li><kbd>SensorEvent</kbd></li>
</ul>
<p>Most Android devices include hardware sensors, but they vary greatly between different manufacturers and models. If your application utilizes sensors, you have two choices:</p>
<ul>
<li>Specify the sensor in the Android Manifest</li>
<li>Check for the sensor at runtime</li>
</ul>
<p>To specify your application uses a sensor, include the <kbd>&lt;uses-feature&gt;</kbd> declaration in the Android Manifest. Here is an example requiring a compass to be available:</p>
<pre>&lt;uses-feature android:name="android.hardware.sensor.compass" android:required="true"/&gt;</pre>
<p>If your application utilizes the compass, but does not require it to function, you should set <kbd>android:required="false"</kbd> instead; otherwise your application will not be available to install from Google Play.</p>
<p>Sensors are grouped into the following three categories:</p>
<ul>
<li>Motion sensors: Measure acceleration and rotational forces along three axes</li>
<li>Environmental sensors: Measure the local environment, such as ambient air temperature and pressure, humidity, and illumination</li>
<li>Position sensors: Measure the physical position of the device using position and a magnometer</li>
</ul>
<p>The Android SDK provides support for the following sensor types:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<thead>
<tr>
<td>
<p>Sensor</p>
</td>
<td>
<p>Detects</p>
</td>
<td>
<p>Use</p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><kbd>TYPE_ACCELEROMETER</kbd></p>
</td>
<td>
<p>Motion detection including gravity</p>
</td>
<td>
<p>Used to determine shake, tilt, and so on</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_AMBIENT_TEMPERATURE</kbd></p>
</td>
<td>
<p>Measures ambient room temperature</p>
</td>
<td>
<p>Used for determining local temperature</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_GRAVITY</kbd></p>
</td>
<td>
<p>Measures the force of gravity on all three axes</p>
</td>
<td>
<p>Used for motion detection</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_GYROSCOPE</kbd></p>
</td>
<td>
<p>Measures rotation on all three axes</p>
</td>
<td>
<p>Used to determine turn, spin, and so on</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_LIGHT</kbd></p>
</td>
<td>
<p>Measures light level</p>
</td>
<td>
<p>Used for setting screen brightness</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_LINEAR_ACCELERATION</kbd></p>
</td>
<td>
<p>Motion detection excluding gravity</p>
</td>
<td>
<p>Used to determine acceleration</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_MAGNETIC_FIELD</kbd></p>
</td>
<td>
<p>Measures geomagnetic field</p>
</td>
<td>
<p>Used to create a compass or determine bearing</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_PRESSURE</kbd></p>
</td>
<td>
<p>Measures air pressure</p>
</td>
<td>
<p>Used for barometer</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_PROXIMITY</kbd></p>
</td>
<td>
<p>Measures objects relative to the screen</p>
</td>
<td>
<p>Used to determine whether the device is being held against the ear during a phone call</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_RELATIVE_HUMIDITY</kbd></p>
</td>
<td>
<p>Measures relative humidity</p>
</td>
<td>
<p>Used to determine dew point and humidity</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TYPE_ROTATION_VECTOR</kbd></p>
</td>
<td>
<p>Measures device orientation</p>
</td>
<td>
<p>Used to detect motion and rotation</p>
</td>
</tr>
</tbody>
</table>
<div><p> </p>
<p>There are two additional sensors, <kbd>TYPE_ORIENTATION</kbd> and <kbd>TYPE_TEMPERATURE</kbd>, which have been deprecated as they have been replaced by newer sensors.</p>
<p>This recipe will demonstrate retrieving a list of available sensors. Here is a screenshot from the Pixel 2 emulator:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7008410a-903b-497c-80b4-101c14b46060.png" style="width:19.25em;height:38.50em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ListDeviceSensors</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we'll query the list of sensors available, then display the results in a <kbd>ListView</kbd>. Here are the detailed steps:</p>
<ol>
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>TextView</kbd> with the following:</li>
</ol>
<pre style="padding-left: 60px">&lt;ListView<br/>    android:id="@+id/list"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="2">
<li>Next, open <kbd>ActivityMain.java</kbd> and add the following code to the existing <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">ListView listView = findViewById(R.id.list);<br/>List sensorList = new ArrayList&lt;String&gt;();<br/><br/>List&lt;Sensor&gt; sensors = ((SensorManager) getSystemService(Context.SENSOR_SERVICE))<br/>        .getSensorList(Sensor.TYPE_ALL);<br/>for (Sensor sensor : sensors ) {<br/>    sensorList.add(sensor.getName());<br/>}<br/>ListAdapter sensorAdapter = new ArrayAdapter&lt;String&gt;(this,<br/>        android.R.layout.simple_list_item_1, sensorList);<br/>listView.setAdapter(sensorAdapter);</pre>
<ol start="3">
<li>Run the program on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The following line of code is responsible for getting the list of available sensors; the rest of the code populates the <kbd>ListView</kbd>:</p>
<pre>List&lt;Sensor&gt; sensors = ((SensorManager) getSystemService(<br/>     Context.SENSOR_SERVICE)).getSensorList(Sensor.TYPE_ALL);</pre>
<p>Notice that we get back a list of <kbd>Sensor</kbd> objects. We only get the sensor name to display in the <kbd>ListView</kbd>, but there are other properties available as well. See the link provided in the <em>See also</em> section for a complete list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It's important to note a device can have multiple sensors of the same type. If you are looking for a specific sensor, you can pass in one of the constants from the table shown in the introduction. In this case, if you wanted to see all the accelerometer sensors available, you could use this call:</p>
<pre>List&lt;Sensor&gt; sensors = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER); </pre>
<p>If you're not looking for a list of sensors, but need to work with a specific sensor, you can check for a default sensor using this code:</p>
<pre>SensorManager sensorManager =  ((SensorManager) getSystemService(Context.SENSOR_SERVICE));<br/>if (sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) != null){<br/>    //Sensor is available - do something here <br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The Android Developer Sensor website at <a href="http://developer.android.com/reference/android/hardware/Sensor.html">http://developer.android.com/reference/android/hardware/Sensor.html</a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading sensor data – using Android Sensor Framework events</h1>
                
            
            
                
<p>The previous recipe, <em>Listing available sensors – an introduction to the Android Sensor Framework</em>, provided an introduction to the Android Sensor Framework. Now, we'll look at reading sensor data using <kbd>SensorEventListener</kbd>. The <kbd>SensorEventListener</kbd> interface only has two callbacks:</p>
<ul>
<li><kbd>onSensorChanged()</kbd></li>
<li><kbd>onAccuracyChanged()</kbd></li>
</ul>
<p>When the sensor has new data to report, it calls <kbd>onSensorChanged()</kbd> with a <kbd>SensorEvent</kbd> object. This recipe will demonstrate reading a light sensor, but since all the sensors use the same framework, it's very easy to adapt this example to any of the other sensors. (See the list of sensor types available in the previous recipe's introduction.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ReadingSensorData</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll add a <kbd>TextView</kbd> to the activity layout to display sensor data, then we'll add the <kbd>SensorEventListener</kbd> to the Java code. We'll use the <kbd>onResume()</kbd> and <kbd>onPause()</kbd> events to start and stop our Event Listener. To get started, open <kbd>activity_main.xml </kbd>and follow these steps:</p>
<ol>
<li>Modify the existing <kbd>TextView</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextView<br/>    android:id="@+id/textView"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="0"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="2">
<li>Now, open <kbd>MainActivity.java</kbd> and add the following global variable declarations:</li>
</ol>
<pre style="padding-left: 60px">private SensorManager mSensorManager; <br/>private Sensor mSensor; <br/>private TextView mTextView; </pre>
<ol start="3">
<li>Implement the <kbd>SensorListener</kbd> class in the <kbd>MainActivity</kbd> class as follows:</li>
</ol>
<pre style="padding-left: 60px">private SensorEventListener mSensorListener = new SensorEventListener() {<br/>    @Override<br/>    public void onSensorChanged(SensorEvent event) {<br/>        mTextView.setText(String.valueOf(event.values[0]));<br/>    }<br/>    @Override<br/>    public void onAccuracyChanged(Sensor sensor, int accuracy) {<br/>        //Nothing to do<br/>    }<br/>};</pre>
<ol start="4">
<li>We'll register and unregister sensor events in <kbd>onResume()</kbd> and <kbd>onPause()</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onResume() {<br/>    super.onResume();<br/>    mSensorManager.registerListener(mSensorListener, mSensor, SensorManager.SENSOR_DELAY_NORMAL);<br/>}<br/><br/>@Override<br/>protected void onPause() {<br/>    super.onPause();<br/>    mSensorManager.unregisterListener(mSensorListener);<br/>}</pre>
<ol start="5">
<li>Add the following code to <kbd>onCreate()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">mTextView = (TextView)findViewById(R.id.textView);<br/>mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);<br/>mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);</pre>
<ol start="6">
<li>You can now run the application on a physical device to see the raw data from the light sensor.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Using the Android Sensor Framework starts with obtaining the sensor, which we do in <kbd>onCreate()</kbd>. Here, we call <kbd>getDefaultSensor(),</kbd> requesting <kbd>TYPE_LIGHT</kbd>. We register the listener in <kbd>onResume()</kbd> and unregister it again in <kbd>onPause()</kbd> to reduce battery consumption. We pass in our <kbd>mSensorListener</kbd> object when we call <kbd>registerListener()</kbd>.</p>
<p>In our case, we are only looking for sensor data, which is sent in the <kbd>onSensorChanged()</kbd> callback. When the sensor changes, we update the <kbd>TextView</kbd> with the sensor data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Now that you've worked with one sensor, you know how to work with all sensors, as they all use the same framework. Of course, what you do with the data will vary greatly, depending on the type of data you're reading. Environment sensors, as shown here, return a single value, but position and motion sensors can also return additional elements, indicated as follows.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Environment sensors</h1>
                
            
            
                
<p>Android supports the following four environment sensors:</p>
<ul>
<li>Humidity</li>
<li>Light</li>
<li>Pressure</li>
<li>Temperature</li>
</ul>
<p>Environment sensors are generally easier to work with since the data returned is in a single element and doesn't usually require calibration or filtering. We used a light sensor (<kbd>Sensor.TYPE_LIGHT</kbd>) for this recipe since most devices include a light sensor to control screen brightness.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Position sensors</h1>
                
            
            
                
<p>Position sensors include:</p>
<ul>
<li>Geomagnetic Field</li>
<li>Proximity</li>
</ul>
<p>The following sensor types use the Geomagnetic field:</p>
<ul>
<li><kbd>TYPE_GAME_ROTATION_VECTOR</kbd></li>
<li><kbd>TYPE_GEOMAGNETIC_ROTATION_VECTOR</kbd></li>
<li><kbd>TYPE_MAGNETIC_FIELD</kbd></li>
<li><kbd>TYPE_MAGNETIC_FIELD_UNCALIBRATED</kbd></li>
</ul>
<p>These sensors return three values in the <kbd>onSensorChanged()</kbd> event, except for <kbd>TYPE_MAGNETIC_FIELD_UNCALIBRATED</kbd>, which sends six values.</p>
<p>A third sensor, the Orientation sensor, has been deprecated, and you are now recommended to use <kbd>getRotation()</kbd> and <kbd>getRotationMatrix()</kbd> to calculate orientation changes. (For device orientation, such as Portrait and Landscape modes, see the next recipe: <em>Reading device orientation</em>.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Motion sensors</h1>
                
            
            
                
<p>Motion sensors include the following:</p>
<ul>
<li>Accelerometer</li>
<li>Gyroscope</li>
<li>Gravity</li>
<li>Linear acceleration</li>
<li>Rotation vector</li>
</ul>
<p>These include the following sensor types:</p>
<ul>
<li><kbd>TYPE_ACCELEROMETE</kbd></li>
<li><kbd>TYPE_GRAVITY</kbd></li>
<li><kbd>TYPE_GYROSCOPE</kbd></li>
<li><kbd>TYPE_GYROSCOPE_UNCALIBRATED</kbd></li>
<li><kbd>TYPE_LINEAR_ACCELERATION</kbd></li>
<li><kbd>TYPE_ROTATION_VECTOR</kbd></li>
<li><kbd>TYPE_SIGNIFICANT_MOTION</kbd></li>
<li><kbd>TYPE_STEP_COUNTER</kbd></li>
<li><kbd>TYPE_STEP_DETECTOR</kbd></li>
</ul>
<p>These sensors also include three data elements, with the exception of the last three. <kbd>TYPE_SIGNIFICANT_MOTION</kbd> and <kbd>TYPE_STEP_DETECTOR</kbd> indicate an event, while <kbd>TYPE_STEP_COUNTER</kbd> returns the number of steps since last boot (while the sensor was active).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <em>Listing available sensors - an introduction to the Android Sensor Framework</em> recipe</li>
<li>The <em>Creating a Compass using sensor data and RotateAnimation</em> recipe in <a href="a9bb5495-da76-415c-b83e-c75d0b8ce4fd.xhtml" target="_blank">Chapter 10</a>, <em>Graphics and Animation</em></li>
<li>For device orientation, see the next recipe: <em>Reading device orientation</em></li>
<li>See the GPS and Location recipe in <a href="01fd07ae-9274-4fb2-a536-bc3ed6ec088c.xhtml" target="_blank">Chapter 14</a>, <em>Location and Using Geofencing</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading device orientation</h1>
                
            
            
                
<p>Although the Android framework will automatically load new resources (such as the layout) upon orientation changes, there are times when you may wish to disable this behavior. If you wish to be notified of an orientation change instead of Android handling it automatically, add the following attribute to the Activity in the Android Manifest:</p>
<pre>android:configChanges="keyboardHidden|orientation|screenSize" </pre>
<p>When any of the following configuration changes occur, the system will notify you through the <kbd>onConfigurationChanged()</kbd> method instead of handling it automatically:</p>
<ul>
<li><kbd>keyboardHidden</kbd></li>
<li><kbd>orientation</kbd></li>
<li><kbd>screenSize</kbd></li>
</ul>
<p>The <kbd>onConfigurationChanged()</kbd> signature is as follows:</p>
<pre>onConfigurationChanged (Configuration newConfig) </pre>
<p>You'll find the new orientation in <kbd>newConfig.orientation</kbd>.</p>
<p class="mce-root"/>
<p>Disabling the automatic configuration change (which causes the layout to be reloaded and state information to be reset) should not be used as a replacement for properly saving state information. Your application can still be interrupted or stopped altogether at any time and killed by the system. (See <em>Saving an activity's state</em> in <a href="ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml" target="_blank">Chapter 1</a>, <em>Activities</em>, for how to properly save a state.)</p>
<p>This recipe will demonstrate how to determine the current device orientation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>GetDeviceOrientation</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity when prompted for the Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll add a button to the layout to check the orientation on demand. Start by opening <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing <kbd>TextView</kbd> with the following <kbd>Button</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;Button<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Check Orientation"<br/>    android:id="@+id/button"<br/>    android:onClick="checkOrientation"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="2">
<li>Add the following method to handle the button click:</li>
</ol>
<pre style="padding-left: 60px">public void checkOrientation(View view){<br/>    int orientation = getResources()<br/>            .getConfiguration().orientation;<br/>    switch (orientation) {<br/>        case Configuration.ORIENTATION_LANDSCAPE:<br/>            Toast.makeText(MainActivity.this, "ORIENTATION_LANDSCAPE", <br/>                    Toast.LENGTH_SHORT).show();<br/>            break;<br/>        case Configuration.ORIENTATION_PORTRAIT:<br/>            Toast.makeText(MainActivity.this, "ORIENTATION_PORTRAIT", <br/>                    Toast.LENGTH_SHORT).show();<br/>            break;<br/>        case Configuration.ORIENTATION_UNDEFINED:<br/>            Toast.makeText(MainActivity.this, "ORIENTATION_UNDEFINED", <br/>                    Toast.LENGTH_SHORT).show();<br/>            break;<br/>    }<br/>}</pre>
<ol start="3">
<li>Run the application on a device or emulator.</li>
</ol>
<p>Use <em>Ctrl</em> + <em>F11</em> to rotate the emulator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>All we need to do to get the current orientation is call this line of code:</p>
<pre>getResources().getConfiguration().orientation </pre>
<p>The orientation is returned as an <kbd>int</kbd>, which we compare to one of three possible values, as demonstrated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Another scenario where you may need to know the current orientation is when working with camera data, pictures, and/or videos. In this case, you need to get the device orientation as and when required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting current device rotation</h1>
                
            
            
                
<p>Often, the image may be rotated according to the device orientation or to compensate for the current orientation. In this scenario, there's another option available to get the rotation:</p>
<pre>int rotation = getWindowManager().getDefaultDisplay().getRotation();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the preceding line of code, <kbd>rotation</kbd> will be one of the following values:</p>
<ul>
<li><kbd>Surface.ROTATION_0</kbd></li>
<li><kbd>Surface.ROTATION_90</kbd></li>
<li><kbd>Surface.ROTATION_180</kbd></li>
<li><kbd>Surface.ROTATION_270</kbd></li>
</ul>
<p>The rotation value will be from its normal orientation. For example, when using a table with a normal orientation of landscape, if a picture is taken in portrait orientation the value will be <kbd>ROTATION_90</kbd> or <kbd>ROTATION_270</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <em>Saving an activity's state</em> recipe in <a href="ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml" target="_blank">Chapter 1</a>, <em>Activities</em></li>
<li>Refer to the following developer link for more information on the Configuration class: <a href="http://developer.android.com/reference/android/content/res/Configuration.html">http://developer.android.com/reference/android/content/res/Configuration.html</a></li>
<li>Refer to the following link for more information on the <kbd>getRotation()</kbd> method: <a href="http://developer.android.com/reference/android/view/Display.html#getRotation()">http://developer.android.com/reference/android/view/Display.html#getRotation()</a></li>
</ul>


            

            
        
    </body></html>