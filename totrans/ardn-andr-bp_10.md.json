["```java\n// Sensor and pins variables\nint pulsePin = 0;\nint blinkPin = 13;\n\n// Pulse rate variable\nvolatile int BPM;    \n\n// Raw signal\nvolatile int Signal;\n\n// Interval between beats\nvolatile int IBI = 600; // Default Inter Beats Interval\n\n// Becomes true when the pulse is high\nvolatile boolean Pulse = false;\n\n// Becomes true when Arduino finds a pulse (QS stands for Quantified Self here)\nvolatile boolean QS = false;\n```", "```java\n// Start Serial\nSerial.begin(115200);\n\n// Sets up to read Pulse Sensor signal every 2mS\ninterruptSetup();\n```", "```java\n  // If heart beat is found\n  if (QS == true) {\n\n    // Print heart rate      \n    Serial.print(\"Heart rate: \");            \n    Serial.println(BPM);\n\n    // Reset the Quantified Self flag for next time      \n    QS = false;                       \n   }\n\n  // Wait 20 ms\n  delay(20);\n}\n```", "```java\n#include <SPI.h>\n#include \"Adafruit_BLE_UART.h\"\n#include <aREST.h>\n```", "```java\n#define ADAFRUITBLE_REQ 10\n#define ADAFRUITBLE_RDY 2     // This should be an interrupt pin, on Uno thats #2 or #3\n#define ADAFRUITBLE_RST 9\n```", "```java\naREST rest = aREST();\n\n// BLE instance\nAdafruit_BLE_UART BTLEserial = Adafruit_BLE_UART(ADAFRUITBLE_REQ, ADAFRUITBLE_RDY, ADAFRUITBLE_RST);\n```", "```java\nint bpm = 0;\n```", "```java\nBTLEserial.begin();\n```", "```java\nrest.set_id(\"1\");\nrest.set_name(\"pulse_sensor\");\n```", "```java\nrest.variable(\"bpm\",&bpm);\n```", "```java\nbpm = BPM;\n```", "```java\n// Tell the nRF8001 to do whatever it should be working on.\nBTLEserial.pollACI();\n\n// Ask what is our current status\naci_evt_opcode_t status = BTLEserial.getState();\n\n// Handle REST calls\nif (status == ACI_EVT_CONNECTED) {\n    rest.handle(BTLEserial);\n  }\n}\n```", "```java\n    <uses-permission android:name=\"android.permission.BLUETOOTH\"/>\n    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/>\n```", "```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<LinearLayout\n\n    android:orientation=\"vertical\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\">\n\n    <LinearLayout\n        android:id=\"@+id/rest\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"250dip\"\n        android:orientation=\"vertical\"\n        android:weightSum=\"1\">\n\n        <TextView\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:textAppearance=\"?android:attr/textAppearanceLarge\"\n            android:id=\"@+id/pulseValueView\"\n            android:layout_gravity=\"center_horizontal\"\n            android:textSize=\"150dp\"\n            android:gravity=\"center\"\n            android:text=\"120\"/>\n    </LinearLayout>\n\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Refresh Connection\"\n        android:id=\"@+id/refreshBtn\"\n        android:layout_gravity=\"center_horizontal\" />\n\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Get Pulse Rate\"\n        android:id=\"@+id/heartRateBtn\"\n        android:layout_gravity=\"center_horizontal\" />\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:textAppearance=\"?android:attr/textAppearanceLarge\"\n        android:text=\"Connection Status\"\n        android:id=\"@+id/connectionStsView\"\n        android:layout_gravity=\"center_horizontal\" />\n</LinearLayout>\n```", "```java\n    //Logging Variables\n    private final String LOG_TAG = PulseActivity.class.getSimpleName();\n\n    //User Interface Variables\n    Button getPulseRate;\n    Button refreshButton;\n    TextView pulseRateView;\n    TextView connectionStsView;\n\n    //Data Output\n    private String output;\n\n    // UUIDs for UAT service and associated characteristics.\n    public static UUID UART_UUID = UUID.fromString(\"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\");\n    public static UUID TX_UUID = UUID.fromString(\"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\");\n    public static UUID RX_UUID = UUID.fromString(\"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\");\n\n    // UUID for the BTLE client characteristic which is necessary for notifications.\n    public static UUID CLIENT_UUID = UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\");\n\n    // BTLE stateta\n    private BluetoothAdapter adapter;\n    private BluetoothGatt gatt;\n    private BluetoothGattCharacteristic tx;\n    private BluetoothGattCharacteristic rx;\n\n    private boolean areServicesAccessible = false;\n```", "```java\n        //Connect U.I Elements\n        getPulseRate = (Button) findViewById(R.id.heartRateBtn);\n        pulseRateView = (TextView) findViewById(R.id.pulseValueView);\n        connectionStsView = (TextView) findViewById(R.id.connectionStsView);\n        refreshButton = (Button) findViewById(R.id.refreshBtn);\n\n        getPulseRate.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                String setOutputMessage = \"/bpm /\";\n                tx.setValue(setOutputMessage.getBytes(Charset.forName(\"UTF-8\")));\n                if (gatt.writeCharacteristic(tx)) {\n                    writeConnectionData(\"Sent: \" + setOutputMessage);\n                } else {\n                    writeConnectionData(\"Couldn't write TX characteristic!\");\n                }\n            }\n        });\n\n        refreshButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                restartScan();\n            }\n        });\n    }\n```", "```java\n    private void writeConnectionData(final CharSequence text) {\n        Log.e(LOG_TAG, text.toString());\n        connectionStsView.setText(text.toString());\n    }\n\n    private void writeSensorData(final CharSequence text) {\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Log.e(LOG_TAG,text.toString());\n                output=text.toString().trim();\n\n                if (output.length() > 0 && output.length() <=3) {\n                    pulseRateView.setText(output);\n                }\n                else {\n                    return;\n                }\n            }\n        });\n    }\n```", "```java\n    // BTLE device scanning bluetoothGattCallback.\n\n    // Main BTLE device bluetoothGattCallback where much of the logic occurs.\n    private BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() {\n        // Called whenever the device connection state changes, i.e. from disconnected to connected.\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n            super.onConnectionStateChange(gatt, status, newState);\n            if (newState == BluetoothGatt.STATE_CONNECTED) {\n                writeConnectionData(\"Connected!\");\n                // Discover services.\n                if (!gatt.discoverServices()) {\n                    writeConnectionData(\"Failed to start discovering services!\");\n                }\n            } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {\n                writeConnectionData(\"Disconnected!\");\n            } else {\n                writeConnectionData(\"Connection state changed.  New state: \" + newState);\n            }\n        }\n\n        // Called when services have been discovered on the remote device.\n        // It seems to be necessary to wait for this discovery to occur before\n        // manipulating any services or characteristics.\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            super.onServicesDiscovered(gatt, status);\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                writeConnectionData(\"Service discovery completed!\");\n            } else {\n                writeConnectionData(\"Service discovery failed with status: \" + status);\n            }\n            // Save reference to each characteristic.\n            tx = gatt.getService(UART_UUID).getCharacteristic(TX_UUID);\n            rx = gatt.getService(UART_UUID).getCharacteristic(RX_UUID);\n\n            // Setup notifications on RX characteristic changes (i.e. data received).\n            // First call setCharacteristicNotification to enable notification.\n            if (!gatt.setCharacteristicNotification(rx, true)) {\n                writeConnectionData(\"Couldn't set notifications for RX characteristic!\");\n            }\n\n            // Next update the RX characteristic's client descriptor to enable notifications.\n            if (rx.getDescriptor(CLIENT_UUID) != null) {\n                BluetoothGattDescriptor desc = rx.getDescriptor(CLIENT_UUID);\n                desc.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);\n                if (!gatt.writeDescriptor(desc)) {\n                    writeConnectionData(\"Couldn't write RX client descriptor value!\");\n                }\n            } else {\n                writeConnectionData(\"Couldn't get RX client descriptor!\");\n            }\n            areServicesAccessible = true;\n        }\n        // Called when a remote characteristic changes (like the RX characteristic).\n        @Override\n        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {\n            super.onCharacteristicChanged(gatt, characteristic);\n            writeSensorData(characteristic.getStringValue(0));\n        }\n    };\n\nprivate BluetoothAdapter.LeScanCallback scanCallback = new BluetoothAdapter.LeScanCallback() {\n        // Called when a device is found.\n        @Override\n        public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) {\n            Log.d(LOG_TAG, bluetoothDevice.getAddress());\n\n            writeConnectionData(\"Found device: \" + bluetoothDevice.getAddress());\n\n            // Check if the device has the UART service.\n            if (BluetoothUtils.parseUUIDs(bytes).contains(UART_UUID)) {\n                // Found a device, stop the scan.\n                adapter.stopLeScan(scanCallback);\n                writeConnectionData(\"Found UART service!\");\n                // Connect to the device.\n                // Control flow will now go to the bluetoothGattCallback functions when BTLE events occur.\n                gatt = bluetoothDevice.connectGatt(getApplicationContext(), false, bluetoothGattCallback);\n            }\n        }\n    };\n}\n```", "```java\n    protected void onStart() {\n        Log.d(LOG_TAG,\"onStart has been called\");\n        super.onStart();\n        // / Scan for all BTLE devices.\n        // The first one with the UART service will be chosen--see the code in the scanCallback.\n        adapter = BluetoothAdapter.getDefaultAdapter();\n        startScan();\n    }\n\n    //When this Activity isn't visible anymore\n    protected void onStop() {\n        Log.d(LOG_TAG,\"onStop has been called\");\n        //disconnect and close Bluetooth Connection for better reliability\n        if (gatt != null) {\n            gatt.disconnect();\n            gatt.close();\n            gatt = null;\n            tx = null;\n            rx = null;\n        }\n        super.onStop();\n    }\n```", "```java\n    //BLUETOOTH METHODS\n    private void startScan() {\n        if (!adapter.isEnabled()) {\n            adapter.enable();\n        }\n        if (!adapter.isDiscovering()) {\n            adapter.startDiscovery();\n        }\n        writeConnectionData(\"Scanning for devices...\");\n        adapter.startLeScan(scanCallback);\n    }\n\n    private void stopScan() {\n        if (adapter.isDiscovering()) {\n            adapter.cancelDiscovery();\n        }\n        writeConnectionData(\"Stopping scan\");\n        adapter.stopLeScan(scanCallback);\n    }\n\n    private void restartScan() {\n        stopScan();\n        startScan();\n    }\n```", "```java\npublic class BluetoothUtils {\n\n    // Filtering by custom UUID is broken in Android 4.3 and 4.4, see:\n    //   http://stackoverflow.com/questions/18019161/startlescan-with-128-bit-uuids-doesnt-work-on-native-android-ble-implementation?noredirect=1#comment27879874_18019161\n    // This is a workaround function from the SO thread to manually parse advertisement data.\n    public static List<UUID> parseUUIDs(final byte[] advertisedData) {\n        List<UUID> uuids = new ArrayList<UUID>();\n\n        int offset = 0;\n        while (offset < (advertisedData.length - 2)) {\n            int len = advertisedData[offset++];\n            if (len == 0)\n                break;\n\n            int type = advertisedData[offset++];\n            switch (type) {\n                case 0x02: // Partial list of 16-bit UUIDs\n                case 0x03: // Complete list of 16-bit UUIDs\n                    while (len > 1) {\n                        int uuid16 = advertisedData[offset++];\n                        uuid16 += (advertisedData[offset++] << 8);\n                        len -= 2;\n                        uuids.add(UUID.fromString(String.format(\"%08x-0000-1000-8000-00805f9b34fb\", uuid16)));\n                    }\n                    break;\n                case 0x06:// Partial list of 128-bit UUIDs\n                case 0x07:// Complete list of 128-bit UUIDs\n                    // Loop through the advertised 128-bit UUID's.\n                    while (len >= 16) {\n                        try {\n                            // Wrap the advertised bits and order them.\n                            ByteBuffer buffer = ByteBuffer.wrap(advertisedData, offset++, 16).order(ByteOrder.LITTLE_ENDIAN);\n                            long mostSignificantBit = buffer.getLong();\n                            long leastSignificantBit = buffer.getLong();\n                            uuids.add(new UUID(leastSignificantBit,\n                                    mostSignificantBit));\n                        } catch (IndexOutOfBoundsException e) {\n                            // Defensive programming.\n                            //Log.e(LOG_TAG, e.toString());\n                            continue;\n                        } finally {\n                            // Move the offset to read the next uuid.\n                            offset += 15;\n                            len -= 16;\n                        }\n                    }\n                    break;\n                default:\n                    offset += (len - 1);\n                    break;\n            }\n        }\n        return uuids;\n    }\n}\n```"]