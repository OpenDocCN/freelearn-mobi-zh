<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Working with Meshes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Working with Meshes</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating polygon meshes with Blender</li><li class="listitem" style="list-style-type: disc">Rendering the wavefront OBJ mesh model</li><li class="listitem" style="list-style-type: disc">Rendering the 3Ds mesh model</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Introduction</h1></div></div></div><p>In previous chapters, you learned the essentials of OpenGL ES to create 3D geometrical objects and place them in the 3D space and also understood and programmed new features in OpenGL ES 3.0. We also programmed a simple 3D cube model using various attributes, such as vertex positions and colors. A procedural geometry modeling (geometry built using only code without any aid of an external data-file reference or tools) in OpenGL ES is not only time consuming, but it can also be very complex to program if the geometry is very complicated. For example, rendering a 3D car model is much more difficult compared to a simple 3D cube. If the user is not careful enough, it becomes very cumbersome to program the geometry.</p><p>The best way to deal with such complicated geometry shapes is to create them using computer aided design tools; such tools not only saves time, but also the created model to visualize. The main advantage of using these tools is that you can create extremely complex geometrical shapes without having to worry about the mathematical concepts involved behind it. After the model is created, you can export them in a variety of 3D file formats in your program. These 3D geometry models are also called meshes.</p><p>In this chapter, you will learn how to create simple meshes using Blender, which is an open source 3D modeling tool. We will discuss and understand two very famous 3D mesh model types, OBJ and 3Ds, and try to understand their specifications. You will also learn how to write a parser for these models in your OpenGL ES recipes. In addition, this chapter will cover various aspects of the 3D mesh model that will be helpful to render them to 3D graphics.</p></div></div>
<div class="section" title="Creating polygon meshes with Blender"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Creating polygon meshes with Blender</h1></div></div></div><p>A polygon <a id="id307" class="indexterm"/>mesh is a collection of vertices, faces, normal, colors, or textures that collectively define a 3D model. This 3D model can be <a id="id308" class="indexterm"/>directly used in various 3D applications, such as computer graphics, simulator, animation movies, and CAD/CAM. In this section, you will learn how to create mesh models in Blender, which we will use throughout the course of this book to demonstrate our recipes.</p><p>In this chapter, we will use Blender 2.68 to develop our 3D model meshes. Blender is a free and open source 3D computer graphics tool. You may use other similar software of your choice, such as 3Ds Max, Maya, Google Sketch, and so on.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec112"/>Getting ready</h2></div></div></div><p>You can <a id="id309" class="indexterm"/>download the latest version of Blender from <a class="ulink" href="http://www.blender.org/download">http://www.blender.org/download</a> and install it as per the instructions given on the website.</p><p>Blender is cross-platform and runs on several popular computing platforms. Blender allows a number of geometric primitives, including various polygon meshes, subdivision surface modeling, and smart geometric editing tools. It also allows various texture techniques to be implemented to geometry surfaces. When Blender is launched for the first time, you will find the tool interface, as given in the following screenshot:</p><div class="mediaobject"><img src="graphics/5527OT_04_01.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec113"/>How to do it...</h2></div></div></div><p>This section will provide a step-by-step procedure to create mesh models in Blender 2.68. We will understand the simple steps to create these meshes and export them to <code class="literal">wavefront.obj</code> and 3Ds formats so that they can be used for demonstration purposes in later recipes.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When <a id="id310" class="indexterm"/>Blender is launched for the first time, a cube-shaped object will be displayed in the middle of the canvas grid. If you are not interested to use this cube, you can delete this. In order to delete an object from the canvas grid, select it (by placing the cursor on it and <a id="id311" class="indexterm"/>right-clicking on it) and click on the delete key on the keyboard. Alternatively, you can select an object and click on the <span class="strong"><strong>X</strong></span> and <span class="emphasis"><em>Enter</em></span> key to delete the selected object.</li><li class="listitem">By default, there are 10 basic mesh models available in Blender, which can be collectively used to create more complex shapes. Depending on the Blender version type, the UI interface may appear different. However, the basic functionality is the same. In order to add a new mesh model, navigate to menu, click on <span class="strong"><strong>Add</strong></span> | <span class="strong"><strong>Mesh</strong></span>, and select the desired model (for example, UV sphere). In the newer Blender versions (such as 2.7.0 and later versions), you may find this option on the left-hand side panel under the <span class="strong"><strong>Create</strong></span> tab, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5527OT_04_02.jpg" alt="How to do it..."/></div></li><li class="listitem">You can change the model properties for each model from the left-hand side pane, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/5527OT_04_03.jpg" alt="How to do it..."/></div><p>For each mesh, you can change the location and apply rotations as well. For all our recipes, we will use Location as (0.0, 0.0, and 0.0) so that the mesh always appears on the origin of the canvas grid.</p></li><li class="listitem">The model can <a id="id312" class="indexterm"/>be edited in the edit mode by selecting the mesh object and clicking on the <span class="emphasis"><em>Tab</em></span> button. In the edit model, the geometry of the mesh can be enhanced. For example, the surface of the <a id="id313" class="indexterm"/>mesh object can be subdivided into many smaller surfaces in order to enhance the smoothness of surfaces. In the edit mode, you can select the subdivide menu option to subdivide the selected objects surface. The following image shows how subdivision works:<div class="mediaobject"><img src="graphics/5527OT_04_04.jpg" alt="How to do it..."/></div></li><li class="listitem">Export the created model using the <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Export</strong></span> menu option. We will export the created model in the wavefront and the 3Ds mesh formats. In the following sections, we will see how of these mesh formats are used in our recipes:<div class="mediaobject"><img src="graphics/5527OT_04_05.jpg" alt="How to do it..."/></div></li><li class="listitem">While exporting <a id="id314" class="indexterm"/>in the wavefront (<code class="literal">.obj</code>) format, you may need to select the following options, depending on your requirements:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Include edges</strong></span>: This <a id="id315" class="indexterm"/>exports edges as two-sided faces.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Triangulate faces</strong></span>: Instead of writing faces as a quad, each quad is represented using three triangles. We must select this option for our <a id="id316" class="indexterm"/>mesh models.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Include UVs (optional)</strong></span>: This writes the texture coordinate information about the geometry surface</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Include normals (optional)</strong></span>: This writes the face and vertex normal depending on the face smooth settings:</li></ul></div><div class="mediaobject"><img src="graphics/5527OT_04_06.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>The <span class="strong"><strong>Include Normals</strong></span> is optional; it calculates the face normal and writes to the file-exported file format. Additionally, calculating normal at runtime will incur some extra processing cost. This feature is useful to minimize runtime calculations at the expense of a large file and the memory utilized while reading this file.</p><p>Alternatively, you can calculate the normal with the face information provided within the mesh model. Later in this recipe, you will learn how the normal is calculated using the face information.</p></div></div></li><li class="listitem">To export the <a id="id317" class="indexterm"/>3Ds format, use all the default <a id="id318" class="indexterm"/>export options.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>The meshes (created in this chapter) do not contain any texture-based information. We will use texture-based models in our later chapter.</p></div></div></li><li class="listitem">While using Blender, the settings can be restored to default factory settings at any time by selecting <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Load Factory Settings</strong></span>.</li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec114"/>There's more...</h2></div></div></div><p>The exported models from Blender and other sample models in the wavefront and 3Ds format can be <a id="id319" class="indexterm"/>found in the <code class="literal">GLPIFramework</code> folder <a id="id320" class="indexterm"/>under <code class="literal">Models</code>. Feel free to explore them. <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <span class="emphasis"><em>Light and Materials</em></span>, makes extensive use of wavefronts models to demonstrate various types of lights.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec115"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Rendering the wavefront OBJ mesh model</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Rendering the 3Ds mesh model</em></span></li></ul></div></div></div>
<div class="section" title="Rendering the wavefront OBJ mesh model"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Rendering the wavefront OBJ mesh model</h1></div></div></div><p>The wave <a id="id321" class="indexterm"/>file format is a famous 3D mesh model format developed by wavefront technologies. It contains the mesh geometry information in a readable text format.</p><p>The wavefront format mainly consists of two types of files: <code class="literal">.obj</code> and <code class="literal">.mtl</code>. The <code class="literal">.obj</code> file is responsible for describing the geometrical information of the 3D model, such as vertex position, normal, texture coordinates faces, and so on. The <code class="literal">.mtl</code> file is optional and contains material information for individual mesh parts, such as the texture and shading (diffuse, specular, and so on) information. Also, the <code class="literal">.mtl</code> file is exported automatically if it contains the texture information; otherwise, you must set <span class="strong"><strong>Write Materials</strong></span>. The term material here refers to the color or texture of an object. The models that we have exported do not contain any texture information. Therefore, these models only consist of <code class="literal">.obj</code> files.</p><p><span class="strong"><strong>File format</strong></span>: As the wave front <a id="id322" class="indexterm"/>format is readable, you can open it in any text editor and read it. It uses special keywords to recognize specific types of information. The following table will help you to understand the keywords used for the wavefront file format:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Keyword</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th><th style="text-align: left" valign="bottom">
<p>Sample</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">#</code></p>
</td><td style="text-align: left" valign="top">
<p>Anything starting with <code class="literal">#</code> is considered as a comment.</p>
</td><td style="text-align: left" valign="top">
<p>This file is created using Blender 2.65</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">v</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the vertex position that specifies x, y, and z coordinates.</p>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">v 1.000000 -1.000000 -1.000000</li><li class="listitem" style="list-style-type: disc">v 1.000000 -1.000000 1.000000</li><li class="listitem" style="list-style-type: disc">v -1.000000 -1.000000 1.000000</li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">vt</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies texture coordinates in the range of 0.0 to 1.0.</p>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">vt 0.0 0.0</li><li class="listitem" style="list-style-type: disc">vt 1.0 0.0</li><li class="listitem" style="list-style-type: disc">vt 1.0 1.0</li><li class="listitem" style="list-style-type: disc">vt 0.0 1.0</li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">vn</code></p>
</td><td style="text-align: left" valign="top">
<p>This represents Normals at each vertex position.</p>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">vn 0.0 1.0 0.0</li><li class="listitem" style="list-style-type: disc">vn 0.0 0.0 1.0</li></ul></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">f</code></p>
</td><td style="text-align: left" valign="top">
<p>This contains the face information. Each face is defined with vertex (v) followed by texture coordinates (u) and vertex normal (n). The syntax for the face information is [v]/[u]/[n].</p>
</td><td style="text-align: left" valign="top">
<p>Face information various formats:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Vertex coordinates: f 1 2 3</li><li class="listitem" style="list-style-type: disc">Vertex and texture coords: f 1/1 3/2 4/3</li><li class="listitem" style="list-style-type: disc">Vertex and texture normal: f 1/1/2 3/2/1 4/3/2</li><li class="listitem" style="list-style-type: disc">Vertex and normal coords: f 1//2 3//1 4//2</li></ul></div>
</td></tr></tbody></table></div><p>The following image shows a sample wavefront (<code class="literal">.obj</code>) file when it's opened in a text editor. This <a id="id323" class="indexterm"/>sample only contains the vertex and face <a id="id324" class="indexterm"/>information, which is a minimal requirement of a mesh model to render to any 3D graphics visualization tool. Depending on the chosen export options, more mesh attributes can be seen with new keywords:</p><div class="mediaobject"><img src="graphics/5527OT_04_07.jpg" alt="Rendering the wavefront OBJ mesh model"/></div><p>The actual capabilities of the wavefront OBJ model are way beyond what we have specified in the file format. Covering all the specifications of <code class="literal">.obj</code> is beyond the scope of this book. You can refer to <a class="ulink" href="http://paulbourke.net/dataformats/obj">http://paulbourke.net/dataformats/obj</a> for the full set of specifications. This <a id="id325" class="indexterm"/>recipe essentially covers the most important and <a id="id326" class="indexterm"/>critical parts of the specification, in which you <a id="id327" class="indexterm"/>will learn how to parse the geometrical information. Our tiny parser and renderer will help you to understand the concept of meshes in-depth and allow you to program any other kind of mesh file formats.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>You can <a id="id328" class="indexterm"/>explore more about wavefront OBJ file format specifications at <a class="ulink" href="http://paulbourke.net/dataformats/obj/">http://paulbourke.net/dataformats/obj/</a>.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec116"/>Getting ready</h2></div></div></div><p>The 3D models we created in Blender need to be imported into the project. Android and iOS have different ways to access their resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Android</strong></span>: On Android, 3D mesh models need to copy from <code class="literal">GLPIFramework/Models</code> and store it in the memory card under the <code class="literal">sdcard/Models</code> folder</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>iOS</strong></span>: Add the <code class="literal">GLPIFramework/Models</code> folder to the project using <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Add Files to [Project Name]</strong></span></li></ul></div><p><span class="strong"><strong>Class and data structure</strong></span>: The <a id="id329" class="indexterm"/>
<code class="literal">OBJMesh</code> class is responsible for parsing wavefront OBJ mesh models; it uses necessary data structures to store the <a id="id330" class="indexterm"/>parsed wavefront OBJ information. This class is defined in <code class="literal">WaveFrontObj.h</code>/<code class="literal">.cpp</code> under our <code class="literal">GLPIframework/WaveFrontOBJ</code> folder. Here are the necessary data structure that are used by this class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertex</strong></span>: This structure will store the information of each vertex, which exists in the 3D geometry. It contains position coordinates of each vertex along the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axis in the position variable. Texture coordinates are stored in the <span class="emphasis"><em>uv</em></span> variable. Normal coordinates are stored in the normal variable. The tangential information at each vertex is stored in the tangent:<div class="informalexample"><pre class="programlisting">struct Vertex
{
public:
   glm::vec3 position; //Store X/Y/Z coordinate.
   glm::vec2 uv;       //Store Tex coordinate.
   glm::vec3 normal;   //Store Normal information.
   glm::vec3 tangent;  //Store Tangent information.
   . . . . .
};</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Face index</strong></span>: This structure is responsible for storing the face-related information. For example, it stores all indexes of the vertices, texture coordinates, and normals that are helpful in defining the face:<div class="informalexample"><pre class="programlisting">struct FaceIndex
{
    short vertexIndex; // Face's vertex Index
    short normalIndex; // Face's normal Index
    short uvIndex;     // Face's texCoord Index
     . . . . .
};</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mesh</strong></span>: The mesh data structure is responsible for storing the Mesh geometry information. It contains the complete path of the OBJ file in the <code class="literal">fileName</code> variable that <a id="id331" class="indexterm"/>needs to be parsed. The class contains the information on vertex, texture, and normal in the form of a vector array. This is stored in the positions, UVs, and normals vector list variables respectively. The <code class="literal">vecFaceIndex</code> stores the information of each face in the form of an index for each vertex making the face.<p>The indices stores the vertex index for each face and is used to calculate normals if the normal information is not available in the <code class="literal">.obj</code> mesh file:</p><div class="informalexample"><pre class="programlisting">struct Mesh
{
    // Obj File name
    char fileName[MAX_FILE_NAME];

    // List of Face Indices For vertex, uvs, normal
   std::vector&lt;FaceIndex&gt; vecFaceIndex;

    // List of vertices containing interleaved 
 // information forposition, uv, and normals
   std::vector&lt;Vertex&gt;    vertices;

    // List of vertices containing positions
   std::vector&lt;glm::vec3&gt; positions;

    // List of vertices containing normal
   std::vector&lt;glm::vec3&gt; normals;

    // List of vertices containing uvs
   std::vector&lt;glm::vec2&gt; uvs;

    //! List of tangents
   std::vector&lt;glm::vec4&gt; tangents;

    // List of face indices
   std::vector&lt;unsigned short&gt; indices;
};</pre></div></li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec117"/>How to do it...</h2></div></div></div><p>This section will provide a step-by-step procedure to parse and render the wavefront OBJ mesh model in OpenGL ES 3.0. Let's start the recipe using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">ObjLoader</code> class derived from the <code class="literal">Model</code> class. It will inherit all the member functions of <code class="literal">Model</code> necessary for the life cycle of <code class="literal">ObjLoader</code>.<p>This class contains member variables to store the wavefront model mesh information. The mesh model is parsed using <code class="literal">ObjMesh</code> function's <code class="literal">waveFrontObjectModel</code> object. This object calls the <code class="literal">parseObjMesh</code> function, which accepts the path for the 3D wavefront OBJ model <a id="id332" class="indexterm"/>as an argument that we are interested to load on:</p><div class="informalexample"><pre class="programlisting">OBJMesh waveFrontObjectModel;
objMeshModel = waveFrontObjectModel.ParseObjModel(fname);</pre></div></li><li class="listitem">The <code class="literal">ParseObjModel</code> function further calls a set of helper functions to store and process the mesh information from the <code class="literal">.obj</code> file. This function returns the <code class="literal">Mesh</code> object pointer. This function accepts the path of the file to be loaded and another argument that specifies whether the normal needs to be calculated as flat or smooth:<div class="informalexample"><pre class="programlisting">Mesh* OBJMesh::ParseObjModel(char* path, bool flatShading)
{
    ParseFileInfo(path);         // Parse's the obj file
    CreateInterleavedArray();    // Interleaved data array
    CalculateNormal(flatShading);// Generate the normal
    if(objMeshModel.uvs.size())
        { CalculateTangents(); } // Generate tangents
    ClearMesh();                 // Release alloc resources
    return &amp;objMeshModel;
}</pre></div></li><li class="listitem">The <code class="literal">ParseFileInfo</code> reads the path of the mesh model to validate its existence. This function parses the file by reading each line in it. Each line contains a keyword at the beginning that specifies the type of information it contains. The <code class="literal">#</code>, <code class="literal">u</code>, <code class="literal">s</code>, or <code class="literal">g</code> keywords are ignored as they are not used in the parser. The <code class="literal">#</code> keyword is used to write comments in the wavefront file. The parsed information from this function is collected in the mesh's object pointer:<div class="informalexample"><pre class="programlisting">strcpy(objMeshModel.fileName, path);
while(!eofReached)
{
    c = fgetc(pFile);
    switch(c)
    {
        case '#': // Ignore (This is a comment)
        case 'u': // Ignore
        case 's': // Ignore
        case 'g': // Grouping not supported
            while(fgetc(pFile) != '\n'); 
// Skip till new next line not reached.
            break;
                
#ifdef __IPHONE_4_0
      case EOF:
#else
      case (unsigned char)EOF:
#endif
            eofReached = true;
            break;
                
        case 'v': // Load the vertices.
            c = fgetc(pFile); 
// The next character will
           // let us know what vertex attribute to load
            ScanVertexNormalAndUV( pFile, c );
            break;
                
        case 'f': 
// 'f' means it is a face index information 
// in the form of v/u/n
            ScanFaceIndex( pFile, c );
            break;
    }
}</pre></div></li><li class="listitem">The line starting <a id="id333" class="indexterm"/>with the <code class="literal">v</code> keyword represents vertex attributes, which could be of three types of information: vertex position (<code class="literal">v</code>), vertex texture coordinate (<code class="literal">vt</code>), and vertex normal (<code class="literal">vn</code>). This information is read using the <code class="literal">ScanVertexNormalAndUV</code> function.<p>This function parses each line and stores the information of vertex position, texture coordinate, and vertex normal in <code class="literal">objMeshModel.positions</code>, <code class="literal">objMeshModel.uvs</code>, and <code class="literal">objMeshModel.normals</code> respectively:</p><div class="informalexample"><pre class="programlisting">       bool OBJMesh::ScanVertexNormalAndUV( FILE* pFile, char c )
{
float  x, y, z, u, v;
switch(c)
{
   case ' ': // Load vertices
      fscanf(pFile,"%f %f %f\n",&amp;x,&amp;y,&amp;z);
      objMeshModel.positions.push_back(glm::vec3(x, y, z));
   break;
   case 'n': // Loading normal coordinate comp. x,y,z
       fscanf(pFile,"%f %f %f\n",&amp;x,&amp;y,&amp;z);
      objMeshModel.normals.push_back(glm::vec3(x, y, z));
      break;
   case 't': // Loading Texture coordinates (UV)
fscanf(pFile,"%f %f\n",&amp;u,&amp;v);
         objMeshModel.uvs.push_back(glm::vec2(u, v));
break;
   default:
        return false;
}
}</pre></div></li><li class="listitem">Similarly, the line starting with the <code class="literal">f</code> keyword and followed by a " " space represents <a id="id334" class="indexterm"/>faces. A face is made up of three vertices and each vertex may consist of three attributes: vertex position, texture coordinates, and vertex normal.<p>Each face stores information in the form of an index. An index here refers to the index of an actual element in the stored arrays (calculated in step five). For example, an index of two for the vertex position in a given face means a third vertex element in the <code class="literal">objMeshModel.positions</code> vector array.</p><p>Gather the face index information in the <code class="literal">objMeshModel.vecFaceIndex</code> vector list. This list contains all faces that have the indices of vertex attributes belonging to each vertex of the face. For more information, refer to the <code class="literal">ObjMesh::ScanFaceIndex</code> function.</p></li><li class="listitem">Using the face <a id="id335" class="indexterm"/>index information gathered in <code class="literal">objMeshModel.vecFace</code>, populate the <code class="literal">objMeshModel.vertices</code> vector list. This list contains vertex attributes to be used to create the Vertex Buffer Object:<div class="informalexample"><pre class="programlisting">    // Allocate enough space to store vertices and indices

  objMeshModel.vertices.resize(obMeshModl.vecFacIndex.size());
        objMeshModel.indices.resize(obMeshModl.vecFacIndex.size());

       // Get the total number of indices.
        objMeshModel.indexCount = objMeshModel.indices.size();

       // Create the interleaved vertex information
  // containing position, uv and normal.
        for(int i = 0; i &lt; objMeshModel.vecFaceIndex.size(); i++)
        {
//Position information must be available always
int index = objMeshModel.vecFaceIndex.at(i + 0).vertexIndex;
objMeshModel.vertices[i].position =
                   objMeshModel.positions.at(index);
objMeshModel.indices[i] =
             (GLushort)objMeshModel.vecFaceIndex.at(i).vertexIndex;

// If UV information is available.
if(objMeshModel.uvs.size()){
index = objMeshModel.vecFaceIndex.at(i).uvIndex;
   objMeshModel.vertices[i].uv =
 objMeshModel.uvs.at(index);
}

// If Normal information is available.
if(objMeshModel.normals.size()){
index = objMeshModel.vecFaceIndex.at(i ).normalIndex;
objMeshModel.vertices[i].normal =
objMeshModel.normals.at(index);
}
}</pre></div></li><li class="listitem">If the normal attribute is missing in the OBJ file, it can be calculated using <code class="literal">OBJMesh::CalculateNormal()</code>. For more information, refer to the <span class="emphasis"><em>There's more...</em></span> section in this recipe.</li><li class="listitem">Similarly, the tangent information at each vertex is calculated using <code class="literal">OBJMesh::CalculateTangents()</code>. You can refer to bump mapping in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <span class="emphasis"><em>Light and Materials</em></span>, to understand the working of this function thoroughly.</li><li class="listitem">Once the OBJ mesh information is parsed and stored in mesh's object, clear all the temporary data structure using the <code class="literal">ClearMesh</code> function:<div class="informalexample"><pre class="programlisting">bool OBJMesh::ClearMesh()
{
  objMeshModel.positions.clear();  // Clear positions
  objMeshModel.normals.clear();    // Clear normals
  objMeshModel.uvs.clear();        // Clear tex Coords
  objMeshModel.indices.clear();      // Clear indices
  objMeshModel.vecFaceIndex.clear(); // Clear FaceIdx 
  return true;
}</pre></div></li><li class="listitem">After parsing the OBJ file, create the VBO within the <code class="literal">ObjLoader</code> constructor:<div class="informalexample"><pre class="programlisting">// Function ObjLoader::ObjLoader( Renderer* parent )
ObjLoader::ObjLoader( Renderer* parent )
{
. . . . . . . 
objMeshModel= waveFrontObjectModel.ParseObjModel(fname);
IndexCount  = waveFrontObjectModel.IndexTotal();
stride      = (2 * sizeof(glm::vec3) )+ sizeof(glm::vec2);
          offset      = (GLvoid*) (sizeof(glm::vec3) + sizeof(glm::vec2));


          // Create the VBO for our obj model vertices.
          GLuint vertexBuffer; glGenBuffers(1, &amp;vertexBuffer);
         glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
      glBufferData(GL_ARRAY_BUFFER, objMeshModel-&gt;vertices.size()
               * sizeof(objMeshModel-&gt;vertices[0]),
               &amp;objMeshModel-&gt;vertices[0], GL_STATIC_DRAW);


// Create the Vertex Array Object (VAO)
          glGenVertexArrays(1, &amp;OBJ_VAO_Id);
          glBindVertexArray(OBJ_VAO_Id);
// Bind VBO, enable attributes and draw geometry
   glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
   glEnableVertexAttribArray(VERTEX_POSITION);
          glEnableVertexAttribArray(NORMAL_POSITION);
          glVertexAttribPointer
      (VERTEX_POSITION, 3, GL_FLOAT, GL_FALSE, stride, 0);
          glVertexAttribPointer
      (NORMAL_POSITION, 3,GL_FLOAT,GL_FALSE,stride,offset);
          glBindVertexArray(0); //Use default VAO</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec118"/>How it works...</h2></div></div></div><p>The <code class="literal">ParseObjMesh</code> function in the <code class="literal">OBJMesh</code> class is responsible for parsing the wavefront OBJ file and storing the information in the mesh's <code class="literal">objMeshModel</code> object variable. This function parses the file and recognizes vertex attributes, such as vertex position, texture <a id="id336" class="indexterm"/>coordinates, and vertex normals. It stores these attributes in the <code class="literal">objMeshModel.positions</code>, <code class="literal">objMeshModel.uvs</code>, and <code class="literal">objMeshModel.normals</code> respective vector arrays. These vector arrays are contiguous in nature. Therefore, these arrays can be used directly to pick elements using the index information.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The vertex texture and vertex normal are optional attributes. Without these, the geometry can still be produced. Texture coordinates only get stored if the model contains any texture. The normal can be saved in the OBJ file by selecting <span class="strong"><strong>Include Normals</strong></span> in export options. For more information on .OBJ mesh model export options, refer to, the <span class="emphasis"><em>How to do it...</em></span> section under the <span class="emphasis"><em>Creating polygon meshes with Blender</em></span> recipe in this chapter for more information on OBJ mesh model export options.</p></div></div><p>After parsing the vertex attribute information, the face information needs to be parsed. Each face is made up of three vertices. These vertices can contain the position, texture, and normal information. The information for each vertex attribute in the face is stored in the form of an index. The face information in the <code class="literal">objMeshModel.vecFaceIndex</code> must be stored in the vector array list.</p><p>The <code class="literal">objMeshModel.vertices</code> is another vector-based array that is contiguous in nature and in the interleaved form. Each record in array represents a vertex element, which contains vertex positions, texture coordinates, and normal attributes. The <code class="literal">OBJMesh::CreateInterleavedArray</code> function is responsible for generating this array. The Interleaved fashion array is highly recommended as it contains different attribute data in a single array, thereby sufficient to store a single VBO. However, if the data is not stored interleaved, each attribute will be stored in a separate array. For each data array, a separate VBO is required. Use of too many VBOs is performance killing because the rendering pipeline spends more time binding and switching VBOs.</p><p>The OBJ model data are to be drawn using <code class="literal">GL_TRIANGLES</code>. The fragment shader used will provide different effects based on the information passed (for example, texture coordinates, lighting information, and so on) in the upcoming chapters. We will apply various vertex and <a id="id337" class="indexterm"/>fragment shaders to OBJ meshes in order to produce mind-blowing real-time rendering effects:</p><div class="mediaobject"><img src="graphics/5527OT_04_08.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec119"/>There's more...</h2></div></div></div><p>Normal's information plays an important role in the light shading of 3D objects. Our wavefront exported models do not contain any normal information. This section will help us in calculating normals using the face information.</p><p>There are two ways in which the normal can be calculated:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Face normal</strong></span>: This is <a id="id338" class="indexterm"/>calculated using a single face information. This type of normal results in flat shading. It's calculated using a cross product of any two edges formed by the triangle face. In other words, it's perpendicular to the surface generated by coplanar vertices.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertex normal</strong></span>: This is <a id="id339" class="indexterm"/>calculated by taking the average of the face normal created by faces that share common vertices:<div class="mediaobject"><img src="graphics/5527OT_04_09.jpg" alt="There's more..."/></div></li></ul></div><p>The preceding image shows the face and vertex normal. Each face normal is calculated using four vertices, which form a plane surface. Out of these four vertices, any of the three vertices can be used to form two edges. The cross product of these two edges results a perpendicular vector to plane. Normalizing this vector produces a face normal.</p><p>In contrast, each vertex shows the vertex normal in the blue colored line, which is formed by four planes or four faces surrounded around each vertex. The average of these four planes face normal results a vertex normal. Vertex normal is extremely important to generate highly detailed and smooth geometrical appearance without requiring too many vertices.</p><p>The flat shade or <a id="id340" class="indexterm"/>smooth shade normal can be calculated using <code class="literal">ParseObjMesh</code> with the second parameter as Boolean <code class="literal">true</code> for flat shading and Boolean <code class="literal">false</code> for smooth shading. Internally, this function calls <code class="literal">OBJMesh::CalculateNormal</code>, which is responsible for the mathematical calculation of normal:</p><div class="informalexample"><pre class="programlisting">    // Calculates the flat or smooth normal on the fly
Function OBJMesh::CalculateNormal(bool flatShading)
{
if( objMeshModel.normals.size() == 0 ){
    // Make space to store the normal information
objMeshModel.normals.resize(objMeshModel.positions.size());
int index0, index1, index2;
glm::vec3 a, b, c;
for(int i=0; i&lt;objMeshModel.indices.size();i += 3){
    // Use indices to retrieve the vertices
          index0 = objMeshModel.indices.at(i);
          index1 = objMeshModel.indices.at(i+1);
          index2 = objMeshModel.indices.at(i+2);
    // Retrieve each triangles vertex    
          a = objMeshModel.positions.at(index0);
          b = objMeshModel.positions.at(index1);
          c = objMeshModel.positions.at(index2);
    // Calculate the normal triangle face.
         glm::vec3 faceNormal =  glm::cross((b - a), (c - a));
    
         if ( flatShading ){
    // Calculate normals for flat shading
             objMeshModel.vertices[i].normal += faceNormal;
             objMeshModel.vertices[i+1].normal += faceNormal;
             objMeshModel.vertices[i+2].normal += faceNormal;
          }
          else{
             objMeshModel.normals[index0] += faceNormal;
             objMeshModel.normals[index1] += faceNormal;
             objMeshModel.normals[index2] += faceNormal;
          }
}
        // Calculate normals for smooth shading
        if ( !flatShading ){
        for(int i = 0;i&lt;objMeshModel.vecFaceIndex.size(); i++){
        int index=objMeshModel.vecFaceIndex.at
(i +0).vertexIndex;
        objMeshModel.vertices[i].normal=
                               objMeshModel.normals.at(index);
      }
   }
          // Store the calculated normal in normalized form
for (int j=0;j&lt;objMeshModel.vertices.size(); j++){
objMeshModel.vertices[j].normal = 
glm::normalize (objMeshModel.vertices[j].normal);
}
}    
}</pre></div><p>The face normal points to the direction where polygons face. However, vertex normal changes the gradient of the polygon. If we change the direction of the vertex normal, the shading around that vertex will <code class="literal">http://change.at/" \t "_blank</code>, this gradient is as same as a flat polygon <a id="id341" class="indexterm"/>that's rotated in the same direction. The computer fakes a gradient over the polygon.</p><p>The following image shows how a simple sphere on the left-hand side appears without a light shading technique. In fact, it's difficult to believe that it's a sphere mesh model. The middle and rightmost mesh models are demonstrated using light shades. The prior mesh model uses the flat light shading, which is achieved using face normals, whereas the latter mesh model renders the <a id="id342" class="indexterm"/>same mesh model with vertex normals:</p><div class="mediaobject"><img src="graphics/5527OT_04_10.jpg" alt="There's more..."/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec120"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Efficient rendering with Vertex Buffer Object</em></span> recipe <a class="link" href="ch02.html" title="Chapter 2. OpenGL ES 3.0 Essentials">Chapter 2</a>, <span class="emphasis"><em>OpenGL ES 3.0 Essentials</em></span></li><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Phong shading – per-fragment shading technique</em></span> recipe in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <span class="emphasis"><em>Light and Materials</em></span></li><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Gouraud shading – the per-fragment shading technique and Phong shading – the per-fragment shading technique recipes</em></span> recipes in <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <span class="emphasis"><em>Light and Materials</em></span></li><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Implementing bump mapping</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Textures and Mapping Techniques">Chapter 7</a>, <span class="emphasis"><em>Texture and Mapping Techniques</em></span></li><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Managing VBO with Vertex Array Objects</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. New Features of OpenGL ES 3.0">Chapter 3</a>, <span class="emphasis"><em>New Features of OpenGL ES 3.0</em></span></li></ul></div></div></div>
<div class="section" title="Rendering the 3Ds mesh model"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Rendering the 3Ds mesh model</h1></div></div></div><p>The 3Ds <a id="id343" class="indexterm"/>mesh format is a well-known 3D mesh file format used in computer graphics. Unlike wavefront, it's not text-based and stores the mesh information in a binary form. This is used widely in Autodesk 3D Studio Max and is a professional 3D graphics program software to create 3D animation and models.</p><p><span class="strong"><strong>File format</strong></span>: This section <a id="id344" class="indexterm"/>will provide an overview of the 3Ds file format. This mesh format contains information in the form of a hierarchy of chunks. A chunk is a structured piece of information in the memory. Its unique ID recognizes each chunk, which contains the size information (in bytes) that can be used to read or skip chunks. The size information of the current chunk is always relative to its start memory position; skipping this much size will point to the next chunk.</p><p>The following table shows that each chunk is represented with the <span class="strong"><strong>Start</strong></span> field, which contains the memory location within the 3Ds file. The <span class="strong"><strong>Size</strong></span> field tells us how big is the chunk in bytes, whereas the <span class="strong"><strong>End</strong></span> field specifies the memory location where the chunk finishes. The <span class="strong"><strong>End</strong></span> field can be calculated with the help of the <span class="emphasis"><em>Size – Start + 1</em></span> formula. The next chunk information is always relative to the current chunk position:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Start</p>
</th><th style="text-align: left" valign="bottom">
<p>End</p>
</th><th style="text-align: left" valign="bottom">
<p>Size</p>
</th><th style="text-align: left" valign="bottom">
<p>Name</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>Chunk ID</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>Next chunk</p>
</td></tr></tbody></table></div><p>Each chunks <a id="id345" class="indexterm"/>ID in the 3Ds file has a predefined meaning associated with <a id="id346" class="indexterm"/>it. For example, the first chunk ID of this file format is always <code class="literal">0x4d4d</code>. This chunk is called the primary or main chunk ID. The other important chunks exist under this primary chunk as child nodes, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5527OT_04_11.jpg" alt="Rendering the 3Ds mesh model"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The detailed <a id="id347" class="indexterm"/>specification of 3Ds is beyond the scope of this book. You can find more information about this specification at <a class="ulink" href="http://www.martinreddy.net/gfx/3d/3DS.spec">http://www.martinreddy.net/gfx/3d/3DS.spec</a>.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec121"/>Getting ready</h2></div></div></div><p>In this recipe, we will parse the 3Ds file format using a third-party library called <code class="literal">lib3ds</code>. This is an open source library that helps us to parse the file and provide us the file data in the form of a data structure. This library is written in ANCI-C. Therefore, it's portable across platforms. The lib3ds is available for commercial application under GNU <span class="strong"><strong>Lesser General Public </strong></span><a id="id348" class="indexterm"/>
<span class="strong"><strong>License</strong></span> (<span class="strong"><strong>LGPL</strong></span>). The library can be download from <a class="ulink" href="https://code.google.com/p/lib3ds/">https://code.google.com/p/lib3ds/</a>.</p><p>In our GLPI framework, this library is present under the <code class="literal">GLPIFramework/3DSParser/lib3ds</code> folder. We have used the 1.30 version for this library. Rendering 3DS mesh models to the application requires these to be stored at some appropriate location on the device or simulator.</p><p>On the Android device, you can store 3DS mesh model files under the <code class="literal">sdcard/GLPIFramework/Model</code> folder. For iOS, these models can be added to the project using <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Add Files to [Project Name]</strong></span>.</p><p><span class="strong"><strong>Android</strong></span>: On the <a id="id349" class="indexterm"/>Android platform, we need the makefile to build the <code class="literal">lib3ds</code> library. Add the <code class="literal">Android.mk</code> makefile under <code class="literal">GLPIFramework/3DSParser/lib3ds</code>. Edit this makefile, as shown in the following code. This library will be compiled as a shared library, which is named as <code class="literal">mylib3ds</code>. You can also directly add the source code in the main project makefile, instead of compiling a shared library:</p><p><code class="literal">Android.mk</code>:</p><div class="informalexample"><pre class="programlisting">LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
# Name of the shared library
LOCAL_MODULE    := mylib3ds
LOCAL_SRC_FILES := \
   lib3ds/viewport.c \
   lib3ds/vector.c \
   lib3ds/tracks.c \
   lib3ds/tcb.c \
   lib3ds/shadow.c \
   lib3ds/quat.c \
   lib3ds/node.c \
   lib3ds/mesh.c \
   lib3ds/matrix.c \
   lib3ds/material.c \
   lib3ds/light.c \
   lib3ds/io.c \
   lib3ds/file.c \
   lib3ds/ease.c \
   lib3ds/chunk.c \
   lib3ds/camera.c \
   lib3ds/background.c \
   lib3ds/atmosphere.c
# Included libraries and compile time flags
LOCAL_LDLIBS := -lz
LOCAL_CFLAGS := -I. -g
# Build as shared library
include $(BUILD_SHARED_LIBRARY)</pre></div><p>Open the <code class="literal">Android.mk</code> makefile present in the project directory under the <code class="literal">JNI</code> folder and include the path <a id="id350" class="indexterm"/>of the <code class="literal">lib3ds</code> library <code class="literal">Android.mk</code> file that we have created in the preceding code:</p><div class="informalexample"><pre class="programlisting">MY_CUR_LOCAL_PATH := $(call my-dir)
FRAMEWORK_DIR   = ../../../../GLPIFramework
LIB3DS_DIR = $(FRAMEWORK_DIR)/3DSParser

include $(CLEAR_VARS)

include$(MY_CUR_LOCAL_PATH)/../GLPIFramework/zlib/Android.mk \
$(MY_CUR_LOCAL_PATH)/../GLPIFramework/3DSParser/Android.mk
# Source file for compilation
LOCAL_SRC_FILES := $(FRAMEWORK_DIR)/GLutils.cpp \
. . . . .
. . . . .
$(SCENE_DIR)/Renderer.cpp \
$(SCENE_DIR)/3DSLoader.cpp \
../../NativeTemplate.cpp
# Include the 3DS library
LOCAL_SHARED_LIBRARIES := zlib mylib3ds</pre></div><p>In <code class="literal">GLESNativeLib.java</code>, edit the <code class="literal">GLESNativeLib</code> class and add the reference of our shared library, so that it will be linked at runtime:</p><div class="informalexample"><pre class="programlisting">public class GLESNativeLib {
static {
   System.loadLibrary("zlib");
   System.loadLibrary("mylib3ds");
   System.loadLibrary("glNative");
}
   . . . . . . Other code
}</pre></div><p><span class="strong"><strong>iOS</strong></span>: On the iOS platform, you need to add <code class="literal">lib3ds</code> library source files to your project using <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Add Files to [Project Name]</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec122"/>How to do it...</h2></div></div></div><p>Here are the steps to create a 3Ds mesh renderer class. This class will be responsible for loading and rendering 3Ds mesh models:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For this recipe, we have derived a new class called <code class="literal">Loader3DS</code> from the <code class="literal">Scene</code>. This class contains a <code class="literal">load3dsModel</code> function, which will be used to load the 3Ds mesh model file.</li><li class="listitem">Implement the <code class="literal">load3dsModel</code> function, as described in the following code snippet. This function parses the 3Ds model file using the <code class="literal">lib3ds</code> library's function called <code class="literal">lib3ds_file_load</code> and returns the <code class="literal">Lib3dsFile</code> pointer. The <code class="literal">Lib3dsFile</code> <a id="id351" class="indexterm"/>structure contains the parsed information of the 3Ds mesh file:<div class="informalexample"><pre class="programlisting">Lib3dsFile* Loader3DS::load3dsModel(const char* fileName){
   Lib3dsFile* file = lib3ds_file_load(fileName);
   if (!file) {
   LOGI("*ERROR*\nLoading file %s failed\n", fileName);
      return NULL;
   }
   . . . . . .
   . . . . . . 
   return file;
}</pre></div></li><li class="listitem">When a 3Ds mesh file is parsed successfully, it loads the mesh data (geometry attributes and material information) of the mesh model in the file object type called <code class="literal">Lib3dsFile</code>. This object contains all the necessary information to read nodes. A node in the 3Ds specification is a special data structure called <code class="literal">Lib3dsNode</code> that corresponds to a subpart or submodel of the complete 3D mesh model. For example, a <code class="literal">car</code> model is made up of many different subparts, such as body frame, tires, doors, engine, and so on. Each of these individual parts correspond to a child node of the parent node that represents the 3D car model.<p>Depending on the complexity of the model, there may be  more than one node. These nodes are arranged in a hierarchical fashion. The nodes are created using <code class="literal">lib3ds_node_new_object()</code> and are arranged in a hierarchal order with <code class="literal">lib3ds_file_insert_node()</code>:</p><div class="informalexample"><pre class="programlisting">if( !file-&gt;nodes )
{
   Lib3dsMesh *mesh;
   Lib3dsNode *node;
   for(mesh=file-&gt;meshes; mesh!=NULL; mesh=mesh-&gt;next){
      node = lib3ds_node_new_object();
      strcpy(node-&gt;name, mesh-&gt;name);
      node-&gt;parent_id = LIB3DS_NO_PARENT;
      lib3ds_file_insert_node(file, node);
   }
}</pre></div></li><li class="listitem">Render the 3Ds mesh model by recursively iterating through all the nodes. Call <code class="literal">RenderNodes()</code> to render each node:<div class="informalexample"><pre class="programlisting">void Loader3DS::Render(Lib3dsFile* file)
{
   . . . . . . .
   Lib3dsNode *p;
   for (Lib3dsNode* p=file-&gt;nodes; p!=0; p=p-&gt;next ){
       RenderNodes( file, p );
   }
   . . . . . . .
}</pre></div></li><li class="listitem"><code class="literal">RenderNodes()</code> is a recursive function that creates VBO for each node and renders them. Each <a id="id352" class="indexterm"/>node contains a pointer to <code class="literal">Lib3dsMesh</code>; the <code class="literal">Lib3dsMesh</code> is a data structure that contains the geometrical information for each node:<div class="informalexample"><pre class="programlisting">void RenderNodes(Lib3dsFile* file,Lib3dsNode *node){
   . . . . . . . 
// Use appropriate shader
glUseProgram( program-&gt;ProgramID );

Lib3dsNode *tempNode;
for(tempNode=node-&gt;child;tempNode!=0;
tempNode=tempNode-&gt;next)     {
      RenderNodes(file, tempNode);
                             }
}</pre></div></li><li class="listitem">The <code class="literal">Lib3ds</code> library contains a structure called <code class="literal">Lib3dsUserData</code>. It allows you to add custom variables to <code class="literal">lib3ds</code>. We will use this structure to store vertex buffer object variables like vertex:<div class="informalexample"><pre class="programlisting">// Check the user.p variable if empty is assigned
MyLib3dsUserData 
if (!mesh-&gt;user.p){
  MyLib3dsUserData* myPObject = new MyLib3dsUserData;
  mesh-&gt;user.p = (void*)myPObject;
}</pre></div></li><li class="listitem">Build the VAO for each mesh using the <code class="literal">BuildMesh()</code> function. Cache the VAO, VBO, and IBO information in the <code class="literal">MyLib3dsUserData</code> object:<div class="informalexample"><pre class="programlisting">void Loader3DS::BuildMesh(Lib3dsMesh *mesh)
{
 MyLib3dsUserData* userObj=(MyLib3dsUsrData*)mesh-&gt;user.p;
 
    // Allocation memory for vertex positions
    meshVert = new float[ mesh-&gt;points * 3 ];
   . . . . .
 
    // Allocate memory for texture
    meshTexture = new float[ mesh-&gt;texels * 2 ];
    . . . . .
 
    // Allocate memory for normal
    meshNormal = new Lib3dsVector[ 3 * mesh-&gt;faces ];
    lib3ds_mesh_calculate_normals(mesh, meshNormal);
 
    // Allocate memory for face information
    faceIndex = new unsigned short[mesh-&gt;faces*3];
    . . . . .
 
    // Create the VBO and populate the VBO data 
    glGenBuffers( 1, (GLuint *)&amp;vId );
    glBindBuffer( GL_ARRAY_BUFFER, vId );
    . . . . .

    // Create and populate the IBO with index info. 
    glGenBuffers( 1, (GLuint *)&amp;iId );
    glBindBuffer( GL_ARRAY_BUFFER, iId );
    . . . . .

    // Create and Bind Vertex Array Object
    glGenVertexArrays(1, &amp;VAOId);
    glBindVertexArray(VAOId);
    . . . . .

    // Cache the information in the User data structure
    userObj-&gt;vertexId   = vId;
    userObj-&gt;indexId    = iId;
    userObj-&gt;VAOId      = VAOId;
    . . . . .
}</pre></div></li><li class="listitem">In <code class="literal">RenderNodes()</code>, use <a id="id353" class="indexterm"/>the VAO information to render the 3Ds mesh model:<div class="informalexample"><pre class="programlisting"> MyLib3dsUserData* userObj=(MyLib3dsUserData*)mesh-&gt;user.p;
 // If VAO is not created, create using BuildMesh. 
 if ( !userObj-&gt;VAOId ) {
       BuildMesh( mesh );
 }
 else {
      // Apply Transformation &amp; set material information
      SetMaterialInfo( mesh );
      //Bind to VAO &amp; draw primitives
      glBindVertexArray(userObj-&gt;VAOId);
      glDrawElements(GL_TRIANGLES, userObj-&gt;indexNum,
                  GL_UNSIGNED_SHORT, (void*)0);
      glBindVertexArray(0); //Bind to default VAO
 }</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec123"/>How it works...</h2></div></div></div><p>The 3Ds mesh file is parsed with lib3ds library's <code class="literal">lib3ds_file_load</code>. This function successfully populates the <code class="literal">Lib3dsFile</code> file pointer that contains all the parsed information from the 3Ds file. Using this data variable, we create nodes that are  populated and <a id="id354" class="indexterm"/>assembled in a hierarchical order using <code class="literal">lib3ds_file_insert_node</code>. Each node represents a mesh, which is read from the node structure and cached in the form of a <span class="strong"><strong>Vertex Array Objects</strong></span> (<span class="strong"><strong>VAO</strong></span>). Each VAO stores the <span class="strong"><strong>Vertex Buffer Object</strong></span> (<span class="strong"><strong>VBO</strong></span>), states, and attributes.</p><p>The <code class="literal">RenderNodes</code> is a <a id="id355" class="indexterm"/>recursive function that creates the VAO and <a id="id356" class="indexterm"/>VBO for each node and renders them. Each node contains a pointer to <code class="literal">Lib3dsMesh</code>, which further contains a <code class="literal">Lib3dsUserData</code> that we will use to check whether the corresponding node contains the VAO. The VAO is recognized with a vertex array ID. These IDs are bound to runtime and used to render the geometry. Once the VAO IDs are generated, these are stored with each node in the <code class="literal">Lib3dsUserData</code> structure:</p><div class="mediaobject"><img src="graphics/5527OT_04_12.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec124"/>There's more...</h2></div></div></div><p>So far in this recipe, you learned how to render 3Ds mesh models. We rendered these using a single color. The 3Ds file format also has the provision to render faces with colors. This information is stored in <code class="literal">Lib3dsMaterial</code> of <code class="literal">Lib3dsMesh</code>. The following code shows how the <a id="id357" class="indexterm"/>material information is read from the material data structure and sends it as a uniform variable to the <code class="literal">3dsFragmentShader.glsl</code> to apply as face colors:</p><div class="informalexample"><pre class="programlisting">void Loader3DS::SetMaterialInfo( Lib3dsMesh *mesh )
{
   Lib3dsMaterial *material = 0;
   if ( mesh-&gt;faces ) {
      // Get associated material with the mesh
      material = lib3ds_file_material_by_name
                      (file, mesh-&gt;faceL[0].material);
   }

   if( !material ){
       return;
   }

   // Set Ambient, Diffuse and Specular light component
   glUniform4f(UniformKa, material-&gt;ambient[0], 
   material-&gt;ambient[1], material-&gt;ambient[2], 
   material-&gt;ambient[3]);
   glUniform4f(UniformKd, material-&gt;diffuse[0], 
   material-&gt;diffuse[1], material-&gt;diffuse[2], 
   material-&gt;diffuse[3]);
   glUniform4f(UniformKs,material-&gt;specular[0],
   material-&gt;specular[1], material-&gt;specular[2], 
   material-&gt;specular[3]);
   glUniform1f(UniformKsh, material-&gt;shininess);
}</pre></div><p>The color information is stored in the form of material colors. For more information on light and material, refer to the <a class="link" href="ch05.html" title="Chapter 5. Light and Materials">Chapter 5</a>, <span class="emphasis"><em>Light and Materials</em></span>. The following image illustrates a car model with colored faces, where the mesh model is rendered with triangle, line, and point primitives:</p><div class="mediaobject"><img src="graphics/5527OT_04_13.jpg" alt="There's more..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p><span class="strong"><strong>Pivot position</strong></span>: The <a id="id358" class="indexterm"/>pivot position renders mesh models to the translation information. This helps the mesh to render with correct positioning. Without <a id="id359" class="indexterm"/>pivot positioning, each node renders at the origin. This behavior causes all node meshes to cluster at the origin because each model does not know its position relative to other models.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec125"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Managing VBO with Vertex Array Objects</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. New Features of OpenGL ES 3.0">Chapter 3</a>, <span class="emphasis"><em>New Features of OpenGL ES 3.0</em></span></li></ul></div></div></div></body></html>