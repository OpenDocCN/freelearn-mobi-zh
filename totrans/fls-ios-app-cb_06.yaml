- en: Chapter 6. Graphics and Hardware Acceleration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing vector and bitmap graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GPU-Blend mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GPU-Vector mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cache as Bitmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cache as Bitmap Matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing bitmaps with ActionScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading bitmaps at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with sprite sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing bitmap animation with ActionScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The release of CS5 made it possible for Flash developers to create exciting
    content for iOS devices without changing their workflow. However, with only a
    fraction of the computing power of a modern day desktop or laptop, developing
    for devices such as the iPhone requires special design and coding considerations.
  prefs: []
  type: TYPE_NORMAL
- en: One of the largest bottlenecks is graphics rendering and it has become an area
    of frustration for many. It is simply not realistic to build the same graphics-heavy
    FLAs that you normally would for desktop delivery and expect them to run well
    on mobile. Even seemingly simple graphical operations can perform badly on iOS
    devices if poorly implemented.
  prefs: []
  type: TYPE_NORMAL
- en: By making available the same powerful drawing and animation tools that you are
    already familiar with, the Flash IDE can actually lull you into a false sense
    of security. For example, complex vector artwork, masks, timeline animations,
    deeply-nested display lists, and alpha transparencies are all easy to create but
    can negatively impact the performance of your app. Targeting mobile requires careful
    planning, profiling, and an understanding of the hardware you are developing for.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore many techniques for optimizing render performance.
    We will cover both Flash's rendering pipeline and the hardware constraints that
    you will be working within. In addition, we will see how to take advantage of
    hardware acceleration, offloading much of the rendering workload from the CPU
    to the Graphics Processing Unit (GPU).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing vector and bitmap graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Flash provides bitmap support, it is primarily thought of as a vector
    animation tool. Vector content can be created and edited directly within the IDE,
    making vectors an obvious choice above bitmaps, which must be edited externally.
  prefs: []
  type: TYPE_NORMAL
- en: However, given the hardware constraints of mobile devices such as the iPhone,
    are vectors appropriate or should you consider using bitmaps in order to maximize
    performance?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two FLAs have been provided for this recipe and can be found within the book's
    accompanying code bundle at `chapter6\recipe1\`.
  prefs: []
  type: TYPE_NORMAL
- en: Both perform a simple render performance test. Each attempts to render ten instances
    of an animating movie clip. After five seconds, the test will end and the average
    number of frames per second (FPS) that was achieved will be shown. The higher
    that number, the faster the rendering performance of the test.
  prefs: []
  type: TYPE_NORMAL
- en: The first FLA`— recipe-vectors.fla —`uses vector artwork for each of the movie
    clip's animation frames. The second`—recipe-bitmaps.fla—`uses a bitmap representation
    for each.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps in order to run both tests on your device:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `recipe-vectors.fla` into Flash Professional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the library, you will find a symbol named **Monkey**, which contains
    a four-frame vector animation. Double-click on the symbol and explore its display
    list. Its construction is typical for a Flash project, containing many nested
    clips of vector artwork.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy `c6-r1-v.ipa`. On your device's home screen, find
    the app named **c6 r1 v** and launch it. Wait for five seconds and then take a
    note of the frame rate that was achieved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open `recipe-bitmaps.fla`. Double-click on the **Monkey** library symbol
    and explore its timeline. This FLA performs the same test as the first, except
    it uses a bitmap for each animation frame rather than vectors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy `c6-r1-b.ipa` to your device. Launch **c6 r1 b**
    and take a note of the frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rendering performance of each will vary across iOS devices but no matter
    what device you use, the bitmap-based animation will outperform the vector-based
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm this, let us take a look at the results of the two FLAs compiled
    from Flash Professional CS5 and run across a handful of devices. The following
    chart shows the average frame rate, measured in frames per second, that was achieved
    by each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1383_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results shown in this chart are an average taken from five runs of each
    test. Each device was running iOS 5 with the exception of the first-generation
    iPod touch, which had iOS 3.1 installed.
  prefs: []
  type: TYPE_NORMAL
- en: Use these results as a rough guide as they may vary slightly across runs.
  prefs: []
  type: TYPE_NORMAL
- en: So why do bitmaps render to the screen faster than vectors?
  prefs: []
  type: TYPE_NORMAL
- en: Vector graphics are represented by a combination of strokes, fills, colors,
    and gradients, with expensive mathematical calculations required in order to render
    them. Bitmaps on the other hand are simply a pixel-by-pixel representation of
    each color required by an image. With every single point of a bitmap already known,
    it can quickly be plotted to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: So does this mean you should exclusively use bitmaps in place of vectors when
    developing for iOS? Not necessarily. Unlike bitmaps, vector artwork can be scaled
    and translated without losing fidelity. This is due to the fact that vector graphics
    are represented mathematically. Another advantage of vectors is file size. In
    many cases, vectors consume significantly less space than their bitmap counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: However, if frame rate is critical to the success of your application, then
    you should always attempt to select the fastest rendering option. Also, be aware
    that doing so may come at the expense of increased memory usage, larger file sizes,
    and extended development times.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you opt to use vectors or bitmaps, adjusting the rendering quality can
    aid performance.
  prefs: []
  type: TYPE_NORMAL
- en: Stage quality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can further increase performance by reducing the rendering quality used
    by your app. This is especially useful if you are attempting to maximize your
    frame rate while manipulating complex vector artwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using ActionScript, set the `Stage.quality` property to one of the following
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StageQuality.HIGH:` Provides bitmap smoothing and anti-aliasing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StageQuality.MEDIUM:` Provides bitmap smoothing and uses lower quality anti-aliasing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StageQuality.LOW:` Does not smooth bitmaps or anti-alias graphics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three quality settings are available from AIR 3.0 with only low and medium
    quality being supported by AIR 2.0-2.7\. All versions of AIR for iOS use `StageQuality.MEDIUM`
    as the default setting.
  prefs: []
  type: TYPE_NORMAL
- en: Render quality is applied globally to all content within your application. Bitmaps,
    however, remain relatively unaffected and, with the exception of smoothing, will
    look identical across all quality settings. This conveniently allows you to get
    the highest level of performance from your vector assets without compromising
    the quality of any bitmaps within your application. You can repeatedly change
    the quality setting throughout your app's lifetime to best suit its needs at any
    particular moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try reducing the stage''s render quality within this recipe''s FLAs. Simply
    open the `Main.as` document class shared by both and add the following line of
    code at the start of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, add the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Publish and re-deploy both `.ipa` files.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering should now be faster although the quality of the vector artwork will
    be noticeably reduced. For many situations, this sacrifice may be acceptable,
    especially on a compact mobile device screen where any reduction in quality may
    be hard to spot.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Converting vectors to bitmaps, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resizing bitmaps, [Chapter 4](ch04.html "Chapter 4. Porting Flash Projects
    to iOS")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GPU-Blend mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike developing for the Flash desktop player, two rendering modes are available
    to those targeting AIR for iOS. Exactly the same software renderer that is present
    in the desktop player is provided as the first option and is handled by the device's
    CPU. The second allows you to take advantage of the device's GPU and can significantly
    improve rendering performance in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: A rendering mode must be selected before compiling your FLA for iOS and cannot
    be changed at runtime. It is, therefore, important to understand the differences
    between both modes and make a decision early on regarding which one you would
    like to support. The choice of renderer can dictate how you architect your application.
  prefs: []
  type: TYPE_NORMAL
- en: Although both Flash Professional CS5 and CS5.5 provide an option to perform
    rendering on the GPU, how that rendering mode is actually implemented is different.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will publish and deploy some example FLAs to help you understand
    the differences between the two modes. In particular, we will focus on the GPU-rendering
    mode provided by Flash Professional CS5.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two FLAs have been provided with the book's accompanying code bundle`—render-test-cpu.fla`
    and `render-test-gpu.fla—` and can be found at `chapter6\recipe2\`.
  prefs: []
  type: TYPE_NORMAL
- en: Both FLAs are identical, with each randomly re-positioning ten movie-clip instances
    on every frame update. After five seconds, the test will end and the average number
    of frames per second (FPS) that was achieved will be shown. The higher that number,
    the faster the rendering performance of the test.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, the FLAs should only be compiled using Flash Professional CS5\.
    However, if you are using CS5.5, read through the material covered here before
    moving to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us select a rendering mode for each FLA and see how they perform on an actual
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Open `render-test-cpu.fla` within Flash Professional CS5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File** | **iPhone OS Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **iPhone OS Settings** panel, select **CPU** from the **Rendering**
    field's drop-down box. Click on **OK** to confirm the change.![How to do it...](img/1383_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy `c6-r2-cpu.ipa` to your device. On your device's
    home screen, find the app named **c6 r2 cpu** and launch it. Take a note of the
    frame rate that was achieved by the test and then close the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open `render-test-gpu.fla`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File** | **iPhone OS Settings**. This time, set the panel's **Rendering**
    field to **GPU**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to close the panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish and deploy `c6-r2-gpu.ipa` to your device. Launch the app labeled **c6
    r2 gpu**. Take a note of the frame rate that was achieved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the iPhone OS Settings panel, we set a different rendering mode for each
    of the FLAs. Both FLAs performed an identical test but used a different rendering
    path. The first used the CPU to render all graphical content, while we selected
    the GPU for the second.
  prefs: []
  type: TYPE_NORMAL
- en: The following chart shows the results of running the tests on a selection of
    devices. The results show the frame rate, measured in frames per second, that
    was achieved by each test.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1383_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results shown in this chart are an average taken from five runs of each
    test. Each device was running iOS 5 with the exception of the first-generation
    iPod touch, which had iOS 3.1 installed.
  prefs: []
  type: TYPE_NORMAL
- en: Use these results as a rough guide as they may vary slightly across runs.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the actual results vary across device but surprisingly there
    is very little difference in performance between the two modes, with CPU being
    slightly faster. You likely expected GPU rendering to be significantly better
    than CPU but to understand why this was not the case, we need to examine the rendering
    process in a little more detail. In particular, we need to look at how GPU rendering
    is implemented by AIR 2.0 in Flash Professional CS5.
  prefs: []
  type: TYPE_NORMAL
- en: The rendering process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rendering is split into the following two distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Rasterization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scene composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During **rasterization,** every element within your display list is drawn to
    a separate off-screen pixel buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Once rasterization is complete, those pixel buffers are taken and are arranged
    to recreate the scene represented by the display list. This is known as **scene
    composition**.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether you are using Flash CS5 or CS5.5, both CPU and GPU modes
    will perform this rendering process. How each rendering mode achieves this, however,
    is different.
  prefs: []
  type: TYPE_NORMAL
- en: CPU mode and GPU-Blend mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using CPU mode, both rasterization and scene composition are performed
    entirely in software by the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Flash CS5, when GPU mode is selected, the device''s GPU will be used to
    compose the scene. Rasterization, however, is still performed by the CPU, with
    each of the off-screen pixel buffers being uploaded to the GPU for composition.
    In other words, the rendering process is only partially performed on the GPU.
    This is shown in the following illustrations. This implementation is known as
    GPU Blend and differs from that used by CS5.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CPU mode and GPU-Blend mode](img/1383_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table should help clarify the difference between CPU and GPU-Blend
    mode used by AIR 2.0 in Flash CS5:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Render mode | Rasterization | Scene composition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CPU | CPU | CPU |'
  prefs: []
  type: TYPE_TB
- en: '| GPU Blend | CPU | GPU |'
  prefs: []
  type: TYPE_TB
- en: The GPU found on iOS devices can compose a scene much faster than the CPU. However,
    the process of uploading the pixel buffers from the CPU to the GPU can be expensive
    because of the amount of data that has to be sent. Therefore, to benefit from
    GPU acceleration when using Flash CS5, you must minimize the amount of bitmap
    traffic going from the CPU to the GPU. In other words, you need to reduce the
    frequency with which display objects are re-rasterized.
  prefs: []
  type: TYPE_NORMAL
- en: Redrawing dirty regions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Re-rasterization takes place when content within a scene changes. Whenever
    changes occur, Flash takes a note of the rectangular regions within the scene
    that need to be redrawn. These are known as the dirty regions and are used as
    an alternative to simply rendering the entire screen again. This is illustrated
    in the following diagram where the star-shaped clip moves position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Redrawing dirty regions](img/1383_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the star movie clip changes position between frames and by
    doing so creates a dirty region. The dirty region is represented as a rectangular
    area that encompasses the space consumed by the star's previous and current location.
    The circle, background image, and the star itself all touch this dirty region
    meaning all three need to be re-rasterized. Any display objects that intersect
    a dirty region need to be re-rasterized.
  prefs: []
  type: TYPE_NORMAL
- en: When using GPU Blend, the bitmap data for each of the re-rasterized display
    objects needs to be uploaded to the GPU in order for compositing to take place.
    As stated, uploading to the GPU can be expensive.
  prefs: []
  type: TYPE_NORMAL
- en: For scenes that change frequently, the performance of your app may suffer when
    using GPU acceleration. This is why `render-test-gpu.fla` doesn't perform as well
    as you might expect. There are so many changes per frame that the bandwidth penalty
    from transferring the re-drawn pixel buffers to the GPU actually negates much
    of the performance gained from utilizing the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: There are techniques that can be employed to cache bitmap data directly on the
    GPU rather than continuously re-rasterizing and uploading from the CPU. We will
    discuss these shortly, but it should be clear that taking full advantage of AIR
    2.0's hardware acceleration isn't as simple as changing the rendering mode within
    the iPhone OS Settings panel.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One more thing, which you may have noticed when selecting a rendering mode
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Auto rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as CPU and GPU, there is an additional rendering option named **Auto**
    that is available. At this moment in time, **Auto** actually defaults to the CPU
    renderer and is, therefore, no different to selecting **CPU**. This is true for
    both Flash Professional CS5 and CS5.5.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding GPU-Vector mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GPU-Vector mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Understanding GPU-Blend mode* recipe, we spent time covering the intricacies
    of the GPU-rendering mode provided by Flash Professional CS5\. Although GPU rendering
    is also supported for those using Flash Professional CS5.5, its implementation
    differs from CS5's.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover how to select a rendering mode using CS5.5 and
    also use the same tests from the *Understanding GPU-Blend mode* recipe in order
    to see the performance difference between both GPU renderers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two FLAs have been provided`—render-test-cpu.fla` and `render-test-gpu.fla—and`
    can be found in the book's accompanying code bundle at `chapter6\recipe3\`.
  prefs: []
  type: TYPE_NORMAL
- en: Both FLAs are identical, with each randomly re-positioning ten movie-clip instances
    on every frame update. After five seconds, the test will end and the average number
    of frames per second (FPS) that was achieved will be shown. The higher that number,
    the faster the rendering performance of the test.
  prefs: []
  type: TYPE_NORMAL
- en: The FLAs should only be compiled using Flash Professional CS5.5\. However, it
    is recommended that those using CS5 read through the material covered here rather
    than skipping to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us select a different rendering mode for each FLA and see the performance
    differences between the two on an actual device.
  prefs: []
  type: TYPE_NORMAL
- en: Open `render-test-cpu.fla` within Flash Professional CS5.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File** | **AIR for iOS Settings** from Flash's drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the AIR for iOS Settings panel, select **CPU** from the **Rendering** field's
    drop-down box. Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy `c6-r3-cpu.ipa` to your device. From the home screen,
    launch the app labeled **c6 r3 cpu**. Let the app run for five seconds and then
    take a note of the frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open `render-test-gpu.fla`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to the **AIR for iOS Settings** panel and this time set the **Rendering**
    field to **GPU**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish and deploy `c6-r3-gpu.ipa` to your device. Launch **c6 r3 gpu** and
    take a note of the app's frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the AIR for iOS Settings panel, we set a different rendering mode for each
    of the test FLAs. Both FLAs performed an identical test but used different rendering
    paths. The first used the CPU to render all graphics content, while we selected
    the GPU for the second.
  prefs: []
  type: TYPE_NORMAL
- en: The following chart shows the results of running the tests on a selection of
    devices. Each result shows the average frame rate that was achieved by each test.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1383_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results shown throughout this recipe are an average taken from five runs
    of each test. Each device was running iOS 5.
  prefs: []
  type: TYPE_NORMAL
- en: Use these results as a rough guide as they may vary slightly across runs.
  prefs: []
  type: TYPE_NORMAL
- en: It should be apparent that impressive performance gains can be made when setting
    GPU rendering within Flash Professional CS5.5\. This is in stark contrast to the
    results from the *Understanding GPU-Blend mode* recipe where Flash Professional
    CS5 was used. Take the **iPhone 4** as an example. While there was no benefit
    from using the GPU when publishing from CS5, the same test published from CS5.5
    exhibited a 252% increase in render performance—23 frames per second using the
    CPU compared to 58 using the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chart lets you easily compare the GPU rendering results for `render-test-gpu.fla`
    across both versions of Flash Professional:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1383_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When published from CS5 and run on an iPhone 4, only an average of 17 frames
    per second were achieved over a five second period. Publishing the FLA using CS5.5
    managed 58 frames per second on the same device. Quite an improvement!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed in this chart that the GPU test compiled from Flash CS5.5
    was not run on the first-generation iPod touch. Support for ARM v6 devices such
    as the first-generation iPod touch was dropped in AIR 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: So why does GPU rendering produce such huge gains in CS5.5 compared to CS5?
    It is down to changes in how GPU rendering has been implemented since AIR 2.6,
    which we will now cover.
  prefs: []
  type: TYPE_NORMAL
- en: GPU-Vector mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GPU Blend, which is the GPU-render mode supported in Flash CS5, only actually
    performs scene composition on the GPU—rasterization takes place entirely on the
    CPU. The GPU-render mode supported by CS5.5, however, performs both rasterization
    and scene composition on the GPU, removing the need to transfer bitmap data from
    the CPU to the GPU. This implementation is known as GPU Vector and is many times
    faster than GPU Blend.
  prefs: []
  type: TYPE_NORMAL
- en: When GPU rendering is selected, GPU Vector will be used by AIR for iOS apps
    published from Flash Professional CS5.5, while apps published from CS5 will use
    GPU Blend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the various rendering modes and from which version
    of Flash and AIR each is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Render mode | Rasterization | Scene composition | Flash | AIR |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CPU | CPU | CPU | CS5 and CS5.5 | 2.0 - 3.x |'
  prefs: []
  type: TYPE_TB
- en: '| GPU Blend | CPU | GPU | CS5 | 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| GPU Vector | GPU | GPU | CS5.5 | 2.6 - 3.x |'
  prefs: []
  type: TYPE_TB
- en: When working with Flash Professional CS5, obtaining a high frame rate from even
    a modest FLA can be difficult without an understanding of GPU Blend and knowing
    how to minimize bitmap traffic between the CPU and GPU. On the other hand, those
    working with Flash Professional CS5.5 need not worry so much. GPU-Vector mode
    removes much of the hardship, making the process of writing AIR for iOS apps closer
    to writing for the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Use GPU mode ahead of CPU as it yields better performance. This is true for
    both CS5 and CS5.5, although those using CS5 will need to work a little harder
    in order to take advantage of the hardware acceleration provided by the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: GPU Vector is a very strong reason for upgrading from Flash Professional CS5
    to CS5.5\. Of course, if you are targeting older iOS devices such as the second-generation
    iPod touch or iPhone 3G, then you will still need to rely upon CS5 and GPU Blend.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The blazing-fast performance of GPU-Vector mode does come at a cost.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering vectors using GPU-Vector mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performance isn't the only noticeable difference between GPU-Blend and GPU-Vector
    modes. Whereas GPU Blend and CPU will produce identical renditions of vector artwork,
    GPU Vector won't always be so accurate.
  prefs: []
  type: TYPE_NORMAL
- en: The GPU is optimized for rendering bitmaps and doesn't provide the same fidelity
    as the software renderer when recreating the complex vector shapes used by Flash.
    GPU-Vector mode requires that Flash's vector shapes be converted to simpler triangles
    that can be rendered quickly by the GPU. GPU Blend on the other hand, performs
    all rasterization on the CPU, allowing it to take advantage of the software renderer
    at the expense of performance.
  prefs: []
  type: TYPE_NORMAL
- en: When using Flash Professional CS5.5, be aware that rendering vector artwork
    on the GPU won't be as precise as rendering on the CPU. CPU rendering is accurate
    but slow, whereas the GPU is faster but inaccurate. However, any differences between
    the two can be difficult to spot.
  prefs: []
  type: TYPE_NORMAL
- en: Using GPU-Vector mode with Flash Professional CS5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although Flash Professional CS5 only supports AIR 2.0, it is actually possible
    to take advantage of the GPU-Vector rendering mode supported by AIR 2.6 and above.
    To do this, you will need to first publish a SWF from Flash CS5, then package
    the SWF into a native iOS app from the command line using the AIR Development
    Tool (ADT). ADT is included with the latest AIR SDK and can be downloaded from
    [www.adobe.com/products/air/sdk](http://www.adobe.com/products/air/sdk).
  prefs: []
  type: TYPE_NORMAL
- en: 'Command line packaging is outside the scope of this book; however, Adobe does
    provide detailed documentation on the subject at: [http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html](http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Stage 3D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to AIR's existing rendering modes, Adobe has recently released a
    new rendering model named Stage 3D (previously codenamed Molehill), which leverages
    GPU hardware to provide advanced 2D and 3D capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Stage 3D is only available for Flash and AIR on the
    desktop. However, Adobe is actively working to bring it to mobile. When it arrives,
    Stage 3D's performance should far exceed what is currently possible with AIR for
    iOS's existing rendering pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about Stage 3D from Adobe Developer Connection at [www.adobe.com/devnet/flashplayer/stage3d.html](http://www.adobe.com/devnet/flashplayer/stage3d.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cache as Bitmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rasterization can be expensive and should be minimized. For display objects
    that only experience translation along the X and Y axes, there is a technique
    available that removes the need for that object to be re-rasterized. This technique
    is known as Cache as Bitmap and in most circumstances can accelerate the rendering
    performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Cache as Bitmap takes a display object and generates a bitmap representation
    of it internally. The cached bitmap is then used for rendering rather than re-rasterizing
    the original display object. This can result in huge performance gains, particularly
    when working with complex vector artwork, which can be CPU-intensive to rasterize.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when a display object changes position, it needs to be re-rasterized.
    When cached, however, any two-dimensional translations will no longer result in
    that object being redrawn. Instead, its cached bitmap will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how to apply Cache as Bitmap using both ActionScript and the Flash
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before continuing you should be aware of the difference between vector and
    bitmap graphics, and also have a firm understanding of the various rendering paths
    available when developing AIR for iOS apps. If you haven''t already done so, complete
    the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Comparing vector and bitmap graphics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding GPU-Blend mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding GPU-Vector mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An FLA has been provided for this recipe and can be found within the book's
    accompanying code bundle at `chapter6\recipe4\recipe.fla`.
  prefs: []
  type: TYPE_NORMAL
- en: Its document class positions ten instances of a **Monkey** movie clip on top
    of a **Background** movie clip. On every frame update, the ten monkeys are randomly
    repositioned. After a period of five seconds, the average frame rate that was
    achieved is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The movie clips used for this recipe are constructed from vector graphics as
    opposed to bitmaps. Also, this recipe's FLA has been set to use GPU rendering.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first see how the existing version of the FLA performs before taking
    advantage of bitmap caching.
  prefs: []
  type: TYPE_NORMAL
- en: Open `recipe.fla`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the current version of the FLA and deploy it to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the app from your device's home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a note of the frame rate; then delete the app from your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move back to `recipe.fla` within Flash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us apply Cache as Bitmap to the display objects used by the FLA. Using the
    **Selection Tool (V)**, click on the **Background** movie clip sitting on the
    stage. From the **Properties** panel, expand the **DISPLAY** section and enable
    Cache as Bitmap. If you are using Flash Professional CS5, then this is done by
    checking the **Cache as bitmap** checkbox. For CS5.5, select **Cache as Bitmap**
    from the **Render** field's drop-down box.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the FLA''s document class and add the following line of code within the
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish and deploy the new version to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the frame rate against the previous version of the app. The app's performance
    should be noticeably improved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DisplayObject` class provides the `cacheAsBitmap` property, which is available
    from any class that extends `DisplayObject`, such as `Sprite` and `MovieClip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used ActionScript to set the `cacheAsBitmap` property for each of the **Monkey**
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the **Background** movie clip sitting on the stage, caching was activated
    through the **Properties** panel.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why bitmap caching can be beneficial, let us start by examining
    what happens within this recipe's example when Cache as Bitmap isn't set.
  prefs: []
  type: TYPE_NORMAL
- en: On each frame update, the position of the ten **Monkey** movie-clip instances
    is changed, forcing a dirty region to be created for each of the ten clips. Although
    the **Background** movie clip doesn't change position, it falls within the dirty
    regions. Therefore, on each frame update, the **Background** and all ten **Monkey**
    instances need to be re-rasterized before being composited into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: By taking advantage of Cache as Bitmap, the rendering time for each frame can
    be reduced. After setting Cache as Bitmap, each clip is initially rasterized and
    an internal representation is stored. Now on each frame update, there will be
    no need to re-rasterize any of the **Monkey** movie clips or the **Background**
    movie clip, as a cached bitmap representation of each is available and can be
    used during scene composition.
  prefs: []
  type: TYPE_NORMAL
- en: On every frame update other than the first, we have managed to completely skip
    rasterization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether using Flash Professional CS5 or CS5.5, you should have experienced
    a significant performance increase by using Cache as Bitmap. The following chart
    gives you the results from publishing this recipe''s example using CS5 and testing
    it on a handful of devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1383_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the following chart shows the same test published using CS5.5 and AIR 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1383_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results shown in these charts are an average taken from five runs of each
    test. Each device was running iOS 5 with the exception of the first-generation
    iPod touch, which had iOS 3.1 installed.
  prefs: []
  type: TYPE_NORMAL
- en: Use these results as a rough guide as they may vary slightly across runs.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the charts, Cache as Bitmap can significantly increase your
    application's frame rate when using complex vector artwork. This does come at
    the expense of memory; however, as an additional bitmap for each display object
    must be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Although we utilized GPU rendering in this recipe, using Cache as Bitmap in
    conjunction with CPU rendering will also lead to performance increases when dealing
    with complex vector artwork. Caching directly on the GPU, however, produces the
    largest performance increase.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cache as Bitmap is extremely powerful and when used correctly can be hugely
    beneficial. However, it is not always apparent when to use it and there are several
    pitfalls that you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Other transformation changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitmap caching is only advantageous if the cached bitmap does not have to be
    frequently re-generated. While changes along the X or Y axes are fine, other changes
    will invalidate the cached bitmap, forcing the display object to be re-cached.
  prefs: []
  type: TYPE_NORMAL
- en: For objects that don't change often, you may be willing to take the performance
    hit. However, frequent changes are likely to degrade the performance of your application,
    as each new change is rasterized and then copied back into the internal pixel
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of changes that will force a display object to be re-cached:'
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpha transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation—Scale and Rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playhead movement within the object's timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change to a child object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constantly re-caching is very expensive and will slow your application. If you
    need to make frequent changes to an object, then either avoid using Cache as Bitmap,
    or deactivate it during such periods. Improper use of Cache as Bitmap will reduce
    the render performance of your application rather than improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Caching display objects that contain children
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when setting Cache as Bitmap on display objects that contain children.
  prefs: []
  type: TYPE_NORMAL
- en: An internal bitmap will be created of the entire container including all of
    its child objects. If any of those children change relative to the container,
    then the whole container clip will need to be re-cached. This is true even if
    a child object only changes its `x` or `y` position. It is only the container
    clip that can be successfully translated without invalidating the cached bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: For nested clips, apply Cache as Bitmap to the lowest leaf node that changes
    relative to its container. Don't apply Cache as Bitmap to the container itself.
  prefs: []
  type: TYPE_NORMAL
- en: This is a common mistake and can cripple the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of GPU Blend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Flash Professional CS5 and wish to take advantage of GPU rendering,
    then the use of Cache as Bitmap is essential for GPU Blend to be effective. It
    isn't just vectors that can benefit either—bitmap performance can be accelerated
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Where cached bitmaps are stored is important. When using GPU rendering, the
    cached bitmaps will be stored directly on the GPU as textures. This is of particular
    importance when using GPU Blend as it removes the bandwidth bottleneck experienced
    when bitmap data is repeatedly transferred from the CPU to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: By using bitmap caching in conjunction with GPU Blend, rendering performance
    will be vastly increased. The only time bitmap data will be transferred from the
    CPU to the GPU will be when each display object is initially cached, or when a
    cached bitmap needs to be regenerated.
  prefs: []
  type: TYPE_NORMAL
- en: For GPU Blend, Cache as Bitmap will accelerate both display objects that use
    vectors and those that use bitmaps. Where possible, try to take advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: Bitmaps and GPU Vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While applying Cache as Bitmap to bitmaps provides acceleration for GPU Blend,
    the same isn't true for GPU Vector and will actually slightly degrade performance.
  prefs: []
  type: TYPE_NORMAL
- en: When you cache a display object, you are essentially creating a pixel buffer.
    However, that is exactly what a bitmap is anyway. By caching bitmaps when using
    GPU Vector, you are simply creating a secondary copy of your bitmap, which will
    only consume more memory and take time to perform the second copy.
  prefs: []
  type: TYPE_NORMAL
- en: In GPU-Blend mode, Cache as Bitmap is used to copy the bitmaps to GPU memory.
    In GPU-Vector mode, the bitmaps are already in GPU memory, removing the need for
    Cache as Bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: Using vectors ahead of bitmaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with vector artwork, Cache as Bitmap can be used to produce the
    performance benefits typically associated with bitmaps. Simply create your artwork
    using Flash's drawing tools and then set Cache as Bitmap for each movie clip that
    contains that vector artwork. The clips will be rasterized and the cached bitmap
    versions will be used from that point onwards.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is almost as fast as simply using a bitmap representation of
    your artwork. The only difference being is that a vector version first has to
    be converted to a bitmap, which will result in a slight performance hit when the
    object first appears on screen. If the size of your IPA is a concern or you genuinely
    need to use vector artwork, then this option is ideal.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding content to the stage, [Chapter 2](ch02.html "Chapter 2. Building iOS
    Apps Using Flash")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Masking content, [Chapter 4](ch04.html "Chapter 4. Porting Flash Projects
    to iOS")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cache as Bitmap Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cache as Bitmap is extremely useful for display objects that are only affected
    by two-dimensional translation. However, it is also possible to benefit from bitmap
    caching when applying other changes to a display object such as scaling and rotation.
    This is achieved by using a transform matrix in conjunction with a cached bitmap
    and is known as Cache as Bitmap Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Let us work through an example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point. From the book's accompanying code
    bundle, open `chapter6\recipe5\recipe.fla` into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Ten instances of a **Monkey** movie clip are positioned on top of a **Background**
    movie clip. All ten movie clips are continuously rotated and after five seconds,
    the average frame rate that was achieved is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The movie clips used for this recipe are constructed from vector graphics and
    the FLA has been set to use GPU rendering.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Work through the following steps to see the performance benefit Cache as Bitmap
    Matrix provides for each of the rotating movie clips.
  prefs: []
  type: TYPE_NORMAL
- en: Publish the current version of the FLA and deploy it to a device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the app and take a note of the frame rate that is reported after five
    seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the app from your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move back to `recipe.fla` within Flash Professional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the FLA''s `Main.as` document class and add the following lines of code
    within the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add an import statement for the `Matrix` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the document class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish and deploy to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the number of frames rendered against the previous version of the app.
    It should be improved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cache as Bitmap Matrix prevents a display object's cached bitmap from becoming
    invalid when any two-dimensional transformation is applied. The same is also true
    for a change in visibility or alpha transparency. Therefore, for any of these
    changes, the cached bitmap won't be regenerated; the changes will instead be applied
    directly to the cached bitmap's internal pixel buffer, which is advantageous as
    the display object won't need to be re-rasterized.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Cache as Bitmap, Cache as Bitmap Matrix cannot be set from Flash's **Properties**
    panel. Instead, use ActionScript to set the `cacheAsBitmapMatrix` property provided
    by the `DisplayObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `cacheAsBitmapMatrix` property is set by passing it a `Matrix` object and
    is used to generate the cached bitmap. For this recipe, we passed the identity
    matrix, which forced the display objects to be rasterized without any change in
    appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In mathematics, a matrix is a rectangular array of numbers, which can be used
    to apply a transformation to points in 2D or 3D space. A matrix can be used to
    apply various graphical transformations to Flash display objects, such as translation,
    rotation, scaling, and skewing. An identity matrix is a special matrix that does
    not alter the appearance of any points that it is applied to.
  prefs: []
  type: TYPE_NORMAL
- en: The `flash.geom.Matrix` class is provided by the Flash API, making it easy to
    create matrices that can be used to perform transformations upon your display
    objects. When instantiating a `Matrix` object, an identity matrix is created if
    you do not provide any parameters to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cacheAsBitmapMatrix` property cannot be used on its own and must always
    be set in conjunction with the `cacheAsBitmap` property. You can see this in the
    following code snippet taken from this recipe''s example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you have already applied Cache as Bitmap on a display object, then there
    is no penalty for also applying Cache as Bitmap Matrix. In fact, this is the recommended
    practice as it will prevent performance penalties if changes other than to an
    object's `x` and `y` properties are made.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows the benefits of using Cache as Bitmap Matrix by highlighting
    changes that won't invalidate the cached bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Translate | Scale | Rotate | Skew | Alpha | Visibility |'
  prefs: []
  type: TYPE_TB
- en: '| `cacheAsBitmap` | ![How it works...](img/icon1.jpg) |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `cacheAsBitmap` and `cacheAsBitmapMatrix` | ![How it works...](img/icon1.jpg)
    | ![How it works...](img/icon1.jpg) | ![How it works...](img/icon1.jpg) | ![How
    it works...](img/icon1.jpg) | ![How it works...](img/icon1.jpg) | ![How it works...](img/icon1.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: When scaling or rotating a vector display object that has been cached, there
    may be a loss of fidelity as the transformations will be applied to the cached
    bitmap rather than to the original vector artwork. Therefore, the final rendition
    will exhibit the artifacts associated with scaling or rotating bitmap images.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `cacheAsBitmapMatrix` property generates a cached bitmap even if
    the display object is off-screen or has its `visible` property set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious about matrices, then perform a search for `flash.geom.Matrix`
    within Adobe Community Help. For a better understanding of matrix mathematics,
    refer to Wikipedia: [http://en.wikipedia.org/wiki/Matrix_(mathematics)](http://en.wikipedia.org/wiki/Matrix_(mathematics)).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let us explore Cache as Bitmap Matrix in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a matrix transformation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The matrix transformation you set the `cacheAsBitmapMatrix` property to will
    be used to generate the cached bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you may choose to use a scale matrix to create a cached version
    of a vector movie clip that is actually twice the movie clip's original size.
    Although the cached bitmap would consume more memory, it would allow the movie
    clip to maintain its fidelity when being scaled to a maximum of twice its size.
    Alternatively, you could cache a version that is half the size of the original,
    reducing memory overheads at the expense of fidelity.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that creating a cached bitmap that is different in size
    to the actual display object doesn't alter the size of the object on screen. In
    other words, if your display object is 100x100 pixels in size and its cached bitmap
    is 50x50 pixels, the object will remain 100x100 pixels in size on screen. AIR
    will take the 50x50 cached bitmap and actually double its dimensions to ensure
    it is shown at the correct size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows how to create a cached bitmap that is half
    the size of the actual display object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, generally the identity matrix will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Changing the Matrix object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common pitfall is attempting to apply two-dimensional transformations to a
    display object by altering the `cacheAsBitmapMatrix` transform. Making changes
    to this matrix will actually invalidate the cache, forcing a new bitmap to be
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: To apply transforms such as scaling and rotation to your display object, simply
    use its two-dimensional transformation properties such as `scaleX, scaleY`, and
    `rotation`.
  prefs: []
  type: TYPE_NORMAL
- en: For most use cases, the `cacheAsBitmapMatrix` property should be set once for
    a display object, and then left untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing the Matrix object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are applying the same transformation matrix to a series of display objects,
    then create a single instance of the `Matrix` object and re-use it. It is a common
    mistake to recreate the `Matrix` object each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code will compile and run but will create 100 copies of the identity matrix.
    This will unnecessarily consume memory and degrade performance due to the number
    of memory allocations and eventual garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, create the matrix outside of your loop and re-use it as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 3D properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a display object has a 3D property applied to it, that object automatically
    becomes cached and you have no control over the transformation matrix that is
    used to generate the cached bitmap. The `cacheAsBitmapMatrix` property can only
    be used with display objects that don't have any 3D properties set. If you set
    a 3D property, such as `z` or `rotationX`, on a display object that has bitmap
    caching applied, then your cached bitmap will be deactivated and a new bitmap
    will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Using 3D properties provides most of the benefits of manually setting the `cacheAsBitmapMatrix`
    property. The one exception is that setting a 3D object's `visible` property to
    `false` will invalidate its cached bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GPU Blend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the largest performance gains are once again to be had when using AIR
    2.0's GPU-Blend rendering mode.
  prefs: []
  type: TYPE_NORMAL
- en: If you have been using Flash Professional CS5 and developing on an older iOS
    device, then the examples from the *Rotating an object* and *Zooming an object*
    recipes in [Chapter 5](ch05.html "Chapter 5. Multi-touch and Gesture Support")
    may have performed poorly. Setting the `cacheAsBitmap` and `cacheAsBitmapMatrix`
    properties will ensure the movie clip used in each example is stored and transformed
    directly on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'If performance was an issue, then revisit these recipes and add the following
    two lines of code to the constructor within each FLA''s document class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, remember to import the `Matrix` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is also worth noting that it is not just vector graphics that benefit from
    Cache as Bitmap Matrix when using GPU Blend. Cache as Bitmap Matrix will also
    accelerate the rendering of bitmaps that have two-dimensional transformations
    applied to them. However, the opposite is true for GPU Vector, where Cache as
    Bitmap Matrix will actually harm performance when using bitmaps.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Rotating an object, [Chapter 5](ch05.html "Chapter 5. Multi-touch and Gesture
    Support")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zooming an object, [Chapter 5](ch05.html "Chapter 5. Multi-touch and Gesture
    Support")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing bitmaps with ActionScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GPU found on iOS devices is optimized for rendering bitmaps rather than
    the complex vector shapes that can be produced using Flash. This makes bitmaps
    the preferred graphics option when building high performance apps. While bitmaps
    can be stored in the library and simply dragged to a timeline during development,
    they can also be directly manipulated at runtime using ActionScript.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to add a bitmap to the display list at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter6\recipe6\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Sitting in the library is a bitmap named **monkey.png**. We will write code
    to add this bitmap to the display list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will split this recipe into two parts. First we will export the bitmap for
    ActionScript usage, before actually writing some ActionScript to display it at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the bitmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us start by exporting the bitmap's data for ActionScript usage.
  prefs: []
  type: TYPE_NORMAL
- en: Within the library, right-click on **monkey.png** and select **Properties**
    from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Bitmap Properties** dialog box, set the **Compression** field to
    **Lossless (PNG/GIF)**. If you are using Flash Professional CS5.5, then ensure
    that the **Options** tab is selected first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now check the **Export for ActionScript** checkbox and change the text within
    the **Class** field to `MonkeyBitmapData`. If you are using Flash Professional
    CS5.5, then this should be performed from the panel's **ActionScript** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A warning panel will appear containing the following text:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A definition for this class could not be found in the classpath, so one will
    be automatically generated in the SWF file upon export.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the expected behavior. Click on **OK.**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displaying the bitmap using ActionScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the bitmap's data now accessible to ActionScript, let us go ahead and write
    some code to display it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the constructor add a line of ActionScript to create an instance of
    the bitmap data sitting in the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a `Bitmap` object that uses the bitmap data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, position the bitmap and add it to the display list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class as `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA and test using ADL. The bitmap image stored in the library will
    be displayed on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy it to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to access an image within the library, you need to explicitly export
    the image's bitmap data for ActionScript usage. We did this by assigning the bitmap
    a unique class name of `MonkeyBitmapData` from the **Bitmap Properties** dialog
    box. By using this class name, it is then possible to create an instance of that
    bitmap data using ActionScript.
  prefs: []
  type: TYPE_NORMAL
- en: Once the bitmap data was obtained, we simply created a `Bitmap` display object
    and passed it a reference to the bitmap data. Displaying it was then a simple
    case of setting the bitmap's `x` and `y` properties before adding it to the display
    list.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the class you linked the bitmap to is automatically
    generated when the SWF is published—there is no need to write code as it is done
    for you. When generated, it will inherit from `flash.display.BitmapData` allowing
    you to treat any instances of it as a `BitmapData` object.
  prefs: []
  type: TYPE_NORMAL
- en: Every bitmap you export for ActionScript will be included directly within your
    app's binary, which will increase both its initial load time and memory footprint.
    Be careful as there is no way to free these bitmaps from memory once you are finished
    with them—an app that supports both standard and Retina graphics for example,
    could easily exhaust memory using this technique. However, with the bitmap data
    stored directly within the app's binary, access to that data will be fast.
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding bitmaps, perform a search for `flash.display.Bitmap`
    and `flash.display.BitmapData` within Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are performance gains to be had when using bitmaps. The following information
    will help you take full advantage of GPU acceleration when working directly with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing image sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using GPU rendering and working with bitmap images, then there are
    some optimizations you can perform to maximize performance.
  prefs: []
  type: TYPE_NORMAL
- en: The GPU allocates memory using powers of 2 for each of a bitmap's dimensions.
    For example, a 31x15 bitmap will be allocated the same amount of memory as a 32x16
    bitmap, while a 33x17 bitmap will consume the same memory as a 64x32 bitmap. The
    size of each bitmap also impacts rendering performance, as memory copies take
    longer for larger bitmaps.
  prefs: []
  type: TYPE_NORMAL
- en: Use bitmaps with dimensions that are close to a power of 2 but not larger. The
    dimensions don't have to be exact powers of 2, as Flash will pad the bitmaps for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Size restrictions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a size restriction imposed by the GPU. The actual size depends on
    the iOS hardware you are using. For older devices, your display objects cannot
    exceed 1024x1024 pixels in size. The more recent devices allow display objects
    with a maximum of 2048x2048 pixels in size. The following table summarizes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | iPhone | iPod touch | iPad |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | original and 3G | 3GS and 4/4S | 1st and 2nd gen | 3rd and 4th gen |
    1 and 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1024x1024 | ![Size restrictions](img/icon1.jpg) |   | ![Size restrictions](img/icon1.jpg)
    |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 2048x2048 |   | ![Size restrictions](img/icon1.jpg) |   | ![Size restrictions](img/icon1.jpg)
    | ![Size restrictions](img/icon1.jpg) |'
  prefs: []
  type: TYPE_TB
- en: If you need to work with a display object that is larger than the size permitted
    by the GPU, then consider using Cache as Bitmap Matrix to cache a smaller representation
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Storing bitmap data on the GPU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When utilizing GPU rendering, any `BitmapData` that you export for ActionScript
    will be stored directly in GPU memory as a texture when instantiated. This is
    the case for both Flash Professional CS5's GPU-Blend mode and CS5.5's GPU-Vector
    mode, providing the fastest possible rendering path for both.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to explicitly set a `Bitmap` object's `cacheAsBitmap` and `cacheAsBitmapMatrix`
    properties, as the bitmap data used by it will already be GPU-accelerated. In
    fact, doing so will only serve to create a duplicate copy of the data that is
    already on the GPU, which would be a waste of memory.
  prefs: []
  type: TYPE_NORMAL
- en: While display objects that have bitmap caching applied to them become textures,
    `BitmapData` objects *are* textures on the GPU. This distinction is important
    and has implications when managing memory. When working with multiple `Bitmap`
    instances, each bitmap can be made to point to the exact same `BitmapData` object,
    meaning only one texture is required on the GPU and shared by all. Applying bitmap
    caching to multiple instances of the same display object, however, uploads an
    individual texture for each, consuming more memory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loading bitmaps at runtime*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading bitmaps at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common practice to minimize an app's up-front load time and memory footprint
    by loading graphics resources on demand. When making use of bitmaps, it is possible
    to store them outside of your app's binary and use ActionScript to load them at
    runtime when required.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter6\recipe7\recipe.fla`
    into Flash Professional. Its AIR for iOS settings have been applied and a dynamic
    text field has been added at the bottom of the stage.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `chapter6\recipe7\monkey.png` has been provided, which is the
    bitmap we will load at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is split into two parts. First, we will bundle the bitmap with the
    app, then we will write some ActionScript to load it.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling the bitmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perform the following steps to bundle the bitmap with the app.
  prefs: []
  type: TYPE_NORMAL
- en: Open the **AIR for iOS Settings** panel and ensure that the panel's **General**
    tab is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the panel is the **Included files** list. Click on the **+**
    symbol above the list and select **monkey.png** from your FLA's root folder. Click
    on **Open** to select the file. You should now see **monkey.png** in the **Included
    files** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to close the **AIR for iOS Settings** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loading the bitmap at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let us write the ActionScript required to load the bitmap and display it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the constructor, create an instance of the `Loader` class; listen for
    `Event.COMPLETE` being dispatched when the bitmap has loaded; and initiate the
    load:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, add a handler for `Event.COMPLETE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `bitmapLoaded()` handler will add the loaded bitmap to the stage. The bitmap
    is obtained from the handler's event parameter, positioned then added to the display
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the class; when prompted name the file `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the FLA and test using ADL to ensure there are no compiler errors. The
    bitmap should load and be positioned on screen. Additionally, the text field should
    be populated with the word **loaded** indicating success.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, publish your app for iOS and deploy it to a device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resources can be bundled with an app by adding them to the **Included files**
    list from the AIR for iOS Settings panel. You can either add files individually
    or include the contents of a folder. For this recipe, we simply selected the `monkey.png`
    file, ensuring it would be bundled with the IPA.
  prefs: []
  type: TYPE_NORMAL
- en: Your app's start-up time won't be affected by this as bundled resources aren't
    part of its binary. Instead, during installation, they will be copied to the same
    directory as the app, allowing the app to load them from the device's file system
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To actually load the bitmap, an instance of the `Loader` class was used and
    a call to its `load()` method was made. Load operations are asynchronous—loading
    from the device's file system can take time—meaning we had to listen for `Event.COMPLETE`
    being dispatched before attempting to access the bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `monkey.png` being bundled into the same folder as the app itself, a relative
    file path was passed to `load()` rather than an absolute path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once the bitmap has loaded, the `COMPLETE` event's handler is called and the
    bitmap is displayed on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually obtain the bitmap, simply extract the loaded content from the `Event`
    object and cast it to a `Bitmap`. The following line of code does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You are then free to manipulate the bitmap and add it to the display list.
  prefs: []
  type: TYPE_NORMAL
- en: Loading bitmaps at runtime rather than including them directly within your FLA's
    library will reduce the overall size of an app's binary, which will lead to improved
    start-up times. Additionally, in contrast to resources embedded directly within
    the app's binary, you will be able to manage your app's memory usage by freeing
    those bitmaps once you are done with them. While bitmaps directly included within
    the app will be immediately available, you will actually need to wait for bitmaps
    from the file system to load.
  prefs: []
  type: TYPE_NORMAL
- en: The `Loader` class loads content asynchronously. This is convenient as it prevents
    the execution of your application from being blocked while resources are being
    loaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain more detail regarding the classes used in this recipe from Adobe
    Community Help. Specifically, take a look at `flash.display.Loader, flash.display.Bitmap`,
    and `flash.display.BitmapData`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on, let us cover a few more points related to bitmap data.
  prefs: []
  type: TYPE_NORMAL
- en: Handling load errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When loading bitmaps, you should also listen for `IOErrorEvent.IO_ERROR`, which
    is dispatched when a load operation fails. This will most commonly happen when
    a file path is incorrect or the resource that you are trying to load is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the bitmap's data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can easily access the bitmap''s data through the `Bitmap.bitmapData` property.
    The following code snippet illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to point the `bitmapData` property to a different `BitmapData`
    object, changing the bitmap's appearance. This is extremely useful for creating
    animations programmatically and can be used to fully utilize hardware acceleration
    on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Disposing of bitmap data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While you typically rely on the garbage collector to free memory, you can force
    AIR, at runtime, to immediately release the bitmap data memory occupied by a `BitmapData`
    object. This is done by calling `BitmapData.dispose()` and is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `BitmapData` object itself isn't released, just its bitmap data. The memory
    consumed by the actual `BitmapData` object is eventually released by the garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: When you no longer have a use for a bitmap, remember to dispose of its data.
    This will free memory, allowing you to load other bitmaps that couldn't otherwise
    be loaded and stored. You should, however, be careful when freeing bitmap data
    memory. Memory management can consume precious CPU cycles and hinder the performance
    of your application. You should attempt to free memory at convenient opportunities
    when the performance of your app isn't critical.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with external SWFs, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing bitmaps with ActionScript*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with sprite sheets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with sprite sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with multiple bitmap resources, you may want to consider using
    a sprite sheet. A **sprite sheet** is a single bitmap that holds a collection
    of individual images. Typically, the sheet is separated into a grid with each
    image occupying identically sized slots.
  prefs: []
  type: TYPE_NORMAL
- en: Once a sprite sheet is loaded into memory, the bitmap data for its individual
    images can be extracted and stored separately. This allows the data for each image
    to be accessed quickly by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter6\recipe8\recipe.fla`.
    The majority of the FLA's AIR for iOS settings have been applied as a starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a bitmap named `sprite-sheet.png` has been provided within the
    same folder as the FLA. Take a look at the bitmap in an image editor such as Adobe
    Photoshop. It contains a collection of images that we will extract and store in
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by bundling the bitmap with your app.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, open the **AIR for iOS Settings** panel and ensure that the panel's
    **General** tab is selected. Click on the **+** symbol above the **Included files**
    list and select `sprite-sheet.png` from the FLA's root folder. Finally, click
    on **OK** to close the **AIR for iOS Settings** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let us write some ActionScript to load the sprite sheet before cutting
    it into individual bitmaps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sprite sheet contains four images aligned in a 2x2 grid. Each image is
    192x256 pixels in size. Store this information within your class by adding the
    following constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a member variable of type `Array` that will be used to store the bitmap
    data for each of the images once they have been extracted from the sprite sheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us also add a member variable of type `Bitmap`, which will be used to verify
    that the bitmaps have been extracted by displaying one of them on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the constructor, use the `Loader` class to load the sprite sheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the handler that will be called when the sprite sheet has loaded. The
    handler itself will call two methods`—sliceSpriteSheet()` and `createMonkey()`.
    The first will extract the bitmap data from the sprite sheet, while the second
    will create and display a bitmap object that will use the bitmap data from one
    of the extracted images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the method that actually extracts the bitmap data for each of the
    sprite sheet''s images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the method that creates a bitmap that uses the bitmap data from
    the first image cut from the sprite sheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your document class as `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your FLA and test it using ADL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SWF will load the sprite sheet, extract the data for all four images, then
    display the first of those images on screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once satisfied, publish for iOS and deploy the app to a device for testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bulk of this recipe's work is performed within the `sliceSpriteSheet()`
    method. Using a nested `for` loop, it traverses the sheet's bitmap data, copying
    the data for each of the images into their own `BitmapData` objects. Each of these
    `BitmapData` objects is added to the `bitmaps` array for use later.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data has been extracted, the sprite sheet's own bitmap data is released
    from memory. The sprite sheet itself is no longer required as the bitmap data
    for each of its images is now stored individually within the `bitmaps` array and
    can be easily accessed from there.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the `bitmaps` array as a library, with each index position representing
    a different image. If you are using GPU-rendering mode, then the data for each
    image will be stored as a texture in video memory providing hardware acceleration
    when rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Using any of these images is as easy as creating a `Bitmap` object and pointing
    its `bitmapData` property to one of the `BitmapData` objects stored within the
    `bitmaps` array. Alternatively, you can pass one of the `BitmapData` references
    into the `Bitmap` object's constructor. Within the `createMonkey()` method, we
    simply created a `Bitmap` object that used the first image (index position `0)`
    stored within the `bitmaps` array. Although, we could just as easily have used
    the bitmap data from one of the other three images.
  prefs: []
  type: TYPE_NORMAL
- en: As with the sprite sheet, you can call `dispose()` on any of the `BitmapData`
    objects stored within the `bitmaps` array in order to release them from memory.
    It is important that you do this when any of the `BitmapData` objects are no longer
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite sheets have many advantages. When working with multiple bitmap images
    that are loaded at runtime, a sprite sheet requires only a single load request.
    This is significantly faster than loading individual bitmaps from the file system.
    Also, in addition to using identically sized slots for each bitmap, it is possible
    to tightly pack arbitrary-sized bitmaps into a sprite sheet. Doing so can lead
    to savings when holding the sprite sheet in memory compared to storing each individual
    bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: The use of sprite sheets is the de facto standard for working with bitmaps in
    many development environments and frameworks. For example, native iOS and Android
    frameworks such as Cocos2D, Sparrow, and Corona take advantage of sprite sheets.
    Both the Starling and ND2D ActionScript 3.0 frameworks, which are built on top
    of Stage 3D, also rely on sprite sheets when using their hardware-accelerated
    2D graphics APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, don't confuse sprite sheets with Flash's `Sprite` class. Any of Flash's
    display objects that support bitmaps can be used to render content from within
    a sprite sheet, not just the `Sprite` class.
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain more detail regarding the classes used in this recipe from Adobe
    Community Help. Specifically, take a look at `flash.display.Loader, flash.display.Bitmap`,
    and `flash.display.BitmapData`. Spend some time looking at `BitmapData.copyPixels()`
    which is used to copy data from the sprite sheet into each individual `BitmapData`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following are a few more things to consider when working with sprite sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprite sheets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many great tools for creating sprite sheets. Take a look at TexturePacker,
    which is freely available for both Mac OS X and Microsoft Windows at [www.texturepacker.com](http://www.texturepacker.com).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing performance and memory consumption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extracting and storing the bitmap data for each individual image provides the
    fastest access to that data when it is eventually required by your app. However,
    cutting the sprite sheet into individual `BitmapData` objects may come at the
    cost of memory, especially when rendering directly on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: The GPU allocates memory using powers of 2 for each of a bitmap's dimensions.
    When creating a sprite sheet, you can use this knowledge to your advantage, packing
    and arranging images into the sheet until its dimensions are exact powers of 2\.
    However, this may not be the case for the individual images contained within the
    sheet, and can lead to significant memory overheads once the bitmap data for all
    the images has been extracted.
  prefs: []
  type: TYPE_NORMAL
- en: Consider carefully your artwork when creating bitmap images. If performance
    is of the utmost importance, then you may need to accept these memory overheads.
    Otherwise consider an alternative approach—perhaps keeping the sprite sheet in
    memory and extracting only the data that you need at a particular moment in time.
    This of course will be slower than extracting all the image data up-front but
    is a viable option, which is often used by professional developers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with external SWFs, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Accessing bitmaps with ActionScript*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Loading bitmaps at runtime*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performing bitmap animation with ActionScript*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing bitmap animation with ActionScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might be the obvious choice for most situations, but the timeline isn't the
    only way to perform frame-by-frame animation. With a collection of `BitmapData`
    objects stored in memory, it is perfectly possible to apply animations to `Bitmap`
    objects using ActionScript.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to do that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can continue to work with the code you wrote during the *Working with sprite
    sheets* recipe. Alternatively, open `chapter6\recipe9\recipe.fla` from the book's
    accompanying code bundle and work from there. You will also find the FLA's document
    class and a sprite sheet in the same folder. The sprite sheet has already been
    added to the **Included files** list in the FLA's **AIR for iOS Settings** panel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will perform the animation by cycling through each of the bitmaps cut from
    the sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Open the FLA's document class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constant that stores the number of frames within the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need a member variable that keeps track of the current frame being
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `bitmapLoaded()` method, listen for `Event.ENTER_FRAME`. Its event
    handler will act as the app''s main loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let us add the method for the main loop. On each call, it will point the
    `monkey` bitmap to a different `BitmapData` object, essentially causing the bitmap
    to animate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your document class and your FLA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the FLA in ADL. You should now see the `monkey` bitmap animating by cycling
    through a series of images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish your app and test it on a device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have a collection of `BitmapData` objects, it doesn't take too much
    effort to perform animation using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `frame` member variable was used as an index position into the `bitmaps`
    array in order to retrieve the next `BitmapData` object for the animation. You
    can see this in the following code snippet, where the `bitmapData` property is
    updated to point to a new `BitmapData` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Some additional logic was also added to ensure that the animation looped back
    round to the first frame again. This was taken care of by comparing the value
    of `frame` against the `MAX_FRAMES` constant and setting `frame` back to `0` when
    both values matched.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like a considerable amount of work for a task that can be performed
    relatively quickly using a timeline animation. However, even the simplest timeline
    animations struggle for performance on older iOS devices. This is especially true
    when using GPU Blend, where each frame needs to be copied from the CPU to the
    GPU whenever the playhead's position changes.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic animation using ActionScript, however, can be incredibly fast,
    with GPU Blend benefitting especially from it. Remember, `BitmapData` objects
    are stored directly in video memory as textures and, therefore, don't suffer the
    same rendering bottlenecks experienced by timeline animations.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Flash Professional CS5, then this may be the only real option
    if you want to maximize the performance of your animations. Utilizing GPU-Blend
    mode and performing bitmap animations using ActionScript can increase performance
    anywhere between five and ten times that of a timeline-based approach. For a comparison,
    publish `recipe-bitmaps.fla` from the *Comparing vector and bitmap graphics* recipe.
    The performance difference between it and this recipe's example FLA should be
    considerable when running on a device.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following are a few final points regarding sprite sheets and animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animation sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find that the existing animation runs too quickly and be tempted to
    reduce the FLA's frame rate to correct this. A better approach is to hold each
    bitmap for a few frames before moving to the next. This provides more control
    over your animations without reducing the SWF's frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this by creating an array that holds a sequence of frame indexes
    for your animation. Each element within the array represents one frame of animation.
    Therefore, we can slow the animation by storing duplicate copies of each frame
    index. Take a look at the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 ]`'
  prefs: []
  type: TYPE_NORMAL
- en: Each integer represents a frame index, with 0 being the first bitmap of the
    animation and 3 being the last. Therefore, this sequence holds the animation on
    each of the bitmaps for four screen redraws before moving to the next. Let us
    implement this in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a constant that holds the animation sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, replace the `update()` method with this new version, which cycles
    through the frame indexes listed in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Save your document class and test the new version of your FLA.
  prefs: []
  type: TYPE_NORMAL
- en: While this example uses a frame-based approach to animation, there is really
    nothing stopping you from writing your own ActionScript animation library that
    can be time-based.
  prefs: []
  type: TYPE_NORMAL
- en: Loading resources at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another reason for employing bitmap-based animation with ActionScript is for
    runtime loading of resources. If you can't fit all your resources into memory
    at once or simply want to reduce the initial load time of your app, then you should
    consider this above timeline-based animations.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, it is not currently possible to instantiate any library symbols within
    external SWFs that you have loaded into your AIR for iOS app. Therefore, as an
    alternative, you may want to load sprite sheets at runtime, extract the images
    from them, and then use ActionScript to perform the animations required by your
    app's display objects.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 3D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the most compelling reason for using sprite sheets is Adobe's Stage
    3D API. Stage 3D (previously codenamed Molehill) provides advanced 2D and 3D hardware
    acceleration on GPU hardware. Its API is intentionally low-level in order to maximize
    performance but you can use various ActionScript 3.0 frameworks built on top of
    Stage 3D that are still capable of results far exceeding Flash's traditional display
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Two such APIs aimed at 2D graphics are Starling and ND2D, which make heavy use
    of sprite sheets. Flash's traditional display list cannot be used with these frameworks.
    Instead, everything must be performed programmatically using ActionScript and
    the graphics elements provided by each.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Stage 3D isn't yet available for mobile. However, Adobe
    is actively working to bring it to AIR for iOS. If you would like to take advantage
    of Stage 3D when it becomes available, then you should consider using sprite sheets
    in your current projects. This should make the process of porting them to Stage
    3D relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about Stage 3D from Adobe Developer Connection at [www.adobe.com/devnet/flashplayer/stage3d.html](http://www.adobe.com/devnet/flashplayer/stage3d.html).
    Links to both Starling and ND2D can be found there too.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using an update loop, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with external SWFs, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with sprite sheets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
