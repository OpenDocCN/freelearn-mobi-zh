- en: Chapter 6. Graphics and Hardware Acceleration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 图形和硬件加速
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Comparing vector and bitmap graphics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较矢量图形和位图图形
- en: Understanding GPU-Blend mode
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GPU-混合模式
- en: Understanding GPU-Vector mode
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GPU-矢量模式
- en: Using Cache as Bitmap
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存作为位图
- en: Using Cache as Bitmap Matrix
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存作为位图矩阵
- en: Accessing bitmaps with ActionScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ActionScript访问位图
- en: Loading bitmaps at runtime
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时加载位图
- en: Working with sprite sheets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用精灵图集工作
- en: Performing bitmap animation with ActionScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ActionScript执行位图动画
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The release of CS5 made it possible for Flash developers to create exciting
    content for iOS devices without changing their workflow. However, with only a
    fraction of the computing power of a modern day desktop or laptop, developing
    for devices such as the iPhone requires special design and coding considerations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CS5的发布使得Flash开发者能够在不改变工作流程的情况下为iOS设备创建令人兴奋的内容。然而，由于现代桌面或笔记本电脑计算能力的只有一小部分，为iPhone等设备开发需要特殊的设计和编码考虑。
- en: One of the largest bottlenecks is graphics rendering and it has become an area
    of frustration for many. It is simply not realistic to build the same graphics-heavy
    FLAs that you normally would for desktop delivery and expect them to run well
    on mobile. Even seemingly simple graphical operations can perform badly on iOS
    devices if poorly implemented.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的瓶颈之一是图形渲染，它已经成为许多人的烦恼之源。简单地构建与桌面交付相同的图形密集型FLA，并期望它们在移动设备上运行良好，这是不现实的。即使看似简单的图形操作，如果实现不当，在iOS设备上也可能表现不佳。
- en: By making available the same powerful drawing and animation tools that you are
    already familiar with, the Flash IDE can actually lull you into a false sense
    of security. For example, complex vector artwork, masks, timeline animations,
    deeply-nested display lists, and alpha transparencies are all easy to create but
    can negatively impact the performance of your app. Targeting mobile requires careful
    planning, profiling, and an understanding of the hardware you are developing for.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供你已熟悉的强大绘图和动画工具，Flash IDE实际上可能会让你产生一种虚假的安全感。例如，复杂的矢量图形、蒙版、时间轴动画、深度嵌套的显示列表和alpha透明度都很容易创建，但可能会对你的应用程序性能产生负面影响。针对移动设备需要仔细规划、分析和了解你正在为哪个硬件开发。
- en: In this chapter, we will explore many techniques for optimizing render performance.
    We will cover both Flash's rendering pipeline and the hardware constraints that
    you will be working within. In addition, we will see how to take advantage of
    hardware acceleration, offloading much of the rendering workload from the CPU
    to the Graphics Processing Unit (GPU).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨许多优化渲染性能的技术。我们将涵盖Flash的渲染管道以及你将在其中工作的硬件限制。此外，我们还将了解如何利用硬件加速，将大部分渲染工作量从CPU卸载到图形处理单元（GPU）。
- en: Comparing vector and bitmap graphics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较矢量图形和位图图形
- en: Although Flash provides bitmap support, it is primarily thought of as a vector
    animation tool. Vector content can be created and edited directly within the IDE,
    making vectors an obvious choice above bitmaps, which must be edited externally.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Flash提供了位图支持，但它主要被视为矢量动画工具。矢量内容可以直接在IDE中创建和编辑，这使得矢量图形成为比必须在外部编辑的位图更明显的选择。
- en: However, given the hardware constraints of mobile devices such as the iPhone,
    are vectors appropriate or should you consider using bitmaps in order to maximize
    performance?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑到移动设备如iPhone的硬件限制，矢量图形是否合适，或者你应该考虑使用位图以最大化性能？
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Two FLAs have been provided for this recipe and can be found within the book's
    accompanying code bundle at `chapter6\recipe1\`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为此配方提供了两个FLA，可以在书的配套代码包中找到，位于`chapter6\recipe1\`。
- en: Both perform a simple render performance test. Each attempts to render ten instances
    of an animating movie clip. After five seconds, the test will end and the average
    number of frames per second (FPS) that was achieved will be shown. The higher
    that number, the faster the rendering performance of the test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都执行一个简单的渲染性能测试。每个都尝试渲染十个动画电影剪辑的实例。五秒后，测试将结束，并显示达到的平均每秒帧数（FPS）。这个数字越高，测试的渲染性能就越快。
- en: The first FLA`— recipe-vectors.fla —`uses vector artwork for each of the movie
    clip's animation frames. The second`—recipe-bitmaps.fla—`uses a bitmap representation
    for each.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个FLA`— recipe-vectors.fla —`为每个电影剪辑的动画帧使用矢量图形。第二个`—recipe-bitmaps.fla—`则使用位图表示。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps in order to run both tests on your device:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤在你的设备上运行这两个测试：
- en: Open `recipe-vectors.fla` into Flash Professional.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`recipe-vectors.fla`打开到Flash Professional中。
- en: Within the library, you will find a symbol named **Monkey**, which contains
    a four-frame vector animation. Double-click on the symbol and explore its display
    list. Its construction is typical for a Flash project, containing many nested
    clips of vector artwork.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库中，你会找到一个名为**Monkey**的符号，它包含一个四帧的矢量动画。双击该符号并探索其显示列表。其结构对于Flash项目来说是典型的，包含许多嵌套的矢量图形剪辑。
- en: Publish the FLA and deploy `c6-r1-v.ipa`. On your device's home screen, find
    the app named **c6 r1 v** and launch it. Wait for five seconds and then take a
    note of the frame rate that was achieved.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA文件并部署`c6-r1-v.ipa`。在你的设备主屏幕上找到名为**c6 r1 v**的应用并启动它。等待五秒钟，然后记录达到的帧率。
- en: Now open `recipe-bitmaps.fla`. Double-click on the **Monkey** library symbol
    and explore its timeline. This FLA performs the same test as the first, except
    it uses a bitmap for each animation frame rather than vectors.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`recipe-bitmaps.fla`。双击**Monkey**库符号并探索其时间轴。这个FLA执行与第一个相同的测试，但它使用位图而不是矢量作为每个动画帧。
- en: Publish the FLA and deploy `c6-r1-b.ipa` to your device. Launch **c6 r1 b**
    and take a note of the frame rate.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并部署`c6-r1-b.ipa`到你的设备。启动**c6 r1 b**并记录帧率。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The rendering performance of each will vary across iOS devices but no matter
    what device you use, the bitmap-based animation will outperform the vector-based
    equivalent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个iOS设备的渲染性能可能会有所不同，但无论你使用什么设备，基于位图的动画都将优于基于矢量的等效动画。
- en: 'To confirm this, let us take a look at the results of the two FLAs compiled
    from Flash Professional CS5 and run across a handful of devices. The following
    chart shows the average frame rate, measured in frames per second, that was achieved
    by each test:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认这一点，让我们看看从Flash Professional CS5编译的两个FLA在多个设备上运行的结果。以下图表显示了每个测试达到的平均帧率，以每秒帧数衡量：
- en: '![How it works...](img/1383_06_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1383_06_01.jpg)'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The results shown in this chart are an average taken from five runs of each
    test. Each device was running iOS 5 with the exception of the first-generation
    iPod touch, which had iOS 3.1 installed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中显示的结果是从每个测试的五次运行中得出的平均值。每个设备都运行iOS 5，除了第一代iPod touch，它安装了iOS 3.1。
- en: Use these results as a rough guide as they may vary slightly across runs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些结果作为粗略的指南，因为它们可能在不同的运行中略有差异。
- en: So why do bitmaps render to the screen faster than vectors?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么位图渲染到屏幕上的速度比矢量快？
- en: Vector graphics are represented by a combination of strokes, fills, colors,
    and gradients, with expensive mathematical calculations required in order to render
    them. Bitmaps on the other hand are simply a pixel-by-pixel representation of
    each color required by an image. With every single point of a bitmap already known,
    it can quickly be plotted to the screen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量图形由线条、填充、颜色和渐变组合而成，渲染它们需要昂贵的数学计算。另一方面，位图只是图像所需每种颜色的像素逐个表示。由于位图的每个点都已经知道，它可以快速绘制到屏幕上。
- en: So does this mean you should exclusively use bitmaps in place of vectors when
    developing for iOS? Not necessarily. Unlike bitmaps, vector artwork can be scaled
    and translated without losing fidelity. This is due to the fact that vector graphics
    are represented mathematically. Another advantage of vectors is file size. In
    many cases, vectors consume significantly less space than their bitmap counterparts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你应该在为iOS开发时专门使用位图代替矢量？不一定。与位图不同，矢量图形可以无失真地缩放和转换。这是由于矢量图形是数学上表示的。矢量的另一个优点是文件大小。在许多情况下，矢量比它们的位图对应物消耗的空间要少得多。
- en: However, if frame rate is critical to the success of your application, then
    you should always attempt to select the fastest rendering option. Also, be aware
    that doing so may come at the expense of increased memory usage, larger file sizes,
    and extended development times.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果帧率对你的应用程序的成功至关重要，那么你应该始终尝试选择最快的渲染选项。此外，请注意，这样做可能会以增加内存使用、更大的文件大小和延长开发时间为代价。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Whether you opt to use vectors or bitmaps, adjusting the rendering quality can
    aid performance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择使用矢量还是位图，调整渲染质量都可以帮助提高性能。
- en: Stage quality
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阶段质量
- en: You can further increase performance by reducing the rendering quality used
    by your app. This is especially useful if you are attempting to maximize your
    frame rate while manipulating complex vector artwork.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过降低应用程序使用的渲染质量来进一步提高性能。这在您试图在操作复杂矢量图形的同时最大化帧率时特别有用。
- en: 'Using ActionScript, set the `Stage.quality` property to one of the following
    constants:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ActionScript，将`Stage.quality`属性设置为以下常量之一：
- en: '`StageQuality.HIGH:` Provides bitmap smoothing and anti-aliasing'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StageQuality.HIGH:` 提供位图平滑和抗锯齿'
- en: '`StageQuality.MEDIUM:` Provides bitmap smoothing and uses lower quality anti-aliasing'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StageQuality.MEDIUM:` 提供位图平滑并使用较低质量的抗锯齿'
- en: '`StageQuality.LOW:` Does not smooth bitmaps or anti-alias graphics'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StageQuality.LOW:` 不平滑位图或抗锯齿图形'
- en: All three quality settings are available from AIR 3.0 with only low and medium
    quality being supported by AIR 2.0-2.7\. All versions of AIR for iOS use `StageQuality.MEDIUM`
    as the default setting.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从AIR 3.0开始，所有三个质量设置都可用，而AIR 2.0-2.7仅支持低质量和中等质量。iOS的所有版本都将`StageQuality.MEDIUM`作为默认设置。
- en: Render quality is applied globally to all content within your application. Bitmaps,
    however, remain relatively unaffected and, with the exception of smoothing, will
    look identical across all quality settings. This conveniently allows you to get
    the highest level of performance from your vector assets without compromising
    the quality of any bitmaps within your application. You can repeatedly change
    the quality setting throughout your app's lifetime to best suit its needs at any
    particular moment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染质量应用于应用程序中的所有内容。然而，位图却相对不受影响，除了平滑处理外，在所有质量设置下看起来都相同。这方便您在不影响应用程序中任何位图质量的情况下，从矢量资源中获得最高性能。您可以在应用程序的生命周期内重复更改质量设置，以最好地适应任何特定时刻的需求。
- en: 'Try reducing the stage''s render quality within this recipe''s FLAs. Simply
    open the `Main.as` document class shared by both and add the following line of
    code at the start of the constructor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在此菜谱的FLA中降低舞台的渲染质量。只需打开由两者共享的`Main.as`文档类，并在构造函数的开始处添加以下代码行：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, add the following import statement:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加以下导入语句：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Publish and re-deploy both `.ipa` files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 发布并重新部署两个`.ipa`文件。
- en: Rendering should now be faster although the quality of the vector artwork will
    be noticeably reduced. For many situations, this sacrifice may be acceptable,
    especially on a compact mobile device screen where any reduction in quality may
    be hard to spot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管矢量图形的质量将明显降低，但渲染速度现在应该更快。对于许多情况，这种牺牲可能是可以接受的，尤其是在紧凑的移动设备屏幕上，任何质量的降低可能都难以察觉。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Converting vectors to bitmaps, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将矢量转换为位图，[第4章](ch04.html "第4章. 将Flash项目移植到iOS")*'
- en: '*Resizing bitmaps, [Chapter 4](ch04.html "Chapter 4. Porting Flash Projects
    to iOS")*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整位图大小，[第4章](ch04.html "第4章. 将Flash项目移植到iOS")*'
- en: Understanding GPU-Blend mode
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GPU-混合模式
- en: Unlike developing for the Flash desktop player, two rendering modes are available
    to those targeting AIR for iOS. Exactly the same software renderer that is present
    in the desktop player is provided as the first option and is handled by the device's
    CPU. The second allows you to take advantage of the device's GPU and can significantly
    improve rendering performance in certain circumstances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与为Flash桌面播放器开发不同，针对iOS的AIR提供了两种渲染模式。与桌面播放器中存在的相同软件渲染器作为第一个选项提供，并由设备的CPU处理。第二个选项允许您利用设备的GPU，并在某些情况下显著提高渲染性能。
- en: A rendering mode must be selected before compiling your FLA for iOS and cannot
    be changed at runtime. It is, therefore, important to understand the differences
    between both modes and make a decision early on regarding which one you would
    like to support. The choice of renderer can dictate how you architect your application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译iOS的FLA之前必须选择渲染模式，且在运行时无法更改。因此，了解两种模式之间的差异并在早期做出决定，关于您希望支持哪种模式，是非常重要的。渲染器的选择可以决定您如何构建应用程序。
- en: Although both Flash Professional CS5 and CS5.5 provide an option to perform
    rendering on the GPU, how that rendering mode is actually implemented is different.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Flash Professional CS5和CS5.5都提供了一个在GPU上执行渲染的选项，但实际上实现渲染模式的方式不同。
- en: In this recipe, we will publish and deploy some example FLAs to help you understand
    the differences between the two modes. In particular, we will focus on the GPU-rendering
    mode provided by Flash Professional CS5.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将发布和部署一些示例 FLA，以帮助您了解两种模式之间的差异。特别是，我们将重点关注 Flash Professional CS5 提供的
    GPU 渲染模式。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Two FLAs have been provided with the book's accompanying code bundle`—render-test-cpu.fla`
    and `render-test-gpu.fla—` and can be found at `chapter6\recipe2\`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带代码包中提供了两个 FLA——“render-test-cpu.fla”和“render-test-gpu.fla”——可以在 `chapter6\recipe2\`
    中找到。
- en: Both FLAs are identical, with each randomly re-positioning ten movie-clip instances
    on every frame update. After five seconds, the test will end and the average number
    of frames per second (FPS) that was achieved will be shown. The higher that number,
    the faster the rendering performance of the test.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 FLA 都是相同的，每个在每一帧更新时都会随机重新定位十个电影剪辑实例。五秒后，测试将结束，并显示达到的平均每秒帧数（FPS）。这个数字越高，测试的渲染性能就越快。
- en: For this recipe, the FLAs should only be compiled using Flash Professional CS5\.
    However, if you are using CS5.5, read through the material covered here before
    moving to the next recipe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，FLA 应仅使用 Flash Professional CS5 编译。但是，如果您使用的是 CS5.5，请在进入下一个菜谱之前阅读这里涵盖的材料。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us select a rendering mode for each FLA and see how they perform on an actual
    device.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为每个 FLA 选择一个渲染模式，并看看它们在实际设备上的表现。
- en: Open `render-test-cpu.fla` within Flash Professional CS5.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Flash Professional CS5 中打开 `render-test-cpu.fla`。
- en: Select **File** | **iPhone OS Settings**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件** | **iPhone OS 设置**。
- en: From the **iPhone OS Settings** panel, select **CPU** from the **Rendering**
    field's drop-down box. Click on **OK** to confirm the change.![How to do it...](img/1383_06_02.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **iPhone OS 设置** 面板中，从 **渲染** 字段的下拉菜单中选择 **CPU**。点击 **确定** 以确认更改。![如何操作...](img/1383_06_02.jpg)
- en: Save the FLA.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 FLA。
- en: Publish the FLA and deploy `c6-r2-cpu.ipa` to your device. On your device's
    home screen, find the app named **c6 r2 cpu** and launch it. Take a note of the
    frame rate that was achieved by the test and then close the app.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 `c6-r2-cpu.ipa` 部署到您的设备上。在您的设备主屏幕上找到名为 **c6 r2 cpu** 的应用程序并启动它。记录测试达到的帧率，然后关闭应用程序。
- en: Now, open `render-test-gpu.fla`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `render-test-gpu.fla`。
- en: Select **File** | **iPhone OS Settings**. This time, set the panel's **Rendering**
    field to **GPU**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件** | **iPhone OS 设置**。这次，将面板的 **渲染** 字段设置为 **GPU**。
- en: Click on **OK** to close the panel.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定** 关闭面板。
- en: Save the FLA.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 FLA。
- en: Publish and deploy `c6-r2-gpu.ipa` to your device. Launch the app labeled **c6
    r2 gpu**. Take a note of the frame rate that was achieved.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `c6-r2-gpu.ipa` 发布并部署到您的设备上。启动名为 **c6 r2 gpu** 的应用程序。记录达到的帧率。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: From the iPhone OS Settings panel, we set a different rendering mode for each
    of the FLAs. Both FLAs performed an identical test but used a different rendering
    path. The first used the CPU to render all graphical content, while we selected
    the GPU for the second.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从 iPhone OS 设置面板中，我们为每个 FLA 设置了不同的渲染模式。两个 FLA 执行了相同的测试，但使用了不同的渲染路径。第一个使用 CPU
    渲染所有图形内容，而第二个我们选择了 GPU。
- en: The following chart shows the results of running the tests on a selection of
    devices. The results show the frame rate, measured in frames per second, that
    was achieved by each test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了在一系列设备上运行测试的结果。结果显示了每个测试达到的帧率，以每秒帧数（fps）来衡量。
- en: '![How it works...](img/1383_06_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1383_06_03.jpg)'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The results shown in this chart are an average taken from five runs of each
    test. Each device was running iOS 5 with the exception of the first-generation
    iPod touch, which had iOS 3.1 installed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中显示的结果是从每个测试的五次运行中取出的平均值。每个设备都运行 iOS 5，除了第一代 iPod touch，它安装了 iOS 3.1。
- en: Use these results as a rough guide as they may vary slightly across runs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些结果作为大致的指南，因为它们可能在不同的运行中略有差异。
- en: As you can see, the actual results vary across device but surprisingly there
    is very little difference in performance between the two modes, with CPU being
    slightly faster. You likely expected GPU rendering to be significantly better
    than CPU but to understand why this was not the case, we need to examine the rendering
    process in a little more detail. In particular, we need to look at how GPU rendering
    is implemented by AIR 2.0 in Flash Professional CS5.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实际结果在不同设备上有所不同，但令人惊讶的是，两种模式之间的性能差异非常小，CPU略快。您可能预计GPU渲染会比CPU显著更好，但为了理解为什么情况并非如此，我们需要更详细地检查渲染过程。特别是，我们需要查看AIR
    2.0在Flash Professional CS5中如何实现GPU渲染。
- en: The rendering process
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染过程
- en: 'Rendering is split into the following two distinct parts:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染被分为以下两个不同的部分：
- en: Rasterization
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光栅化
- en: Scene composition
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景合成
- en: During **rasterization,** every element within your display list is drawn to
    a separate off-screen pixel buffer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在**光栅化**过程中，您显示列表中的每个元素都会绘制到一个单独的离屏像素缓冲区中。
- en: Once rasterization is complete, those pixel buffers are taken and are arranged
    to recreate the scene represented by the display list. This is known as **scene
    composition**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦光栅化完成，那些像素缓冲区就会被取出并排列以重新创建由显示列表表示的场景。这被称为**场景合成**。
- en: Regardless of whether you are using Flash CS5 or CS5.5, both CPU and GPU modes
    will perform this rendering process. How each rendering mode achieves this, however,
    is different.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用的是Flash CS5还是CS5.5，CPU和GPU模式都会执行此渲染过程。然而，每种渲染模式如何实现这一点是不同的。
- en: CPU mode and GPU-Blend mode
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU模式与GPU-混合模式
- en: When using CPU mode, both rasterization and scene composition are performed
    entirely in software by the CPU.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CPU模式时，光栅化和场景合成完全由CPU在软件中执行。
- en: 'In Flash CS5, when GPU mode is selected, the device''s GPU will be used to
    compose the scene. Rasterization, however, is still performed by the CPU, with
    each of the off-screen pixel buffers being uploaded to the GPU for composition.
    In other words, the rendering process is only partially performed on the GPU.
    This is shown in the following illustrations. This implementation is known as
    GPU Blend and differs from that used by CS5.5:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flash CS5中，当选择GPU模式时，设备的GPU将用于合成场景。然而，光栅化仍然由CPU执行，每个离屏像素缓冲区都会上传到GPU进行合成。换句话说，渲染过程只在GPU上部分执行。这种实现被称为GPU混合，与CS5.5中使用的实现不同：
- en: '![CPU mode and GPU-Blend mode](img/1383_06_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![CPU模式与GPU-混合模式](img/1383_06_04.jpg)'
- en: 'The following table should help clarify the difference between CPU and GPU-Blend
    mode used by AIR 2.0 in Flash CS5:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下表可以帮助您了解Flash CS5中AIR 2.0使用的CPU和GPU-混合模式之间的区别：
- en: '| Render mode | Rasterization | Scene composition |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 渲染模式 | 光栅化 | 场景合成 |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CPU | CPU | CPU |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| CPU | CPU | CPU |'
- en: '| GPU Blend | CPU | GPU |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| GPU混合 | CPU | GPU |'
- en: The GPU found on iOS devices can compose a scene much faster than the CPU. However,
    the process of uploading the pixel buffers from the CPU to the GPU can be expensive
    because of the amount of data that has to be sent. Therefore, to benefit from
    GPU acceleration when using Flash CS5, you must minimize the amount of bitmap
    traffic going from the CPU to the GPU. In other words, you need to reduce the
    frequency with which display objects are re-rasterized.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备上发现的GPU可以比CPU更快地合成场景。然而，由于需要发送的数据量，从CPU上传像素缓冲区到GPU的过程可能非常昂贵。因此，为了在使用Flash
    CS5时从GPU加速中受益，您必须最小化从CPU到GPU的位图流量。换句话说，您需要减少显示对象重新光栅化的频率。
- en: Redrawing dirty regions
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新绘制脏区域
- en: 'Re-rasterization takes place when content within a scene changes. Whenever
    changes occur, Flash takes a note of the rectangular regions within the scene
    that need to be redrawn. These are known as the dirty regions and are used as
    an alternative to simply rendering the entire screen again. This is illustrated
    in the following diagram where the star-shaped clip moves position:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景中的内容发生变化时，会发生重新光栅化。每当发生变化时，Flash都会记录下场景中需要重新绘制的矩形区域。这些区域被称为脏区域，并用作仅重新渲染整个屏幕的替代方案。以下图示中星形剪辑的位置移动说明了这一点：
- en: '![Redrawing dirty regions](img/1383_06_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![重新绘制脏区域](img/1383_06_05.jpg)'
- en: In this example, the star movie clip changes position between frames and by
    doing so creates a dirty region. The dirty region is represented as a rectangular
    area that encompasses the space consumed by the star's previous and current location.
    The circle, background image, and the star itself all touch this dirty region
    meaning all three need to be re-rasterized. Any display objects that intersect
    a dirty region need to be re-rasterized.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，星星电影剪辑在帧之间改变位置，从而创建了一个脏区域。脏区域表示为一个矩形区域，它包含了星星之前和当前位置所消耗的空间。圆形、背景图像以及星星本身都触及这个脏区域，这意味着所有三个都需要重新光栅化。任何与脏区域相交的显示对象都需要重新光栅化。
- en: When using GPU Blend, the bitmap data for each of the re-rasterized display
    objects needs to be uploaded to the GPU in order for compositing to take place.
    As stated, uploading to the GPU can be expensive.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 GPU 混合时，需要将每个重新光栅化的显示对象的位图数据上传到 GPU，以便进行合成。正如所述，上传到 GPU 可能很昂贵。
- en: For scenes that change frequently, the performance of your app may suffer when
    using GPU acceleration. This is why `render-test-gpu.fla` doesn't perform as well
    as you might expect. There are so many changes per frame that the bandwidth penalty
    from transferring the re-drawn pixel buffers to the GPU actually negates much
    of the performance gained from utilizing the GPU.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经常变化的场景，当使用 GPU 加速时，你的应用程序的性能可能会受到影响。这就是为什么 `render-test-gpu.fla` 的表现不如你预期的那么好。每一帧都有很多变化，将重新绘制的像素缓冲区传输到
    GPU 的带宽惩罚实际上抵消了利用 GPU 获得的许多性能。
- en: There are techniques that can be employed to cache bitmap data directly on the
    GPU rather than continuously re-rasterizing and uploading from the CPU. We will
    discuss these shortly, but it should be clear that taking full advantage of AIR
    2.0's hardware acceleration isn't as simple as changing the rendering mode within
    the iPhone OS Settings panel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采用技术直接在 GPU 上缓存位图数据，而不是从 CPU 持续重新光栅化和上传。我们很快就会讨论这些，但应该清楚的是，充分利用 AIR 2.0 的硬件加速并不像在
    iPhone OS 设置面板中更改渲染模式那样简单。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'One more thing, which you may have noticed when selecting a rendering mode
    is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，你可能在选择渲染模式时已经注意到了：
- en: Auto rendering
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动渲染
- en: As well as CPU and GPU, there is an additional rendering option named **Auto**
    that is available. At this moment in time, **Auto** actually defaults to the CPU
    renderer and is, therefore, no different to selecting **CPU**. This is true for
    both Flash Professional CS5 and CS5.5.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 CPU 和 GPU，还有一个名为 **Auto** 的额外渲染选项可用。目前，**Auto** 实际上默认为 CPU 渲染器，因此与选择 **CPU**
    没有区别。这在 Flash Professional CS5 和 CS5.5 中都是如此。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding GPU-Vector mode*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解 GPU-矢量模式*'
- en: '*Using Cache as Bitmap*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图*'
- en: '*Using Cache as Bitmap Matrix*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图矩阵*'
- en: Understanding GPU-Vector mode
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GPU-矢量模式
- en: In the *Understanding GPU-Blend mode* recipe, we spent time covering the intricacies
    of the GPU-rendering mode provided by Flash Professional CS5\. Although GPU rendering
    is also supported for those using Flash Professional CS5.5, its implementation
    differs from CS5's.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *理解 GPU-混合模式* 菜谱中，我们花费时间介绍了 Flash Professional CS5 提供的 GPU 渲染模式的复杂性。尽管 Flash
    Professional CS5.5 也支持 GPU 渲染，但其实现方式与 CS5 不同。
- en: In this recipe, we will cover how to select a rendering mode using CS5.5 and
    also use the same tests from the *Understanding GPU-Blend mode* recipe in order
    to see the performance difference between both GPU renderers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将介绍如何使用 CS5.5 选择渲染模式，并使用 *理解 GPU-混合模式* 菜谱中的相同测试，以便查看两个 GPU 渲染器之间的性能差异。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Two FLAs have been provided`—render-test-cpu.fla` and `render-test-gpu.fla—and`
    can be found in the book's accompanying code bundle at `chapter6\recipe3\`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了两个 FLA 文件`—render-test-cpu.fla` 和 `render-test-gpu.fla`，可以在本书的配套代码包中找到，位于
    `chapter6\recipe3\`。
- en: Both FLAs are identical, with each randomly re-positioning ten movie-clip instances
    on every frame update. After five seconds, the test will end and the average number
    of frames per second (FPS) that was achieved will be shown. The higher that number,
    the faster the rendering performance of the test.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 FLA 文件完全相同，每个在每一帧更新时都会随机重新定位十个电影剪辑实例。五秒后，测试将结束，并显示达到的平均每秒帧数（FPS）。这个数字越高，测试的渲染性能就越快。
- en: The FLAs should only be compiled using Flash Professional CS5.5\. However, it
    is recommended that those using CS5 read through the material covered here rather
    than skipping to the next recipe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: FLA 应仅使用 Flash Professional CS5.5 编译。然而，对于使用 CS5 的用户，建议阅读此处涵盖的材料，而不是跳到下一个菜谱。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us select a different rendering mode for each FLA and see the performance
    differences between the two on an actual device.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为每个 FLA 选择不同的渲染模式，并查看在实际设备上两种模式之间的性能差异。
- en: Open `render-test-cpu.fla` within Flash Professional CS5.5.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Flash Professional CS5.5 中打开 `render-test-cpu.fla`。
- en: Select **File** | **AIR for iOS Settings** from Flash's drop-down menu.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Flash 的下拉菜单中选择 **文件** | **AIR for iOS 设置**。
- en: From the AIR for iOS Settings panel, select **CPU** from the **Rendering** field's
    drop-down box. Click on **OK**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 AIR for iOS 设置面板中，从 **渲染** 字段的下拉框中选择 **CPU**。点击 **确定**。
- en: Save the FLA.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 FLA。
- en: Publish the FLA and deploy `c6-r3-cpu.ipa` to your device. From the home screen,
    launch the app labeled **c6 r3 cpu**. Let the app run for five seconds and then
    take a note of the frame rate.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将 `c6-r3-cpu.ipa` 部署到您的设备上。从主屏幕上，启动标有 **c6 r3 cpu** 的应用程序。让应用程序运行五秒钟，然后记录帧率。
- en: Now, open `render-test-gpu.fla`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `render-test-gpu.fla`。
- en: Move to the **AIR for iOS Settings** panel and this time set the **Rendering**
    field to **GPU**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到 **AIR for iOS 设置** 面板，并将这次 **渲染** 字段设置为 **GPU**。
- en: Save the FLA.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 FLA。
- en: Publish and deploy `c6-r3-gpu.ipa` to your device. Launch **c6 r3 gpu** and
    take a note of the app's frame rate.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `c6-r3-gpu.ipa` 发布并部署到您的设备上。启动 **c6 r3 gpu** 并记录应用程序的帧率。
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: From the AIR for iOS Settings panel, we set a different rendering mode for each
    of the test FLAs. Both FLAs performed an identical test but used different rendering
    paths. The first used the CPU to render all graphics content, while we selected
    the GPU for the second.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从 AIR for iOS 设置面板中，我们为每个测试 FLA 设置了不同的渲染模式。两个 FLA 执行了相同的测试，但使用了不同的渲染路径。第一个使用
    CPU 渲染所有图形内容，而第二个我们选择了 GPU。
- en: The following chart shows the results of running the tests on a selection of
    devices. Each result shows the average frame rate that was achieved by each test.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了在一系列设备上运行测试的结果。每个结果都显示了每个测试达到的平均帧率。
- en: '![How it works...](img/1383_06_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1383_06_06.jpg)'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The results shown throughout this recipe are an average taken from five runs
    of each test. Each device was running iOS 5.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中显示的结果是从每个测试的五次运行中取出的平均值。每个设备都运行 iOS 5。
- en: Use these results as a rough guide as they may vary slightly across runs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些结果作为大致指南，因为它们在运行之间可能会有所不同。
- en: It should be apparent that impressive performance gains can be made when setting
    GPU rendering within Flash Professional CS5.5\. This is in stark contrast to the
    results from the *Understanding GPU-Blend mode* recipe where Flash Professional
    CS5 was used. Take the **iPhone 4** as an example. While there was no benefit
    from using the GPU when publishing from CS5, the same test published from CS5.5
    exhibited a 252% increase in render performance—23 frames per second using the
    CPU compared to 58 using the GPU.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当在 Flash Professional CS5.5 中设置 GPU 渲染时，可以获得令人印象深刻的性能提升。这与使用 Flash Professional
    CS5 的 *理解 GPU-混合模式* 菜单的结果形成鲜明对比。以 **iPhone 4** 为例。当从 CS5 发布时，使用 GPU 没有带来任何好处，但从
    CS5.5 发布的相同测试显示了 252% 的渲染性能提升——CPU 使用时每秒 23 帧，而 GPU 使用时为 58 帧。
- en: 'The following chart lets you easily compare the GPU rendering results for `render-test-gpu.fla`
    across both versions of Flash Professional:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表让您可以轻松比较 `render-test-gpu.fla` 在 Flash Professional 两个版本中的 GPU 渲染结果：
- en: '![How it works...](img/1383_06_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1383_06_07.jpg)'
- en: When published from CS5 and run on an iPhone 4, only an average of 17 frames
    per second were achieved over a five second period. Publishing the FLA using CS5.5
    managed 58 frames per second on the same device. Quite an improvement!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 CS5 发布并在 iPhone 4 上运行时，在五秒钟内平均只达到了 17 帧/秒。使用 CS5.5 发布的 FLA 在同一设备上达到了 58 帧/秒。这是一个相当大的改进！
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: You may have noticed in this chart that the GPU test compiled from Flash CS5.5
    was not run on the first-generation iPod touch. Support for ARM v6 devices such
    as the first-generation iPod touch was dropped in AIR 2.6.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在这个图表中，从 Flash CS5.5 编译的 GPU 测试没有在第一代 iPod touch 上运行。在 AIR 2.6 中取消了第一代
    iPod touch 等ARM v6设备的支持。
- en: So why does GPU rendering produce such huge gains in CS5.5 compared to CS5?
    It is down to changes in how GPU rendering has been implemented since AIR 2.6,
    which we will now cover.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 GPU 渲染在 CS5.5 中比 CS5 产生了如此巨大的提升？这归因于自 AIR 2.6 以来 GPU 渲染实现的改变，我们现在将介绍这一点。
- en: GPU-Vector mode
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPU-Vector 模式
- en: GPU Blend, which is the GPU-render mode supported in Flash CS5, only actually
    performs scene composition on the GPU—rasterization takes place entirely on the
    CPU. The GPU-render mode supported by CS5.5, however, performs both rasterization
    and scene composition on the GPU, removing the need to transfer bitmap data from
    the CPU to the GPU. This implementation is known as GPU Vector and is many times
    faster than GPU Blend.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Flash CS5 支持的 GPU 混合渲染模式实际上只在实际的 GPU 上执行场景合成——光栅化完全在 CPU 上进行。然而，CS5.5 支持的 GPU
    渲染模式既在 GPU 上执行光栅化也在 GPU 上执行场景合成，从而消除了从 CPU 到 GPU 转移位图数据的需求。这种实现被称为 GPU 向量，并且比
    GPU 混合快得多。
- en: When GPU rendering is selected, GPU Vector will be used by AIR for iOS apps
    published from Flash Professional CS5.5, while apps published from CS5 will use
    GPU Blend.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择 GPU 渲染时，从 Flash Professional CS5.5 发布的 AIR for iOS 应用将使用 GPU 向量，而从 CS5 发布的应用将使用
    GPU 混合。
- en: 'The following table summarizes the various rendering modes and from which version
    of Flash and AIR each is available:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了各种渲染模式以及它们在 Flash 和 AIR 中各自的可用版本：
- en: '| Render mode | Rasterization | Scene composition | Flash | AIR |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 渲染模式 | 光栅化 | 场景合成 | Flash | AIR |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| CPU | CPU | CPU | CS5 and CS5.5 | 2.0 - 3.x |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| CPU | CPU | CPU | CS5 和 CS5.5 | 2.0 - 3.x |'
- en: '| GPU Blend | CPU | GPU | CS5 | 2.0 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| GPU 混合 | CPU | GPU | CS5 | 2.0 |'
- en: '| GPU Vector | GPU | GPU | CS5.5 | 2.6 - 3.x |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| GPU 向量 | GPU | GPU | CS5.5 | 2.6 - 3.x |'
- en: When working with Flash Professional CS5, obtaining a high frame rate from even
    a modest FLA can be difficult without an understanding of GPU Blend and knowing
    how to minimize bitmap traffic between the CPU and GPU. On the other hand, those
    working with Flash Professional CS5.5 need not worry so much. GPU-Vector mode
    removes much of the hardship, making the process of writing AIR for iOS apps closer
    to writing for the desktop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Flash Professional CS5 时，即使是一个普通的 FLA 文件，如果没有理解 GPU 混合并知道如何最小化 CPU 和 GPU
    之间的位图流量，要获得高帧率也是困难的。另一方面，使用 Flash Professional CS5.5 的人不必过于担心。GPU-Vector 模式大大减少了困难，使得为
    iOS 应用编写 AIR 的过程更接近于桌面应用编写。
- en: Use GPU mode ahead of CPU as it yields better performance. This is true for
    both CS5 and CS5.5, although those using CS5 will need to work a little harder
    in order to take advantage of the hardware acceleration provided by the GPU.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GPU 模式而不是 CPU 模式可以获得更好的性能。这对 CS5 和 CS5.5 都适用，尽管使用 CS5 的人需要付出更多努力才能利用 GPU
    提供的硬件加速。
- en: GPU Vector is a very strong reason for upgrading from Flash Professional CS5
    to CS5.5\. Of course, if you are targeting older iOS devices such as the second-generation
    iPod touch or iPhone 3G, then you will still need to rely upon CS5 and GPU Blend.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 向量是从 Flash Professional CS5 升级到 CS5.5 的一个非常有力的理由。当然，如果你针对的是旧款 iOS 设备，如第二代
    iPod touch 或 iPhone 3G，那么你仍然需要依赖于 CS5 和 GPU 混合。
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The blazing-fast performance of GPU-Vector mode does come at a cost.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: GPU-Vector 模式的惊人性能确实是有代价的。
- en: Rendering vectors using GPU-Vector mode
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 GPU-Vector 模式渲染向量
- en: Performance isn't the only noticeable difference between GPU-Blend and GPU-Vector
    modes. Whereas GPU Blend and CPU will produce identical renditions of vector artwork,
    GPU Vector won't always be so accurate.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: GPU-Blend 和 GPU-Vector 模式之间的性能差异并非唯一显著的差异。虽然 GPU 混合和 CPU 会产生相同的向量艺术作品渲染效果，但
    GPU 向量并不总是那么精确。
- en: The GPU is optimized for rendering bitmaps and doesn't provide the same fidelity
    as the software renderer when recreating the complex vector shapes used by Flash.
    GPU-Vector mode requires that Flash's vector shapes be converted to simpler triangles
    that can be rendered quickly by the GPU. GPU Blend on the other hand, performs
    all rasterization on the CPU, allowing it to take advantage of the software renderer
    at the expense of performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 优化用于渲染位图，并且在重新创建 Flash 使用的复杂向量形状时，并不提供与软件渲染器相同的保真度。GPU-Vector 模式要求 Flash
    的向量形状被转换为 GPU 可以快速渲染的简单三角形。另一方面，GPU 混合在 CPU 上执行所有光栅化，从而可以利用软件渲染器，但以牺牲性能为代价。
- en: When using Flash Professional CS5.5, be aware that rendering vector artwork
    on the GPU won't be as precise as rendering on the CPU. CPU rendering is accurate
    but slow, whereas the GPU is faster but inaccurate. However, any differences between
    the two can be difficult to spot.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Flash Professional CS5.5 时，请注意，在 GPU 上渲染矢量图形不会像在 CPU 上渲染那样精确。CPU 渲染准确但速度慢，而
    GPU 速度快但不够准确。然而，两者之间的任何差异可能都难以察觉。
- en: Using GPU-Vector mode with Flash Professional CS5
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Flash Professional CS5 的 GPU-Vector 模式
- en: Although Flash Professional CS5 only supports AIR 2.0, it is actually possible
    to take advantage of the GPU-Vector rendering mode supported by AIR 2.6 and above.
    To do this, you will need to first publish a SWF from Flash CS5, then package
    the SWF into a native iOS app from the command line using the AIR Development
    Tool (ADT). ADT is included with the latest AIR SDK and can be downloaded from
    [www.adobe.com/products/air/sdk](http://www.adobe.com/products/air/sdk).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Flash Professional CS5 只支持 AIR 2.0，但实际上可以利用 AIR 2.6 及以上版本支持的 GPU-Vector 渲染模式。为此，您需要首先从
    Flash CS5 发布一个 SWF 文件，然后使用 AIR 开发工具（ADT）从命令行将该 SWF 文件打包成一个原生 iOS 应用程序。ADT 包含在最新的
    AIR SDK 中，并可以从 [www.adobe.com/products/air/sdk](http://www.adobe.com/products/air/sdk)
    下载。
- en: 'Command line packaging is outside the scope of this book; however, Adobe does
    provide detailed documentation on the subject at: [http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html](http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行打包超出了本书的范围；然而，Adobe 在此主题上提供了详细的文档，可在以下地址找到：[http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html](http://help.adobe.com/en_US/air/build/WS901d38e593cd1bac35eb7b4e12cddc5fbbb-8000.html)。
- en: Stage 3D
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Stage 3D
- en: In addition to AIR's existing rendering modes, Adobe has recently released a
    new rendering model named Stage 3D (previously codenamed Molehill), which leverages
    GPU hardware to provide advanced 2D and 3D capabilities.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 AIR 的现有渲染模式之外，Adobe 最近发布了一种名为 Stage 3D 的新渲染模型（之前代号为 Molehill），它利用 GPU 硬件提供高级的
    2D 和 3D 功能。
- en: At the time of writing, Stage 3D is only available for Flash and AIR on the
    desktop. However, Adobe is actively working to bring it to mobile. When it arrives,
    Stage 3D's performance should far exceed what is currently possible with AIR for
    iOS's existing rendering pipelines.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Stage 3D 仅在桌面上的 Flash 和 AIR 中可用。然而，Adobe 正在积极努力将其引入移动设备。当它到来时，Stage 3D
    的性能应该远超目前通过 AIR for iOS 的现有渲染管线所能实现的。
- en: You can find out more about Stage 3D from Adobe Developer Connection at [www.adobe.com/devnet/flashplayer/stage3d.html](http://www.adobe.com/devnet/flashplayer/stage3d.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Adobe 开发者连接处了解更多关于 Stage 3D 的信息：[www.adobe.com/devnet/flashplayer/stage3d.html](http://www.adobe.com/devnet/flashplayer/stage3d.html)。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using Cache as Bitmap*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存位图*'
- en: '*Using Cache as Bitmap Matrix*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存位图矩阵*'
- en: Using Cache as Bitmap
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存位图
- en: Rasterization can be expensive and should be minimized. For display objects
    that only experience translation along the X and Y axes, there is a technique
    available that removes the need for that object to be re-rasterized. This technique
    is known as Cache as Bitmap and in most circumstances can accelerate the rendering
    performance of your application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化可能很昂贵，应该尽量减少。对于仅在 X 和 Y 轴上经历平移的显示对象，有一种技术可以消除该对象需要重新光栅化的需求。这种技术被称为缓存位图，并且在大多数情况下可以加速应用程序的渲染性能。
- en: Cache as Bitmap takes a display object and generates a bitmap representation
    of it internally. The cached bitmap is then used for rendering rather than re-rasterizing
    the original display object. This can result in huge performance gains, particularly
    when working with complex vector artwork, which can be CPU-intensive to rasterize.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存位图从显示对象中提取并生成其内部的位图表示。然后使用缓存的位图进行渲染，而不是重新光栅化原始显示对象。这可能导致巨大的性能提升，尤其是在处理复杂矢量图形时，这些图形的光栅化可能对
    CPU 来说非常耗时。
- en: Normally, when a display object changes position, it needs to be re-rasterized.
    When cached, however, any two-dimensional translations will no longer result in
    that object being redrawn. Instead, its cached bitmap will be used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个显示对象改变位置时，它需要重新光栅化。然而，一旦被缓存，任何二维平移都不会导致该对象被重新绘制。相反，将使用其缓存的位图。
- en: Let us see how to apply Cache as Bitmap using both ActionScript and the Flash
    IDE.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 ActionScript 和 Flash IDE 两种方式应用缓存位图。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before continuing you should be aware of the difference between vector and
    bitmap graphics, and also have a firm understanding of the various rendering paths
    available when developing AIR for iOS apps. If you haven''t already done so, complete
    the following recipes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您应该了解矢量图形和位图图形之间的区别，并且对开发iOS应用程序时可用各种渲染路径有牢固的理解。如果您还没有这样做，请完成以下菜谱：
- en: '*Comparing vector and bitmap graphics*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较矢量图形和位图图形*'
- en: '*Understanding GPU-Blend mode*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解GPU-混合模式*'
- en: '*Understanding GPU-Vector mode*'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解GPU-矢量模式*'
- en: An FLA has been provided for this recipe and can be found within the book's
    accompanying code bundle at `chapter6\recipe4\recipe.fla`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为此菜谱提供了一个FLA，可以在本书的配套代码包中找到，位于`chapter6\recipe4\recipe.fla`。
- en: Its document class positions ten instances of a **Monkey** movie clip on top
    of a **Background** movie clip. On every frame update, the ten monkeys are randomly
    repositioned. After a period of five seconds, the average frame rate that was
    achieved is displayed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其文档类将十个**猴子**电影剪辑实例放置在**背景**电影剪辑的上方。在每一帧更新时，十个猴子被随机重新定位。经过五秒钟后，显示平均帧率。
- en: The movie clips used for this recipe are constructed from vector graphics as
    opposed to bitmaps. Also, this recipe's FLA has been set to use GPU rendering.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此菜谱的电影剪辑是由矢量图形而不是位图构建的。此外，此菜谱的FLA已被设置为使用GPU渲染。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will first see how the existing version of the FLA performs before taking
    advantage of bitmap caching.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看现有版本的FLA的性能，然后再利用位图缓存。
- en: Open `recipe.fla`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`recipe.fla`。
- en: Publish the current version of the FLA and deploy it to your device.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布当前版本的FLA并将其部署到您的设备上。
- en: Launch the app from your device's home screen.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的设备主屏幕启动应用程序。
- en: Take a note of the frame rate; then delete the app from your device.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录帧率；然后从您的设备中删除应用程序。
- en: Now, move back to `recipe.fla` within Flash.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到Flash中的`recipe.fla`。
- en: Let us apply Cache as Bitmap to the display objects used by the FLA. Using the
    **Selection Tool (V)**, click on the **Background** movie clip sitting on the
    stage. From the **Properties** panel, expand the **DISPLAY** section and enable
    Cache as Bitmap. If you are using Flash Professional CS5, then this is done by
    checking the **Cache as bitmap** checkbox. For CS5.5, select **Cache as Bitmap**
    from the **Render** field's drop-down box.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们将缓存作为位图应用于FLA中使用的显示对象。使用**选择工具（V）**，点击舞台上的**背景**电影剪辑。从**属性**面板，展开**显示**部分并启用缓存作为位图。如果您使用的是Flash
    Professional CS5，那么这通过勾选**缓存为位图**复选框来完成。对于CS5.5，从**渲染**字段的下拉框中选择**缓存为位图**。
- en: 'Open the FLA''s document class and add the following line of code within the
    constructor:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开FLA的文档类，并在构造函数中添加以下代码行：
- en: '[PRE2]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the class.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类。
- en: Publish and deploy the new version to your device.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布并部署新版本到您的设备上。
- en: Compare the frame rate against the previous version of the app. The app's performance
    should be noticeably improved.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将帧率与应用程序的先前版本进行比较。应用程序的性能应该有明显的提升。
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `DisplayObject` class provides the `cacheAsBitmap` property, which is available
    from any class that extends `DisplayObject`, such as `Sprite` and `MovieClip`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayObject`类提供了`cacheAsBitmap`属性，该属性从任何扩展`DisplayObject`的类中可用，例如`Sprite`和`MovieClip`。'
- en: 'We used ActionScript to set the `cacheAsBitmap` property for each of the **Monkey**
    instances:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ActionScript为每个**猴子**实例设置了`cacheAsBitmap`属性：
- en: '[PRE3]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the **Background** movie clip sitting on the stage, caching was activated
    through the **Properties** panel.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于位于舞台上的**背景**电影剪辑，通过**属性**面板激活了缓存。
- en: To understand why bitmap caching can be beneficial, let us start by examining
    what happens within this recipe's example when Cache as Bitmap isn't set.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解位图缓存为何有益，让我们首先检查当未设置缓存为位图时，此菜谱示例中发生的情况。
- en: On each frame update, the position of the ten **Monkey** movie-clip instances
    is changed, forcing a dirty region to be created for each of the ten clips. Although
    the **Background** movie clip doesn't change position, it falls within the dirty
    regions. Therefore, on each frame update, the **Background** and all ten **Monkey**
    instances need to be re-rasterized before being composited into the scene.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧更新时，十个**猴子**电影剪辑实例的位置都会改变，迫使每个剪辑创建一个脏区域。尽管**背景**电影剪辑的位置没有改变，但它位于脏区域中。因此，在每一帧更新时，**背景**和所有十个**猴子**实例都需要在合成为场景之前重新光栅化。
- en: By taking advantage of Cache as Bitmap, the rendering time for each frame can
    be reduced. After setting Cache as Bitmap, each clip is initially rasterized and
    an internal representation is stored. Now on each frame update, there will be
    no need to re-rasterize any of the **Monkey** movie clips or the **Background**
    movie clip, as a cached bitmap representation of each is available and can be
    used during scene composition.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用缓存为位图，可以减少每帧的渲染时间。在设置缓存为位图后，每个剪辑最初都会进行光栅化，并存储一个内部表示。现在在每次帧更新时，将不需要重新光栅化任何**Monkey**电影剪辑或**背景**电影剪辑，因为每个都有缓存的位图表示，可以在场景组成期间使用。
- en: On every frame update other than the first, we have managed to completely skip
    rasterization.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在除了第一次之外的所有帧更新中，我们已经成功完全跳过了光栅化。
- en: 'Whether using Flash Professional CS5 or CS5.5, you should have experienced
    a significant performance increase by using Cache as Bitmap. The following chart
    gives you the results from publishing this recipe''s example using CS5 and testing
    it on a handful of devices:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是使用Flash Professional CS5还是CS5.5，你应该已经通过使用缓存为位图体验到了显著的性能提升。以下图表显示了使用CS5发布此示例配方并在一些设备上测试的结果：
- en: '![How it works...](img/1383_06_08.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1383_06_08.jpg)'
- en: 'And the following chart shows the same test published using CS5.5 and AIR 3.0:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用CS5.5和AIR 3.0发布的相同测试：
- en: '![How it works...](img/1383_06_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1383_06_09.jpg)'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The results shown in these charts are an average taken from five runs of each
    test. Each device was running iOS 5 with the exception of the first-generation
    iPod touch, which had iOS 3.1 installed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表中显示的结果是从每个测试的五次运行中取的平均值。每个设备都运行iOS 5，除了第一代iPod touch，它安装了iOS 3.1。
- en: Use these results as a rough guide as they may vary slightly across runs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些结果作为粗略的指南，因为它们可能在不同的运行中略有差异。
- en: As you can see from the charts, Cache as Bitmap can significantly increase your
    application's frame rate when using complex vector artwork. This does come at
    the expense of memory; however, as an additional bitmap for each display object
    must be stored.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如图表所示，缓存为位图可以在使用复杂矢量图形时显著提高你应用程序的帧率。这确实是以内存为代价的；然而，因为每个显示对象必须存储额外的位图。
- en: Although we utilized GPU rendering in this recipe, using Cache as Bitmap in
    conjunction with CPU rendering will also lead to performance increases when dealing
    with complex vector artwork. Caching directly on the GPU, however, produces the
    largest performance increase.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本配方中使用了GPU渲染，但与CPU渲染结合使用缓存为位图也会在处理复杂矢量图形时提高性能。然而，直接在GPU上缓存会产生最大的性能提升。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Cache as Bitmap is extremely powerful and when used correctly can be hugely
    beneficial. However, it is not always apparent when to use it and there are several
    pitfalls that you should be aware of.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存为位图功能非常强大，并且当正确使用时可以带来巨大的好处。然而，并不总是明显何时使用它，并且有一些陷阱你应该注意。
- en: Other transformation changes
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他变换更改
- en: Bitmap caching is only advantageous if the cached bitmap does not have to be
    frequently re-generated. While changes along the X or Y axes are fine, other changes
    will invalidate the cached bitmap, forcing the display object to be re-cached.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 位图缓存只有在缓存的位图不需要频繁重新生成时才有优势。虽然沿X轴或Y轴的变化是可以接受的，但其他变化将使缓存的位图无效，迫使显示对象重新缓存。
- en: For objects that don't change often, you may be willing to take the performance
    hit. However, frequent changes are likely to degrade the performance of your application,
    as each new change is rasterized and then copied back into the internal pixel
    buffer.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不经常变化的对象，你可能愿意承受性能损失。然而，频繁的变化可能会降低你应用程序的性能，因为每次新的更改都会进行光栅化，然后复制回内部像素缓冲区。
- en: 'The following is a list of changes that will force a display object to be re-cached:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个列表，列出了将强制显示对象重新缓存的更改：
- en: Visibility
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性
- en: Alpha transparency
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度
- en: Transformation—Scale and Rotation
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换—缩放和旋转
- en: Playhead movement within the object's timeline
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象的时线上移动播放头
- en: Any change to a child object
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对子对象的任何更改
- en: Constantly re-caching is very expensive and will slow your application. If you
    need to make frequent changes to an object, then either avoid using Cache as Bitmap,
    or deactivate it during such periods. Improper use of Cache as Bitmap will reduce
    the render performance of your application rather than improve it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 持续重新缓存非常昂贵，并且会减慢你的应用程序。如果你需要频繁更改对象，那么要么避免使用缓存为位图，要么在这些期间将其停用。不正确地使用缓存为位图将降低你的应用程序的渲染性能，而不是提高它。
- en: Caching display objects that contain children
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存包含子对象的显示对象
- en: Be careful when setting Cache as Bitmap on display objects that contain children.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置包含子对象的显示对象的缓存为位图时要小心。
- en: An internal bitmap will be created of the entire container including all of
    its child objects. If any of those children change relative to the container,
    then the whole container clip will need to be re-cached. This is true even if
    a child object only changes its `x` or `y` position. It is only the container
    clip that can be successfully translated without invalidating the cached bitmap.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个容器及其所有子对象创建为内部位图。如果这些子对象相对于容器有任何变化，那么整个容器剪辑就需要重新缓存。即使子对象只改变了其`x`或`y`位置，也是如此。只有容器剪辑才能成功平移而不使缓存的位图无效。
- en: For nested clips, apply Cache as Bitmap to the lowest leaf node that changes
    relative to its container. Don't apply Cache as Bitmap to the container itself.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套剪辑，将缓存为位图应用于相对于其容器发生变化的最低叶节点。不要将缓存为位图应用于容器本身。
- en: This is a common mistake and can cripple the performance of your application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的错误，可能会损害你应用程序的性能。
- en: Taking advantage of GPU Blend
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用GPU混合的优势
- en: If you are using Flash Professional CS5 and wish to take advantage of GPU rendering,
    then the use of Cache as Bitmap is essential for GPU Blend to be effective. It
    isn't just vectors that can benefit either—bitmap performance can be accelerated
    too.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Flash Professional CS5并希望利用GPU渲染，那么使用缓存为位图对于GPU混合的有效性是必不可少的。不仅矢量可以从中受益，位图性能也可以得到加速。
- en: Where cached bitmaps are stored is important. When using GPU rendering, the
    cached bitmaps will be stored directly on the GPU as textures. This is of particular
    importance when using GPU Blend as it removes the bandwidth bottleneck experienced
    when bitmap data is repeatedly transferred from the CPU to the GPU.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的位图存储位置很重要。当使用GPU渲染时，缓存的位图将直接存储在GPU上作为纹理。这在使用GPU混合时尤为重要，因为它消除了当位图数据反复从CPU传输到GPU时遇到的带宽瓶颈。
- en: By using bitmap caching in conjunction with GPU Blend, rendering performance
    will be vastly increased. The only time bitmap data will be transferred from the
    CPU to the GPU will be when each display object is initially cached, or when a
    cached bitmap needs to be regenerated.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合使用位图缓存和GPU混合，渲染性能将大大提高。位图数据将从CPU传输到GPU的唯一时间是在每个显示对象最初缓存时，或者当缓存的位图需要重新生成时。
- en: For GPU Blend, Cache as Bitmap will accelerate both display objects that use
    vectors and those that use bitmaps. Where possible, try to take advantage of it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GPU混合，缓存为位图将加速使用矢量的显示对象和使用位图的显示对象。尽可能利用它。
- en: Bitmaps and GPU Vector
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位图和GPU矢量
- en: While applying Cache as Bitmap to bitmaps provides acceleration for GPU Blend,
    the same isn't true for GPU Vector and will actually slightly degrade performance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将缓存为位图应用于位图可以加速GPU混合，但对于GPU矢量来说并不适用，实际上可能会略微降低性能。
- en: When you cache a display object, you are essentially creating a pixel buffer.
    However, that is exactly what a bitmap is anyway. By caching bitmaps when using
    GPU Vector, you are simply creating a secondary copy of your bitmap, which will
    only consume more memory and take time to perform the second copy.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你缓存一个显示对象时，你实际上是在创建一个像素缓冲区。然而，位图本质上就是这样。在使用GPU矢量时缓存位图，你只是在创建位图的副本来，这只会消耗更多的内存并花费时间来执行第二次复制。
- en: In GPU-Blend mode, Cache as Bitmap is used to copy the bitmaps to GPU memory.
    In GPU-Vector mode, the bitmaps are already in GPU memory, removing the need for
    Cache as Bitmap.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU-混合模式下，缓存为位图用于将位图复制到GPU内存中。在GPU-矢量模式下，位图已经位于GPU内存中，因此不需要缓存为位图。
- en: Using vectors ahead of bitmaps
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在位图之前使用矢量
- en: When working with vector artwork, Cache as Bitmap can be used to produce the
    performance benefits typically associated with bitmaps. Simply create your artwork
    using Flash's drawing tools and then set Cache as Bitmap for each movie clip that
    contains that vector artwork. The clips will be rasterized and the cached bitmap
    versions will be used from that point onwards.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理矢量图形时，可以使用“缓存为位图”来产生与位图通常相关的性能优势。只需使用Flash的绘图工具创建您的图形作品，然后为包含该矢量图形的每个电影剪辑设置“缓存为位图”。从那时起，剪辑将被光栅化，并使用缓存的位图版本。
- en: This technique is almost as fast as simply using a bitmap representation of
    your artwork. The only difference being is that a vector version first has to
    be converted to a bitmap, which will result in a slight performance hit when the
    object first appears on screen. If the size of your IPA is a concern or you genuinely
    need to use vector artwork, then this option is ideal.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术几乎与直接使用您作品的位图表示一样快。唯一的区别是，矢量版本首先必须转换为位图，这将在对象首次出现在屏幕上时产生轻微的性能影响。如果您的IPA大小是问题，或者您确实需要使用矢量图形，那么这个选项是理想的。
- en: See also
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Adding content to the stage, [Chapter 2](ch02.html "Chapter 2. Building iOS
    Apps Using Flash")*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将内容添加到舞台，[第2章](ch02.html "第2章。使用Flash构建iOS应用")*'
- en: '*Masking content, [Chapter 4](ch04.html "Chapter 4. Porting Flash Projects
    to iOS")*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遮罩内容，[第4章](ch04.html "第4章。将Flash项目移植到iOS")*'
- en: '*Using Cache as Bitmap Matrix*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存为位图矩阵*'
- en: Using Cache as Bitmap Matrix
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存为位图矩阵
- en: Cache as Bitmap is extremely useful for display objects that are only affected
    by two-dimensional translation. However, it is also possible to benefit from bitmap
    caching when applying other changes to a display object such as scaling and rotation.
    This is achieved by using a transform matrix in conjunction with a cached bitmap
    and is known as Cache as Bitmap Matrix.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: “缓存为位图”对于仅受二维平移影响的显示对象非常有用。然而，在应用其他更改到显示对象（如缩放和旋转）时，也可以从位图缓存中受益。这是通过结合使用变换矩阵和缓存的位图来实现的，被称为“缓存为位图矩阵”。
- en: Let us work through an example.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来操作。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point. From the book's accompanying code
    bundle, open `chapter6\recipe5\recipe.fla` into Flash Professional.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供一个FLA作为起点。从本书的配套代码包中，在Flash Professional中打开`chapter6\recipe5\recipe.fla`。
- en: Ten instances of a **Monkey** movie clip are positioned on top of a **Background**
    movie clip. All ten movie clips are continuously rotated and after five seconds,
    the average frame rate that was achieved is displayed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 10个**Monkey**电影剪辑被放置在**背景**电影剪辑的上方。所有10个电影剪辑都在持续旋转，并在五秒后，显示达到的平均帧率。
- en: The movie clips used for this recipe are constructed from vector graphics and
    the FLA has been set to use GPU rendering.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此菜谱的电影剪辑是由矢量图形构成的，并且FLA已设置为使用GPU渲染。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Work through the following steps to see the performance benefit Cache as Bitmap
    Matrix provides for each of the rotating movie clips.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作，以查看“缓存为位图矩阵”为每个旋转电影剪辑提供的性能优势。
- en: Publish the current version of the FLA and deploy it to a device.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布当前的FLA版本并将其部署到设备上。
- en: Launch the app and take a note of the frame rate that is reported after five
    seconds.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用，并在五秒后记录报告的帧率。
- en: Delete the app from your device.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的设备中删除该应用。
- en: Move back to `recipe.fla` within Flash Professional.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Flash Professional中的`recipe.fla`。
- en: 'Open the FLA''s `Main.as` document class and add the following lines of code
    within the constructor:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开FLA的`Main.as`文档类，并在构造函数中添加以下代码行：
- en: '[PRE4]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, add an import statement for the `Matrix` class:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加对`Matrix`类的导入语句：
- en: '[PRE5]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the document class.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档类。
- en: Publish and deploy to your device.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布并部署到您的设备。
- en: Compare the number of frames rendered against the previous version of the app.
    It should be improved.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将渲染的帧数与应用的上一版本进行比较。应该有所改进。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cache as Bitmap Matrix prevents a display object's cached bitmap from becoming
    invalid when any two-dimensional transformation is applied. The same is also true
    for a change in visibility or alpha transparency. Therefore, for any of these
    changes, the cached bitmap won't be regenerated; the changes will instead be applied
    directly to the cached bitmap's internal pixel buffer, which is advantageous as
    the display object won't need to be re-rasterized.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: “缓存为位图矩阵”可以防止在应用任何二维变换时，显示对象的缓存的位图变得无效。同样，对于可见性或alpha透明度的更改也是如此。因此，对于这些更改中的任何一种，缓存的位图都不会被重新生成；更改将直接应用于缓存的位图的内部像素缓冲区，这有利于显示对象不需要重新光栅化。
- en: Unlike Cache as Bitmap, Cache as Bitmap Matrix cannot be set from Flash's **Properties**
    panel. Instead, use ActionScript to set the `cacheAsBitmapMatrix` property provided
    by the `DisplayObject` class.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与“缓存为位图”不同，“缓存为位图矩阵”不能从Flash的**属性**面板中设置。相反，请使用ActionScript来设置由`DisplayObject`类提供的`cacheAsBitmapMatrix`属性。
- en: The `cacheAsBitmapMatrix` property is set by passing it a `Matrix` object and
    is used to generate the cached bitmap. For this recipe, we passed the identity
    matrix, which forced the display objects to be rasterized without any change in
    appearance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递一个`Matrix`对象来设置`cacheAsBitmapMatrix`属性，并用于生成缓存的位图。对于本食谱，我们传递了单位矩阵，这强制显示对象以不改变外观的方式被光栅化。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In mathematics, a matrix is a rectangular array of numbers, which can be used
    to apply a transformation to points in 2D or 3D space. A matrix can be used to
    apply various graphical transformations to Flash display objects, such as translation,
    rotation, scaling, and skewing. An identity matrix is a special matrix that does
    not alter the appearance of any points that it is applied to.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，矩阵是一个数字的矩形数组，可以用于将变换应用于2D或3D空间中的点。矩阵可以用于将各种图形变换应用于Flash显示对象，例如平移、旋转、缩放和扭曲。单位矩阵是一个特殊的矩阵，它不会改变其应用到的任何点的外观。
- en: The `flash.geom.Matrix` class is provided by the Flash API, making it easy to
    create matrices that can be used to perform transformations upon your display
    objects. When instantiating a `Matrix` object, an identity matrix is created if
    you do not provide any parameters to the constructor.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.geom.Matrix`类由Flash API提供，这使得创建可用于在显示对象上执行变换的矩阵变得容易。当实例化`Matrix`对象时，如果您没有向构造函数提供任何参数，将创建一个单位矩阵。'
- en: 'The `cacheAsBitmapMatrix` property cannot be used on its own and must always
    be set in conjunction with the `cacheAsBitmap` property. You can see this in the
    following code snippet taken from this recipe''s example code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheAsBitmapMatrix`属性不能单独使用，必须始终与`cacheAsBitmap`属性一起设置。您可以在以下代码片段中看到这一点，该片段取自本食谱的示例代码：'
- en: '[PRE6]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have already applied Cache as Bitmap on a display object, then there
    is no penalty for also applying Cache as Bitmap Matrix. In fact, this is the recommended
    practice as it will prevent performance penalties if changes other than to an
    object's `x` and `y` properties are made.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在显示对象上应用了“缓存为位图”，那么再应用“缓存为位图矩阵”也不会有任何惩罚。实际上，这是推荐的做法，因为它可以防止在除了对象的`x`和`y`属性之外进行更改时出现性能惩罚。
- en: The following table shows the benefits of using Cache as Bitmap Matrix by highlighting
    changes that won't invalidate the cached bitmap.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格通过突出显示不会使缓存的位图无效的更改，显示了使用“缓存为位图矩阵”的好处。
- en: '|   | Translate | Scale | Rotate | Skew | Alpha | Visibility |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|   | 平移 | 缩放 | 旋转 | 扭曲 | 透明度 | 可见性 |'
- en: '| `cacheAsBitmap` | ![How it works...](img/icon1.jpg) |   |   |   |   |   |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `cacheAsBitmap` | ![如何工作...](img/icon1.jpg) |   |   |   |   |   |'
- en: '| `cacheAsBitmap` and `cacheAsBitmapMatrix` | ![How it works...](img/icon1.jpg)
    | ![How it works...](img/icon1.jpg) | ![How it works...](img/icon1.jpg) | ![How
    it works...](img/icon1.jpg) | ![How it works...](img/icon1.jpg) | ![How it works...](img/icon1.jpg)
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `cacheAsBitmap` 和 `cacheAsBitmapMatrix` | ![如何工作...](img/icon1.jpg) | ![如何工作...](img/icon1.jpg)
    | ![如何工作...](img/icon1.jpg) | ![如何工作...](img/icon1.jpg) | ![如何工作...](img/icon1.jpg)
    | ![如何工作...](img/icon1.jpg) |'
- en: When scaling or rotating a vector display object that has been cached, there
    may be a loss of fidelity as the transformations will be applied to the cached
    bitmap rather than to the original vector artwork. Therefore, the final rendition
    will exhibit the artifacts associated with scaling or rotating bitmap images.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当缩放或旋转一个已经被缓存的矢量显示对象时，由于变换将应用于缓存的位图而不是原始矢量艺术品，因此可能会出现保真度损失。因此，最终呈现的效果将显示出与缩放或旋转位图图像相关的伪影。
- en: Setting the `cacheAsBitmapMatrix` property generates a cached bitmap even if
    the display object is off-screen or has its `visible` property set to `false`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `cacheAsBitmapMatrix` 属性即使在显示对象在屏幕外或其 `visible` 属性设置为 `false` 时也会生成缓存的位图。
- en: 'If you are curious about matrices, then perform a search for `flash.geom.Matrix`
    within Adobe Community Help. For a better understanding of matrix mathematics,
    refer to Wikipedia: [http://en.wikipedia.org/wiki/Matrix_(mathematics)](http://en.wikipedia.org/wiki/Matrix_(mathematics)).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对矩阵感兴趣，请在 Adobe Community Help 中搜索 `flash.geom.Matrix`。为了更好地理解矩阵数学，请参考维基百科：[http://en.wikipedia.org/wiki/Matrix_(mathematics)](http://en.wikipedia.org/wiki/Matrix_(mathematics))。
- en: There's more...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Now, let us explore Cache as Bitmap Matrix in more detail.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地探讨缓存为位图矩阵。
- en: Selecting a matrix transformation
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择矩阵变换
- en: The matrix transformation you set the `cacheAsBitmapMatrix` property to will
    be used to generate the cached bitmap.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您将 `cacheAsBitmapMatrix` 属性设置为的矩阵变换将用于生成缓存的位图。
- en: For example, you may choose to use a scale matrix to create a cached version
    of a vector movie clip that is actually twice the movie clip's original size.
    Although the cached bitmap would consume more memory, it would allow the movie
    clip to maintain its fidelity when being scaled to a maximum of twice its size.
    Alternatively, you could cache a version that is half the size of the original,
    reducing memory overheads at the expense of fidelity.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以选择使用缩放矩阵来创建一个缓存的向量电影剪辑版本，其实际大小是原始电影剪辑的两倍。尽管缓存的位图将消耗更多内存，但它允许电影剪辑在缩放到最大两倍大小时保持其保真度。或者，您也可以缓存一个大小为原始大小一半的版本，以减少内存开销，但会牺牲保真度。
- en: It is important to note that creating a cached bitmap that is different in size
    to the actual display object doesn't alter the size of the object on screen. In
    other words, if your display object is 100x100 pixels in size and its cached bitmap
    is 50x50 pixels, the object will remain 100x100 pixels in size on screen. AIR
    will take the 50x50 cached bitmap and actually double its dimensions to ensure
    it is shown at the correct size.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，创建与实际显示对象大小不同的缓存的位图不会改变屏幕上对象的大小。换句话说，如果您的显示对象大小为 100x100 像素，其缓存的位图大小为
    50x50 像素，对象在屏幕上仍然保持 100x100 像素的大小。AIR 会将 50x50 的缓存位图实际加倍其尺寸，以确保以正确的尺寸显示。
- en: 'The following code example shows how to create a cached bitmap that is half
    the size of the actual display object:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何创建一个大小为实际显示对象一半的缓存的位图：
- en: '[PRE7]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, generally the identity matrix will suffice:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，单位矩阵就足够了：
- en: '[PRE8]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Changing the Matrix object
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改矩阵对象
- en: A common pitfall is attempting to apply two-dimensional transformations to a
    display object by altering the `cacheAsBitmapMatrix` transform. Making changes
    to this matrix will actually invalidate the cache, forcing a new bitmap to be
    generated.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的陷阱是尝试通过改变 `cacheAsBitmapMatrix` 变换来对显示对象应用二维变换。对这个矩阵的更改实际上会无效化缓存，迫使生成新的位图。
- en: To apply transforms such as scaling and rotation to your display object, simply
    use its two-dimensional transformation properties such as `scaleX, scaleY`, and
    `rotation`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用缩放和旋转等变换到您的显示对象，只需使用其二维变换属性，如 `scaleX, scaleY` 和 `rotation`。
- en: For most use cases, the `cacheAsBitmapMatrix` property should be set once for
    a display object, and then left untouched.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用例，`cacheAsBitmapMatrix` 属性应为一个显示对象设置一次，然后保持不变。
- en: Reusing the Matrix object
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复使用矩阵对象
- en: 'If you are applying the same transformation matrix to a series of display objects,
    then create a single instance of the `Matrix` object and re-use it. It is a common
    mistake to recreate the `Matrix` object each time:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将相同的变换矩阵应用到一系列显示对象上，则创建一个 `Matrix` 对象的单例并重复使用它。每次都重新创建 `Matrix` 对象是一个常见的错误：
- en: '[PRE9]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code will compile and run but will create 100 copies of the identity matrix.
    This will unnecessarily consume memory and degrade performance due to the number
    of memory allocations and eventual garbage collection.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将编译并运行，但会创建 100 个单位矩阵的副本。这将无谓地消耗内存，并由于内存分配和最终垃圾回收的数量而降低性能。
- en: 'Instead, create the matrix outside of your loop and re-use it as shown in the
    following code snippet:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在循环外部创建矩阵，并如以下代码片段所示重复使用它：
- en: '[PRE10]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 3D properties
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3D 属性
- en: When a display object has a 3D property applied to it, that object automatically
    becomes cached and you have no control over the transformation matrix that is
    used to generate the cached bitmap. The `cacheAsBitmapMatrix` property can only
    be used with display objects that don't have any 3D properties set. If you set
    a 3D property, such as `z` or `rotationX`, on a display object that has bitmap
    caching applied, then your cached bitmap will be deactivated and a new bitmap
    will be generated.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个显示对象应用了 3D 属性时，该对象会自动被缓存，并且你无法控制用于生成缓存位图的变换矩阵。`cacheAsBitmapMatrix` 属性只能用于没有设置任何
    3D 属性的显示对象。如果你在一个应用了位图缓存的显示对象上设置了 3D 属性，例如 `z` 或 `rotationX`，那么你的缓存位图将被禁用，并将生成一个新的位图。
- en: Using 3D properties provides most of the benefits of manually setting the `cacheAsBitmapMatrix`
    property. The one exception is that setting a 3D object's `visible` property to
    `false` will invalidate its cached bitmap.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 3D 属性提供了手动设置 `cacheAsBitmapMatrix` 属性的大部分好处。唯一的例外是，将 3D 对象的 `visible` 属性设置为
    `false` 将使其缓存的位图无效。
- en: Working with GPU Blend
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 GPU 混合
- en: Some of the largest performance gains are once again to be had when using AIR
    2.0's GPU-Blend rendering mode.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 AIR 2.0 的 GPU-Blend 渲染模式时，一些最大的性能提升再次出现。
- en: If you have been using Flash Professional CS5 and developing on an older iOS
    device, then the examples from the *Rotating an object* and *Zooming an object*
    recipes in [Chapter 5](ch05.html "Chapter 5. Multi-touch and Gesture Support")
    may have performed poorly. Setting the `cacheAsBitmap` and `cacheAsBitmapMatrix`
    properties will ensure the movie clip used in each example is stored and transformed
    directly on the GPU.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用 Flash Professional CS5 并在较旧的 iOS 设备上开发，那么 [第 5 章](ch05.html "第 5 章。多点触控和手势支持")
    中 *旋转对象* 和 *缩放对象* 菜谱的示例可能表现不佳。设置 `cacheAsBitmap` 和 `cacheAsBitmapMatrix` 属性将确保每个示例中使用的电影剪辑被存储并直接在
    GPU 上变换。
- en: 'If performance was an issue, then revisit these recipes and add the following
    two lines of code to the constructor within each FLA''s document class:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能是个问题，那么重新查看这些菜谱，并在每个 FLA 文档类的构造函数中添加以下两行代码：
- en: '[PRE11]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, remember to import the `Matrix` class:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记得导入 `Matrix` 类：
- en: '[PRE12]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is also worth noting that it is not just vector graphics that benefit from
    Cache as Bitmap Matrix when using GPU Blend. Cache as Bitmap Matrix will also
    accelerate the rendering of bitmaps that have two-dimensional transformations
    applied to them. However, the opposite is true for GPU Vector, where Cache as
    Bitmap Matrix will actually harm performance when using bitmaps.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当使用 GPU 混合时，受益于 Cache as Bitmap Matrix 的不仅仅是矢量图形。Cache as Bitmap Matrix
    也会加速应用了二维变换的位图的渲染。然而，对于 GPU 矢量来说，Cache as Bitmap Matrix 实际上会损害性能，当使用位图时。
- en: See also
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Rotating an object, [Chapter 5](ch05.html "Chapter 5. Multi-touch and Gesture
    Support")*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旋转对象，[第 5 章](ch05.html "第 5 章。多点触控和手势支持")*'
- en: '*Zooming an object, [Chapter 5](ch05.html "Chapter 5. Multi-touch and Gesture
    Support")*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缩放对象，[第 5 章](ch05.html "第 5 章。多点触控和手势支持")*'
- en: Accessing bitmaps with ActionScript
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ActionScript 访问位图
- en: The GPU found on iOS devices is optimized for rendering bitmaps rather than
    the complex vector shapes that can be produced using Flash. This makes bitmaps
    the preferred graphics option when building high performance apps. While bitmaps
    can be stored in the library and simply dragged to a timeline during development,
    they can also be directly manipulated at runtime using ActionScript.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 设备上找到的 GPU 优化于渲染位图，而不是使用 Flash 可以生成的复杂矢量形状。这使得位图在构建高性能应用程序时成为首选的图形选项。虽然位图可以存储在库中，并在开发期间简单地拖放到时间轴上，但它们也可以使用
    ActionScript 在运行时直接操作。
- en: This recipe will show you how to add a bitmap to the display list at runtime.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示如何在运行时向显示列表添加位图。
- en: Getting ready
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter6\recipe6\recipe.fla`
    into Flash Professional.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，打开 `chapter6\recipe6\recipe.fla` 到 Flash Professional。
- en: Sitting in the library is a bitmap named **monkey.png**. We will write code
    to add this bitmap to the display list.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中有一个名为 **monkey.png** 的位图。我们将编写代码将这个位图添加到显示列表中。
- en: How to do it...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will split this recipe into two parts. First we will export the bitmap for
    ActionScript usage, before actually writing some ActionScript to display it at
    runtime.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个菜谱分成两部分。首先，我们将导出位图以供 ActionScript 使用，然后再实际编写一些 ActionScript 代码在运行时显示它。
- en: Exporting the bitmap
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出位图
- en: Let us start by exporting the bitmap's data for ActionScript usage.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导出位图数据以供ActionScript使用。
- en: Within the library, right-click on **monkey.png** and select **Properties**
    from the context menu.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库中，右键单击**monkey.png**，然后从上下文菜单中选择**属性**。
- en: From the **Bitmap Properties** dialog box, set the **Compression** field to
    **Lossless (PNG/GIF)**. If you are using Flash Professional CS5.5, then ensure
    that the **Options** tab is selected first.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**位图属性**对话框中，将**压缩**字段设置为**无损（PNG/GIF）**。如果您使用的是Flash Professional CS5.5，请确保首先选中**选项**选项卡。
- en: Now check the **Export for ActionScript** checkbox and change the text within
    the **Class** field to `MonkeyBitmapData`. If you are using Flash Professional
    CS5.5, then this should be performed from the panel's **ActionScript** tab.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在勾选**导出为ActionScript**复选框，并将**类**字段中的文本更改为`MonkeyBitmapData`。如果您使用的是Flash Professional
    CS5.5，则应从面板的**ActionScript**选项卡中执行此操作。
- en: 'A warning panel will appear containing the following text:'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将会弹出一个包含以下文本的警告面板：
- en: '**A definition for this class could not be found in the classpath, so one will
    be automatically generated in the SWF file upon export.**'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**在类路径中找不到此类的定义，因此将在导出时在SWF文件中自动生成。**'
- en: This is the expected behavior. Click on **OK.**
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是预期的行为。点击**确定**。
- en: Save the FLA.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存FLA文件。
- en: Displaying the bitmap using ActionScript
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ActionScript显示位图
- en: With the bitmap's data now accessible to ActionScript, let us go ahead and write
    some code to display it.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在位图的数据对ActionScript可访问后，让我们继续编写一些代码来显示它。
- en: Create a document class and name it `Main`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为`Main`。
- en: 'Add the following import statement:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入语句：
- en: '[PRE13]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Within the constructor add a line of ActionScript to create an instance of
    the bitmap data sitting in the library:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加一行ActionScript来创建库中位图数据的实例：
- en: '[PRE14]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, create a `Bitmap` object that uses the bitmap data:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个使用位图数据的`Bitmap`对象：
- en: '[PRE15]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, position the bitmap and add it to the display list:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定位位图并将其添加到显示列表：
- en: '[PRE16]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the class as `Main.as`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类保存为`Main.as`。
- en: Save your FLA and test using ADL. The bitmap image stored in the library will
    be displayed on screen.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的FLA文件并使用ADL进行测试。库中存储的位图图像将在屏幕上显示。
- en: Publish the FLA and deploy it to your device.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并将其部署到您的设备。
- en: How it works...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to access an image within the library, you need to explicitly export
    the image's bitmap data for ActionScript usage. We did this by assigning the bitmap
    a unique class name of `MonkeyBitmapData` from the **Bitmap Properties** dialog
    box. By using this class name, it is then possible to create an instance of that
    bitmap data using ActionScript.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在库中访问图像，您需要明确导出图像的位图数据以供ActionScript使用。我们通过从**位图属性**对话框中将位图分配一个唯一的类名`MonkeyBitmapData`来实现这一点。使用这个类名，就可以使用ActionScript创建该位图数据的实例。
- en: Once the bitmap data was obtained, we simply created a `Bitmap` display object
    and passed it a reference to the bitmap data. Displaying it was then a simple
    case of setting the bitmap's `x` and `y` properties before adding it to the display
    list.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了位图数据，我们只需创建一个`Bitmap`显示对象，并将其传递位图数据的引用。然后，显示它就变成了在将其添加到显示列表之前简单地设置位图的`x`和`y`属性。
- en: It should be noted that the class you linked the bitmap to is automatically
    generated when the SWF is published—there is no need to write code as it is done
    for you. When generated, it will inherit from `flash.display.BitmapData` allowing
    you to treat any instances of it as a `BitmapData` object.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，您链接到位图的类将在发布SWF时自动生成——您不需要编写代码，因为这是为您完成的。生成时，它将继承自`flash.display.BitmapData`，这使得您可以将其任何实例视为`BitmapData`对象。
- en: Every bitmap you export for ActionScript will be included directly within your
    app's binary, which will increase both its initial load time and memory footprint.
    Be careful as there is no way to free these bitmaps from memory once you are finished
    with them—an app that supports both standard and Retina graphics for example,
    could easily exhaust memory using this technique. However, with the bitmap data
    stored directly within the app's binary, access to that data will be fast.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 您为ActionScript导出的每个位图都将直接包含在您的应用程序的二进制文件中，这将增加其初始加载时间和内存占用。请注意，一旦您完成这些位图，就无法从内存中释放它们——例如，支持标准图形和Retina图形的应用程序可能会很容易地通过此技术耗尽内存。然而，由于位图数据直接存储在应用程序的二进制文件中，访问这些数据将会很快。
- en: For more information regarding bitmaps, perform a search for `flash.display.Bitmap`
    and `flash.display.BitmapData` within Adobe Community Help.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有关位图的更多信息，请在 Adobe Community Help 中搜索 `flash.display.Bitmap` 和 `flash.display.BitmapData`。
- en: There's more...
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are performance gains to be had when using bitmaps. The following information
    will help you take full advantage of GPU acceleration when working directly with
    them.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位图可以获得性能提升。以下信息将帮助您在直接使用位图时充分利用 GPU 加速。
- en: Managing image sizes
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理图像大小
- en: If you are using GPU rendering and working with bitmap images, then there are
    some optimizations you can perform to maximize performance.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 GPU 渲染并处理位图图像，那么您可以执行一些优化以最大化性能。
- en: The GPU allocates memory using powers of 2 for each of a bitmap's dimensions.
    For example, a 31x15 bitmap will be allocated the same amount of memory as a 32x16
    bitmap, while a 33x17 bitmap will consume the same memory as a 64x32 bitmap. The
    size of each bitmap also impacts rendering performance, as memory copies take
    longer for larger bitmaps.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 使用 2 的幂次为每个位图的维度分配内存。例如，一个 31x15 的位图将分配与 32x16 位图相同的内存量，而一个 33x17 的位图将消耗与
    64x32 位图相同的内存量。每个位图的大小也会影响渲染性能，因为内存复制对于较大的位图来说会更耗时。
- en: Use bitmaps with dimensions that are close to a power of 2 but not larger. The
    dimensions don't have to be exact powers of 2, as Flash will pad the bitmaps for
    you.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接近 2 的幂次的位图尺寸，但不要更大。尺寸不必是 2 的精确幂次，因为 Flash 会为您填充位图。
- en: Size restrictions
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大小限制
- en: 'There is a size restriction imposed by the GPU. The actual size depends on
    the iOS hardware you are using. For older devices, your display objects cannot
    exceed 1024x1024 pixels in size. The more recent devices allow display objects
    with a maximum of 2048x2048 pixels in size. The following table summarizes this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 施加了一个大小限制。实际大小取决于您使用的 iOS 硬件。对于旧设备，您的显示对象的大小不能超过 1024x1024 像素。较新的设备允许显示对象的最大大小为
    2048x2048 像素。以下表格总结了这一点：
- en: '|   | iPhone | iPod touch | iPad |   |   |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|   | iPhone | iPod touch | iPad |   |   |'
- en: '|   | original and 3G | 3GS and 4/4S | 1st and 2nd gen | 3rd and 4th gen |
    1 and 2 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|   | 原版和 3G | 3GS 和 4/4S | 第 1 代和第 2 代 | 第 3 代和第 4 代 | 第 1 代和第 2 代 |'
- en: '| 1024x1024 | ![Size restrictions](img/icon1.jpg) |   | ![Size restrictions](img/icon1.jpg)
    |   |   |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 1024x1024 | ![大小限制](img/icon1.jpg) |   | ![大小限制](img/icon1.jpg) |   |   |'
- en: '| 2048x2048 |   | ![Size restrictions](img/icon1.jpg) |   | ![Size restrictions](img/icon1.jpg)
    | ![Size restrictions](img/icon1.jpg) |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 2048x2048 |   | ![大小限制](img/icon1.jpg) |   | ![大小限制](img/icon1.jpg) | ![大小限制](img/icon1.jpg)
    |'
- en: If you need to work with a display object that is larger than the size permitted
    by the GPU, then consider using Cache as Bitmap Matrix to cache a smaller representation
    of it.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要处理一个比 GPU 允许的大小更大的显示对象，那么考虑使用 Cache as Bitmap Matrix 来缓存其较小的表示形式。
- en: Storing bitmap data on the GPU
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 GPU 上存储位图数据
- en: When utilizing GPU rendering, any `BitmapData` that you export for ActionScript
    will be stored directly in GPU memory as a texture when instantiated. This is
    the case for both Flash Professional CS5's GPU-Blend mode and CS5.5's GPU-Vector
    mode, providing the fastest possible rendering path for both.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 GPU 渲染时，您为 ActionScript 导出的任何 `BitmapData` 都将在实例化时直接存储在 GPU 内存中作为纹理。这适用于
    Flash Professional CS5 的 GPU-Blend 模式和 CS5.5 的 GPU-Vector 模式，为两者提供最快的渲染路径。
- en: There is no need to explicitly set a `Bitmap` object's `cacheAsBitmap` and `cacheAsBitmapMatrix`
    properties, as the bitmap data used by it will already be GPU-accelerated. In
    fact, doing so will only serve to create a duplicate copy of the data that is
    already on the GPU, which would be a waste of memory.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要显式设置 `Bitmap` 对象的 `cacheAsBitmap` 和 `cacheAsBitmapMatrix` 属性，因为它使用的位图数据已经进行了
    GPU 加速。实际上，这样做只会创建一个已经在 GPU 上的数据的副本，这将浪费内存。
- en: While display objects that have bitmap caching applied to them become textures,
    `BitmapData` objects *are* textures on the GPU. This distinction is important
    and has implications when managing memory. When working with multiple `Bitmap`
    instances, each bitmap can be made to point to the exact same `BitmapData` object,
    meaning only one texture is required on the GPU and shared by all. Applying bitmap
    caching to multiple instances of the same display object, however, uploads an
    individual texture for each, consuming more memory.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用位图缓存的显示对象成为纹理时，`BitmapData` 对象 *是* GPU 上的纹理。这种区别很重要，并且在管理内存时有影响。当与多个 `Bitmap`
    实例一起工作时，每个位图都可以指向完全相同的 `BitmapData` 对象，这意味着 GPU 上只需要一个纹理，并由所有实例共享。然而，将位图缓存应用于同一显示对象的多个实例时，将为每个实例上传一个单独的纹理，消耗更多内存。
- en: See also
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将类链接到电影剪辑符号，[第 3 章](ch03.html "第 3 章。编写您的第一个应用程序")*'
- en: '*Using Cache as Bitmap Matrix*'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓存作为位图矩阵*'
- en: '*Loading bitmaps at runtime*'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在运行时加载位图*'
- en: Loading bitmaps at runtime
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时加载位图
- en: It is a common practice to minimize an app's up-front load time and memory footprint
    by loading graphics resources on demand. When making use of bitmaps, it is possible
    to store them outside of your app's binary and use ActionScript to load them at
    runtime when required.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按需加载图形资源，这是一种常见的做法，可以最小化应用程序的前端加载时间和内存占用。当使用位图时，可以将它们存储在应用程序的二进制文件之外，并使用 ActionScript
    在需要时在运行时加载它们。
- en: Let us see how this is done.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何操作的。
- en: Getting ready
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供一个 FLA 文件作为起点。
- en: From the book's accompanying code bundle, open `chapter6\recipe7\recipe.fla`
    into Flash Professional. Its AIR for iOS settings have been applied and a dynamic
    text field has been added at the bottom of the stage.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter6\recipe7\recipe.fla` 打开到 Flash Professional 中。其 AIR for
    iOS 设置已应用，并在舞台底部添加了一个动态文本字段。
- en: Additionally, `chapter6\recipe7\monkey.png` has been provided, which is the
    bitmap we will load at runtime.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`chapter6\recipe7\monkey.png` 已经提供，这是我们将在运行时加载的位图。
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This recipe is split into two parts. First, we will bundle the bitmap with the
    app, then we will write some ActionScript to load it.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方分为两部分。首先，我们将位图与应用程序捆绑在一起，然后我们将编写一些 ActionScript 来加载它。
- en: Bundling the bitmap
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捆绑位图
- en: Perform the following steps to bundle the bitmap with the app.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将位图与应用程序捆绑在一起。
- en: Open the **AIR for iOS Settings** panel and ensure that the panel's **General**
    tab is selected.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **AIR for iOS 设置** 面板并确保已选择面板的 **常规** 选项卡。
- en: At the bottom of the panel is the **Included files** list. Click on the **+**
    symbol above the list and select **monkey.png** from your FLA's root folder. Click
    on **Open** to select the file. You should now see **monkey.png** in the **Included
    files** list.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面板底部是 **包含的文件** 列表。点击列表上方的 **+** 符号，然后从 FLA 的根文件夹中选择 **monkey.png**。点击 **打开**
    选择文件。现在你应该在 **包含的文件** 列表中看到 **monkey.png**。
- en: Click on **OK** to close the **AIR for iOS Settings** panel.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **OK** 关闭 **AIR for iOS 设置** 面板。
- en: Loading the bitmap at runtime
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在运行时加载位图
- en: Now, let us write the ActionScript required to load the bitmap and display it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写加载位图并显示它的 ActionScript。
- en: Create a document class and name it `Main`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类并命名为 `Main`。
- en: 'Add the following import statements:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入语句：
- en: '[PRE17]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Within the constructor, create an instance of the `Loader` class; listen for
    `Event.COMPLETE` being dispatched when the bitmap has loaded; and initiate the
    load:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，创建 `Loader` 类的实例；监听位图加载时发出的 `Event.COMPLETE` 事件；并开始加载：
- en: '[PRE18]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, add a handler for `Event.COMPLETE`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个处理 `Event.COMPLETE` 的事件处理器。
- en: '[PRE19]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `bitmapLoaded()` handler will add the loaded bitmap to the stage. The bitmap
    is obtained from the handler's event parameter, positioned then added to the display
    list.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bitmapLoaded()` 事件处理器会将加载的位图添加到舞台。位图从事件处理器的参数中获取，然后定位并添加到显示列表中。'
- en: Save the class; when prompted name the file `Main.as`.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类；当提示时，将文件命名为 `Main.as`。
- en: Save the FLA and test using ADL to ensure there are no compiler errors. The
    bitmap should load and be positioned on screen. Additionally, the text field should
    be populated with the word **loaded** indicating success.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 FLA 并使用 ADL 测试以确保没有编译器错误。位图应该加载并定位在屏幕上。此外，文本字段应填充单词 **loaded**，表示成功。
- en: Finally, publish your app for iOS and deploy it to a device.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发布您的应用程序以供 iOS 使用并将它部署到设备上。
- en: How it works...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Resources can be bundled with an app by adding them to the **Included files**
    list from the AIR for iOS Settings panel. You can either add files individually
    or include the contents of a folder. For this recipe, we simply selected the `monkey.png`
    file, ensuring it would be bundled with the IPA.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将文件添加到AIR for iOS设置面板的**包含文件**列表中来将资源打包到应用程序中。您可以单独添加文件或包含文件夹的内容。对于此配方，我们仅选择了`monkey.png`文件，确保它将与IPA打包在一起。
- en: Your app's start-up time won't be affected by this as bundled resources aren't
    part of its binary. Instead, during installation, they will be copied to the same
    directory as the app, allowing the app to load them from the device's file system
    at runtime.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于打包的资源不是其二进制的一部分，因此这不会影响您的应用程序的启动时间。相反，在安装过程中，它们将被复制到与应用程序相同的目录中，允许应用程序在运行时从设备的文件系统中加载它们。
- en: To actually load the bitmap, an instance of the `Loader` class was used and
    a call to its `load()` method was made. Load operations are asynchronous—loading
    from the device's file system can take time—meaning we had to listen for `Event.COMPLETE`
    being dispatched before attempting to access the bitmap.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 实际加载位图时，使用了`Loader`类的实例并调用了其`load()`方法。加载操作是异步的——从设备的文件系统中加载可能需要时间——这意味着在尝试访问位图之前，我们必须监听`Event.COMPLETE`事件。
- en: 'With `monkey.png` being bundled into the same folder as the app itself, a relative
    file path was passed to `load()` rather than an absolute path:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`monkey.png`与应用程序本身打包在同一文件夹中，因此传递给`load()`的是相对文件路径，而不是绝对路径：
- en: '[PRE20]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the bitmap has loaded, the `COMPLETE` event's handler is called and the
    bitmap is displayed on screen.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦位图加载完成，`COMPLETE`事件的处理程序就会被调用，位图就会显示在屏幕上。
- en: 'To actually obtain the bitmap, simply extract the loaded content from the `Event`
    object and cast it to a `Bitmap`. The following line of code does that:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际获取位图，只需从`Event`对象中提取加载的内容并将其转换为`Bitmap`。以下代码行执行此操作：
- en: '[PRE21]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You are then free to manipulate the bitmap and add it to the display list.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以自由地操作位图并将其添加到显示列表中。
- en: Loading bitmaps at runtime rather than including them directly within your FLA's
    library will reduce the overall size of an app's binary, which will lead to improved
    start-up times. Additionally, in contrast to resources embedded directly within
    the app's binary, you will be able to manage your app's memory usage by freeing
    those bitmaps once you are done with them. While bitmaps directly included within
    the app will be immediately available, you will actually need to wait for bitmaps
    from the file system to load.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时加载位图而不是直接将其包含在FLA库中，可以减小应用程序二进制文件的整体大小，从而提高启动时间。此外，与直接嵌入到应用程序二进制文件中的资源相比，您将能够通过在完成使用后释放这些位图来管理应用程序的内存使用。虽然直接包含在应用程序中的位图将立即可用，但您实际上需要等待从文件系统中加载的位图。
- en: The `Loader` class loads content asynchronously. This is convenient as it prevents
    the execution of your application from being blocked while resources are being
    loaded.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loader`类异步加载内容。这很方便，因为它可以防止在资源加载时阻塞应用程序的执行。'
- en: You can obtain more detail regarding the classes used in this recipe from Adobe
    Community Help. Specifically, take a look at `flash.display.Loader, flash.display.Bitmap`,
    and `flash.display.BitmapData`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Adobe社区帮助中获取有关此配方中使用的类的更多详细信息。具体来说，请查看`flash.display.Loader, flash.display.Bitmap`和`flash.display.BitmapData`。
- en: There's more...
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Before moving on, let us cover a few more points related to bitmap data.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们再讨论一些与位图数据相关的问题。
- en: Handling load errors
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理加载错误
- en: When loading bitmaps, you should also listen for `IOErrorEvent.IO_ERROR`, which
    is dispatched when a load operation fails. This will most commonly happen when
    a file path is incorrect or the resource that you are trying to load is missing.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载位图时，您还应该监听`IOErrorEvent.IO_ERROR`，当加载操作失败时将触发此事件。这通常发生在文件路径不正确或您尝试加载的资源缺失时。
- en: Accessing the bitmap's data
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问位图的数据
- en: 'You can easily access the bitmap''s data through the `Bitmap.bitmapData` property.
    The following code snippet illustrates this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`Bitmap.bitmapData`属性轻松访问位图的数据。以下代码片段说明了这一点：
- en: '[PRE22]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is also possible to point the `bitmapData` property to a different `BitmapData`
    object, changing the bitmap's appearance. This is extremely useful for creating
    animations programmatically and can be used to fully utilize hardware acceleration
    on the GPU.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`bitmapData`属性指向不同的`BitmapData`对象，从而改变位图的外观。这对于通过编程创建动画非常有用，并且可以用于充分利用GPU上的硬件加速。
- en: Disposing of bitmap data
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理位图数据
- en: 'While you typically rely on the garbage collector to free memory, you can force
    AIR, at runtime, to immediately release the bitmap data memory occupied by a `BitmapData`
    object. This is done by calling `BitmapData.dispose()` and is shown in the following
    code snippet:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你通常依赖垃圾回收器来释放内存，但你可以在运行时强制AIR立即释放 `BitmapData` 对象占用的位图数据内存。这是通过调用 `BitmapData.dispose()`
    来实现的，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `BitmapData` object itself isn't released, just its bitmap data. The memory
    consumed by the actual `BitmapData` object is eventually released by the garbage
    collector.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapData` 对象本身并没有被释放，只是它的位图数据。实际的 `BitmapData` 对象所占用的内存最终会被垃圾回收器释放。'
- en: When you no longer have a use for a bitmap, remember to dispose of its data.
    This will free memory, allowing you to load other bitmaps that couldn't otherwise
    be loaded and stored. You should, however, be careful when freeing bitmap data
    memory. Memory management can consume precious CPU cycles and hinder the performance
    of your application. You should attempt to free memory at convenient opportunities
    when the performance of your app isn't critical.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再需要位图时，请记住释放其数据。这将释放内存，允许你加载其他无法加载和存储的位图。然而，在释放位图数据内存时，你应该小心。内存管理可能会消耗宝贵的CPU周期，并阻碍应用程序的性能。你应该在应用程序性能不是关键的时候，尝试在方便的机会释放内存。
- en: See also
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Working with external SWFs, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理外部SWF文件，[第4章](ch04.html "第4章。将Flash项目移植到iOS")*'
- en: '*Accessing bitmaps with ActionScript*'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ActionScript访问位图*'
- en: '*Working with sprite sheets*'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理精灵图集*'
- en: Working with sprite sheets
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理精灵图集
- en: When working with multiple bitmap resources, you may want to consider using
    a sprite sheet. A **sprite sheet** is a single bitmap that holds a collection
    of individual images. Typically, the sheet is separated into a grid with each
    image occupying identically sized slots.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个位图资源时，你可能想要考虑使用精灵图集。**精灵图集**是一个包含多个单独图像的单个位图。通常，图集被分割成一个网格，每个图像占据相同大小的槽位。
- en: Once a sprite sheet is loaded into memory, the bitmap data for its individual
    images can be extracted and stored separately. This allows the data for each image
    to be accessed quickly by the application.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦精灵图集被加载到内存中，其单个图像的位图数据可以被提取并单独存储。这允许应用程序快速访问每个图像的数据。
- en: Let us see how this is done.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的。
- en: Getting ready
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter6\recipe8\recipe.fla`.
    The majority of the FLA's AIR for iOS settings have been applied as a starting
    point.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中打开 `chapter6\recipe8\recipe.fla`。FLA的大多数AIR for iOS设置都已应用为起点。
- en: Additionally, a bitmap named `sprite-sheet.png` has been provided within the
    same folder as the FLA. Take a look at the bitmap in an image editor such as Adobe
    Photoshop. It contains a collection of images that we will extract and store in
    memory.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在同一文件夹中提供了名为 `sprite-sheet.png` 的位图。使用Adobe Photoshop等图像编辑器查看位图。它包含我们将从中提取并存储在内存中的图像集合。
- en: How to do it...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start by bundling the bitmap with your app.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将位图捆绑到你的应用程序中。
- en: To do this, open the **AIR for iOS Settings** panel and ensure that the panel's
    **General** tab is selected. Click on the **+** symbol above the **Included files**
    list and select `sprite-sheet.png` from the FLA's root folder. Finally, click
    on **OK** to close the **AIR for iOS Settings** panel.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成此操作，请打开**AIR for iOS设置**面板，并确保已选择面板的**常规**选项卡。在**包含文件**列表上方单击**+**符号，并从FLA的根文件夹中选择`sprite-sheet.png`。最后，单击**确定**以关闭**AIR
    for iOS设置**面板。
- en: Now, let us write some ActionScript to load the sprite sheet before cutting
    it into individual bitmaps.
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些ActionScript代码来在切割成单个位图之前加载精灵图集。
- en: Create a document class and name it `Main`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类并命名为 `Main`。
- en: 'Add the following import statements:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入语句：
- en: '[PRE24]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The sprite sheet contains four images aligned in a 2x2 grid. Each image is
    192x256 pixels in size. Store this information within your class by adding the
    following constants:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精灵图集包含四个图像，它们在2x2网格中排列。每个图像的大小为192x256像素。通过在类中添加以下常量来存储这些信息：
- en: '[PRE25]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a member variable of type `Array` that will be used to store the bitmap
    data for each of the images once they have been extracted from the sprite sheet:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为 `Array` 的成员变量，用于存储从精灵图集中提取后的每个图像的位图数据：
- en: '[PRE26]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let us also add a member variable of type `Bitmap`, which will be used to verify
    that the bitmaps have been extracted by displaying one of them on screen:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加一个类型为`Bitmap`的成员变量，它将用于验证位图是否已提取，通过在屏幕上显示其中一个位图来实现：
- en: '[PRE27]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Within the constructor, use the `Loader` class to load the sprite sheet:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，使用`Loader`类来加载精灵图集：
- en: '[PRE28]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Write the handler that will be called when the sprite sheet has loaded. The
    handler itself will call two methods`—sliceSpriteSheet()` and `createMonkey()`.
    The first will extract the bitmap data from the sprite sheet, while the second
    will create and display a bitmap object that will use the bitmap data from one
    of the extracted images:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写当精灵图集加载时将被调用的处理程序。处理程序本身将调用两个方法`—sliceSpriteSheet()`和`createMonkey()`。第一个将提取精灵图集中的位图数据，而第二个将创建并显示一个使用提取图像之一位图数据的位图对象：
- en: '[PRE29]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, add the method that actually extracts the bitmap data for each of the
    sprite sheet''s images:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个方法，用于实际提取精灵图集每个图像的位图数据：
- en: '[PRE30]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, add the method that creates a bitmap that uses the bitmap data from
    the first image cut from the sprite sheet:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个创建使用从精灵图集中裁剪的第一个图像的位图数据的方法：
- en: '[PRE31]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Save your document class as `Main.as`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的文档类保存为`Main.as`。
- en: Save your FLA and test it using ADL.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的FLA保存并使用ADL进行测试。
- en: The SWF will load the sprite sheet, extract the data for all four images, then
    display the first of those images on screen.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SWF将加载精灵图集，提取所有四个图像的数据，然后在屏幕上显示这些图像中的第一个。
- en: Once satisfied, publish for iOS and deploy the app to a device for testing.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦满意，发布iOS版本并将应用部署到设备上进行测试。
- en: How it works...
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The bulk of this recipe's work is performed within the `sliceSpriteSheet()`
    method. Using a nested `for` loop, it traverses the sheet's bitmap data, copying
    the data for each of the images into their own `BitmapData` objects. Each of these
    `BitmapData` objects is added to the `bitmaps` array for use later.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这道菜谱的大部分工作是在`sliceSpriteSheet()`方法中完成的。使用嵌套的`for`循环，它遍历图集的位图数据，将每个图像的数据复制到它们自己的`BitmapData`对象中。这些`BitmapData`对象中的每一个都被添加到`bitmaps`数组中以便以后使用。
- en: Once the data has been extracted, the sprite sheet's own bitmap data is released
    from memory. The sprite sheet itself is no longer required as the bitmap data
    for each of its images is now stored individually within the `bitmaps` array and
    can be easily accessed from there.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被提取，精灵图集自己的位图数据将从内存中释放。由于每个图像的位图数据现在都存储在`bitmaps`数组中，并且可以轻松访问，因此不再需要精灵图集本身。
- en: Think of the `bitmaps` array as a library, with each index position representing
    a different image. If you are using GPU-rendering mode, then the data for each
    image will be stored as a texture in video memory providing hardware acceleration
    when rendering.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 将`bitmaps`数组想象成一个库，每个索引位置代表一个不同的图像。如果你正在使用GPU渲染模式，那么每个图像的数据将作为纹理存储在视频内存中，从而在渲染时提供硬件加速。
- en: Using any of these images is as easy as creating a `Bitmap` object and pointing
    its `bitmapData` property to one of the `BitmapData` objects stored within the
    `bitmaps` array. Alternatively, you can pass one of the `BitmapData` references
    into the `Bitmap` object's constructor. Within the `createMonkey()` method, we
    simply created a `Bitmap` object that used the first image (index position `0)`
    stored within the `bitmaps` array. Although, we could just as easily have used
    the bitmap data from one of the other three images.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些图像就像创建一个`Bitmap`对象并将它的`bitmapData`属性指向`bitmaps`数组中存储的`BitmapData`对象之一一样简单。或者，你也可以将`BitmapData`引用之一传递给`Bitmap`对象的构造函数。在`createMonkey()`方法中，我们只是创建了一个使用`bitmaps`数组中存储的第一个图像（索引位置`0`）的`Bitmap`对象。尽管，我们同样可以使用其他三个图像中的任何一个的位图数据。
- en: As with the sprite sheet, you can call `dispose()` on any of the `BitmapData`
    objects stored within the `bitmaps` array in order to release them from memory.
    It is important that you do this when any of the `BitmapData` objects are no longer
    required.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 与精灵图集一样，你可以对存储在`bitmaps`数组中的任何`BitmapData`对象调用`dispose()`方法，以将其从内存中释放。当任何`BitmapData`对象不再需要时，执行此操作非常重要。
- en: Sprite sheets have many advantages. When working with multiple bitmap images
    that are loaded at runtime, a sprite sheet requires only a single load request.
    This is significantly faster than loading individual bitmaps from the file system.
    Also, in addition to using identically sized slots for each bitmap, it is possible
    to tightly pack arbitrary-sized bitmaps into a sprite sheet. Doing so can lead
    to savings when holding the sprite sheet in memory compared to storing each individual
    bitmap.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集有许多优点。当处理在运行时加载的多个位图图像时，精灵图集只需要一个加载请求。这比从文件系统中加载单个位图要快得多。此外，除了为每个位图使用相同大小的槽位外，还可以将任意大小的位图紧密打包到精灵图集中。这样做可以在内存中保存精灵图集时节省空间，与存储每个单独的位图相比。
- en: The use of sprite sheets is the de facto standard for working with bitmaps in
    many development environments and frameworks. For example, native iOS and Android
    frameworks such as Cocos2D, Sparrow, and Corona take advantage of sprite sheets.
    Both the Starling and ND2D ActionScript 3.0 frameworks, which are built on top
    of Stage 3D, also rely on sprite sheets when using their hardware-accelerated
    2D graphics APIs.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多开发环境和框架中，精灵图集的使用是处理位图的既定标准。例如，原生iOS和Android框架如Cocos2D、Sparrow和Corona都利用了精灵图集。建立在Stage
    3D之上的Starling和ND2D ActionScript 3.0框架，在使用其硬件加速的2D图形API时，也依赖于精灵图集。
- en: Finally, don't confuse sprite sheets with Flash's `Sprite` class. Any of Flash's
    display objects that support bitmaps can be used to render content from within
    a sprite sheet, not just the `Sprite` class.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要将精灵图集与Flash的`Sprite`类混淆。Flash中支持位图的任何显示对象都可以用来渲染来自精灵图集的内容，而不仅仅是`Sprite`类。
- en: You can obtain more detail regarding the classes used in this recipe from Adobe
    Community Help. Specifically, take a look at `flash.display.Loader, flash.display.Bitmap`,
    and `flash.display.BitmapData`. Spend some time looking at `BitmapData.copyPixels()`
    which is used to copy data from the sprite sheet into each individual `BitmapData`
    object.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Adobe社区帮助中获取有关此配方中使用的类的更多详细信息。具体来说，请查看`flash.display.Loader, flash.display.Bitmap`和`flash.display.BitmapData`。花些时间看看`BitmapData.copyPixels()`，它用于将精灵图集中的数据复制到每个单独的`BitmapData`对象中。
- en: There's more...
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Following are a few more things to consider when working with sprite sheets.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用精灵图集时，以下是一些需要考虑的额外事项。
- en: Creating sprite sheets
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建精灵图集
- en: There are many great tools for creating sprite sheets. Take a look at TexturePacker,
    which is freely available for both Mac OS X and Microsoft Windows at [www.texturepacker.com](http://www.texturepacker.com).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的工具可以创建精灵图集。看看TexturePacker，它可以在Mac OS X和Microsoft Windows上免费使用，网址为[www.texturepacker.com](http://www.texturepacker.com)。
- en: Comparing performance and memory consumption
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较性能和内存消耗
- en: Extracting and storing the bitmap data for each individual image provides the
    fastest access to that data when it is eventually required by your app. However,
    cutting the sprite sheet into individual `BitmapData` objects may come at the
    cost of memory, especially when rendering directly on the GPU.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 提取和存储每个单独图像的位图数据，可以在最终需要时提供最快的访问速度。然而，将精灵图集切割成单独的`BitmapData`对象可能会以内存为代价，尤其是在直接在GPU上渲染时。
- en: The GPU allocates memory using powers of 2 for each of a bitmap's dimensions.
    When creating a sprite sheet, you can use this knowledge to your advantage, packing
    and arranging images into the sheet until its dimensions are exact powers of 2\.
    However, this may not be the case for the individual images contained within the
    sheet, and can lead to significant memory overheads once the bitmap data for all
    the images has been extracted.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: GPU为每个位图的每个维度使用2的幂来分配内存。在创建精灵图集时，您可以使用这一知识来提高效率，将图像打包并排列到图集中，直到其尺寸是2的精确幂。然而，对于图集中的单个图像来说，情况可能并非如此，一旦所有图像的位图数据都被提取出来，可能会导致显著的内存开销。
- en: Consider carefully your artwork when creating bitmap images. If performance
    is of the utmost importance, then you may need to accept these memory overheads.
    Otherwise consider an alternative approach—perhaps keeping the sprite sheet in
    memory and extracting only the data that you need at a particular moment in time.
    This of course will be slower than extracting all the image data up-front but
    is a viable option, which is often used by professional developers.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建位图图像时，仔细考虑你的艺术作品。如果性能至关重要，那么你可能需要接受这些内存开销。否则，考虑一种替代方法——也许是将精灵表保持在内存中，并在特定时刻提取所需的数据。当然，这会比预先提取所有图像数据慢，但这是一个可行的选项，通常被专业开发者所采用。
- en: See also
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with external SWFs, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理外部 SWF，[第 4 章](ch04.html "第 4 章。将 Flash 项目移植到 iOS")*'
- en: '*Accessing bitmaps with ActionScript*'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 ActionScript 访问位图*'
- en: '*Loading bitmaps at runtime*'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在运行时加载位图*'
- en: '*Performing bitmap animation with ActionScript*'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 ActionScript 进行位图动画*'
- en: Performing bitmap animation with ActionScript
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ActionScript 进行位图动画
- en: It might be the obvious choice for most situations, but the timeline isn't the
    only way to perform frame-by-frame animation. With a collection of `BitmapData`
    objects stored in memory, it is perfectly possible to apply animations to `Bitmap`
    objects using ActionScript.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况来说，这可能是显而易见的选择，但时间轴并不是执行帧帧动画的唯一方法。在内存中存储一系列 `BitmapData` 对象的情况下，使用 ActionScript
    应用动画到 `Bitmap` 对象是完全可能的。
- en: We will see how to do that in this recipe.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本食谱中看到如何做到这一点。
- en: Getting ready
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can continue to work with the code you wrote during the *Working with sprite
    sheets* recipe. Alternatively, open `chapter6\recipe9\recipe.fla` from the book's
    accompanying code bundle and work from there. You will also find the FLA's document
    class and a sprite sheet in the same folder. The sprite sheet has already been
    added to the **Included files** list in the FLA's **AIR for iOS Settings** panel.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用你在 *使用精灵表* 食谱中编写的代码。或者，从书籍的配套代码包中打开 `chapter6\recipe9\recipe.fla` 并从那里开始工作。你还可以在同一个文件夹中找到
    FLA 的文档类和精灵表。精灵表已经添加到 FLA 的 **包含文件** 列表中，在 **AIR for iOS 设置** 面板中。
- en: How to do it...
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will perform the animation by cycling through each of the bitmaps cut from
    the sprite sheet.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过循环遍历从精灵表中切割出的每个位图来执行动画。
- en: Open the FLA's document class.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 FLA 的文档类。
- en: 'Add a constant that stores the number of frames within the animation:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个存储动画中帧数的常量：
- en: '[PRE32]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will also need a member variable that keeps track of the current frame being
    shown:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个成员变量来跟踪当前显示的帧：
- en: '[PRE33]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Within the `bitmapLoaded()` method, listen for `Event.ENTER_FRAME`. Its event
    handler will act as the app''s main loop:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bitmapLoaded()` 方法中，监听 `Event.ENTER_FRAME` 事件。其事件处理程序将充当应用程序的主循环：
- en: '[PRE34]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let us add the method for the main loop. On each call, it will point the
    `monkey` bitmap to a different `BitmapData` object, essentially causing the bitmap
    to animate:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加主循环的方法。在每次调用时，它将 `monkey` 位图指向不同的 `BitmapData` 对象，从而本质上使位图动画化：
- en: '[PRE35]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save your document class and your FLA.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的文档类和 FLA 文件。
- en: Test the FLA in ADL. You should now see the `monkey` bitmap animating by cycling
    through a series of images.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ADL 中测试 FLA。你现在应该看到 `monkey` 位图通过一系列图像进行动画循环。
- en: Publish your app and test it on a device.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布你的应用程序并在设备上测试它。
- en: How it works...
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once you have a collection of `BitmapData` objects, it doesn't take too much
    effort to perform animation using them.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一系列 `BitmapData` 对象，使用它们进行动画并不需要太多的努力。
- en: 'The `frame` member variable was used as an index position into the `bitmaps`
    array in order to retrieve the next `BitmapData` object for the animation. You
    can see this in the following code snippet, where the `bitmapData` property is
    updated to point to a new `BitmapData` object:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`frame` 成员变量被用作 `bitmaps` 数组的索引位置，以检索用于动画的下一个 `BitmapData` 对象。你可以在以下代码片段中看到这一点，其中
    `bitmapData` 属性被更新为指向一个新的 `BitmapData` 对象：'
- en: '[PRE36]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Some additional logic was also added to ensure that the animation looped back
    round to the first frame again. This was taken care of by comparing the value
    of `frame` against the `MAX_FRAMES` constant and setting `frame` back to `0` when
    both values matched.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 还添加了一些额外的逻辑来确保动画循环回到第一帧。这是通过比较 `frame` 的值与 `MAX_FRAMES` 常量的值来实现的，当这两个值匹配时，将
    `frame` 设置回 `0`。
- en: It may seem like a considerable amount of work for a task that can be performed
    relatively quickly using a timeline animation. However, even the simplest timeline
    animations struggle for performance on older iOS devices. This is especially true
    when using GPU Blend, where each frame needs to be copied from the CPU to the
    GPU whenever the playhead's position changes.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个相对快速完成的任务来说，这似乎是一项相当多的工作。然而，即使是简单的基于时间轴的动画，在较旧的iOS设备上也会在性能上遇到困难。这尤其在使用GPU混合时更为明显，每当播放头的位置改变时，每一帧都需要从CPU复制到GPU。
- en: Programmatic animation using ActionScript, however, can be incredibly fast,
    with GPU Blend benefitting especially from it. Remember, `BitmapData` objects
    are stored directly in video memory as textures and, therefore, don't suffer the
    same rendering bottlenecks experienced by timeline animations.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ActionScript进行程序化动画可以非常快，特别是GPU混合从中受益。记住，`BitmapData`对象直接存储在视频内存中作为纹理，因此不会像时间轴动画那样遇到相同的渲染瓶颈。
- en: If you are using Flash Professional CS5, then this may be the only real option
    if you want to maximize the performance of your animations. Utilizing GPU-Blend
    mode and performing bitmap animations using ActionScript can increase performance
    anywhere between five and ten times that of a timeline-based approach. For a comparison,
    publish `recipe-bitmaps.fla` from the *Comparing vector and bitmap graphics* recipe.
    The performance difference between it and this recipe's example FLA should be
    considerable when running on a device.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Flash Professional CS5，那么如果您想最大限度地提高动画的性能，这可能确实是唯一的选择。利用GPU混合模式并使用ActionScript执行位图动画可以将性能提高五到十倍。为了比较，从*比较矢量图形和位图图形*配方发布`recipe-bitmaps.fla`。当在设备上运行时，它与这个配方示例FLA之间的性能差异应该是相当大的。
- en: There's more...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Following are a few final points regarding sprite sheets and animation.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些关于精灵表和动画的最终要点。
- en: Animation sequences
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画序列
- en: You may find that the existing animation runs too quickly and be tempted to
    reduce the FLA's frame rate to correct this. A better approach is to hold each
    bitmap for a few frames before moving to the next. This provides more control
    over your animations without reducing the SWF's frame rate.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现现有的动画运行得太快，并倾向于降低FLA的帧率来纠正这个问题。更好的方法是，在移动到下一个之前，让每个位图保持几帧。这提供了对动画的更多控制，而不会降低SWF的帧率。
- en: 'We can achieve this by creating an array that holds a sequence of frame indexes
    for your animation. Each element within the array represents one frame of animation.
    Therefore, we can slow the animation by storing duplicate copies of each frame
    index. Take a look at the following sequence:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个包含动画帧索引序列的数组来实现这一点。数组中的每个元素代表一个动画帧。因此，我们可以通过存储每个帧索引的重复副本来减慢动画。看看以下序列：
- en: '`[ 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 ]`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 ]`'
- en: Each integer represents a frame index, with 0 being the first bitmap of the
    animation and 3 being the last. Therefore, this sequence holds the animation on
    each of the bitmaps for four screen redraws before moving to the next. Let us
    implement this in your code.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 每个整数代表一个帧索引，其中0是动画的第一个位图，3是最后一个。因此，这个序列在移动到下一个之前，在每一个位图上保持动画，进行四次屏幕重绘。让我们在您的代码中实现这一点。
- en: 'First, add a constant that holds the animation sequence:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个包含动画序列的常量：
- en: '[PRE37]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, replace the `update()` method with this new version, which cycles
    through the frame indexes listed in the sequence:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用这个新版本替换`update()`方法，它循环遍历序列中列出的帧索引：
- en: '[PRE38]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save your document class and test the new version of your FLA.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的文档类并测试您FLA的新版本。
- en: While this example uses a frame-based approach to animation, there is really
    nothing stopping you from writing your own ActionScript animation library that
    can be time-based.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子使用基于帧的方法进行动画，但实际上没有任何阻止您编写自己的基于时间的ActionScript动画库。
- en: Loading resources at runtime
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时加载资源
- en: Another reason for employing bitmap-based animation with ActionScript is for
    runtime loading of resources. If you can't fit all your resources into memory
    at once or simply want to reduce the initial load time of your app, then you should
    consider this above timeline-based animations.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于位图动画的ActionScript的另一个原因是运行时加载资源。如果您无法一次性将所有资源放入内存，或者只想减少应用程序的初始加载时间，那么您应该考虑这一点，而不是基于时间轴的动画。
- en: Remember, it is not currently possible to instantiate any library symbols within
    external SWFs that you have loaded into your AIR for iOS app. Therefore, as an
    alternative, you may want to load sprite sheets at runtime, extract the images
    from them, and then use ActionScript to perform the animations required by your
    app's display objects.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目前无法在您加载到iOS AIR应用程序中的外部SWF中实例化任何库符号。因此，作为替代方案，您可能希望在运行时加载精灵表单，从中提取图像，然后使用ActionScript执行应用程序显示对象所需的动画。
- en: Stage 3D
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Stage 3D
- en: Perhaps the most compelling reason for using sprite sheets is Adobe's Stage
    3D API. Stage 3D (previously codenamed Molehill) provides advanced 2D and 3D hardware
    acceleration on GPU hardware. Its API is intentionally low-level in order to maximize
    performance but you can use various ActionScript 3.0 frameworks built on top of
    Stage 3D that are still capable of results far exceeding Flash's traditional display
    list.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精灵表单的最有说服力的理由可能是Adobe的Stage 3D API。Stage 3D（之前代号为Molehill）在GPU硬件上提供了高级的2D和3D硬件加速。它的API故意设计为低级，以最大化性能，但您可以使用建立在Stage
    3D之上的各种ActionScript 3.0框架，这些框架仍然能够产生远超Flash传统显示列表的效果。
- en: Two such APIs aimed at 2D graphics are Starling and ND2D, which make heavy use
    of sprite sheets. Flash's traditional display list cannot be used with these frameworks.
    Instead, everything must be performed programmatically using ActionScript and
    the graphics elements provided by each.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 针对2D图形的两个这样的API是Starling和ND2D，它们大量使用精灵表单。Flash的传统显示列表不能与这些框架一起使用。相反，所有操作都必须通过ActionScript和每个框架提供的图形元素进行编程实现。
- en: At the time of writing, Stage 3D isn't yet available for mobile. However, Adobe
    is actively working to bring it to AIR for iOS. If you would like to take advantage
    of Stage 3D when it becomes available, then you should consider using sprite sheets
    in your current projects. This should make the process of porting them to Stage
    3D relatively straightforward.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Stage 3D尚未对移动设备可用。然而，Adobe正在积极工作，将其引入到iOS的AIR中。如果您想在Stage 3D可用时利用它，那么您应该考虑在当前项目中使用精灵表单。这应该会使将它们移植到Stage
    3D的过程相对简单。
- en: You can find out more about Stage 3D from Adobe Developer Connection at [www.adobe.com/devnet/flashplayer/stage3d.html](http://www.adobe.com/devnet/flashplayer/stage3d.html).
    Links to both Starling and ND2D can be found there too.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Adobe开发者连接处了解更多关于3D舞台的信息：[www.adobe.com/devnet/flashplayer/stage3d.html](http://www.adobe.com/devnet/flashplayer/stage3d.html)。在那里也可以找到Starling和ND2D的链接。
- en: See also
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using an update loop, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用更新循环，[第3章](ch03.html "第3章。编写您的第一个应用程序")*'
- en: '*Working with external SWFs, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理外部SWF，[第4章](ch04.html "第4章。将Flash项目移植到iOS")*'
- en: '*Working with sprite sheets*'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理精灵表单*'
