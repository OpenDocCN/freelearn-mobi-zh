- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Enhancing Code Quality
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高代码质量
- en: As we develop our Android apps, we must ensure that the code we write complies
    with the set rules and follows the best practices. This not only helps us to write
    good code but also makes it easier to maintain and easily onboard others to the
    code base.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发 Android 应用程序，我们必须确保我们编写的代码符合既定规则并遵循最佳实践。这不仅有助于我们编写良好的代码，还使维护更容易，并便于他人快速熟悉代码库。
- en: In this chapter, we will learn about the Kotlin style and the best practices
    for writing Kotlin code. We will also learn how to use plugins such as Ktlint
    and Detekt to format, lint, and detect the code smells early.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Kotlin 的风格和编写 Kotlin 代码的最佳实践。我们还将学习如何使用 Ktlint 和 Detekt 等插件来格式化、检查和早期检测代码问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Mastering Kotlin style and best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Kotlin 风格和最佳实践
- en: Using Ktlint for static analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ktlint 进行静态分析
- en: Detecting code smells with Detekt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Detekt 检测代码问题
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要下载 Android Studio Hedgehog 或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章中的说明。您可以在 [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereleven)
    找到本章的代码。
- en: Mastering Kotlin style and best practices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握 Kotlin 风格和最佳实践
- en: As we learned in [*Chapter 1*](B19779_01.xhtml#_idTextAnchor015), Kotlin is
    a very concise and static language. As such, it is easier for us as developers
    to not follow some of the recommended practices. This leads to a lot of code smells
    and technical debt. A **code smell** is a pattern or practice that might indicate
    a deeper problem within the code. It indicates that the code might lead to potential
    problems or hinder maintainability. On the other hand, **technical debt** refers
    to the cost or consequences of choosing quick and suboptimal solutions in development
    to meet immediate needs rather than developing robust and maintainable solutions.
    We always have to come back later to such solutions to refactor them to be more
    scalable and maintainable. Let us start by learning about some of the best practices
    and how to avoid them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第一章*](B19779_01.xhtml#_idTextAnchor015)中学到的，Kotlin 是一种非常简洁和静态的语言。因此，作为开发者，我们更容易不遵循一些推荐的最佳实践。这会导致许多代码问题和技术债务。**代码问题**是一种模式或实践，可能表明代码中存在更深层次的问题。它表明代码可能引起潜在问题或阻碍可维护性。另一方面，**技术债务**指的是为了满足即时需求而选择快速和次优解决方案的成本或后果，而不是开发健壮和可维护的解决方案。我们总是需要回来对这些解决方案进行重构，使其更具可扩展性和可维护性。让我们从学习一些最佳实践和如何避免它们开始。
- en: Coding conventions
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码约定
- en: 'Kotlin has a wide variety of coding conventions that cover everything from
    naming conventions to formatting. Following these conventions makes it easier
    to read our code and makes it maintainable. Examples of these are the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 拥有一系列广泛的编码约定，涵盖了从命名约定到格式化的各个方面。遵循这些约定可以使我们的代码更容易阅读，并使其易于维护。以下是一些例子：
- en: Variable names should be in **camelCase**
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名应该使用**驼峰式命名法**
- en: Class names should be in **PascalCase**
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名应该使用**帕斯卡命名法**
- en: Constants should be in **UPPERCASE**
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量应该使用**大写**
- en: Functions should be in **camelCase**
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该使用**驼峰式命名法**
- en: Functions with multiple words should be separated by **underscores**
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个单词的函数应该用**下划线**分隔
- en: Functions with a single expression should be **inlined**
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行表达式的函数应该**内联**
- en: Kotlin offers a lot of coding conventions. You can find them at [https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了许多编码约定。您可以在 [https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html)
    找到它们。
- en: Null safety
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空安全
- en: 'As discussed extensively in [*Chapter 1*](B19779_01.xhtml#_idTextAnchor015),
    Kotlin has a very strong `null`. When working with nullable types, it is recommended
    that we use the safe call operator (`?.`) and the Elvis operator (`?:`) to avoid
    null pointer exceptions. We should also use the `let` function to perform operations
    on nullable types. We should also use the safe cast operator (`as?`) to avoid
    class cast exceptions. An example is shown in the following snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第一章*](B19779_01.xhtml#_idTextAnchor015)中广泛讨论的那样，Kotlin 具有非常强大的 `null` 类型。当处理可空类型时，建议我们使用安全调用操作符
    (`?.`) 和 Elvis 操作符 (`?:`) 来避免空指针异常。我们还应该使用 `let` 函数来对可空类型执行操作。我们还应该使用安全转换操作符 (`as?`)
    来避免类转换异常。以下是一个示例片段：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we declared a `name` variable of the `String` type
    and assigned it `null`. Then, we used the `let` function to check whether the
    variable is `null` or not. If the variable is not `null`, then the `println(it)`
    function will print the value of the variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个 `name` 变量，其类型为 `String` 并赋值为 `null`。然后，我们使用 `let` 函数检查变量是否为
    `null`。如果变量不是 `null`，则 `println(it)` 函数将打印变量的值。
- en: Data classes
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类
- en: 'Kotlin makes it easy for us to create `equals`, `hashCode`, `toString`, and
    `copy` functions. We should use data classes when we need to hold data:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 使我们轻松创建 `equals`、`hashCode`、`toString` 和 `copy` 函数。当我们需要存储数据时应该使用数据类：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, we created a `Person` data class with two properties:
    `name` (which is a `String` type) and `age` (which is an `Int` type).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个具有两个属性的数据类 `Person`：`name`（类型为 `String`）和 `age`（类型为 `Int`）。
- en: Extensions functions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展函数
- en: 'Kotlin provides **extension functions**, which allow us to add new functions
    to new classes without having to inherit from them. This will help us avoid creating
    utility classes. While extension functions are powerful, overuse or inappropriate
    use can lead to code that is hard to read and maintain. An example is shown in
    the following code block:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了**扩展函数**，这允许我们在不继承它们的情况下向新类添加新函数。这将帮助我们避免创建工具类。虽然扩展函数功能强大，但过度使用或不恰当的使用可能会导致难以阅读和维护的代码。以下是一个代码块示例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we created an extension function on the `String`
    class. The function removes the first and last character of the string and returns
    the remaining string. Additionally, we used the `when` expression to check whether
    the length of the string is less than or equal to `1`. If the length is less than
    or equal to `1`, then the function returns an empty string. Otherwise, it returns
    the substring of the string from index 1 to the length of the string – `1`. We
    used the extension function in the `main` function to remove the first and last
    character of the `"Hello Everyone"` string. The result is then printed to the
    console as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为 `String` 类创建了一个扩展函数。该函数移除了字符串的第一个和最后一个字符，并返回剩余的字符串。此外，我们使用了 `when`
    表达式来检查字符串的长度是否小于或等于 `1`。如果长度小于或等于 `1`，则函数返回空字符串。否则，它返回从索引 `1` 到字符串长度减去 `1` 的子字符串。我们在
    `main` 函数中使用扩展函数来移除 `"Hello Everyone"` 字符串的第一个和最后一个字符。结果随后按如下方式打印到控制台：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Type inference
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Kotlin has a very strong type system. As such, we can omit specifying the type
    of a variable and let the compiler infer the type. This will help us avoid a lot
    of boilerplate code. Here is an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 具有非常强大的类型系统。因此，我们可以省略指定变量的类型，让编译器推断类型。这将帮助我们避免大量的样板代码。以下是一个示例：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Collections
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'Kotlin has a rich `List`, `Set`, `Map`, `Array`, and `Sequence` as collection
    types available in Kotlin. Collections can either be `mutable` or `immutable`.
    A `mutable` collection can be modified after creation, while an `immutable` collection
    cannot be modified after creation. An example of a `mutable` list is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了丰富的 `List`、`Set`、`Map`、`Array` 和 `Sequence` 作为 Kotlin 中的集合类型。集合可以是
    `mutable` 或 `immutable` 的。一个 `mutable` 集合在创建后可以被修改，而一个 `immutable` 集合在创建后不能被修改。以下是一个
    `mutable` 列表的示例：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding example, we created a `mutable` list of strings. We used the
    `mutableListOf` function to create the list. We then added a new string to the
    list using the `add` function. An example of an `immutable` list is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个字符串的 `mutable` 列表。我们使用 `mutableListOf` 函数创建列表。然后，我们使用 `add` 函数向列表中添加一个新的字符串。以下是一个
    `immutable` 列表的示例：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we created an `immutable` list of strings. We used
    the `listOf` function to create the list. We cannot add or remove items from the
    list after creation. We can only read items from the list. Kotlin collections
    also have a wide variety of functions that can be used to perform operations on
    collections. We should use these functions instead of writing our own functions.
    This helps us make our code concise and readable. Let us see the following example
    of creating a list and filtering odd and even numbers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个不可变字符串列表。我们使用`listOf`函数来创建列表。一旦创建，我们无法向列表中添加或删除项目。我们只能从列表中读取项目。Kotlin集合也提供了一系列可以用于对集合执行操作的函数。我们应该使用这些函数而不是编写我们自己的函数。这有助于我们使代码更加简洁和易读。让我们看看以下创建列表并过滤奇偶数的例子：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we created a list of numbers. We then used the `filter`
    function to filter even and odd numbers. The `filter` function takes a lambda
    as an argument. The lambda is used to filter the numbers. The `filter` function
    returns a new list with the filtered numbers. We used the `it` keyword to refer
    to the current item in the list. We then used the `%` operator to check whether
    the number is even or odd. If the number is even, then the `filter` function returns
    `true` and the number is added to the `evenNumbers` variable. For odd numbers,
    the `filter` function returns `false` and the number is added to the `oddNumbers`
    variable. Kotlin collections also have functions such as `map`, `reduce`, `fold`,
    `flatMap`, and so on. We should use these functions instead of writing our own
    functions. This helps us make our code concise and readable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个数字列表。然后我们使用`filter`函数来过滤偶数和奇数。`filter`函数接受一个lambda作为参数。lambda用于过滤数字。`filter`函数返回一个包含过滤数字的新列表。我们使用`it`关键字来引用列表中的当前项目。然后我们使用`%`运算符来检查数字是偶数还是奇数。如果数字是偶数，则`filter`函数返回`true`并将数字添加到`evenNumbers`变量中。对于奇数，`filter`函数返回`false`并将数字添加到`oddNumbers`变量中。Kotlin集合还提供了`map`、`reduce`、`fold`、`flatMap`等函数。我们应该使用这些函数而不是编写我们自己的函数。这有助于我们使代码更加简洁和易读。
- en: Sealed classes and interfaces
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封类和接口
- en: 'Kotlin provides **sealed classes**, which are used to represent restricted
    class and interface hierarchies. This improves code readability and ensures that
    we know all the possible subclasses of a class. Here’s an example of a sealed
    class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin提供了**密封类**，用于表示受限的类和接口层次结构。这提高了代码的可读性并确保我们知道一个类的所有可能的子类。以下是一个密封类的例子：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we created a sealed class called `Shape`. We then
    created three classes (`Circle`, `Square`, and `Rectangle`), which are subclasses
    of the `Shape` class. The `Shape` class can only be extended in the same file
    where it is declared. We cannot extend the `Shape` class in another file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个名为`Shape`的密封类。然后我们创建了三个类（`Circle`、`Square`和`Rectangle`），它们是`Shape`类的子类。`Shape`类只能在其声明的同一文件中扩展。我们无法在另一个文件中扩展`Shape`类。
- en: Formatting
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化
- en: We use four spaces for indentation in Kotlin. However, note that this is a convention
    and not a strict rule. We should always ensure that our code is properly formatted
    as per the conventions agreed upon by the team or company
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们使用四个空格进行缩进。然而，请注意，这是一个约定而不是严格规则。我们应该始终确保我们的代码按照团队或公司商定的约定正确格式化。
- en: Functional programming
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'We should take advantage of Kotlin **functional programming** features such
    as **lambdas**, **higher-order functions**, and **inline functions**. This will
    help us make our code more concise and readable. An example is shown in the following
    code block:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该利用Kotlin的**函数式编程**特性，如**lambda**、**高阶函数**和**内联函数**。这将帮助我们使代码更加简洁和易读。以下是一个代码块的例子：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Coroutines
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程
- en: 'Kotlin provides **coroutines**, which are used to perform asynchronous operations.
    They are very lightweight and easy to use and help us avoid callback hell. We
    should use coroutines when we need to perform asynchronous operations. An example
    of a coroutine in Kotlin is as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin提供了**协程**，用于执行异步操作。它们非常轻量级且易于使用，帮助我们避免回调地狱。当我们需要执行异步操作时，应该使用协程。以下是一个Kotlin协程的例子：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we used `viewModelScope` to launch a coroutine. This
    is to ensure that the coroutine is canceled when the view model is destroyed.
    We used the `launch` coroutine builder to create a new coroutine. Inside the `launch`
    lambda, we performed our network call, which is supposed to happen in the background.
    We used the `async` coroutine builder, which allows us to await the result of
    the network call. The `async` coroutine builder returns a `Deferred` object. Lastly,
    we updated the UI with the result of the network call.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `viewModelScope` 来启动协程。这是为了确保当视图模型被销毁时，协程会被取消。我们使用了 `launch` 协程构建器来创建一个新的协程。在
    `launch` 拉姆达函数内部，我们执行了网络调用，这应该在后台发生。我们使用了 `async` 协程构建器，它允许我们等待网络调用的结果。`async`
    协程构建器返回一个 `Deferred` 对象。最后，我们使用网络调用的结果更新了 UI。
- en: The when statements
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: when 语句
- en: 'Kotlin provides `when` statements, which are used to replace `switch` statements.
    We should use `when` statements when we need to perform conditional operations.
    If we have blocks with more than one `if` `else` statement, we should consider
    using `when` statements. An example is shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了 `when` 语句，用于替换 `switch` 语句。当我们需要执行条件操作时，我们应该使用 `when` 语句。如果我们有包含多个
    `if` `else` 语句的块，我们应该考虑使用 `when` 语句。以下代码展示了示例：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Classes and functions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和函数
- en: Kotlin allows us to declare multiple classes in a single file. We should use
    this feature to avoid creating a lot of files, especially for classes that are
    closely related. We should, however, be keen not to have bloated files with a
    lot of classes, so we should use this feature with caution.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 允许我们在单个文件中声明多个类。我们应该利用这个特性来避免创建大量文件，尤其是对于紧密相关的类。然而，我们应谨慎不要让文件变得臃肿，包含许多类，因此我们应该谨慎使用这个特性。
- en: We have to ensure that we define only one **primary constructor** per class.
    Instead of overloading the constructor with a second one, we can always consider
    using default values for the constructor parameters.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须确保每个类只定义一个 **主构造函数**。而不是通过第二个构造函数来重载构造函数，我们总是可以考虑为构造函数参数使用默认值。
- en: We can use **companion objects** to create static members. Both Kotlin’s companion
    objects and Java’s **static members** facilitate the creation of class-level members
    that can be accessed without creating an instance of the class. However, Kotlin’s
    companion objects provide additional flexibility by allowing access to non-static
    members and offer a more expressive syntax.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 **伴随对象**来创建静态成员。Kotlin 的伴随对象和 Java 的 **静态成员**都便于创建类级别的成员，这些成员可以在不创建类实例的情况下访问。然而，Kotlin
    的伴随对象提供了额外的灵活性，允许访问非静态成员，并提供了一种更表达性的语法。
- en: We should always avoid returning **null** from functions. Instead, we should
    use nullable types.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该始终避免从函数中返回 **null**。相反，我们应该使用可空类型。
- en: We can always use **scope functions** to perform operations on objects. This
    will help us avoid creating a lot of temporary variables.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们总是可以使用 **作用域函数**来对对象执行操作。这将帮助我们避免创建大量临时变量。
- en: This is just a small list of best practices. As the code base grows, it’s hard
    at times to keep track of all the best practices. This is where static code analysis
    tools come in handy. They help us identify code smells and technical debt. They
    also help us identify bugs and security vulnerabilities. In the next section,
    we will learn about some of the static code analysis tools that we can use to
    improve the quality of our code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个最佳实践的小列表。随着代码库的增长，有时很难跟踪所有最佳实践。这就是静态代码分析工具派上用场的地方。它们帮助我们识别代码异味和技术债务。它们还帮助我们识别错误和安全漏洞。在下一节中，我们将了解一些我们可以使用的静态代码分析工具，以改善我们代码的质量。
- en: Using Ktlint for static analysis
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ktlint 进行静态分析
- en: According to the official documentation, ktlint is “*an anti-bikeshedding Kotlin
    linter with a built-in formatter*.” It helps us do `gradle` tasks that allow us
    to run `ktlint` on our project. We are also able to do auto-formatting.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档，ktlint 是“*一个内置格式化功能的反自行车棚 Kotlin 检查器*。”它帮助我们执行 `gradle` 任务，允许我们在项目中运行
    `ktlint`。我们还能进行自动格式化。
- en: 'To set up Ktlint in our project, we need to add the Ktlint plugin to our project’s
    `build.gradle.kts` file in the plugins block, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中设置 Ktlint，我们需要在 `build.gradle.kts` 文件的插件块中添加 Ktlint 插件，如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Tap the `build.gradle.kts` file below the plugins block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点击插件块下方的 `build.gradle.kts` 文件：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will apply the plugin to all the project modules. Tap the `ktlint` block.
    In our case, we are setting the `verbose` and `android` properties to `true`.
    We are also excluding the `generated` folder from the analysis.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将插件应用于所有项目模块。点击 `ktlint` 块。在我们的例子中，我们将 `verbose` 和 `android` 属性设置为 `true`。我们还将
    `generated` 文件夹排除在分析之外。
- en: 'With that, we are ready to use Ktlint. First, though, let’s disable some formatting
    options. To do this, we need to create an `.editorconfig` file in the root of
    our project. In the file, we add the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好使用 Ktlint 了。不过，首先让我们禁用一些格式化选项。为此，我们需要在我们的项目根目录中创建一个 `.editorconfig`
    文件。在文件中，我们添加以下代码：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This disables some formatting options, the key one being `insert_final_newline`
    at the end of each file. This is especially useful for existing projects as it
    prevents us from having to reformat the whole project. If you need to customize
    Ktlint behavior, this is the file you use to enable or disable some options.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将禁用一些格式化选项，其中关键的是在每个文件末尾的 `insert_final_newline`。这对于现有项目特别有用，因为它可以防止我们不得不重新格式化整个项目。如果您需要自定义
    Ktlint 的行为，请使用此文件来启用或禁用一些选项。
- en: 'Let us now run the `ktlintCheck` task. To do this, let us open the **Terminal**
    tab in our IDE and run the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在运行 `ktlintCheck` 任务。为此，让我们在我们的 IDE 中打开 **终端** 选项卡并运行以下命令：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After the task completes, we will see the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成后，我们将看到以下输出：
- en: '![Figure 11.1 – Ktlint check failure](img/B19779_11_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Ktlint 检查失败](img/B19779_11_01.jpg)'
- en: Figure 11.1 – Ktlint check failure
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Ktlint 检查失败
- en: '![Figure 11.2 – Ktlint check failure continued](img/B19779_11_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – Ktlint 检查失败继续](img/B19779_11_02.jpg)'
- en: Figure 11.2 – Ktlint check failure continued
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Ktlint 检查失败继续
- en: 'From the preceding figures, we can see that the task was completed with failures,
    which means our project is not correctly formatted. The output also shows the
    specific formatting error and the file. We can see indentation, formatting, and
    new lines issues. We can opt to fix the issues by ourselves but, first, we should
    always check whether the Ktlint formatter can fix the issues for us. To do this,
    we can run the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从前图中，我们可以看到任务以失败完成，这意味着我们的项目格式不正确。输出还显示了具体的格式化错误和文件。我们可以选择自行修复问题，但首先，我们应始终检查
    Ktlint 格式化器是否能够为我们修复问题。为此，我们可以运行以下命令：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will run the `ktlintFormat` task. After the task is completed, we will
    see the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 `ktlintFormat` 任务。任务完成后，我们将看到以下输出：
- en: '![Figure 11.3 – ktlintFormat successful](img/B19779_11_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – ktlintFormat 成功](img/B19779_11_03.jpg)'
- en: Figure 11.3 – ktlintFormat successful
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – ktlintFormat 成功
- en: 'As seen in the preceding figure, the task was completed successfully. This
    means the Ktlint formatter was able to fix the issues for us. If the Ktlint formatter
    is not able to fix the issues, it normally highlights the issues that the plugin
    is not able to fix and shows the file and line number. We can then fix the issues
    manually. For now, we don’t have such issues. We can now run the `ktlintCheck`
    task again to confirm that the issues have been fixed. After the task completes,
    we will see the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，任务已成功完成。这意味着 Ktlint 格式化器能够为我们修复问题。如果 Ktlint 格式化器无法修复问题，它通常会突出显示插件无法修复的问题，并显示文件和行号。然后我们可以手动修复这些问题。目前，我们没有这样的问题。现在我们可以再次运行
    `ktlintCheck` 任务以确认问题已修复。任务完成后，我们将看到以下输出：
- en: '![Figure 11.4 – ktlintFormat successful](img/B19779_11_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – ktlintFormat 成功](img/B19779_11_04.jpg)'
- en: Figure 11.4 – ktlintFormat successful
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – ktlintFormat 成功
- en: 'As seen in the preceding figure, the build was successful. This means our project
    is correctly formatted. By using the Git tool in our IDE by pressing *Command*
    + *K* on macOS and *Ctrl* + *K* on Windows, we can see the files that have changes
    and see the changes made by the Ktlint formatter. From our project, this is what
    the commit modal looks like:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，构建成功。这意味着我们的项目格式正确。通过在 IDE 中使用 Git 工具（在 macOS 上按 *Command* + *K*，在 Windows
    上按 *Ctrl* + *K*），我们可以看到有变化的文件以及 Ktlint 格式化器所做的更改。从我们的项目来看，这是提交模态的样式：
- en: '![Figure 11.5 – Git commit modal](img/B19779_11_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – Git 提交模态](img/B19779_11_05.jpg)'
- en: Figure 11.5 – Git commit modal
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – Git 提交模态
- en: As shown in *Figure 11**.5*, the `ktlintFormat` command has made a bunch of
    changes to our files. We can check each file for changes too. The formatter is
    a good tool to help us quickly format our code according to the Kotlin style and
    conventions. The `ktlintFormat` and `ktlintCheck` commands are the ones to run
    after you complete your changes before you commit your code. This will help you
    avoid committing code that is not formatted correctly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11**.5* 所示，`ktlintFormat` 命令对我们的文件进行了一系列更改。我们也可以检查每个文件的更改。格式化器是一个很好的工具，可以帮助我们快速根据
    Kotlin 风格和约定格式化我们的代码。在提交代码之前，完成更改后运行 `ktlintFormat` 和 `ktlintCheck` 命令是必须的。这将帮助您避免提交格式不正确的代码。
- en: 'We have done a basic setup, which is sufficient for most projects. For more
    information, you can learn more about the plugin, the rules available, and how
    to customize it here: [https://github.com/jlleitschuh/ktlint-gradle](https://github.com/jlleitschuh/ktlint-gradle).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了基本设置，这对于大多数项目来说是足够的。有关更多信息，您可以在此处了解有关插件、可用规则以及如何自定义它的信息：[https://github.com/jlleitschuh/ktlint-gradle](https://github.com/jlleitschuh/ktlint-gradle)。
- en: We have seen how to use the Ktlint plugin to format and perform static analysis
    of our code. In the next section, we will learn how to use the detekt plugin to
    check for code smells and technical debt in our code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 Ktlint 插件来格式化和执行我们代码的静态分析。在下一节中，我们将学习如何使用 detekt 插件来检查我们代码中的代码异味和技术债务。
- en: Detecting code smells with detekt
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 detekt 检测代码异味
- en: 'detekt is another static code analysis tool for Kotlin. It helps us identify
    problems early and keep the technical debt low throughout the development process.
    It enforces a set of rules that help us avoid code smells and technical debt.
    It also gives us the flexibility to create our own custom rule sets. Detekt offers
    the following features:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: detekt 是另一个用于 Kotlin 的静态代码分析工具。它帮助我们尽早识别问题，并在整个开发过程中保持技术债务低。它强制执行一系列规则，帮助我们避免代码异味和技术债务。它还允许我们创建自己的自定义规则集。Detekt
    提供以下功能：
- en: It identifies code smell for Kotlin projects
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为 Kotlin 项目识别代码异味
- en: It’s easily configurable and customizable to suit our needs
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易配置和自定义以满足我们的需求
- en: We can always suppress the warnings if we feel they are not applicable
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们总是可以抑制那些我们认为不适用的警告
- en: We can specify the code smell thresholds that we want to enforce
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以指定我们想要强制执行的代码异味阈值
- en: 'We will be using these features in our project. But before that, let us understand
    the rule sets. detekt has several rule sets that check the compliance of your
    code with the Kotlin style guide. The available rule sets are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的项目中使用这些功能。但在那之前，让我们了解规则集。detekt 有几个规则集，用于检查您的代码是否符合 Kotlin 风格指南。可用的规则集如下：
- en: '**Comments**: This rule set provides rules that address issues in comments
    and the documentation of the code. It checks header files, comments on private
    methods, and undocumented classes, properties, or methods.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注释**：此规则集提供解决注释和代码文档中问题的规则。它检查头文件、私有方法的注释以及未记录的类、属性或方法。'
- en: '**Complexity**: This rule set contains rules that report complex code. It checks
    for complex conditions, methods, expressions, and classes, as well as long methods
    and long parameter lists.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：此规则集包含报告复杂代码的规则。它检查复杂条件、方法、表达式和类，以及长方法和长参数列表。'
- en: '**Coroutines**: This rule set analyzes code for potential coroutine problems.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**：此规则集分析代码中可能存在的协程问题。'
- en: '**Empty-Blocks**: This rule set contains rules that report empty blocks of
    code. Examples include empty **catch** blocks, empty class blocks, and empty function
    and conditional function blocks.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空块**：此规则集包含报告空代码块的规则。例如，空的 **catch** 块、空的类块和空的函数及条件函数块。'
- en: '**Exceptions**: This rule set reports issues related to how code throws and
    handles exceptions. For example, it has rules for if you’re catching generic exceptions,
    among other issues related to handling exceptions.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**例外情况**：此规则集报告与代码抛出和处理异常相关的问题。例如，它包含关于捕获通用异常以及其他与异常处理相关问题的规则。'
- en: '**Formatting**: This rule set checks whether your code base follows a specific
    formatting rule set. It allows for checking indentation, spacing, semicolons,
    or even import ordering, among other things.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式化**：此规则集检查您的代码库是否遵循特定的格式化规则集。它允许检查缩进、间距、分号，甚至导入顺序等。'
- en: '**Naming**: This rule set contains rules that assert the naming of different
    parts of the code base. It checks how we name our classes, packages, functions,
    and variables. It reports the errors in case we’re not following the set conventions.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名**: 此规则集包含断言代码库中不同部分命名的规则。它检查我们如何命名类、包、函数和变量。如果未遵循既定约定，则会报告错误。'
- en: '**Performance**: This rule set analyzes code for potential performance problems.
    Some of the issues it reports include the use of **ArrayPrimitives** or the misuse
    of **forEach** loops, for instance.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**: 此规则集分析代码以查找潜在的性能问题。它报告的一些问题包括使用 **ArrayPrimitives** 或滥用 **forEach**
    循环等。'
- en: '**Potential-Bugs**: This rule set provides rules that detect potential bugs.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在问题**: 此规则集提供了检测潜在问题的规则。'
- en: '**Ruleauthors**: This rule set provides rules that ensure good practices are
    followed when writing custom rules.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则作者**: 此规则集提供了确保在编写自定义规则时遵循良好实践的规则。'
- en: '**Style**: This rule set provides rules that assert the style of the code.
    This will help keep the code in line with the given code style guidelines.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风格**: 此规则集提供了断言代码风格的规则。这将有助于保持代码与给定的代码风格指南保持一致。'
- en: With this understanding of detekt rule sets and features, let us now set up
    detekt in our project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了 detekt 规则集和功能之后，现在让我们在我们的项目中设置 detekt。
- en: Setting up detekt
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 detekt
- en: 'Similar to Ktlint, detekt is available as a Gradle plugin. To add the plugin
    to our project, we need to add the following code to our project’s `build.gradle.kts`
    file in the plugins block:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ktlint 类似，detekt 作为一个 Gradle 插件提供。要将插件添加到我们的项目中，我们需要在我们的项目 `build.gradle.kts`
    文件的插件块中添加以下代码：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Click on the `build.gradle.kts` file below the plugins block:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件块下方点击 `build.gradle.kts` 文件：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This applies the detekt plugin to all the modules that will be in our project
    so we do not need to add the plugin to each module. We also set the `parallel`
    property to `true`. This will help us run the detekt tasks in parallel and save
    time when running the tasks. Click on the **Sync Now** button at the top to add
    the changes to the project. We are now set to use detekt. Open your terminal and
    run the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用 detekt 插件到我们项目中所有将包含的模块，因此我们不需要为每个模块添加插件。我们还设置了 `parallel` 属性为 `true`。这将帮助我们并行运行
    detekt 任务，并在运行任务时节省时间。点击顶部的 **同步现在** 按钮以将更改添加到项目中。我们现在可以开始使用 detekt。打开您的终端并运行以下命令：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will run the `detekt` task. After the task completes, we will see the
    following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 `detekt` 任务。任务完成后，我们将看到以下输出：
- en: '![Figure 11.6 – detekt errors](img/B19779_11_06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – detekt 错误](img/B19779_11_06.jpg)'
- en: Figure 11.6 – detekt errors
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – detekt 错误
- en: 'The first time we run the task, we will get a number of errors. As we can see
    from the preceding figure, detekt shows the file and line number with the error
    and the type of rule set that has not been complied with. In *Figure 11**.6*,
    we can see the common ones being the function is too long, and magic numbers are
    included, among others. At the end of the list of errors, detekt normally shows
    the total number of weighted issues, as shown in the following figure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行任务时，我们将得到许多错误。如前图所示，detekt 会显示包含错误的文件和行号以及未遵守的规则集类型。在 *图 11*.6 中，我们可以看到常见的错误包括函数太长，以及包含魔法数字等。在错误列表的末尾，detekt
    通常会显示加权问题的总数，如下图所示：
- en: '![Figure 11.7 – detekt errors summary](img/B19779_11_07.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – detekt 错误摘要](img/B19779_11_07.jpg)'
- en: Figure 11.7 – detekt errors summary
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – detekt 错误摘要
- en: 'We have a total of 121 weighted issues. We are going to see how to suppress
    some as well as increase thresholds for others and fix the ones that we can shortly.
    First, we need to change the default behavior of detekt. To do this, we need to
    create a `detekt-config.yml` file in the root of our project. detekt has a task
    that does this. Let us open the **Terminal** tab in our IDE and run the following
    command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总共有 121 个加权问题。我们将看到如何抑制一些问题以及提高其他问题的阈值，并尽快修复我们可以修复的问题。首先，我们需要更改 detekt 的默认行为。为此，我们需要在我们的项目根目录中创建一个
    `detekt-config.yml` 文件。detekt 有一个任务可以完成这个操作。让我们在我们的 IDE 中打开 **终端** 选项卡并运行以下命令：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will generate a `config` file if we don’t have it already. After the task
    completes, we will see the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有配置文件，这将生成一个 `config` 文件。任务完成后，我们将看到以下输出：
- en: '![Figure 11.8 – detekt config file](img/B19779_11_08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – detekt 配置文件](img/B19779_11_08.jpg)'
- en: Figure 11.8 – detekt config file
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – detekt 配置文件
- en: 'We need to reference this file to our detekt setup. Let us head over to the
    project-level `build.gradle.kts` file and modify our `detekt` block to look like
    this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将此文件引用到我们的 detekt 设置中。让我们转到项目级别的 `build.gradle.kts` 文件并修改我们的 `detekt` 块，使其看起来如下：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are using our newly created file as the `config` file. Click on the
    `config` file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们新创建的文件作为 `config` 文件。点击 `config` 文件。
- en: Customizing detekt
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 detekt
- en: 'At times, `detekt` might be reporting issues that we do not want to fix or
    we might want to change the severity or thresholds of the issue. Here is where
    customizing detekt comes in handy. We can customize `detekt` in the `detekt.yml`
    file and customize the rules that we are interested in. The first issue we are
    going to disable is the `detekt.yml` file and press *Command* + *F* on macOS or
    *Ctrl* + *F* on Windows to search for the `MagicNumber` issue and modify it as
    follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`detekt` 可能会报告我们不希望修复的问题，或者我们可能想要更改问题的严重性或阈值。这就是自定义 detekt 发挥作用的地方。我们可以在
    `detekt.yml` 文件中自定义 `detekt` 并自定义我们感兴趣的规则。我们将要禁用的第一个问题是 `detekt.yml` 文件，并在 macOS
    上按 *Command* + *F* 或在 Windows 上按 *Ctrl* + *F* 搜索 `MagicNumber` 问题并将其修改如下：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are setting the `active` property to `false`. This will disable the issue.
    By running the `./gradlew detekt` command again, we can see that we have reduced
    the error from 121 to 60 now! That’s a significant drop. We can also see that
    the `MagicNumber` issue is no longer present.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `active` 属性设置为 `false`。这将禁用该问题。通过再次运行 `./gradlew detekt` 命令，我们可以看到错误已从 121
    减少到 60！这是一个显著的下降。我们还可以看到 `MagicNumber` 问题不再存在。
- en: '![Figure 11.9 – detekt with no magic numbers](img/B19779_11_09.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 无魔法数字的 detekt](img/B19779_11_09.jpg)'
- en: Figure 11.9 – detekt with no magic numbers
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 无魔法数字的 detekt
- en: 'Next, let us ensure that detekt doesn’t complain about Jetpack Compose function
    naming. Search for the `FunctionNaming` issue and modify it to be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保 detekt 不会对 Jetpack Compose 函数命名提出抱怨。搜索 `FunctionNaming` 问题并将其修改如下：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have added `ignoreAnnotated: [''Composable'']`. This will not report issues
    for all functions annotated with the `@Composable` annotation. Composable functions
    use the Pascal case naming convention. Next, we want to disable the new line at
    the end of the file rule on detekt since we disabled it on Ktlint. Search for
    the `FinalNewline` issue and modify it to be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加了 `ignoreAnnotated: [''Composable'']`。这将不会报告所有使用 `@Composable` 注解的函数的问题。Composable
    函数使用 Pascal 大小写命名约定。接下来，我们希望在 detekt 中禁用文件末尾的新行规则，因为我们已经在 Ktlint 中禁用了它。搜索 `FinalNewline`
    问题并将其修改如下：'
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will disable the issue. By running the `./gradlew detekt` command again,
    we can see that we have reduced the errors to only eight now:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将禁用该问题。通过再次运行 `./gradlew detekt` 命令，我们可以看到错误已减少到现在的只有八个：
- en: '![Figure 11.10 – detekt errors reduced](img/B19779_11_10.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – detekt 错误减少](img/B19779_11_10.jpg)'
- en: Figure 11.10 – detekt errors reduced
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – detekt 错误减少
- en: 'Now, let us see how to increase the thresholds to resolve the *function too
    long* issue. Search for the `FunctionTooLong` issue and modify it to be as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何增加阈值以解决 *函数过长* 的问题。搜索 `FunctionTooLong` 问题并将其修改如下：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will solve all the issues related to the function being too long. Search
    for the `LongParameterList` issue and modify it to be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解决所有与函数过长相关的问题。搜索 `LongParameterList` 问题并将其修改如下：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have increased the threshold from `6` to `8`. Lastly, search for the `ComplexCondition`
    issue and modify it to be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将阈值从 `6` 增加到 `8`。最后，搜索 `ComplexCondition` 问题并将其修改如下：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have also increased the threshold from `4` to `6`. By running the `./gradlew
    detekt` command again, we can see that we have reduced the errors to only three
    now:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将阈值从 `4` 增加到 `6`。通过再次运行 `./gradlew detekt` 命令，我们可以看到错误已减少到现在的只有三个：
- en: '![Figure 11.11 – More errors removed](img/B19779_11_11.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – 移除更多错误](img/B19779_11_11.jpg)'
- en: Figure 11.11 – More errors removed
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – 移除更多错误
- en: 'Increasing thresholds is a good way of reducing errors. It’s also great since
    it reduces the amount of refactoring that we have to do. However, we should be
    careful not to increase the thresholds too much. Let us now try to fix the remaining
    issues. Let us start with the `TooGenericExceptionCaught` and `SwallowedException`
    issues. This is in our `PetsSyncWorker` `doWork` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 增加阈值是减少错误的好方法。这也很好，因为它减少了我们必须进行的重构量。然而，我们应该小心不要将阈值增加得太多。现在，让我们尝试修复剩余的问题。让我们从
    `TooGenericExceptionCaught` 和 `SwallowedException` 问题开始。这是在我们的 `PetsSyncWorker`
    `doWork` 函数中：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To resolve the issues, we need to add a `log` statement to the `catch` block
    and catch only the exceptions that we expect. Let us modify the code to be as
    follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决问题，我们需要在`catch`块中添加一个`log`语句，并只捕获我们期望的异常。让我们修改代码如下：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have added a `log` statement and we are only catching `IOException`. Lastly,
    let us fix the `UtilityClassWithPublicConstructor` issue. This is in our `LeakTestUtils`
    class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`log`语句，并且只捕获`IOException`。最后，让我们修复`UtilityClassWithPublicConstructor`问题。这个问题在我们的`LeakTestUtils`类中：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This class only has a companion object, which returns an instance of the `LeakCanaryTest`
    class. We can use an object instead of a class. Let us modify the class to be
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个伴生对象，它返回`LeakCanaryTest`类的实例。我们可以使用对象而不是类。让我们修改这个类如下：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'All the issues should be fixed now. By running the `./gradlew detekt` command
    again, we can see that we have no errors now:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有问题现在应该都修复了。再次运行`./gradlew detekt`命令后，我们可以看到现在没有错误了：
- en: '![Figure 11.12 – detekt successful run](img/B19779_11_12.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图11.12 – detekt成功运行](img/B19779_11_12.jpg)'
- en: Figure 11.12 – detekt successful run
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – detekt成功运行
- en: Our build successfully passes. Our project now has a plugin that helps us do
    static analysis of our code. We can now identify code smells and technical debt
    early in the development process. We can also use these plugins on **Continuous
    Integration/ Continuous Delivery** (**CI/CD**) pipelines to ensure that we don’t
    merge code that has code smells and technical debt. This will help us keep our
    code base clean and maintainable, especially when we are working in teams. We
    will learn about this extensively in [*Chapter 14*](B19779_14.xhtml#_idTextAnchor198).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建成功通过了。我们的项目现在有一个插件，可以帮助我们进行代码的静态分析。我们现在可以在开发早期就识别代码异味和技术债务。我们还可以将这些插件用于**持续集成/持续交付**（**CI/CD**）管道，以确保我们不会合并有代码异味和技术债务的代码。这将帮助我们保持代码库的清洁和可维护性，尤其是在团队工作时。我们将在[*第14章*](B19779_14.xhtml#_idTextAnchor198)中详细学习这一点。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the Kotlin style and the best practices
    for writing Kotlin code. We have also learned how to use plugins such as Ktlint
    and Detekt to format, lint, and detect code smells early.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Kotlin风格和编写Kotlin代码的最佳实践。我们还学习了如何使用Ktlint和Detekt等插件进行格式化、代码审查和早期检测代码异味。
- en: In the next chapter, we will learn how to add tests for the different layers
    in the MVVM architecture. We will learn about the importance of adding tests to
    our apps and how to add unit tests, integration tests, and instrumentation tests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何为MVVM架构中的不同层添加测试。我们将了解添加测试到我们的应用的重要性，以及如何添加单元测试、集成测试和仪器测试。
