["```java\n    // VERTEX SHADER – PhongVertex.glsl\n    // Reuse old code.. many lines skipped.\n    // Model View Project matrix\n    uniform mat4 LightCoordsMatrix, ModelViewMatrix, NormalMatrix;\n    uniform mat4 ModelMatrix;\n\n    out vec3 normalCoord, eyeCoord;\n    out vec4 shadowCoord;\n\n    void main()\n    {\n        normalCoord = NormalMatrix * Normal;\n        eyeCoord    = vec3 ( ModelViewMatrix * VertexPosition );\n        shadowCoord = LightCoordsMatrix \n                             * ModelMatrix * VertexPosition;\n        gl_Position = ModelViewProjectionMatrix * VertexPosition;\n    }\n    ```", "```java\n    // FRAGMENT SHADER – PhongFragment.glsl\n    // Many line skipped contain Material and light properties\n    in vec3  normalCoord, eyeCoord;\n    in vec4 shadowCoord;\n    uniform lowp sampler2DShadow ShadowMap;\n\n    layout(location = 0) out vec4 FinalColor;\n    vec3 normalizeNormal, normalizeEyeCoord, normalizeLightVec, V, R, ambient, diffuse, specular;\n    float sIntensity, cosAngle;\n    uniform int isLightPerspectivePass;\n\n    vec3 PhongShading(){ /* Reuse existing code */ }\n\n    void main() {\n        if(isLightPerspectivePass == 1){ return; }\n\n        vec3 diffAndSpec = PhongShading();\n        float shadow = textureProj(ShadowMap, shadowCoord);\n\n        //If the fragment is in shadow, use ambient light\n        FinalColor = vec4(diffAndSpec * shadow + ambient, 1.0);\n\n        // Correct the Gamma configuration\n        FinalColor = pow( FinalColor, vec4(1.0 / 2.2) );\n        return;\n    }\n    ```", "```java\n    CustomScene::CustomScene(std::string name, Object* parentObj)\n                :Scene(name, parentObj){\n       // Create the FBO\n       fbo = new FrameBufferObjectSurface(); \n\n        // Generate the FBO ID\n       fbo->GenerateFBO();\n\n        depthTexture.generateTexture2D(GL_TEXTURE_2D, fbo->\n          GetWidth(), fbo->GetHeight(), GL_DEPTH_COMPONENT32F,\n          GL_FLOAT, GL_DEPTH_COMPONENT, 0, true, 0, 0,\n          GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE,GL_NEAREST,\n          GL_NEAREST );\n\n       // Attached Depth Buffer\n       fbo->AttachTexture(depthTexture, GL_DEPTH_ATTACHMENT);\n\n       // Check the status of the FBO\n       fbo->CheckFboStatus();\n       lightPerspective = camera = NULL;\n    }\n    ```", "```java\n    void CustomScene::initializeScene(){\n    // Create camera view from lights perspective    lightPerspective = new Camera(\"lightPerspective\", this);\n       lightPerspective->SetClearBitFieldMask(GL_DEPTH_BUFFER_BIT);\n       lightPerspective->SetPosition\n                   (vec3(this->lights.at(0)->position));\n        lightPerspective->SetTarget(vec3 (0.0, 0.0,0.0));\n        this->addCamera(lightPerspective);\n\n        // Create scene's camera view.\n        viewersPerspective = new Camera(\"Camera1\", this);\n        viewersPerspective->SetClearBitFieldMask\n                (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        viewersPerspective->SetPosition(vec3 (25.0, 25.0,25.0));\n        viewersPerspective->SetTarget(vec3 (0.0, 0.0,0.0));\n        this->addCamera(viewersPerspective);\n        Scene::initializeScene(); // Call the base class.\n    }\n    ```", "```java\n    void CustomScene::render(){\n        // Set Framebuffer to the FBO    \n        fbo->Push(); \n\n        // Render the scene from lights perspective\n        lightPerspective->Render();\n\n         // Cull the front faces to produce \n        glEnable(GL_CULL_FACE);\n        glCullFace(GL_FRONT);\n\n        glEnable(GL_POLYGON_OFFSET_FILL);\n        glPolygonOffset(2.5f, 20.0f);\n\n        for( int i=0; i<models.size();  i++ ){\n            currentModel = models.at(i);\n            if(!currentModel){ continue; }\n\n           // Set LIGHT PASS (PASS ONE) to True\n            ((ObjLoader*)currentModel)->SetLightPass(true);\n            currentModel->Render();\n        }\n        fbo->Pop();// Reset to previous framebuffer\n\n        // Bind the texture unit 0 to depth texture of FBO\n        glActiveTexture (GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, depthTexture.getTextureID());\n\n        camera->Render();    // View the scene from camera\n        glCullFace(GL_BACK); // Cull objects back face.\n        glDisable(GL_POLYGON_OFFSET_FILL);\n\n        for( int i=0; i<models.size();  i++ ){\n            currentModel = models.at(i);\n            if(!currentModel){ continue; }\n\n            // PASS TWO => Normal scene rendering\n            ((ObjLoader*)currentModel)->SetLightPass(!true);\n            currentModel->Render();\n        }\n    }\n    ```", "```java\n    // Inside CustomScene::CustomScene\n    fbo = new FrameBufferObjectSurface();\n    fbo->GenerateFBO();\n\n    // Generate the depth texture with linear filtering\n    depthTexture.generateTexture2D( GL_TEXTURE_2D, \n       fbo->GetWidth(), fbo->GetHeight(),\n       GL_DEPTH_COMPONENT32F, GL_FLOAT, GL_DEPTH_COMPONENT, \n       0, true, 0, 0,GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE,\n       GL_LINEAR, GL_LINEAR );\n\n    // Attached the Depth Buffer to FBO's depth attachment\n    fbo->AttachTexture(depthTexture, GL_DEPTH_ATTACHMENT);\n    ```", "```java\n      // Many lines below skipped, please refer to the recipe code \n      void main() { \n      vec3 diff_Spec = PhongShading();\n\n      // APPLY the Percentage Closer filtering and use sum \n      // of the contributions from 4 texels around it\n      float sum = 0.0;\n      sum += textureProjOffset(ShadowMap, shadowCoord, ivec2(-1,-1));\n      sum += textureProjOffset(ShadowMap, shadowCoord, ivec2(-1,1));\n      sum += textureProjOffset(ShadowMap, shadowCoord, ivec2(1,1));\n      sum += textureProjOffset(ShadowMap, shadowCoord, ivec2(1,-1));\n\n      ambient    = MaterialAmbient  * LightAmbient;\n      // If the fragment is under shadow, use ambient light\n      FinalColor = vec4(diff_Spec * sum * 0.25+ ambient, 1.0);\n\n      // Correct the Gamma configuration\n      FinalColor = pow( FinalColor, vec4(1.0/2.2) );\n     }\n    ```", "```java\n    // Inside CustomScene::CustomScene\n    fbo = new FrameBufferObjectSurface();\n    fbo->GenerateFBO();\n\n    // Generate the depth texture with linear filtering\n    colorTexture.generateTexture2D( GL_TEXTURE_2D, \n       fbo->GetWidth(), fbo->GetHeight(),\n       GL_RGB16F, GL_FLOAT, GL_RGB, \n       0, true, 0, 0,GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE,\n       GL_LINEAR, GL_LINEAR );\n\n    // Attached the Depth Buffer to FBO's depth attachment\n    fbo->AttachTexture(colorTexture, GL_COLOR_ATTACHMENT0);\n    ```", "```java\n    #version 300 es\n    layout(location = 0) in vec4  VertexPosition;\n    uniform mat4    ModelViewProjectionMatrix;\n    out vec4    position;\n\n    void main(){\n        gl_Position = ModelViewProjectionMatrix * VertexPosition;\n        position = gl_Position;\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    in vec4    position;\n    layout(location = 0) out vec4 FinalColor;\n\n    void main() {\n        float depth = position.z / position.w ;\n        //Homogenous to texture coordinate system ([-1,1]) to [0,1] \n        depth = depth * 0.5 + 0.5;\n\n        float M1 = depth;           // Moment 1\n        float M2 = depth * depth;   // Moment 2\n\n        float dx = dFdx(depth);\n        float dy = dFdy(depth);\n        moment2 += 0.25*(dx*dx+dy*dy) ;\n\n        FinalColor = vec4( moment1,moment2, 0.0, 0.0 );\n    }\n    ```", "```java\n      // Many line below skipped\n\n    in vec4    shadowCoord;\n\n    uniform sampler2D ShadowMap;\n    layout(location = 0) out vec4 FinalColor;\n\n    vec3 PhongShading(){ . . . }\n    vec4 homogenShadowCoords;\n\n    float chebyshevComputeQuantity( float distance){\n        // Get the two moments M1 and M2 in moments.x \n        // and moment.y respectively\n        vec2 moments = texture(ShadowMap,\n                        homogenShadowCoords.xy).rg;\n\n        // Current fragment is ahead of the object surface,\n        // therefore must be lighted\n        if (distance <= moments.x)\n            return 1.0 ;\n\n        float E_x2 = moments.y;\n        float Ex_2 = moments.x * moments.x;\n\n        // Computer the variance\n        float variance = E_x2 - (Ex_2);\n\n        float t = distance - moments.x;\n        float pMax = variance / (variance + t*t);\n\n        return pMax;\n    }\n\n    void main() {\n        vec3 diff_Spec = PhongShading();\n\n        // Calculate the homogenous coordinates\n        homogenShadowCoords = shadowCoord/shadowCoord.w;\n\n        // Calculate the quantity\n        float shadow = chebyshevComputeQuantity(\n                              homogenShadowCoords.z);\n\n        ambient    = MaterialAmbient  * LightAmbient;\n\n        // If the fragment is in shadow, use ambient light only.\n        FinalColor = vec4(diff_Spec * shadow + ambient, 1.0);\n\n        // Correct the Gamma configuration\n        FinalColor = pow( FinalColor, vec4(1.0 / 2.2) );\n        return;\n    }\n    ```", "```java\n        image = new PngImage();\n        image->loadImage(fname);\n    ```", "```java\n    // ParticleVertex.glsl\n    #version 300 es\n\n    // Vertex information\n    layout(location = 0) in vec3  position;\n    layout(location = 1) in vec2  texcoord;\n\n    uniform mat4 worldMatrix;\n    uniform mat4 viewProjectionMatrix;\n    uniform float lifeFactor;\n\n    out vec2 texCoord;\n    out float life;\n\n    void main( void ) {\n        texCoord         = texcoord;\n        life             = lifeFactor;\n        gl_Position      = viewProjectionMatrix*vec4(position, 1.0 );\n    }\n    ```", "```java\n    // ParticleFragment.glsl\n\n    #version 300 es\n    precision mediump float;\n\n    uniform sampler2D Tex1;\n    in vec2 texCoord;\n    in float life;\n\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        // directional light\n        vec3 lightDir = normalize( vec3( 1.0, 1.0, 1.0 ) );\n        // diffuse\n        vec4 diffuseColor = vec4( 1, 1.0 - life, 0, 1 );\n        vec4 texColor = texture( Tex1, texCoord );\n        diffuseColor *= texColor;\n\n        // final color\n        vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n        color.rgb = clamp( diffuseColor.rgb, 0.0, 1.0 );\n        color.a = diffuseColor.a * life;\n\n        // save it out\n        outColor = vec4(texColor.xyz, 1.0);\n        outColor = diffuseColor;\n    }\n    ```", "```java\n    void ParticleSystem::InitModel(){\n        DrawShader();      // Initialize the shader\n        InitParticles();   // Initialize the particles\n        Model::InitModel();// Call the base class\n    }\n    ```", "```java\n    void ParticleSystem::DrawShader(){\n\n       // Load the shader file here, many lines skipped below\n       . . . . . .      \n\n       // Use the compiled program \n       glUseProgram( program->ProgramID );\n\n       // Load the uniform variable from the shader files.\n       TEX = GetUniform( program, (char *) \"Tex1\" );\n       worldUniform = GetUniform(program,(char*)\"worldMatrix\");\n       viewProjectionUniform = GetUniform( program, \n       (char *) \"viewProjectionMatrix\" );\n       life = GetUniform( program, (char *) \"lifeFactor\" );\n\n       // Allocate the memory for Particle System. The\n       // particle count are contained in the MAX_PARTICLES.\n       particles = (Particle*)malloc(sizeof(Particle)*MAX_PARTICLES);\n\n       // Start position of each particle (0.0, 0.0, 0.0)\n       sourcePosition = glm::vec3(0.0, 0.0, 0.0);\n    }\n    ```", "```java\n    void ParticleSystem::InitParticles(){\n        // define the type of mesh to use for the particles\n        particleMesh        = CreateQuadrilateral();\n\n       // define the type of mesh to use for the particles\n        particleMesh        = CreateQuadrilateral();\n\n        float lowestSpeed, highestSpeed, rangeSpeed;\n        lowestSpeed = highestSpeed = rangeSpeed = 1.0f;\n\n        for( ii = 0; ii < MAX_PARTICLES; ++ii ){\n            Particle* p  = &particles[ ii ];\n            p->transform = mat4();\n            p->pos       = sourcePosition;\n            p->life      = -1.0f;\n            p->transform = translate(p->transform,p->pos);\n            lowestSpeed  = -2.0;\n            highestSpeed = 2.0f;\n            rangeSpeed   = ( highestSpeed - lowestSpeed ) + 1;\n            float f      = (float)(lowestSpeed + (rangeSpeed * \n                                rand() / (RAND_MAX + 1.0f) ) );\n            p->vel.x     = f;\n            lowestSpeed  = 4.0;\n            highestSpeed = 8.0f;\n            rangeSpeed   = ( highestSpeed - lowestSpeed ) + 1;\n            f            = (float)(lowestSpeed + (rangeSpeed *\n                                rand() / (RAND_MAX + 1.0f) ) );\n            p->vel.y     = f;\n            p->vel.z     = 0;\n        }\n    }\n    ```", "```java\n        MeshParticle* ParticleSystem::CreateQuadrilateral( void )\n    {\n        // Quadrilateral made of 2 triangle=>[0,1,2] & [0,2,3]\n        //  1-------0\n        //  |     / |\n        //  |   /   |\n        //  | /     |\n        //  2-------3\n\n        // Interleaved square vertices with position & tex \n        const Vertex quadVertices[] ={\n        // Triangle 1: Orientation [ 0, 1, 2 ]\n        { {  1.0f,  1.0f,  0.0f },  { 1.0f, 1.0f } },\n        { { -1.0f,  1.0f,  0.0f },  { 0.0f, 1.0f } },\n        { { -1.0f, -1.0f,  0.0f },  { 0.0f, 0.0f } },\n\n        // Triangle 2: Orientation [ 0, 2, 3 ]\n        { {  1.0f,  1.0f,  0.0f },  { 1.0f, 1.0f } },\n        { { -1.0f, -1.0f,  0.0f },  { 0.0f, 0.0f } },\n        { {  1.0f, -1.0f,  0.0f },  { 1.0f, 0.0f } },\n        };\n\n        // Allocate memory for particle geometry datastructure\n        const int Count   = 6;\n        MeshParticle* quad = ( MeshParticle* )malloc\n        ( sizeof( MeshParticle ) );\n        quad->vertices     = (Vertex*)malloc(sizeof(Vertex) * Count);\n        memcpy( quad->vertices, quadVertices, Count*sizeof(Vertex) );\n        quad->vertexCount  = quadVertexCount;\n        return quad;\n    }\n    ```", "```java\n    void ParticleSystem::Update (){\n        static clock_t lastTime = clock();\n        clock_t currentTime     = clock();\n        float deltaTime  = (currentTime - lastTime) /\n                           (float)(CLOCKS_PER_SEC);\n        lastTime         = currentTime;\n\n        // update attribute for the particle emission \n        EmitParticles( deltaTime );\n        return;\n    }\n    ```", "```java\n    void ParticleSystem::EmitParticles(float elapsedTime ){\n        static float fRotation = 0.0f;\n        if(fRotation>360.0){\n            fRotation = 0.0;\n        }\n\n        int spawn   = 0;\n\n        for(unsigned ii = 0; ii < MAX_PARTICLES; ++ii ){\n            Particle* p = &particles[ ii ];\n\n            // Living particles\n            if(particle->life > 0.0f){\n                unsigned int bIsEven = ( ( ii % 2 ) == 0 ) ? 1 : 0;\n                particle->transform  = rotate( particle->transform, \n               (bIsEven) ? fRotation : -fRotation, vec3(0.0,0.0,1.0));\n               vec3 vel              = p->vel/100.0f * elapsedTime;\n                p->pos               = p->pos + vel;\n\n                p->life           -= p->vel.y * elapsedTime;\n                p->transform       = translate( p->transform, p->pos);\n            }\n\n           // Dead particles. Re-spawn more\n            else{\n                // Re-Spawn a max of 10 particles every frame\n                if( spawn++ > 10 ) { continue; }\n                particle->pos       = sourcePosition;\n                particle->life      = MAX_LIFE;\n                particle->transform = mat4();\n            }\n\n            float fScaleFactor = 1.0+(particle->pos.y * 0.25f);\n            p->transform = scale(p->transform, \n               vec3( fScaleFactor, fScaleFactor, fScaleFactor ));\n        }\n    }\n    ```", "```java\n    void ParticleSystem::RenderParticles(){\n        // Set the shader program\n        glUseProgram( program->ProgramID );\n\n        // All the particles are using the same texture, so it\n        // only needs to be set once for all the particles\n        glEnable(GL_BLEND);\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);\n        glActiveTexture( GL_TEXTURE0 );\n        if(image){\n        glBindTexture( GL_TEXTURE_2D, image->getTextureID() );\n        // Apply texture filter, below many lines are skipped...\n\n        }\n\n        glUniform1i( TEX, 0 );\n        mat4 viewProj=*TransformObj-> \n                       TransformGetModelViewProjectionMatrix();\n\n        // Loop through the particles\n        unsigned int ii = 0;\n        for( ii = 0; ii < MAX_PARTICLES; ++ii )\n        {\n            // Current particle\n            Particle* p = &particles[ ii ];\n\n            // Pointer to the particle mesh\n            MeshParticle* pMesh = particleMesh;\n\n            // Only draw the particle if it is alive\n            if( p->life > 0.0f ){\n               // Set the particle transform uniform\n                glUniformMatrix4fv( worldUniform, 1, \n               GL_FALSE, ( const GLfloat* )&p->transform );\n\n               // Set view and projection matrices\n                glm::mat4 mvp = viewProj * p->transform ;\n                glUniformMatrix4fv( viewProjectionUniform, \n                    1, GL_FALSE, ( const GLfloat* )&mvp );\n\n                // Send the remaining life span.\n                glUniform1f( life, p->life / MAX_LIFE );\n\n                // Enable and Set the vertex attributes:-\n                // position, texture coords\n                glEnableVertexAttribArray( VERTEX_POSITION );\n                glEnableVertexAttribArray( TEX_COORD );\n                glVertexAttribPointer( VERTEX_POSITION, 3, GL_FLOAT, \n                GL_FALSE, sizeof( Vertex ), &pMesh->vertices->pos );\n                glVertexAttribPointer( TEX_COORD, 2, GL_FLOAT, \n                GL_FALSE, sizeof( Vertex ), \n                &pMesh->vertices->texCoord );\n\n                glDrawArrays( GL_TRIANGLES, 0, pMesh->vertexCount );\n            }\n        }\n    }\n    ```", "```java\n    #version 300 es\n    #define NUM_PARTICLES           200\n    #define ATTRIBUTE_POSITION      0                                 \n    #define ATTRIBUTE_VELOCITY      1                                 \n    #define ATTRIBUTE_SIZE          2                                 \n    #define ATTRIBUTE_CURTIME       3                                 \n    #define ATTRIBUTE_LIFETIME      4                                 \n    uniform float               time;\n    uniform float               emissionRate;\n    uniform mediump sampler3D   noiseTex;\n\n    layout(location = ATTRIBUTE_POSITION) in vec2   inPosition;\n    layout(location = ATTRIBUTE_VELOCITY) in vec2   inVelocity;\n    layout(location = ATTRIBUTE_SIZE) in float      inSize;\n    layout(location = ATTRIBUTE_CURTIME) in float   inCurrentTime;\n    layout(location = ATTRIBUTE_LIFETIME) in float  inLifeTime;\n\n    out vec2    position;\n    out vec2    velocity;\n    out float   size;\n    out float   currentTime;\n    out float   lifeTime;\n\n    float randomValue( inout float seed ){                                                                 \n       float vertexId   = float(gl_VertexID) / float(NUM_PARTICLES);\n       vec3 texCoord    = vec3( time, vertexId, seed );\n       seed             += 0.41;//(.10/float( NUM_PARTICLES ));\n       return texture( noiseTex, texCoord ).r;\n    }                                                                 \n\n    void main(){                                                                 \n        float seed      = time;\n        float lifetime  = (inCurrentTime - time)*10.0;\n        if( lifetime <= 0.0 && randomValue(seed) < emissionRate )\n        {\n            position       = vec2( 0.0, -1.0 );\n            velocity       = vec2( randomValue(seed) * 2.0 - 1.00,\n                                  randomValue(seed)  + 3.0 );\n            size           = randomValue(seed) * 20.0;\n            currentTime    = time;\n            lifeTime       = 5.0;\n        }\n        else{\n            position = inPosition; velocity   = inVelocity;\n            size      = inSize;  currentTime  = inCurrentTime;\n            lifeTime = inLifeTime;\n        }\n        gl_Position = vec4( position, 0.0, 1.0 );\n    }\n    ```", "```java\n    #version 300 es                         \n    precision mediump float;                \n    layout(location = 0) out vec4 fragColor;\n    void main(){                                       \n      fragColor = vec4(1.0);                \n    }\n    ```", "```java\n    #version 300 es                                              \n    #define ATTRIBUTE_POSITION      0                             \n    #define ATTRIBUTE_VELOCITY      1                             \n    #define ATTRIBUTE_SIZE          2                             \n    #define ATTRIBUTE_CURTIME       3                             \n    #define ATTRIBUTE_LIFETIME      4                             \n\n    layout(location = ATTRIBUTE_POSITION) in vec2   inPosition;\n    layout(location = ATTRIBUTE_VELOCITY) in vec2   inVelocity;\n    layout(location = ATTRIBUTE_SIZE) in float      inSize;\n    layout(location = ATTRIBUTE_CURTIME) in float   inCurrentTime;\n    layout(location = ATTRIBUTE_LIFETIME) in float  inLifeTime;\n\n    uniform float   time;\n    uniform vec2    acceleration;\n    uniform mat4    ModelViewProjectMatrix;\n\n    void main(){                                                             \n      float deltaTime = (time - inCurrentTime)/10.0;\n      if ( deltaTime <= inLifeTime ){ \n         vec2 velocity = inVelocity + deltaTime * acceleration;\n         vec2 position = inPosition + deltaTime * velocity;\n         gl_Position   = ModelViewProjectMatrix\n                                    *vec4(position, 0.0, 1.0);\n         gl_PointSize  = inSize * ( 1.0 - deltaTime / inLifeTime );\n      }                                                           \n      else{                                                     \n         gl_Position    = vec4( -1000, -1000, 0, 0 );\n         gl_PointSize   = 0.0;\n      }\n    }\n    ```", "```java\n    #version 300 es                                  \n    precision mediump float;                         \n    layout(location = 0) out vec4 fragColor;         \n    uniform vec4 color;\n    uniform sampler2D tex;\n\n    void main(){                                                \n      vec4 texColor = texture( tex, gl_PointCoord );\n      fragColor     = texColor * color;\n    }\n    ```", "```java\n       void ParticleSystem::EmitShader(){\n       program = ProgramManagerObj->ProgramLoad((char*) \"TFEmit\",\n       VERTEX_SHADER_PRG_EMIT, FRAGMENT_SHADER_PRG_EMIT);\n\n       glUseProgram( program->ProgramID );\n       emitProgramObject = program->ProgramID;\n\n       const char *feedbackVaryings[5] = { \"position\", \"velocity\", \n       \"size\", \"currentTime\", \"lifeTime\" };\n\n       // Set vertex shader outputs as transform feedback\n       glTransformFeedbackVaryings ( emitProgramObject, 5,\n       feedbackVaryings, GL_INTERLEAVED_ATTRIBS );\n\n       // Link program after calling glTransformFeedbackVaryings\n       glLinkProgram ( program );\n\n       emitTimeLoc = GetUniform(program,\"time\");\n       emitEmissionRateLoc = GetUniform( program, \"emissionRate\" );\n       emitNoiseSamplerLoc = GetUniform(program, \"noiseTex\" );\n    }\n    ```", "```java\n        void glTransformFeedbackVaryings(GLuint program, GLsizei count, const char ** varyings, GLenum bufferMode);\n        ```", "```java\n    void ParticleSystem::DrawShader(){\n        program = ProgramManagerObj->ProgramLoad((char*)\"TFDraw\", \n             VERTEX_SHADER_PRG_DRAW, FRAGMENT_SHADER_PRG_DRAW); \n        glUseProgram( program->ProgramID );\n\n        MVP = GetUniform( program,(char*)\"ModelViewProjectMatrix\");\n\n        // Load the shaders and get a linked program object\n        drawProgramObject = program->ProgramID;\n\n        // Get the uniform locations\n        drawTimeLoc   = GetUniform(drawProgramObject,\"time\");\n        drawColorLoc  = GetUniform(drawProgramObject,\"color\");\n        drawAccelerationLoc = GetUniform(program, \"acceleration\");\n        samplerLoc  = GetUniform (program, \"tex\");\n    }\n    ```", "```java\n       void ParticleSystem::InitParticles(){\n\n       time        = 0.0f; \n       curSrcIndex  = 0; \n       textureId    = image->getTextureID();\n\n       if(textureId <= 0){ return; }\n\n       // Create a 3D noise texture for random values\n       noiseTextureId = Create3DNoiseTexture ( 128, 50.0 );\n       Particle particleData[ NUM_PARTICLES ];\n\n       // Initialize particle data\n       for ( int i = 0; i < NUM_PARTICLES; i++ ){\n          Particle *particle     = &particleData[i];\n          particle->position[0]  = 0.0f; \n          particle->position[1]  = 0.0f;\n          particle->velocity[0]  = 0.0f; \n          particle->velocity[1]  = 0.0f;\n          particle->size         = 0.0f;  \n          particle->curtime      = 0.0f;\n            particle->lifetime       = 0.0f;\n       }\n\n       // Create the particle VBOs\n       glGenBuffers ( 2, &particleVBOs[0] );\n\n       for ( int i = 0; i < 2; i++ ) {\n       glBindBuffer ( GL_ARRAY_BUFFER, particleVBOs[i] );\n       glBufferData ( GL_ARRAY_BUFFER, sizeof ( Particle ) * \n       NUM_PARTICLES, particleData, GL_DYNAMIC_COPY );\n       }\n    }\n    ```", "```java\n    void ParticleSystem::InitModel(){\n        UpdateShader();\n        DrawShader();\n        InitParticles();\n        Model::InitModel();\n        return;\n    }\n    ```", "```java\n        void ParticleSystem::Update (){\n        static clock_t lastTime = clock();\n        clock_t currentTime     = clock();\n        float deltaTime         = (currentTime - lastTime)/\n                                   CLOCKS_PER_SEC*0.10;\n        lastTime                = currentTime;\n        time                    += deltaTime;\n\n        EmitParticles ( deltaTime );\n    }\n    ```", "```java\n        void ParticleSystem::EmitParticles(float deltaTime ){\n        //UserData *userData = esContext->userData;\n        GLuint srcVBO = particleVBOs[ curSrcIndex ];\n        GLuint dstVBO = particleVBOs[ ( curSrcIndex + 1 ) % 2 ];\n\n        glUseProgram ( emitProgramObject );\n\n        // transform feedback buffer\n        SetupVertexAttributes ( srcVBO );\n\n        // Set transform feedback buffer\n        glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, dstVBO);\n        glBindBufferBase (GL_TRANSFORM_FEEDBACK_BUFFER, 0, dstVBO);\n\n        // Turn off rasterization - we are not drawing\n        glEnable(GL_RASTERIZER_DISCARD);\n\n        // Set uniforms\n        glUniform1f(emitTimeLoc, time);\n        glUniform1f(emitEmissionRateLoc, EMISSION_RATE);\n\n        // Bind the 3D noise texture\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_3D, noiseTextureId);\n        glUniform1i(emitNoiseSamplerLoc, 0);\n\n        // Emit particles using transform feedback\n        glBeginTransformFeedback(GL_POINTS);\n        glDrawArrays(GL_POINTS, 0, NUM_PARTICLES);\n        glEndTransformFeedback();\n\n        // Ensure transform feedback results are completed\n        // before the draw that uses them.\n        emitSync = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);\n\n        //Allows fragment drawing\n        glDisable ( GL_RASTERIZER_DISCARD ); \n        glUseProgram ( 0 );\n        glBindBufferBase ( GL_TRANSFORM_FEEDBACK_BUFFER, 0, 0 );\n        glBindBuffer ( GL_ARRAY_BUFFER, 0 );\n        glBindTexture ( GL_TEXTURE_3D, 0 );\n\n        // Ping pong the buffers\n        curSrcIndex = ( curSrcIndex + 1 ) % 2;\n    }\n    ```", "```java\n    void glBeginTransformFeedback(GLenum primitiveMode);\n    void glEndTransformFeedback();\n    ```", "```java\n    void ParticleSystem::RenderParticles(){\n        // Make sure that the GL server blocked until\n        // transform feedback output is not captured.\n        glWaitSync ( emitSync, 0, GL_TIMEOUT_IGNORED );\n        glDeleteSync ( emitSync );\n        glUseProgram(drawProgramObject);\n\n        // Load the VBO and vertex attributes\n        SetupVertexAttributes ( particleVBOs[ curSrcIndex ] );\n        glUniformMatrix4fv( MVP, 1, GL_FALSE,(float*) \n          TransformObj->TransformGetModelViewProjectionMatrix());\n\n        glUniform1f ( drawTimeLoc, time );\n        glUniform4f ( drawColorLoc, 1.0f, 1.0f, 1.0f, 1.0f );\n        glUniform2f ( drawAccelerationLoc, 0.0f, ACCELERATION );\n\n        glEnable ( GL_BLEND );\n        glBlendFunc ( GL_SRC_ALPHA, GL_ONE );\n\n        // Bind the texture \n        glActiveTexture ( GL_TEXTURE0 );  \n        glBindTexture ( GL_TEXTURE_2D, textureId );\n\n        // Set the sampler texture unit to 0\n        glUniform1i ( samplerLoc, 0 );\n        glDrawArrays ( GL_POINTS, 0, NUM_PARTICLES );\n    }\n    ```"]