<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer067">
			<h1 id="_idParaDest-49" class="chapter-number"><a id="_idTextAnchor055"/>4</h1>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor056"/>Design with Material Design 3</h1>
			<p>Material Design is a design system developed by Google. It helps us create beautiful UIs. It provides a set of guidelines and components for us to use as we’re developing our <span class="No-Break">Android apps.</span></p>
			<p>In this chapter, we’ll introduce ourselves to <strong class="bold">Material 3</strong>. We will also cover the features that Material 3 offers. Lastly, we will learn how to use Material 3 in our Android apps and some of the components in <span class="No-Break">Material 3.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Material Design 3 and <span class="No-Break">its features</span></li>
				<li>Using Material Design 3 in <span class="No-Break">our apps</span></li>
				<li>Building for large screens <span class="No-Break">and foldables</span></li>
				<li>Making our <span class="No-Break">app accessible</span></li>
			</ul>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor057"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio"><span class="No-Break">https://developer.android.com/studio</span></a><span class="No-Break">) downloaded.</span></p>
			<p>You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor058"/>Material Design 3 and its features</h1>
			<p>The release of <strong class="bold">Material Design 3</strong> (<strong class="bold">Material 3</strong>) came with lots of new features to help us build UIs for our apps. Here are some of the<a id="_idIndexMarker163"/> features of Material <span class="No-Break">Design 3:</span></p>
			<ul>
				<li><strong class="bold">Dynamic color</strong>: This is a color system that sets the color of our apps to the color of the user’s wallpaper. The System UI also adapts to this color. This enables users to have that personalized feel for their apps. Please note that dynamic color only works for Android 12 and <span class="No-Break">above devices.</span></li>
				<li><strong class="bold">More components</strong>: Material 3 has a new set of improved components that are available for use. Some components have new UIs and others have been added to <span class="No-Break">the APIs.</span></li>
				<li><strong class="bold">Simplified typography</strong>: Material 3 has a much more simplified naming and grouping for typography. We have the following types: <strong class="bold">display</strong>, <strong class="bold">headline</strong>, <strong class="bold">title</strong>, <strong class="bold">body</strong>, and <strong class="bold">label</strong>, with each supporting <em class="italic">small</em>, <em class="italic">medium</em>, and <em class="italic">large</em> sizes. This makes it easier for us to define styles all across <span class="No-Break">our apps.</span></li>
				<li><strong class="bold">Improved color scheme</strong>: The color scheme has undergone a lot of improvements with the addition of more color schemes to fine-grain color customization. It’s also way easier for us to support both dark and light color schemes in our apps. In addition to that, they created a new tool, Material Theme Builder (<a href="https://m3.material.io/theme-builder">https://m3.material.io/theme-builder</a>), which allows us to generate and export dark and <a id="_idIndexMarker164"/>light theme colors for <span class="No-Break">our apps.</span></li>
				<li><strong class="bold">Simplified shapes</strong>: Similar to typography, shapes have also been simplified to the following: <strong class="bold">Extra Small</strong>, <strong class="bold">Small</strong>, <strong class="bold">Medium</strong>, <strong class="bold">Large</strong>, and <strong class="bold">Extra Large</strong>. All these shapes come with default values, which we can always override to use <span class="No-Break">our own.</span></li>
			</ul>
			<p>The good news for us is that from Android Studio Hedgehog onward, we have project templates that come set up with Material 3, which makes things easier for us. Even the project we created in <a href="B19779_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> comes with Material 3 set <span class="No-Break">up already.</span></p>
			<p>Material 3 APIs and their predecessors offer a wide range of components for us to use in our apps. In the next<a id="_idIndexMarker165"/> subsection, we will be looking at some of the <span class="No-Break">common ones.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor059"/>Material components</h2>
			<p>The Material library<a id="_idIndexMarker166"/> comes with prebuilt components that we can use to build common UI components. Let us look at some of the commonly used components and some of the updates they had in <span class="No-Break">Material 3.</span></p>
			<h3>Top app bars</h3>
			<p>This is a <a id="_idIndexMarker167"/>component displayed at the top of the screen. It has a title and can also have some actions that are related to the screen the user is on. Some of the common actions are the settings icon normally at the top right of the screen. In Material 3, we have four types of top app bars: <strong class="bold">center-aligned</strong>, <strong class="bold">small</strong>, <strong class="bold">medium</strong>, and <strong class="bold">large</strong>, as shown in the <span class="No-Break">following figures.</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B19779_04_01.jpg" alt="Figure 4.1 – Small top app bar" width="361" height="64"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Small top app bar</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B19779_04_02.jpg" alt="Figure 4.2 – Center-aligned top app bar" width="361" height="66"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Center-aligned top app bar</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B19779_04_03.jpg" alt="Figure 4.3 – Medium top app bar" width="361" height="107"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Medium top app bar</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B19779_04_04.jpg" alt="Figure 4.4 – Large top app bar" width="361" height="145"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Large top app bar</p>
			<p>As seen in <em class="italic">Figures 4.1</em> to <em class="italic">4.4</em>, all the<a id="_idIndexMarker168"/> top bars have the same width and only differ in height and positioning of the <span class="No-Break">title text.</span></p>
			<p>Let us look at the sample code for one of these top <span class="No-Break">app bars:</span></p>
			<pre class="source-code">
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PacktCenterAlignedTopBar() {
    CenterAlignedTopAppBar(
        title = {
            Text(text = "Packt Publishing")
        }
    )
}</pre>			<p>Here, we have our custom composable and, inside it, we are using the <strong class="source-inline">CenterAlignedTopBar</strong> composable from Material 3 and passing in <strong class="source-inline">Text</strong> to the <strong class="source-inline">title</strong> composable. The other three (<strong class="source-inline">LargeTopAppBar</strong>, <strong class="source-inline">MediumTopAppBar</strong>, and <strong class="source-inline">TopAppBar</strong>) are similar; the only difference is the composable that you will use. Notice that we have the <strong class="source-inline">@OptIn</strong> annotation as these components are <span class="No-Break">still experimental.</span></p>
			<p>Next, let us look at the <span class="No-Break"><strong class="source-inline">FloatingActionButton</strong></span><span class="No-Break"> component.</span></p>
			<h3>FloatingActionButton</h3>
			<p>Most apps use the component to represent a call to action that is frequently used in the app. For example, create a new chat in a chat app. It is normally positioned at the bottom right of the screen or <a id="_idIndexMarker169"/>elsewhere, depending on your use case. This is how we create <span class="No-Break">the component:</span></p>
			<pre class="source-code">
FloatingActionButton(
    onClick = { /*TODO*/ },
    content = {
        Icon(
            imageVector = Icons.Default.Add ,
            contentDescription = "New Chat"
        )
    }
)</pre>			<p>We use the <strong class="source-inline">FloatingActionButton</strong> component from the Material 3 library. We have the <strong class="source-inline">onclick</strong> argument on the composable and, inside the <strong class="source-inline">content</strong> lambda, we pass in an <strong class="source-inline">Icon</strong> composable that has an <em class="italic">add</em> icon. The preview should be <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B19779_04_05.jpg" alt="Figure 4.5 – FloatingActionButton" width="157" height="150"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – FloatingActionButton</p>
			<p>The <strong class="source-inline">FloatingActionButton</strong> component has these sizes: large, normal, and small, and you can use whichever fits<a id="_idIndexMarker170"/> <span class="No-Break">your purpose.</span></p>
			<p>We have another type of <strong class="source-inline">FloatingActionButton</strong> component known as <strong class="source-inline">ExtendedFloatingActionButton</strong>, which looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B19779_04_06.jpg" alt="Figure 4.6 – ExtendedFloatingActionButton" width="350" height="174"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – ExtendedFloatingActionButton</p>
			<p>As seen in the preceding figure, an <strong class="source-inline">ExtendedFloatingActionButton</strong> component allows us to add more items to our FAB. They are wider than the normal <strong class="source-inline">FloatActionButton</strong> components. In this case, we have a <strong class="source-inline">Text</strong> composable with the text <strong class="bold">New Chat</strong> in addition to the icon. You can use it with or without the icon. The implementation for this is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
ExtendedFloatingActionButton(
    onClick = { /*TODO*/ },
    content = {
        Icon(
            imageVector = Icons.Default.Add ,
            contentDescription = "New Chat"
        )
        Text(
            modifier = Modifier.padding(10.dp),
            text = "New Chat"
        )
    }
)</pre>			<p>Here, we used the <strong class="source-inline">ExtendedFloatingActionButton</strong> component and still passed in the same parameters as before. The only difference is that inside the content, we pass in a text since the <strong class="source-inline">content</strong> lambda exposes <strong class="source-inline">RowScope</strong>, which means children composables will be<a id="_idIndexMarker171"/> arranged in <span class="No-Break">a row.</span></p>
			<p>Next, let us look at the bottom app <span class="No-Break">bar components.</span></p>
			<h3>Bottom app bars</h3>
			<p>The bottom app bar components <a id="_idIndexMarker172"/>display navigation items at the bottom of the screen. They are normally useful for apps that have three to five <span class="No-Break">primary destinations.</span></p>
			<p>Let us look at the code for a bottom <span class="No-Break">app bar:</span></p>
			<pre class="source-code">
BottomAppBar(
    actions = {
        Icon(imageVector = Icons.Rounded.Home, contentDescription = "Home Screen")
        Icon(imageVector = Icons.Rounded.ShoppingCart, contentDescription = "Cart Screen")
        Icon(imageVector = Icons.Rounded.AccountCircle, contentDescription = "Account Screen")
    }
)</pre>			<p>We use the <strong class="source-inline">BottomAppBar</strong> component and, inside the <strong class="source-inline">actions</strong> lambda, we pass in three <strong class="source-inline">Icon</strong> composables to represent the items we are supposed to show. This is how the preview of the composable <a id="_idIndexMarker173"/><span class="No-Break">will look:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B19779_04_07.jpg" alt="Figure 4.7 – BottomAppBar" width="534" height="108"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – BottomAppBar</p>
			<p>In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">,7</em>, we can see we have three icons <span class="No-Break">arranged horizontally.</span></p>
			<p>Additionally, in <strong class="source-inline">BottomAppBar</strong>, we can also provision a <strong class="source-inline">FloatingActionButton</strong> component. We are going to use the <strong class="source-inline">FloatingActionButton</strong> component that we used early on. The updated component code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
BottomAppBar(
    actions = {
        Icon(imageVector = Icons.Rounded.Home, contentDescription = "Home Screen")
        Icon(imageVector = Icons.Rounded.ShoppingCart, contentDescription = "Cart Screen")
        Icon(imageVector = Icons.Rounded.AccountCircle, contentDescription = "Account Screen")
    },
    floatingActionButton = {
        PacktFloatingActionButton()
    }
)</pre>			<p>In the preceding code, we have used the <strong class="source-inline">floatingActionButton</strong> parameter and passed in <strong class="source-inline">PacktFloatingActionButton()</strong> that we created earlier. The updated preview will be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B19779_04_08.jpg" alt="Figure 4.8 – BottomAppBar with FloatingActionButton" width="534" height="108"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – BottomAppBar with FloatingActionButton</p>
			<p>As seen in the preceding figure, our <strong class="source-inline">BottomAppBar</strong> now has a nice <strong class="source-inline">FloatingActionButton</strong> to<a id="_idIndexMarker174"/> its right. The FAB is automatically positioned for you to <span class="No-Break">the right.</span></p>
			<p>We have looked at the different components in isolation, but what happens when we want to place them on one screen together? Next, we are going to look at <strong class="source-inline">Scaffold</strong>, which is meant <span class="No-Break">for this.</span></p>
			<h3>Scaffold</h3>
			<p>This is a layout provided by Material Design that helps place all components on your screen in their desired <a id="_idIndexMarker175"/>positions <span class="No-Break">with ease.</span></p>
			<p>Let us look at a sample of <strong class="source-inline">Scaffold</strong> that has a top app bar, a floating action button, text center-aligned on the screen, and a bottom <span class="No-Break">navigation bar:</span></p>
			<pre class="source-code">
Scaffold(
    topBar = {
        PacktSmallTopAppBar()
    },
    bottomBar = {
        PacktBottomNavigationBar()
    },
    floatingActionButton = {
        PacktFloatingActionButton()
    },
    content = { paddingValues -&gt;
      Column(
          modifier = Modifier
              .fillMaxSize()
              .padding(paddingValues)
              .background(Color.Gray.copy(alpha = 0.1f)),
          verticalArrangement = Arrangement.Center,
          horizontalAlignment = Alignment.CenterHorizontally
      ) {
          Text(
              modifier = Modifier.padding(10.dp),
              text = "Mastering Kotlin for Android Development - Chapter 4",
              textAlign = TextAlign.Center
          )
        }
    }
)</pre>			<p>A lot is happening here, so let<a id="_idIndexMarker176"/> us break <span class="No-Break">it down:</span></p>
			<ul>
				<li>The <strong class="source-inline">Scaffold</strong> composable is used to create a layout that implements the Material Design guidelines. It is a container that contains the top bar, bottom bar, floating action button, and <span class="No-Break">the content.</span></li>
				<li>The <strong class="source-inline">topBar</strong> parameter is used to specify the top bar. In this case, we are using the <strong class="source-inline">PacktSmallTopAppBar</strong> composable that we <span class="No-Break">created earlier.</span></li>
				<li>The <strong class="source-inline">bottomBar</strong> parameter is used to specify the bottom bar. In this case, we are using the <span class="No-Break"><strong class="source-inline">PacktBottomNavigationBar</strong></span><span class="No-Break"> composable.</span></li>
				<li>The <strong class="source-inline">floatingActionButton</strong> parameter is used to specify the floating action button. In this case, we are using the <span class="No-Break"><strong class="source-inline">PacktFloatingActionButton</strong></span><span class="No-Break"> composable.</span></li>
				<li>The <strong class="source-inline">content</strong> parameter is used to specify the content of the screen. In this case, we are using a <strong class="source-inline">Column</strong> composable that contains a <strong class="source-inline">Text</strong> composable. The text is centered in the column<a id="_idIndexMarker177"/> using the <strong class="source-inline">verticalArrangement</strong> and <strong class="source-inline">horizontalAlignment</strong> parameters. Notice that inside <strong class="source-inline">Column</strong>, we are using the <strong class="source-inline">paddingValues</strong> parameter to add padding to the column. This is because the <strong class="source-inline">Scaffold</strong> composable passes the <strong class="source-inline">padding</strong> values to the <span class="No-Break"><strong class="source-inline">content</strong></span><span class="No-Break"> parameter.</span></li>
			</ul>
			<p>With our <strong class="source-inline">Scaffold</strong> composable ready, let us see how its <span class="No-Break">preview looks:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B19779_04_09.jpg" alt="Figure 4.9 – Scaffold" width="270" height="576"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Scaffold</p>
			<p>In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.9</em>, we can see that the <strong class="source-inline">Scaffold</strong> composable has added the top bar, bottom bar, and the floating action button to the screen. The components are also placed in the correct positions <a id="_idIndexMarker178"/>as per the Material <span class="No-Break">Design guidelines.</span></p>
			<p>We have learned about a bunch of components so far; Material 3 still offers more components out of the box for us. We will be using some of these components in the upcoming chapters of this book. To view the full list of all the components, go to the Material 3<a id="_idIndexMarker179"/> Components website (https://m3.material.io/components) to see them and <span class="No-Break">their guidelines.</span></p>
			<p>Now that we understand Material 3 and its features, let us look at how to add it to <span class="No-Break">our apps.</span></p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor060"/>Using Material Design in our apps</h1>
			<p>To take advantage of the <a id="_idIndexMarker180"/>Material 3 features that we looked at in the previous section, we need to add it to our app. Luckily, with Android Studio Hedgehog, we have Material 3 templates. Even the sample apps we have been using already use Material 3. So cool, right? Let us quickly scan the dependencies to understand what <span class="No-Break">is happening:</span></p>
			<pre class="source-code">
implementation 'androidx.core:core-ktx:1.10.1'
implementation platform('org.jetbrains.kotlin:kotlin-bom:1.8.0')
implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.6.1'
implementation 'androidx.activity:activity-compose:1.7.2'
implementation platform('androidx.compose:compose-bom:2022.10.00')
implementation 'androidx.compose.ui:ui'
implementation 'androidx.compose.ui:ui-graphics'
implementation 'androidx.compose.ui:ui-tooling-preview'
implementation 'androidx.compose.material3:material3'
testImplementation 'junit:junit:4.13.2'
androidTestImplementation 'androidx.test.ext:junit:1.1.5'
androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
androidTestImplementation platform('androidx.compose:compose-bom:2022.10.00')
androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
debugImplementation 'androidx.compose.ui:ui-tooling'
debugImplementation 'androidx.compose.ui:ui-test-manifest'</pre>			<p>This dependencies block sets up several for us, including the <strong class="source-inline">compose</strong> dependencies. The most important one is the <strong class="source-inline">androidx.compose.material3:material3</strong> dependency. This is the dependency that contains <a id="_idIndexMarker181"/>the Material 3 components. We are using the Compose <strong class="bold">Bill of Materials</strong> (<strong class="bold">BOM</strong>) to manage our dependencies. This means that we do not have to specify the version of each dependency. Instead, we specify the version of the BOM, and it will <a id="_idIndexMarker182"/>manage the versions of the dependencies for us. This is the recommended way of managing dependencies in Compose. That is why we have not specified the version of <span class="No-Break">each dependency.</span></p>
			<p>With that, our project is ready to take advantage of the Material 3 features. In the next subsection, we will be adding more color schemes to <span class="No-Break">the app.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor061"/>Adding Material Design 3 color schemes</h2>
			<p>As mentioned earlier, Material 3<a id="_idIndexMarker183"/> comes with a lot of fine-grained color schemes and introduces <strong class="bold">dynamic color</strong>. However, they<a id="_idIndexMarker184"/> are not set up with the templates that Android Studio generates. We will be setting them up in the next <span class="No-Break">few steps.</span></p>
			<p>Head over to the <strong class="source-inline">ui/theme</strong> package and open the <strong class="source-inline">Color.kt</strong> file, which has the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)
val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)</pre>			<p>So far, this file only has a few colors defined. These colors do not cover all the color tokens provided by Material 3. We will add more colors as we need them in <span class="No-Break">the app.</span></p>
			<p>We will be using the <strong class="bold">Material Theme Builder</strong> tool to generate these colors. Let us open our browser and<a id="_idIndexMarker185"/> go to the Material Theme Builder tool (<a href="https://m3.material.io/theme-builder">https://m3.material.io/theme-builder</a>). We will be presented with the <span class="No-Break">following screen:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B19779_04_10.jpg" alt="Figure 4.10 – Material Theme Builder tool" width="1084" height="743"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Material Theme Builder tool</p>
			<p>This tool helps us visualize the color schemes for our apps and shows how different components will be themed. It<a id="_idIndexMarker186"/> makes it easier for us to customize and produce a consistent color scheme for our app. It has two tabs: <strong class="bold">Dynamic</strong> and <strong class="bold">Custom</strong>. In the <strong class="bold">Dynamic</strong> tab, we can select one of the preloaded colors or wallpapers to see how the color changes. One useful feature is that we can also add your own wallpaper and generate the colors based on <span class="No-Break">the wallpaper.</span></p>
			<p>In the <strong class="bold">Custom</strong> tab, we can select a color and the tool generates all the complementary colors for us based on the color we select, ensuring a harmonious <span class="No-Break">color palette:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B19779_04_11.jpg" alt="Figure 4.11 – Material Theme Builder tool custom color" width="1083" height="743"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Material Theme Builder tool custom color</p>
			<p>On the left, we have the <strong class="bold">Core colors</strong> section<a id="_idIndexMarker187"/> where we can select either <strong class="bold">Primary</strong>, <strong class="bold">Secondary</strong>, <strong class="bold">Tertiary</strong>, or <strong class="bold">Neutral</strong> colors for <span class="No-Break">our app.</span></p>
			<p>We are going to select the <strong class="bold">Primary</strong> color option, which opens a <strong class="bold">Color </strong><span class="No-Break"><strong class="bold">Picker</strong></span><span class="No-Break"> dialog:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B19779_04_12.jpg" alt="Figure 4.12 – Color Picker" width="234" height="474"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Color Picker</p>
			<p>As we are changing the primary color, we will be able to see the visual preview change to match the color we have. Now <a id="_idIndexMarker188"/>we have our primary color ready, we are going to export the files so that we can use them in <span class="No-Break">our project:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B19779_04_13.jpg" alt="Figure 4.13 – Export option" width="1094" height="755"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Export option</p>
			<p>As seen in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.13</em>, the visual preview has changed to the color we chose. Click on the <strong class="bold">Export</strong> option (highlighted in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.13</em>) and, from the dropdown that appears, choose <strong class="bold">Jetpack Compose (Theme.kt)</strong>. This will prompt a download of a zipped file. Unzip the file and open the folder. We<a id="_idIndexMarker189"/> will now have a <strong class="source-inline">ui</strong> folder that has a <strong class="source-inline">theme</strong> folder inside containing <strong class="source-inline">Color.kt</strong> and <span class="No-Break"><strong class="source-inline">Theme.kt</strong></span><span class="No-Break"> files.</span></p>
			<p>Let us open the <strong class="source-inline">Color.kt</strong> file, which contains the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
val md_theme_light_primary = Color(0xFF006C49)
val md_theme_light_onPrimary = Color(0xFFFFFFFF)
val md_theme_light_primaryContainer = Color(0xFF7AFAC0)
val md_theme_light_onPrimaryContainer = Color(0xFF002113)
val md_theme_light_secondary = Color(0xFF4D6357)
val md_theme_light_onSecondary = Color(0xFFFFFFFF)
val md_theme_light_secondaryContainer = Color(0xFFD0E8D8)
val md_theme_light_onSecondaryContainer = Color(0xFF0A1F16)
val md_theme_light_tertiary = Color(0xFF3D6473)
val md_theme_light_onTertiary = Color(0xFFFFFFFF)
val md_theme_light_tertiaryContainer = Color(0xFFC0E9FB)
val md_theme_light_onTertiaryContainer = Color(0xFF001F29)
val md_theme_light_error = Color(0xFFBA1A1A)
val md_theme_light_errorContainer = Color(0xFFFFDAD6)
val md_theme_light_onError = Color(0xFFFFFFFF)
val md_theme_light_onErrorContainer = Color(0xFF410002)
val md_theme_light_background = Color(0xFFFBFDF9)
val md_theme_light_onBackground = Color(0xFF191C1A)
val md_theme_light_surface = Color(0xFFFBFDF9)
val md_theme_light_onSurface = Color(0xFF191C1A)
val md_theme_light_surfaceVariant = Color(0xFFDCE5DD)
val md_theme_light_onSurfaceVariant = Color(0xFF404943)
val md_theme_light_outline = Color(0xFF707973)
val md_theme_light_inverseOnSurface = Color(0xFFEFF1ED)
val md_theme_light_inverseSurface = Color(0xFF2E312F)
val md_theme_light_inversePrimary = Color(0xFF5CDDA5)
val md_theme_light_shadow = Color(0xFF000000)
val md_theme_light_surfaceTint = Color(0xFF006C49)
val md_theme_light_outlineVariant = Color(0xFFC0C9C1)
val md_theme_light_scrim = Color(0xFF000000)
val md_theme_dark_primary = Color(0xFF5CDDA5)
val md_theme_dark_onPrimary = Color(0xFF003824)
val md_theme_dark_primaryContainer = Color(0xFF005236)
val md_theme_dark_onPrimaryContainer = Color(0xFF7AFAC0)
val md_theme_dark_secondary = Color(0xFFB4CCBD)
val md_theme_dark_onSecondary = Color(0xFF20352A)
val md_theme_dark_secondaryContainer = Color(0xFF364B40)
val md_theme_dark_onSecondaryContainer = Color(0xFFD0E8D8)
val md_theme_dark_tertiary = Color(0xFFA5CDDE)
val md_theme_dark_onTertiary = Color(0xFF063543)
val md_theme_dark_tertiaryContainer = Color(0xFF244C5A)
val md_theme_dark_onTertiaryContainer = Color(0xFFC0E9FB)
val md_theme_dark_error = Color(0xFFFFB4AB)
val md_theme_dark_errorContainer = Color(0xFF93000A)
val md_theme_dark_onError = Color(0xFF690005)
val md_theme_dark_onErrorContainer = Color(0xFFFFDAD6)
val md_theme_dark_background = Color(0xFF191C1A)
val md_theme_dark_onBackground = Color(0xFFE1E3DF)
val md_theme_dark_surface = Color(0xFF191C1A)
val md_theme_dark_onSurface = Color(0xFFE1E3DF)
val md_theme_dark_surfaceVariant = Color(0xFF404943)
val md_theme_dark_onSurfaceVariant = Color(0xFFC0C9C1)
val md_theme_dark_outline = Color(0xFF8A938C)
val md_theme_dark_inverseOnSurface = Color(0xFF191C1A)
val md_theme_dark_inverseSurface = Color(0xFFE1E3DF)
val md_theme_dark_inversePrimary = Color(0xFF006C49)
val md_theme_dark_shadow = Color(0xFF000000)
val md_theme_dark_surfaceTint = Color(0xFF5CDDA5)
val md_theme_dark_outlineVariant = Color(0xFF404943)
val md_theme_dark_scrim = Color(0xFF000000)</pre>			<p>As you can now see, we have more color additions. Let us copy these colors to the <strong class="source-inline">Color.kt</strong> file in our project. Next, let us open the <strong class="source-inline">Theme.kt</strong> from the <span class="No-Break">unzipped folder.</span></p>
			<p>We will notice it is similar to the <strong class="source-inline">Theme.kt</strong> file but it defines all the Material 3 color schemes. Copy the contents of this file and paste them into the <strong class="source-inline">Theme.kt</strong> file in our project. We are going to make minor <a id="_idIndexMarker190"/>edits to the code to make sure we maintain the <strong class="source-inline">ChapterFourTheme</strong> name and dynamic color logic that was in our theme. Next, we need to change the <strong class="source-inline">DarkColorScheme</strong> variable values to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
private val DarkColorScheme = darkColorScheme(
    primary = md_theme_light_primary,
    onPrimary = md_theme_light_onPrimary,
    primaryContainer = md_theme_light_primaryContainer,
    onPrimaryContainer = md_theme_light_onPrimaryContainer,
    secondary = md_theme_light_secondary,
    onSecondary = md_theme_light_onSecondary,
    secondaryContainer = md_theme_light_secondaryContainer,
    onSecondaryContainer = md_theme_light_onSecondaryContainer,
    tertiary = md_theme_light_tertiary,
    onTertiary = md_theme_light_onTertiary,
    tertiaryContainer = md_theme_light_tertiaryContainer,
    onTertiaryContainer = md_theme_light_onTertiaryContainer,
    error = md_theme_light_error,
    errorContainer = md_theme_light_errorContainer,
    onError = md_theme_light_onError,
    onErrorContainer = md_theme_light_onErrorContainer,
    background = md_theme_light_background,
    onBackground = md_theme_light_onBackground,
    surface = md_theme_light_surface,
    onSurface = md_theme_light_onSurface,
    surfaceVariant = md_theme_light_surfaceVariant,
    onSurfaceVariant = md_theme_light_onSurfaceVariant,
    outline = md_theme_light_outline,
    inverseOnSurface = md_theme_light_inverseOnSurface,
    inverseSurface = md_theme_light_inverseSurface,
    inversePrimary = md_theme_light_inversePrimary,
    surfaceTint = md_theme_light_surfaceTint,
    outlineVariant = md_theme_light_outlineVariant,
    scrim = md_theme_light_scrim,
)</pre>			<p>In the preceding code, we are using the <strong class="source-inline">DarkColorScheme</strong> function to create a dark color scheme. We are passing the colors that we generated using the Material Theme Builder tool. We will use this <a id="_idIndexMarker191"/>color scheme to create a dark theme. The dark color scheme variable is defined in a similar manner, and we can copy the values from the <strong class="source-inline">Theme.kt</strong> file from the tool and add it there too. Let us now look at our theme composable <span class="No-Break">in wholesome:</span></p>
			<pre class="source-code">
@Composable
fun ChapterFourTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -&gt; Unit
) {
    val colorScheme = when {
        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -&gt; DarkColorScheme
        else -&gt; LightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme
        }
    }
    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}</pre>			<p>Let us break down the <a id="_idIndexMarker192"/><span class="No-Break">preceding code:</span></p>
			<ul>
				<li>The <strong class="source-inline">ChapterFourTheme</strong> composable is used to create a theme for our app. It takes <span class="No-Break">three parameters:</span><ul><li>The <strong class="source-inline">darkTheme</strong> parameter is used to specify whether the theme is dark or light. By default, we are using the <span class="No-Break">system theme.</span></li><li>The <strong class="source-inline">dynamicColor</strong> parameter is used to specify whether the theme should use dynamic colors. By default, we are using <span class="No-Break">dynamic colors.</span></li><li>The <strong class="source-inline">content</strong> parameter is used to specify the content of the theme. In this case, we are using the <strong class="source-inline">MaterialTheme</strong> composable to create a theme for <span class="No-Break">our app.</span></li></ul></li>
				<li>The <strong class="source-inline">colorScheme</strong> variable is used to specify the color scheme to use. We are using a <strong class="source-inline">when</strong> expression to determine the color scheme to use. If the <strong class="source-inline">dynamicColor</strong> parameter is <strong class="source-inline">true</strong> and the device is running Android 12 or higher, we are using the <strong class="source-inline">dynamicDarkColorScheme</strong> or <strong class="source-inline">dynamicLightColorScheme</strong> function to create a dynamic color scheme. When not using dynamic colors, we fall back to the normal themes. If the <strong class="source-inline">darkTheme</strong> parameter is <strong class="source-inline">true</strong>, we are using the <strong class="source-inline">DarkColorScheme</strong> variable to create a dark color scheme. Otherwise, we are using the <strong class="source-inline">LightColorScheme</strong> variable to create a light <span class="No-Break">color scheme.</span></li>
				<li>The <strong class="source-inline">view</strong> variable is used to get the view that is using <span class="No-Break">the theme.</span></li>
				<li>The <strong class="source-inline">SideEffect</strong> composable is used to execute a side effect. In this case, we are using it to set the status bar color and the status bar icons’ color. We are using the <strong class="source-inline">WindowCompat</strong> class to get <strong class="source-inline">InsetsController</strong> and set the status bar color and the status bar icons’ color. We are using the <strong class="source-inline">colorScheme.primary</strong> color to set the status bar color. We are using the <strong class="source-inline">darkTheme</strong> parameter to determine whether the status bar icons’ color should be light <span class="No-Break">or dark.</span></li>
				<li>The <strong class="source-inline">MaterialTheme</strong> composable is used to create a theme for our app. We are using the <strong class="source-inline">colorScheme</strong> parameter to specify the color scheme to use. We are using the <strong class="source-inline">typography</strong> variable to specify the typography <span class="No-Break">to use.</span></li>
			</ul>
			<p>To be able to see the changes<a id="_idIndexMarker193"/> we have made, we need to call <strong class="source-inline">PacktScaffold</strong>, which we created earlier inside the <strong class="source-inline">MainActivity.kt</strong> file in the <span class="No-Break"><strong class="source-inline">ChapterFourTheme</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ChapterFourTheme {
                PacktScaffold()
            }
        }
    }
}</pre>			<p>Let us build and run the app. We should be able to see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B19779_04_14.jpg" alt="Figure 4.14 – Chapter 4 app" width="493" height="1035"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Chapter 4 app</p>
			<p>Like me, you might be wondering why<a id="_idIndexMarker194"/> the app does not have the greenish color we set on the Material Theme Builder tool. Remember the dynamic color logic in our <strong class="source-inline">ChapterFourTheme</strong> composable? It is responsible for the brownish color we see. Look at my <span class="No-Break">wallpaper settings:</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B19779_04_15.jpg" alt="Figure 4.15 – Wallpaper settings" width="489" height="1026"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Wallpaper settings</p>
			<p>As seen in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.15</em>, my wallpaper has a brown color set. This means our dynamic color logic is working, and our app can adapt well to my <span class="No-Break">wallpaper settings!</span></p>
			<p>We have seen how to use the <a id="_idIndexMarker195"/>Material 3 features in our app. In the next section, we will see how we can design UIs that work for large screens and foldables in <span class="No-Break">Jetpack Compose.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor062"/>Designing UIs for large screens and foldables</h1>
			<p>In recent years and with the release of Material 3, there has been an increased focus on tablets and foldable devices. As such, we, as developers, must make our apps work well on these devices. In this<a id="_idIndexMarker196"/> section, we will look at how we can make our apps work well on large screens and foldables. We need to ensure our apps adapt to the different screen sizes. Making our apps responsive provides a good <span class="No-Break">user experience.</span></p>
			<p>Material 3 offers <strong class="bold">canonical layouts</strong> to serve as<a id="_idIndexMarker197"/> guidelines for creating UIs for large screens and foldables. These layouts are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">List-detail view</strong>: Here, we place a list of items on the left and, on the right, we show the details of a <span class="No-Break">single item.</span></li>
				<li><strong class="bold">Feed</strong>: Here, we arrange content elements such as cards in a customizable grid, which provides a good view of a large amount <span class="No-Break">of content.</span></li>
				<li><strong class="bold">Supporting pane</strong>: Here, we organize app content into primary and secondary display areas. The primary area shows the main content while the secondary area shows the supporting content. The primary area occupies most of the screen while the secondary area occupies a <span class="No-Break">smaller portion.</span></li>
			</ul>
			<p>For us to show the different layouts, we must know the screen size of the device the user is using. Luckily for us, Jetpack Compose provides us with a way to get the screen size. We have the Material 3 <strong class="bold">WindowSizeClass</strong> to help us determine which layout to show in <span class="No-Break">our app.</span></p>
			<p>We are going to learn how to use <span class="No-Break"><strong class="source-inline">WindowSizeClass</strong></span><span class="No-Break"> next.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor063"/>Using WindowSizeClass</h2>
			<p>For us to use <strong class="source-inline">WindowSizeClass</strong>, we <a id="_idIndexMarker198"/>must add the following dependency to <span class="No-Break">our app:</span></p>
			<pre class="source-code">
implementation 'androidx.compose.material3:material3-window-size-class'</pre>			<p>This is the Material 3 dependency that adds <strong class="source-inline">WindowSizeClass</strong> to our project. Notice we are not providing a version for this dependency. This is because we are using the Compose BOM to manage our dependencies. The BOM will manage the version of this dependency <span class="No-Break">for us.</span></p>
			<p><strong class="source-inline">WindowSizeClass</strong> classifies the available screen width into <span class="No-Break">three categories:</span></p>
			<ul>
				<li><strong class="source-inline">Compact</strong>: This is for devices whose width is less than 600 dp. Commonly, these are devices in <span class="No-Break">portrait mode.</span></li>
				<li><strong class="source-inline">Medium</strong>: This is for devices whose width is between 600 dp and 840 dp. Devices such as tablets and foldables in portrait mode fall into <span class="No-Break">this category.</span></li>
				<li><strong class="source-inline">Expanded</strong>: This is for devices whose width is greater than 840 dp. Devices such as tablets and foldables in<a id="_idIndexMarker199"/> landscape mode, phones in landscape mode, and desktops fall into <span class="No-Break">this category.</span></li>
			</ul>
			<p><strong class="source-inline">WindowSizeClass</strong> uses <strong class="source-inline">widthSizeClass</strong> to get the width of the screen. In addition to <strong class="source-inline">widthSizeClass</strong>, it also has <strong class="source-inline">heightSizeClass</strong> to help us determine the height of <span class="No-Break">the screen.</span></p>
			<p>Let us look at <strong class="source-inline">widthSizeClass</strong> <span class="No-Break">in action:</span></p>
			<pre class="source-code">
when(calculateWindowSizeClass(activity = this).widthSizeClass) {
    WindowWidthSizeClass.Compact -&gt; {
        CharactersScreen(
            navigationOptions = NavigationOptions.BottomNavigation,
            showDetails = false
        )
    }
    WindowWidthSizeClass.Medium -&gt; {
        CharactersScreen(
            navigationOptions = NavigationOptions.NavigationRail,
            showDetails = true
        )
    }
    WindowWidthSizeClass.Expanded -&gt; {
        CharactersScreen(
            navigationOptions = NavigationOptions.NavigationDrawer,
            showDetails = true
        )
    }
    else -&gt; {
        CharactersScreen(
            navigationOptions = NavigationOptions.BottomNavigation,
            showDetails = false
        )
    }
}</pre>			<p>Here is an explanation of what the preceding code <span class="No-Break">is doing:</span></p>
			<ul>
				<li>The <strong class="source-inline">calculateWindowSizeClass</strong> function is used to calculate <strong class="source-inline">WindowSizeClass</strong>. We are passing the activity as the parameter. The function is from the <strong class="source-inline">WindowSizeClass</strong> APIs. It has the <strong class="source-inline">widthSizeClass</strong> and <strong class="source-inline">heightSizeClass</strong> properties, which<a id="_idIndexMarker200"/> we can use to get the width and height of the <span class="No-Break">screen, respectively.</span></li>
				<li>We use <strong class="source-inline">widthSizeClass</strong> to customize our <span class="No-Break">display options:</span><ul><li>For the <strong class="source-inline">WindowWidthSizeClass.Compact</strong> case, we are using <strong class="source-inline">BottomNavigation</strong> for navigation, and the UI should only show the list <span class="No-Break">of characters</span></li><li>For the <strong class="source-inline">WindowWidthSizeClass.Medium</strong> case, we are using <strong class="source-inline">NavigationRail</strong> for navigation, and the UI should show the list of characters and the details of the <span class="No-Break">selected character</span></li><li>For the <strong class="source-inline">WindowWidthSizeClass.Expanded</strong> case, we are using <strong class="source-inline">NavigationDrawer</strong> for navigation. and the UI should show the list of characters and the details of the <span class="No-Break">selected character</span></li><li>We have a default case where we are using <strong class="source-inline">BottomNavigation</strong> for navigation, and the UI<a id="_idIndexMarker201"/> should only show the list <span class="No-Break">of characters</span></li></ul></li>
			</ul>
			<p>At a glance, you can see how we take advantage of <strong class="source-inline">WindowSizeClass</strong> to customize our UI and navigation type based on the screen size. This is an immensely powerful feature that we can use to make our apps responsive. This makes sure we take advantage of the screen size and provide a good <span class="No-Break">user experience.</span></p>
			<p>The example shown in this section was a simple one. In <a href="B19779_07.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> of this book, we will have a more detailed example where we will use <strong class="source-inline">WindowSizeClass</strong> to customize our UI based on the <span class="No-Break">screen size.</span></p>
			<p>Now that we know how to design and build apps for large screens and foldables, let us look at yet another important topic in this chapter, which <span class="No-Break">is accessibility.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor064"/>Making our app accessible</h1>
			<p>Making the apps that we develop accessible is extremely important. It ensures that our apps can be used by everyone. In this section, we will look at how we can make our apps accessible. Jetpack Compose <a id="_idIndexMarker202"/>uses <strong class="bold">semantics</strong> to make our apps accessible. Semantics are used to describe the UI elements in our apps. They are used by accessibility services to make our apps accessible. Semantics are<a id="_idIndexMarker203"/> also used by automated testing tools to test our apps. Some of the best practices for making our apps accessible are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>We should always ensure that all clickable or touchable elements or those that require user interaction are large enough to be easily tapped or clicked. Most Material components out of the box have a default size that is large enough to be easily tapped or clicked. If we must size by ourselves, we should ensure that the size is at least 48 dp by <span class="No-Break">48 dp.</span></li>
				<li>We should add content descriptions to our composables. Components such as <strong class="source-inline">Icon</strong> and <strong class="source-inline">Image</strong> provide this argument to describe visual elements to accessibility services. We <a id="_idIndexMarker204"/>should always provide a content description for these components. The following is <span class="No-Break">an example:</span><pre class="source-code">
Icon(
    modifier = Modifier.size(48.dp),
    painter = painterResource(id = R.drawable.ic_launcher_foreground),
    contentDescription = "Icon"
)</pre><p class="list-inset">You can see in the preceding code that we are using the <strong class="source-inline">contentDescription</strong> parameter to provide a description for <strong class="source-inline">Icon</strong>. This is a good practice that we should <span class="No-Break">always follow.</span></p></li>				<li>We should label our clickable elements. We can pass a clickable label to the clickable modifiers. This enables us to add descriptions to our clickable elements. The following is <span class="No-Break">an example:</span><pre class="source-code">
Text(
    modifier = Modifier
        .clickable(
            onClick = { /*TODO*/ },
            onClickLabel = "Click Me"
        )
        .padding(10.dp),
    text = "Click Me"
)</pre><p class="list-inset">In the preceding example, we are using the <strong class="source-inline">onClickLabel</strong> parameter to add a description to the <strong class="source-inline">Text</strong> composable. This is a good practice that we should <span class="No-Break">always follow.</span></p></li>				<li>By using semantics, we can also describe headers. Headers are used to describe the content that follows <a id="_idIndexMarker205"/>them. We can use semantics to add a header to our composables. The following is <span class="No-Break">an example:</span><pre class="source-code">
Text(
    modifier = Modifier
        .semantics { heading() }
        .padding(10.dp),
    text = "Heading One"
)</pre></li>				<li>We can additionally provide information about the state of our composables. For example, we can provide information about the state of a button. We can use semantics to provide this information. The following is <span class="No-Break">an example:</span><pre class="source-code">
Button(
    modifier = Modifier
        .semantics { stateDescription = "Disabled" }
        .padding(10.dp),
    onClick = { /*TODO*/ },
    enabled = false
) {
    Text(text = "Disabled Button")
}</pre><p class="list-inset">This helps us inform our users about the state of <span class="No-Break">our composables.</span></p></li>				<li>For some groups of components, we can also use the <strong class="source-inline">mergeDescendants</strong> parameter to merge<a id="_idIndexMarker206"/> the semantics of the children composables. The following is <span class="No-Break">an example:</span><pre class="source-code">
Column(
    modifier = Modifier
        .padding(10.dp)
        .semantics(mergeDescendants = true) { }
) {
    Text(text = "Heading One")
    Text(text = "Heading Two")
    Text(text = "Heading Three")
}</pre><p class="list-inset">Merging descendants is useful when we want to provide a description for a group of composables. In the preceding example, we are using the <strong class="source-inline">mergeDescendants</strong> parameter to merge the semantics of the <strong class="source-inline">Text</strong> composables. However, we should be careful when using this parameter. We should only use it when we want to provide a description for a group of composables. If we use it for a large group of composables, it can lead to performance issues and can also be confusing for <span class="No-Break">the users.</span></p></li>			</ul>
			<p>To learn more about accessibility in Jetpack Compose, visit the official <span class="No-Break">documentation (</span><a href="https://developer.android.com/jetpack/compose/accessibility"><span class="No-Break">https://developer.android.com/jetpack/compose/accessibility</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor065"/>Summary</h1>
			<p>In this chapter, we introduced Material 3. We also covered the features that Material 3 offers. We saw how to use Material 3 in our apps. Additionally, we covered how to design and develop our apps for large screens and, finally, we saw how to make our Jetpack Compose <span class="No-Break">UIs accessible.</span></p>
			<p>In the next chapter, we will continue building upon the skills that we’ve gained from the previous chapters. We will be looking at how to architect our app and the different architectures available. We will learn how to use Jetpack libraries in our apps and how to tackle <span class="No-Break">dependency injection.</span></p>
		</div>
	</div></div>
<div id="book-content"><div id="sbo-rt-content"><div id="_idContainer068" class="Content">
			<h1 id="_idParaDest-60" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor066"/>Part 2: Using Advanced Features</h1>
			<p>Building upon the foundational knowledge gained in <em class="italic">Part 1</em>, this part propels you into advanced concepts, providing a deeper understanding of Android development. Delving into diverse architectures, the focus shifts toward mastering the MVVM architecture for your applications. Furthermore, you will unravel the intricacies of making network calls by incorporating the Retrofit networking library. Taking it a step further, you will harness the power of Kotlin coroutines to seamlessly execute asynchronous network requests. Your navigational prowess will be honed using the Jetpack Navigation library, exploring techniques for efficient navigation on large screens and foldable devices. The journey continues with insights into handling long-running tasks in the background and leveraging Room for local data storage. Wrapping up, we will demystify runtime permissions, and you will comprehend their significance and master the art of requesting permissions dynamically within <span class="No-Break">your app.</span></p>
			<p>This section contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19779_05.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Architect Your App</em></li>
				<li><a href="B19779_06.xhtml#_idTextAnchor084"><em class="italic">Chapter 6</em></a>, <em class="italic">Network Calls with Kotlin Coroutines</em></li>
				<li><a href="B19779_07.xhtml#_idTextAnchor092"><em class="italic">Chapter 7</em></a>, <em class="italic">Navigating within Your App</em></li>
				<li><a href="B19779_08.xhtml#_idTextAnchor101"><em class="italic">Chapter 8</em></a>, <em class="italic">Persisting Data Locally and Doing Background Work</em></li>
				<li><a href="B19779_09.xhtml#_idTextAnchor112"><em class="italic">Chapter 9</em></a>, <em class="italic">Runtime Permissions</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer069">
			</div>
		</div>
		<div>
			<div id="_idContainer070">
			</div>
		</div>
		<div>
			<div id="_idContainer071">
			</div>
		</div>
		<div>
			<div id="_idContainer072">
			</div>
		</div>
		<div>
			<div id="_idContainer073">
			</div>
		</div>
		<div>
			<div id="_idContainer074" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer075" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer076">
			</div>
		</div>
		<div>
			<div id="_idContainer077">
			</div>
		</div>
		<div>
			<div id="_idContainer078" class="Basic-Graphics-Frame">
			</div>
		</div>
	</div></div></body></html>