<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Testing on Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Testing on Android</h1></div></div></div><p>Now that we have introduced the reasons and the basic concepts behind testing, it's time to put them into practice.</p><p>In this second chapter, we are covering:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Testing on Android</li><li class="listitem" style="list-style-type: disc">Unit testing and JUnit</li><li class="listitem" style="list-style-type: disc">Creating an Android Test project</li><li class="listitem" style="list-style-type: disc">Running tests</li></ul></div><p>We will be creating a simple Android<span class="strong"><strong> main</strong></span> project and its companion<span class="strong"><strong> test</strong></span> project. The main project will be almost empty and will just highlight testing components.<a class="indexterm" id="id59"/>
</p><p>From my personal experience, I suggest that this chapter is useful for new developers with no Android Testing experience. If you have some experience with Android Projects and have been using testing techniques for them, you might read this chapter as a revision or reaffirmation of the concepts.</p><p>Though not mandatory, best practices dictate that tests should live in a separate correlated project. This feature is now supported by the Android ADP plugin, but this has not always been the case. Some time ago I published an article (<a class="ulink" href="http://dtmilano.blogspot.com/2008/11/android-testing-on-android-platf.html">http://dtmilano.blogspot.com/2008/11/android-testing-on-android-platf.html</a>) describing a method for manually maintaining two correlated projects—a main project and a test project.</p><p>The advantages of this decision may not be immediately evident, but among them we can count:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Testing code is easily stripped out from a production build as it is not included in the main project and thus not in the APK</li><li class="listitem" style="list-style-type: disc">Ease the way of running the tests in the emulator through the Instrumentation option in Dev Tools</li><li class="listitem" style="list-style-type: disc">With large projects, deploying the main package and the tests takes less time if they are separated</li><li class="listitem" style="list-style-type: disc">Encourages code reusability in similar projects</li></ul></div><div class="section" title="JUnit"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec01"/>JUnit</h1></div></div></div><p>We had an overview of JUnit in the previous chapter, so no introduction is needed here. It is worth mentioning that the JUnit testing framework is the default option for Android testing projects and it is supported by Eclipse, the Android ADT plugin, and by Ant as well, in case you are not developing with an IDE.<a class="indexterm" id="id60"/>
</p><p>So you are free to choose the best alternative for every case.</p><p>Most of the following examples will be based on Eclipse because is the most common option. So, let's open Eclipse and start with no preamble.</p></div></div>
<div class="section" title="Creating the Android main project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec02"/>Creating the Android main project</h1></div></div></div><p>We will create a new Android project. This is done from Eclipse menu<span class="strong"><strong> File</strong></span> |<span class="strong"><strong> New</strong></span> |<span class="strong"><strong> Project..</strong></span>. |<span class="strong"><strong> Android</strong></span> |<span class="strong"><strong> Android Project</strong></span>.<a class="indexterm" id="id61"/>
</p><p>In this particular case, we are using the following values for the required component names:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Project name:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>MyFirstProject</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Build Target:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Android 2.3.1</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Application name:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>My First Project</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Package name:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>com.example.aatg.myfirstproject</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Create Activity:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>MyFirstProjectActivity</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Min SDK Version:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>9</strong></span>
</p>
</td></tr></tbody></table></div><p>This is what your project creation dialog will look like after entering these values:</p><div class="mediaobject"><img alt="Creating the Android main project" src="graphics/3500_02_01.jpg"/></div></div>
<div class="section" title="Creating the Android test project"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Creating the Android test project</h1></div></div></div><p>Press the<span class="strong"><strong> Next</strong></span> button and the Android Test Project creation dialog will be displayed. Note that some values have been already picked according to the corresponding values selected in the main project.<a class="indexterm" id="id62"/>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note03"/>Note</h3><p>Alternatively, to create a Test project for an existing Android project you can select the main project and then<span class="strong"><strong> Android Tools | Create Test Project</strong></span>. Under<span class="emphasis"><em> Test Target</em></span> select the name of the existing project and the required values will be filled in automatically.</p></div><p>This image shows the Android Test Project creation dialog after entering the corresponding values. All the values have been already entered for us and we should only have to click<span class="strong"><strong> Finish:</strong></span>
</p><div class="mediaobject"><img alt="Creating the Android test project" src="graphics/3500_02_02.jpg"/></div></div>
<div class="section" title="Package explorer"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec04"/>Package explorer</h1></div></div></div><p>After having created both projects, our Package explorer should look like the next image. We can note the existence of the two correlated projects, each with an independent set of components and project properties.<a class="indexterm" id="id63"/>
</p><div class="mediaobject"><img alt="Package explorer" src="graphics/3500_02_03.jpg"/></div><p>Now that we have the basic infrastructure set up, it's time for us to start adding some tests.</p><p>There's nothing to test right now, but as we are setting up the fundamentals of Test Driven Development discipline we are adding a dummy test just to get acquainted with the technique.<a class="indexterm" id="id64"/>
</p><p>The<code class="literal"> src</code> folder on<code class="literal"> MyFirstProjectTest</code> project is the perfect place to add the tests. It is not mandatory but a good practice. The package should be the same as the corresponding package of the component being tested.<a class="indexterm" id="id65"/>
</p><p>Right now, we are not concentrating on the tests but on the concepts and placement of those tests.</p></div>
<div class="section" title="Creating a test case"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec05"/>Creating a test case</h1></div></div></div><p>As described before, we are creating our test cases in the<code class="literal"> src</code> folder of the Test project.<a class="indexterm" id="id66"/>
</p><p>In this particular case, we are creating a unit test using JUnit TestCase. Eclipse provides a wizard to help us <span class="strong"><strong>(File | New... | Junit Test Case)</strong></span>.</p><p>We are selecting the main project's Activity as the class under test; however this is not relevant in this example.</p><p>These are the values that we should enter when we create the test case:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Junit:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Junit 3</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Source folder:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>MyFirstProjectTest/src</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Package:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>com.example.aatg.myfirstproject.test</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Name:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>MyFirstProjectTests</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Superclass:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>junit.framework.TestCase</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Which method stubs would you like to create?</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>setUp(), tearDown(), constructor</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Class under test:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>com.example.aatg.myfirstproject.MyFirstProjectActivity</strong></span>
</p>
</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note04"/>Note</h3><p>Strictly speaking we could have left the<span class="strong"><strong> setUp(), tearDown()</strong></span>, and<span class="strong"><strong> constructor</strong></span> options unselected and this basic test we are creating would not be affected, but here we are describing the most general practices and we will find in many real life scenarios that these methods are needed.</p></div><p>After entering all the required values our JUnit test case creation dialog would look like this:<a class="indexterm" id="id67"/>
</p><div class="mediaobject"><img alt="Creating a test case" src="graphics/3500_02_04.jpg"/></div><p>The basic infrastructure for our tests is in place; what is left is adding a dummy test to verify that everything is working as expected.</p><p>Eclipse also provides a way of creating stubs for the test methods. After pressing<span class="strong"><strong> Next &gt;</strong></span> the following dialog is presented where you can choose the methods under tests you want to generate the stubs for:</p><div class="mediaobject"><img alt="Creating a test case" src="graphics/3500_02_05.jpg"/></div><p>These stub methods may be useful in some cases but you have to consider that testing should be behavior driven rather than method driven.</p><p>We now have a test case template, so the next step is to start completing it to suit our needs. To do it, open the recently created case class and add the test<code class="literal"> testSomething()</code>. As a best practice, add the tests at the end of the class.<a class="indexterm" id="id68"/>
</p><p>We should have something like this:</p><div class="informalexample"><pre class="programlisting">/**
*
*/
package com.example.aatg.myfirstproject.test;
import android.test.suitebuilder.annotation.SmallTest;
import junit.framework.TestCase;
/**
* @author diego
*
*/
public class MyFirstProjectTests extends TestCase {<span class="strong"><strong>
public MyFirstProjectTests() {
this("MyFirstProjectTests");
}</strong></span>
/**
* @param name
*/
public MyFirstProjectTests(String name) {
super(name);
}
/* (non-Javadoc)
* @see junit.framework.TestCase#setUp()
*/
protected void setUp() throws Exception {
super.setUp();
}
/* (non-Javadoc)
* @see junit.framework.TestCase#tearDown()
*/
protected void tearDown() throws Exception {
super.tearDown();
}<span class="strong"><strong>
@SmallTest
public void testSomething() {
fail("Not implemented yet");
}</strong></span>
}
</pre></div><p>This test will always fail, presenting the message:<span class="strong"><strong> Not implemented yet</strong></span>. In order to do this we are using the<code class="literal"> fail</code> method from the<code class="literal"> junit.framework.Assert</code> class that fails the test with the given message.<a class="indexterm" id="id69"/>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note05"/>Note</h3><p>The no-argument constructor is needed to run a specific test from the command line as explained later using<code class="literal"> am instrumentation</code>.</p></div><div class="section" title="Special methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec01"/>Special methods</h2></div></div></div><p>The following table describes the special methods found in our test case class:<a class="indexterm" id="id70"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">setUp</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets up the fixture. For example, opens a network connection or creates global objects that may be needed by the tests. This method is called before a test is executed.</p>
<p>In this case we are only invoking the super method.</p>
<p>See<a class="link" href="ch01.html" title="Chapter 1. Getting Started with Testing"> Chapter 1</a>,<span class="emphasis"><em> Getting Started with Testing</em></span> for details.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">tearDown</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tears down the fixture. For example, close a network connection. This method is called after a test is executed.</p>
<p>In this case we are only invoking the super method.</p>
<p>See<a class="link" href="ch01.html" title="Chapter 1. Getting Started with Testing"> Chapter 1</a>,<span class="emphasis"><em> Getting Started with Testing</em></span> for details.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">testSomething</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A simple test. In order to be discovered by JUnit 3 using reflection, test methods should start with the word<code class="literal"> test</code>.</p>
<p>The rest of the method name should clearly identify the feature under test.</p>
</td></tr></tbody></table></div></div><div class="section" title="Test annotations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec02"/>Test annotations</h2></div></div></div><p>Looking carefully at the test definition you may find that we decorated the test using<code class="literal"> @MediumTest</code> annotation. This is a way to organize or categorize our tests and run them separately.<a class="indexterm" id="id71"/>
</p><p>There are other annotations that can be used by the tests, such as:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@SmallTest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Marks a test that should run as part of the small tests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@MediumTest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Marks a test that should run as part of the medium tests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@LargeTest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Marks a test that should run as part of the large tests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Smoke</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Marks a test that should run as part of the smoke tests. The<code class="literal"> android.test.suitebuilder.SmokeTestSuiteBuilder</code> will run all tests with this annotation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@FlakyTest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Use this annotation on<code class="literal"> InstrumentationTestCase</code> class' test methods. When this is present, the test method is re-executed if the test fails. The total number of executions is specified by the tolerance and defaults to 1. This is useful for tests that may fail due to an external condition that could vary with time.</p>
<p>For example, to specify a tolerance of 4, you would annotate your test with:<code class="literal"> @FlakyTest(tolerance=4)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@UIThreadTest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Use this annotation on<code class="literal"> InstrumentationTestCase</code> class' test methods. When this is present, the test method is executed on the application's main thread (or UI thread).</p>
<p>Because instrumentation methods may not be used when this annotation is present there are other techniques if, for example, you need to modify the UI and get access to the instrumentation within the same test.</p>
<p>In those cases you can resort to the<code class="literal"> Activity.runOnUIThread</code> method allowing to create any<code class="literal"> Runnable</code> and run it in the UI thread from within your test.</p>
<p>
</p><div class="informalexample"><pre class="programlisting">
mActivity.runOnUIThread(new Runnable() {
public void run() {
// do somethings
}
});
</pre></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Suppress</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Use this annotation on test classes or test methods that should not be included in a test suite.</p>
<p>This annotation can be used at the class level, where none of the methods in that class are included in the test suite, or at the method level to exclude just a single method or set of methods.</p>
</td></tr></tbody></table></div><p>Now that we have the tests in place, it's time to run them, and that's what we are going to do next.</p></div></div>
<div class="section" title="Running the tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec06"/>Running the tests</h1></div></div></div><p>There are several ways of running our tests, and we will analyze them here.<a class="indexterm" id="id72"/>
</p><p>Additionally, as was mentioned in the previous section about annotations, tests can be grouped or categorized and run together, depending on the situation.</p><div class="section" title="Running all tests from Eclipse"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec03"/>Running all tests from Eclipse</h2></div></div></div><p>This is perhaps the simplest method if you have adopted Eclipse as your development environment. This will run all the tests in the package.<a class="indexterm" id="id73"/>
</p><p>Select the test project and then<span class="strong"><strong> Run As | Android Junit Test</strong></span>.</p><p>If a suitable device or emulator is not found, one will be started automatically.</p><p>Then the tests are run and the results presented inside the Eclipse DDMS perspective, which you may need to change to manually.</p><div class="mediaobject"><img alt="Running all tests from Eclipse" src="graphics/3500_02_06.jpg"/></div><p>A more detailed view of the results and the messages produced during their execution can also be obtained in the LogCat view within the Eclipse DDMS perspective:</p><div class="mediaobject"><img alt="Running all tests from Eclipse" src="graphics/3500_02_07.jpg"/></div></div><div class="section" title="Running a single test case from Eclipse"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec04"/>Running a single test case from Eclipse</h2></div></div></div><p>There is an option to run a single test case from Eclipse, should you need to.<a class="indexterm" id="id74"/>
</p><p>Select the test project and then<span class="strong"><strong> Run As | Run Configurations</strong></span>.</p><p>Then create a new configuration and under<span class="emphasis"><em> Test</em></span>, use the following values:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Run a single test:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>checked</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Project:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>MyFirstProjectTest</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Test class:</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>com.example.aatg.myfirstproject.test.MyFirstProjectTests</strong></span>
</p>
</td></tr></tbody></table></div><p>When you run as usual, only this test will be executed. In our case, we have only one test, so the result will be similar to the screenshot presented earlier.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;" title="Tip"><h3 class="title"><a id="tip03"/>Tip</h3><p>There is a shortcut for this that you can use from within the Eclipse editor. Selecting the method name you can press<span class="emphasis"><em> Shift+Alt+X T</em></span> or right-click on it and then choosing<span class="strong"><strong> Run As | JUnit Test</strong></span>.</p></div></div><div class="section" title="Running from the emulator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec05"/>Running from the emulator</h2></div></div></div><p>The default system image used by the emulator has the<span class="emphasis"><em> Dev Tools</em></span> application installed, providing several handy tools and settings. Among these tools, we can find a rather long list as is shown in this screenshot:<a class="indexterm" id="id75"/>
</p><div class="mediaobject"><img alt="Running from the emulator" src="graphics/3500_02_08.jpg"/></div><p>We are interested in<span class="strong"><strong> Instrumentation</strong></span> now, which is the way to run our tests. This application lists all of the packages installed that define the<code class="literal"> instrumentation</code> tag in their<code class="literal"> AndroidManifest.xml</code>. By default, packages are listed using the default instrumentation which normally is<code class="literal"> android.test.InstrumentationTestRunner</code> which is a problem to identify if you have more than one package list. To solve this problem you can set an optional label in the manifest, under the Instrumentation tab, as shown here:<a class="indexterm" id="id76"/>
</p><div class="mediaobject"><img alt="Running from the emulator" src="graphics/3500_02_09.jpg"/></div><p>Once this is done and the Instrumentation list is re-displayed, our package will be listed under this new label and we can run the tests by selecting it:</p><div class="mediaobject"><img alt="Running from the emulator" src="graphics/3500_02_10.jpg"/></div><p>When the tests are run in this way, the results can be seen through<span class="strong"><strong> LogCat</strong></span> as described in the previous section.<a class="indexterm" id="id77"/>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note06"/>Note</h3><p>You can see how, as mentioned previously, if you don't set the optional Label more than one instrumentation appears under the same default label<code class="literal"> android.test.InstrumentationTestRunner</code>.</p></div></div><div class="section" title="Running tests from the command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec06"/>Running tests from the command line</h2></div></div></div><p>Finally, tests can be run from the command line too. This is useful if you want to automate or script the process.<a class="indexterm" id="id78"/>
</p><p>To run the tests we are using the<code class="literal"> am instrument</code> command (strictly speaking the<code class="literal"> am</code> command and<code class="literal"> instrument</code> subcommand) which allows us to run instrumentations specifying the package name and some other options.</p><p>You may wonder what<code class="literal"> am</code> stands for. It is short for<span class="strong"><strong> Activity Manager</strong></span>, a main component of the internal Android infrastructure that is started by the<span class="strong"><strong> System Server</strong></span> at the beginning of the boot process and is responsible for managing Activities and their life cycle. Additionally, as we can see here, it is also responsible for Activity instrumentation.</p><p>The general usage of the<code class="literal"> am instrument</code> command is:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>am instrument [flags] &lt;COMPONENT&gt;
-r: print raw results (otherwise decode REPORT_KEY_STREAMRESULT)
-e &lt;NAME&gt; &lt;VALUE&gt;: set argument &lt;NAME&gt; to &lt;VALUE&gt;
-p &lt;FILE&gt;: write profiling data to &lt;FILE&gt;
-w: wait for instrumentation to finish before returning</strong></span>
</pre></div><p>This table summarizes the most common options:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Option</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-r</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Print raw results. Useful to collect raw performance data.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e &lt;NAME&gt; &lt;VALUE&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Set arguments by name. We will examine its usage shortly.</p>
<p>This is a generic option argument that allows us to set<code class="literal">&lt;name, value&gt;</code> pairs.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-p &lt;FILE&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Write profiling data to an external file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-w</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Wait for instrumentation to finish before exiting. Normally used in commands, although not mandatory it's very handy, as otherwise you will not be able to see the test's results.</p>
</td></tr></tbody></table></div><p>To invoke the<code class="literal"> am</code> command we will be using the<code class="literal"> adb shell</code> command or, if you already have a shell running on an emulator or device, you can issue the<code class="literal"> am</code> command directly at the shell command prompt.<a class="indexterm" id="id79"/>
</p><div class="section" title="Running all tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Running all tests</h3></div></div></div><p>This command line will run all tests with the exception of performance tests:<a class="indexterm" id="id80"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>diego@bruce:\~$ adb shell am instrument -w com.example.aatg.myfirstproject.test/android.test.InstrumentationTestRunner
com.example.aatg.myfirstproject.test.MyFirstProjectTests:
Failure in testSomething:
junit.framework.AssertionFailedError: Not implemented yet
at com.example.aatg.myfirstproject.test.MyFirstProjectTests.testSomething(MyFirstProjectTests.java:22)
at java.lang.reflect.Method.invokeNative(Native Method)
at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)
at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)
at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:430)
at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)
Test results for InstrumentationTestRunner=.F
Time: 0.2
FAILURES!!!
Tests run: 1, Failures: 1, Errors: 0</strong></span>
</pre></div></div><div class="section" title="Running tests from a specific test case"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Running tests from a specific test case</h3></div></div></div><p>To run all the tests in a specific test case, you may use:<a class="indexterm" id="id81"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>diego@bruce:\~$ adb shell am instrument -w -e class com.example.aatg.myfirstproject.test.MyFirstProjectTests com.example.aatg.myfirstproject.test/android.test.InstrumentationTestRunner</strong></span>
</pre></div></div><div class="section" title="Running a specific test by name"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Running a specific test by name</h3></div></div></div><p>Additionally we have the alternative of specifying which test we want to run in the command line:<a class="indexterm" id="id82"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>diego@bruce:\~$ adb shell am instrument -w -e class com.example.aatg.myfirstproject.test.MyFirstProjectTests\#testSomething com.example.aatg.myfirstproject.test/android.test.InstrumentationTestRunner</strong></span>
</pre></div><p>This test cannot be run in this way unless we have a no-argument constructor in our test case — that is the reason we added it before.</p></div><div class="section" title="Running specific tests by category"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Running specific tests by category</h3></div></div></div><p>As we mentioned before, tests can be grouped into different categories using annotations<span class="emphasis"><em> (Test Annotations)</em></span> and you can run all tests in this category.<a class="indexterm" id="id83"/>
</p><p>The following options can be added to the command line:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e unit true</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Run all unit tests. These are tests that are not derived from<code class="literal"> InstrumentationTestCase</code> (and are not performance tests).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e func true</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Run all functional tests. These are tests that are derived from<code class="literal"> InstrumentationTestCase</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e perf true</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Include performance tests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e size {small | medium | large}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Run small, medium, or large tests depending on the annotations added to the tests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e annotation &lt;annotation-name&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Run tests annotated with this annotation. This option is mutually exclusive with the size option.</p>
</td></tr></tbody></table></div><p>In our example, we annotated the test method<code class="literal"> testSomething()</code> with<code class="literal"> @SmallTest</code>. So this test is considered to be in that category and thus run, eventually with other tests belonging to that same category, when we specify<code class="literal"> small</code> as the test size.</p><p>This command line will run all the tests annotated with<code class="literal"> @SmallTest:</code>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>diego@bruce:\~$ adb shell am instrument -w -e size small com.example.aatg.myfirstproject.test/android.test.InstrumentationTestRunner</strong></span>
</pre></div><div class="section" title="Creating a custom annotation"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec01"/>Creating a custom annotation<a class="indexterm" id="id84"/>
</h4></div></div></div><p>In case you decide to sort the tests by a different criterion than their size, a custom annotation can be created and then specified in the command line.</p><p>As an example, let's say we want to arrange them according to their importance, so we create an annotation<code class="literal"> @VeryImportantTest</code>.</p><div class="informalexample"><pre class="programlisting">package com.example.aatg.myfirstproject.test;
/**
* Annotation for very important tests.
*
* @author diego
*
*/
public @interface VeryImportantTest {
}
</pre></div><p>Following this, we can create another test and annotate it with<code class="literal"> @VeryImportantTest</code>.</p><div class="informalexample"><pre class="programlisting">@VeryImportantTest
public void testOtherStuff() {
fail("Not implemented yet");
}
</pre></div><p>So, as we mentioned before, we can include this annotation in the<code class="literal"> am instrument</code> command line to run only the annotated tests:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>diego@bruce:\~$ adb shell am instrument -w -e annotation VeryImportantTest \ com.example.aatg.myfirstproject.test/android.test.InstrumentationTestRunner</strong></span>
</pre></div></div></div><div class="section" title="Running performance tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Running performance tests</h3></div></div></div><p>We will be reviewing performance test details in<a class="link" href="ch09.html" title="Chapter 9. Performance Testing and Profiling"> Chapter 9</a>,<span class="emphasis"><em> Performance Testing</em></span> but here we will introduce the available options to the<code class="literal"> am instrument</code> command.<a class="indexterm" id="id85"/>
</p><p>To include performance tests on your test run you should add this command line option</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e perf true</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Include performance tests.</p>
</td></tr></tbody></table></div></div><div class="section" title="Dry run"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Dry run</h3></div></div></div><p>Sometimes you may need to know only what tests will be run instead of actually running them.<a class="indexterm" id="id86"/>
</p><p>This is the option you need to add to your command line:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e log true</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Display the tests to be run instead of running them.</p>
</td></tr></tbody></table></div><p>This is useful if you are writing scripts or perhaps building other tools.</p></div></div></div>
<div class="section" title="Debugging tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec07"/>Debugging tests</h1></div></div></div><p>Your tests might have bugs too; you should assume that. In that case usual debugging techniques apply, for example adding messages through LogCat.<a class="indexterm" id="id87"/>
</p><p>If a more sophisticated debugging technique is needed you should attach the debugger to the test runner. In order to do so, there are two main alternatives.</p><p>The first is easy — not leaving the convenience of Eclipse and not having to remember hard-to-memorize command-line options. In the latest version of the Android ADT plugin, the option<span class="strong"><strong> Debug As| Android JUnit Test</strong></span> was added. Thus you can set a breakpoint in your tests and use it.</p><p>To toggle a breakpoint you can select the desired line in the editor and then use the menu option<span class="strong"><strong> Run | Toggle Line Breakpoint</strong></span>. Alternatively you can slightly alter the code of your tests to wait for the debugger connection. But don't worry, this change is extremely simple. Add the following snippet to the constructor or any other test you want to debug. The place where you add it is not really relevant as the debugger would stop at breakpoints anyway. In this case, we decided to add<code class="literal"> Debug.waitForDebugger()</code> to the constructor as follows:<a class="indexterm" id="id88"/>
</p><div class="informalexample"><pre class="programlisting">public class MyFirstProjectTests extends TestCase {<span class="strong"><strong>
private static final boolean DEBUG = true;</strong></span>
public MyFirstProjectTests(String name) {
super(name);<span class="strong"><strong>
if ( DEBUG ) {
Debug.waitForDebugger();
}</strong></span>
}
…
</pre></div><p>When you run the tests as usual, using<span class="strong"><strong> Run As | Android JUnit Test</strong></span>, you will probably be asked to change the perspective.</p><div class="mediaobject"><img alt="Debugging tests" src="graphics/3500_02_11.jpg"/></div><p>Once it is done, you will be in a standard debugging perspective and session.</p><p>Additionally if you can't or don't want to alter your tests' code, you can set breakpoints in it and pass the following option to<code class="literal"> am instrument</code>.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-e debug true</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Attach to debugger.</p>
</td></tr></tbody></table></div><p>Once your tests have been started, the test runner will wait for your debugger to attach.</p><p>Execute this command line to debug the tests:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ adb shell am instrument -w -e debug true com.example.aatg.myfirstproject.test/android.test.InstrumentationTestRunner</strong></span>
</pre></div><p>You will see this line while waiting at the first breakpoint reached:<a class="indexterm" id="id89"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>com.example.aatg.myfirstproject.test.MyFirstProjectTests:</strong></span>
</pre></div><p>This will continue and exit normally once the debug was attached and your debugging session will be completed.</p></div>
<div class="section" title="Other command-line options"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec08"/>Other command-line options</h1></div></div></div><p>The<code class="literal"> am instrument</code> command accepts other<code class="literal">&lt;name, value&gt;</code> pairs beside the previously mentioned ones:<a class="indexterm" id="id90"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>package</p>
</td><td style="text-align: left" valign="top">
<p>Fully qualified package name of one or several packages in the test application.</p>
<p>Multiple values are separated by commas (,).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>class</p>
</td><td style="text-align: left" valign="top">
<p>A fully qualified test case class to be executed by the test runner.</p>
<p>Optionally this could include the test method name separated from the class name by a hash (<code class="literal">#</code>).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>coverage</p>
</td><td style="text-align: left" valign="top">
<p>True</p>
<p>Runs the EMMA code coverage and writes output to a file that can also be specified.</p>
<p>We will dig into details about supporting EMMA code coverage for our tests in<a class="link" href="ch10.html" title="Chapter 10. Alternative Testing Tactics"> Chapter 10</a>, <span class="emphasis"><em>Alternative Testing Tactics.</em></span></p>
</td></tr></tbody></table></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Summary</h1></div></div></div><p>We have reviewed the main techniques and tools behind testing in Android.</p><p>The following is what we have covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Created our first Android test project as a companion for a sample Android project.</li><li class="listitem" style="list-style-type: disc">Followed the best practice of always creating our companion test project even if initially you may think it's not needed.</li><li class="listitem" style="list-style-type: disc">Created a simple test class to test the Activity in the project. We haven't added any useful test cases yet but adding those simple ones was intended to validate all of our infrastructure.</li><li class="listitem" style="list-style-type: disc">We also ran this simple test from Eclipse and from the command line to understand the alternatives we have. In this process, we mentioned the Activity Manager and its command line incarnation<code class="literal"> am</code>.</li><li class="listitem" style="list-style-type: disc">Analyzed the most used command lines and explained their options.</li><li class="listitem" style="list-style-type: disc">Created a custom annotation to sort our tests and demonstrated its usage.</li><li class="listitem" style="list-style-type: disc">Running the tests and interpreting the results let us know how well our application is behaving.</li></ul></div><p>In the next chapter we will start analyzing the mentioned techniques, frameworks, and tools in much greater detail and provide examples of their usage.</p></div></body></html>