<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Displaying Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Displaying Data</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Providing lists</li><li class="listitem" style="list-style-type: disc">Displaying data in a table</li><li class="listitem" style="list-style-type: disc">Customizing rows</li><li class="listitem" style="list-style-type: disc">Editing a table</li><li class="listitem" style="list-style-type: disc">Table indexing</li><li class="listitem" style="list-style-type: disc">Searching through the data</li><li class="listitem" style="list-style-type: disc">Creating a simple web browser</li><li class="listitem" style="list-style-type: disc">Displaying data in a grid</li><li class="listitem" style="list-style-type: disc">Customizing the grid</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Introduction</h1></div></div></div><p>In the previous chapter, we discussed some of the available options for data management in an iOS app. In this chapter, we will discuss the various ways of displaying data to the user.</p><p>Specifically, we will focus on how to use the following controls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIPickerView</strong></span>: This <a id="id311" class="indexterm"/>control provides functionality that is similar to a list box.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UITableView</strong></span>: This<a id="id312" class="indexterm"/> is a very customizable view for displaying data. It is one of the most used controls in iOS apps.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UISearchBar</strong></span> <span class="strong"><strong>and</strong></span> <span class="strong"><strong>UISearchDisplayController</strong></span>: This is a combination of controls<a id="id313" class="indexterm"/> that provides an easy-to-use interface<a id="id314" class="indexterm"/> for searching through data.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UIWebView</strong></span>: This<a id="id315" class="indexterm"/> brings web-browser functionality to apps.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UICollectionView</strong></span>: This <a id="id316" class="indexterm"/>displays data in a customizable grid.</li></ul></div><p>Furthermore, we will learn how to provide indexing in tables to make large volumes of data easily accessible to the user.</p></div></div>
<div class="section" title="Providing lists"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Providing lists</h1></div></div></div><p>In this recipe, we will learn how to use the <code class="literal">UIPickerView</code> class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec166"/>Getting ready</h2></div></div></div><p>The <code class="literal">UIPickerView</code> class provides us with a control whose functionality is similar to that of a list box. It is <a id="id317" class="indexterm"/>specifically designed for human fingers that touch the screen. Its main difference from a common list box is that each column can have its own number of rows. To get started, create a new iPhone <span class="strong"><strong>Single View Application</strong></span> project and name it <code class="literal">PickerViewApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec167"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">PickerViewAppViewController.xib</code> file in Interface Builder. Add <code class="literal">UILabel</code> and <code class="literal">UIPickerView</code> on the main view and save the document.</li><li class="listitem">Back in Xamarin Studio, create a nested class in the <code class="literal">PickerViewAppViewController</code> class that inherits from UIPickerViewModel using the following code:<div class="informalexample"><pre class="programlisting">private class PickerModel : UIPickerViewModel</pre></div></li><li class="listitem">Add the following constructor and fields in the nested class:<div class="informalexample"><pre class="programlisting">public PickerModel (PickerViewAppViewController controller) {
  this.parentController = controller;
  this.transportList = new List&lt;string&gt;() { "On foot", "Bicycle", "Motorcycle", "Car", "Bus" };
  this.distanceList = new List&lt;string&gt;() { "0.5", 	"1", "5", "10", "100" };
  this.unitList = new List&lt;string&gt;() { "mi", "km" };
  this.transportSelected = this.transportList[0];
  this.distanceSelected = this.distanceList[0];
  this.unitSelected = this.unitList[0];
}
private PickerViewAppViewController parentController;
private List&lt;string&gt; transportList;
private List&lt;string&gt; distanceList;
private List&lt;string&gt; unitList;
string transportSelected;
string distanceSelected;
string unitSelected;</pre></div></li><li class="listitem">You will<a id="id318" class="indexterm"/> now need to override four methods from the <code class="literal">UIPickerViewModel</code> class, as shown in the following code:<div class="informalexample"><pre class="programlisting">public override int GetComponentCount (UIPickerView picker) {
  return 3;
}
public override int GetRowsInComponent(UIPickerView picker, int component) {
  switch (component) {
  case 0: 
    return this.transportList.Count;
  case 1:
    return this.distanceList.Count;
  default:
    return this.unitList.Count;
  }
}
public override string GetTitle (UIPickerView picker, int row, int component) {
  switch (component) {
  case 0:
    return this.transportList[row];
  case 1:
    return this.distanceList[row];
  default:
    return this.unitList[row];
  }
}
public override void Selected (UIPickerView picker, int row, int component) {
  switch (component) {
    case 0:
      this.transportSelected = this.transportList[row];
    break;
    case 1:
      this.distanceSelected = this.distanceList[row];
    break;
    default:
      this.unitSelected = this.unitList[row];
    break;
  }
  this.parentController.lblStatus.Text = String.Format("Transport: {0}\nDistance: {1}{2}", this.transportSelected, this.distanceSelected, this.unitSelected);
} </pre></div></li><li class="listitem">Finally, set<a id="id319" class="indexterm"/> the model object we created to the picker view's <code class="literal">Model</code> property inside the controller's <code class="literal">ViewDidLoad</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">this.pickerView.Model = new PickerModel (this);</pre></div></li><li class="listitem">Compile and run the app on the simulator. Drag through the items in the picker view and watch the label's content change according to your selection. The following screenshot shows how it should look:<div class="mediaobject"><img src="graphics/8924OT_05_01.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec168"/>How it works...</h2></div></div></div><p>The <code class="literal">UIPickerViewModel</code> class does not exist in Objective-C. Xamarin.iOS provides this class as a <a id="id320" class="indexterm"/>wrapper around the <code class="literal">UIPickerViewDataSource</code> and <code class="literal">UIPickerViewDelegate</code> native protocols, and contains both of these classes' methods for us to override. This is extremely helpful since we only have to implement and assign one class instead of two for our picker view. Both of these protocols are available as <code class="literal">C#</code> classes in Xamarin.iOS at the same time.</p><p>Inside the constructor, we initialize the lists that will hold the data to be displayed in the picker. The following four methods we need to override are responsible for displaying the data:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">int GetComponentCount (UIPickerView picker)</code>: This returns the number of columns we want the picker view to display</li><li class="listitem" style="list-style-type: disc"><code class="literal">int GetRowsInComponent (UIPickerView picker, int component)</code>: This returns the number of rows each component will display</li><li class="listitem" style="list-style-type: disc"><code class="literal">string GetTitle (UIPickerView picker, int row, int component)</code>: This is the text of each row</li><li class="listitem" style="list-style-type: disc"><code class="literal">void Selected (UIPickerView picker, int row, int component)</code>: This is the action to be taken when the user selects an item from any component/row combination in the picker view</li></ul></div><p>We use the lists <a id="id321" class="indexterm"/>we have assigned in the constructor to display the data. For example, the <code class="literal">GetTitle</code> method is implemented as shown in the following code:</p><div class="informalexample"><pre class="programlisting">switch (component)
{
case 0:
  return this.transportList[row];
case 1:
  return this.distanceList[row];
default:
  return this.unitList[row];
}</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec169"/>There's more...</h2></div></div></div><p>We can programmatically select the initial selection of the picker view by calling the <code class="literal">Select (int, int, bool)</code> method. The first two parameters reflect the row and component index, respectively, while the <code class="literal">bool</code> parameter toggles the selection animation. The only thing to remember with this method is to call it after we have assigned the picker's <code class="literal">Model</code> property. An exception will occur otherwise.</p><div class="section" title="More UIPickerView customization"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec42"/>More UIPickerView customization</h3></div></div></div><p>Apart from the options presented earlier, we also have the option of setting the width of each <a id="id322" class="indexterm"/>component. To do this, we override the <code class="literal">GetComponentWidth (UIPickerView, int)</code> method, which returns a float that represents the width for each component.</p><p>We can also set custom views as items in the picker view, instead of plain text. This can be done by overriding the <code class="literal">GetView(UIPickerView, int, int, UIView)</code> method and returning the view we want to be displayed on each position in the <code class="literal">UIPickerView</code> control.</p></div><div class="section" title="Date and time selection"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec43"/>Date and time selection</h3></div></div></div><p>There is a control named <code class="literal">UIDatePicker</code> that is similar to <code class="literal">UIPickerView</code> and is specifically <a id="id323" class="indexterm"/>customized to display and select the date and time values. Note that <a id="id324" class="indexterm"/>although its user interface is the same as the picker view, it does not inherit the <code class="literal">UIPickerView</code> class. It just uses an instance of it as a subview.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec170"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying data in a table</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Displaying data in a table"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Displaying data in a table</h1></div></div></div><p>In this recipe, we will learn how to use the <code class="literal">UITableView</code> class to display data. This class, along with <a id="id325" class="indexterm"/>the <code class="literal">UITableViewCell</code> object, provides an interface for <a id="id326" class="indexterm"/>displaying data on the screen in multiple rows, but on a single column.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec171"/>Getting ready</h2></div></div></div><p>To get started, create a new project in Xamarin Studio and name it <code class="literal">TableViewApp</code>. In this recipe, we will not use the XIB files. We will create our user interface in code.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec172"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new class to the project and name it <code class="literal">TableController</code>. Derive the class from <code class="literal">UITableViewController</code> using the following code:<div class="informalexample"><pre class="programlisting">public class TableController : UITableViewController</pre></div></li><li class="listitem">Create the following nested class inside the <code class="literal">TableController</code> class:<div class="informalexample"><pre class="programlisting">private class TableSource : UITableViewSource
{
  public TableSource ()
  {
    this.cellID = "cellIdentifier";
    this.tableData = new Dictionary&lt;int, string&gt; () {
      {0, "Music"},
      {1, "Videos"},
      {2, "Images"}
    };
  }
  private readonly string cellID;
  private Dictionary&lt;int, string&gt; tableData;
  public override int RowsInSection (UITableView tableview, int section)
  {
    return this.tableData.Count;
  }
  public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath)
  {
    int rowIndex = indexPath.Row;
    UITableViewCell cell = tableView.DequeueReusableCell (this.cellID);
    if (null == cell)
    {
      cell = new UITableViewCell (UITableViewCellStyle.Default, this.cellID);
    }
    cell.TextLabel.Text = this.tableData[rowIndex];
    return cell;
  }
}</pre></div></li><li class="listitem">Override<a id="id327" class="indexterm"/> the controller's <code class="literal">ViewDidLoad</code> method <a id="id328" class="indexterm"/>and add the following line of code:<div class="informalexample"><pre class="programlisting">this.TableView.Source = new TableSource ();</pre></div></li><li class="listitem">Add the following code in the <code class="literal">FinishedLaunching</code> method to display the table controller:<div class="informalexample"><pre class="programlisting">TableController tableController = new TableController();
UINavigationController navController = new UINavigationController(tableController);
window.RootViewController = navController;</pre></div></li><li class="listitem">Compile and run the application on the simulator. The result should be similar to the one shown in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_05_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec173"/>How it works...</h2></div></div></div><p>The nested<a id="id329" class="indexterm"/> class we created acts as the data source of <code class="literal">UITableView</code>. The <a id="id330" class="indexterm"/>class created in the following code inherits from the Xamarin.iOS <code class="literal">UITableViewSource</code> class:</p><div class="informalexample"><pre class="programlisting">private class TableSource : UITableViewSource</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>Like <code class="literal">UIPickerView</code>, in the example discussed in the previous recipe, the <code class="literal">UITableViewSource</code> class does not exist in Objective-C. It is merely a wrapper object offered by Xamarin.iOS around the <code class="literal">UITableViewDelegate</code> and <code class="literal">UITableViewSource</code> protocols.</p></div></div><p>In its constructor, we initialize two variables (as shown in the following code): <code class="literal">string</code>, which will act as the cells' identifier, and a generic <code class="literal">Dictionary</code> variable for our data source:</p><div class="informalexample"><pre class="programlisting">this.cellID = "cellIdentifier";
this.tableData = new Dictionary&lt;int, string&gt; () {
  {0, "Music"},
  {1, "Videos"},
  {2, "Images"}
};</pre></div><p>To make the <code class="literal">TableSource</code> class work, we need to override two methods. The first method, named <code class="literal">RowsInSection</code>, returns the number of rows that the table shall display. In the following code, we return the number of items in our data source object:</p><div class="informalexample"><pre class="programlisting">return this.tableData.Count;</pre></div><p>The second method, <code class="literal">GetCell</code>, returns the <code class="literal">UITableViewCell</code> object that will be displayed in the table.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>The <code class="literal">UITableViewCell</code> class represents a single row and manages its content in <code class="literal">UITableView</code>.</p></div></div><p>To be more <a id="id331" class="indexterm"/>efficient, the table view creates its cell objects <a id="id332" class="indexterm"/>when they are needed. For this reason, we need to get <code class="literal">UITableViewCell</code> (that was used earlier) from the table through its <code class="literal">DequeueReusableCell</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">UITableViewCell cell = tableView.DequeueReusableCell (this.cellID);</pre></div><p>If no cells exist for the particular cell identifier, the method returns <code class="literal">null</code>. Hence, we create the cell that will be used, using the following code:</p><div class="informalexample"><pre class="programlisting">cell = new UITableViewCell (UITableViewCellStyle.Default, this.cellID);</pre></div><p>Then, we assign the text that the particular cell will display and return using the following code:</p><div class="informalexample"><pre class="programlisting">cell.TextLabel.Text = this.tableData[rowIndex];
return cell;</pre></div><p>By default, the <code class="literal">UITableViewCell</code> class contains two labels that can be used to display text. The main label can be accessed through the <code class="literal">TextLabel</code> property and the secondary label through the <code class="literal">DetailTextLabel</code> property. Note that when using a cell with the <code class="literal">Default</code> style, the <code class="literal">DetailTextLabel</code> property cannot be used and will return <code class="literal">null</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec174"/>There's more...</h2></div></div></div><p>To provide functionality when the user selects a particular row, we need to override the <code class="literal">RowSelected</code> property in the class that acts as a <code class="literal">UITableViewSource</code>. By default, when the user taps on a row, the cell is highlighted with a light gray color to indicate the selection. To deselect the row, we use the <code class="literal">UITableView.DeselectRow(NSIndexPath, bool)</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public override void RowSelected (UITableView tableView, NSIndexPath indexPath)
{
  tableView.DeselectRow (indexPath, true);
}</pre></div><div class="section" title="The UITableView styles"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec44"/>The UITableView styles</h3></div></div></div><p>
<code class="literal">UITableView</code> can be created with two different styles. The default style is <code class="literal">Plain</code>. The other style<a id="id333" class="indexterm"/> that can be used is the <code class="literal">Grouped</code> style. This style is being used in many iOS native apps such as the <span class="emphasis"><em>Settings</em></span> app.</p><p>Also, <code class="literal">UITableView</code> supports the display of data divided into different sections. We must explicitly return the number of rows each section will have in the <code class="literal">RowsInSection</code> override if we want to use different sections.</p></div><div class="section" title="The UITableViewCell styles"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec45"/>The UITableViewCell styles</h3></div></div></div><p>A table cell <a id="id334" class="indexterm"/>can have four different cell styles, which are represented by the <code class="literal">UITableViewCellStyle</code> enumeration. Its values are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Default</strong></span>: This is the default cell style. Only the <code class="literal">TextLabel</code> property can be used to display text.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Subtitle</strong></span>: This is a style that provides <code class="literal">DetailTextLabel</code> as a subtitle to <code class="literal">TextLabel</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Value1</strong></span>: This is a style that displays both <code class="literal">TextLabel</code> and <code class="literal">DetailTextLabel</code> text in the same size, with a different color, and aligned to the sides of the cell.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Value2</strong></span>: This is a style that displays the <code class="literal">TextLabel</code> text smaller than the <code class="literal">DetailTextLabel</code> text. This style is used in the native <span class="emphasis"><em>Contacts</em></span> app, in the contact details screen.</li></ul></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec175"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Providing lists</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Customizing rows</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Navigating through different view controllers</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. User Interface – View Controllers">Chapter 3</a>, <span class="emphasis"><em>User Interface – View Controllers</em></span></li></ul></div></div></div>
<div class="section" title="Customizing rows"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Customizing rows</h1></div></div></div><p>In this recipe, we <a id="id335" class="indexterm"/>will create a table view that uses our own custom <a id="id336" class="indexterm"/>subclass of <code class="literal">UITableViewCell</code> to display data.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec176"/>Getting ready</h2></div></div></div><p>Create a new project in Xamarin Studio in the same manner in which the project in the earlier recipe was created. Name it <code class="literal">CustomRowsApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec177"/>How to do it...</h2></div></div></div><p>Perform <a id="id337" class="indexterm"/>the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a <a id="id338" class="indexterm"/>new class to the project and name it <code class="literal">CustomCell</code>.</li><li class="listitem">Implement the class with the following code:<div class="informalexample"><pre class="programlisting">[Register("CustomCell")]
public partial class CustomCell : UITableViewCell {
  public const string CELLID = "CustomCell";
  public CustomCell (IntPtr handle) : base(handle) {}
  [Outlet("lblTitle")]
  public UILabel LabelTitle { get; private set; }
  [Outlet("imgView")]
  public UIImageView ImgView { get; private set; }
}</pre></div></li><li class="listitem">Add a new <span class="strong"><strong>Empty iPhone Interface Definition</strong></span> to the project and name it <code class="literal">CustomCell</code>. Don't worry about the name conflicting with the class we created earlier, as this is an XIB file. Open the file in Interface Builder.</li><li class="listitem">Add <code class="literal">UITableViewCell</code> on the canvas. The following screenshot shows a selected <code class="literal">UITableViewCell</code> in the object browser in Xcode:<div class="mediaobject"><img src="graphics/8924OT_05_03.jpg" alt="How to do it..."/></div></li><li class="listitem">Set the <span class="strong"><strong>Class</strong></span> field of the table cell to <code class="literal">CustomCell</code> in the <span class="strong"><strong>Identity</strong></span> inspector.</li><li class="listitem">Set the <span class="strong"><strong>Identifier</strong></span> field of the cell to <code class="literal">CustomCell</code> in the <span class="strong"><strong>Attributes</strong></span> inspector.</li><li class="listitem">Add a <code class="literal">UIImageView</code> and a <code class="literal">UILabel</code> on the cell and connect them to their outlets. Save the document.</li><li class="listitem">Add<a id="id339" class="indexterm"/> the <code class="literal">TableController.cs</code> file we created in the <a id="id340" class="indexterm"/>previous recipe, <span class="emphasis"><em>Displaying data in a table</em></span>, to the project. Change its namespace from <code class="literal">TableViewApp</code> to <code class="literal">CustomRowsApp</code>.</li><li class="listitem">Change the <code class="literal">TableSource</code> class' <code class="literal">GetCell</code> method to the following code:<div class="informalexample"><pre class="programlisting">public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath) {
  int rowIndex = indexPath.Row;
  CustomCell cell = (CustomCell)tableView.DequeueReusableCell(CustomCell.CELLID);
  cell.LabelTitle.Text = this.tableData[rowIndex];
  return cell;
}</pre></div></li><li class="listitem"> Add the following code in the <code class="literal">ViewDidLoad</code> method of <code class="literal">TableController</code>:<div class="informalexample"><pre class="programlisting">this.TableView.RegisterNibForCellReuse (UINib.FromName("CustomCell", NSBundle.MainBundle), CustomCell.CellID);</pre></div></li><li class="listitem">Finally, make sure that <code class="literal">TableController</code> is presented in the <code class="literal">FinishedLaunching</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">TableController tableController = new TableController();
UINavigationController navController = new UINavigationController();
window.RootViewController = navController;</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec178"/>How it works...</h2></div></div></div><p>Just like creating a custom view, we are able to create our own custom cells to present data with a <code class="literal">UITableView</code>. The main difference lies in the fact that the table view reuses the instances of its cells so that it is more efficient when we want to display multiple rows.</p><p>To make our table view "aware" of our custom cell, we call the <code class="literal">RegisterNibForCellReuse</code> method using the following code:</p><div class="informalexample"><pre class="programlisting">this.TableView.RegisterNibForCellReuse (UINib.FromName("CustomCell", NSBundle.MainBundle), CustomCell.CellID);</pre></div><p>This way, when we call the <code class="literal">DequeueReusable</code> cell method in <code class="literal">GetCell</code>, the system will automatically create a cell instance for us or get one that was created earlier. Hence, there is no need for us to check if the cell is null or not:</p><div class="informalexample"><pre class="programlisting">CustomCell cell = (CustomCell)tableView.DequeueReusableCell(CustomCell.CELLID);</pre></div><p>Did you <a id="id341" class="indexterm"/>notice something common in the two method calls discussed <a id="id342" class="indexterm"/>earlier? They both need an identifier string for the cell. The <code class="literal">CustomCell.CELLID</code> constant has the same value we entered in the <span class="strong"><strong>Identifier</strong></span> field of the cell in Xcode: <code class="literal">CustomCell</code>. In this case, it is the same as the class name of our cell, as it keeps things tidy if we were to have different custom cells to present. However, basically, the identifier for a cell can be whatever we want it to be.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec179"/>There's more...</h2></div></div></div><p>We can create as many custom cells as we need. As discussed earlier, we need to make sure that we set a unique identifier for each of the cell classes we are going to use. Also, if the custom cells we create have different heights, we need to make sure we override the <code class="literal">GetHeightForRow</code> method in our <code class="literal">UITableViewSource</code> implementation using the following code:</p><div class="informalexample"><pre class="programlisting">public override float GetHeightForRow (UITableView tableView, NSIndexPath indexPath) {
  return 44f; // Or whatever height we want the particular row to have.
}</pre></div><p>For greater efficiency, it's good to have the heights of the rows calculated beforehand and not calculate them inside <code class="literal">GetHeightForRow</code>.</p><div class="section" title="Useful properties of the UITableViewCell class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec46"/>Useful properties of the UITableViewCell class</h3></div></div></div><p>Apart from adding text in the default labels, the <code class="literal">UITableViewCell</code> contains some other properties whose values we can set to add more default items in a cell. These properties are are follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ImageView</code>: This <a id="id343" class="indexterm"/>accepts a <code class="literal">UIImageView</code> parameter. We can use it to display an image in a cell, on its left-hand side.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AccessoryView</code>: This accepts any instance of <code class="literal">UIView</code>. Its position defaults to <a id="id344" class="indexterm"/>the right of the cell, in the place of the cell's accessory, which is located on the right-hand side of the cell.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Accessory</code>: This accepts values of the <code class="literal">UITableViewCellAccessory</code> type. It provides <a id="id345" class="indexterm"/>predefined views for <a id="id346" class="indexterm"/>the cell's accessory, such as <code class="literal">DetailDisclosureButton</code> or <code class="literal">Checkmark</code>.</li></ul></div></div><div class="section" title="UINib class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec47"/>UINib class</h3></div></div></div><p>The <code class="literal">UINib</code> class is responsible for loading NIB files at runtime. We instantiate a <code class="literal">UINib</code> instance<a id="id347" class="indexterm"/> through its <code class="literal">FromName</code> static method, passing the name of the NIB file we want to load without its extension, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">UINib nib = UINib.FromName("CustomCell", NSBundle.MainBundle);</pre></div></div><div class="section" title="Adding content programmatically"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec48"/>Adding content programmatically</h3></div></div></div><p>We can add <a id="id348" class="indexterm"/>views to a table cell programmatically. However, we should not add them to the cell directly, but to its <code class="literal">ContentView</code>, using the following code:</p><div class="informalexample"><pre class="programlisting">// Inside our custom cell class:
this.ContentView.AddSubview(myView);</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec180"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying data in a table</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Editing a table</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a custom view</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. User Interface – Views">Chapter 2</a>, <span class="emphasis"><em>User Interface – Views</em></span></li></ul></div></div></div>
<div class="section" title="Editing a table"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Editing a table</h1></div></div></div><p>In this recipe, we <a id="id349" class="indexterm"/>will discuss how to insert and delete rows at runtime from a <code class="literal">UITableView</code>, providing the user with the appropriate user interface interaction.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec181"/>Getting ready</h2></div></div></div><p>Open the <code class="literal">CustomRowsApp</code> project we created in the previous recipe, <span class="emphasis"><em>Customizing rows</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec182"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Remove the <code class="literal">tableData</code> field from the <code class="literal">TableSource</code> class and replace it with the following property:<div class="informalexample"><pre class="programlisting">public List&lt;string&gt; TableData { get; private set; }</pre></div></li><li class="listitem">Initialize the list in the constructor using the following code:<div class="informalexample"><pre class="programlisting">this.TableData = new List&lt;string&gt;() { "Music", "Videos", "Images" };</pre></div></li><li class="listitem">In the <code class="literal">TableSource</code> class, override the <code class="literal">CommitEditingStyle</code> method and implement it with the following code:<div class="informalexample"><pre class="programlisting">public override void CommitEditingStyle (UITableView tableView, UITableViewCellEditingStyle editingStyle, NSIndexPath indexPath) {
  if (editingStyle == UITableViewCellEditingStyle.Delete) {
    this.tableData.RemoveAt(indexPath.Row);
    tableView.DeleteRows(new NSIndexPath[] { indexPath }, UITableViewRowAnimation.Automatic);
  }
}</pre></div></li><li class="listitem">In<a id="id350" class="indexterm"/> the <code class="literal">TableController</code> class, add a <code class="literal">UIBarButtonItem</code> using the following code:<div class="informalexample"><pre class="programlisting">UIBarButtonItem btnAdd;
public override ViewDidLoad() {
  // … existing code here.
  this.btnAdd = new UIBarButtonItem(UIBarButtonSystemItem.Add, (s, e) =&gt; {
    TableSource tableSource = (TableSource)this.TableView.Source;
    int itemCount = tableSource.TableData.Count;
    tableSource.TableData.Add(string.Format("Inserted item: {0}", itemCount));
    this.TableView.InsertRows(new NSIndexPath[] { 
      NSIndexPath.FromRowSection(itemCount, 0)
    }, UITableViewRowAnimation.Automatic);
  };
  this.NavigationItem.SetRightBarButtonItem(this.btnAdd, false);
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap the plus button to add new rows to the table and swipe on an item from right to left to delete items. The following screenshot shows the table after having added one item and swiped on another one:<div class="mediaobject"><img src="graphics/8924OT_05_04.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>To swipe an item on the simulator, click-and-drag the cursor sideways.</p></div></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec183"/>How it works...</h2></div></div></div><p>The <code class="literal">CommitEditingStyleForRow</code> method is called whenever an editing action is about to take <a id="id351" class="indexterm"/>place. In our implementation, we check if the editing action is about deleting an item, and if it is, we remove the row. To do this, we first remove the corresponding item from our data source and then call the <code class="literal">DeleteRows</code> method of the table view:</p><div class="informalexample"><pre class="programlisting">this.tableData.RemoveAt(indexPath.Row);
tableView.DeleteRows(new NSIndexPath[] { indexPath }, UITableViewRowAnimation.Automatic);</pre></div><p>Similarly, when we want to add a row to the table, we first add the item we want to our data source and then call the <code class="literal">InsertRows</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">tableSource.TableData.Add(string.Format("Inserted item: {0}", itemCount));
this.TableView.InsertRows(new NSIndexPath[] { 
  NSIndexPath.FromRowSection(itemCount, 0)
}, UITableViewRowAnimation.Automatic);</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec184"/>There's more...</h2></div></div></div><p>The <code class="literal">UITableView</code> also supports an editing mode. We can activate/deactivate the editing mode of a <a id="id352" class="indexterm"/>table view by calling the <code class="literal">SetEditing</code> method, passing <code class="literal">true</code> or <code class="literal">false</code>, respectively, an example of which is shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.TableView.SetEditing(true, true);</pre></div><p>The second parameter determines whether we want the table view to transition to/from the editing mode with an animation.</p><p>When a table view is in the editing mode, each row has a red minus sign on its left-hand side. If the user taps the sign, the <span class="strong"><strong>Delete</strong></span> button will appear on the right-hand side of the row, just as it appears when they swipe the row.</p><div class="section" title="Enabling editing modes for individual rows"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec49"/>Enabling editing modes for individual rows</h3></div></div></div><p>We can also enable a specific editing mode or even disable it for individual rows. To do this, we <a id="id353" class="indexterm"/>need to override the <code class="literal">EditingStyleForRow</code> method in our <code class="literal">UITableViewSource</code> subclass, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public override UITableViewCellEditingStyle EditingStyleForRow(UITableView tableView, NSIndexPath indexPath) {
  // To disable the editing style of a row:
  // return UITableViewCellEditingStyle.None;
  return UITableViewCellEditingStyle.Delete;
}</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec185"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying data in a table</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Table indexing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Table indexing</h1></div></div></div><p>In this<a id="id354" class="indexterm"/> recipe, we will learn how to provide an index in a table, allowing<a id="id355" class="indexterm"/> the user to quickly browse through the rows of <code class="literal">UITableView</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec186"/>Getting ready</h2></div></div></div><p>Create a new project in Xamarin Studio and name it <code class="literal">TableIndexApp</code>. Add a <code class="literal">UITableViewController</code>, as shown in the previous tasks in this chapter, and implement the <code class="literal">TableSource</code> class.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec187"/>How to do it...</h2></div></div></div><p>Perform the following step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the table source class, override and implement the following methods:<div class="informalexample"><pre class="programlisting">public override int NumberOfSections (UITableView tableView)
{
  return this.tableData.Count;
}
public override string TitleForHeader (UITableView tableView, int section)
{
  return Convert.ToString (this.tableData[section][0]);
}
public override string[] SectionIndexTitles (UITableView tableView)
{
  return this.tableData.Select (s =&gt; Convert.ToString (s[0])).Distinct ().ToArray ();
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec188"/>How it works...</h2></div></div></div><p>The table source created in this recipe contains many different sections. For simplicity, each section contains one row. The <code class="literal">NumberOfSections</code> method returns the total number of sections that the table will display.</p><p>To set a title for each section, we must override the <code class="literal">TitleForHeader</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public override string TitleForHeader (UITableView tableView, int section)
{
  return Convert.ToString (this.tableData[section][0]);
}</pre></div><p>This implementation returns the first letter of each string in the data source. To provide the index, we override the <code class="literal">SectionIndexTitles</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public override string[] SectionIndexTitles (UITableView tableView)
{
  return this.tableData.Select (s =&gt; Convert.ToString (s[0])).Distinct ().ToArray ();
}</pre></div><p>Here, it returns<a id="id356" class="indexterm"/> the first letter of each item in the data source. The<a id="id357" class="indexterm"/> result of this project will be similar to one shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8924OT_05_05.jpg" alt="How it works..."/></div><p>When the user touches the screen anywhere on the index, the table view will scroll to that specific section.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec189"/>There's more...</h2></div></div></div><p>Indexing should be<a id="id358" class="indexterm"/> applied to tables with a <span class="strong"><strong>Plain</strong></span> style. Applying an<a id="id359" class="indexterm"/> index on tables with a <span class="strong"><strong>Grouped</strong></span> style set is not advisable, because the index will not be easily distinguished.</p><p>A good example of a native iOS app with an index on a table can be found in the native <span class="emphasis"><em>Contacts</em></span> app.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec190"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying data in a table</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Searching through the data"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Searching through the data</h1></div></div></div><p>In this recipe, we will learn how to provide search functionality for the content in a table view.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec191"/>Getting ready</h2></div></div></div><p>Create a<a id="id360" class="indexterm"/> new project in Xamarin Studio and name it <code class="literal">SearchTableApp</code>. Add <code class="literal">UIViewController</code> and name it <code class="literal">SearchController</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec192"/>How to do it...</h2></div></div></div><p>Perform<a id="id361" class="indexterm"/> the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">SearchController.xib</code> file in Interface Builder. Add <span class="strong"><strong>Search Bar and Search Display Controller</strong></span> in <code class="literal">UITableView</code>. The following screenshot shows the <code class="literal">UISearchDisplayController</code> object selected in the object browser: <div class="mediaobject"><img src="graphics/8924OT_05_06.jpg" alt="How to do it..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Note that after this action, some outlets are created and connected automatically. We need most of them, so we leave them as they are.</p></div></div></li><li class="listitem">Add <code class="literal">UITableView</code> and connect it to an outlet. Save the document.</li><li class="listitem">Back in Xamarin Studio, create a <code class="literal">UITableViewSource</code> subclass that will act as the <a id="id362" class="indexterm"/>data source for the table view. Refer to the <span class="emphasis"><em>Displaying data in a table</em></span> recipe in this chapter for information on how to do this. This time, make<a id="id363" class="indexterm"/> sure that the <code class="literal">List&lt;string&gt;</code> variable, which will hold the data, is a member of the <code class="literal">SearchController</code> class.</li><li class="listitem">Add another <code class="literal">List&lt;string&gt;</code> variable in the <code class="literal">SearchController</code> class using the following code:<div class="informalexample"><pre class="programlisting">private List&lt;string&gt; filterDataList;</pre></div></li><li class="listitem">Implement a subclass that will act as a delegate object for the search display controller, as shown in the following code:<div class="informalexample"><pre class="programlisting">private class SearchDelegate : UISearchDisplayDelegate
{
  public SearchDelegate (TableController controller)
  {
    this.parentController = controller;
  }
  private TableController parentController;
  public override bool ShouldReloadForSearchString (UISearchDisplayController controller, string forSearchString)
  {
    this.parentController.filterDataList = this.parentController.tableData
      .Where (s =&gt; s.ToLower ().Contains (forSearchString.ToLower ()))
        .ToList ();
    this.parentController.filterDataList.Sort (delegate(string firstStr, string secondStr) {
        return firstStr.CompareTo (secondStr);
      });
    return true;
  }
}</pre></div></li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method and assign the source and delegate objects in it:<div class="informalexample"><pre class="programlisting">this.TableView.Source = new TableSource (this);
this.SearchDisplayController.SearchResultsSource = new TableSource(this);
this.SearchDisplayController.Delegate = new SearchDelegate(this);</pre></div></li><li class="listitem">Compile <a id="id364" class="indexterm"/>and run the app on the simulator. Tap the search bar <a id="id365" class="indexterm"/>and start typing into it. It will automatically search the table and show the results.<p>You can find the complete code in the <code class="literal">SearchTableApp</code> project. The result will be the common iOS search bar above the table, similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/8924OT_05_07.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec193"/>How it works...</h2></div></div></div><p>The <code class="literal">UISearchDisplayController</code> class provides a convenient way of searching through<a id="id366" class="indexterm"/> data. It contains <code class="literal">UISearchBar</code> which accepts input from the <a id="id367" class="indexterm"/>user, and <code class="literal">UITableView</code> which is used to display the results. After we add a search controller in a view controller, we can access it through that controller's <code class="literal">SearchDisplayController</code> property. To trigger the results table, we must implement <code class="literal">UISearchDisplayDelegate</code> and override its <code class="literal">ShouldReloadForSearchString</code> (which returns a Boolean value) using the following code:</p><div class="informalexample"><pre class="programlisting">private class SearchDelegate : UISearchDisplayDelegate</pre></div><p>Inside the <code class="literal">ShouldReloadForSearchString</code> method override, we search our data source, saving the filtered results in a new data source according to its <code class="literal">forSearchString</code> parameter:</p><div class="informalexample"><pre class="programlisting">this.parentController.filterDataList = this.parentController.tableData
  .Where (s =&gt; s.ToLower ().Contains (forSearchString.ToLower ()))
  .ToList ();</pre></div><p>We then <a id="id368" class="indexterm"/>sort the results alphabetically and return <code class="literal">true</code> so that the <a id="id369" class="indexterm"/>search controller's table will reload its data, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.parentController.filterDataList.Sort (delegate(string firstStr, string secondStr) {
  return firstStr.CompareTo (secondStr);
});
return true;</pre></div><p>The search controller's table view also needs a source object. In this example, we set it to the same object we created for our table, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">this.TableView.Source = new TableSource (this);
this.SearchDisplayController.SearchResultsSource = new TableSource(this);</pre></div><p>As we are using instances of the same object, we need to modify some things in it to display data according to which table calls it. So, for example, the <code class="literal">RowsInSection</code> method looks like the following code:</p><div class="informalexample"><pre class="programlisting">public override int RowsInSection (UITableView tableview, int section)
{
  if (tableview.Equals (this.parentController.TableView))
  {
    return this.parentController.tableData.Count;
  } else
  {
    return this.parentController.filterDataList.Count;
  }
}</pre></div><p>In this way, we return the number of rows according to which table calls the method. Similarly, we need to set each cell's text label inside the <code class="literal">GetCell</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (tableView.Equals (this.parentController.TableView))
{
  cell.TextLabel.Text = this.parentController.tableData[rowIndex];
} else
{
  cell.TextLabel.Text = this.parentController.filterDataList[rowIndex];
}</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec194"/>There's more...</h2></div></div></div><p>When the <a id="id370" class="indexterm"/>user taps on the search bar, the keyboard appears, making the <a id="id371" class="indexterm"/>search controller active. To deactivate it, we can hook on the search bar's <code class="literal">SearchButtonClicked</code> event. This event will get triggered when the user taps on the keyboard's <span class="strong"><strong>Search</strong></span> button:</p><div class="informalexample"><pre class="programlisting">this.SearchDisplayController.SearchBar.SearchButtonClicked += (s, e) =&gt; {
  this.SearchDisplayController.SetActive(false, true);
};</pre></div><p>The <code class="literal">SetActive</code> method is what we can use to enable or disable the search controller.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec195"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying data in a table</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Table indexing</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Creating a simple web browser"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Creating a simple web browser</h1></div></div></div><p>In this recipe, we will discuss displaying online content with the <code class="literal">UIWebView</code> class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec196"/>Getting ready</h2></div></div></div><p>Create a<a id="id372" class="indexterm"/> new <span class="strong"><strong>Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">WebBrowserApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec197"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">WebBrowserAppViewController.xib</code> file in Interface Builder and add a <code class="literal">UIWebView</code> object on the main view. Create and connect an outlet for it with the name <code class="literal">webView</code>. Save the document.</li><li class="listitem">Override the <code class="literal">ViewDidAppear</code> method in the <code class="literal">WebBrowserAppViewController</code> class, as shown in the following code:<div class="informalexample"><pre class="programlisting">public override void ViewDidAppear (bool animated)
{
  NSUrl url = new NSUrl ("http://software.tavlikos.com");
  NSUrlRequest urlRequest = new NSUrlRequest (url);
  this.webView.LoadRequest (urlRequest);
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Watch the website load on the screen!</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec198"/>How it works...</h2></div></div></div><p>The <code class="literal">UIWebView</code> class is iOS SDK's web browser control. To load web content, we just have to <a id="id373" class="indexterm"/>call its <code class="literal">LoadRequest</code> method, which accepts a parameter of the <code class="literal">NSUrlRequest</code> type. The <code class="literal">NSUrlRequest</code> object contains the URL we want it to load, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">NSUrl url = new NSUrl ("http://software.tavlikos.com");</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec199"/>There's more...</h2></div></div></div><p>The <code class="literal">UIWebView</code> class contains some very useful events, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LoadStarted</code>: This<a id="id374" class="indexterm"/> is triggered when the control has started loading content</li><li class="listitem" style="list-style-type: disc"><code class="literal">LoadFinished</code>: This<a id="id375" class="indexterm"/> is triggered when the content finished loading successfully</li><li class="listitem" style="list-style-type: disc"><code class="literal">LoadError</code>: This<a id="id376" class="indexterm"/> is triggered when the loading of the content failed</li></ul></div><div class="section" title="Scaling the content"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec50"/>Scaling the content</h3></div></div></div><p>Another<a id="id377" class="indexterm"/> important feature of the <code class="literal">UIWebView</code> is the automatic scaling of content. It can be activated by setting its <code class="literal">ScalePageToFit</code> property to <code class="literal">true</code>.</p></div><div class="section" title="UIWebView supported files"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec51"/>UIWebView supported files</h3></div></div></div><p>Apart<a id="id378" class="indexterm"/> from web pages, the <code class="literal">UIWebView</code> control can be used to display local content with the following types of files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Excel (<code class="literal">.xls</code>)</li><li class="listitem" style="list-style-type: disc">Keynote (<code class="literal">.key.zip</code>)</li><li class="listitem" style="list-style-type: disc">Numbers (<code class="literal">.numbers.zip</code>)</li><li class="listitem" style="list-style-type: disc">Pages (<code class="literal">.pages.zip</code>)</li><li class="listitem" style="list-style-type: disc">PDF (<code class="literal">.pdf</code>)</li><li class="listitem" style="list-style-type: disc">Powerpoint (<code class="literal">.ppt</code>)</li><li class="listitem" style="list-style-type: disc">Word (<code class="literal">.doc</code>)</li><li class="listitem" style="list-style-type: disc">Rich Text Format (<code class="literal">.rtf</code>)</li><li class="listitem" style="list-style-type: disc">Rich Text Format Directory (<code class="literal">.rtfd.zip</code>)</li><li class="listitem" style="list-style-type: disc">Keynote (<code class="literal">.key</code>)</li><li class="listitem" style="list-style-type: disc">Numbers (<code class="literal">.numbers</code>)</li><li class="listitem" style="list-style-type: disc">Pages (<code class="literal">.pages</code>)</li></ul></div></div></div></div>
<div class="section" title="Displaying data in a grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Displaying data in a grid</h1></div></div></div><p>In this recipe, we will discuss using the <code class="literal">UICollectionView</code> object to display data in a grid-like layout. The <code class="literal">UICollectionView</code> class was introduced in iOS 6, and is a very useful<a id="id379" class="indexterm"/> control that was missed by iOS developers. Prior to <code class="literal">UICollectionView</code>, the only way to display data in a grid was to create a custom control, which <a id="id380" class="indexterm"/>was not a very easy task.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec200"/>Getting ready</h2></div></div></div><p>Create a new project in Xamarin Studio and name it <code class="literal">CollectionViewApp</code>. We will also need something to display, so add an image to the project.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec201"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">CollectionViewAppViewController.xib</code> file in Interface Builder and add a <code class="literal">UICollectionView</code> on its main view. The following screenshot shows the object in the object browser:<div class="mediaobject"><img src="graphics/8924OT_05_08.jpg" alt="How to do it..."/></div></li><li class="listitem">Back <a id="id381" class="indexterm"/>in Xamarin Studio, add the following class:<div class="informalexample"><pre class="programlisting">public class ImageCell : UICollectionViewCell {
  public const string CELLID = "ImageCell";
  public ImageCell(IntPtr handle) : base(handle) {
    this.Initialize();
  }
  public UIImageView ImageView { get; private set; }
  private void Initialize() {
    this.ImageView = new UIImageView(this.ContentView.Bounds);
    this.ContentView.AddSubview(this.ImageView);
  }
}</pre></div></li><li class="listitem">Add the <a id="id382" class="indexterm"/>following nested class in the controller:<div class="informalexample"><pre class="programlisting">private class CollectionSource : UICollectionViewSource {
  public CollectionSource(CollectionViewAppViewController parentController) {
    this.parentController = parentController;
  }
  private CollectionViewAppViewController parentController;
  public override int GetItemsCount(UICollectionView collectionView, int section) {
    return this.parentController.collectionData.Count;
  }
  public override UICollectionViewCell GetCell(UICollectionView collectionView, NSIndexPath indexPath) {
    ImageCell cell = (ImageCell)collectionView.DeqeueReusableCell((NSString)ImageCell.Cell, indexPath);
    cell.ImageView.Image = this.parentController.collectionData[indexPath.Row];
    return cell;
  }
}</pre></div></li><li class="listitem">Add <a id="id383" class="indexterm"/>the<a id="id384" class="indexterm"/> following code in the controller:<div class="informalexample"><pre class="programlisting">private List&lt;UIImage&gt; collectionData;
public override ViewDidLoad() {
  base.ViewDidLoad();
  this.collectionData = new List&lt;UIImage&gt;();
  for (int i = 0; i &lt; 30; i++) {
    this.collectionData.Add(UIImage.FromBundle("shapes"));
  }
  this.collectionView.RegisterClassForCell(typeof(ImageCell), (NSString)ImageCell.CELLID);
  this.collectionView.Source = new CollectionSource(this);
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. The result should be similar to the one shown in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_05_09.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec202"/>How it works...</h2></div></div></div><p>The <code class="literal">UICollectionView</code> class is used in a manner that is similar to <code class="literal">UITableView</code>. The main <a id="id385" class="indexterm"/>difference is that instead of showing the data in a single <a id="id386" class="indexterm"/>column, it does so in a grid arrangement. The <code class="literal">UICollectionViewSource</code> class is overridden to provide the data source of the collection view, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private class CollectionSource : UICollectionViewSource {</pre></div><p>Just like table views in <code class="literal">UITableViewSource</code>, we need to provide the number of items in the grid and the object for single items, in this case, <code class="literal">UICollectionViewCell</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public override int GetItemsCount(UICollectionView collectionView, int section) {
  return this.parentController.collectionData.Count;
}
public override UICollectionViewCell GetCell(UICollectionView collectionView, NSIndexPath indexPath) {
  ImageCell cell = (ImageCell)collectionView.DeqeueReusableCell((NSString)ImageCell.Cell, indexPath);
  cell.ImageView.Image = this.parentController.collectionData[indexPath.Row];
  return cell;
}</pre></div><p>Note that <a id="id387" class="indexterm"/>unlike <code class="literal">UITableViewCell</code>, the <code class="literal">UICollectionViewCell</code> class doesn't offer much for us to use. So, we have to override it to create <a id="id388" class="indexterm"/>our own cell for the collection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class ImageCell : UICollectionViewCell</pre></div><p>As we are using a custom cell, we have to let the collection view know about it through the <code class="literal">RegisterClassForCell</code> method, using the following code:</p><div class="informalexample"><pre class="programlisting">this.collectionView.RegisterClassForCell(typeof(ImageCell), (NSString)ImageCell.CELLID);</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec203"/>There's more...</h2></div></div></div><p>Apart from showing individual items with the <code class="literal">UICollectionViewCell</code> class, the <code class="literal">UICollectionView</code> supports the display of supplementary views of the <code class="literal">UICollectionReusableView</code> type. These views basically represent either the header or the footer of the sections in the collection view.</p><p>To provide supplementary views, we need to create our own subclass using the following code:</p><div class="informalexample"><pre class="programlisting">public class CollectionHeader : UICollectionReusableView</pre></div><p>We then need to override the following method in the collection source (this method will return the supplementary view that we want):</p><div class="informalexample"><pre class="programlisting">public override UICollectionReusableView GetViewForSupplementaryElement(UICollectionView collectionView, NSString elementKind, NSIndexPath indexPath) {
  CollectionHeader header = (CollectionHeader)collectionView.DequeueReusableSupplementaryView(UICollectionElementKindSection.Header, viewIdentifier, indexPath);
  return header;
}</pre></div><p>The <code class="literal">elementKind</code> parameter is the <code class="literal">NSString</code> representation of the <code class="literal">UICollectionElementKindSection</code> enumeration, which contains two values: <code class="literal">Footer</code> and <code class="literal">Header</code>.</p><p>Finally, we need to call the <code class="literal">RegisterClassForSupplementaryView</code> method to register our custom class with the collection view, using the following code:</p><div class="informalexample"><pre class="programlisting">this.collectionView.RegisterClassForSupplementaryView(typeof(CollectionHeader), UICollectionElementKindSection.Header, viewIdentifier);</pre></div><div class="section" title="More information on UICollectionView"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec52"/>More information on UICollectionView</h3></div></div></div><p>A good<a id="id389" class="indexterm"/> tutorial on <code class="literal">UICollectionView</code> can be found at Xamarin's website: <a class="ulink" href="http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/">http://docs.xamarin.com/guides/ios/user_interface/introduction_to_collection_views/</a>.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec204"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying data in a table</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Customizing rows</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Customizing the grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Customizing the grid</h1></div></div></div><p>In this<a id="id390" class="indexterm"/> recipe, we will learn how to customize the display of the collection view.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec205"/>Getting ready</h2></div></div></div><p>In this recipe, we will work on the <code class="literal">CollectionViewApp</code> project we created in the <span class="emphasis"><em>Displaying data in a grid</em></span> recipe. Open the project in Xamarin Studio.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec206"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">ViewDidLoad</code> method of the controller, add the following code:<div class="informalexample"><pre class="programlisting">UICollectionViewFlowLayout flowLayout = new UICollectionViewFlowLayout();
flowLayout.MinimumLineSpacing = 20f;
flowLayout.MinimumInteritemSpacing = 4f;
flowLayout.SectionInset = new UIEdgeInset(4f, 4f, 4f, 4f);
flowLayout.ItemSize = new SizeF(20f, 20f);
this.collectionView.CollectionViewLayout = flowLayout;</pre></div></li><li class="listitem">Compile and run the app on the simulator. The result should be similar to the one <a id="id391" class="indexterm"/>shown in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_05_10.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec207"/>How it works...</h2></div></div></div><p>The collection view's layout can be customized through the <code class="literal">UICollectionViewLayout</code> class. <code class="literal">UICollectionViewFlowLayout</code> is a subclass of this class and offers a simple layout that we can use.</p><p>By setting specific properties, we define how the cells will be arranged by the collection view. The following list describes the properties we are setting in this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MinimumLineSpacing</code>: This is the smallest distance between rows in the grid</li><li class="listitem" style="list-style-type: disc"><code class="literal">MinimumInteritemSpacing</code>: This is the smallest distance between individual items in the grid</li><li class="listitem" style="list-style-type: disc"><code class="literal">SectionInset</code>: This is the area around each section in the collection view that should be left blank</li><li class="listitem" style="list-style-type: disc"><code class="literal">ItemSize</code>: This is the size of each item in the collection view</li></ul></div><p>The <a id="id392" class="indexterm"/>following image shows what each property corresponds to in the collection view:</p><div class="mediaobject"><img src="graphics/8924OT_05_11_diagram.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec208"/>There's more...</h2></div></div></div><p>Setting the <code class="literal">ItemSize</code> parameter of the collection layout object will adjust the size of all the items in the collection view. We can set the size for every cell individually by providing the following method in the <code class="literal">CollectionSource</code> subclass:</p><div class="informalexample"><pre class="programlisting">[Export("collectionView:layout:sizeForItemAtIndexPath:")]
public SizeF GetSizeForItem(UICollectionView collectionView, UICollectionViewLayout layout, NSIndexPath indexPath) {
  if (indexPath.Item &gt; 11 &amp;&amp; indexPath.Item &lt; 19) {
    return new SizeF(40f, 40f);
  } else {
    return new SizeF(20f, 20f);
  }
}</pre></div><p>Adding<a id="id393" class="indexterm"/> the preceding method to our own <code class="literal">CollectionSource</code> subclass would give the result shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8924OT_05_12.jpg" alt="There's more..."/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec209"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying data in a grid</em></span> recipe </li></ul></div></div></div></body></html>