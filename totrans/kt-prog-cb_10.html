<html><head></head><body><div><h1 class="header-title">Databases and Dependency Injection</h1>
                
            
            
                
<p class="mce-root">The following recipes will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400">Using SQLite database in Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">Creating database tables</li>
</ul>
<ul>
<li style="font-weight: 400">Injecting dependencies in Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">Reading data from database</li>
</ul>
<ul>
<li style="font-weight: 400">Converting database cursor into list of objects</li>
</ul>
<ul>
<li style="font-weight: 400">Using parseOpt for nullable objects</li>
</ul>
<ul>
<li style="font-weight: 400">Inserting data into database</li>
</ul>
<ul>
<li style="font-weight: 400">Creating singletons in Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">Using Dagger2 with Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">Using Butterknife with Kotlin</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>When we develop an app, we should bear in mind those situations when the app won't be connected to the internet. The user might be in an elevator or there might not be any network coverage when they try to use the app. To provide a great user experience, we need to ensure that some parts our app work even when there isn't any network connection. To be able to do this, we need a persistent storage mechanism in our app. It can be achieved by either using shared preferences or using the database. Shared preferences can come in handy when we have small amounts of data such as the app's setting values. Databases are much more powerful for situations when we need to store structured data. In this chapter, we will learn how to use Android's built-in database SQLite and will also learn about dependency injection with Dagger2, which is considered among the best practices for developing a quality app.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using SQLite database in Kotlin</h1>
                
            
            
                
<p>SQLite is a relational database. Android comes with a built-in SQLite database. It is an open source SQL database and is widely used in Android apps. However, doing it in a raw manner is very time-consuming and eats up a lot of development and testing time. You have to work with cursors, iterate over them row by row, and wrap code in <kbd>try-finally</kbd>, and such. Of course, you can use libraries that provide ORM mapping, which makes it easier to deal with a SQLite database, but if the database is small, it is expensive and is generally overkill. Kotlin, with Anko, provides a really easy way to deal with SQLite database. So let's get to work and see how we can use SQLite database in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll be using Android Studio 3.0 for coding. First, we need to add anko-sqlite to our <kbd>build.gradle</kbd> file:</p>
<pre>dependencies {
    compile "org.jetbrains.anko:anko-sqlite:$anko_version"
}</pre>
<p>You can replace <kbd>$anko_version</kbd> with the latest version of the library.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Anko provides a wrapper around our built-in SQLite API, which helps eliminate a lot of boilerplate code and also adds safety mechanisms such as closing the database after the code execution is complete and more.</p>
<p class="mce-root">While implementing a SQLite database, the first step is to create the database helper class. In this case, we need the class to extend the <kbd>ManagedSQLiteOpenHelper</kbd> class instead of the <kbd>SQLiteOpenHelper</kbd> class, which we used to do. <kbd>ManagedSQLiteOpenHelper</kbd> is concurrency aware and closes the database at the end of query executions.<br/>
Check out the following code for a simple database helper that I am using for this example:</p>
<pre>class DatabaseHelper(ctx: Context) : ManagedSQLiteOpenHelper(ctx, "SupportDatabase", null, 1) {<br/>    companion object {<br/>        private var instance: DatabaseHelper? = null<br/><br/>        @Synchronized<br/>        fun getInstance(context: Context): DatabaseHelper {<br/>            if (instance == null) {<br/>                instance = DatabaseHelper(context.applicationContext)<br/>            }<br/>            return instance!!<br/>        }<br/>    }<br/><br/>    override fun onCreate(db: SQLiteDatabase) {<br/>        db.createTable("Requests", true,<br/>                "id" to INTEGER + PRIMARY_KEY + UNIQUE,<br/>                "name" to TEXT,<br/>                "message" to TEXT)<br/>    }<br/><br/>    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {<br/>        db.dropTable("Requests", true)<br/>    }<br/>}</pre>
<p>So basically, in <kbd>onCreate</kbd>, we create tables and in <kbd>onUpgrade</kbd>, we upgrade tables. <br/>
I am creating a single table in my database, which is <kbd>Requests</kbd>. In the <kbd>Requests</kbd> table, we have the <kbd>name</kbd>, <kbd>message</kbd>, and <kbd>id</kbd> fields as primary keys.</p>
<p class="mce-root">We can provide access to the database by adding it as an extension property to the context. This allows access to the database by any class that requires context. The following code adds the database as an extension property to the context:</p>
<pre>// Access property for Context<br/>val Context.database: DatabaseHelper<br/>    get() = DatabaseHelper.getInstance(getApplicationContext())</pre>
<p>I added the preceding code to the same file as that of the database helper, outside the class.</p>
<p>Now, here's my code for the activity, where I have fields for a name and message and on pressing the Enter button, the details are stored in the database:</p>
<pre>class MainActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        MainActivityUI().setContentView(this)<br/>        <strong>btn_send.onClick {</strong><br/><strong>            database.use {</strong><br/><strong>                insert("Requests",</strong><br/><strong>                        "id" to 1,</strong><br/><strong>                        "name" to name.text.toString(),</strong><br/><strong>                        "message" to message.text.toString())</strong><br/><strong>            }</strong><br/><strong>        }</strong><br/>    }<br/><br/>    class MainActivityUI : AnkoComponent&lt;MainActivity&gt; {<br/>        override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) {<br/>            verticalLayout {<br/>                gravity = Gravity.CENTER<br/>                padding = dip(20)<br/><br/>                textView {<br/>                    gravity = Gravity.CENTER<br/>                    text = "Enter your request"<br/>                    textColor = Color.BLACK<br/>                    textSize = 24f<br/>                }.lparams(width = matchParent) {<br/>                    margin = dip(20)<br/>                }<br/><br/>                val name = editText {<br/>                    id = R.id.name<br/>                    hint = "What is your name?"<br/>                }<br/><br/>                editText {<br/>                    id = R.id.message<br/>                    hint = "What is your message?"<br/>                    lines = 3<br/>                }<br/><br/>                button("Enter") {<br/>                    id = R.id.btn_send<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>Note the code in bold. So basically, we can perform operations on the database inside the use block. The database will be opened at the beginning of the use block and closed after its execution. </p>
<p>The following screenshot is how our layout looks:</p>
<div><img height="1282" width="722" src="img/a522b58a-b12c-4b18-9dec-7f7953ce331d.jpeg"/> </div>
<p>Now try to put something in the database. Here's a screenshot of my database, and the insert operation worked:</p>
<div><img src="img/da4899d4-09cb-4571-a6ff-bb4207b30bcc.png" width="812" height="374"/></div>
<p>I am using Stetho (<a href="https://github.com/facebook/stetho">https://github.com/facebook/stetho</a>) to view the database in Chrome dev tools.</p>
<p>For the layout of the activity, I have used Anko DSL layouts. You can refer to <a href="https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/52df376c-f81c-4fee-b607-3c954d405230.xhtml" target="_blank">Chapter 9</a>, <em>Anko Layouts</em>, of this book to learn more about them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating database tables</h1>
                
            
            
                
<p>Now that you have learned how to add anko-sqlite dependencies to your project and how to use SQLite database in the first recipe, the next step is learning how to create database tables.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll be using Android Studio 3 for coding. Ensure that you have added anko-sqlite to your <kbd>build.gradle</kbd> file and gone through the first recipe on how to use a SQLite database.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>We will be creating two tables: <kbd>Requests</kbd> and <kbd>customers</kbd>:</p>
<ol>
<li>For the <kbd>Requests</kbd> table, we have the <kbd>name</kbd> and <kbd>message</kbd> fields, and we can directly create them in the <kbd>onCreate</kbd> method of our database helper, as shown:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">db.createTable("Requests", true,<br/>    "id" to INTEGER + PRIMARY_KEY + UNIQUE,<br/>    "name" to TEXT,<br/>    "message" to TEXT)</pre>
<ol start="2">
<li class="mce-root">For the <kbd>customers</kbd> table, we will be using a better coding practice by making a data class and using it to define the columns of the <kbd>customers</kbd> table.<br/>
Given here is the code for our <kbd>Customer</kbd> data class:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">data class Customer(val id: Int, val name: String, val phone_num: String) {<br/>    companion object {<br/>        val COLUMN_ID = "id"<br/>        val TABLE_NAME = "customers"<br/>        val COLUMN_NAME = "name"<br/>        val COLUMN_PHONE_NUM = "phone_num"<br/>    }<br/>}</pre>
<ol start="3">
<li class="mce-root">Now, we will use this data class to create our table like this:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">db.createTable(Customer.TABLE_NAME,<br/>        true,<br/>        Customer.COLUMN_ID to INTEGER + PRIMARY_KEY,<br/>        Customer.COLUMN_NAME to TEXT,<br/>        Customer.COLUMN_PHONE_NUM to TEXT)</pre>
<ol start="4">
<li class="mce-root">The following is how our database helper finally looks after filling in the code for drop tables:</li>
</ol>
<pre style="padding-left: 60px">class DatabaseHelper(ctx: Context) : ManagedSQLiteOpenHelper(ctx, "SupportDatabase", null, 1) {<br/>    companion object {<br/>        private var instance: DatabaseHelper? = null<br/><br/>        @Synchronized<br/>        fun getInstance(context: Context): DatabaseHelper {<br/>            if (instance == null) {<br/>                instance = DatabaseHelper(context.applicationContext)<br/>            }<br/>            return instance!!<br/>        }<br/>    }<br/><br/>    override fun onCreate(db: SQLiteDatabase) {<br/>        <strong>db.createTable("Requests", true,</strong><br/><strong>                "id" to INTEGER + PRIMARY_KEY + UNIQUE,</strong><br/><strong>                "name" to TEXT,</strong><br/><strong>                "message" to TEXT)</strong><br/><br/><strong>        db.createTable(Customer.TABLE_NAME,</strong><br/><strong>                true,</strong><br/><strong>                Customer.COLUMN_ID to INTEGER + PRIMARY_KEY,</strong><br/><strong>                Customer.COLUMN_NAME to TEXT,</strong><br/><strong>                Customer.COLUMN_PHONE_NUM to TEXT)</strong><br/>    }<br/><br/>    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {<br/>        db.dropTable("Requests", true)<br/>        db.dropTable(Customer.TABLE_NAME, true)<br/>    }<br/>}<br/><br/>// Access property for Context<br/>val Context.database: DatabaseHelper<br/>    get() = DatabaseHelper.getInstance(getApplicationContext())</pre>
<ol start="5">
<li>Now, let's do a fresh install of our app and see whether the two tables have been formed in our database. The following is how our database screenshot looks (using Stetho), and our tables have successfully been created:</li>
</ol>
<div><img height="478" width="414" src="img/ec9fe063-9d31-49f3-8124-91cf8e725368.png"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Injecting dependencies in Kotlin</h1>
                
            
            
                
<p>In Android development, Dagger 2 is the most popular dependency injection framework. You define the dependency objects, and with the help of a Dagger component, you inject it where you want. In this recipe, we will see how to inject the dependencies. We won't be going into the details of how to work with Dagger 2 in detail; for that, you can refer to the <em>Using Dagger2 with Kotlin</em> recipe in this chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using Android Studio 3.0 for this recipe. Ensure that you have its latest version.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>When you've defined all the dependency objects you need in the module class, you can get the component. Let's take look at the mentioned steps:</p>
<ol>
<li>To inject the object, you just need to add the <kbd>@Inject</kbd> annotation before the variable, then the object will be injected there. Let’s look at the following example:</li>
</ol>
<pre style="padding-left: 60px">@Inject<br/>lateinit var mPresenter:AddActivityMvpPresenter</pre>
<p style="padding-left: 60px">We have also used the <kbd>lateinit</kbd> modifier to void null checks before using the variable.</p>
<ol start="2">
<li>Another way to do it is by constructor injection. To understand it, let’s take a look at the given code:</li>
</ol>
<pre style="padding-left: 60px">@Module<br/>class AddActivityModule {<br/>  @Provides @ControllerScope<br/>  fun providesAddActivityPresenter(addActivityPresenter: AddActivityPresenter):AddActivityMvpPresenter =addActivityPresenter<br/>}</pre>
<ol start="3">
<li>As you can see, we have sent <kbd>AddActivityPresenter</kbd> in the <kbd>providesAddActivityPresenter</kbd>, but the module doesn’t provide it. This usually won’t work unless you provide <kbd>AddActivityPresnter</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">class AddActivityPresenter @Inject constructor(var mDataManager:DataManager):AddActivityMvpPresenter</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>When you use the <kbd>@Inject</kbd> annotation in the constructor, it means that the class needs the <kbd>DataManager</kbd> object before it can be created. Dagger2 will look into the dependency tree and provide you the dependency if it can.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reading data from database</h1>
                
            
            
                
<p>Now that we have seen how to create a database and how to create tables, let's learn how to read from a database.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies to your project and creating a SQLite database with the <kbd>Requests</kbd> table in it by going through and implementing the <em>Using SQLite database in Kotlin</em> recipe in this chapter. By using the form we created in this recipe, add some data to your <kbd>Requests</kbd> table.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's take look at the given steps to understand how to read data from the database:</p>
<ol>
<li>Now, let's add a button to our existing layout from the first recipe; on clicking, it should retrieve all data from our <kbd>Requests</kbd> table. Check out the updated code, which is as follows, where I have added a button with a click listener on it:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        MainActivityUI().setContentView(this)<br/>        val btn_send = find&lt;Button&gt;(R.id.btn_send)<br/>        btn_send.onClick {<br/>            database.use {<br/>                insert("Requests",<br/>                        "name" to name.text.toString(),<br/>                        "message" to message.text.toString())<br/>            }<br/>            toast("success")<br/>            name.text.clear()<br/>            message.text.clear()<br/>        }<br/>        val btn_read = find&lt;Button&gt;(R.id.btn_read)<br/>        btn_read.onClick {<br/>            <strong>var reqs = database.use {<br/>                select("Requests").parseList(classParser&lt;Request&gt;())</strong><br/><strong>            }<br/>            for(x in reqs) {</strong><br/><strong>                logd(x.name + ": " + x.message)</strong><br/><strong>            }</strong><br/>        }<br/>    }<br/><br/>    private fun logd(s: String) {<br/>        Log.d("request", s)<br/>    }<br/><br/>    class MainActivityUI : AnkoComponent&lt;MainActivity&gt; {<br/>        override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) {<br/>            verticalLayout {<br/>                padding = dip(20)<br/><br/>                textView {<br/>                    gravity = Gravity.CENTER<br/>                    text = "Enter your request"<br/>                    textColor = Color.BLACK<br/>                    textSize = 24f<br/>                }.lparams(width = matchParent) {<br/>                    margin = dip(20)<br/>                }<br/><br/>                val name = editText {<br/>                    id = R.id.name<br/>                    hint = "What is your name?"<br/>                }<br/><br/>                editText {<br/>                    id = R.id.message<br/>                    hint = "What is your message?"<br/>                    lines = 3<br/>                }<br/><br/>                button("Enter") {<br/>                    id = R.id.btn_send<br/>                }<br/><br/>                button("Show me requests") {<br/>                    id = R.id.btn_read<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    class Request(val id: Int, val name: String, val message: String)<br/><br/>}</pre>
<ol start="2">
<li>I am using Anko DSL to create the layout for my activity. As we discussed in previous recipes, we do all database operations inside the <kbd>database.use{...}</kbd> block. To read data from the database, we use the <kbd>select</kbd> function. The syntax is this:</li>
</ol>
<pre style="padding-left: 60px">db.select(tableName, vararg columns) // where db is an instance of the SQLiteDatabase</pre>
<ol start="3">
<li class="mce-root">Inside <kbd>database.use {...}</kbd> , <kbd>this</kbd> is the database instance, so we can directly use methods such as <kbd>select</kbd> and <kbd>insert</kbd>. The following is the data and the output in the database table:</li>
</ol>
<p style="padding-left: 60px">This is the data:</p>
<div><img src="img/b46f6904-b0f4-486a-b351-e9503fcf68ec.png" width="811" height="262"/></div>
<p style="padding-left: 60px">Here's the output:</p>
<pre style="padding-left: 60px"><strong>11-18 18:21:34.709 12523-12523/android.my_company.com.helloworldapp D/request: name 1: request 1</strong><br/><strong>11-18 18:21:34.709 12523-12523/android.my_company.com.helloworldapp D/request: name 2: request 2</strong><br/><strong>11-18 18:21:34.709 12523-12523/android.my_company.com.helloworldapp D/request: name 3 : request 3</strong></pre>
<ol start="4">
<li>There's a lot more we can do with the query builder; listed here are the methods provided by Anko:
<ul>
<li><kbd>column(String)</kbd>: used to add a column to our <kbd>select</kbd> query</li>
<li><kbd>distinct(Boolean)</kbd>: used to add distinct to the query</li>
<li><kbd>whereArgs(String)</kbd>: used to specify the raw <kbd>where</kbd> string</li>
<li><kbd>whereArgs(String, args)</kbd>: used to specify the <kbd>where</kbd> query and corresponding arguments</li>
<li><kbd>whereSimple(String, args) </kbd>: used to specify a <kbd>where</kbd> query with the <kbd>?</kbd> marks and corresponding arguments for <kbd>?</kbd></li>
<li><kbd>orderBy(String, [ASC/DESC])</kbd>  : used to specify a column for order by</li>
<li><kbd>groupBy(String)</kbd>: used to specify a column for group by</li>
<li><kbd>limit(count: Int)</kbd>: used to limit the number of rows returned by the query</li>
<li><kbd>limit(offset: Int, count: Int)</kbd>: used to limit the number of rows returned by the query after an <kbd>offset</kbd></li>
<li><kbd>having(String)</kbd>: used to specify the raw <kbd>having</kbd> expression</li>
<li><kbd>having(String, args)</kbd>: used to specify the raw <kbd>having</kbd> expression with arguments</li>
</ul>
</li>
<li>Let's try another example. In this example, we will select data from a database using the <kbd>where</kbd> clause:</li>
</ol>
<pre style="padding-left: 60px">select("Requests")<br/>    .whereArgs("(id &gt; {userId})",<br/>        "userId" to 1)</pre>
<p style="padding-left: 60px">Here's the output of the preceding query:</p>
<pre style="padding-left: 60px"><strong>11-18 21:11:04.328 18149-18149/android.my_company.com.helloworldapp D/request: name 2: request 2</strong><br/><strong>11-18 21:11:04.329 18149-18149/android.my_company.com.helloworldapp D/request: name 3 : request 3</strong></pre>
<ol start="6">
<li>After getting the query results, we also need to parse the result. We get a cursor as a result from the query and using methods provided by Anko, we can easily parse them into regular classes. In the preceding example, we made a class named <kbd>Request</kbd>:</li>
</ol>
<pre style="padding-left: 60px">class Request(val id: Int, val name: String, val message: String)</pre>
<ol start="7">
<li>The class has all the fields that we may get as columns from our query result cursor. The following are the methods that we can use for parsing results:
<ul>
<li><kbd>parseSingle(rowParser): T</kbd> : Parses exactly and only one row; if there's more than one row in the cursor, then it throws an exception</li>
<li><kbd>parseOpt(rowParser): T?</kbd> : Parses zero or one row, but if there's more than one row in the cursor, then it throws an exception</li>
<li><kbd>parseList(rowParser): List&lt;T&gt;</kbd>  : Parses zero or more rows</li>
</ul>
</li>
</ol>
<p>We used <kbd>parseList</kbd> in the preceding example. You can pass row parsers or map parsers, and you can also use <kbd>classParser</kbd> of the type of your custom class, which passes a row parser, like this:</p>
<div><pre>val rowParser = classParser&lt;Person&gt;()</pre></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting database cursor into list of objects</h1>
                
            
            
                
<p>In the previous recipe, we learned how to query data from a database table. We receive a cursor as result of the query. In this recipe, we will learn how to use <kbd>parseList</kbd> to convert the cursor into a list of objects.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies to your project and creating a database helper like we did in the <em>Using SQLite database in Kotlin</em> recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Follow these steps to convert the cursor into a list of objects:</p>
<ol>
<li>Let's start by creating a <kbd>Customer</kbd> class as a model for our <kbd>customers</kbd> table:</li>
</ol>
<pre style="padding-left: 60px">data class Customer(val id: Int, val name: String, val phone_num: String) {<br/>    companion object {<br/>        val COLUMN_ID = "id"<br/>        val TABLE_NAME = "customers"<br/>        val COLUMN_NAME = "name"<br/>        val COLUMN_PHONE_NUM = "phone_num"<br/>    }<br/>}</pre>
<ol start="2">
<li>Now we will write code to create the <kbd>customers</kbd> table inside the database helper class. Check out the following code:</li>
</ol>
<pre style="padding-left: 60px">class DatabaseHelper(ctx: Context) : ManagedSQLiteOpenHelper(ctx, "SupportDatabase", null, 1) {<br/>    companion object {<br/>        private var instance: DatabaseHelper? = null<br/><br/>        @Synchronized<br/>        fun getInstance(context: Context): DatabaseHelper {<br/>            if (instance == null) {<br/>                instance = DatabaseHelper(context.applicationContext)<br/>            }<br/>            return instance!!<br/>        }<br/>    }<br/><br/>    override fun onCreate(db: SQLiteDatabase) {<br/>        db.createTable(Customer.TABLE_NAME,<br/>                true,<br/>                Customer.COLUMN_ID to INTEGER + PRIMARY_KEY,<br/>                Customer.COLUMN_NAME to TEXT,<br/>                Customer.COLUMN_PHONE_NUM to TEXT)<br/>    }<br/><br/>    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {<br/>        db.dropTable(Customer.TABLE_NAME, true)<br/>    }<br/>}<br/><br/>// Access property for Context<br/>val Context.database: DatabaseHelper<br/>    get() = DatabaseHelper.getInstance(getApplicationContext())</pre>
<ol start="3">
<li>Now, we will create a form to enter customers and a button that shows all customers in the database table using the <kbd>select</kbd> function. We will use the <kbd>parseList</kbd> method to get rows in the resulting cursor as a <kbd>List</kbd>. We need to pass in a row parser or map parser inside the <kbd>parseList</kbd> method. The easiest way of doing this is using <kbd>classParser</kbd> provided by Anko and using our <kbd>Customer</kbd> class constructor to get a row parser, like this:</li>
</ol>
<pre style="padding-left: 60px">var customers = database.use {<br/>    select(Customer.TABLE_NAME)<br/>    .parseList(classParser&lt;Customer&gt;())<br/>}</pre>
<p>I suggest that you try this exercise on your own before moving to the solution.</p>
<p>The following is my version of the activity that also contains DSL layout:</p>
<pre>class MainActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        MainActivityUI().setContentView(this)<br/>        val name = find&lt;EditText&gt;(R.id.name)<br/>        val phone = find&lt;EditText&gt;(R.id.phone)<br/>        btn_send.onClick {<br/>            database.use {<br/>                insert(Customer.TABLE_NAME,<br/>                        Customer.COLUMN_NAME to name.text.toString(),<br/>                        Customer.COLUMN_PHONE_NUM to phone.text.toString())<br/>            }<br/>            toast("success")<br/>            name.text.clear()<br/>            phone.text.clear()<br/>        }<br/>        val btn_read = find&lt;Button&gt;(R.id.btn_read)<br/>        btn_read.onClick {<br/>            <strong>var customers = database.use {<br/>                select(Customer.TABLE_NAME)<br/>                        .parseList(classParser&lt;Customer&gt;())</strong><br/><strong>            }<br/>            // customers is the list of objects which we can now iterate on to get individual values as objects of Customer class<br/>            for(c in customers) {</strong><br/><strong>                debug(c.name + " (" + c.phone_num + ")")</strong><br/><strong>            }</strong><br/>        }<br/>    }<br/><br/>    private fun debug(s: String) {<br/>        Log.d("customer", s)<br/>    }<br/><br/>    class MainActivityUI : AnkoComponent&lt;MainActivity&gt; {<br/>        override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) {<br/>            verticalLayout {<br/>                padding = dip(20)<br/><br/>                textView {<br/>                    gravity = Gravity.CENTER<br/>                    text = "Enter the customer"<br/>                    textColor = Color.BLACK<br/>                    textSize = 24f<br/>                }.lparams(width = matchParent) {<br/>                    margin = dip(20)<br/>                }<br/><br/>                val name = editText {<br/>                    id = R.id.name<br/>                    hint = "Name"<br/>                }<br/><br/>                editText {<br/>                    id = R.id.phone<br/>                    hint = "Phone no."<br/>                }<br/><br/>                button("Enter") {<br/>                    id = R.id.btn_send<br/>                }<br/><br/>                button("Show me customers") {<br/>                    id = R.id.btn_read<br/>                }<br/><br/>                button("Delete all customers") {<br/>                    id = R.id.btn_delete<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The result of the query, that is, <kbd>customers</kbd>, is the list of objects that we can now iterate on to get individual rows as objects of the <kbd>Customer</kbd> class.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using parseOpt for nullable object</h1>
                
            
            
                
<p>We use <kbd>parseList</kbd> when we get multiple rows in our cursor, but when we get only one row, we use <kbd>parseSingle</kbd> or <kbd>parseOpt</kbd>. However, what is the difference between <kbd>parseSingle</kbd> and <kbd>parseOpt</kbd>?  In this recipe, we will understand the difference between both and when to use which one.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies to your project and creating a database helper, like we did in the <em>Using SQLite database in Kotlin</em> recipe. You will need to read and implement the previous recipe to be able to follow this recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>If you have read and implemented the previous recipe, you must already have a <kbd>customers</kbd> table in your database. Follow the mentioned steps to understand the difference between <kbd>parseSingle</kbd> and <kbd>parseOpt</kbd>:</p>
<ol>
<li>In the previous recipe, we used <kbd>parseList</kbd> to get a list of rows as objects. If we need to get only a single row as an object, then we need to use <kbd>parseSingle</kbd>. The following is the syntax of <kbd>parseSingle</kbd>:</li>
</ol>
<pre style="padding-left: 60px">parseSingle(rowParser): T</pre>
<ol start="2">
<li>Now we use it in the following way in our previous code:</li>
</ol>
<pre style="padding-left: 60px">btn_read.onClick {<br/>    var c = database.use {<br/>        select(Customer.TABLE_NAME)<br/>            .whereArgs("(id = {userId})",<br/>            "userId" to 1)<br/><strong>            .parseSingle(classParser&lt;Customer&gt;())</strong><br/>    }<br/>    debug(c.name + " (" + c.phone_num + ")")<br/>}</pre>
<ol start="3">
<li>We are using <kbd>parseSingle</kbd> because we will only get one row in the cursor, but if we get zero rows from the cursor, that is, we get an empty cursor, then we get an exception:</li>
</ol>
<pre style="padding-left: 60px">android.database.sqlite.SQLiteException: parseSingle accepts only cursors with a single entry</pre>
<p>However, what if there is a possibility of getting an empty cursor when we are expecting a cursor with a single row? It will always throw an exception, that is, when we use <kbd>parseOpt</kbd>; <kbd>parseOpt</kbd> accepts zero or one rows of cursors. Also, if <kbd>parseOpt</kbd> gets a null object, it handles the scenario accordingly by giving the value of <kbd>null</kbd> for each column. Basically, <kbd>parseOpt</kbd> is used for cursors that can be empty and objects that can be <kbd>null</kbd>.</p>
<p>The syntax for <kbd>parseOpt</kbd> is as follows:</p>
<p><kbd>parseOpt(rowParser): T?</kbd> // The <kbd>?</kbd> denotes that the object returned is nullable.</p>
<p>Here's how we will use it in our code:</p>
<pre>btn_read.onClick {<br/>    var c = database.use {<br/>        select(Customer.TABLE_NAME)<br/>            .whereArgs("(id = {userId})",<br/>            "userId" to 1)<br/><strong>            .parseOpt(classParser&lt;Customer&gt;())</strong><br/>    }<br/>    debug(c?.name + " (" + c?.phone_num + ")")<br/>}</pre>
<p>Now even if the cursor returned is empty, we do not get an exception, and <kbd>null</kbd> values are printed as output.</p>
<p>This is the output in case of an empty table:</p>
<pre><strong>11-18 21:11:04.329 18149-18149/android.my_company.com.helloworldapp D/customer: null (null)</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Inserting data into database</h1>
                
            
            
                
<p>Inserting data into the database using Anko SQLite is a piece of cake. In this recipe, we will learn how to do that.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies to your project by adding the following lines to your <kbd>build.gradle</kbd> file:</p>
<pre>dependencies {
    compile "org.jetbrains.anko:anko-sqlite:$anko_version"
}</pre>
<p>You can replace <kbd>$anko_version</kbd> with the latest version of the library.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's insert data into our database by following the mentioned steps:</p>
<ol>
<li>Let's start with our database helper, in which we will be creating a <kbd>Requests</kbd> table with the <kbd>name</kbd>, <kbd>message</kbd>, and <kbd>id</kbd> fields, as follows:</li>
</ol>
<pre style="padding-left: 60px">class DatabaseHelper(ctx: Context) : ManagedSQLiteOpenHelper(ctx, "SupportDatabase", null, 1) {<br/>    companion object {<br/>        private var instance: DatabaseHelper? = null<br/><br/>        @Synchronized<br/>        fun getInstance(context: Context): DatabaseHelper {<br/>            if (instance == null) {<br/>                instance = DatabaseHelper(context.applicationContext)<br/>            }<br/>            return instance!!<br/>        }<br/>    }<br/><br/>    override fun onCreate(db: SQLiteDatabase) {<br/>        db.createTable("Requests", true,<br/>                "id" to INTEGER + PRIMARY_KEY + UNIQUE + AUTOINCREMENT,<br/>                "name" to TEXT,<br/>                "message" to TEXT)<br/>    }<br/><br/>    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {<br/>        db.dropTable("Requests", true)<br/>    }<br/>}<br/><br/>// Access property for Context<br/>val Context.database: DatabaseHelper<br/>    get() = DatabaseHelper.getInstance(getApplicationContext())</pre>
<ol start="2">
<li>Now, let's create an activity with a form that takes the name and message and stores it in the database. I am using Anko DSL layouts for the layout of the activity:</li>
</ol>
<pre style="padding-left: 60px">class MainActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        MainActivityUI().setContentView(this)<br/>        btn_send.onClick {<br/>            <strong>database.use {</strong><br/><strong>                insert("Requests",</strong><br/><strong>                        "name" to name.text.toString(),</strong><br/><strong>                        "message" to message.text.toString())</strong><br/><strong>            }</strong><br/>            toast("success")<br/>            name.text.clear()<br/>            message.text.clear()<br/>        }<br/>    }<br/><br/>    class MainActivityUI : AnkoComponent&lt;MainActivity&gt; {<br/>        override fun createView(ui: AnkoContext&lt;MainActivity&gt;) = with(ui) {<br/>            verticalLayout {<br/>                padding = dip(20)<br/><br/>                textView {<br/>                    gravity = Gravity.CENTER<br/>                    text = "Enter your request"<br/>                    textColor = Color.BLACK<br/>                    textSize = 24f<br/>                }.lparams(width = matchParent) {<br/>                    margin = dip(20)<br/>                }<br/><br/>                val name = editText {<br/>                    id = R.id.name<br/>                    hint = "What is your name?"<br/>                }<br/><br/>                editText {<br/>                    id = R.id.message<br/>                    hint = "What is your message?"<br/>                    lines = 3<br/>                }<br/><br/>                button("Enter") {<br/>                    id = R.id.btn_send<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>Note the code in bold in the preceding code snippet. We will do all operations inside the <kbd>database.use {...}</kbd> block, because it is concurrency safe and also closes the database after execution of the block. If you have gone through the <em>Creating database tables</em> recipe, you will note that table creation and insertion is quite similar. The syntax is this:</li>
</ol>
<pre style="padding-left: 60px">db.insert(TABLE_NAME, <br/>    COLUMN_NAME_1 to VALUE_1,<br/>    COLUMN_NAME_2 to VALUE_2,<br/>    COLUMN_NAME_3 to VALUE_3<br/>)</pre>
<p>This is our layout:</p>
<div><img height="1282" width="722" src="img/2c7459ff-469b-44d1-9cc7-3a6d8bda109c.jpeg"/></div>
<p>On entering the data, we can check whether our name and message are being stored in our database or not. I am using Stetho to view the database on my device.</p>
<div><img src="img/0a67fa84-0ab5-4579-b89f-319c062d8780.png" width="813" height="374"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating singletons in Kotlin</h1>
                
            
            
                
<p>A singleton class is a class that can have only one instance/object of that class at a time. The concept is to restrict instantiation of objects to a certain number. In this recipe, we will explore singletons in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3 to write code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Follow these steps to create singletons in Kotlin:</p>
<ol>
<li class="mce-root">Kotlin does not have static members or variables, so for declaring static members of a class, we use <kbd>companion object</kbd>. Check out this example:</li>
</ol>
<pre style="padding-left: 60px">class SomeClass {<br/><br/>    companion object {<br/>        var intro = "I am some class. Pleased to meet you!"<br/>        fun infoIntro(): String {<br/>            return "I am some class. Pleased to meet you!"<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Accessing the members and methods of <kbd>companion</kbd> object of the preceding class is the same as we would do for any static members or methods:</li>
</ol>
<pre style="padding-left: 60px">var x = SomeClass.intro<br/>toast(SomeClass.infoIntro())</pre>
<ol start="3">
<li>Now what if we want a singleton class, that is, the class with only one object/instance at a time? Brace yourselves, this one is fun. Here's a way to create a singleton class in just a few lines:</li>
</ol>
<pre style="padding-left: 60px">object SomeClass {<br/><br/>    var intro = "I am some class. Pleased to meet you!"<br/>    fun infoIntro(): String {<br/>        return "I am some class. Pleased to meet you!"<br/>    }<br/>}</pre>
<p class="mce-root">Also, we use it just like the static members in the preceding examples:</p>
<pre>var x = SomeClass.intro<br/>toast(SomeClass.infoIntro())</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>In Kotlin, decompiling bytecode is always a great way to know what is happening behind the scenes. If we decompile the bytecode of the object we created, we get the following code, which shows that behind the scenes, the object is just a class with a single instance at a time:</p>
<pre>public final class SomeClass {<br/>   @NotNull<br/>   private static String intro;<br/>   public static final SomeClass INSTANCE;<br/><br/>   @NotNull<br/>   public final String getIntro() {<br/>      return intro;<br/>   }<br/><br/>   public final void setIntro(@NotNull String var1) {<br/>      Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;");<br/>      intro = var1;<br/>   }<br/><br/>   @NotNull<br/>   public final String infoIntro() {<br/>      return "I am some class. Pleased to meet you!";<br/>   }<br/><br/>   private SomeClass() {<br/>      INSTANCE = (SomeClass)this;<br/>      intro = "I am some class. Pleased to meet you!";<br/>   }<br/><br/>   static {<br/>      new SomeClass();<br/>   }<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Using Dagger 2 with Kotlin</h1>
                
            
            
                
<p>Dagger 2 is the best dependency injection framework in the Android community and is also open source. It is backed by Google and is widely used. Dependency injection is considered best practice and makes your code base scalable. In this recipe, we will learn how to use Dagger 2 for dependency injection in Kotlin.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll be using Android Studio 3.0 for coding purposes. First, we need to include Dagger 2 in the project, by adding the following lines to the <kbd>build.gradle</kbd> file:</p>
<pre>compile "com.google.dagger:dagger:$daggerVersion"<br/>kapt "com.google.dagger:dagger-compiler:$daggerVersion"</pre>
<p>You need to replace <kbd>$daggerVersion</kbd> with the latest version of Dagger2.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Before we move ahead, we need to understand how Dagger2 works. Dagger2 uses annotation to generate codes and uses it to access fields; therefore, it can't use private fields.</p>
<p>The following annotations are used in Dagger2:</p>
<ul>
<li class="mce-root"><kbd>@Module</kbd> and <kbd>@Provides</kbd>: Define classes and methods that provide dependencies</li>
<li class="mce-root"><kbd>@Inject</kbd>: Requests dependencies, and can be used on a constructor, a field, or a method</li>
<li class="mce-root"><kbd>@Component</kbd>: Enables selected modules and is used for performing dependency injection</li>
</ul>
<p>The classes annotated with <kbd>@Module</kbd> are responsible for providing objects that can be injected. The methods that provide those objects need to be annotated with <kbd>@Provides</kbd>. If the method requires another object to create a dependency object, they are provided in the method parameters. Dagger2 creates a dependency tree and checks whether the parameters can be supplied or not. Let's take a look at the implementation of a module:</p>
<ol>
<li>We will look at an example of a network module that will supply objects such as <kbd>HttpCache</kbd>, <kbd>HttpLoggingInterceptor</kbd>, GSON object, and such:</li>
</ol>
<pre style="padding-left: 60px">@Module<br/>class NetworkModule {<br/>    @Provides @Singleton<br/>    fun getHttpLoggingInterceptor():HttpLoggingInterceptor=<br/>            HttpLoggingInterceptor().<br/>                    setLevel(HttpLoggingInterceptor.Level.BODY)<br/><br/>    @Provides<br/>    @Singleton<br/>    fun provideHttpCache( @AppContext application: App): Cache {<br/>        val cacheSize = 10 * 1024 * 1024<br/>        val cache = Cache(application.cacheDir, cacheSize.toLong())<br/>        return cache<br/>    }<br/><br/>    @Provides<br/>    @Singleton<br/>    fun provideGson(): Gson {<br/>        val gsonBuilder = GsonBuilder()<br/>        gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)<br/>        return gsonBuilder.create()<br/>    }<br/><br/>    @Provides<br/>    @Singleton<br/>    fun provideOkhttpClient(cache: Cache, httpLoggingInterceptor: HttpLoggingInterceptor): OkHttpClient =<br/>            OkHttpClient.Builder().addInterceptor(httpLoggingInterceptor).cache(cache).build()<br/><br/>    @Provides @Singleton <br/>    fun getRetrofit(okHttpClient: OkHttpClient): Retrofit =                                             Retrofit.Builder().addCallAdapterFactory(RxJava2CallAdapterFactory.create())<br/>            .addConverterFactory(GsonConverterFactory.create())<br/>            .client(okHttpClient)<br/>            .baseUrl(AppConstants.INSTAGRAM_BASE_URL)<br/>            .build()<br/><br/>}</pre>
<p style="padding-left: 60px">As you can see, we annotated every method that provides an object through dependency injection with the <kbd>@Provides</kbd> annotation. We have also used the <kbd>@Singleton</kbd> annotation, which means that a singleton object is provided by the method.</p>
<p style="padding-left: 60px">You may notice, we've used other objects to create injectable objects, which we've provided as parameters. Those parameters should be available either from outside or from other injected objects.</p>
<ol start="2">
<li>Now, let's look at an example of the <kbd>Dagger</kbd> component:</li>
</ol>
<pre style="padding-left: 60px">@Component(dependencies = arrayOf(ApplicationComponent::class)<br/>        , modules = arrayOf(AddActivityModule::class))<br/>interface AddActivityComponent {<br/>    fun inject(addActivity: AddActivity)<br/>}</pre>
<p style="padding-left: 60px">The component acts as an interface that tells us from which modules (or other components) the dependencies are met. In the preceding example, we created a component that will provide us with the dependency objects from <kbd>AddActivityModule</kbd> and another <kbd>ApplicationComponent</kbd> component.</p>
<p style="padding-left: 60px">We also defined an inject method, which takes in a parameter (<kbd>AddActivity</kbd> here) that tells us where the objects will be injected.</p>
<ol start="3">
<li>Once defined, we can inject it into our <kbd>AddActivity</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">class AddActivity : BaseActivity&lt;AddActivityMvpView,AddActivityMvpPresenter&gt;(),AddActivityMvpView {<br/><br/>    @Inject<br/>    lateinit var mPresenter:AddActivityMvpPresenter<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_add)<br/>        DaggerAddActivityComponent.builder()<br/>                .applicationComponent(applicationComponent)<br/>                .build()<br/>                .inject(this)<br/>    }<br/>}</pre>
<p>As you can see, we use our <kbd>AddActivityComponent</kbd> (now prefixed with <em>Dagger</em>) to inject our <kbd>AddActivity</kbd> class.</p>
<p>Also, we have marked our dependency objects using the <kbd>@Inject</kbd> annotation, which means objects will be injected here. We've also added the <kbd>lateinit</kbd> modifier to prevent us from null checks every time we access it. Adding the <kbd>@Inject</kbd> annotation means that you want an object there, and dagger will then look into its components and dependencies to provide you that object.</p>
<p>Apart from that module class, you can instantiate the object at constructor level. Let's take a look at the following example:</p>
<pre>class AddActivityPresenter @Inject constructor(var mDataManager:DataManager)</pre>
<p>In the preceding example, adding the <kbd>@Inject</kbd> annotation to constructor means that the class needs the <kbd>DataManager</kbd> object before it can be created. Dagger will look into its dependency tree (in its component) and create <kbd>AddActivityPresenter</kbd>, if present.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using Butterknife with Kotlin</h1>
                
            
            
                
<p>The Android world has many libraries that require annotation processing. You just annotate the code, and it generates all the code behind the scenes for you, making your life easier. Many libraries such as Butterknife and Dagger2 work in similar ways. In this recipe, we will learn how to use Butterknife with Kotlin. For those who aren't familiar with Butterknife, it's a library that binds a view to a field without needing the <kbd>findViewById</kbd> calls. It's a household name in the Android development world. In Kotlin, the Kotlin Android Extension does almost the same work and is bundled along with Kotlin. However, if you are migrating your Java code where you've used Butterknife, this recipe will help you.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will be using Android Studio 3.0 for coding purposes.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To include Butterknife in your project, follow the given steps:</p>
<ol>
<li> To start with, add the following lines to your <kbd>build.gradle</kbd> file; also, you need to add the <kbd>kotlin-kapt</kbd> plugin and replace <kbd>annotationProcessor</kbd> with <kbd>kapt</kbd>. <kbd>kapt</kbd> is the Java equivalent of <kbd>annotationProcessor</kbd>, so wherever you used <kbd>annotationProcessor</kbd>, you need to replace it with <kbd>kapt</kbd>:</li>
</ol>
<pre style="padding-left: 60px">apply plugin: 'kotlin-kapt'  <br/>dependencies {  ...  <br/>    compile "com.jakewharton:butterknife:$butterknife-version"  <br/>    kapt "com.jakewharton:butterknife-compiler:$butterknife-version" }</pre>
<ol start="2">
<li>In Java, we used the Butterknife library, as shown:</li>
</ol>
<pre style="padding-left: 60px">@BindView(R.id.headline) TextView headline;</pre>
<p style="padding-left: 60px">In Kotlin, we can do it as follows:</p>
<pre style="padding-left: 60px">@BindView(R.id.headline) lateinit var headline: TextView</pre>
<p>Note that we've used the <kbd>lateinit</kbd> modifier, which will save us from declaring it nullable. We can also implement click listeners, as illustrated:</p>
<pre>@OnClick(R.id.button) <br/>internal fun sayHello() {  <br/>    Toast.makeText(this, "Hello, World!", LENGTH_SHORT).show() <br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>It's important to understand the working of annotation processors. They basically act as a hook for the compiler to analyze the source code for defined annotations, and handle them by producing compiler errors, warnings, or extra code in their place. This makes writing apps faster, because you just have to annotate and the compiler will generate all the necessary code for you behind the scenes. Dagger 2 is a popular library that works this way.</p>


            

            
        
    </div>



  </body></html>