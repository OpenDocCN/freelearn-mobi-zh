<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Exploring Swift"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Exploring Swift</h1></div></div></div><p>In the final chapter of this book, if your heart so desires, you can start learning Swift, Apple's new programming language. Here, you'll get a brief overview of what Swift is, how the language works, and some various syntax differences between Objective-C and Swift. We'll also cover the creation of a few simple apps using Swift.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">How Swift works</li><li class="listitem">Learning Swift through Playgrounds</li><li class="listitem">Using Cocos2d-Swift to create a game in Swift instead of Objective-C</li></ul></div><div class="note" title="Note"><h3 class="title"><a id="tip70"/>Tip</h3><p>This chapter will not cover most of Swift. It is instead intended as an introduction to coding in Swift through Cocos2d to create a game with this engine.</p><p>Also note that Swift, as a language, is only compatible with iOS 7 and above. If you intend to support iOS 6 or prior, you cannot use Swift in your project.</p></div><div class="section" title="How Swift works"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>How Swift works</h1></div></div></div><p>The main <a id="id489" class="indexterm"/>difference between Objective-C and Swift is in the way it looks. It still feels like Objective-C (in the sense that you can call all of the same methods), but the syntax is different.</p><p>For example, suppose you want to call this in Objective-C:</p><div class="informalexample"><pre class="programlisting">[object someMethodWithParam:param1 andOtherParam:param2];</pre></div><p>Instead, you end up calling the following in Swift:</p><div class="informalexample"><pre class="programlisting">object.someMethodWithParam(param1, andOtherParam:param2)</pre></div><p>Also, instead of using a header and a main file as in Objective-C, there's only a <code class="literal">.swift</code> file that gets used for everything.</p><p>There are obviously some syntax differences that you'll have to learn about when it comes to coding in Swift, but those who are familiar with Objective-C will pick up Swift quite easily. Don't worry, even if you aren't familiar with Objective-C. Swift is an easy-to-learn language, which makes picking it up much better.</p><p>That <a id="id490" class="indexterm"/>being said, let's cover some syntax differences using Apple's new tool they created to help learn and debug Swift—Playgrounds.</p></div></div>
<div class="section" title="Learning Swift through Playgrounds"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Learning Swift through Playgrounds</h1></div></div></div><p>Playgrounds<a id="id491" class="indexterm"/> offer a way to test your Swift code <a id="id492" class="indexterm"/>quickly and easily without much baggage that usually comes when creating a test project in another language. They're intended as files used for prototyping and quick fiddling with code if you have problems with a small section. They're really easy to use and understand, so let's begin.</p><div class="note" title="Note"><h3 class="title"><a id="note05"/>Note</h3><p>The first thing you'll notice about Swift is that there are no semicolons required (except when writing multiple statements on one line, which must be separated by semicolons). That's right—none! They're optional, but the preferred style of writing Swift code is without semicolons.</p><p>Also, when coding if statements, loops, switch statements, and so on, you must use curly braces around the block of code that will be run (even if there's only one line of code that will be executed).</p></div><p>Right now, go ahead and open the <code class="literal">SwiftSyntax.playground</code> file in the <code class="literal">Sample Projects</code> folder included with this book.</p><div class="note" title="Note"><h3 class="title"><a id="tip71"/>Tip</h3><p>If you cannot open the file within Xcode, update your version of Xcode to the newest version, as your version might be outdated.</p></div><p>When you open this file in Xcode, you'll see a lot of things happening. It's separated via comment lines (<code class="literal">// ------</code>). Each section represents a different set of syntax differences between Objective-C and Swift.</p><p>Although it is not explicitly stated what the Objective-C equivalent is, you can see how to declare a variable, how to run loops, create and call functions, and so on. Also, not all the syntax differences with Swift are included here. Only the most common uses of the language appear here.</p><p>With the playground file opened, let's see how Playgrounds are organized so that you can better understand what's going on (and why Playgrounds are useful for purposes besides<a id="id493" class="indexterm"/> just being a<a id="id494" class="indexterm"/> place to hold code).</p><div class="section" title="How Playgrounds are organized"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec148"/>How Playgrounds are organized</h2></div></div></div><p>The<a id="id495" class="indexterm"/> left side obviously has the code. The right side has a description of the state of the code; for example, if it's a variable, it will show the variable's value. If it's a <code class="literal">println</code> statement (the standard way to print the console in Swift), it will display the output.</p><p>If you type any new code in the Playground, you'll see the Playground's right-hand-side pane update as you type. If you copy and paste any code, you'll see all the lines updated with the final result of each line.</p><p>Because this is a Playground, we don't have to worry about using a <code class="literal">println</code> or <code class="literal">NSLog</code> statement here. It will automatically show up on the right-hand side of the Playground.</p></div><div class="section" title="Viewing the results over time"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec149"/>Viewing the results over time</h2></div></div></div><p>One <a id="id496" class="indexterm"/>of the cool things about using Playgrounds is that you can track the progress of your loops over time. For example, if you want to see each item that was printed in the names array, or what the value of a variable is in each iteration, you can see it visually with the Playground's <span class="strong"><strong>Value History</strong></span> button.</p><p>Also, if you want to debug your own Swift code in a project (and not just a Playground), you can bring it into a playground and observe the results over time. So if you have, say, an enemy patrolling back and forth with a loop, you can use the Playground's value history to see each value (in this case, position) at each iteration of the loop.</p><p>So first, go to the <code class="literal">for</code> loop section (approximately line 90), and find the line that says total <code class="literal">+= x</code> within the <code class="literal">for</code> loop, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00300.jpeg" alt="Viewing the results over time"/></div><p style="clear:both; height: 1em;"> </p><p>To view, move <a id="id497" class="indexterm"/>your mouse arrow onto the (100 times) line in the right-hand-side pane, and you should see two buttons appear on the right side of it. The first is an eyeball that will show you every value that a given object contains. For example, if you have a dictionary, you can view all the key/value pairs in that dictionary, as shown in this screenshot:</p><div class="mediaobject"><img src="../Images/image00301.jpeg" alt="Viewing the results over time"/></div><p style="clear:both; height: 1em;"> </p><p>The second button is the <span class="strong"><strong>Value History</strong></span> button. When your mouse arrow is on it, it will turn into a <span class="strong"><strong>+</strong></span> button, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00302.jpeg" alt="Viewing the results over time"/></div><p style="clear:both; height: 1em;"> </p><p>When <a id="id498" class="indexterm"/>you click on this button, you'll see a chart showing the values of that variable over time as the loop iterates (you'll also see the output console, which displays the names being printed as expected, from the previous loop) as shown in this screenshot:</p><div class="mediaobject"><img src="../Images/image00303.jpeg" alt="Viewing the results over time"/></div><p style="clear:both; height: 1em;"> </p><p>If you want to get more details of how your variable changes over time, you can either drag the <a id="id499" class="indexterm"/>red scrubber to the bottom of the <span class="strong"><strong>Value History</strong></span> section, or click on any data point along the chart to see its respective value, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00304.jpeg" alt="Viewing the results over time"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Learning more about Swift"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec150"/>Learning more about Swift</h2></div></div></div><p>There's a lot<a id="id500" class="indexterm"/> of content on Swift that wasn't covered here, such as lazy variables, the identity operator, the nil coalescing operator, class initializers, inheritance, and so on.</p><p>Some great places to learn more about Swift include <a class="ulink" href="http://www.lynda.com">www.lynda.com</a> (a great course on Swift is at <a class="ulink" href="http://www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html">www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html</a>) and <a class="ulink" href="http://www.raywenderlich.com/tutorials">www.raywenderlich.com/tutorials</a>, which have many online courses and tutorials that go over the basic and advanced features of Swift. You can also look at Apple's developer videos; just search for Swift at <a class="ulink" href="https://developer.apple.com/videos/wwdc/2014/.">https://developer.apple.com/videos/wwdc/2014/.</a> Then there are sample projects, the <a id="id501" class="indexterm"/>Swift developer blog at <a class="ulink" href="https://developer.apple.com/swift/blog/">https://developer.apple.com/swift/blog/</a>, as well as other websites such as Stack Overflow.</p><p>As mentioned earlier, Playgrounds can be very useful for developers who are just learning Swift, as well as those who are more experienced and wish to test their code for debugging purposes.</p><p>But a Playground isn't an app all by itself, so let's make a simple game using Swift as our language for Cocos2d. Again, you'll notice that the code itself is fairly similar to Objective-C; only the syntax is slightly different, so you should pick it up fairly quickly.</p></div></div>
<div class="section" title="Creating a game in Swift instead of Objective-C"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Creating a game in Swift instead of Objective-C</h1></div></div></div><p>The<a id="id502" class="indexterm"/> idea behind using Cocos2d-Swift is to switch over to the new programming language, right? Even though the Swift version of Cocos2d is still relatively new, and everything might not be implemented by the time you read this book, it can still be used as the core language when creating a game. So let's make a very simple game here, building upon the core concepts you just learned and combining them with the knowledge you already have of how the Cocos2d engine works in general.</p><p>Why use Swift instead of Objective-C? Because, you should be staying up to date with the latest technologies in the field, and Swift is just the next step in that direction. Also, as the years pass by, Apple may slowly deprecate and stop supporting Objective-C (but that's just a theory).</p><p>In general, it helps to know more languages if the opportunity calls for it. And if you're interested in web development, Swift feels very similar to JavaScript, so it's like learning two languages at once.</p><p>So why Cocos2d-Swift specifically? For the same reasons you just read. Also, typing code in Swift is generally faster than in Objective-C, and so, if you can create code faster, you<a id="id503" class="indexterm"/> can, in theory, create games faster, which is awesome!</p><div class="section" title="Goal of the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec151"/>Goal of the game</h2></div></div></div><p>The <a id="id504" class="indexterm"/>game we're going to make consists of a turret in the center that can shoot bullets, a score counter, and square-shaped enemies that come in from the left and the right. If the enemies make it to the center, it's game over! As the score increases, so will the spawn rate of enemies, eventually overwhelming the turret's fire rate.</p><p>Here are a few screenshots of the game we'll be making:</p><div class="mediaobject"><img src="../Images/image00305.jpeg" alt="Goal of the game"/></div><p style="clear:both; height: 1em;"> </p><div class="mediaobject"><img src="../Images/image00306.jpeg" alt="Goal of the game"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Starting a new Swift project"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec152"/>Starting a new Swift project</h2></div></div></div><p>Remember, the<a id="id505" class="indexterm"/> way to start Cocos2d projects now is by going through SpriteBuilder. Even though we won't be using SpriteBuilder for any code, we still have to go through the process of creating a project there.</p><p>So, in SpriteBuilder, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Project</strong></span>. Select the location where you want to create the project, name it something like <code class="literal">TurretGame</code>, and make sure you select <span class="strong"><strong>Swift</strong></span> as the language. This is also shown in the following screenshot for your reference:</p><div class="mediaobject"><img src="../Images/image00307.jpeg" alt="Starting a new Swift project"/></div><p style="clear:both; height: 1em;"> </p><p>Then, in <code class="literal">Turret Game</code>, go to the <code class="literal">Assets</code> folder of this book's content, and drag the <code class="literal">Images</code> folder<a id="id506" class="indexterm"/> into the resources list on the left side of SpriteBuilder as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00308.jpeg" alt="Starting a new Swift project"/></div><p style="clear:both; height: 1em;"> </p><p>After it has been imported to SpriteBuilder, right-click (or press <span class="emphasis"><em>Ctrl</em></span> and click) on the <code class="literal">Images</code> folder in SpriteBuilder, and select <span class="strong"><strong>Make Smart Sprite Sheet</strong></span>. This is what TexturePacker <a id="id507" class="indexterm"/>normally does for us. However, we can speed up the process using SpriteBuilder's auto sheet maker, since this is only going to be an example project.</p><div class="mediaobject"><img src="../Images/image00309.jpeg" alt="Starting a new Swift project"/></div><p style="clear:both; height: 1em;"> </p><p>Once it has turned into a sprite sheet, the folder icon should be of a pinkish color with a smiley on it. Now, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Publish</strong></span> so that SpriteBuilder can generate the necessary files for <a id="id508" class="indexterm"/>our project and we can be on our way.</p></div><div class="section" title="Adding the font files"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec153"/>Adding the font files</h2></div></div></div><p>Unfortunately, SpriteBuilder is lame at the time of writing this book and doesn't handle BMFonts<a id="id509" class="indexterm"/> very well. So, what we're going to do instead of having SpriteBuilder handle the sizing/exporting is create our own BMFont and manually add it to our list of files. This might not be the most efficient way, but it works, so we're going with it.</p><p>In this book's project folder, you should see a list of folders such as <code class="literal">resources-hd</code> and so on next to the <code class="literal">Images</code> folder you dragged into SpriteBuilder. Copy all four of these folders and paste them in the iOS <code class="literal">Resources</code> folder of your project files. When it asks you, make sure you click on <span class="strong"><strong>Merge</strong></span> (as well as <span class="strong"><strong>Apply to All</strong></span>).</p><div class="mediaobject"><img src="../Images/image00310.jpeg" alt="Adding the font files"/></div><p style="clear:both; height: 1em;"> </p><p>This will add the font files for each size type to the respective folder so that Cocos2d's directory<a id="id510" class="indexterm"/> search mode can find the correct size based on the device.</p></div><div class="section" title="Importing Bridging-Header and loading MainScene"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec154"/>Importing Bridging-Header and loading MainScene</h2></div></div></div><p>Objective-C, when<a id="id511" class="indexterm"/> working with Swift files, needs <a id="id512" class="indexterm"/>something called a <code class="literal">Bridging-Header</code> file. It's automatically created, so all we have to do is import the file. The format of the file is <code class="literal">ProjectName-Swift.h</code>, where <code class="literal">ProjectName</code> is the name of your project (for example, if the project is called <code class="literal">TurretGame</code>, we'll use <code class="literal">TurretGame-Swift.h</code>).</p><p>Now, feel free to open the Xcode project. Open <code class="literal">AppDelegate.m</code> and, at the top of the file, add the import statement to add the <code class="literal">Bridging-Header</code> file:</p><div class="informalexample"><pre class="programlisting">#import "TurretGame-Swift.h"</pre></div><p>Then, in the <code class="literal">StartScene</code> method, we need to change the line of code that will transition to the main scene (as well as add a line that will read in our images sheet):</p><div class="informalexample"><pre class="programlisting">- (CCScene*) startScene
{
  // Capital "I"
  [[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"Images.plist"];
//[CCBReader loadAsScene:@"MainScene"];
  return [MainScene node]; 
}</pre></div><p>We're using <code class="literal">node</code> here instead of <code class="literal">Scene</code> because we're calling a <code class="literal">Swift</code> class. In the previous examples in this book, the <code class="literal">Scene</code> method was a method we created, whereas <code class="literal">node</code> is a predefined function that does the same thing.</p></div><div class="section" title="Creating the background, turret, and score label"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec155"/>Creating the background, turret, and score label</h2></div></div></div><p>Because <a id="id513" class="indexterm"/>Swift is intended to be short and to the point when it<a id="id514" class="indexterm"/> comes to readability, the following code is all that is <a id="id515" class="indexterm"/>required in the <code class="literal">MainScene.swift</code> file in order to get a white background, an image to display, and a label at the bottom of the screen (note the <code class="literal">CCScene</code> inheritance; the default is <code class="literal">CCNode</code>):</p><div class="informalexample"><pre class="programlisting">class MainScene: CCScene {
  
  let winSize = CCDirector.sharedDirector().viewSize()
  var background = CCNodeColor(color: CCColor.whiteColor())

  //a value of "527" to make sure it's working. It'll get auto-set later, don't worry.
  var lblScore = CCLabelBMFont(string: "527", fntFile: "bmFont.fnt")
  
  //"Images/turret.png" because the turret image was located inside the Images folder
  //also making sure to Downcast to a CCSprite from AnyObject!
//We want to downcast because the variable we're setting should be a sprite, so because the spriteFrameByName() method returns AnyObject (as an explicitly unwrapped optional), we must downcast the ambiguous type to CCSprite for better use of the variable later on.
  var turret = CCSprite.spriteWithSpriteFrame(CCSpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName("Images/turret.png")) as CCSprite
  

  override init() {
    super.init()
    
    //simply add the background color
    self.addChild(background)
    
    //position and add the score label
    self.lblScore.position = ccp(self.winSize.width/2, self.winSize.height * 0.1)
    self.addChild(self.lblScore)

    //position and add the turret (z:1 so the bullets can spawn underneath it)
    self.turret.position = ccp(self.winSize.width/2, self.winSize.height/2)
    self.addChild(self.turret, z: 1)

  }
}</pre></div><p>Run <a id="id516" class="indexterm"/>the <a id="id517" class="indexterm"/>project at this point, and <a id="id518" class="indexterm"/>you'll see exactly what we described as our result. If you're starting to appreciate how little code it takes to make stuff happen, then Swift just might be your language to learn.</p><p>Now let's move on to getting the turret to rotate.</p></div><div class="section" title="Rotating the turret with touchMoved"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec156"/>Rotating the turret with touchMoved</h2></div></div></div><p>Notice<a id="id519" class="indexterm"/> so far how just about all the classes and methods are named exactly the same, with minor syntax differences between Objective-C and Swift. It's going to be the same for our <code class="literal">touchBegan</code>, <code class="literal">touchMoved</code>, and <code class="literal">touchEnded</code> methods.</p><p>First, we need to add a variable to store the player's touch position. So, at the top of <code class="literal">MainScene</code>, add the following variable:</p><div class="informalexample"><pre class="programlisting">class MainScene: CCScene {
  ...
    var touchPos = ccp(0, 0)
  ...
}</pre></div><p>Then, in the <code class="literal">init()</code> method, set the user interaction Boolean to <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">//records touches
self.userInteractionEnabled = true</pre></div><p>Next, add the following methods to <code class="literal">MainScene</code>:</p><div class="informalexample"><pre class="programlisting">// a method that will be called when a touch is registered on the device

override func touchBegan(touch: CCTouch!, withEvent event: CCTouchEvent!) {
    // grab the touch's location within the scene, and set it to our variable
    self.touchPos = touch.locationInNode(self)
    // calculate the angle of the touch relative to the turret's current position
    var angle = ccpToAngle( ccpSub( self.touchPos, self.turret.position ) )    
// set the rotation of the turret based on the calculated angle (converted to degrees because Cocos2D doesn't use radians)
    self.turret.rotation = CC_RADIANS_TO_DEGREES(Float(angle)) * -1
}
  
// a method called when a touch is dragged across the screen
override func touchMoved(touch: CCTouch!, withEvent event: CCTouchEvent!) {
// grab the location of the touch and set it again
    self.touchPos = touch.locationInNode(self)
    // calculate the angle again based on the new touch position
    var angle = ccpToAngle( ccpSub( self.touchPos, self.turret.position ) )
    // set the rotation of the turret again based on the new angle
    self.turret.rotation = CC_RADIANS_TO_DEGREES(Float(angle)) * -1
}
  
override func touchEnded(touch: CCTouch!, withEvent event: CCTouchEvent!) {
    // do nothing at the moment
}</pre></div><p>If you <a id="id520" class="indexterm"/>run the game, you'll be able to drag your finger around and rotate the turret in the direction of your finger.</p></div><div class="section" title="Shooting some bullets"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec157"/>Shooting some bullets</h2></div></div></div><p>Ours is <a id="id521" class="indexterm"/>not a very useful turret unless it's shooting bullets, so let's write that code.</p><p>First, we want a method we can call (or schedule). We want to make it spawn a bullet and then launch it in the direction of our finger (where the turret is pointing). So go ahead and add the following method:</p><div class="informalexample"><pre class="programlisting">func shootBullet() {
    
  //create the bullet. Again, "Images/bullet.png" because of the Images folder
    var bullet = CCSprite.spriteWithSpriteFrame(CCSpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName("Images/bullet.png")) as CCSprite

    //position the bullet underneath the turret
    bullet.position = ccp(self.winSize.width/2, self.winSize.height/2)
    
    //calculate the distance to move based on similar triangles
    let xDist = self.touchPos.x - self.turret.position.x;
    let yDist = self.touchPos.y - self.turret.position.y;
    let zDist = ccpDistance(self.touchPos, self.turret.position)
    
    let newX = (xDist * winSize.width) / zDist;
    let newY = (yDist * winSize.width) / zDist;
    
    //assign that distance to a CGPoint variable
    let moveDistance = ccp(newX, newY)
    
    //create an action that will move the bullet, then after 0.5 seconds, it will remove it from the screen
    var moveAndRemoveAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(0.5, position: moveDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({
      
      self.removeChild(bullet)
    }) as CCActionFiniteTime) as CCAction
    
    //add the bullet
    self.addChild(bullet)
    
    //run the move action
    bullet.runAction(moveAndRemoveAction)
}</pre></div><p>Although <a id="id522" class="indexterm"/>we now have this function that will create a bullet and launch it along a path, we have no way of testing it yet. So, in our <code class="literal">touchBegan</code> method, we add a call to schedule the selector:</p><div class="informalexample"><pre class="programlisting">override func touchBegan(touch: CCTouch!, withEvent event: CCTouchEvent!) {
  ...
    //call it once, then schedule it
    shootBullet()
    self.schedule(Selector("shootBullet"), interval: 0.125)
}</pre></div><p>Also, in our <code class="literal">touchEnded</code> method, we add a call to <code class="literal">unschedule</code> the selector (as we don't want the turret to shoot constantly):</p><div class="informalexample"><pre class="programlisting">override func touchEnded(touch: CCTouch!, withEvent event: CCTouchEvent!) {
    self.unschedule(Selector("shootBullet"))
}</pre></div><p>If you're wondering why the selector is in quotes, let me tell you that that's just the syntax of Swift. Instead of explicitly stating the function, you have to pass the function name as a string, and Swift handles the rest.</p><p>If you run the game at this point, you'll watch those bullets go rocketing out of the turret when you <a id="id523" class="indexterm"/>drag your finger across the screen.</p></div><div class="section" title="Spawning enemies and sending them towards the center"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec158"/>Spawning enemies and sending them towards the center</h2></div></div></div><p>We want <a id="id524" class="indexterm"/>some enemies to shoot at, so let's create a method that will spawn an enemy along either the left or right wall, and send it to the center of the screen (where the turret is), over a period of 3 seconds:</p><div class="informalexample"><pre class="programlisting">func spawnEnemy() {
    //create the enemy. Again, "Images/enemy.png" because of the Images folder
    var enemy = CCSprite.spriteWithSpriteFrame(CCSpriteFrameCache.sharedSpriteFrameCache().spriteFrameByName("Images/enemy.png")) as CCSprite
    
    //position the enemy randomly along the left or right wall
    let yPos = arc4random() % UInt32(winSize.height)
    let xPos = arc4random() % 2 == 0 ? -50 : winSize.width + 50
    enemy.position = ccp(CGFloat(xPos),CGFloat(yPos))
    
    //add the enemy to the screen
    self.addChild(enemy)
    
    //move to exactly 1 enemy-length away from the center (calculated with triangle ratios)
    let distanceToCenter = ccpDistance(self.turret.position, enemy.position)
    let xDistance = self.turret.position.x - xPos
    let yDistance = self.turret.position.y - CGFloat(yPos)
    
    let newDistanceToCenter = distanceToCenter - enemy.boundingBox().size.width
    let newX = (newDistanceToCenter * xDistance) / distanceToCenter
    let newY = (newDistanceToCenter * yDistance) / distanceToCenter
    
    let centerPosDistance = ccp(newX,newY)
    
    //create a move action that, after 3 seconds, will do something (nothing at the moment)
    let moveAndEndGameAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(3, position: centerPosDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({
      //do nothing at the moment
    }) as CCActionFiniteTime) as CCAction
    
    //run the move action
    enemy.runAction(moveAndEndGameAction)
}</pre></div><p>It's great <a id="id525" class="indexterm"/>that we have a method to spawn enemies, but there are none currently spawning. So, just like the <code class="literal">shootBullet</code> function we scheduled, we must schedule the <code class="literal">spawnEnemy</code> function.</p><p>In the <code class="literal">init()</code> method, add the following line of code to spawn the enemies:</p><div class="informalexample"><pre class="programlisting">override init() {
    super.init()

    ...
    
    self.schedule(Selector("spawnEnemy"), interval: 0.35)
}</pre></div><p>There we go! Now we have our enemies spawning. But even if they make it to their final position, nothing happens. Let's fix that.</p></div><div class="section" title="Transitioning to GameOver"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec159"/>Transitioning to GameOver</h2></div></div></div><p>When <a id="id526" class="indexterm"/>an enemy gets near the center (after the action completes), we want our game to be over, so let's create a <code class="literal">GameOverScene</code> class, and transition to it when an enemy reaches their end position.</p><p>First, create a new file by hitting <span class="emphasis"><em>Command</em></span> + <span class="emphasis"><em>N</em></span> (or <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>File</strong></span>). Select <span class="strong"><strong>Cocoa Touch Class</strong></span> by navigating to <span class="strong"><strong>iOS</strong></span> | <span class="strong"><strong>Source</strong></span>.</p><div class="mediaobject"><img src="../Images/image00311.jpeg" alt="Transitioning to GameOver"/></div><p style="clear:both; height: 1em;"> </p><p>Then<a id="id527" class="indexterm"/> name it <code class="literal">GameOverScene</code>, and make sure you choose <span class="strong"><strong>Swift</strong></span> as the language.</p><div class="mediaobject"><img src="../Images/image00312.jpeg" alt="Transitioning to GameOver"/></div><p style="clear:both; height: 1em;"> </p><p>Save <a id="id528" class="indexterm"/>it in the <code class="literal">Source</code> folder of your project, and it will automatically open up.</p><p>Replace your <code class="literal">GameOverScene</code> class with the following, which will set the background to white, create a label in the center of the screen, enable touches, and transition back to <code class="literal">MainScene</code> when the screen is tapped:</p><div class="informalexample"><pre class="programlisting">class GameOverScene: CCScene {
  
  override init() {

    super.init()
    
    let winSize = CCDirector.sharedDirector().viewSize()
    
    var background = CCNodeColor(color: CCColor.whiteColor())
    self.addChild(background)
    
    var label = CCLabelBMFont(string: "Tap anywhere to restart", fntFile: "bmFont.fnt")
    label.position = ccp(winSize.width/2, winSize.height/2)
    self.addChild(label)
    
    self.userInteractionEnabled = true
  }
  
  override func touchBegan(touch: CCTouch!, withEvent event: CCTouchEvent!) {

    CCDirector.sharedDirector().replaceScene(MainScene.node() as CCScene)
  }
}</pre></div><p>Then, to <a id="id529" class="indexterm"/>test this scene, add the following <code class="literal">replaceScene</code> call to the closure (or code block) of the enemy's move action in <code class="literal">MainScene.swift</code>:</p><div class="informalexample"><pre class="programlisting">func spawnEnemy() {
...
    //create a move action that, after 3 seconds, will do something (nothing at the moment)
    let moveAndEndGameAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(3, position: centerPosDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({

  //add this line – it will transition to the GameOverScene (in other words, the enemy was not killed)
    CCDirector.sharedDirector().replaceScene(GameOverScene.node() as CCScene)

}) as CCActionFiniteTime) as CCAction
    
    //run the move action
    enemy.runAction(moveAndEndGameAction)
}</pre></div><p>Hmmm! Except now that it transitions properly, it's not much of a game, since we can't stop the enemies with the bullets we're shooting. Let's fix that!</p></div><div class="section" title="Handling collisions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec160"/>Handling collisions</h2></div></div></div><p>There's a<a id="id530" class="indexterm"/> ton of different ways to handle collisions, but the way we're going to handle them is by using the bounding box of our bullets and the enemies. To do that, we're going to set up two arrays (one for enemies and one for bullets) and a function to loop through the arrays and check for bounding box intersections.</p><p>First, we add two variables for the arrays. We're going to use <code class="literal">NSMutableArray</code> instead of Swift's arrays because Swift's array allows us to remove an item only via its index, and not by passing the item itself. So, it will be easier with <code class="literal">NSMutableArray</code>:</p><div class="informalexample"><pre class="programlisting">class MainScene: CCScene {
  
  ...
  
  //arrays to hold our bullets and enemies
  var bullets : NSMutableArray = []
  var enemies : NSMutableArray = []
  
  override init() {
    ...</pre></div><p>Now we need to add our bullets and enemies to their respective array (as well as handle their removal from the array). So, in our <code class="literal">shootBullet</code> and <code class="literal">spawnEnemy</code> functions, we add the objects to the array, as well as remove the bullet from the array right before we remove it from the scene:</p><div class="informalexample"><pre class="programlisting">func shootBullet() {

...

    var moveAndRemoveAction = CCActionSequence.actionOne(CCActionMoveBy.actionWithDuration(0.5, position: moveDistance) as CCActionFiniteTime, two: CCActionCallBlock.actionWithBlock({
      
      //remove the bullet from the array
      //before removing it from the screen
      self.bullets.removeObject(bullet)
      self.removeChild(bullet)
    }) as CCActionFiniteTime) as CCAction
    
    //add the bullet
    self.bullets.addObject(bullet)
    self.addChild(bullet)
  
...
}
  
func spawnEnemy() {
...
    
    
//add the enemy to the enemies array before adding it to the screen
    self.enemies.addObject(enemy)
//add the enemy to the screen
    self.addChild(enemy)

...
}</pre></div><p>Next, we<a id="id531" class="indexterm"/> need to create a function that will loop through our arrays and check for collisions. If a collision is found, we will remove both objects from the arrays (and the screen) and break out of the loop so that we don't accidentally go out of bounds.</p><p>Create the following function in the <code class="literal">MainScene.swift</code> file:</p><div class="informalexample"><pre class="programlisting">func checkForCollisions() {
    
    //check for collisions
    for bullet in self.bullets {
      for enemy in self.enemies {

        //if the two bounding boxes are overlapping/intersecting/colliding
        if CGRectIntersectsRect(bullet.boundingBox(),
        enemy.boundingBox()) {
          self.bullets.removeObject(bullet)
          self.enemies.removeObject(enemy)
          
          self.removeChild(bullet as CCSprite)
          self.removeChild(enemy as CCSprite)
          
          break;
        }
      }
    }
}</pre></div><p>Finally, we need to schedule this function so that it will be called frequently enough when our bullets interact with the enemies, and the collision will get detected at the right time. To do that, simply schedule it in the <code class="literal">init()</code> function:</p><div class="informalexample"><pre class="programlisting">override init() {
    ...
    self.schedule(Selector("checkForCollisions"), interval: 1.0/60.0)
}</pre></div><p>Run the <a id="id532" class="indexterm"/>game at this point, and you'll see the bullets colliding properly. But no! It's not much of a game without a score counter. So let's add that to this example game in Swift.</p></div><div class="section" title="Counting the score"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec161"/>Counting the score</h2></div></div></div><p>All we <a id="id533" class="indexterm"/>need is a variable that tracks our score and a label to display it. Arguably, you can also have this on the game over scene, but we're not going to worry about that in this example.</p><p>So, at the top of our <code class="literal">MainScene</code> class, we create two variables as described, and then add the label to the screen in the <code class="literal">init()</code> method:</p><div class="informalexample"><pre class="programlisting">class MainScene: CCScene {

  ... 
//a variable to hold the score. The value of 0.0 sets it to a Float type by default, not Int
  var score = 0.0   
  override init() {
    ...
  }
}</pre></div><p>Then we implement the <code class="literal">update</code> function, which gets automatically called by Cocos2d:</p><div class="informalexample"><pre class="programlisting">override func update(delta: CCTime) {
    //some obscure score increment over time...
    self.score += 0.47
    
    //set the label using String Interpolation
  self.lblScore.setString("\(Int(self.score))")
}</pre></div><p>We also <a id="id534" class="indexterm"/>want to increase the score by <code class="literal">100</code> for every enemy that dies, so in the <code class="literal">checkForCollisions</code> function, we simply add <code class="literal">100</code> to the score variable:</p><div class="informalexample"><pre class="programlisting">func checkForCollisions() {
...
  if CGRectIntersectsRect(bullet.boundingBox(), enemy.boundingBox()) {
     ...
     self.score += 100   
     break;
  }
}</pre></div><p>If you run the game at this point, you'll see the score increasing as time goes on, as well as when any enemy gets hit by a bullet. The only thing left to do is make the game harder over time (because it's rather boring at the moment).</p></div><div class="section" title="Increasing the difficulty"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec162"/>Increasing the difficulty</h2></div></div></div><p>Finally (although it doesn't entirely matter for the purpose of making the example work), we <a id="id535" class="indexterm"/>want our difficulty to increase over time so that only the best players can make it far. We're going to do this by increasing the rate at which units spawn (every 2,000 points, to be exact). First, we want some variables to hold the current spawn rate as well as the amount of points accrued since the last increase in difficulty:</p><div class="informalexample"><pre class="programlisting">class MainScene: CCScene {
  ...
  //variables for enemy spawn rate (aka, difficulty)
  var spawnRate = 0.35
  var scoreSinceLastIncrease = 0.0
  
  override init() {</pre></div><p>Then, we must replace the hardcoded value of <code class="literal">0.35</code> with the <code class="literal">spawnRate</code> variable:</p><div class="informalexample"><pre class="programlisting">override init() {
  ...
  self.schedule(Selector("spawnEnemy"), interval: self.spawnRate)
}</pre></div><p>Now, every time we increase our <code class="literal">score</code> variable, we must also increase the <code class="literal">scoreSinceLastIncrease</code> variable. So in <code class="literal">update</code> as well as <code class="literal">checkForCollisions</code>, we need<a id="id536" class="indexterm"/> to add the same amount to both the variables:</p><div class="informalexample"><pre class="programlisting">func checkForCollisions() {
  ...     
  if CGRectIntersectsRect(bullet.boundingBox(), enemy.boundingBox()) {
    ...
    self.score += 100
    self.scoreSinceLastIncrease += 100
          
    break;
  }
}
  
override func update(delta: CCTime) {
    //some random score increment over time...
    self.score += 0.47
    self.scoreSinceLastIncrease += 0.47
    
    //set the label using String Interpolation
    self.lblScore.setString("\(Int(self.score))")
    
}</pre></div><p>Finally, we need to check inside our update: method whether the score since the last difficulty increase has crossed our limit (in this case, we're going to increase it after every 2,000 points earned). To do this, we'll just <code class="literal">unschedule</code> the <code class="literal">spawnEnemy</code> function, reduce <code class="literal">spawnRate</code> (only to a certain amount), and <code class="literal">re-schedule</code> the <code class="literal">spawnEnemy</code> function:</p><div class="informalexample"><pre class="programlisting">override func update(delta: CCTime) {
    ...
    if self.scoreSinceLastIncrease &gt; 2000 {
      
      //unschedule and re-schedule the spawnEnemy method
      //using the new spawn rate
      self.unschedule(Selector("spawnEnemy"))

      spawnRate -= 0.025
      if (spawnRate &lt; 0.005) {
        spawnRate = 0.005
      }

      self.schedule(Selector("spawnEnemy"), interval: self.spawnRate)
      
      //subtract 2000, the amount of the difficulty
      self.scoreSinceLastIncrease -= 2000
    }
}</pre></div><p>Run the <a id="id537" class="indexterm"/>game at this point and watch as more and more units come flooding into the view, eventually overwhelming you.</p><p>And that's it! We've just made a very simple game in Cocos2d but with the help of Swift this time. It's not the best or most fun game in the world but it counts. Plus, this example was more of a way to show you how to go ahead and make games using Swift as your core language instead of Objective-C.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Summary</h1></div></div></div><p>In this chapter, you learned how to make use of playgrounds and create a basic game using Cocos2d and Swift.</p><p>As mentioned earlier, if you wish to learn more about Swift, there's a plethora of available online resources at your disposal—online courses, Apple-created content, as well as online communities that provide assistance as needed.</p><p>Happy coding!</p></div></body></html>