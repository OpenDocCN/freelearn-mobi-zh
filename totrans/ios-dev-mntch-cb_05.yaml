- en: Chapter 5. Displaying Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 显示数据
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Providing lists
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供列表
- en: Displaying data in a table
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表格中显示数据
- en: Customizing rows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义行
- en: 'Editing a table: deleting rows'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑表格：删除行
- en: 'Editing a table: inserting rows'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑表格：插入行
- en: Table indexing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表索引
- en: Searching through the data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索数据
- en: Creating a simple web browser
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的网页浏览器
- en: Displaying local content
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示本地内容
- en: Displaying formatted text
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示格式化文本
- en: Displaying documents
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示文档
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we discussed about some of the available options for
    data management in an iOS application. In this chapter, we will discuss various
    ways of displaying data to the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了iOS应用程序中数据管理的一些可用选项。在本章中，我们将讨论向用户显示数据的各种方法。
- en: 'Specifically, we will see how to use the following controls:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将看到如何使用以下控件：
- en: '`UIPickerView:` This is the control that provides similar functionality to
    a list box.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIPickerView:` 这是一个提供类似列表框功能的控件。'
- en: '`UITableView:` This is a very customizable view for displaying data. One of
    the most used controls in iOS applications.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UITableView:` 这是一个非常可定制的视图，用于显示数据。iOS应用程序中最常用的控件之一。'
- en: '`UISearchBar` **and** `UISearchDisplayController:` These are a combination
    of controls that provide an easy-to-use interface for searching through data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UISearchBar` **和** `UISearchDisplayController:` 这些是一组控件，提供了一种易于使用的界面来搜索数据。'
- en: '`UIWebView:` This brings web browser functionality to applications.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIWebView:` 这将网页浏览器功能带给应用程序。'
- en: '`QLPreviewController:` This displays various document formats.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QLPreviewController:` 这可以显示各种文档格式。'
- en: Furthermore, we will learn how to provide indexing in tables, to make large
    volumes of data easily accessible to the user. We will also discuss some of the
    available ways to display formatted text, even **Portable Document Format (PDF)**
    , and other documents.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将学习如何在表格中提供索引，以便用户可以轻松访问大量数据。我们还将讨论一些显示格式化文本的可用方法，甚至包括**便携式文档格式（PDF）**和其他文档。
- en: Also, starting from this chapter, all code examples will use a default view
    controller named `MainController`, unless otherwise stated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，所有代码示例都将使用默认视图控制器`MainController`，除非另有说明。
- en: Providing lists
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供列表
- en: In this recipe, we will learn how to use the `UIPickerView` class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用`UIPickerView`类。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UIPickerView` class provides us with a control whose functionality is similar
    to a listbox, specifically designed for human fingers touching the screen. Its
    main difference to a common listbox is that each column can have its own number
    of rows. To get started, create a new iPhone project and name it `PickerViewApp`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPickerView`类为我们提供了一个与列表框功能相似的控件，专门设计用于人类手指触摸屏幕。它与普通列表框的主要区别在于，每一列可以有自己的行数。要开始，创建一个新的iPhone项目，并将其命名为`PickerViewApp`。'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `MainController.xib` file in Interface Builder.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`MainController.xib`文件。
- en: Add a `UILabel` and a `UIPickerView` on the main View.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主视图中添加一个`UILabel`和一个`UIPickerView`。
- en: Save the document.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Back in MonoDevelop, create a nested class in the `MainController` class that
    inherits from `UIPickerViewModel:`
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MonoDevelop中，创建一个继承自`UIPickerViewModel:`的`MainController`类中的嵌套类：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following constructor and fields in the nested class:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在嵌套类中添加以下构造函数和字段：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will now need to override four methods from the `UIPickerViewModel` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在需要覆盖`UIPickerViewModel`类中的四个方法：
- en: '`int GetComponentCount (UIPickerView picker)`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int GetComponentCount (UIPickerView picker)`'
- en: '`int GetRowsInComponent (UIPickerView picker, int component)`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int GetRowsInComponent (UIPickerView picker, int component)`'
- en: '`string GetTitle (UIPickerView picker, int row, int component)`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string GetTitle (UIPickerView picker, int row, int component)`'
- en: '`void Selected (UIPickerView picker, int row, int component)`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void Selected (UIPickerView picker, int row, int component)`'
- en: 'Finally, set the model object created to the picker view''s `Model` property
    inside the controller''s `ViewDidLoad` method:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在控制器中的`ViewDidLoad`方法内将创建的模型对象设置为picker视图的`Model`属性：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The complete code can be found in the `PickerViewApp` project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`PickerViewApp`项目中找到。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIPickerViewModel` class does not exist in `Objective-C`. MonoTouch provides
    this class as a wrapper around the native protocols `UIPickerViewDataSource` and
    `UIPickerViewDelegate` and contains both of these class' methods for us to override.
    This is extremely helpful, since we only have to implement and assign one class
    instead of two for our picker view. Both of these protocols are at the same time
    available as classes in MonoTouch.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPickerViewModel` 类在 `Objective-C` 中不存在。MonoTouch 提供了这个类，作为原生协议 `UIPickerViewDataSource`
    和 `UIPickerViewDelegate` 的包装器，并包含这两个类的所有方法，以便我们重写。这非常有帮助，因为我们只需要实现和分配一个类，而不是两个类来为我们的选择视图。这两个协议同时作为类在
    MonoTouch 中可用。'
- en: 'Inside the constructor, we initialize the lists that will hold the data to
    be displayed in the picker. The four classes we need to override are responsible
    for displaying the data:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们初始化将包含要显示在选择器中的数据的列表。我们需要重写的四个类负责显示数据：
- en: '`int GetComponentCount (UIPickerView picker):` This returns the number of columns
    we want the picker view to display.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int GetComponentCount (UIPickerView picker):` 这个方法返回我们想要选择视图显示的列数。'
- en: '`int GetRowsInComponent (UIPickerView picker, int component):` This returns
    the number of rows each component will display.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int GetRowsInComponent (UIPickerView picker, int component):` 这个方法返回每个组件将显示的行数。'
- en: '`string GetTitle (UIPickerView picker, int row, int component):` This returns
    the text of each row.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`string GetTitle (UIPickerView picker, int row, int component):` 这个方法返回每一行的文本。'
- en: '`void Selected (UIPickerView picker, int row, int component):` This returns
    the action to take when the user selects an item from any component/row combination
    in the picker view.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void Selected (UIPickerView picker, int row, int component):` 这个方法返回当用户从选择视图的任何组件/行组合中选择项目时要采取的操作。'
- en: 'We use the lists we have assigned in the constructor to display the data. For
    example, the `GetTitle` method is implemented as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在构造函数中分配的列表来显示数据。例如，`GetTitle` 方法实现如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we run the application and select anything from the picker, the result
    will be similar to the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序并从选择器中选择任何内容时，结果将类似于以下截图：
- en: '![How it works...](img/1468EXP_05_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1468EXP_05_01.jpg)'
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We can programmatically select the initial selection of the picker view by calling
    the method `Select (int, int, bool)`. The first two parameters reflect the row
    and component index respectively, while the `bool` parameter toggles the selection
    animation. The only thing to remember with this method is to call it after we
    have assigned the picker's `Model` property. An exception will occur otherwise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用方法 `Select (int, int, bool)` 来程序化选择选择视图的初始选择。前两个参数分别表示行和组件索引，而 `bool`
    参数切换选择动画。使用此方法时需要注意的唯一一点是，我们必须在分配选择器的 `Model` 属性之后调用它。否则将发生异常。
- en: More information on UIPickerView customization
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于 UIPickerView 定制的信息
- en: Apart from the options presented, we also have the option of setting the width
    of each component. To do this, we override the `GetComponentWidth (UIPickerView,
    int)` method, which returns a float that represents the width for each component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供的选项外，我们还可以设置每个组件的宽度。为此，我们重写 `GetComponentWidth (UIPickerView, int)` 方法，它返回一个表示每个组件宽度的浮点数。
- en: We can also set custom views as items in the picker view, instead of plain text.
    This can be done by overriding the `GetView(UIPickerView, int, int, UIView)` method
    and returning the view we want to be displayed in each position in the `UIPickerView`
    control.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过重写 `GetView(UIPickerView, int, int, UIView)` 方法来设置自定义视图作为选择视图中的项目，而不是纯文本。这可以通过返回我们想要在
    `UIPickerView` 控制中的每个位置显示的视图来实现。
- en: Date and time selection
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和时间选择
- en: There is a control named `UIDatePicker` that is similar to the `UIPickerView`
    and is specifically customized for displaying and selecting date and time values.
    Note that although its user interface is the same as the picker view, it does
    not inherit the `UIPickerView` class. It just uses an instance of it as a sub-view.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `UIDatePicker` 的控件，它与 `UIPickerView` 类似，专门用于显示和选择日期和时间值。请注意，尽管它的用户界面与选择视图相同，但它并不继承
    `UIPickerView` 类。它只是使用它的一个实例作为子视图。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying data in a table*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*'
- en: Displaying data in a table
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表格中显示数据
- en: In this recipe, we will learn how to use the `UITableView` class to display
    data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 `UITableView` 类来显示数据。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UITableView` class, along with the `UITableViewCell` object, provides an
    interface for displaying data on the screen in multiple rows, but on a single
    column. To get started, create a new project in MonoDevelop, and name it `TableViewApp.`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 类以及 `UITableViewCell` 对象提供了一种在屏幕上以多行但单列的形式显示数据的接口。要开始，请在 MonoDevelop
    中创建一个新的项目，并将其命名为 `TableViewApp.`'
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add a view with controller to the project, and name it `TableController`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将带有控制器的视图添加到项目中，并将其命名为 `TableController`。
- en: Change the `TableController` class' inheritance from `UIViewController` to `UITableViewController:`
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TableController` 类的继承从 `UIViewController` 更改为 `UITableViewController:`
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open the `TableController.xib` file in Interface.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface 中打开 `TableController.xib` 文件。
- en: Delete the document's `UIView`, and add a `UITableView` in its place.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除文档的 `UIView`，并在其位置添加一个 `UITableView`。
- en: Connect the outlet named view of the `TableController` to the table view added.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TableController` 的输出端口 `view` 连接到添加的表格视图。
- en: Save the document.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in MonoDevelop, create the following nested class inside the `TableController`
    class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中，在 `TableController` 类内部创建以下嵌套类：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Override the controller''s `ViewDidLoad` method, and add the following line
    of code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写控制器的 `ViewDidLoad` 方法，并添加以下代码行：
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The complete code can be found in the `TableViewApp` project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在 `TableViewApp` 项目中找到。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The nested class that we created acts as the data source of the `UITableView`.
    It inherits from the MonoTouch `UITableViewSource` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的嵌套类充当 `UITableView` 的数据源。它继承自 MonoTouch 的 `UITableViewSource` 类：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like the `UIPickerView`, in the example discussed in the previous recipe, the
    `UITableViewSource` class does not exist in `Objective-C`. It is merely a wrapper
    object offered by MonoTouch around `UITableViewDelegate` and `UITableViewSource`
    protocols.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的示例中的 `UIPickerView` 类似，`UITableViewSource` 类在 `Objective-C` 中不存在。它仅仅是
    MonoTouch 提供的围绕 `UITableViewDelegate` 和 `UITableViewSource` 协议的包装对象。
- en: In its constructor, we initialize two variables. A string that will act as the
    cells' identifier and a generic `Dictionary` for our data source.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在其构造函数中，我们初始化两个变量。一个字符串将作为单元格的标识符，以及一个用于数据源的通用 `Dictionary`。
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To make the `TableSource` class work, we need to override two methods. The
    first method, named `RowsInSection`, which returns the number of rows the table
    shall display. Here, we return the number of items in our data source object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `TableSource` 类工作，我们需要重写两个方法。第一个方法名为 `RowsInSection`，它返回表格应显示的行数。在这里，我们返回数据源对象中的项目数量：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The second method, `GetCell`, returns the `UITableViewCell` object that will
    be displayed in the table.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法 `GetCell` 返回将在表格中显示的 `UITableViewCell` 对象。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `UITableViewCell` class represents a single row and manages its content
    in a `UITableView`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableViewCell` 类代表一行，并在 `UITableView` 中管理其内容。'
- en: 'To be more efficient, the table view creates its cell objects when they are
    needed. For this reason, we need to get a previously used `UITableViewCell` from
    the table through its `DequeueReusableCell` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效，表格视图在需要时创建其单元格对象。因此，我们需要通过其 `DequeueReusableCell` 方法从表格中获取之前使用的 `UITableViewCell`：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If no cells exist for the particular cell identifier, the method returns `null`.
    Hence, we create the cell that will be used:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在特定单元格标识符的单元格，该方法将返回 `null`。因此，我们创建将要使用的单元格：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we assign the text that the particular cell will display and return it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分配特定单元格将显示的文本并返回它：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By default, the `UITableViewCell` class contains two labels that can be used
    to display text. The main label can be accessed through the `TextLabel` property
    and the secondary label through the `DetailTextLabel` property. Note that when
    using a cell with the `Default` style, the `DetailTextLabel` property cannot be
    used and will return `null`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`UITableViewCell` 类包含两个标签，可以用来显示文本。主标签可以通过 `TextLabel` 属性访问，次要标签可以通过 `DetailTextLabel`
    属性访问。请注意，当使用具有 `Default` 风格的单元格时，`DetailTextLabel` 属性不能使用，并将返回 `null`。
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To provide functionality when the user selects a particular row, we need to
    override the `RowSelected` property in the class that acts as a `UITableViewSource`.
    By default, when the user taps on a row, the cell is highlighted with a blue color
    to indicate the selection. To de-select the row, we use the `UITableView.DeselectRow(NSIndexPath,
    bool)` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户选择特定行时提供功能，我们需要覆盖作为`UITableViewSource`的类的`RowSelected`属性。默认情况下，当用户点击一行时，单元格会以蓝色突出显示以表示选中。要取消选中行，我们使用`UITableView.DeselectRow(NSIndexPath,
    bool)`方法：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: UITableView styles
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UITableView`样式'
- en: The `UITableView` can be created with two different styles. The default style
    is `Plain`. The other style that can be used is the `Grouped` style. This style
    is being used in many iOS native applications, such as the `Settings` application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView`可以以两种不同的样式创建。默认样式是`Plain`。另一种可以使用的样式是`Grouped`样式。这种样式在许多iOS原生应用中都被使用，例如`Settings`应用。'
- en: Also, the `UITableView` supports display of data divided into different sections.
    We must explicitly return the number of rows that each section will have in the
    `RowsInSection` override if we want to use different sections.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`UITableView`支持显示分为不同部分的数据。如果我们想使用不同的部分，我们必须在`RowsInSection`覆盖中明确返回每个部分将有的行数。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Providing lists*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供列表*'
- en: '*Customizing rows*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义行*'
- en: 'In this book:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 3](ch03.html "Chapter 3. User Interface: View Controllers"), User
    Interface: View Controllers:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面：视图控制器")，用户界面：视图控制器：'
- en: '*Creating* a *table controller*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建*一个*表格控制器*'
- en: Customizing rows
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*自定义行*'
- en: In this recipe, we will cover some of the different options available for customizing
    the display of content in table cells.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将介绍一些可用于自定义表格单元格内容显示的不同选项。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop in the same manner the project in the previous
    recipe was created. Name it `CustomRowsApp.`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以与上一个菜谱中创建项目相同的方式在MonoDevelop中创建一个新的项目。将其命名为`CustomRowsApp.`
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Copy and paste the `TableSource` class from the project in the previous task,
    inside the `TableController` class.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一个任务中的项目中的`TableSource`类复制并粘贴到`TableController`类内部。
- en: 'Perform the following changes in the `GetCell` override:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetCell`覆盖中执行以下更改：
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remove the `cellID` field and add a new one:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`cellID`字段并添加一个新的：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initialize it in the constructor, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化，如下所示：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add another `KeyValuePair` in the data source object:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据源对象中添加另一个`KeyValuePair`：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compile and run the application on the simulator. The output should be something
    similar to the following, as explained in the following screenshot:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。输出应该类似于以下内容，如以下截图所示：
- en: '![How to do it...](img/1468EXP_05_02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_05_02.jpg)'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A table cell can have four different cell styles, which are represented by
    the `UITableViewCellStyle` enumeration. Its values are:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表格单元格可以有四种不同的单元格样式，这些样式由`UITableViewCellStyle`枚举表示。其值如下：
- en: '`Default:` This is the default cell style. Only the `TextLabel` property can
    be used to display text.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`默认:` 这是默认单元格样式。只能使用`TextLabel`属性来显示文本。'
- en: '`Subtitle:` This is a style that provides the `DetailTextLabel` as a sub-title
    to the `TextLabel`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`副标题:` 这是一种提供`DetailTextLabel`作为`TextLabel`副标题的样式。'
- en: '`Value1:` This is a style that displays both `TextLabel` and `DetailTextLabel`
    text in the same size, with different colors and aligned to the sides of the cell.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Value1:` 这是显示`TextLabel`和`DetailTextLabel`文本大小相同、颜色不同且对齐到单元格两侧的样式。'
- en: '`Value2:` This is a style that displays the `TextLabel` text smaller than the
    `DetailTextLabel` text. This style is used in the native `Contacts` application,
    in the contact details screen.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Value2:` 这是显示`TextLabel`文本比`DetailTextLabel`文本小的样式。这种样式在原生的`Contacts`应用中的联系人详情屏幕中使用。'
- en: To easily use all available styles, we have added all the values of the `UITableViewCellStyle`
    enumeration in a `Dictionary:`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用所有可用的样式，我们已经在`Dictionary:`中添加了`UITableViewCellStyle`枚举的所有值：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we use different cell styles, hence different cells, we need one cell
    identifier for each string. To avoid declaring another list or more fields in
    the class, we use the data source for this reason:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用了不同的单元格样式，因此需要为每个字符串提供一个单元格标识符。为了避免在类中声明另一个列表或更多字段，我们出于这个原因使用数据源：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create each cell with a specific style, we extract the `UITableViewCellStyle`
    value from the `cellStyles` field, according to the current row:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个单元格创建具有特定样式的单元格，我们根据当前行从 `cellStyles` 字段中提取 `UITableViewCellStyle` 值：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To set the `DetailTextLabel` text for each cell, we just make sure we are not
    trying to set it on a cell with `Default` style, as the first one in this example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个单元格设置 `DetailTextLabel` 文本，我们只需确保我们不是在具有 `Default` 样式的单元格上设置它，如本例中的第一个：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Further customization can be done in a `UITableViewCell`. All views a cell contains,
    including the `TextLabel` and `DetailTextLabel,` are sub-views to the cell's view,
    which is exposed through its `ContentView` property. We can create custom views
    and add them as sub-views to it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 `UITableViewCell` 中进行进一步的自定义。单元格包含的所有视图，包括 `TextLabel` 和 `DetailTextLabel`，都是单元格视图的子视图，该视图通过其
    `ContentView` 属性公开。我们可以创建自定义视图并将其作为子视图添加到其中。
- en: Other useful properties of the UITableViewCell class
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UITableViewCell` 类的其他有用属性'
- en: 'Apart from adding text in the default labels, the `UITableViewCell` contains
    some other properties, whose values we can set, to add more default items in a
    cell:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在默认标签中添加文本外，`UITableViewCell` 还包含一些其他属性，我们可以设置它们的值，以在单元格中添加更多默认项：
- en: '`ImageView:` This property accepts a `UIImageView`. We can use it to display
    an image in a cell, on its left side.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageView:` 这个属性接受一个 `UIImageView`。我们可以用它来在单元格的左侧显示一个图像。'
- en: '`AccessoryView:` This property accepts any instance of `UIView`. Its position
    defaults to the right of the cell, in the place of the cell''s `Accessory`, which
    is located at the right side of the cell.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccessoryView:` 这个属性接受任何 `UIView` 实例。它的默认位置是单元格的右侧，在单元格的 `Accessory` 位置，位于单元格的右侧。'
- en: '`Accessory:` This property accepts values of the type `UITableViewCellAccessory`.
    It provides predefined views for the cell''s accessory, such as a `DetailDisclosureButton`
    or a `Checkmark`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accessory:` 这个属性接受 `UITableViewCellAccessory` 类型的值。它为单元格的附件提供预定义视图，例如 `DetailDisclosureButton`
    或 `Checkmark`。'
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying data in a table*'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*'
- en: '*Editing data in a table*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中编辑数据*'
- en: 'Editing a table: deleting rows'
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑表格：删除行
- en: In this recipe, we will discuss how to delete rows from a `UITableView`, with
    appropriate feedback to the user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何从 `UITableView` 中删除行，并提供适当的用户反馈。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `EditingTableDataApp`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `EditingTableDataApp`。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add a view controller to the project, and convert it to a `UITableViewController`
    as described in the *Displaying data in a table* section in this chapter, and
    name it `TableController`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图控制器添加到项目中，并将其转换为本章中 *在表格中显示数据* 部分所述的 `UITableViewController`，并将其命名为 `TableController`。
- en: 'Add a `UINavigationController` in the `AppDelegate` class. Initialize it, setting
    the `TableController` as its root controller:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类中添加一个 `UINavigationController`。初始化它，将 `TableController` 设置为其根控制器：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Back in MonoDevelop, add three fields in the TableController class: `List<string>
    tableData, UIBarButtonItem buttonEdit`, and `UIBarButtonItem buttonDone`. Override
    the class'' `ViewDidLoad` method, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中，在 `TableController` 类中添加三个字段：`List<string> tableData`、`UIBarButtonItem
    buttonEdit` 和 `UIBarButtonItem buttonDone`。重写类的 `ViewDidLoad` 方法，如下所示：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a proper table view source for the table, which accepts the `tableData`
    generic `List` as an argument in its constructor. Create the handler method `ButtonEdit_Clicked`,
    and enter the following code in it:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为表格创建适当的表格视图源，它在构造函数中接受 `tableData` 泛型 `List` 作为参数。创建处理方法 `ButtonEdit_Clicked`，并在其中输入以下代码：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the handler method `ButtonDone_Clicked`, and enter the following code
    in it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建处理方法 `ButtonDone_Clicked`，并在其中输入以下代码：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, override the `CommitEditingStyle` method of the table source:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重写表格源代码中的 `CommitEditingStyle` 方法：
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing we do here is make use of the navigation bar to add buttons
    that will handle the table''s edit mode. When the view loads, we set the edit
    button with the `SetRightBarButtonItem` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们首先使用导航栏添加按钮来处理表格的编辑模式。当视图加载时，我们使用 `SetRightBarButtonItem` 方法设置编辑按钮：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside the `ButtonEdit_Clicked` method, we set the table to editing mode. Then,
    we change the button in the navigation bar so that the user can exit from editing:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ButtonEdit_Clicked` 方法内部，我们将表格设置为编辑模式。然后，我们更改导航栏中的按钮，以便用户可以退出编辑模式：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `SetEditing` method enables or disables the table''s editing mode. When
    a table view is in editing mode, a round red icon with the minus (-) symbol appears
    on the left side of each cell. When the user taps the icon, a confirmation red
    **Delete** button appears in the cell. To actually delete the row when the user
    confirms deletion by tapping on the **Delete** button, we must implement the `CommitEditingStyle`
    method in the table source:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetEditing` 方法用于启用或禁用表格的编辑模式。当表格处于编辑模式时，每个单元格左侧会出现一个带有减号 (-) 符号的圆形红色图标。当用户点击该图标时，单元格中会出现一个确认的红色
    **删除** 按钮。要实际删除用户通过点击 **删除** 按钮确认删除的行，我们必须在表格源中实现 `CommitEditingStyle` 方法：'
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first thing we need to do is check if the method was called as a result
    of the user tapping the `Delete` button. This is done by checking the `editingStyle`
    parameter, highlighted in this code. Then, we delete the data of the row from
    the data source and the row from the table with the `DeleteRows` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是检查该方法是否是由于用户点击 `删除` 按钮而调用的。这是通过检查 `editingStyle` 参数来完成的，如代码中所突出显示的。然后，我们使用
    `DeleteRows` 方法从数据源和表格中删除行的数据。
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The table view provides another, more direct way to the user for deleting rows.
    This can be accomplished by swiping the finger on the cell we want to delete.
    In this case, only the **Delete** button is shown. We still need to implement
    the `CommitEditingStyle` method in the table source to actually remove the row
    from the table.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表视图为用户提供了另一种更直接的方式来删除行。这可以通过在想要删除的单元格上滑动手指来实现。在这种情况下，只会显示 **删除** 按钮。我们仍然需要在表格源中实现
    `CommitEditingStyle` 方法，以实际从表格中删除行。
- en: The fact that a navigation controller was used in this recipe doesn't mean it
    is the only way to accomplish the function of deleting rows. It is, however, a
    combination of view controllers that will be used most of the time, in real-world
    application scenarios.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中使用导航控制器并不意味着它是实现删除行功能的唯一方法。然而，它是一种在现实世界的应用场景中将被广泛使用的视图控制器组合。
- en: Row removal animations
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 行删除动画
- en: The `UITableViewRowAnimation` enumeration used in the `DeleteRows` method represents
    the type of animation a row will be removed by. It contains various values (Left,
    `Right, Middle, Fade, Top, Bottom`, and `None)` for animating the row. Note that
    to accomplish the best result, the type of animation should be used according
    to the position of the row in the data source. For example, if the row to be removed
    is the last one on the table, it is best to use `UITableViewRowAnimation.Bottom`
    so that the row that should be removed will move downwards. If the row to be removed
    is the first one in the data source, it is best to use `UITableViewRowAnimation.Top`
    so the row that should be removed will move upwards. The rest of the options are
    more suitable for the intermediate rows, between the first and last.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DeleteRows` 方法中使用的 `UITableViewRowAnimation` 枚举表示将要被删除的行的动画类型。它包含各种值（Left，`Right`，Middle，Fade，Top，Bottom
    和 `None`），用于动画行。请注意，为了实现最佳效果，应根据行在数据源中的位置使用动画类型。例如，如果将要删除的行是表格中的最后一行，最好使用 `UITableViewRowAnimation.Bottom`，这样应该删除的行会向下移动。如果将要删除的行是数据源中的第一行，最好使用
    `UITableViewRowAnimation.Top`，这样应该删除的行会向上移动。其余选项更适合中间行，即在第一行和最后一行之间。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying data in a table*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*'
- en: '*Editing a table: Inserting rows*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑表格：插入行*'
- en: 'In this book:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 3](ch03.html "Chapter 3. User Interface: View Controllers"), User
    Interface: View Controllers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。用户界面：视图控制器")，用户界面：视图控制器：'
- en: '*Navigating through different view controllers*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同视图控制器之间导航*'
- en: 'Editing a table: inserting rows'
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑表格：插入行
- en: In this recipe, we will learn how to provide the user with the ability to insert
    rows in a `UITableView`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何为用户在 `UITableView` 中提供插入行的能力。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this task, we will use the project `EditingTableDataApp` from the previous
    task. Open it in MonoDevelop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将使用上一个任务中的项目 `EditingTableDataApp`。在 MonoDevelop 中打开它。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add another `UIBarButtonItem` field in the `TableController` class, and initialize
    it in the `ViewDidLoad` method:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TableController` 类中添加另一个 `UIBarButtonItem` 字段，并在 `ViewDidLoad` 方法中初始化它：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Add the handler method `ButtonAdd_Clicked:`
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理方法 `ButtonAdd_Clicked:`
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `ButtonEdit_Clicked` method, add the following line:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ButtonEdit_Clicked` 方法中添加以下行：
- en: '[PRE32]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also add the following line in the `ButtonDone_Clicked` method:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在`ButtonDone_Clicked`方法中添加以下行：
- en: '[PRE33]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Compile and run the app on the simulator.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap the **Edit** button, and see the add button appear on the leftside in the
    navigation bar. Tap it and see the new row is added to the table.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**编辑**按钮，你会看到添加按钮出现在导航栏的左侧。点击它，你会看到新行被添加到表格中。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A system-default **Add** button is used here. When the user taps on the button,
    a new row is added in the table. The button is added in the edit button''s `Clicked`
    handler as the left button in the navigation bar. To remove it, we call the same
    method, passing as the `UIBarButtonItem` parameter, which is a `null` value inside
    the `ButtonDone_Clicked` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了一个系统默认的**添加**按钮。当用户点击按钮时，表格中会添加一行。按钮作为导航栏中的左侧按钮添加到编辑按钮的`Clicked`处理程序中。要移除它，我们调用相同的函数，将`UIBarButtonItem`参数传递为`null`值，在`ButtonDone_Clicked`方法中：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This way, when the user disables the editing mode, the `add` button will disappear.
    Next, all we need to do to add a row is add the data to the data source and force
    the table to reload, which is done as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当用户禁用编辑模式时，`添加`按钮将消失。接下来，我们只需将数据添加到数据源中，并强制表格重新加载，具体操作如下：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This is the simplest way of inserting rows in a table. It is not the most efficient
    though. Calling the `UITableView.ReloadData` method causes the `UITableView` to
    reload everything, which will degrade performance if the table contains a large
    number of rows. To avoid this, you can replace the `ReloadData` call in this example
    with the following line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在表格中插入行最简单的方法。但这并不是最有效的方法。调用`UITableView.ReloadData`方法会导致`UITableView`重新加载所有内容，如果表格包含大量行，这将降低性能。为了避免这种情况，您可以将此示例中的`ReloadData`调用替换为以下行：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `InsertRows` method causes the table view to reload only the part of its
    contents that are needed, in this case the last item in the data source. Note
    that with this method, we can also specify in which section of the table the cell
    will be inserted.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertRows`方法只会重新加载表格内容中所需的部分，在本例中是数据源中的最后一个项目。注意，使用此方法，我们还可以指定单元格将被插入表格的哪个部分。'
- en: Row re-ordering
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行重新排序
- en: 'Another useful feature of the `UITableView` class is that of re-ordering rows.
    To demonstrate this, add the following method overrides in the table source:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView`类的另一个有用功能是行重新排序。为了演示这一点，在表源中添加以下方法重写：'
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Returning `true` in the `CanMoveRow` method enables re-ordering for all cells.
    This is indicated by a grip appearance icon displaying on the right side in each
    cell. When the user touches and drags the icon, the cell can be moved to another
    position. Inside the `MoveRow` method is where the actual re-ordering occurs.
    The only thing that needs to be done is to remove and re-insert the item in the
    data source in the desired index, using the `sourceIndexPath` and `destinationIndexPath`
    parameters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CanMoveRow`方法中返回`true`可以启用所有单元格的重新排序。这通过在每个单元格右侧显示的抓手外观图标来表示。当用户触摸并拖动图标时，单元格可以被移动到另一个位置。实际的重新排序发生在`MoveRow`方法中。需要做的只是使用`sourceIndexPath`和`destinationIndexPath`参数，在数据源中移除并重新插入项目到期望的索引。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying data in a table*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*'
- en: '*Editing a table: deleting rows*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编辑表格：删除行*'
- en: Table indexing
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表索引
- en: In this recipe, we will learn how to provide an index in a table, allowing the
    user to browse through the rows of a `UITableView` quicker.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何在表格中提供一个索引，使用户能够更快地浏览`UITableView`中的行。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `TableIndexApp`. Add a `UITableViewController`
    as shown in the previous tasks in this chapter, and implement the `TableSource`
    class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`TableIndexApp`。添加一个`UITableViewController`，如本章前面的任务所示，并实现`TableSource`类。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the table source class, override and implement the following methods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在表源类中，重写并实现以下方法：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The table source created in this task contains many different sections. For
    simplicity, each section contains one row. The `NumberOfSections` method returns
    the total number of sections the table will display.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中创建的表源包含许多不同的部分。为了简单起见，每个部分包含一行。`NumberOfSections`方法返回表格将显示的总部分数。
- en: 'To set a title for each section, we must override the `TitleForHeader` method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个部分设置标题，我们必须重写`TitleForHeader`方法：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This implementation returns the first letter of each string in the data source.
    To provide the index, we override the `SectionIndexTitles` method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现返回数据源中每个字符串的第一个字母。为了提供索引，我们重写了`SectionIndexTitles`方法：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, it returns the first letter of each item in the data source. The result
    of this project will be similar to the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，它返回数据源中每个项目的第一个字母。此项目的结果将类似于以下：
- en: '![How it works...](img/1468EXP_05_03.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1468EXP_05_03.jpg)'
- en: When the user touches somewhere on the index, the table view will automatically
    scroll to that specific section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户触摸索引上的任何位置时，表格视图将自动滚动到该特定部分。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Indexing should be applied on tables with a `Plain` style. Applying an index
    in tables with a `Grouped` style set is not advisable, because the index will
    not be easily distinguished.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 应在具有`Plain`样式的表格上应用索引。在设置了`Grouped`样式的表格上应用索引是不推荐的，因为索引将不易区分。
- en: A good example of a native iOS application with an index on a table can be found
    in the native `Contacts` application.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有表格索引的本地iOS应用程序的好例子可以在本地的`Contacts`应用程序中找到。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying data in a table*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*'
- en: '*Searching through the data*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*搜索数据*'
- en: Searching through the data
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索数据
- en: In this recipe, we will learn how to provide search functionality for the content
    in a table view.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何为表格中的内容提供搜索功能。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `SearchTableApp`. Add a `UITableViewController`,
    and name it `TableController`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`SearchTableApp`。添加一个`UITableViewController`，并将其命名为`TableController`。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open the `TableController.xib` file in Interface Builder.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`TableController.xib`文件。
- en: Add a **Search Bar** and **Search Display Controller** in the `UITableView`.
    Note that after this action, some outlets are created and connected automatically.
    We need most of them, so we leave them as they are and save the document.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UITableView`中添加**搜索栏**和**搜索显示控制器**。请注意，在此操作之后，将自动创建并连接一些输出。我们需要大多数它们，所以我们保留它们原样并保存文档。
- en: 'Back in MonoDevelop, implement a class that will act as a delegate object for
    the search display controller:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到MonoDevelop，实现一个将作为搜索显示控制器委托对象的类：
- en: '[PRE41]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Override the `ViewDidLoad` method and assign the source and delegate objects
    in it:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`ViewDidLoad`方法，并在其中分配源和委托对象：
- en: '[PRE42]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can find the complete code in the `SearchTableApp` project. The result
    will be the common iOS search bar above the table, similar to the following screenshot:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`SearchTableApp`项目中找到完整的代码。结果将是表格上方的常见iOS搜索栏，类似于以下截图：
- en: '![How to do it...](img/1468EXP_05_04.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/1468EXP_05_04.jpg)'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `UISearchDisplayController` class provides a convenient way of search through
    data. It contains a `UISearchBar` that accepts input from the user and a `UITableView`
    that is used to display the results. After we add a search controller in a view
    controller, we can access it through that controller''s `SearchDisplayController`
    property. To trigger the results table, we must implement a `UISearchDisplayDelegate`
    and override its `ShouldReloadForSearchString`, which returns a boolean value:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`UISearchDisplayController`类提供了一个方便的搜索数据的方法。它包含一个`UISearchBar`，用于接受用户的输入，以及一个`UITableView`，用于显示结果。在我们在视图控制器中添加搜索控制器后，我们可以通过该控制器的`SearchDisplayController`属性访问它。为了触发结果表格，我们必须实现`UISearchDisplayDelegate`并重写其`ShouldReloadForSearchString`，它返回一个布尔值：'
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Inside the `ShouldReloadForSearchString` method override, we search our data
    source saving the filtered results in a new data source, according to its `forSearchString`
    parameter:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShouldReloadForSearchString`方法重写中，我们根据其`forSearchString`参数搜索数据源，将过滤后的结果保存在一个新的数据源中：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We then sort the results alphabetically and return `true`, so that the search
    controller''s table will reload its data:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按字母顺序对结果进行排序并返回`true`，这样搜索控制器的表格就会重新加载数据：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The search controller''s table view also needs a source object. In this example,
    we set it to the same object that we created for our table:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索控制器的表格视图也需要一个源对象。在这个例子中，我们将其设置为为我们表格创建的相同对象：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since we are using instances of the same object, we need to modify some things
    in it to display data according to which table calls it. So, for example, the
    `RowsInSection` method looks like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是相同对象的实例，我们需要对其进行一些修改以根据调用它的表格显示数据。例如，`RowsInSection`方法看起来如下：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This way, we return the number of rows according to which table calls the method.
    Similarly, we need to set each cell''s text label inside the `GetCell` method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就根据表格调用该方法返回行数。同样，我们还需要在`GetCell`方法内部设置每个单元格的文本标签：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There's more...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When the user taps on the search bar, the keyboard appears, setting the search
    controller active. To de-activate it, we can hook on the search bar''s `SearchButtonClicked`
    event. This event will get triggered when the user taps on the keyboard''s **Search**
    button:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击搜索栏时，键盘出现，设置搜索控制器为活动状态。要使其不活动，我们可以挂钩到搜索栏的`SearchButtonClicked`事件。当用户点击键盘上的**搜索**按钮时，此事件将被触发：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `SetActive` method is what we can use to enable or disable the search controller.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetActive`方法是我们用来启用或禁用搜索控制器的。'
- en: Providing search functionality to other controllers.
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为其他控制器提供搜索功能。
- en: Although this example uses a `UISearchDisplayController` in a `UITableViewController`,
    it does not mean that it is the only way it can be used. We can use a search controller
    with whatever kind of `UIViewController` we want. The only extra thing we need
    to do in this case is set the search controller's `SearchContentsController` property
    to the view controller it belongs to. This is being taken care of automatically
    by Interface Builder when we add a `UISearchDisplayController` in a `UITableViewController`,
    but not with other controllers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子在`UITableViewController`中使用了一个`UISearchDisplayController`，但这并不意味着它是唯一的使用方式。我们可以使用任何我们想要的`UIViewController`类型的搜索控制器。在这种情况下，我们唯一需要做的额外事情是将搜索控制器的`SearchContentsController`属性设置为它所属的视图控制器。当我们在`UITableViewController`中添加`UISearchDisplayController`时，Interface
    Builder会自动处理这一点，但不是在其他控制器中。
- en: See also
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying data in a table*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*'
- en: '*Table indexing*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表格索引*'
- en: Creating a simple web browser
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单的网页浏览器
- en: In this recipe, we will discuss displaying online content with the `UIWebView`
    class.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论使用`UIWebView`类显示在线内容。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `WebBrowserApp`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`WebBrowserApp`。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open the `MainController.xib` file in Interface Builder, and add a `UIWebView`
    object on the main View.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`MainController.xib`文件，并在主视图中添加一个`UIWebView`对象。
- en: Create and connect an outlet for it with the name `webView`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并连接一个名为`webView`的出口。
- en: Save the document.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Override the `ViewDidAppear` method in the `MainController` class:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`类中重写`ViewDidAppear`方法：
- en: '[PRE50]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Compile and run the application on the simulator. Watch the website load on
    the screen!
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。观察屏幕上网站加载的情况！
- en: How it works...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIWebView` class is iOS SDK''s web browser control. To load web content,
    we just have to call its `LoadRequest` method, which accepts a parameter of the
    type `NSUrlRequest`. The `NSUrlRequest` object contains the URL we want it to
    load:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView`类是iOS SDK的网页浏览器控件。要加载网页内容，我们只需调用其`LoadRequest`方法，该方法接受一个类型为`NSUrlRequest`的参数。`NSUrlRequest`对象包含我们想要它加载的URL：'
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `UIWebView` class contains some very useful events:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView`类包含一些非常有用的事件：'
- en: '`LoadStarted:` It is triggered when the control has started loading content'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadStarted:` 当控件开始加载内容时触发'
- en: '`LoadFinished:` It is triggered when the content has finished loading successfully'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadFinished:` 当内容成功加载完成时触发'
- en: '`LoadError:` It is triggered when loading of the content has failed'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadError:` 当内容加载失败时触发'
- en: Scaling content
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容缩放
- en: Another important feature of the `UIWebView` is the automatic scaling of content.
    It can be activated by setting its `ScalePageToFit` property to `true`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView`类的另一个重要功能是内容的自动缩放。可以通过将其`ScalePageToFit`属性设置为`true`来激活它。'
- en: See also
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying local content*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示本地内容*'
- en: '*Displaying formatted text*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示格式化文本*'
- en: '*Displaying documents*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示文档*'
- en: Displaying local content
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示本地内容
- en: In this recipe, we will discuss displaying local HTML files.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论显示本地HTML文件。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `LocalContentApp`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`LocalContentApp`。
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Add a `UIWebView` on the main view of `MainController`, and save the document.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的主视图中添加一个`UIWebView`，并保存文档。
- en: Add a new folder to the project, and name it `html_content.`
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新的文件夹，并将其命名为`html_content`。
- en: Add your content to that folder through MonoDevelop. Don't forget to set each
    file's **Build Action** to **Content**.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 MonoDevelop 将您的内容添加到该文件夹中。别忘了将每个文件的 **构建操作** 设置为 **内容**。
- en: 'Override the `ViewDidAppear` method in the `MainController` class, and enter
    the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类中重写 `ViewDidAppear` 方法，并输入以下代码：
- en: '[PRE52]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Compile and run the application on the simulator.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: View your HTML content displayed on the screen.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看屏幕上显示的 HTML 内容。
- en: Zoom in to view the content larger, just like you would do for online content.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放大以查看更大的内容，就像您在线内容中做的那样。
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The process of displaying local content is the same as displaying online content.
    The `NSUrl` class has a static method that creates an instance, based on a file
    path:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 显示本地内容的过程与显示在线内容相同。`NSUrl` 类有一个静态方法，根据文件路径创建一个实例：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There's more...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `UIWebView` is a very powerful control. It can be used to display everything
    the Safari browser on iOS can. This includes HTML, plain text, images, and PDF
    documents.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView` 是一个非常强大的控件。它可以用来显示 iOS 上 Safari 浏览器可以显示的一切。这包括 HTML、纯文本、图片和 PDF
    文档。'
- en: Navigating through content
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在内容中导航
- en: You can also navigate through the history of `UIWebView` with its `GoBack()`
    and `GoForward()` methods.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用其 `GoBack()` 和 `GoForward()` 方法在 `UIWebView` 的历史记录中导航。
- en: UIWebView supported files
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIWebView 支持的文件
- en: 'The `UIWebView` control can be used to display other types of files as well.
    These file types are:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView` 控件也可以用来显示其他类型的文件。这些文件类型包括：'
- en: '**Excel (.xls)**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Excel (.xls)**'
- en: '**Keynote (.key.zip)**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Keynote (.key.zip)**'
- en: '**Numbers (.numbers.zip)**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字文件 (.numbers.zip)**'
- en: '**Pages (.pages.zip)**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pages (.pages.zip)**'
- en: '**PDF (.pdf)**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PDF (.pdf)**'
- en: '**PowerPoint (.ppt)**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PowerPoint (.ppt)**'
- en: '**Word (.doc)**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Word (.doc)**'
- en: '**Rich Text Format** (.rtf)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**富文本格式** (.rtf)'
- en: '**Rich Text Format Directory (.rtfd.zip)**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**富文本格式目录 (.rtfd.zip)**'
- en: '**Keynote ''09 (.key)**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Keynote ''09 (.key)**'
- en: '**Numbers ''09 (.numbers)**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Numbers ''09 (.numbers)**'
- en: '**Pages ''09 (.pages)**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pages ''09 (.pages)**'
- en: See also
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating a simple web browser*'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个简单的网页浏览器*'
- en: '*Displaying documents*'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示文档*'
- en: Displaying formatted text
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示格式化文本
- en: In this chapter, we will learn how to use the `UIWebView` class to display formatted
    text.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 `UIWebView` 类来显示格式化文本。
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this task, we will work on the `LocalContentApp` project discussed previously.
    Open it in MonoDevelop.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将处理之前讨论过的 `LocalContentApp` 项目。在 MonoDevelop 中打开它。
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Comment out the previous code in the `ViewDidAppear` method, and add the following:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidAppear` 方法中注释掉之前的代码，并添加以下代码：
- en: '[PRE54]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Compile and run the application on the simulator.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Watch how the HTML string is displayed.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察 HTML 字符串的显示。
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As discussed in [Chapter 2](ch02.html "Chapter 2. User Interface: Views"),
    *User Interface: Views*, the `UITextView` can be used to display large blocks
    of text and edit it, but it cannot display formatted text. The `UIWebView` can
    do this by passing our HTML-formatted text as a parameter to the `LoadHtmlString`
    method:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 [第 2 章](ch02.html "第 2 章。用户界面：视图") 中讨论的，*用户界面：视图*，`UITextView` 可以用来显示大块文本并进行编辑，但它不能显示格式化文本。`UIWebView`
    可以通过将我们的 HTML 格式化文本作为参数传递给 `LoadHtmlString` 方法来实现这一点：
- en: '[PRE55]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The second parameter is of the type `NSUrl`. Since we have created our HTML
    string in-code and there are no external references to other files, we don't need
    it, and so we just pass `null`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数的类型是 `NSUrl`。由于我们在代码中创建了 HTML 字符串，并且没有对其他文件的引用，所以我们不需要它，因此我们只需传递 `null`。
- en: There's more...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we would like to reference external files inside our HTML string, we should
    set the `NSUrl` parameter of `LoadHtmlString` to the path that contains the files,
    thus setting the base directory for the HTML. For example, consider the following
    HTML string, which references a file inside the `html_content` folder of the application
    bundle:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 HTML 字符串内部引用外部文件，我们应该将 `LoadHtmlString` 的 `NSUrl` 参数设置为包含文件的路径，从而设置 HTML
    的基本目录。例如，考虑以下 HTML 字符串，它引用了应用程序包中 `html_content` 文件夹内的文件：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we were to pass it to the `LoadHtmlString` to display the image, we should
    have also set the `baseUrl` parameter:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将其传递给 `LoadHtmlString` 来显示图片，我们还应该设置 `baseUrl` 参数：
- en: '[PRE57]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `bool` parameter of the `NSUrl` constructor indicates that the URL string
    of the first parameter is a path to a directory and should be treated like one.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSUrl` 构造函数的 `bool` 参数表示第一个参数的 URL 字符串是目录的路径，应该像目录一样处理。'
- en: Note
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Although the `UIWebView` can display a wide variety of content, it cannot be
    used to edit it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `UIWebView` 可以显示各种内容，但不能用于编辑。
- en: Allowing specific links
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许特定的链接
- en: The `UIWebView` also provides control on how links that the user taps on be
    treated. To do this, we can assign a handler to its `ShouldStartLoad` property.
    It accepts delegates of the type `UIWebLoaderControl`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView` 还提供了对用户点击的链接如何处理的控制。为此，我们可以将其 `ShouldStartLoad` 属性分配一个处理程序。它接受
    `UIWebLoaderControl` 类型的代理。'
- en: See also
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating a simple web browser*'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个简单的网页浏览器*'
- en: '*Displaying local content*'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示本地内容*'
- en: 'In this book:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"),User Interface: Views:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章. 用户界面：视图"), 用户界面：视图：'
- en: '*Displaying and editing text*'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和编辑文本*'
- en: Displaying documents
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示文档
- en: In this recipe, we will discuss how to easily display various documents of different
    formats with the `QLPreviewController` class.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将讨论如何使用 `QLPreviewController` 类轻松显示不同格式的各种文档。
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `DocumentPreviewApp`. Add a
    view with controller, and name it `MainController`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `DocumentPreviewApp`。添加一个带有控制器的视图，并将其命名为 `MainController`。
- en: How to do it...
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `MainController.xib` file in Interface Builder and add a `UIButton`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `MainController.xib` 文件并添加一个 `UIButton`。
- en: Save the document.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Add a folder named `docs` to the project and put some document files in it.
    The project `DocumentPreviewApp` contains three different documents: a `PDF`,
    a `DOCX`, and an `XLSX`.'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个名为 `docs` 的文件夹，并将一些文档文件放入其中。项目 `DocumentPreviewApp` 包含三种不同的文档：一个 `PDF`、一个
    `DOCX` 和一个 `XLSX`。
- en: 'Enter the following `using` directive in the `MainController.cs` file:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController.cs` 文件中输入以下 `using` 指令：
- en: '[PRE58]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create the following nested class inside the `MainController` class:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类内部创建以下嵌套类：
- en: '[PRE59]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Enter the following code in the `ViewDidLoad` override of the `MainController:`
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的 `ViewDidLoad` 重写中输入以下代码：
- en: '[PRE60]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `QLPreviewController` class provides a very convenient way of displaying
    multiple document formats at once. It is a controller that can be displayed either
    by pushing it in a navigation controller stack, or by presenting it modally.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLPreviewController` 类提供了一种非常方便的方式，可以一次性显示多种文档格式。它是一个可以通过将其推入导航控制器堆栈或以模态方式显示的控制器。'
- en: 'To define the documents that we want it to display, we have to create a `QLPreviewControllerDataSource`
    class and assign it to its `DataSource` property:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们想要显示的文档，我们必须创建一个 `QLPreviewControllerDataSource` 类并将其分配给其 `DataSource`
    属性：
- en: '[PRE61]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `QLPreviewControllerDataSource` contains two methods we need to override:
    `PreviewItemCount`, which returns the number of items the controller has to display,
    and `GetPreviewItem,` which returns the actual item. This item is of the type
    `QLPreviewItem`, and we have to implement a method that inherits it:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLPreviewControllerDataSource` 包含两个我们需要重写的方法：`PreviewItemCount`，它返回控制器需要显示的项目数量，以及
    `GetPreviewItem`，它返回实际的项目。此项目是 `QLPreviewItem` 类型，我们必须实现一个继承它的方法：'
- en: '[PRE62]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this class, we have to override two properties, both of which represent the
    information of the item to be previewed. These are `ItemTitle` and `ItemUrl`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类中，我们必须重写两个属性，这两个属性都代表要预览的项目信息。这些是 `ItemTitle` 和 `ItemUrl`。
- en: 'When the controller calls the `PreviewItemCount` method and it returns a number
    more than `1`, it adds a `UIToolbar` with two arrow buttons that allows the user
    to navigate through the documents. When the `GetPreviewItem` method is called,
    it sets the current title to its `ItemTitle` property and loads the document according
    to the `ItemUrl` property. If the button is tapped in this application, the result
    will be similar to the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制器调用 `PreviewItemCount` 方法并且返回一个大于 `1` 的数字时，它会添加一个带有两个箭头按钮的 `UIToolbar`，允许用户在文档之间导航。当调用
    `GetPreviewItem` 方法时，它会将当前标题设置为 `ItemTitle` 属性，并根据 `ItemUrl` 属性加载文档。如果在此应用程序中点击按钮，结果将类似于以下内容：
- en: '![How it works...](img/1468EXP_05_05.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1468EXP_05_05.jpg)'
- en: This screenshot displays the `QLPreviewController` after navigating to the last
    document that is a file of the type `XLSX`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图显示了导航到最后一个文档（`XLSX` 类型的文件）后的 `QLPreviewController`。
- en: There's more...
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The controller contains a system-default **Done** button on its navigation bar.
    If the button is tapped, the controller is automatically dismissed. We can hook
    on its `WillDismiss` and/or `DidDismiss` events to provide extra behavior.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器在其导航栏上包含一个系统默认的**完成**按钮。如果按下该按钮，控制器将自动关闭。我们可以通过其`WillDismiss`和/或`DidDismiss`事件来提供额外的行为。
- en: See also
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying local content*'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示本地内容*'
- en: '*Displaying formatted text*'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示格式化文本*'
