<html><head></head><body><div><div><h1 id="_idParaDest-118"><a id="_idTextAnchor148"/>Chapter 9: Exploring Interoperability APIs</h1>
			<p>The aim of this book is to show you how to develop beautiful, fast, and maintainable Jetpack Compose apps. The previous chapters helped you get familiar with core techniques and principles, as well as important interfaces, classes, packages, and—of course—composable functions. The remaining chapters cover topics beyond a successful adoption of Android's new declarative user interface toolkit.</p>
			<p>In this chapter, we are going to look at <code>AndroidView()</code>, <code>AndroidViewBinding()</code>, and <code>ComposeView</code> as the interoperability <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) of Jetpack Compose. The main sections are listed here:</p>
			<ul>
				<li>Showing Views in a Compose app</li>
				<li>Sharing data between Views and composable functions</li>
				<li>Embedding composables in View hierarchies</li>
			</ul>
			<p>We start by looking at how to show a traditional View hierarchy in a Compose app. Imagine you have written a custom component (which under the hood consists of several UI elements), such as an image picker, a color chooser, or a camera preview. Instead of rewriting your component with Jetpack Compose, you can save your investment by simply reusing it. A lot of third-party libraries are still written in Views, so I will show you how to use them in Compose apps.</p>
			<p>Once you have embedded a View in a Compose app, you need to share data between the View and your composable functions. The <em class="italic">Sharing data between Views and composable functions</em> section explains how to do this with ViewModels.</p>
			<p>Often, you may not want to rewrite an app from scratch but migrate it to Jetpack Compose gradually, replacing View hierarchies with composable functions step by step. The final main section, <em class="italic">Embedding composables in View hierarchies</em>, discusses how to include a Compose hierarchy in existing View-based apps.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor149"/>Technical requirements</h1>
			<p>This chapter is based on the <code>ZxingDemo</code> and <code>InteropDemo</code> samples. Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em><em class="italic">,</em> for information about how to install and set up Android Studio, and how to get the repository accompanying this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_09">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_09</a>.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor150"/>Showing Views in a Compose app</h1>
			<p>Imagine you have <a id="_idIndexMarker317"/>written a View-based custom <a id="_idIndexMarker318"/>component for one of your previous apps—for example, an image picker, a color chooser, or a camera preview—or you would like to include <a id="_idIndexMarker319"/>a third-party library such as <em class="italic">Zebra Crossing</em> (<em class="italic">ZXing</em>) to scan <strong class="bold">Quick Response</strong> (<strong class="bold">QR</strong>) codes and barcodes. To incorporate them into a Compose app, you need to add the View (or the root of a View hierarchy) to your composable functions.</p>
			<p>Let's see how this works.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor151"/>Adding custom components to a Compose app</h2>
			<p>The <code>ZxingDemo</code> sample, shown in the following screenshot, uses the <em class="italic">ZXing Android Embedded</em> barcode <a id="_idIndexMarker320"/>scanner library for Android, which is based on the ZXing decoder. It is released under the terms of the Apache License 2.0 and is hosted on GitHub (<a href="https://github.com/journeyapps/zxing-android-embedded">https://github.com/journeyapps/zxing-android-embedded</a>):</p>
			<div><div><img src="img/B17505_09_1.jpg" alt="Figure 9.1 – The ZxingDemo sample&#13;&#10;" width="730" height="973"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The ZxingDemo sample</p>
			<p>My example continuously scans for barcodes and QR codes. The decorated barcode view is <a id="_idIndexMarker321"/>provided by the library. If the scanner engine provides a result, the corresponding text is shown as an overlay using <code>Text()</code>. To use <em class="italic">ZXing Android Embedded</em>, you need to add an implementation dependency to your module-level <code>build.gradle</code> file, as follows:</p>
			<pre>implementation 'com.journeyapps:zxing-android-embedded:4.3.0'</pre>
			<p>The scanner accesses the camera and (optionally) the device vibrator. The app must request at least <code>android.permission.WAKE_LOCK</code> and <code>android.permission.CAMERA</code> permissions in the manifest, and the <code>android.permission.CAMERA</code> permission during runtime. My implementation is based on <code>ActivityResultContracts.RequestPermission</code>, which replaces the traditional approach overriding <code>onRequestPermissionsResult()</code>. Also, depending on the lifecycle of the activity, the scanner must be paused and resumed. For the sake of simplicity, I use a <code>lateinit</code> variable named <code>barcodeView</code> and invoke <code>barcodeView.pause()</code> and <code>barcodeView.resume()</code> when needed. Please refer to the source code of the project for details. Next, I will show you how to initialize the scanner library. This involves inflating a layout file (named <code>layout.xml</code>), as follows:</p>
			<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;com.journeyapps.barcodescanner.DecoratedBarcodeView
  
  android:id="@+id/barcode_scanner"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:layout_alignParentTop="true" /&gt;</pre>
			<p>The layout consists of only one element, <code>DecoratedBarcodeView</code>. It is configured to fill all available space. The following code snippet is part of <code>onCreate()</code>. Please remember that <code>barcodeView</code> is accessed in some lifecycle functions such as <code>onPause()</code>, and therefore is a <code>lateinit</code> property:</p>
			<pre>val root = layoutInflater.inflate(R.layout.layout, null)
barcodeView = root.findViewById(R.id.barcode_scanner)
val formats = listOf(BarcodeFormat.QR_CODE,
    BarcodeFormat.CODE_39)
barcodeView.barcodeView.decoderFactory =
    DefaultDecoderFactory(formats)
barcodeView.initializeFromIntent(intent)
val callback = object : BarcodeCallback {
  override fun barcodeResult(result: BarcodeResult) {
    if (result.text == null || result.text == text.value) {
      return
    }
    text.value = result.text
  }
}
barcodeView.decodeContinuous(callback)</pre>
			<p>First, <code>layout.xml</code> is inflated and assigned to <code>root</code>. Then, <code>barcodeView</code> is initialized (<code>initializeFromIntent()</code>) and configured (by setting a decoder factory). Finally, the <a id="_idIndexMarker322"/>continuous scanning process is started using <code>decodeContinuous()</code>. The <code>callback</code> lambda expression is invoked every time a new scan result is available. The <code>text</code> variable is defined like this:</p>
			<pre>private val text = MutableLiveData("")</pre>
			<p>I am using <code>MutableLiveData</code>, because it can easily be observed as state. Before I show you how to access it inside a composable function, let's briefly recap, as follows:</p>
			<ul>
				<li>We have set up and activated the scanner library. </li>
				<li>When it detects a barcode or a QR code, it updates the value of a <code>MutableLiveData</code> instance. </li>
				<li>We defined and initialized two <code>View</code> instances—<code>root</code> and <code>barcodeView</code>.</li>
			</ul>
			<p>Next, I show you how to access the state obtained from the ViewModel inside a composable, as follows:</p>
			<pre>setContent {
  val state = text.observeAsState()
  state.value?.let {
    ZxingDemo(root, it)
  }
}</pre>
			<p>The value <a id="_idIndexMarker323"/>of the state and <code>root</code> are passed to the <code>ZxingDemo()</code> composable. We display <code>value</code> using <code>Text()</code>. The <code>root</code> parameter is used to include the View hierarchy in the Compose UI. The code is illustrated in the following snippet:</p>
			<pre>@Composable
fun ZxingDemo(root: View, value: String) {
  Box(
    modifier = Modifier.fillMaxSize(),
    contentAlignment = Alignment.TopCenter
  ) {
    AndroidView(modifier = Modifier.fillMaxSize(),
      factory = {
        root
      })
    if (value.isNotBlank()) {
      Text(
        modifier = Modifier.padding(16.dp),
        text = value,
        color = Color.White,
        style = MaterialTheme.typography.h4
      )
    }
  }
}</pre>
			<p>The UI consists of a <code>Box()</code> composable with two children, <code>AndroidView()</code> and <code>Text()</code>. <code>AndroidView()</code> receives a <code>factory</code> block, which just returns <code>root</code> (the View hierarchy containing the scanner viewfinder). The <code>Text()</code> composable shows the last scan result.</p>
			<p>The <code>factory</code> block is called exactly once, to obtain the View to be composed. It will always be invoked on the UI thread, so you can set View properties as needed. In my example, this is <a id="_idIndexMarker324"/>not needed, as all initialization has already been done in <code>onCreate()</code>. Configuring the barcode scanner should not be done in a composable, because preparing the camera and preview is potentially time-consuming. Also, parts of the component tree are accessed on the activity level, therefore references to children (<code>barcodeView</code>) are needed anyway.</p>
			<p>In this section, I have shown you how to include a View hierarchy in your Compose app using <code>AndroidView()</code>. This composable function is one of the important pieces of the Jetpack Compose interoperability APIs. We used <code>layoutInflater.inflate()</code> to inflate the component tree and <code>findViewById()</code> to access one of its children. Modern View-based apps try to avoid <code>findViewById()</code> and use <em class="italic">View Binding</em> instead. In the next section, you will learn how to combine View Binding and composable functions.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor152"/>Inflating View hierarchies with AndroidViewBinding()</h2>
			<p>Traditionally, activities held references to Views in <code>lateinit</code> properties, if the corresponding <a id="_idIndexMarker325"/>components <a id="_idIndexMarker326"/>needed to be modified in different functions. The <em class="italic">Inflating layout files</em> section of <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, discussed some of the issues with this approach and introduced View Binding as a solution. It was adopted by many apps. Therefore, if you want to migrate an existing app to Jetpack Compose, you likely need to combine View Binding and composable functions. This section explains how to achieve that.</p>
			<p>The following screenshot shows the <code>InteropDemo</code> sample:</p>
			<div><div><img src="img/B17505_09_2.jpg" alt="Figure 9.2 – The InteropDemo sample&#13;&#10;" width="1376" height="461"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – The InteropDemo sample</p>
			<p>The <code>InteropDemo</code> sample consists of two activities. One (<code>ViewActivity</code>) integrates a composable <a id="_idIndexMarker327"/>function in a <code>View</code> hierarchy. We will turn to <a id="_idIndexMarker328"/>this in the <em class="italic">Embedding composables in View hierarchies</em> section. The second one, <code>ComposeActivity</code>, does <a id="_idIndexMarker329"/>the opposite: it inflates a <code>View</code> hierarchy using View Binding and shows the component tree inside a <code>Column()</code> composable. Let's take a look here:</p>
			<pre>class ComposeActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val viewModel: MyViewModel by viewModels()
    …
    se<a id="_idTextAnchor153"/>tContent {
      ViewIntegrationDemo(viewModel) {
        val i = Intent(
          this,
          ViewActivity::class.java
        )
        i.putExtra(KEY, viewModel.sliderValue.value)
        startActivity(i)
      }
    }
  }
}</pre>
			<p>The root <a id="_idIndexMarker330"/>composable is called <code>ViewIntegrationDemo()</code>. It receives a ViewModel and a lambda expression. The <a id="_idIndexMarker331"/>ViewModel is used to share data between the Compose and the <code>View</code> hierarchies, which I will discuss in the <em class="italic">Sharing data between Views and composable functions</em> section. The lambda expression starts <code>ViewActivity</code> and passes a value from the ViewModel (<code>sliderValue</code>). The code is illustrated in the following snippet:</p>
			<pre>@Composable
fun ViewIntegrationDemo(viewModel: MyViewModel,
                        onClick: () -&gt; Unit) {
  val sliderValueState =
    viewModel.sliderValue.observeAsState()
  Scaffold( ... ) {
    Column( ... ) {
      Slider( … )
      AndroidViewBinding(
        modifier = Modifier.fillMaxWidth(),
        factory = CustomBinding::inflate
      ) {
        // Here Views will be updated
      }
    }
  }
}</pre>
			<p><code>Scaffold()</code> is an important integrational composable function. It structures a Compose screen. Besides <a id="_idIndexMarker332"/>top and <a id="_idIndexMarker333"/>bottom bars, it contains some content—in this case, a <code>Column()</code> composable with two children, <code>Slider()</code> and <code>AndroidViewBinding()</code>. The slider gets its current value from a ViewModel and propagates changes back to it. You will learn more about that in the <em class="italic">Revisiting ViewModels</em> section.</p>
			<p><code>AndroidViewBinding()</code> is similar to <code>AndroidView()</code>. A <code>factory</code> block creates a View hierarchy to be composed. <code>CustomBinding::inflate</code> inflates the layout from the <code>custom.xml</code> file represented by <code>CustomBinding</code> and returns an instance of this type. The class is created and updated during builds. It provides constants that reflect the contents of a layout file named <code>custom.xml</code>. Here is an abridged version:</p>
			<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.<strong class="bold">ConstraintLayout</strong>
  
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"&gt;
  &lt;com.google.android.material.textview.<strong class="bold">MaterialTextView</strong>
    android:id="<strong class="bold">@+id/textView</strong>"
    ... /&gt;
  &lt;com.google.android.material.button.<strong class="bold">MaterialButton</strong>
    android:id="<strong class="bold">@+id/button</strong>"
    …
    android:text="@string/view_activity"
    …
    app:layout_constraintTop_toBottomOf="@id/textView" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<p>This <code>ConstraintLayout</code> has two children, a <code>MaterialTextView</code> and a <code>MaterialButton</code>. A button click invokes the lambda expression passed to <code>ViewIntegrationDemo()</code>. The text fields receive the current slider value. This is done in the <code>update</code> block. The following code belongs below <code>// Here Views will be updated</code> inside <code>ViewIntegrationDemo()</code>:</p>
			<pre>textView.text = sliderValueState.value.toString()
button.setOnClickListener {
    onClick()
}</pre>
			<p>You may be wondering where <code>textView</code> and <code>button</code> are defined, and why they can be accessed <a id="_idIndexMarker334"/>immediately. The <code>update</code> block <a id="_idIndexMarker335"/>is invoked right after the layout is inflated. It is an extension function of the type whose instance is returned by <code>inflate</code>—in my example, <code>CustomBinding</code>. Because the <code>custom.xml</code> are <code>button</code> and <code>textView</code>, there are corresponding variables in <code>CustomBinding</code>.</p>
			<p>The <code>update</code> block <a id="_idIndexMarker337"/>is also invoked <a id="_idIndexMarker338"/>when a value being used by it (<code>sliderValueState.value</code>) changes. In the next section, we look at when and where such changes are triggered.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor154"/>Sharing data between Views and composable functions</h1>
			<p>State is app data that may change over time. Recomposition occurs when state being used by a <a id="_idIndexMarker339"/>composable changes. To achieve something similar in the traditional View world, we need to store data in a way that changes to it can be observed. There are many implementations of the <em class="italic">Observable</em> pattern. The Android Architecture Components (and subsequent Jetpack versions) include <code>LiveData</code> and <code>MutableLiveData</code>. Both are frequently used inside ViewModels to store state outside activities. </p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor155"/>Revisiting ViewModels</h2>
			<p>I introduced you <a id="_idIndexMarker340"/>to ViewModels in the <em class="italic">Surviving configuration changes</em> section of <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>, and the <em class="italic">Persisting and retrieving state</em> section of <a href="B17505_07_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Tips, Tricks, and Best Practices</em>. Before we look at how to use ViewModels to synchronize data between Views and composable functions, let's briefly recap on key techniques, as follows:</p>
			<ul>
				<li>To create or get an instance of a ViewModel, use the top-level <code>viewModels()</code> function, which belongs to the <code>androidx.activity</code> package.</li>
				<li>To observe <code>LiveData</code> instances as compose state, invoke the <code>observeAsState()</code> extension function on a ViewModel property inside a composable function. </li>
				<li>To observe <code>LiveData</code> instances outside of composable functions, invoke <code>observe()</code>. This function belongs to <code>androidx.lifecycle.LiveData</code>.</li>
				<li>To change a ViewModel property, invoke the corresponding setter.<p class="callout-heading">Important Note</p><p class="callout">Please make sure to add implementation dependencies of <code>androidx.compose.runtime:runtime-livedata</code>, <code>androidx.lifecycle:lifecycle-runtime-ktx</code>, and <code>androidx.lifecycle:lifecycle-viewmodel-compose</code> in the module-level <code>build.gradle</code> file as needed.</p></li>
			</ul>
			<p>Now that we have refamiliarized ourselves with key techniques related to ViewModels, let's look at how <a id="_idIndexMarker341"/>the synchronization between Views and composable functions works. <em class="italic">Synchronization</em> means that a composable function and code related to a View observe the same ViewModel property and may trigger changes on that property. Triggering changes is usually done by invoking a setter. For a <code>Slider()</code> composable, it may look like this:</p>
			<pre>Slider(
  modifier = Modifier.fillMaxWidth(),
  onValueChange = {
    viewModel.setSliderValue(it)
  },
  value = sliderValueState.value ?: 0F
)</pre>
			<p>This example also shows the readout inside a composable (<code>sliderValueState.value</code>). Here is how <code>sliderValueState</code> has been defined:</p>
			<pre>val sliderValueState = viewModel.sliderValue.observeAsState()</pre>
			<p>Next, let's look at traditional (non-Compose) code using View Binding. The following examples are part of <code>ViewActivity</code>, which also belongs to the <code>InteropDemo</code> sample. </p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor156"/>Combining View Binding and ViewModels</h2>
			<p>Activities taking <a id="_idIndexMarker342"/>advantage of View Binding usually have a <code>lateinit</code> property named <code>binding</code>, as illustrated in the following code snippet:</p>
			<pre>binding = LayoutBinding.inflate(layoutInflater)</pre>
			<p><code>LayoutBinding.inflate()</code> returns an instance of <code>LayoutBinding</code>. <code>Binding.root</code> represents the root of the component tree. It is passed to <code>setContentView()</code>. Here is an abridged version of the corresponding layout file (<code>layout.xml</code>):</p>
			<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
  
  …
  android:layout_width="match_parent"
  android:layout_height="match_parent"&gt;
  &lt;com.google.android.material.slider.Slider
    android:id="@+id/slider"
    ... /&gt;
  &lt;androidx.compose.ui.platform.ComposeView
    android:id="@+id/compose_view"
    ...
    app:layout_constraintTop_toBottomOf="@id/slider" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<p><code>ConstraintLayout</code> contains a <code>com.google.android.material.slider.Slider</code> and a <code>ComposeView</code> (which is discussed in detail in the following section). The ID of the slider is <code>slider</code>, so <code>LayoutBinding</code> contains <a id="_idIndexMarker343"/>an equally named variable. We can therefore link the slider to the ViewModel, like this:</p>
			<pre>viewModel.sliderValue.observe(this) {
  binding.slider.value = it
}</pre>
			<p>The block passed to <code>observe()</code> is invoked when the value stored in <code>sliderValue</code> changes. By updating <code>binding.slider.value</code>, we change the position of the slider handle, which means we update the slider. The code is illustrated here:</p>
			<pre>binding.slider.addOnChangeListener { _, value, _ -&gt;
  viewModel.setSliderValue(value) }</pre>
			<p>The block passed to <code>addOnChangeListener()</code> is invoked when the user drags the slider handle. By invoking <code>setSliderValue()</code> we update the ViewModel, which in turn triggers updates on observers—for example, our composable functions.</p>
			<p>In this section, I familiarized you with the steps needed to tie composable functions and traditional Views to a ViewModel property. When the property is changed, all observers are called, which leads to the update of both the composable and View. In the following section, we continue our look at the <code>InteropDemo</code> sample. This time, I will show you how to embed composables in a View hierarchy. This is important if an existing app is to be migrated to Jetpack Compose step by step.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor157"/>Embedding composables in View hierarchies</h1>
			<p>As you have seen, integrating Views in composable functions is simple and straightforward using <code>AndroidView()</code> and <code>AndroidViewBinding()</code>. But what about the <a id="_idIndexMarker344"/>other way round? Often, you may not <a id="_idIndexMarker345"/>want to rewrite an existing (View-based) app from scratch but migrate it to Jetpack Compose gradually, replacing View hierarchies with composable functions step by step. Depending on the complexity of the activity, it may make sense to start with small composables that reflect portions of the UI and incorporate them into the remaining layout.</p>
			<p><code>Androidx.compose.ui.platform.ComposeView</code> makes composables available inside <a id="_idIndexMarker346"/>classic layouts. The class <a id="_idIndexMarker347"/>extends <code>AbstractComposeView</code>, which has <code>ViewGroup</code> as its parent. Once the layout that includes the ComposeView has been inflated, here is how you configure it:</p>
			<pre>binding.composeView.run {
  setViewCompositionStrategy(
      ViewCompositionStrategy.DisposeOnDetachedFromWindow)
  setContent {
    val sliderValue =
            viewModel.sliderValue.observeAsState()
    sliderValue.value?.let {
      ComposeDemo(it) {
        val I = Intent(
          context,
          ComposeActivity::class.java
        )
        i.putExtra(KEY, it)
        startActivity(i)
      }
    }
  }
}</pre>
			<p><code>setContent()</code> sets the content for this view. An initial composition will occur when the view is attached to a window, or when <code>createComposition()</code> is called. While <code>setContent()</code> is defined in <code>ComposeView</code>, <code>createComposition()</code> belongs to <code>AbstractComposeView</code>. It performs the initial composition for this view. Typically, you do not need to invoke this function directly.</p>
			<p><code>setViewCompositionStrategy()</code> configures how to manage the disposal of the View's internal composition. <code>ViewCompositionStrategy.</code><code>DisposeOnDetached FromWindow</code> (the default) means that the <a id="_idIndexMarker348"/>composition is disposed whenever <a id="_idIndexMarker349"/>the view becomes detached from a window. This is preferred for simple scenarios, as in my example. If your view is shown inside a fragment or a component with a known <code>LifecycleOwner</code>, you should use <code>DisposeOnViewTreeLifecycleDestroyed</code> or <code>DisposeOnLifecycleDestroyed</code> instead. These, however, are topics beyond the scope of this book. The following line creates state based on the <code>sliderValue</code> property of the ViewModel and passes the value to <code>ComposeDemo()</code>:</p>
			<pre>val sliderValue = viewModel.sliderValue.observeAsState()</pre>
			<p>This composable also receives a block that launches <code>ComposeActivity</code> and passes the current slider value to it, as illustrated in the following code snippet:</p>
			<pre>@Composable
fun ComposeDemo(value: Float, onClick: () -&gt; Unit) {
  Column(
    modifier = Modifier
      .fillMaxSize(),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Box(
      modifier = Modifier
        .fillMaxWidth()
        .background(MaterialTheme.colors.secondary)
        .height(64.dp),
      contentAlignment = Alignment.Center
    ) {
      Text(
        text = value.toString()
      )
    }
    Button(
      onClick = onClick,
      modifier = Modifier.padding(top = 16.dp)
    ) {
      Text(text = stringResource(id =
            R.string.compose_activity))
    }
  }
}</pre>
			<p><code>ComposeDemo()</code>, as <a id="_idIndexMarker350"/>illustrated in the following <a id="_idIndexMarker351"/>screenshot, puts a <code>Box()</code> (which contains a <code>Text()</code>) and a <code>Button()</code>inside a <code>Column()</code>, in order to resemble <code>ViewActivity</code>. Wrapping <code>Text()</code> inside the <code>Box()</code>is necessary to vertically center the text inside an area with a particular height. A click on the button invokes the <code>onClick</code> lambda expression. <code>Text()</code> just shows the <code>value</code> parameter: </p>
			<div><div><img src="img/B17505_09_3.jpg" alt="Figure 9.3 – The InteropDemo sample showing ViewActivity&#13;&#10;" width="1380" height="517"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The InteropDemo sample showing ViewActivity</p>
			<p>Before closing <a id="_idIndexMarker352"/>out this chapter, let me recap <a id="_idIndexMarker353"/>on important steps you need to take to include a Compose hierarchy in a layout, as follows:</p>
			<ul>
				<li>Add <code>androidx.compose.ui.platform.ComposeView</code> to the layout.</li>
				<li>Decide on a <code>ViewCompositionStrategy</code>, depending on where the layout is shown (activity, fragment, …).</li>
				<li>Set the content using <code>setContent {}</code>.</li>
				<li>Obtain a reference to the <code>ViewModel</code> by invoking <code>viewModels()</code>.</li>
				<li>Register listeners to relevant Views and update the <code>ViewModel</code> upon changes.</li>
				<li>Inside composable functions, create state by invoking <code>observeAsState()</code> on ViewModel properties as needed.</li>
				<li>Inside composables, update the ViewModel by invoking corresponding setters.</li>
			</ul>
			<p>Jetpack Compose interoperability APIs allow for seamless two-way integration of composable functions and <code>View</code> hierarchies. They help you use libraries that rely on Views and <a id="_idIndexMarker354"/>ease the transition to Compose by <a id="_idIndexMarker355"/>making a gradual, fine-grained migration possible.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor158"/>Summary</h1>
			<p>In this chapter, we looked at the interoperability APIs of Jetpack Compose, which allow you to mix composable functions and traditional Views. We started by incorporating a traditional View hierarchy from a third-party library in a Compose app, using <code>AndroidView()</code>. As recent apps favor View Binding over the direct use of <code>findViewById()</code>, I also showed you how to embed layouts in a composable with View Binding and <code>AndroidViewBinding()</code>. Once you have embedded a <code>View</code> in a Compose UI, you need to share data between the two worlds. The <em class="italic">Sharing data between Views and composable functions</em> section explained how to achieve this with ViewModels. The final main section, <em class="italic">Embedding composables in View hierarchies</em>, discussed how to include a Compose UI in existing apps using <code>ComposeView</code>.</p>
			<p><a href="B17505_10_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 10</em></a>, <em class="italic">Testing and Debugging Compose Apps</em><em class="italic">,</em> focuses on testing your Compose apps. You will learn how to use <code>ComposeTestRule</code> and <code>AndroidComposeTestRule</code>. Also, I will introduce you to the <em class="italic">semantics tree</em>.</p>
		</div>
	</div></body></html>