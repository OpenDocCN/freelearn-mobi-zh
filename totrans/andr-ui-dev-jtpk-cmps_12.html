<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer055">
			<h1 id="_idParaDest-118"><a id="_idTextAnchor148"/>Chapter 9: Exploring Interoperability APIs</h1>
			<p>The aim of this book is to show you how to develop beautiful, fast, and maintainable Jetpack Compose apps. The previous chapters helped you get familiar with core techniques and principles, as well as important interfaces, classes, packages, and—of course—composable functions. The remaining chapters cover topics beyond a successful adoption of Android's new declarative user interface toolkit.</p>
			<p>In this chapter, we are going to look at <strong class="source-inline">AndroidView()</strong>, <strong class="source-inline">AndroidViewBinding()</strong>, and <strong class="source-inline">ComposeView</strong> as the interoperability <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) of Jetpack Compose. The main sections are listed here:</p>
			<ul>
				<li>Showing Views in a Compose app</li>
				<li>Sharing data between Views and composable functions</li>
				<li>Embedding composables in View hierarchies</li>
			</ul>
			<p>We start by looking at how to show a traditional View hierarchy in a Compose app. Imagine you have written a custom component (which under the hood consists of several UI elements), such as an image picker, a color chooser, or a camera preview. Instead of rewriting your component with Jetpack Compose, you can save your investment by simply reusing it. A lot of third-party libraries are still written in Views, so I will show you how to use them in Compose apps.</p>
			<p>Once you have embedded a View in a Compose app, you need to share data between the View and your composable functions. The <em class="italic">Sharing data between Views and composable functions</em> section explains how to do this with ViewModels.</p>
			<p>Often, you may not want to rewrite an app from scratch but migrate it to Jetpack Compose gradually, replacing View hierarchies with composable functions step by step. The final main section, <em class="italic">Embedding composables in View hierarchies</em>, discusses how to include a Compose hierarchy in existing View-based apps.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor149"/>Technical requirements</h1>
			<p>This chapter is based on the <strong class="source-inline">ZxingDemo</strong> and <strong class="source-inline">InteropDemo</strong> samples. Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em><em class="italic">,</em> for information about how to install and set up Android Studio, and how to get the repository accompanying this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_09">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_09</a>.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor150"/>Showing Views in a Compose app</h1>
			<p>Imagine you have <a id="_idIndexMarker317"/>written a View-based custom <a id="_idIndexMarker318"/>component for one of your previous apps—for example, an image picker, a color chooser, or a camera preview—or you would like to include <a id="_idIndexMarker319"/>a third-party library such as <em class="italic">Zebra Crossing</em> (<em class="italic">ZXing</em>) to scan <strong class="bold">Quick Response</strong> (<strong class="bold">QR</strong>) codes and barcodes. To incorporate them into a Compose app, you need to add the View (or the root of a View hierarchy) to your composable functions.</p>
			<p>Let's see how this works.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor151"/>Adding custom components to a Compose app</h2>
			<p>The <strong class="source-inline">ZxingDemo</strong> sample, shown in the following screenshot, uses the <em class="italic">ZXing Android Embedded</em> barcode <a id="_idIndexMarker320"/>scanner library for Android, which is based on the ZXing decoder. It is released under the terms of the Apache License 2.0 and is hosted on GitHub (<a href="https://github.com/journeyapps/zxing-android-embedded">https://github.com/journeyapps/zxing-android-embedded</a>):</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="Images/B17505_09_1.jpg" alt="Figure 9.1 – The ZxingDemo sample&#13;&#10;" width="730" height="973"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The ZxingDemo sample</p>
			<p>My example continuously scans for barcodes and QR codes. The decorated barcode view is <a id="_idIndexMarker321"/>provided by the library. If the scanner engine provides a result, the corresponding text is shown as an overlay using <strong class="source-inline">Text()</strong>. To use <em class="italic">ZXing Android Embedded</em>, you need to add an implementation dependency to your module-level <strong class="source-inline">build.gradle</strong> file, as follows:</p>
			<p class="source-code">implementation 'com.journeyapps:zxing-android-embedded:4.3.0'</p>
			<p>The scanner accesses the camera and (optionally) the device vibrator. The app must request at least <strong class="source-inline">android.permission.WAKE_LOCK</strong> and <strong class="source-inline">android.permission.CAMERA</strong> permissions in the manifest, and the <strong class="source-inline">android.permission.CAMERA</strong> permission during runtime. My implementation is based on <strong class="source-inline">ActivityResultContracts.RequestPermission</strong>, which replaces the traditional approach overriding <strong class="source-inline">onRequestPermissionsResult()</strong>. Also, depending on the lifecycle of the activity, the scanner must be paused and resumed. For the sake of simplicity, I use a <strong class="source-inline">lateinit</strong> variable named <strong class="source-inline">barcodeView</strong> and invoke <strong class="source-inline">barcodeView.pause()</strong> and <strong class="source-inline">barcodeView.resume()</strong> when needed. Please refer to the source code of the project for details. Next, I will show you how to initialize the scanner library. This involves inflating a layout file (named <strong class="source-inline">layout.xml</strong>), as follows:</p>
			<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p>
			<p class="source-code">&lt;com.journeyapps.barcodescanner.DecoratedBarcodeView</p>
			<p class="source-code">  </p>
			<p class="source-code">  android:id="@+id/barcode_scanner"</p>
			<p class="source-code">  android:layout_width="match_parent"</p>
			<p class="source-code">  android:layout_height="match_parent"</p>
			<p class="source-code">  android:layout_alignParentTop="true" /&gt;</p>
			<p>The layout consists of only one element, <strong class="source-inline">DecoratedBarcodeView</strong>. It is configured to fill all available space. The following code snippet is part of <strong class="source-inline">onCreate()</strong>. Please remember that <strong class="source-inline">barcodeView</strong> is accessed in some lifecycle functions such as <strong class="source-inline">onPause()</strong>, and therefore is a <strong class="source-inline">lateinit</strong> property:</p>
			<p class="source-code">val root = layoutInflater.inflate(R.layout.layout, null)</p>
			<p class="source-code">barcodeView = root.findViewById(R.id.barcode_scanner)</p>
			<p class="source-code">val formats = listOf(BarcodeFormat.QR_CODE,</p>
			<p class="source-code">    BarcodeFormat.CODE_39)</p>
			<p class="source-code">barcodeView.barcodeView.decoderFactory =</p>
			<p class="source-code">    DefaultDecoderFactory(formats)</p>
			<p class="source-code">barcodeView.initializeFromIntent(intent)</p>
			<p class="source-code">val callback = object : BarcodeCallback {</p>
			<p class="source-code">  override fun barcodeResult(result: BarcodeResult) {</p>
			<p class="source-code">    if (result.text == null || result.text == text.value) {</p>
			<p class="source-code">      return</p>
			<p class="source-code">    }</p>
			<p class="source-code">    text.value = result.text</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">barcodeView.decodeContinuous(callback)</p>
			<p>First, <strong class="source-inline">layout.xml</strong> is inflated and assigned to <strong class="source-inline">root</strong>. Then, <strong class="source-inline">barcodeView</strong> is initialized (<strong class="source-inline">initializeFromIntent()</strong>) and configured (by setting a decoder factory). Finally, the <a id="_idIndexMarker322"/>continuous scanning process is started using <strong class="source-inline">decodeContinuous()</strong>. The <strong class="source-inline">callback</strong> lambda expression is invoked every time a new scan result is available. The <strong class="source-inline">text</strong> variable is defined like this:</p>
			<p class="source-code">private val text = MutableLiveData("")</p>
			<p>I am using <strong class="source-inline">MutableLiveData</strong>, because it can easily be observed as state. Before I show you how to access it inside a composable function, let's briefly recap, as follows:</p>
			<ul>
				<li>We have set up and activated the scanner library. </li>
				<li>When it detects a barcode or a QR code, it updates the value of a <strong class="source-inline">MutableLiveData</strong> instance. </li>
				<li>We defined and initialized two <strong class="source-inline">View</strong> instances—<strong class="source-inline">root</strong> and <strong class="source-inline">barcodeView</strong>.</li>
			</ul>
			<p>Next, I show you how to access the state obtained from the ViewModel inside a composable, as follows:</p>
			<p class="source-code">setContent {</p>
			<p class="source-code">  val state = text.observeAsState()</p>
			<p class="source-code">  state.value?.let {</p>
			<p class="source-code">    ZxingDemo(root, it)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The value <a id="_idIndexMarker323"/>of the state and <strong class="source-inline">root</strong> are passed to the <strong class="source-inline">ZxingDemo()</strong> composable. We display <strong class="source-inline">value</strong> using <strong class="source-inline">Text()</strong>. The <strong class="source-inline">root</strong> parameter is used to include the View hierarchy in the Compose UI. The code is illustrated in the following snippet:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ZxingDemo(root: View, value: String) {</p>
			<p class="source-code">  Box(</p>
			<p class="source-code">    modifier = Modifier.fillMaxSize(),</p>
			<p class="source-code">    contentAlignment = Alignment.TopCenter</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    AndroidView(modifier = Modifier.fillMaxSize(),</p>
			<p class="source-code">      factory = {</p>
			<p class="source-code">        root</p>
			<p class="source-code">      })</p>
			<p class="source-code">    if (value.isNotBlank()) {</p>
			<p class="source-code">      Text(</p>
			<p class="source-code">        modifier = Modifier.padding(16.dp),</p>
			<p class="source-code">        text = value,</p>
			<p class="source-code">        color = Color.White,</p>
			<p class="source-code">        style = MaterialTheme.typography.h4</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The UI consists of a <strong class="source-inline">Box()</strong> composable with two children, <strong class="source-inline">AndroidView()</strong> and <strong class="source-inline">Text()</strong>. <strong class="source-inline">AndroidView()</strong> receives a <strong class="source-inline">factory</strong> block, which just returns <strong class="source-inline">root</strong> (the View hierarchy containing the scanner viewfinder). The <strong class="source-inline">Text()</strong> composable shows the last scan result.</p>
			<p>The <strong class="source-inline">factory</strong> block is called exactly once, to obtain the View to be composed. It will always be invoked on the UI thread, so you can set View properties as needed. In my example, this is <a id="_idIndexMarker324"/>not needed, as all initialization has already been done in <strong class="source-inline">onCreate()</strong>. Configuring the barcode scanner should not be done in a composable, because preparing the camera and preview is potentially time-consuming. Also, parts of the component tree are accessed on the activity level, therefore references to children (<strong class="source-inline">barcodeView</strong>) are needed anyway.</p>
			<p>In this section, I have shown you how to include a View hierarchy in your Compose app using <strong class="source-inline">AndroidView()</strong>. This composable function is one of the important pieces of the Jetpack Compose interoperability APIs. We used <strong class="source-inline">layoutInflater.inflate()</strong> to inflate the component tree and <strong class="source-inline">findViewById()</strong> to access one of its children. Modern View-based apps try to avoid <strong class="source-inline">findViewById()</strong> and use <em class="italic">View Binding</em> instead. In the next section, you will learn how to combine View Binding and composable functions.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor152"/>Inflating View hierarchies with AndroidViewBinding()</h2>
			<p>Traditionally, activities held references to Views in <strong class="source-inline">lateinit</strong> properties, if the corresponding <a id="_idIndexMarker325"/>components <a id="_idIndexMarker326"/>needed to be modified in different functions. The <em class="italic">Inflating layout files</em> section of <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, discussed some of the issues with this approach and introduced View Binding as a solution. It was adopted by many apps. Therefore, if you want to migrate an existing app to Jetpack Compose, you likely need to combine View Binding and composable functions. This section explains how to achieve that.</p>
			<p>The following screenshot shows the <strong class="source-inline">InteropDemo</strong> sample:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="Images/B17505_09_2.jpg" alt="Figure 9.2 – The InteropDemo sample&#13;&#10;" width="1376" height="461"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – The InteropDemo sample</p>
			<p>The <strong class="source-inline">InteropDemo</strong> sample consists of two activities. One (<strong class="source-inline">ViewActivity</strong>) integrates a composable <a id="_idIndexMarker327"/>function in a <strong class="source-inline">View</strong> hierarchy. We will turn to <a id="_idIndexMarker328"/>this in the <em class="italic">Embedding composables in View hierarchies</em> section. The second one, <strong class="source-inline">ComposeActivity</strong>, does <a id="_idIndexMarker329"/>the opposite: it inflates a <strong class="source-inline">View</strong> hierarchy using View Binding and shows the component tree inside a <strong class="source-inline">Column()</strong> composable. Let's take a look here:</p>
			<p class="source-code">class ComposeActivity : ComponentActivity() {</p>
			<p class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">    super.onCreate(savedInstanceState)</p>
			<p class="source-code">    val viewModel: MyViewModel by viewModels()</p>
			<p class="source-code">    …</p>
			<p class="source-code">    se<a id="_idTextAnchor153"/>tContent {</p>
			<p class="source-code">      ViewIntegrationDemo(viewModel) {</p>
			<p class="source-code">        val i = Intent(</p>
			<p class="source-code">          this,</p>
			<p class="source-code">          ViewActivity::class.java</p>
			<p class="source-code">        )</p>
			<p class="source-code">        i.putExtra(KEY, viewModel.sliderValue.value)</p>
			<p class="source-code">        startActivity(i)</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The root <a id="_idIndexMarker330"/>composable is called <strong class="source-inline">ViewIntegrationDemo()</strong>. It receives a ViewModel and a lambda expression. The <a id="_idIndexMarker331"/>ViewModel is used to share data between the Compose and the <strong class="source-inline">View</strong> hierarchies, which I will discuss in the <em class="italic">Sharing data between Views and composable functions</em> section. The lambda expression starts <strong class="source-inline">ViewActivity</strong> and passes a value from the ViewModel (<strong class="source-inline">sliderValue</strong>). The code is illustrated in the following snippet:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ViewIntegrationDemo(viewModel: MyViewModel,</p>
			<p class="source-code">                        onClick: () -&gt; Unit) {</p>
			<p class="source-code">  val sliderValueState =</p>
			<p class="source-code">    viewModel.sliderValue.observeAsState()</p>
			<p class="source-code">  Scaffold( ... ) {</p>
			<p class="source-code">    Column( ... ) {</p>
			<p class="source-code">      Slider( … )</p>
			<p class="source-code">      AndroidViewBinding(</p>
			<p class="source-code">        modifier = Modifier.fillMaxWidth(),</p>
			<p class="source-code">        factory = CustomBinding::inflate</p>
			<p class="source-code">      ) {</p>
			<p class="source-code">        // Here Views will be updated</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Scaffold()</strong> is an important integrational composable function. It structures a Compose screen. Besides <a id="_idIndexMarker332"/>top and <a id="_idIndexMarker333"/>bottom bars, it contains some content—in this case, a <strong class="source-inline">Column()</strong> composable with two children, <strong class="source-inline">Slider()</strong> and <strong class="source-inline">AndroidViewBinding()</strong>. The slider gets its current value from a ViewModel and propagates changes back to it. You will learn more about that in the <em class="italic">Revisiting ViewModels</em> section.</p>
			<p><strong class="source-inline">AndroidViewBinding()</strong> is similar to <strong class="source-inline">AndroidView()</strong>. A <strong class="source-inline">factory</strong> block creates a View hierarchy to be composed. <strong class="source-inline">CustomBinding::inflate</strong> inflates the layout from the <strong class="source-inline">custom.xml</strong> file represented by <strong class="source-inline">CustomBinding</strong> and returns an instance of this type. The class is created and updated during builds. It provides constants that reflect the contents of a layout file named <strong class="source-inline">custom.xml</strong>. Here is an abridged version:</p>
			<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p>
			<p class="source-code">&lt;androidx.constraintlayout.widget.<strong class="bold">ConstraintLayout</strong></p>
			<p class="source-code">  </p>
			<p class="source-code">  </p>
			<p class="source-code">  android:layout_width="match_parent"</p>
			<p class="source-code">  android:layout_height="match_parent"&gt;</p>
			<p class="source-code">  &lt;com.google.android.material.textview.<strong class="bold">MaterialTextView</strong></p>
			<p class="source-code">    android:id="<strong class="bold">@+id/textView</strong>"</p>
			<p class="source-code">    ... /&gt;</p>
			<p class="source-code">  &lt;com.google.android.material.button.<strong class="bold">MaterialButton</strong></p>
			<p class="source-code">    android:id="<strong class="bold">@+id/button</strong>"</p>
			<p class="source-code">    …</p>
			<p class="source-code">    android:text="@string/view_activity"</p>
			<p class="source-code">    …</p>
			<p class="source-code">    app:layout_constraintTop_toBottomOf="@id/textView" /&gt;</p>
			<p class="source-code">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</p>
			<p>This <strong class="source-inline">ConstraintLayout</strong> has two children, a <strong class="source-inline">MaterialTextView</strong> and a <strong class="source-inline">MaterialButton</strong>. A button click invokes the lambda expression passed to <strong class="source-inline">ViewIntegrationDemo()</strong>. The text fields receive the current slider value. This is done in the <strong class="source-inline">update</strong> block. The following code belongs below <strong class="source-inline">// Here Views will be updated</strong> inside <strong class="source-inline">ViewIntegrationDemo()</strong>:</p>
			<p class="source-code">textView.text = sliderValueState.value.toString()</p>
			<p class="source-code">button.setOnClickListener {</p>
			<p class="source-code">    onClick()</p>
			<p class="source-code">}</p>
			<p>You may be wondering where <strong class="source-inline">textView</strong> and <strong class="source-inline">button</strong> are defined, and why they can be accessed <a id="_idIndexMarker334"/>immediately. The <strong class="source-inline">update</strong> block <a id="_idIndexMarker335"/>is invoked right after the layout is inflated. It is an extension function of the type whose instance is returned by <strong class="source-inline">inflate</strong>—in my example, <strong class="source-inline">CustomBinding</strong>. Because the <strong class="bold">identifiers</strong> (<strong class="bold">IDs</strong>) of the button and the <a id="_idIndexMarker336"/>text field in <strong class="source-inline">custom.xml</strong> are <strong class="source-inline">button</strong> and <strong class="source-inline">textView</strong>, there are corresponding variables in <strong class="source-inline">CustomBinding</strong>.</p>
			<p>The <strong class="source-inline">update</strong> block <a id="_idIndexMarker337"/>is also invoked <a id="_idIndexMarker338"/>when a value being used by it (<strong class="source-inline">sliderValueState.value</strong>) changes. In the next section, we look at when and where such changes are triggered.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor154"/>Sharing data between Views and composable functions</h1>
			<p>State is app data that may change over time. Recomposition occurs when state being used by a <a id="_idIndexMarker339"/>composable changes. To achieve something similar in the traditional View world, we need to store data in a way that changes to it can be observed. There are many implementations of the <em class="italic">Observable</em> pattern. The Android Architecture Components (and subsequent Jetpack versions) include <strong class="source-inline">LiveData</strong> and <strong class="source-inline">MutableLiveData</strong>. Both are frequently used inside ViewModels to store state outside activities. </p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor155"/>Revisiting ViewModels</h2>
			<p>I introduced you <a id="_idIndexMarker340"/>to ViewModels in the <em class="italic">Surviving configuration changes</em> section of <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>, and the <em class="italic">Persisting and retrieving state</em> section of <a href="B17505_07_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Tips, Tricks, and Best Practices</em>. Before we look at how to use ViewModels to synchronize data between Views and composable functions, let's briefly recap on key techniques, as follows:</p>
			<ul>
				<li>To create or get an instance of a ViewModel, use the top-level <strong class="source-inline">viewModels()</strong> function, which belongs to the <strong class="source-inline">androidx.activity</strong> package.</li>
				<li>To observe <strong class="source-inline">LiveData</strong> instances as compose state, invoke the <strong class="source-inline">observeAsState()</strong> extension function on a ViewModel property inside a composable function. </li>
				<li>To observe <strong class="source-inline">LiveData</strong> instances outside of composable functions, invoke <strong class="source-inline">observe()</strong>. This function belongs to <strong class="source-inline">androidx.lifecycle.LiveData</strong>.</li>
				<li>To change a ViewModel property, invoke the corresponding setter.<p class="callout-heading">Important Note</p><p class="callout">Please make sure to add implementation dependencies of <strong class="source-inline">androidx.compose.runtime:runtime-livedata</strong>, <strong class="source-inline">androidx.lifecycle:lifecycle-runtime-ktx</strong>, and <strong class="source-inline">androidx.lifecycle:lifecycle-viewmodel-compose</strong> in the module-level <strong class="source-inline">build.gradle</strong> file as needed.</p></li>
			</ul>
			<p>Now that we have refamiliarized ourselves with key techniques related to ViewModels, let's look at how <a id="_idIndexMarker341"/>the synchronization between Views and composable functions works. <em class="italic">Synchronization</em> means that a composable function and code related to a View observe the same ViewModel property and may trigger changes on that property. Triggering changes is usually done by invoking a setter. For a <strong class="source-inline">Slider()</strong> composable, it may look like this:</p>
			<p class="source-code">Slider(</p>
			<p class="source-code">  modifier = Modifier.fillMaxWidth(),</p>
			<p class="source-code">  onValueChange = {</p>
			<p class="source-code">    viewModel.setSliderValue(it)</p>
			<p class="source-code">  },</p>
			<p class="source-code">  value = sliderValueState.value ?: 0F</p>
			<p class="source-code">)</p>
			<p>This example also shows the readout inside a composable (<strong class="source-inline">sliderValueState.value</strong>). Here is how <strong class="source-inline">sliderValueState</strong> has been defined:</p>
			<p class="source-code">val sliderValueState = viewModel.sliderValue.observeAsState()</p>
			<p>Next, let's look at traditional (non-Compose) code using View Binding. The following examples are part of <strong class="source-inline">ViewActivity</strong>, which also belongs to the <strong class="source-inline">InteropDemo</strong> sample. </p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor156"/>Combining View Binding and ViewModels</h2>
			<p>Activities taking <a id="_idIndexMarker342"/>advantage of View Binding usually have a <strong class="source-inline">lateinit</strong> property named <strong class="source-inline">binding</strong>, as illustrated in the following code snippet:</p>
			<p class="source-code">binding = LayoutBinding.inflate(layoutInflater)</p>
			<p><strong class="source-inline">LayoutBinding.inflate()</strong> returns an instance of <strong class="source-inline">LayoutBinding</strong>. <strong class="source-inline">Binding.root</strong> represents the root of the component tree. It is passed to <strong class="source-inline">setContentView()</strong>. Here is an abridged version of the corresponding layout file (<strong class="source-inline">layout.xml</strong>):</p>
			<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p>
			<p class="source-code">&lt;androidx.constraintlayout.widget.ConstraintLayout</p>
			<p class="source-code">  </p>
			<p class="source-code">  …</p>
			<p class="source-code">  android:layout_width="match_parent"</p>
			<p class="source-code">  android:layout_height="match_parent"&gt;</p>
			<p class="source-code">  &lt;com.google.android.material.slider.Slider</p>
			<p class="source-code">    android:id="@+id/slider"</p>
			<p class="source-code">    ... /&gt;</p>
			<p class="source-code">  &lt;androidx.compose.ui.platform.ComposeView</p>
			<p class="source-code">    android:id="@+id/compose_view"</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    app:layout_constraintTop_toBottomOf="@id/slider" /&gt;</p>
			<p class="source-code">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</p>
			<p><strong class="source-inline">ConstraintLayout</strong> contains a <strong class="source-inline">com.google.android.material.slider.Slider</strong> and a <strong class="source-inline">ComposeView</strong> (which is discussed in detail in the following section). The ID of the slider is <strong class="source-inline">slider</strong>, so <strong class="source-inline">LayoutBinding</strong> contains <a id="_idIndexMarker343"/>an equally named variable. We can therefore link the slider to the ViewModel, like this:</p>
			<p class="source-code">viewModel.sliderValue.observe(this) {</p>
			<p class="source-code">  binding.slider.value = it</p>
			<p class="source-code">}</p>
			<p>The block passed to <strong class="source-inline">observe()</strong> is invoked when the value stored in <strong class="source-inline">sliderValue</strong> changes. By updating <strong class="source-inline">binding.slider.value</strong>, we change the position of the slider handle, which means we update the slider. The code is illustrated here:</p>
			<p class="source-code">binding.slider.addOnChangeListener { _, value, _ -&gt;</p>
			<p class="source-code">  viewModel.setSliderValue(value) }</p>
			<p>The block passed to <strong class="source-inline">addOnChangeListener()</strong> is invoked when the user drags the slider handle. By invoking <strong class="source-inline">setSliderValue()</strong> we update the ViewModel, which in turn triggers updates on observers—for example, our composable functions.</p>
			<p>In this section, I familiarized you with the steps needed to tie composable functions and traditional Views to a ViewModel property. When the property is changed, all observers are called, which leads to the update of both the composable and View. In the following section, we continue our look at the <strong class="source-inline">InteropDemo</strong> sample. This time, I will show you how to embed composables in a View hierarchy. This is important if an existing app is to be migrated to Jetpack Compose step by step.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor157"/>Embedding composables in View hierarchies</h1>
			<p>As you have seen, integrating Views in composable functions is simple and straightforward using <strong class="source-inline">AndroidView()</strong> and <strong class="source-inline">AndroidViewBinding()</strong>. But what about the <a id="_idIndexMarker344"/>other way round? Often, you may not <a id="_idIndexMarker345"/>want to rewrite an existing (View-based) app from scratch but migrate it to Jetpack Compose gradually, replacing View hierarchies with composable functions step by step. Depending on the complexity of the activity, it may make sense to start with small composables that reflect portions of the UI and incorporate them into the remaining layout.</p>
			<p><strong class="source-inline">Androidx.compose.ui.platform.ComposeView</strong> makes composables available inside <a id="_idIndexMarker346"/>classic layouts. The class <a id="_idIndexMarker347"/>extends <strong class="source-inline">AbstractComposeView</strong>, which has <strong class="source-inline">ViewGroup</strong> as its parent. Once the layout that includes the ComposeView has been inflated, here is how you configure it:</p>
			<p class="source-code">binding.composeView.run {</p>
			<p class="source-code">  setViewCompositionStrategy(</p>
			<p class="source-code">      ViewCompositionStrategy.DisposeOnDetachedFromWindow)</p>
			<p class="source-code">  setContent {</p>
			<p class="source-code">    val sliderValue =</p>
			<p class="source-code">            viewModel.sliderValue.observeAsState()</p>
			<p class="source-code">    sliderValue.value?.let {</p>
			<p class="source-code">      ComposeDemo(it) {</p>
			<p class="source-code">        val I = Intent(</p>
			<p class="source-code">          context,</p>
			<p class="source-code">          ComposeActivity::class.java</p>
			<p class="source-code">        )</p>
			<p class="source-code">        i.putExtra(KEY, it)</p>
			<p class="source-code">        startActivity(i)</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">setContent()</strong> sets the content for this view. An initial composition will occur when the view is attached to a window, or when <strong class="source-inline">createComposition()</strong> is called. While <strong class="source-inline">setContent()</strong> is defined in <strong class="source-inline">ComposeView</strong>, <strong class="source-inline">createComposition()</strong> belongs to <strong class="source-inline">AbstractComposeView</strong>. It performs the initial composition for this view. Typically, you do not need to invoke this function directly.</p>
			<p><strong class="source-inline">setViewCompositionStrategy()</strong> configures how to manage the disposal of the View's internal composition. <strong class="source-inline">ViewCompositionStrategy.</strong><strong class="source-inline">DisposeOnDetached FromWindow</strong> (the default) means that the <a id="_idIndexMarker348"/>composition is disposed whenever <a id="_idIndexMarker349"/>the view becomes detached from a window. This is preferred for simple scenarios, as in my example. If your view is shown inside a fragment or a component with a known <strong class="source-inline">LifecycleOwner</strong>, you should use <strong class="source-inline">DisposeOnViewTreeLifecycleDestroyed</strong> or <strong class="source-inline">DisposeOnLifecycleDestroyed</strong> instead. These, however, are topics beyond the scope of this book. The following line creates state based on the <strong class="source-inline">sliderValue</strong> property of the ViewModel and passes the value to <strong class="source-inline">ComposeDemo()</strong>:</p>
			<p class="source-code">val sliderValue = viewModel.sliderValue.observeAsState()</p>
			<p>This composable also receives a block that launches <strong class="source-inline">ComposeActivity</strong> and passes the current slider value to it, as illustrated in the following code snippet:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeDemo(value: Float, onClick: () -&gt; Unit) {</p>
			<p class="source-code">  Column(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize(),</p>
			<p class="source-code">    horizontalAlignment = Alignment.CenterHorizontally</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .fillMaxWidth()</p>
			<p class="source-code">        .background(MaterialTheme.colors.secondary)</p>
			<p class="source-code">        .height(64.dp),</p>
			<p class="source-code">      contentAlignment = Alignment.Center</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">      Text(</p>
			<p class="source-code">        text = value.toString()</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">    Button(</p>
			<p class="source-code">      onClick = onClick,</p>
			<p class="source-code">      modifier = Modifier.padding(top = 16.dp)</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">      Text(text = stringResource(id =</p>
			<p class="source-code">            R.string.compose_activity))</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">ComposeDemo()</strong>, as <a id="_idIndexMarker350"/>illustrated in the following <a id="_idIndexMarker351"/>screenshot, puts a <strong class="source-inline">Box()</strong> (which contains a <strong class="source-inline">Text()</strong>) and a <strong class="source-inline">Button()</strong>inside a <strong class="source-inline">Column()</strong>, in order to resemble <strong class="source-inline">ViewActivity</strong>. Wrapping <strong class="source-inline">Text()</strong> inside the <strong class="source-inline">Box()</strong>is necessary to vertically center the text inside an area with a particular height. A click on the button invokes the <strong class="source-inline">onClick</strong> lambda expression. <strong class="source-inline">Text()</strong> just shows the <strong class="source-inline">value</strong> parameter: </p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="Images/B17505_09_3.jpg" alt="Figure 9.3 – The InteropDemo sample showing ViewActivity&#13;&#10;" width="1380" height="517"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The InteropDemo sample showing ViewActivity</p>
			<p>Before closing <a id="_idIndexMarker352"/>out this chapter, let me recap <a id="_idIndexMarker353"/>on important steps you need to take to include a Compose hierarchy in a layout, as follows:</p>
			<ul>
				<li>Add <strong class="source-inline">androidx.compose.ui.platform.ComposeView</strong> to the layout.</li>
				<li>Decide on a <strong class="source-inline">ViewCompositionStrategy</strong>, depending on where the layout is shown (activity, fragment, …).</li>
				<li>Set the content using <strong class="source-inline">setContent {}</strong>.</li>
				<li>Obtain a reference to the <strong class="source-inline">ViewModel</strong> by invoking <strong class="source-inline">viewModels()</strong>.</li>
				<li>Register listeners to relevant Views and update the <strong class="source-inline">ViewModel</strong> upon changes.</li>
				<li>Inside composable functions, create state by invoking <strong class="source-inline">observeAsState()</strong> on ViewModel properties as needed.</li>
				<li>Inside composables, update the ViewModel by invoking corresponding setters.</li>
			</ul>
			<p>Jetpack Compose interoperability APIs allow for seamless two-way integration of composable functions and <strong class="source-inline">View</strong> hierarchies. They help you use libraries that rely on Views and <a id="_idIndexMarker354"/>ease the transition to Compose by <a id="_idIndexMarker355"/>making a gradual, fine-grained migration possible.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor158"/>Summary</h1>
			<p>In this chapter, we looked at the interoperability APIs of Jetpack Compose, which allow you to mix composable functions and traditional Views. We started by incorporating a traditional View hierarchy from a third-party library in a Compose app, using <strong class="source-inline">AndroidView()</strong>. As recent apps favor View Binding over the direct use of <strong class="source-inline">findViewById()</strong>, I also showed you how to embed layouts in a composable with View Binding and <strong class="source-inline">AndroidViewBinding()</strong>. Once you have embedded a <strong class="source-inline">View</strong> in a Compose UI, you need to share data between the two worlds. The <em class="italic">Sharing data between Views and composable functions</em> section explained how to achieve this with ViewModels. The final main section, <em class="italic">Embedding composables in View hierarchies</em>, discussed how to include a Compose UI in existing apps using <strong class="source-inline">ComposeView</strong>.</p>
			<p><a href="B17505_10_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 10</em></a>, <em class="italic">Testing and Debugging Compose Apps</em><em class="italic">,</em> focuses on testing your Compose apps. You will learn how to use <strong class="source-inline">ComposeTestRule</strong> and <strong class="source-inline">AndroidComposeTestRule</strong>. Also, I will introduce you to the <em class="italic">semantics tree</em>.</p>
		</div>
	</div></body></html>