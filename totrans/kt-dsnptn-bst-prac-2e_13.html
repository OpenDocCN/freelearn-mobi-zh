<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer027">&#13;
			<h1 id="_idParaDest-231"><em class="italic"><a id="_idTextAnchor237"/>Chapter 10</em>: Concurrent Microservices with Ktor</h1>&#13;
			<p>In the previous chapter, we explored how we should write idiomatic Kotlin code that will be readable and maintainable, as well as performant.</p>&#13;
			<p>In this chapter, we'll put the skills we've learned so far to use by building a microservice using the <strong class="bold">Ktor framework</strong>. We also want this microservice to be reactive and to be as close to real life as possible. For that, we'll use the Ktor framework, the benefits of which we'll list in the first section of this chapter.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Getting started with Ktor</li>&#13;
				<li>Routing requests</li>&#13;
				<li>Testing the service</li>&#13;
				<li>Modularizing the application</li>&#13;
				<li>Connecting to a database</li>&#13;
				<li>Creating new entities</li>&#13;
				<li>Making the test consistent</li>&#13;
				<li>Fetching entities</li>&#13;
				<li>Organizing routes in Ktor</li>&#13;
				<li>Achieving concurrency in Ktor</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you'll have a microservice written in Kotlin that is well tested and can read data from a PostgreSQL database and store data in it.</p>&#13;
			<h1 id="_idParaDest-232"><a id="_idTextAnchor238"/>Technical requirements</h1>&#13;
			<p>This is what you'll need to get started:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">JDK 11</strong> or later</li>&#13;
				<li>IntelliJ IDEA</li>&#13;
				<li><strong class="bold">Gradle 6.8</strong> or later</li>&#13;
				<li><strong class="bold">PostgreSQL 14</strong> or later</li>&#13;
			</ul>&#13;
			<p>This chapter will assume that you have <strong class="source-inline">PostgreSQL</strong> already installed and that you have the basic knowledge for working with it. If you don't, please refer to the official documentation: <a href="https://www.postgresql.org/docs/14/tutorial-install.html">https://www.postgresql.org/docs/14/tutorial-install.html</a>.</p>&#13;
			<p>You can find the source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10</a>.</p>&#13;
			<h1 id="_idParaDest-233"><a id="_idTextAnchor239"/>Getting started with Ktor</h1>&#13;
			<p>You're probably<a id="_idIndexMarker654"/> tired of creating to-do or shopping lists.</p>&#13;
			<p>So, instead, in this chapter, the microservice will be for a <strong class="source-inline">cat shelter</strong>. The microservice should be able to do the following:</p>&#13;
			<ul>&#13;
				<li>Supply an endpoint we can ping to check whether the service is up and running</li>&#13;
				<li>List the cats currently in the shelter</li>&#13;
				<li>Provide us with a means to add new cats</li>&#13;
			</ul>&#13;
			<p>The framework we'll be using for our microservice in this<a id="_idIndexMarker655"/> chapter is called <strong class="bold">Ktor</strong>. It's a concurrent framework that's developed and maintained by the creators of the Kotlin programming language.</p>&#13;
			<p>Let's start by creating a new Kotlin Gradle project:</p>&#13;
			<ol>&#13;
				<li>From your IntelliJ IDEA, select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong> and choose <strong class="bold">Kotlin</strong> from <strong class="bold">New Project</strong> and <strong class="bold">Gradle Kotlin</strong> as your <strong class="bold">Build System</strong>.</li>&#13;
				<li>Give your project a descriptive name – <strong class="source-inline">CatsHostel</strong>, in my case – and choose <strong class="bold">Project JDK</strong> (in this case, we are using <strong class="bold">JDK 15</strong>):<div id="_idContainer023" class="IMG---Figure"><img src="Images/Figure_10.1_B17816.jpg" alt="Figure 10.1 – Selecting the Project JDK type&#13;&#10;" width="1100" height="791"/></div><p class="figure-caption">Figure 10.1 – Selecting the Project JDK type</p></li>&#13;
				<li>On the next<a id="_idIndexMarker656"/> screen, select <strong class="bold">JUnit 5</strong> as your <strong class="bold">Test framework</strong> and set <strong class="bold">Target JVM version</strong> to <strong class="bold">1.8</strong>. Then, click <strong class="bold">Finish</strong>:<div id="_idContainer024" class="IMG---Figure"><img src="Images/Figure_10.2_B17816.jpg" alt="Figure 10.2 – Selecting Test framework and Target JVM version&#13;&#10;" width="980" height="330"/></div><p class="figure-caption">Figure 10.2 – Selecting Test framework and Target JVM version</p></li>&#13;
				<li>Now, you should see the following structure:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer025" class="IMG---Figure">&#13;
					<img src="Images/Figure_10.3_B17816.jpg" alt="Figure 10.3 – Project structure&#13;&#10;" width="539" height="516"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 10.3 – Project structure</p>&#13;
			<p>Next, let's<a id="_idIndexMarker657"/> open <strong class="source-inline">build.gradle.kts</strong>. This file controls how your project is built, its dependencies, and the libraries that the project is going to use. Depending on the version of your IntelliJ IDEA, the file's contents may differ a bit, but the general structure stays the same. </p>&#13;
			<p>The <strong class="source-inline">.kts</strong> extension means that the configuration file for our Kotlin project is written in Kotlin, or to be precise, in <strong class="bold">Kotlin Script</strong>. Now, we would like to start using the Ktor framework to write our server. To do that, let's find our <strong class="source-inline">dependencies</strong> block, which should look like this:</p>&#13;
			<p class="source-code">dependencies {</p>&#13;
			<p class="source-code">    implementation(...)</p>&#13;
			<p class="source-code">    testImplementation("org.junit.jupiter:junit-jupiter-        api:5.6.0")</p>&#13;
			<p class="source-code">    testRuntimeOnly("org.junit.jupiter:junit-jupiter-        engine:5.6.0")</p>&#13;
			<p class="source-code">    </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The preceding code mentions all the libraries that your project will be using. The <strong class="source-inline">implementation()</strong> configuration means that the library will be used at all times. The <strong class="source-inline">testImplementation()</strong> configuration means that the library will only be used during tests.</p>&#13;
			<p>Now, let's take a look at how a library is defined in the following example:</p>&#13;
			<p class="source-code">"org.junit.jupiter:junit-jupiter-api:5.6.0"</p>&#13;
			<p>This is a regular string that has been separated into three parts, as follows:</p>&#13;
			<p class="source-code">"group:name:version"</p>&#13;
			<p>The <strong class="source-inline">group</strong> and <strong class="source-inline">name</strong> strings<a id="_idIndexMarker658"/> identify the library; the <strong class="source-inline">version</strong> configuration should be self-explanatory.</p>&#13;
			<p>Now, let's modify the <strong class="source-inline">dependencies</strong> block, as follows:</p>&#13;
			<p class="source-code">val ktorVersion = "1.6.0"</p>&#13;
			<p class="source-code">dependencies {</p>&#13;
			<p class="source-code">    implementation("io.ktor:ktor-server-</p>&#13;
			<p class="source-code">        netty:$ktorVersion")</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Since the files with <strong class="source-inline">.kts</strong> extensions are Kotlin files, we can use regular Kotlin syntax in them. In this case, we are using values and string interpolation to extract the version of our library.</p>&#13;
			<p>The latest version of Ktor to date is <strong class="bold">1.6.4</strong>, but when you read this book, it will be greater than this. You can find the <a id="_idIndexMarker659"/>latest version here: <a href="https://ktor.io/">https://ktor.io/</a>.</p>&#13;
			<p>As a general rule, all Ktor libraries should be the same version and that's when the variable becomes useful.</p>&#13;
			<p class="callout-heading">Tip:</p>&#13;
			<p class="callout">If you have followed the steps from the beginning of this section, you should have a file called <strong class="source-inline">server.kt</strong> in the <strong class="source-inline">src/main/kotlin</strong> folder in your project. If you don't, create one now.</p>&#13;
			<p>Now, let's add<a id="_idIndexMarker660"/> the following content to the <strong class="source-inline">server.kt</strong> file:</p>&#13;
			<p class="source-code">fun main() {</p>&#13;
			<p class="source-code">    embeddedServer(Netty, port = 8080) {</p>&#13;
			<p class="source-code">        routing {</p>&#13;
			<p class="source-code">            get("/") {</p>&#13;
			<p class="source-code">                call.respondText("OK")</p>&#13;
			<p class="source-code">            }</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }.start(wait = true)</p>&#13;
			<p class="source-code">    println("open http://localhost:8080")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>That's all the code we need to write to start a web server that will respond with <strong class="source-inline">OK</strong> when you open <strong class="source-inline">http://localhost:8080</strong> in your browser. </p>&#13;
			<p>Now, let's understand what happens here:</p>&#13;
			<ul>&#13;
				<li>To interact with the request and return a response, we can use the <strong class="source-inline">call</strong> object, also known <a id="_idIndexMarker661"/>as the <strong class="bold">context</strong>. This object provides all the convenient methods for parsing requests and returning responses in different formats, and we'll see the different methods available for it throughout this chapter.</li>&#13;
				<li>The <strong class="source-inline">embeddedServer()</strong> function is an implementation of the Builder pattern, which we discussed in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. It allows us to configure our server. Most of the arguments have the same defaults. We override <strong class="source-inline">port</strong> to <strong class="source-inline">8080</strong> just for convenience. </li>&#13;
				<li>We specify the <strong class="source-inline">wait</strong> argument to be <strong class="source-inline">true</strong> so that our server will wait for incoming requests.</li>&#13;
				<li>The only mandatory argument to the <strong class="source-inline">embeddedServer</strong> function is the server engine. In our example, we use <strong class="source-inline">Netty</strong>, which is a very well-known JVM library, but there are others as well. The most interesting of them is <strong class="source-inline">CIO</strong>, which was developed by JetBrains themselves. </li>&#13;
			</ul>&#13;
			<p>Now, let's understand what <strong class="source-inline">CIO</strong> and <strong class="source-inline">Netty</strong> are. They are both <strong class="bold">Factory</strong> patterns that create the actual instance of our server when invoked. This is a really interesting combination of different design patterns in one place to create a very flexible and extensible architecture.</p>&#13;
			<p>To switch to <a id="_idIndexMarker662"/>using <strong class="source-inline">CIO</strong>, all we need to do is add a new dependency:</p>&#13;
			<p class="source-code">dependencies { </p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">    implementation("io.ktor:ktor-server-cio:$ktorVersion") </p>&#13;
			<p class="source-code">    ... </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Then, we need to pass another server engine, <strong class="source-inline">CIO</strong>, to our <strong class="source-inline">embeddedServer</strong> function:</p>&#13;
			<p class="source-code">embeddedServer(CIO, port = 8080) { </p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}.start(wait = true)</p>&#13;
			<p>Notice that we didn't have to change anything else in our code when we switched the server engine. That is because <strong class="source-inline">embeddedServer()</strong> uses the Bridge design pattern to make components interchangeable. </p>&#13;
			<p>Now that our server has been started, let's investigate how we define different responses for each request to the server.</p>&#13;
			<h1 id="_idParaDest-234"><a id="_idTextAnchor240"/>Routing requests</h1>&#13;
			<p>Now, let's take<a id="_idIndexMarker663"/> a look at the <strong class="source-inline">routing</strong> block:</p>&#13;
			<p class="source-code">routing { </p>&#13;
			<p class="source-code">    get("/") { </p>&#13;
			<p class="source-code">        call.respondText("OK") </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This block describes all the URLs that will be handled by our server. In this case, we only handle the root URL. When that URL is requested, a text response, <strong class="source-inline">OK</strong>, will be returned to the user.</p>&#13;
			<p>The following code returns a text response. Now, let's see how we can return a JSON response instead:</p>&#13;
			<p class="source-code">get("/status") {</p>&#13;
			<p class="source-code">    call.respond(mapOf("status" to "OK"))</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Instead of using the <strong class="source-inline">respondText()</strong> method, we'll use <strong class="source-inline">respond()</strong>, which receives an object instead of a string. In our example, we're passing a map of strings to the <strong class="source-inline">respond()</strong> function. If we run this code, though, we'll get an exception.</p>&#13;
			<p>This is because, by default, objects are not serialized into JSON. Multiple libraries can do this for us. In this example, we'll use the <strong class="source-inline">kotlinx-serialization</strong> library. Let's start by adding it to our dependencies:</p>&#13;
			<p class="source-code">dependencies {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">    implementation("org.jetbrains.kotlinx:kotlinx-        serialization-json-jvm:1.3.0")</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Next, we need to add the following lines before our <strong class="source-inline">routing</strong> block:</p>&#13;
			<p class="source-code">install(ContentNegotiation) {</p>&#13;
			<p class="source-code">    json()</p>&#13;
			<p class="source-code">} </p>&#13;
			<p>Now, if we run our code again, it will output this on our browser:</p>&#13;
			<p class="source-code">&gt; {"status":"OK"}</p>&#13;
			<p>We've just created our first route, which returns an object serialized as JSON. Now, we can check whether our application works by opening <strong class="source-inline">http://localhost:8080/status</strong> in our browser. But that is a bit cumbersome. In the next section, we'll learn how to write a test <a id="_idIndexMarker664"/>for the <strong class="source-inline">/status</strong> endpoint.</p>&#13;
			<h1 id="_idParaDest-235"><a id="_idTextAnchor241"/>Testing the service</h1>&#13;
			<p>To write our first <a id="_idIndexMarker665"/>test, let's create a new file called <strong class="source-inline">ServerTest.kt</strong> under the <strong class="source-inline">src/test/kotlin</strong> directory.</p>&#13;
			<p>Now, let's add a new dependency:</p>&#13;
			<p class="source-code">dependencies {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">    testImplementation("io.ktor:ktor-server-</p>&#13;
			<p class="source-code">        tests:$ktorVersion")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Next, let's add the following contents to our <strong class="source-inline">ServerTest.kt</strong> file:</p>&#13;
			<p class="source-code">internal class ServerTest {</p>&#13;
			<p class="source-code">    @Test</p>&#13;
			<p class="source-code">    fun testStatus() {</p>&#13;
			<p class="source-code">        withTestApplication {</p>&#13;
			<p class="source-code">            val response = handleRequest(HttpMethod.Get,                 "/status").response</p>&#13;
			<p class="source-code">            assertEquals(HttpStatusCode.OK,                 response.status())</p>&#13;
			<p class="source-code">            assertEquals("""{"status": "OK"}""",                 response.content)</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Tests in Kotlin are grouped into classes, and each test is a method in the class, which is marked with the <strong class="source-inline">@Test</strong> annotation. </p>&#13;
			<p>Inside the <strong class="source-inline">test</strong> method, we start a test server, issue a <strong class="source-inline">GET</strong> request to the <strong class="source-inline">/status</strong> endpoint, and check that the endpoint responds with a correct status code and JSON body.</p>&#13;
			<p>If you run this test <a id="_idIndexMarker666"/>now, though, it will fail, because we haven't started our server yet. To do so, we'll need to refactor it a bit, which we'll do in the next section.</p>&#13;
			<h1 id="_idParaDest-236"><a id="_idTextAnchor242"/>Modularizing the application</h1>&#13;
			<p>So far, our server<a id="_idIndexMarker667"/> has been started from the <strong class="source-inline">main()</strong> function. This was simple to set up, but this doesn't allow us to test our application. </p>&#13;
			<p>In Ktor, the code is usually organized into modules. Let's rewrite our <strong class="source-inline">main</strong> function, as follows:</p>&#13;
			<p class="source-code">fun main() {</p>&#13;
			<p class="source-code">    embeddedServer(</p>&#13;
			<p class="source-code">        CIO,</p>&#13;
			<p class="source-code">        port = 8080,</p>&#13;
			<p class="source-code">        module = Application::mainModule</p>&#13;
			<p class="source-code">    ).start(wait = true)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, instead of providing the logic of our server within a block, we specified a module that will contain all the configurations for our server.</p>&#13;
			<p>This module is <a id="_idIndexMarker668"/>defined as an extension function on the <strong class="source-inline">Application</strong> object:</p>&#13;
			<p class="source-code">fun Application.mainModule() {</p>&#13;
			<p class="source-code">    install(ContentNegotiation) {</p>&#13;
			<p class="source-code">        json()</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    routing {</p>&#13;
			<p class="source-code">        get("/status") {</p>&#13;
			<p class="source-code">            call.respond(mapOf("status" to "OK"))</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    println("open http://localhost:8080")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>As you can see, the content of this function is the same as that of the block that we passed to our <strong class="source-inline">embeddedService</strong> function earlier.</p>&#13;
			<p>Now, all we need to do is go back to our test and specify which module we would like to test:</p>&#13;
			<p class="source-code">@Test</p>&#13;
			<p class="source-code">fun testStatus() {</p>&#13;
			<p class="source-code">    withTestApplication(<strong class="bold">Application::mainModule</strong>) {</p>&#13;
			<p class="source-code">        ...</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If you run this test now, it should pass, because our server has started properly in test mode. </p>&#13;
			<p>So far, we've only dealt with the infrastructure of our service; we haven't touched on its business logic: <em class="italic">managing cats</em>. To do so, we'll need a database. In the next section, we'll discuss <a id="_idIndexMarker669"/>how Ktor solves this problem using the Exposed library.</p>&#13;
			<h1 id="_idParaDest-237"><a id="_idTextAnchor243"/>Connecting to a database</h1>&#13;
			<p>To store and <a id="_idIndexMarker670"/>retrieve cats, we'll need to connect to a database. We'll use PostgreSQL for that purpose, although using another SQL database won't be any different.</p>&#13;
			<p>First, we'll need a new library to connect to the database. We'll use the Exposed library, which is also developed by JetBrains. </p>&#13;
			<p>Let's add the following dependency to our <strong class="source-inline">build.gradle.kts</strong> file:</p>&#13;
			<p class="source-code">dependencies {</p>&#13;
			<p class="source-code">    implementation("org.jetbrains.exposed:exposed:0.17.14")</p>&#13;
			<p class="source-code">    implementation("org.postgresql:postgresql:42.2.24")</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Once the libraries are in place, we need to connect to them. To do that, let's create a new file called <strong class="source-inline">DB.kt</strong> under <strong class="source-inline">/src/main/kotlin</strong> with the following contents:</p>&#13;
			<p class="source-code">object DB {</p>&#13;
			<p class="source-code">    private val host=System.getenv("DB_HOST")?:"localhost"</p>&#13;
			<p class="source-code">    private val port =         System.getenv("DB_PORT")?.toIntOrNull() ?: 5432</p>&#13;
			<p class="source-code">    private val dbName = System.getenv("DB_NAME") ?:         "cats_db"</p>&#13;
			<p class="source-code">    private val dbUser = System.getenv("DB_USER") ?:         "cats_admin"</p>&#13;
			<p class="source-code">    private val dbPassword = System.getenv("DB_PASSWORD")         ?: "abcd1234"</p>&#13;
			<p class="source-code">  fun connect() = Database.connect(      "jdbc:postgresql://$host:$port/$dbName",      driver = "org.postgresql.Driver",      user = dbUser,      password = dbPassword</p>&#13;
			<p class="source-code">  )</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Since our application needs exactly one instance of a database, the <strong class="source-inline">DB</strong> object can use the Singleton pattern, which we discussed in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. For that, we will use the <strong class="source-inline">object</strong> keyword.</p>&#13;
			<p>Then, for each of <a id="_idIndexMarker671"/>the variables that we need to connect to the database, we will attempt to read them from our environment. If the <strong class="source-inline">environment</strong> variable is not set, we will use a default value using the <strong class="bold">Elvis</strong> operator. </p>&#13;
			<p class="callout-heading">Tip:</p>&#13;
			<p class="callout">Creating a database and a user is beyond the scope of this book, but you can refer to the official documentation for this, at <a href="https://www.postgresql.org/docs/14/app-createuser.html">https://www.postgresql.org/docs/14/app-createuser.html</a> and <a href="https://www.postgresql.org/docs/14/app-createdb.html">https://www.postgresql.org/docs/14/app-createdb.html</a>.</p>&#13;
			<p>Alternatively, you can simply run the following two commands in your command line:</p>&#13;
			<p class="source-code">$ createuser cats_admin -W –d</p>&#13;
			<p class="source-code">$ createdb cats_db -U cats_admin</p>&#13;
			<p>The first command creates a database user called <strong class="source-inline">cats_admin</strong> and asks you to specify a password for this user. Our application will use this <strong class="source-inline">cats_admin</strong> user to interact with the database. The second command creates a database called <strong class="source-inline">cats_db</strong> that belongs to the <strong class="source-inline">cats_admin</strong> user. Now that our database has been created, all we need to do is create a table that will store our cats in it.</p>&#13;
			<p>For that, let's define another Singleton object in our <strong class="source-inline">DB.kt</strong> file that will represent a table:</p>&#13;
			<p class="source-code">object CatsTable : IntIdTable() {</p>&#13;
			<p class="source-code">    val name = varchar("name", 20).uniqueIndex()</p>&#13;
			<p class="source-code">    val age = integer("age").default(0)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Let's understand what the preceding definition means:</p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">IntIdTable</strong> means that we want to create a table with a primary key of the <strong class="source-inline">Int</strong> type.</li>&#13;
				<li>In the body<a id="_idIndexMarker672"/> of our object, we define the columns. In addition to the <strong class="source-inline">ID</strong> column, we'll have a <strong class="source-inline">name</strong> column that is of the <strong class="source-inline">varchar</strong> type, or in other words, a string, and is <strong class="source-inline">20</strong> characters at the most.</li>&#13;
				<li>The cat's <strong class="source-inline">name</strong> column is also unique, meaning that no two cats can have the same name.</li>&#13;
				<li>We also have a third column that is of the <strong class="source-inline">integer</strong> type, or <strong class="source-inline">Int</strong> in Kotlin terms, and is defaulted to <strong class="source-inline">0</strong>.</li>&#13;
			</ul>&#13;
			<p>We'll also have a <strong class="source-inline">data</strong> class to represent a single cat:</p>&#13;
			<p class="source-code">data class Cat(val id: Int,</p>&#13;
			<p class="source-code">               val name: String,</p>&#13;
			<p class="source-code">               val age: Int)</p>&#13;
			<p>The only thing that is left for us to do is add the following lines of code to our <strong class="source-inline">mainModule()</strong> function:</p>&#13;
			<p class="source-code">DB.connect()</p>&#13;
			<p class="source-code">transaction {</p>&#13;
			<p class="source-code">    SchemaUtils.create(CatsTable)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Each time our application starts, the preceding code will connect to the database. Then, it will attempt to create a table that stores our entities. If a table already exists, nothing will happen. </p>&#13;
			<p>Now that we<a id="_idIndexMarker673"/> have established a connection to our database, let's examine how we can use this connection to store a few cats in it.</p>&#13;
			<h1 id="_idParaDest-238"><a id="_idTextAnchor244"/>Creating new entities</h1>&#13;
			<p>Our next task is <a id="_idIndexMarker674"/>adding the first cat to our virtual shelter. </p>&#13;
			<p>Following the REST principles, it should be a <strong class="source-inline">POST</strong> request, where the body of the request may look something like this: </p>&#13;
			<p class="source-code">{"name": "Meatloaf", "age": 4}</p>&#13;
			<p>We'll start by writing a new test:</p>&#13;
			<p class="source-code">@Test</p>&#13;
			<p class="source-code">fun `POST creates a new cat`() {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Backticks are a useful Kotlin feature that allows us to have spaces in the names of our functions. This helps us create descriptive test names.</p>&#13;
			<p>Next, let's look at the body of our test:</p>&#13;
			<p class="source-code">withTestApplication(Application::mainModule) {</p>&#13;
			<p class="source-code">    val response = handleRequest(HttpMethod.Post, "/cats") {</p>&#13;
			<p class="source-code">        addHeader(</p>&#13;
			<p class="source-code">          HttpHeaders.ContentType,</p>&#13;
			<p class="source-code">          ContentType.Application.FormUrlEncoded.toString()</p>&#13;
			<p class="source-code">        )</p>&#13;
			<p class="source-code">        setBody(</p>&#13;
			<p class="source-code">            listOf(</p>&#13;
			<p class="source-code">                "name" to "Meatloaf",</p>&#13;
			<p class="source-code">                "age" to 4.toString()</p>&#13;
			<p class="source-code">            ).formUrlEncode()</p>&#13;
			<p class="source-code">        )</p>&#13;
			<p class="source-code">    }.response</p>&#13;
			<p class="source-code">    assertEquals(HttpStatusCode.Created, response.status())</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We discussed the <strong class="source-inline">withTestApplication</strong> and <strong class="source-inline">handleRequest</strong> functions in the previous section. This time, we are using a <strong class="source-inline">POST</strong> request. These types of requests should have the correct header, so we must set those headers using the <strong class="source-inline">addHeader()</strong> function. We must also set the body to the contents discussed previously. </p>&#13;
			<p>Finally, we must <a id="_idIndexMarker675"/>check whether the response header is set to the <strong class="source-inline">Created</strong> HTTP code.</p>&#13;
			<p>If we run this test now, it will fail with an HTTP code of <strong class="source-inline">404</strong> since we haven't implemented the <strong class="source-inline">post</strong> <strong class="source-inline">/cats</strong> endpoint yet. </p>&#13;
			<p>Let's go back to our <strong class="source-inline">routing</strong> block and add a new endpoint:</p>&#13;
			<p class="source-code">post("/cats") {</p>&#13;
			<p class="source-code">    ...    </p>&#13;
			<p class="source-code">    call.respond(HttpStatusCode.Created)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>To create a new cat, we'll need to read the body of the <strong class="source-inline">POST</strong> request. We'll use the <strong class="source-inline">receiveParameters()</strong> function for this:</p>&#13;
			<p class="source-code">val parameters = call.receiveParameters()</p>&#13;
			<p class="source-code">val name = requireNotNull(parameters["name"])</p>&#13;
			<p class="source-code">val age = parameters["age"]?.toInt() ?: 0</p>&#13;
			<p>The <strong class="source-inline">receiveParameters</strong> function returns a case-insensitive map. First, we will attempt to fetch the cat's <strong class="source-inline">name</strong> from this map, and if there's no name in the request, we will fail the call. This will be handled by Ktor.</p>&#13;
			<p>Then, if we didn't receive <strong class="source-inline">age</strong>, we will default it to <strong class="source-inline">0</strong> using the Elvis operator.</p>&#13;
			<p>Now, we must insert those values into the database:</p>&#13;
			<p class="source-code">transaction {</p>&#13;
			<p class="source-code">    CatsTable.insert { cat -&gt;</p>&#13;
			<p class="source-code">        cat[CatsTable.name] = name</p>&#13;
			<p class="source-code">        cat[CatsTable.age] = age</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we open a <strong class="source-inline">transaction</strong> block to make changes to the database. Then, we use the <strong class="source-inline">insert()</strong> method, which is available on every table. Inside the <strong class="source-inline">insert</strong> lambda, the <strong class="source-inline">cat</strong> variable refers to the new row we are going to populate. We set the name of that row to the value of the <strong class="source-inline">name</strong> parameter and do the same for <strong class="source-inline">age</strong>.</p>&#13;
			<p>If you run your test now, it should pass. But if you run it again, it will fail. That's because the name of a cat in the database is unique. Also, we don't clean the database between test runs. So, the<a id="_idIndexMarker676"/> first run creates a cat named <strong class="source-inline">Meatloaf</strong>, while the second run fails. This is because such a cat already exists. </p>&#13;
			<p>To make our tests consistent, we need a way to clean our database between runs.</p>&#13;
			<h1 id="_idParaDest-239"><a id="_idTextAnchor245"/>Making the tests consistent</h1>&#13;
			<p>Let's go <a id="_idIndexMarker677"/>back to our test and add the following piece of code:</p>&#13;
			<p class="source-code">@BeforeEach</p>&#13;
			<p class="source-code">fun setup() {</p>&#13;
			<p class="source-code">    DB.connect()</p>&#13;
			<p class="source-code">    transaction {</p>&#13;
			<p class="source-code">        SchemaUtils.drop(CatsTable)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we are using the <strong class="source-inline">@BeforeEach</strong> annotation on a function. As its name suggests, this code will run before each test. The function will establish a connection to the database and drop the table completely. Then, our application will recreate the table.</p>&#13;
			<p>Now, our tests should pass consistently. In the next section, we'll learn how to fetch a cat from the<a id="_idIndexMarker678"/> database using the Exposed library.</p>&#13;
			<h1 id="_idParaDest-240"><a id="_idTextAnchor246"/>Fetching entities</h1>&#13;
			<p>Following the REST <a id="_idIndexMarker679"/>practices, the URL for fetching all cats should be <strong class="source-inline">/cats</strong>, while for fetching a single cat, it should be <strong class="source-inline">/cats/123</strong>, where <strong class="source-inline">123</strong> is the ID of the cat we are trying to fetch.</p>&#13;
			<p>Let's add two new routes for that:</p>&#13;
			<p class="source-code">get("/cats") {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">get("/cats/{id}") {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The first route is very similar to the <strong class="source-inline">/status</strong> route we introduced earlier in this chapter. But the second round is slightly different: it uses a query parameter in the URL. You can recognize query parameters by the curly brackets around their name.</p>&#13;
			<p>To read a query parameter, we can access the <strong class="source-inline">parameters</strong> map:</p>&#13;
			<p class="source-code">val id = requireNotNull(call.parameters["id"]).toInt()</p>&#13;
			<p>If there is an ID on the URL, we need to try and fetch a cat from the database:</p>&#13;
			<p class="source-code">val cat = transaction {</p>&#13;
			<p class="source-code">    CatsTable.select {</p>&#13;
			<p class="source-code">        CatsTable.id.eq(id)</p>&#13;
			<p class="source-code">    }.firstOrNull()</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we open a transaction and use the <strong class="source-inline">select</strong> statement to get a cat with an ID equal to what we were provided previously.</p>&#13;
			<p>If an object was returned, we would convert it into JSON. Otherwise, we would return an HTTP <a id="_idIndexMarker680"/>code of <strong class="source-inline">404</strong>, <strong class="source-inline">Not Found</strong>:</p>&#13;
			<p class="source-code">if (row == null) {</p>&#13;
			<p class="source-code">    call.respond(HttpStatusCode.NotFound)</p>&#13;
			<p class="source-code">} else {</p>&#13;
			<p class="source-code">    call.respond(</p>&#13;
			<p class="source-code">        Cat(</p>&#13;
			<p class="source-code">            row[CatsTable.id].value,</p>&#13;
			<p class="source-code">            row[CatsTable.name],</p>&#13;
			<p class="source-code">            row[CatsTable.age]</p>&#13;
			<p class="source-code">        )</p>&#13;
			<p class="source-code">    )</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, let's add a test for fetching a single cat as well:</p>&#13;
			<p class="source-code">@Test</p>&#13;
			<p class="source-code">fun `GET with ID fetches a single cat`() {</p>&#13;
			<p class="source-code">    withTestApplication(Application::mainModule) {</p>&#13;
			<p class="source-code">        val id = transaction {</p>&#13;
			<p class="source-code">            CatsTable.<strong class="bold">insertAndGetId </strong>{ cat -&gt;</p>&#13;
			<p class="source-code">                cat[name] = "Fluffy"</p>&#13;
			<p class="source-code">            }</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">         val response = handleRequest(HttpMethod.Get, </p>&#13;
			<p class="source-code">            "/cats/$id").response</p>&#13;
			<p class="source-code">        assertEquals("""{"id":1,"name":</p>&#13;
			<p class="source-code">            "Fluffy","age":0}""", response.content)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In this test, we create a cat using Exposed. Here, we're using a new method called <strong class="source-inline">insertAndGetId</strong>. As its name suggests, it will return the ID of a newly created row. Then, we try to fetch that cat using our newly created endpoint.</p>&#13;
			<p>If we try to run this test, though, it will fail with the following exception:</p>&#13;
			<p class="source-code">&gt; Serializer for class 'Cat' is not found.</p>&#13;
			<p>By default, Ktor<a id="_idIndexMarker681"/> doesn't know how to turn our custom data class into JSON. To fix that, we'll need to add a new plugin to our <strong class="source-inline">build.gradle.kts</strong> file:</p>&#13;
			<p class="source-code">plugins {</p>&#13;
			<p class="source-code">    kotlin("jvm") version "1.5.10"</p>&#13;
			<p class="source-code">    application</p>&#13;
			<p class="source-code">    <strong class="bold">kotlin("plugin.serialization") version "1.5.10"</strong></p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This plugin will create serializers at compile time for any class marked with the <strong class="source-inline">@Serializable</strong> annotation. All we need to do now for the test to pass is add that annotation to our <strong class="source-inline">Cat</strong> class:</p>&#13;
			<p class="source-code">@Serializable</p>&#13;
			<p class="source-code">data class Cat(</p>&#13;
			<p class="source-code">    val id: Int,</p>&#13;
			<p class="source-code">    val name: String,</p>&#13;
			<p class="source-code">    val age: Int</p>&#13;
			<p class="source-code">)</p>&#13;
			<p>That's it; now, our test for fetching a cat by its ID should pass. </p>&#13;
			<p>Finally, we would like to be able to fetch all the cats from the database. To do that, we must change<a id="_idIndexMarker682"/> our test setup a little:</p>&#13;
			<p class="source-code">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</p>&#13;
			<p class="source-code">class ServerTest {</p>&#13;
			<p class="source-code">    @BeforeAll</p>&#13;
			<p class="source-code">    fun setup() {</p>&#13;
			<p class="source-code">        DB.connect()</p>&#13;
			<p class="source-code">        transaction {</p>&#13;
			<p class="source-code">            SchemaUtils.create(CatsTable)</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    @AfterAll</p>&#13;
			<p class="source-code">    fun cleanup() {</p>&#13;
			<p class="source-code">        DB.connect()</p>&#13;
			<p class="source-code">        transaction {</p>&#13;
			<p class="source-code">            SchemaUtils.drop(CatsTable)</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we changed the setup of our test to drop the table once all the tests have been executed. So, instead of the <strong class="source-inline">@BeforeEach</strong> annotation, which executes the function before each test, we use the <strong class="source-inline">@AfterAll</strong> annotation, which executes the function after all tests have been executed.</p>&#13;
			<p>For this annotation to work, we also need to add the <strong class="source-inline">@TestInstance</strong> annotation to our class. The default for that is <strong class="source-inline">PER_METHOD</strong>, but since we want to execute multiple tests at once, and then clean up after, we need to set the life cycle of our test class to <strong class="source-inline">PER_CLASS</strong>.</p>&#13;
			<p>Next, let's wrap our test into a nested class, like this:</p>&#13;
			<p class="source-code">@Nested</p>&#13;
			<p class="source-code">inner class `With cat in DB` {</p>&#13;
			<p class="source-code">    </p>&#13;
			<p class="source-code">    @Test</p>&#13;
			<p class="source-code">    fun `GET with ID fetches a single cat`() {</p>&#13;
			<p class="source-code">        ...</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Nested test <a id="_idIndexMarker683"/>classes are a great way to encapsulate specific test situations. In our case, we would like to run two tests when there is a cat in our database already. </p>&#13;
			<p>Now, let's add the following setup code to our nested test:</p>&#13;
			<p class="source-code">lateinit var id: EntityID&lt;Int&gt;</p>&#13;
			<p class="source-code">@BeforeEach</p>&#13;
			<p class="source-code">fun setup() {</p>&#13;
			<p class="source-code">    DB.connect()</p>&#13;
			<p class="source-code">    id = transaction {</p>&#13;
			<p class="source-code">        CatsTable.insertAndGetId { cat -&gt;</p>&#13;
			<p class="source-code">            cat[name] = "Fluffy"</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">@AfterEach</p>&#13;
			<p class="source-code">fun teardown() {</p>&#13;
			<p class="source-code">    DB.connect()</p>&#13;
			<p class="source-code">    transaction {</p>&#13;
			<p class="source-code">        CatsTable.deleteAll()</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Before we execute each test in this nested class, we will create a cat in the database and after each test, we will delete all the cats from our database. Since we would like to keep track of the ID of the cat that we create, we will store it in a variable.</p>&#13;
			<p>Now, our test<a id="_idIndexMarker684"/> class for fetching a single entity looks like this:</p>&#13;
			<p class="source-code">@Test</p>&#13;
			<p class="source-code">fun `GET with ID fetches a single cat`() {</p>&#13;
			<p class="source-code">    withTestApplication(Application::mainModule) {</p>&#13;
			<p class="source-code">        val response = handleRequest(HttpMethod.Get,             "/cats/$id").response         assertEquals("""{<strong class="bold">"id":$id,</strong>"name":"Fluffy",            "age":0}""", response.content)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Notice that we interpolate the cat's ID into our expected response since it will change with each test execution.</p>&#13;
			<p>The test for fetching all the cats from the database will look almost the same:</p>&#13;
			<p class="source-code">@Test</p>&#13;
			<p class="source-code">fun `GET without ID fetches all cats`() {</p>&#13;
			<p class="source-code">    withTestApplication(Application::mainModule) {</p>&#13;
			<p class="source-code">        val response = handleRequest(HttpMethod.Get,             <strong class="bold">"/cats"</strong>).response         assertEquals("""<strong class="bold">[</strong>{"id":$id,"name":"Fluffy",            "age":0}<strong class="bold">]</strong>""", response.content)</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We just don't specify the ID, and the response is wrapped into a JSON array, as you can see by the square brackets around it.</p>&#13;
			<p>Now, all we<a id="_idIndexMarker685"/> need to do is implement this new route:</p>&#13;
			<p class="source-code">get("/cats") {</p>&#13;
			<p class="source-code">    val cats = transaction {</p>&#13;
			<p class="source-code">        CatsTable.selectAll().map { row -&gt;</p>&#13;
			<p class="source-code">            Cat(</p>&#13;
			<p class="source-code">                row[CatsTable.id].value,</p>&#13;
			<p class="source-code">                row[CatsTable.name],</p>&#13;
			<p class="source-code">                row[CatsTable.age]</p>&#13;
			<p class="source-code">            )</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    call.respond(cats)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If you followed the example for fetching a single entity from the database (from the beginning of this section), then this example won't be very different for you. We use the <strong class="source-inline">selectAll()</strong> function to fetch all the rows from the table. Then, we map each row to our <strong class="source-inline">data</strong> class. The only problem that is left for us to solve is that our code is quite messy and resides in a single file. It would be better if we split all the cat routes into a separate file. We'll<a id="_idIndexMarker686"/> do that in the next section.</p>&#13;
			<h1 id="_idParaDest-241"><a id="_idTextAnchor247"/>Organizing routes in Ktor</h1>&#13;
			<p>In this<a id="_idIndexMarker687"/> section, we'll see what the idiomatic approach in Ktor is for structuring multiple routes that belong to the same domain. </p>&#13;
			<p>Our current <strong class="source-inline">routing</strong> block looks like this:</p>&#13;
			<p class="source-code">routing {</p>&#13;
			<p class="source-code">    get("/status") {</p>&#13;
			<p class="source-code">        ...</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    post("/cats") {</p>&#13;
			<p class="source-code">        ...    </p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    get("/cats") {</p>&#13;
			<p class="source-code">        …</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    get("/cats/{id}") {</p>&#13;
			<p class="source-code">        ...    </p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>It would be good if we could extract all the routes that are related to cats into a separate file. Let's start by replacing all the cat routes with a function:</p>&#13;
			<p class="source-code">routing { </p>&#13;
			<p class="source-code">    get("/status") { </p>&#13;
			<p class="source-code">        ... </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">    cats() </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If you are using IntelliJ IDEA, it will even suggest that you generate an extension function on the <strong class="source-inline">Routing</strong> class:</p>&#13;
			<p class="source-code">fun Routing.cats() {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, we can move all our cat routes to this function:</p>&#13;
			<p class="source-code">fun Routing.cats() {</p>&#13;
			<p class="source-code">    post("/cats") {</p>&#13;
			<p class="source-code">        ...</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    get("/cats") {</p>&#13;
			<p class="source-code">        ...</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    get("/cats/{id}") {</p>&#13;
			<p class="source-code">        ...</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, you can see <a id="_idIndexMarker688"/>that the <strong class="source-inline">/cats</strong> URL is repeated many times. We can lift it using the <strong class="source-inline">route()</strong> block:</p>&#13;
			<div>&#13;
				<div id="_idContainer026" class="IMG---Figure">&#13;
					<img src="Images/Table.jpg" alt="Table 10.1 - Cleaner code after using the route() block&#13;&#10;" width="1491" height="787"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Table 10.1 - Cleaner code after using the route() block</p>&#13;
			<p>Notice how much cleaner our code has become now. </p>&#13;
			<p>Now, there's one last important topic for us to cover. At the beginning of this chapter, we mentioned that<a id="_idIndexMarker689"/> Ktor is a highly concurrent framework. And in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>, we said that concurrency in Kotlin is mainly achieved by using coroutines. But we have started a single coroutine in this chapter. We'll look at this in the next section.</p>&#13;
			<h1 id="_idParaDest-242"><a id="_idTextAnchor248"/>Achieving concurrency in Ktor</h1>&#13;
			<p>Looking back at<a id="_idIndexMarker690"/> the code we've written in this chapter, you may be under the impression that the Ktor code is not concurrent at all. However, this couldn't be further from the truth. </p>&#13;
			<p>All the Ktor functions we've used in this chapter are based on coroutines and the concept<a id="_idIndexMarker691"/> of <strong class="bold">suspending functions</strong>. </p>&#13;
			<p>For every incoming request, Ktor will start a new coroutine that will handle it, thanks to the CIO server engine, which is based on coroutines at its core. Having a concurrency model that is performant but not obtrusive is a very important principle in Ktor.</p>&#13;
			<p>In addition, the <strong class="source-inline">routing</strong> blocks we used to specify all our endpoints have access to <strong class="source-inline">CoroutineScope</strong>, meaning that we can invoke suspending functions within those blocks.</p>&#13;
			<p>One of the examples for such a suspending function is <strong class="source-inline">call.respond()</strong>, which we were using throughout this chapter. Suspending functions provide our application with opportunities to context switch, and to execute other code concurrently. This means that the same number of resources can serve far more requests than they would be able to otherwise. We'll<a id="_idIndexMarker692"/> stop here and summarize what we've learned about developing applications using Ktor. </p>&#13;
			<h1 id="_idParaDest-243"><a id="_idTextAnchor249"/>Summary</h1>&#13;
			<p>In this chapter, we have built a well-tested service using Kotlin that uses the Ktor framework to store entities in the database. We've also discussed how the multiple design patterns that we encountered at the beginning of this book, such as Factory, Singleton, and Bridge, are used in the Ktor framework to provide a flexible structure for our code. </p>&#13;
			<p>Now, you should be able to interact with the database using the Exposed framework. We've learned how we can declare, create, and drop tables, how to insert new entities, and how to fetch and delete them.</p>&#13;
			<p>In the next chapter, we'll look at an alternative approach to developing web applications, but this time using a Reactive framework called <strong class="bold">Vert.x</strong>. This will allow us to compare the concurrent and Reactive approaches for developing web applications and discuss the tradeoffs of each of the approaches.</p>&#13;
			<h1 id="_idParaDest-244"><a id="_idTextAnchor250"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How are the Ktor applications structured and what are their benefits?</li>&#13;
				<li>What are plugins in Ktor and what are they used for?</li>&#13;
				<li>What is the main problem that the Exposed library solves?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>