<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-231"><em class="italic"><a id="_idTextAnchor237"/>Chapter 10</em>: Concurrent Microservices with Ktor</h1>&#13;
			<p>In the previous chapter, we explored how we should write idiomatic Kotlin code that will be readable and maintainable, as well as performant.</p>&#13;
			<p>In this chapter, we'll put the skills we've learned so far to use by building a microservice using the <strong class="bold">Ktor framework</strong>. We also want this microservice to be reactive and to be as close to real life as possible. For that, we'll use the Ktor framework, the benefits of which we'll list in the first section of this chapter.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Getting started with Ktor</li>&#13;
				<li>Routing requests</li>&#13;
				<li>Testing the service</li>&#13;
				<li>Modularizing the application</li>&#13;
				<li>Connecting to a database</li>&#13;
				<li>Creating new entities</li>&#13;
				<li>Making the test consistent</li>&#13;
				<li>Fetching entities</li>&#13;
				<li>Organizing routes in Ktor</li>&#13;
				<li>Achieving concurrency in Ktor</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you'll have a microservice written in Kotlin that is well tested and can read data from a PostgreSQL database and store data in it.</p>&#13;
			<h1 id="_idParaDest-232"><a id="_idTextAnchor238"/>Technical requirements</h1>&#13;
			<p>This is what you'll need to get started:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">JDK 11</strong> or later</li>&#13;
				<li>IntelliJ IDEA</li>&#13;
				<li><strong class="bold">Gradle 6.8</strong> or later</li>&#13;
				<li><strong class="bold">PostgreSQL 14</strong> or later</li>&#13;
			</ul>&#13;
			<p>This chapter will assume that you have <code>PostgreSQL</code> already installed and that you have the basic knowledge for working with it. If you don't, please refer to the official documentation: <a href="https://www.postgresql.org/docs/14/tutorial-install.html">https://www.postgresql.org/docs/14/tutorial-install.html</a>.</p>&#13;
			<p>You can find the source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10</a>.</p>&#13;
			<h1 id="_idParaDest-233"><a id="_idTextAnchor239"/>Getting started with Ktor</h1>&#13;
			<p>You're probably<a id="_idIndexMarker654"/> tired of creating to-do or shopping lists.</p>&#13;
			<p>So, instead, in this chapter, the microservice will be for a <code>cat shelter</code>. The microservice should be able to do the following:</p>&#13;
			<ul>&#13;
				<li>Supply an endpoint we can ping to check whether the service is up and running</li>&#13;
				<li>List the cats currently in the shelter</li>&#13;
				<li>Provide us with a means to add new cats</li>&#13;
			</ul>&#13;
			<p>The framework we'll be using for our microservice in this<a id="_idIndexMarker655"/> chapter is called <strong class="bold">Ktor</strong>. It's a concurrent framework that's developed and maintained by the creators of the Kotlin programming language.</p>&#13;
			<p>Let's start by creating a new Kotlin Gradle project:</p>&#13;
			<ol>&#13;
				<li>From your IntelliJ IDEA, select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong> and choose <strong class="bold">Kotlin</strong> from <strong class="bold">New Project</strong> and <strong class="bold">Gradle Kotlin</strong> as your <strong class="bold">Build System</strong>.</li>&#13;
				<li>Give your project a descriptive name – <code>CatsHostel</code>, in my case – and choose <strong class="bold">Project JDK</strong> (in this case, we are using <strong class="bold">JDK 15</strong>):<div><img src="img/Figure_10.1_B17816.jpg" alt="Figure 10.1 – Selecting the Project JDK type&#13;&#10;" width="1100" height="791"/></p><p class="figure-caption">Figure 10.1 – Selecting the Project JDK type</p></li>&#13;
				<li>On the next<a id="_idIndexMarker656"/> screen, select <strong class="bold">JUnit 5</strong> as your <strong class="bold">Test framework</strong> and set <strong class="bold">Target JVM version</strong> to <strong class="bold">1.8</strong>. Then, click <strong class="bold">Finish</strong>:<div><img src="img/Figure_10.2_B17816.jpg" alt="Figure 10.2 – Selecting Test framework and Target JVM version&#13;&#10;" width="980" height="330"/></div><p class="figure-caption">Figure 10.2 – Selecting Test framework and Target JVM version</p></li>&#13;
				<li>Now, you should see the following structure:</li>&#13;
			</ol>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/Figure_10.3_B17816.jpg" alt="Figure 10.3 – Project structure&#13;&#10;" width="539" height="516"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 10.3 – Project structure</p>&#13;
			<p>Next, let's<a id="_idIndexMarker657"/> open <code>build.gradle.kts</code>. This file controls how your project is built, its dependencies, and the libraries that the project is going to use. Depending on the version of your IntelliJ IDEA, the file's contents may differ a bit, but the general structure stays the same. </p>&#13;
			<p>The <code>.kts</code> extension means that the configuration file for our Kotlin project is written in Kotlin, or to be precise, in <code>dependencies</code> block, which should look like this:</p>&#13;
			<pre>dependencies {</pre>&#13;
			<pre>    implementation(...)</pre>&#13;
			<pre>    testImplementation("org.junit.jupiter:junit-jupiter-        api:5.6.0")</pre>&#13;
			<pre>    testRuntimeOnly("org.junit.jupiter:junit-jupiter-        engine:5.6.0")</pre>&#13;
			<pre>    </pre>&#13;
			<pre>}</pre>&#13;
			<p>The preceding code mentions all the libraries that your project will be using. The <code>implementation()</code> configuration means that the library will be used at all times. The <code>testImplementation()</code> configuration means that the library will only be used during tests.</p>&#13;
			<p>Now, let's take a look at how a library is defined in the following example:</p>&#13;
			<pre>"org.junit.jupiter:junit-jupiter-api:5.6.0"</pre>&#13;
			<p>This is a regular string that has been separated into three parts, as follows:</p>&#13;
			<pre>"group:name:version"</pre>&#13;
			<p>The <code>group</code> and <code>name</code> strings<a id="_idIndexMarker658"/> identify the library; the <code>version</code> configuration should be self-explanatory.</p>&#13;
			<p>Now, let's modify the <code>dependencies</code> block, as follows:</p>&#13;
			<pre>val ktorVersion = "1.6.0"</pre>&#13;
			<pre>dependencies {</pre>&#13;
			<pre>    implementation("io.ktor:ktor-server-</pre>&#13;
			<pre>        netty:$ktorVersion")</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Since the files with <code>.kts</code> extensions are Kotlin files, we can use regular Kotlin syntax in them. In this case, we are using values and string interpolation to extract the version of our library.</p>&#13;
			<p>The latest version of Ktor to date is <strong class="bold">1.6.4</strong>, but when you read this book, it will be greater than this. You can find the <a id="_idIndexMarker659"/>latest version here: <a href="https://ktor.io/">https://ktor.io/</a>.</p>&#13;
			<p>As a general rule, all Ktor libraries should be the same version and that's when the variable becomes useful.</p>&#13;
			<p class="callout-heading">Tip:</p>&#13;
			<p class="callout">If you have followed the steps from the beginning of this section, you should have a file called <code>server.kt</code> in the <code>src/main/kotlin</code> folder in your project. If you don't, create one now.</p>&#13;
			<p>Now, let's add<a id="_idIndexMarker660"/> the following content to the <code>server.kt</code> file:</p>&#13;
			<pre>fun main() {</pre>&#13;
			<pre>    embeddedServer(Netty, port = 8080) {</pre>&#13;
			<pre>        routing {</pre>&#13;
			<pre>            get("/") {</pre>&#13;
			<pre>                call.respondText("OK")</pre>&#13;
			<pre>            }</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }.start(wait = true)</pre>&#13;
			<pre>    println("open http://localhost:8080")</pre>&#13;
			<pre>}</pre>&#13;
			<p>That's all the code we need to write to start a web server that will respond with <code>OK</code> when you open <code>http://localhost:8080</code> in your browser. </p>&#13;
			<p>Now, let's understand what happens here:</p>&#13;
			<ul>&#13;
				<li>To interact with the request and return a response, we can use the <code>call</code> object, also known <a id="_idIndexMarker661"/>as the <strong class="bold">context</strong>. This object provides all the convenient methods for parsing requests and returning responses in different formats, and we'll see the different methods available for it throughout this chapter.</li>&#13;
				<li>The <code>embeddedServer()</code> function is an implementation of the Builder pattern, which we discussed in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. It allows us to configure our server. Most of the arguments have the same defaults. We override <code>port</code> to <code>8080</code> just for convenience. </li>&#13;
				<li>We specify the <code>wait</code> argument to be <code>true</code> so that our server will wait for incoming requests.</li>&#13;
				<li>The only mandatory argument to the <code>embeddedServer</code> function is the server engine. In our example, we use <code>Netty</code>, which is a very well-known JVM library, but there are others as well. The most interesting of them is <code>CIO</code>, which was developed by JetBrains themselves. </li>&#13;
			</ul>&#13;
			<p>Now, let's understand what <code>CIO</code> and <code>Netty</code> are. They are both <strong class="bold">Factory</strong> patterns that create the actual instance of our server when invoked. This is a really interesting combination of different design patterns in one place to create a very flexible and extensible architecture.</p>&#13;
			<p>To switch to <a id="_idIndexMarker662"/>using <code>CIO</code>, all we need to do is add a new dependency:</p>&#13;
			<pre>dependencies { </pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>    implementation("io.ktor:ktor-server-cio:$ktorVersion") </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Then, we need to pass another server engine, <code>CIO</code>, to our <code>embeddedServer</code> function:</p>&#13;
			<pre>embeddedServer(CIO, port = 8080) { </pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}.start(wait = true)</pre>&#13;
			<p>Notice that we didn't have to change anything else in our code when we switched the server engine. That is because <code>embeddedServer()</code> uses the Bridge design pattern to make components interchangeable. </p>&#13;
			<p>Now that our server has been started, let's investigate how we define different responses for each request to the server.</p>&#13;
			<h1 id="_idParaDest-234"><a id="_idTextAnchor240"/>Routing requests</h1>&#13;
			<p>Now, let's take<a id="_idIndexMarker663"/> a look at the <code>routing</code> block:</p>&#13;
			<pre>routing { </pre>&#13;
			<pre>    get("/") { </pre>&#13;
			<pre>        call.respondText("OK") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>This block describes all the URLs that will be handled by our server. In this case, we only handle the root URL. When that URL is requested, a text response, <code>OK</code>, will be returned to the user.</p>&#13;
			<p>The following code returns a text response. Now, let's see how we can return a JSON response instead:</p>&#13;
			<pre>get("/status") {</pre>&#13;
			<pre>    call.respond(mapOf("status" to "OK"))</pre>&#13;
			<pre>}</pre>&#13;
			<p>Instead of using the <code>respondText()</code> method, we'll use <code>respond()</code>, which receives an object instead of a string. In our example, we're passing a map of strings to the <code>respond()</code> function. If we run this code, though, we'll get an exception.</p>&#13;
			<p>This is because, by default, objects are not serialized into JSON. Multiple libraries can do this for us. In this example, we'll use the <code>kotlinx-serialization</code> library. Let's start by adding it to our dependencies:</p>&#13;
			<pre>dependencies {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>    implementation("org.jetbrains.kotlinx:kotlinx-        serialization-json-jvm:1.3.0")</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Next, we need to add the following lines before our <code>routing</code> block:</p>&#13;
			<pre>install(ContentNegotiation) {</pre>&#13;
			<pre>    json()</pre>&#13;
			<pre>} </pre>&#13;
			<p>Now, if we run our code again, it will output this on our browser:</p>&#13;
			<pre>&gt; {"status":"OK"}</pre>&#13;
			<p>We've just created our first route, which returns an object serialized as JSON. Now, we can check whether our application works by opening <code>http://localhost:8080/status</code> in our browser. But that is a bit cumbersome. In the next section, we'll learn how to write a test <a id="_idIndexMarker664"/>for the <code>/status</code> endpoint.</p>&#13;
			<h1 id="_idParaDest-235"><a id="_idTextAnchor241"/>Testing the service</h1>&#13;
			<p>To write our first <a id="_idIndexMarker665"/>test, let's create a new file called <code>ServerTest.kt</code> under the <code>src/test/kotlin</code> directory.</p>&#13;
			<p>Now, let's add a new dependency:</p>&#13;
			<pre>dependencies {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>    testImplementation("io.ktor:ktor-server-</pre>&#13;
			<pre>        tests:$ktorVersion")</pre>&#13;
			<pre>}</pre>&#13;
			<p>Next, let's add the following contents to our <code>ServerTest.kt</code> file:</p>&#13;
			<pre>internal class ServerTest {</pre>&#13;
			<pre>    @Test</pre>&#13;
			<pre>    fun testStatus() {</pre>&#13;
			<pre>        withTestApplication {</pre>&#13;
			<pre>            val response = handleRequest(HttpMethod.Get,                 "/status").response</pre>&#13;
			<pre>            assertEquals(HttpStatusCode.OK,                 response.status())</pre>&#13;
			<pre>            assertEquals("""{"status": "OK"}""",                 response.content)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Tests in Kotlin are grouped into classes, and each test is a method in the class, which is marked with the <code>@Test</code> annotation. </p>&#13;
			<p>Inside the <code>test</code> method, we start a test server, issue a <code>GET</code> request to the <code>/status</code> endpoint, and check that the endpoint responds with a correct status code and JSON body.</p>&#13;
			<p>If you run this test <a id="_idIndexMarker666"/>now, though, it will fail, because we haven't started our server yet. To do so, we'll need to refactor it a bit, which we'll do in the next section.</p>&#13;
			<h1 id="_idParaDest-236"><a id="_idTextAnchor242"/>Modularizing the application</h1>&#13;
			<p>So far, our server<a id="_idIndexMarker667"/> has been started from the <code>main()</code> function. This was simple to set up, but this doesn't allow us to test our application. </p>&#13;
			<p>In Ktor, the code is usually organized into modules. Let's rewrite our <code>main</code> function, as follows:</p>&#13;
			<pre>fun main() {</pre>&#13;
			<pre>    embeddedServer(</pre>&#13;
			<pre>        CIO,</pre>&#13;
			<pre>        port = 8080,</pre>&#13;
			<pre>        module = Application::mainModule</pre>&#13;
			<pre>    ).start(wait = true)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, instead of providing the logic of our server within a block, we specified a module that will contain all the configurations for our server.</p>&#13;
			<p>This module is <a id="_idIndexMarker668"/>defined as an extension function on the <code>Application</code> object:</p>&#13;
			<pre>fun Application.mainModule() {</pre>&#13;
			<pre>    install(ContentNegotiation) {</pre>&#13;
			<pre>        json()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    routing {</pre>&#13;
			<pre>        get("/status") {</pre>&#13;
			<pre>            call.respond(mapOf("status" to "OK"))</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    println("open http://localhost:8080")</pre>&#13;
			<pre>}</pre>&#13;
			<p>As you can see, the content of this function is the same as that of the block that we passed to our <code>embeddedService</code> function earlier.</p>&#13;
			<p>Now, all we need to do is go back to our test and specify which module we would like to test:</p>&#13;
			<pre>@Test</pre>&#13;
			<pre>fun testStatus() {</pre>&#13;
			<pre>    withTestApplication(<strong class="bold">Application::mainModule</strong>) {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>If you run this test now, it should pass, because our server has started properly in test mode. </p>&#13;
			<p>So far, we've only dealt with the infrastructure of our service; we haven't touched on its business logic: <em class="italic">managing cats</em>. To do so, we'll need a database. In the next section, we'll discuss <a id="_idIndexMarker669"/>how Ktor solves this problem using the Exposed library.</p>&#13;
			<h1 id="_idParaDest-237"><a id="_idTextAnchor243"/>Connecting to a database</h1>&#13;
			<p>To store and <a id="_idIndexMarker670"/>retrieve cats, we'll need to connect to a database. We'll use PostgreSQL for that purpose, although using another SQL database won't be any different.</p>&#13;
			<p>First, we'll need a new library to connect to the database. We'll use the Exposed library, which is also developed by JetBrains. </p>&#13;
			<p>Let's add the following dependency to our <code>build.gradle.kts</code> file:</p>&#13;
			<pre>dependencies {</pre>&#13;
			<pre>    implementation("org.jetbrains.exposed:exposed:0.17.14")</pre>&#13;
			<pre>    implementation("org.postgresql:postgresql:42.2.24")</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Once the libraries are in place, we need to connect to them. To do that, let's create a new file called <code>DB.kt</code> under <code>/src/main/kotlin</code> with the following contents:</p>&#13;
			<pre>object DB {</pre>&#13;
			<pre>    private val host=System.getenv("DB_HOST")?:"localhost"</pre>&#13;
			<pre>    private val port =         System.getenv("DB_PORT")?.toIntOrNull() ?: 5432</pre>&#13;
			<pre>    private val dbName = System.getenv("DB_NAME") ?:         "cats_db"</pre>&#13;
			<pre>    private val dbUser = System.getenv("DB_USER") ?:         "cats_admin"</pre>&#13;
			<pre>    private val dbPassword = System.getenv("DB_PASSWORD")         ?: "abcd1234"</pre>&#13;
			<pre>  fun connect() = Database.connect(      "jdbc:postgresql://$host:$port/$dbName",      driver = "org.postgresql.Driver",      user = dbUser,      password = dbPassword</pre>&#13;
			<pre>  )</pre>&#13;
			<pre>}</pre>&#13;
			<p>Since our application needs exactly one instance of a database, the <code>DB</code> object can use the Singleton pattern, which we discussed in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. For that, we will use the <code>object</code> keyword.</p>&#13;
			<p>Then, for each of <a id="_idIndexMarker671"/>the variables that we need to connect to the database, we will attempt to read them from our environment. If the <code>environment</code> variable is not set, we will use a default value using the <strong class="bold">Elvis</strong> operator. </p>&#13;
			<p class="callout-heading">Tip:</p>&#13;
			<p class="callout">Creating a database and a user is beyond the scope of this book, but you can refer to the official documentation for this, at <a href="https://www.postgresql.org/docs/14/app-createuser.html">https://www.postgresql.org/docs/14/app-createuser.html</a> and <a href="https://www.postgresql.org/docs/14/app-createdb.html">https://www.postgresql.org/docs/14/app-createdb.html</a>.</p>&#13;
			<p>Alternatively, you can simply run the following two commands in your command line:</p>&#13;
			<pre>$ createuser cats_admin -W –d</pre>&#13;
			<pre>$ createdb cats_db -U cats_admin</pre>&#13;
			<p>The first command creates a database user called <code>cats_admin</code> and asks you to specify a password for this user. Our application will use this <code>cats_admin</code> user to interact with the database. The second command creates a database called <code>cats_db</code> that belongs to the <code>cats_admin</code> user. Now that our database has been created, all we need to do is create a table that will store our cats in it.</p>&#13;
			<p>For that, let's define another Singleton object in our <code>DB.kt</code> file that will represent a table:</p>&#13;
			<pre>object CatsTable : IntIdTable() {</pre>&#13;
			<pre>    val name = varchar("name", 20).uniqueIndex()</pre>&#13;
			<pre>    val age = integer("age").default(0)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Let's understand what the preceding definition means:</p>&#13;
			<ul>&#13;
				<li><code>IntIdTable</code> means that we want to create a table with a primary key of the <code>Int</code> type.</li>&#13;
				<li>In the body<a id="_idIndexMarker672"/> of our object, we define the columns. In addition to the <code>ID</code> column, we'll have a <code>name</code> column that is of the <code>varchar</code> type, or in other words, a string, and is <code>20</code> characters at the most.</li>&#13;
				<li>The cat's <code>name</code> column is also unique, meaning that no two cats can have the same name.</li>&#13;
				<li>We also have a third column that is of the <code>integer</code> type, or <code>Int</code> in Kotlin terms, and is defaulted to <code>0</code>.</li>&#13;
			</ul>&#13;
			<p>We'll also have a <code>data</code> class to represent a single cat:</p>&#13;
			<pre>data class Cat(val id: Int,</pre>&#13;
			<pre>               val name: String,</pre>&#13;
			<pre>               val age: Int)</pre>&#13;
			<p>The only thing that is left for us to do is add the following lines of code to our <code>mainModule()</code> function:</p>&#13;
			<pre>DB.connect()</pre>&#13;
			<pre>transaction {</pre>&#13;
			<pre>    SchemaUtils.create(CatsTable)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Each time our application starts, the preceding code will connect to the database. Then, it will attempt to create a table that stores our entities. If a table already exists, nothing will happen. </p>&#13;
			<p>Now that we<a id="_idIndexMarker673"/> have established a connection to our database, let's examine how we can use this connection to store a few cats in it.</p>&#13;
			<h1 id="_idParaDest-238"><a id="_idTextAnchor244"/>Creating new entities</h1>&#13;
			<p>Our next task is <a id="_idIndexMarker674"/>adding the first cat to our virtual shelter. </p>&#13;
			<p>Following the REST principles, it should be a <code>POST</code> request, where the body of the request may look something like this: </p>&#13;
			<pre>{"name": "Meatloaf", "age": 4}</pre>&#13;
			<p>We'll start by writing a new test:</p>&#13;
			<pre>@Test</pre>&#13;
			<pre>fun `POST creates a new cat`() {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Backticks are a useful Kotlin feature that allows us to have spaces in the names of our functions. This helps us create descriptive test names.</p>&#13;
			<p>Next, let's look at the body of our test:</p>&#13;
			<pre>withTestApplication(Application::mainModule) {</pre>&#13;
			<pre>    val response = handleRequest(HttpMethod.Post, "/cats") {</pre>&#13;
			<pre>        addHeader(</pre>&#13;
			<pre>          HttpHeaders.ContentType,</pre>&#13;
			<pre>          ContentType.Application.FormUrlEncoded.toString()</pre>&#13;
			<pre>        )</pre>&#13;
			<pre>        setBody(</pre>&#13;
			<pre>            listOf(</pre>&#13;
			<pre>                "name" to "Meatloaf",</pre>&#13;
			<pre>                "age" to 4.toString()</pre>&#13;
			<pre>            ).formUrlEncode()</pre>&#13;
			<pre>        )</pre>&#13;
			<pre>    }.response</pre>&#13;
			<pre>    assertEquals(HttpStatusCode.Created, response.status())</pre>&#13;
			<pre>}</pre>&#13;
			<p>We discussed the <code>withTestApplication</code> and <code>handleRequest</code> functions in the previous section. This time, we are using a <code>POST</code> request. These types of requests should have the correct header, so we must set those headers using the <code>addHeader()</code> function. We must also set the body to the contents discussed previously. </p>&#13;
			<p>Finally, we must <a id="_idIndexMarker675"/>check whether the response header is set to the <code>Created</code> HTTP code.</p>&#13;
			<p>If we run this test now, it will fail with an HTTP code of <code>404</code> since we haven't implemented the <code>post</code> <code>/cats</code> endpoint yet. </p>&#13;
			<p>Let's go back to our <code>routing</code> block and add a new endpoint:</p>&#13;
			<pre>post("/cats") {</pre>&#13;
			<pre>    ...    </pre>&#13;
			<pre>    call.respond(HttpStatusCode.Created)</pre>&#13;
			<pre>}</pre>&#13;
			<p>To create a new cat, we'll need to read the body of the <code>POST</code> request. We'll use the <code>receiveParameters()</code> function for this:</p>&#13;
			<pre>val parameters = call.receiveParameters()</pre>&#13;
			<pre>val name = requireNotNull(parameters["name"])</pre>&#13;
			<pre>val age = parameters["age"]?.toInt() ?: 0</pre>&#13;
			<p>The <code>receiveParameters</code> function returns a case-insensitive map. First, we will attempt to fetch the cat's <code>name</code> from this map, and if there's no name in the request, we will fail the call. This will be handled by Ktor.</p>&#13;
			<p>Then, if we didn't receive <code>age</code>, we will default it to <code>0</code> using the Elvis operator.</p>&#13;
			<p>Now, we must insert those values into the database:</p>&#13;
			<pre>transaction {</pre>&#13;
			<pre>    CatsTable.insert { cat -&gt;</pre>&#13;
			<pre>        cat[CatsTable.name] = name</pre>&#13;
			<pre>        cat[CatsTable.age] = age</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we open a <code>transaction</code> block to make changes to the database. Then, we use the <code>insert()</code> method, which is available on every table. Inside the <code>insert</code> lambda, the <code>cat</code> variable refers to the new row we are going to populate. We set the name of that row to the value of the <code>name</code> parameter and do the same for <code>age</code>.</p>&#13;
			<p>If you run your test now, it should pass. But if you run it again, it will fail. That's because the name of a cat in the database is unique. Also, we don't clean the database between test runs. So, the<a id="_idIndexMarker676"/> first run creates a cat named <code>Meatloaf</code>, while the second run fails. This is because such a cat already exists. </p>&#13;
			<p>To make our tests consistent, we need a way to clean our database between runs.</p>&#13;
			<h1 id="_idParaDest-239"><a id="_idTextAnchor245"/>Making the tests consistent</h1>&#13;
			<p>Let's go <a id="_idIndexMarker677"/>back to our test and add the following piece of code:</p>&#13;
			<pre>@BeforeEach</pre>&#13;
			<pre>fun setup() {</pre>&#13;
			<pre>    DB.connect()</pre>&#13;
			<pre>    transaction {</pre>&#13;
			<pre>        SchemaUtils.drop(CatsTable)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we are using the <code>@BeforeEach</code> annotation on a function. As its name suggests, this code will run before each test. The function will establish a connection to the database and drop the table completely. Then, our application will recreate the table.</p>&#13;
			<p>Now, our tests should pass consistently. In the next section, we'll learn how to fetch a cat from the<a id="_idIndexMarker678"/> database using the Exposed library.</p>&#13;
			<h1 id="_idParaDest-240"><a id="_idTextAnchor246"/>Fetching entities</h1>&#13;
			<p>Following the REST <a id="_idIndexMarker679"/>practices, the URL for fetching all cats should be <code>/cats</code>, while for fetching a single cat, it should be <code>/cats/123</code>, where <code>123</code> is the ID of the cat we are trying to fetch.</p>&#13;
			<p>Let's add two new routes for that:</p>&#13;
			<pre>get("/cats") {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<pre>get("/cats/{id}") {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>The first route is very similar to the <code>/status</code> route we introduced earlier in this chapter. But the second round is slightly different: it uses a query parameter in the URL. You can recognize query parameters by the curly brackets around their name.</p>&#13;
			<p>To read a query parameter, we can access the <code>parameters</code> map:</p>&#13;
			<pre>val id = requireNotNull(call.parameters["id"]).toInt()</pre>&#13;
			<p>If there is an ID on the URL, we need to try and fetch a cat from the database:</p>&#13;
			<pre>val cat = transaction {</pre>&#13;
			<pre>    CatsTable.select {</pre>&#13;
			<pre>        CatsTable.id.eq(id)</pre>&#13;
			<pre>    }.firstOrNull()</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we open a transaction and use the <code>select</code> statement to get a cat with an ID equal to what we were provided previously.</p>&#13;
			<p>If an object was returned, we would convert it into JSON. Otherwise, we would return an HTTP <a id="_idIndexMarker680"/>code of <code>404</code>, <code>Not Found</code>:</p>&#13;
			<pre>if (row == null) {</pre>&#13;
			<pre>    call.respond(HttpStatusCode.NotFound)</pre>&#13;
			<pre>} else {</pre>&#13;
			<pre>    call.respond(</pre>&#13;
			<pre>        Cat(</pre>&#13;
			<pre>            row[CatsTable.id].value,</pre>&#13;
			<pre>            row[CatsTable.name],</pre>&#13;
			<pre>            row[CatsTable.age]</pre>&#13;
			<pre>        )</pre>&#13;
			<pre>    )</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, let's add a test for fetching a single cat as well:</p>&#13;
			<pre>@Test</pre>&#13;
			<pre>fun `GET with ID fetches a single cat`() {</pre>&#13;
			<pre>    withTestApplication(Application::mainModule) {</pre>&#13;
			<pre>        val id = transaction {</pre>&#13;
			<pre>            CatsTable.<strong class="bold">insertAndGetId </strong>{ cat -&gt;</pre>&#13;
			<pre>                cat[name] = "Fluffy"</pre>&#13;
			<pre>            }</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>         val response = handleRequest(HttpMethod.Get, </pre>&#13;
			<pre>            "/cats/$id").response</pre>&#13;
			<pre>        assertEquals("""{"id":1,"name":</pre>&#13;
			<pre>            "Fluffy","age":0}""", response.content)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>In this test, we create a cat using Exposed. Here, we're using a new method called <code>insertAndGetId</code>. As its name suggests, it will return the ID of a newly created row. Then, we try to fetch that cat using our newly created endpoint.</p>&#13;
			<p>If we try to run this test, though, it will fail with the following exception:</p>&#13;
			<pre>&gt; Serializer for class 'Cat' is not found.</pre>&#13;
			<p>By default, Ktor<a id="_idIndexMarker681"/> doesn't know how to turn our custom data class into JSON. To fix that, we'll need to add a new plugin to our <code>build.gradle.kts</code> file:</p>&#13;
			<pre>plugins {</pre>&#13;
			<pre>    kotlin("jvm") version "1.5.10"</pre>&#13;
			<pre>    application</pre>&#13;
			<pre>    <strong class="bold">kotlin("plugin.serialization") version "1.5.10"</strong></pre>&#13;
			<pre>}</pre>&#13;
			<p>This plugin will create serializers at compile time for any class marked with the <code>@Serializable</code> annotation. All we need to do now for the test to pass is add that annotation to our <code>Cat</code> class:</p>&#13;
			<pre>@Serializable</pre>&#13;
			<pre>data class Cat(</pre>&#13;
			<pre>    val id: Int,</pre>&#13;
			<pre>    val name: String,</pre>&#13;
			<pre>    val age: Int</pre>&#13;
			<pre>)</pre>&#13;
			<p>That's it; now, our test for fetching a cat by its ID should pass. </p>&#13;
			<p>Finally, we would like to be able to fetch all the cats from the database. To do that, we must change<a id="_idIndexMarker682"/> our test setup a little:</p>&#13;
			<pre>@TestInstance(TestInstance.Lifecycle.PER_CLASS)</pre>&#13;
			<pre>class ServerTest {</pre>&#13;
			<pre>    @BeforeAll</pre>&#13;
			<pre>    fun setup() {</pre>&#13;
			<pre>        DB.connect()</pre>&#13;
			<pre>        transaction {</pre>&#13;
			<pre>            SchemaUtils.create(CatsTable)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    @AfterAll</pre>&#13;
			<pre>    fun cleanup() {</pre>&#13;
			<pre>        DB.connect()</pre>&#13;
			<pre>        transaction {</pre>&#13;
			<pre>            SchemaUtils.drop(CatsTable)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we changed the setup of our test to drop the table once all the tests have been executed. So, instead of the <code>@BeforeEach</code> annotation, which executes the function before each test, we use the <code>@AfterAll</code> annotation, which executes the function after all tests have been executed.</p>&#13;
			<p>For this annotation to work, we also need to add the <code>@TestInstance</code> annotation to our class. The default for that is <code>PER_METHOD</code>, but since we want to execute multiple tests at once, and then clean up after, we need to set the life cycle of our test class to <code>PER_CLASS</code>.</p>&#13;
			<p>Next, let's wrap our test into a nested class, like this:</p>&#13;
			<pre>@Nested</pre>&#13;
			<pre>inner class `With cat in DB` {</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    @Test</pre>&#13;
			<pre>    fun `GET with ID fetches a single cat`() {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Nested test <a id="_idIndexMarker683"/>classes are a great way to encapsulate specific test situations. In our case, we would like to run two tests when there is a cat in our database already. </p>&#13;
			<p>Now, let's add the following setup code to our nested test:</p>&#13;
			<pre>lateinit var id: EntityID&lt;Int&gt;</pre>&#13;
			<pre>@BeforeEach</pre>&#13;
			<pre>fun setup() {</pre>&#13;
			<pre>    DB.connect()</pre>&#13;
			<pre>    id = transaction {</pre>&#13;
			<pre>        CatsTable.insertAndGetId { cat -&gt;</pre>&#13;
			<pre>            cat[name] = "Fluffy"</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>@AfterEach</pre>&#13;
			<pre>fun teardown() {</pre>&#13;
			<pre>    DB.connect()</pre>&#13;
			<pre>    transaction {</pre>&#13;
			<pre>        CatsTable.deleteAll()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Before we execute each test in this nested class, we will create a cat in the database and after each test, we will delete all the cats from our database. Since we would like to keep track of the ID of the cat that we create, we will store it in a variable.</p>&#13;
			<p>Now, our test<a id="_idIndexMarker684"/> class for fetching a single entity looks like this:</p>&#13;
			<pre>@Test</pre>&#13;
			<pre>fun `GET with ID fetches a single cat`() {</pre>&#13;
			<pre>    withTestApplication(Application::mainModule) {</pre>&#13;
			<pre>        val response = handleRequest(HttpMethod.Get,             "/cats/$id").response         assertEquals("""{<strong class="bold">"id":$id,</strong>"name":"Fluffy",            "age":0}""", response.content)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Notice that we interpolate the cat's ID into our expected response since it will change with each test execution.</p>&#13;
			<p>The test for fetching all the cats from the database will look almost the same:</p>&#13;
			<pre>@Test</pre>&#13;
			<pre>fun `GET without ID fetches all cats`() {</pre>&#13;
			<pre>    withTestApplication(Application::mainModule) {</pre>&#13;
			<pre>        val response = handleRequest(HttpMethod.Get,             <strong class="bold">"/cats"</strong>).response         assertEquals("""<strong class="bold">[</strong>{"id":$id,"name":"Fluffy",            "age":0}<strong class="bold">]</strong>""", response.content)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>We just don't specify the ID, and the response is wrapped into a JSON array, as you can see by the square brackets around it.</p>&#13;
			<p>Now, all we<a id="_idIndexMarker685"/> need to do is implement this new route:</p>&#13;
			<pre>get("/cats") {</pre>&#13;
			<pre>    val cats = transaction {</pre>&#13;
			<pre>        CatsTable.selectAll().map { row -&gt;</pre>&#13;
			<pre>            Cat(</pre>&#13;
			<pre>                row[CatsTable.id].value,</pre>&#13;
			<pre>                row[CatsTable.name],</pre>&#13;
			<pre>                row[CatsTable.age]</pre>&#13;
			<pre>            )</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    call.respond(cats)</pre>&#13;
			<pre>}</pre>&#13;
			<p>If you followed the example for fetching a single entity from the database (from the beginning of this section), then this example won't be very different for you. We use the <code>selectAll()</code> function to fetch all the rows from the table. Then, we map each row to our <code>data</code> class. The only problem that is left for us to solve is that our code is quite messy and resides in a single file. It would be better if we split all the cat routes into a separate file. We'll<a id="_idIndexMarker686"/> do that in the next section.</p>&#13;
			<h1 id="_idParaDest-241"><a id="_idTextAnchor247"/>Organizing routes in Ktor</h1>&#13;
			<p>In this<a id="_idIndexMarker687"/> section, we'll see what the idiomatic approach in Ktor is for structuring multiple routes that belong to the same domain. </p>&#13;
			<p>Our current <code>routing</code> block looks like this:</p>&#13;
			<pre>routing {</pre>&#13;
			<pre>    get("/status") {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    post("/cats") {</pre>&#13;
			<pre>        ...    </pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    get("/cats") {</pre>&#13;
			<pre>        …</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    get("/cats/{id}") {</pre>&#13;
			<pre>        ...    </pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>It would be good if we could extract all the routes that are related to cats into a separate file. Let's start by replacing all the cat routes with a function:</p>&#13;
			<pre>routing { </pre>&#13;
			<pre>    get("/status") { </pre>&#13;
			<pre>        ... </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    cats() </pre>&#13;
			<pre>}</pre>&#13;
			<p>If you are using IntelliJ IDEA, it will even suggest that you generate an extension function on the <code>Routing</code> class:</p>&#13;
			<pre>fun Routing.cats() {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, we can move all our cat routes to this function:</p>&#13;
			<pre>fun Routing.cats() {</pre>&#13;
			<pre>    post("/cats") {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    get("/cats") {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    get("/cats/{id}") {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, you can see <a id="_idIndexMarker688"/>that the <code>/cats</code> URL is repeated many times. We can lift it using the <code>route()</code> block:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/Table.jpg" alt="Table 10.1 - Cleaner code after using the route() block&#13;&#10;" width="1491" height="787"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Table 10.1 - Cleaner code after using the route() block</p>&#13;
			<p>Notice how much cleaner our code has become now. </p>&#13;
			<p>Now, there's one last important topic for us to cover. At the beginning of this chapter, we mentioned that<a id="_idIndexMarker689"/> Ktor is a highly concurrent framework. And in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>, we said that concurrency in Kotlin is mainly achieved by using coroutines. But we have started a single coroutine in this chapter. We'll look at this in the next section.</p>&#13;
			<h1 id="_idParaDest-242"><a id="_idTextAnchor248"/>Achieving concurrency in Ktor</h1>&#13;
			<p>Looking back at<a id="_idIndexMarker690"/> the code we've written in this chapter, you may be under the impression that the Ktor code is not concurrent at all. However, this couldn't be further from the truth. </p>&#13;
			<p>All the Ktor functions we've used in this chapter are based on coroutines and the concept<a id="_idIndexMarker691"/> of <strong class="bold">suspending functions</strong>. </p>&#13;
			<p>For every incoming request, Ktor will start a new coroutine that will handle it, thanks to the CIO server engine, which is based on coroutines at its core. Having a concurrency model that is performant but not obtrusive is a very important principle in Ktor.</p>&#13;
			<p>In addition, the <code>routing</code> blocks we used to specify all our endpoints have access to <code>CoroutineScope</code>, meaning that we can invoke suspending functions within those blocks.</p>&#13;
			<p>One of the examples for such a suspending function is <code>call.respond()</code>, which we were using throughout this chapter. Suspending functions provide our application with opportunities to context switch, and to execute other code concurrently. This means that the same number of resources can serve far more requests than they would be able to otherwise. We'll<a id="_idIndexMarker692"/> stop here and summarize what we've learned about developing applications using Ktor. </p>&#13;
			<h1 id="_idParaDest-243"><a id="_idTextAnchor249"/>Summary</h1>&#13;
			<p>In this chapter, we have built a well-tested service using Kotlin that uses the Ktor framework to store entities in the database. We've also discussed how the multiple design patterns that we encountered at the beginning of this book, such as Factory, Singleton, and Bridge, are used in the Ktor framework to provide a flexible structure for our code. </p>&#13;
			<p>Now, you should be able to interact with the database using the Exposed framework. We've learned how we can declare, create, and drop tables, how to insert new entities, and how to fetch and delete them.</p>&#13;
			<p>In the next chapter, we'll look at an alternative approach to developing web applications, but this time using a Reactive framework called <strong class="bold">Vert.x</strong>. This will allow us to compare the concurrent and Reactive approaches for developing web applications and discuss the tradeoffs of each of the approaches.</p>&#13;
			<h1 id="_idParaDest-244"><a id="_idTextAnchor250"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How are the Ktor applications structured and what are their benefits?</li>&#13;
				<li>What are plugins in Ktor and what are they used for?</li>&#13;
				<li>What is the main problem that the Exposed library solves?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>