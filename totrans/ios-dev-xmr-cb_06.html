<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Web Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Web Services</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Consuming web services</li><li class="listitem" style="list-style-type: disc">Consuming REST services</li><li class="listitem" style="list-style-type: disc">Communicating with native APIs</li><li class="listitem" style="list-style-type: disc">Using WCF services</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Introduction</h1></div></div></div><p>Providing online information to the user is a crucial part of mobile development. In this chapter, we will discuss developing apps that communicate with web services to provide information. We will see how to consume and invoke web services based on SOAP. We will also discuss on how to use REST web services and how to parse the popular JSON data format from a web server. Last but not least, we will take a look at how to use the native iOS APIs for communication and also how to use WCF services.</p><p>All <a id="id394" class="indexterm"/>examples in this chapter use <span class="strong"><strong>XSP</strong></span>, a lightweight web server that is shipped with the Mono Framework; so, there is no need to have a live web service up and running online or locally to make use of the provided code.</p></div></div>
<div class="section" title="Consuming web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Consuming web services</h1></div></div></div><p>In this recipe, we <a id="id395" class="indexterm"/>will learn how to use a SOAP web service in a Xamarin.iOS project.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec210"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> project in Xamarin Studio and name it <code class="literal">WebServiceApp</code>. This chapter's code contains a web service project named <code class="literal">MTWebService</code>. This is the web service that will be used.</p><p>To use the <code class="literal">MTWebService</code> web service, we need a web server. Mono Framework provides us with the XSP lightweight web server for testing purposes. Open a terminal and type the following command to get to the web service's directory, replacing <code class="literal">&lt;code_directory&gt;</code> with the path the downloaded code is in:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd &lt;code_directory&gt;/CH06_code/MTWebService/MTWebService</strong></span>
</pre></div><p>Run the XSP web server by typing <code class="literal">xsp4</code> in the prompt. You will see an output that is similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>xsp4</strong></span>
<span class="strong"><strong>Listening on address: 0.0.0.0</strong></span>
<span class="strong"><strong>Root directory: /Users/dtavlikos/projects/CH06_code/MTWebService/MTWebService</strong></span>
<span class="strong"><strong>Listening on port: 8080 (non-secure)</strong></span>
<span class="strong"><strong>Hit Return to stop the server.</strong></span>
</pre></div><p>The web <a id="id396" class="indexterm"/>server is now up and running.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec211"/>How to do it...</h2></div></div></div><p>Perform the following steps to complete this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to add a reference to the web service in our project. Right-click on the project in the <span class="strong"><strong>Solution</strong></span> pad and navigate to <span class="strong"><strong>Add</strong></span> | <span class="strong"><strong>Add Web Reference</strong></span>. In the dialog box that will be shown, add <code class="literal">http://localhost:8080/MTTestWebService.asmx?wsdl</code> in the <span class="strong"><strong>Web Service Url</strong></span> field and click on the <span class="strong"><strong>Jump to</strong></span> button.</li><li class="listitem">Select <span class="strong"><strong>.NET 2.0 Web Services</strong></span> in the <span class="strong"><strong>Framework</strong></span> combo box.</li><li class="listitem">Set the <span class="strong"><strong>Reference</strong></span> field to <code class="literal">mtWebService</code>.</li><li class="listitem">With all the settings properly entered, the dialog box should look similar to the following screenshot. Click on the <span class="strong"><strong>OK</strong></span> button to add the web reference:<div class="mediaobject"><img src="graphics/8924OT_06_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Add a<a id="id397" class="indexterm"/> button and label to <code class="literal">WebServiceAppViewController</code>.</li><li class="listitem">In the <code class="literal">ViewDidLoad</code> method of the controller, add the following code:<div class="informalexample"><pre class="programlisting">this.btnFetch.TouchUpInside += (s, e) =&gt; {
  using (MTTestWebService webService = new MTTestWebService())
  {
    this.lblOutput.Text = webService.GetMessage ("Hello Web Service!");
  }
};</pre></div></li><li class="listitem">Add the following <code class="literal">using</code> directive to the <code class="literal">WebServiceAppViewController.cs</code> file:<div class="informalexample"><pre class="programlisting">using WebServiceApp.mtWebService;</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click on the <span class="strong"><strong>Fetch</strong></span> button and the output should be displayed on the screen.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec212"/>How it works...</h2></div></div></div><p>Xamarin.iOS apps can consume web services just like a .NET desktop application. The XSP lightweight <a id="id398" class="indexterm"/>web server is installed when installing the Mono Framework by default, which is a requirement for the Xamarin installation. When running the <code class="literal">xsp4</code> command in the terminal without any parameters, it sets its base directory to the current directory by default and starts listening on the <code class="literal">8080</code> port. If the web server is started, the web service description can be viewed by entering <code class="literal">http://localhost:8080/MTTestWebService.asmx</code> in a browser.</p><p>Xamarin Studio reads the <span class="strong"><strong>WSDL</strong></span> information<a id="id399" class="indexterm"/> from the provided URL and creates the necessary proxy that will allow us to use the web service in the project.</p><p>We then set the <span class="strong"><strong>Framework</strong></span> value to <span class="strong"><strong>.NET 2.0 Web Services</strong></span> and provide a <span class="strong"><strong>Reference</strong></span> name, which will reflect the namespace of the web reference. To make use of the web service within our code, we instantiate it and then just call the method we are interested in:</p><div class="informalexample"><pre class="programlisting">this.lblOutput.Text = webService.GetMessage ("Hello Web Service!");</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec213"/>There's more...</h2></div></div></div><p>Apart from using a local hosted web service, there are also numerous sample web services on the Internet. A simple search will yield many results.</p><div class="section" title="Invoking web service methods asynchronously"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec53"/>Invoking web service methods asynchronously</h3></div></div></div><p>The created<a id="id400" class="indexterm"/> proxy also contains methods based on Begin/End and the event to invoke the web service asynchronously. The following example shows us how to use the event-based methods:</p><div class="informalexample"><pre class="programlisting">MTTestWebService webService = new MTTestWebService();
webService.GetMessageCompleted += (sender, args) =&gt; this.InvokeOnMainThread(() =&gt; this.lblOutput.Text = args.Result);
webService.GetMessageAsync("Hello Web Service!");</pre></div><p>Note the <code class="literal">InvokeOnMainThread</code> call inside the event handler; it is being called on a separate thread. So, if we want to access the main thread in it, we need to wrap our calls with <code class="literal">InvokeOnMainThread</code>.</p></div><div class="section" title="The XSP shutdown"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec54"/>The XSP shutdown</h3></div></div></div><p>To shut down<a id="id401" class="indexterm"/> the XSP web server, just click on the <span class="emphasis"><em>Return</em></span> key in the terminal where it was executed from.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec214"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Communicating with native APIs</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Consuming REST services"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Consuming REST services</h1></div></div></div><p>In this recipe, we <a id="id402" class="indexterm"/>will discuss how to properly use and consume REST services with Xamarin.iOS.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec215"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">ForecastApp</code>. In this recipe, we <a id="id403" class="indexterm"/>will use the <span class="strong"><strong>Open Meteo Foundation</strong></span> REST API. The use of this API is subject to the terms of use stated in this<a id="id404" class="indexterm"/> page: <a class="ulink" href="http://openmeteofoundation.org/terms-of-use">http://openmeteofoundation.org/terms-of-use</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec216"/>How to do it...</h2></div></div></div><p>Perform the following steps to complete this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a label and a button on <code class="literal">ForecastAppViewController</code>. Make sure that the label's <span class="strong"><strong>Lines</strong></span> property is set to at least three lines.</li><li class="listitem">Add the following code in the controller's <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.btnForecast.TouchUpInside += async (sender, e) =&gt; {

  HttpClient client = new HttpClient();
  string jsonResponse = await client.GetStringAsync("http://api.ometfn.net/0.1/forecast/eu12/46.5,6.32/now.json");
  JsonValue jsonObj = JsonValue.Parse(jsonResponse);
  JsonArray tempArray = (JsonArray)jsonObj["temp"];
  double temp = (double)tempArray[0];
  JsonArray windSpeedArray = (JsonArray)jsonObj["wind_10m_ground_speed"];
  double windSpeed = (double)windSpeedArray[0];
  this.lblOutput.Text = string.Format("Temperature: {0}\nWind speed: {1}", temp, windSpeed);
};</pre></div></li><li class="listitem">Add the <code class="literal">System.Net.Http</code> and <code class="literal">System.Json</code> references to the project. Don't forget to include the corresponding <code class="literal">using</code> directives to the <code class="literal">ForecastAppViewcontroller.cs</code> file.</li><li class="listitem">Compile and run the app on the simulator. Click on the <span class="strong"><strong>Get Forecast</strong></span> button to display the current temperature and wind speed on the screen.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec217"/>How it works...</h2></div></div></div><p>In this recipe, we created an app that uses a REST API to get the current forecast for a location. We<a id="id405" class="indexterm"/> are using the <code class="literal">async</code>/<code class="literal">await</code> pattern that allows us to connect and retrieve the data asynchronously. This helps us make sure that our app will not freeze while it is connected to retrieve the data.</p><p>As it all happens when we click on the button, its <code class="literal">TouchUpInside</code> handler method needs to be marked <code class="literal">async</code>, as follows:</p><div class="informalexample"><pre class="programlisting">this.btnForecast.TouchUpInside += async (sender, e) =&gt; {
//..</pre></div><p>We then use the <code class="literal">HttpClient</code> class, which is part of the <code class="literal">System.Net.Http</code> namespace that provides us with asynchronous methods to connect to endpoints, as follows:</p><div class="informalexample"><pre class="programlisting">HttpClient client = new HttpClient();
  string jsonResponse = await client.GetStringAsync("http://api.ometfn.net/0.1/forecast/eu12/46.5,6.32/now.json");</pre></div><p>We pass the endpoint to the <code class="literal">GetStringAsync</code> method, and we get back a JSON response string.</p><p>After retrieving the response, we need to parse it to extract the information we need from it. We do this by using the <code class="literal">System.Json</code> namespace. This namespace contains a set of simple classes that allow us to parse JSON strings, as follows:</p><div class="informalexample"><pre class="programlisting">JsonValue jsonObj = JsonValue.Parse(jsonResponse);</pre></div><p>The temperature is contained in the JSON response under the temp key that contains an array, albeit with a single item, as follows:</p><div class="informalexample"><pre class="programlisting">JsonArray tempArray = (JsonArray)jsonObj["temp"];
double temp = (double)tempArray[0];</pre></div><p>After we read the information we need from the JSON response, we display it as follows:</p><div class="informalexample"><pre class="programlisting">this.lblOutput.Text = string.Format("Temperature: {0}\nWind speed: {1}", temp, windSpeed);</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec218"/>There's more...</h2></div></div></div><p>The <code class="literal">System.Json</code> namespace is very helpful for parsing simple JSON strings. However, things could get very complicated if we have to parse large and more complex objects. There<a id="id406" class="indexterm"/> are a number of open source libraries we can download and use in our Xamarin.iOS projects. The most popular are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Xamarin port of NewtonSoft Json.NET from Andrew Young</strong></span>: Even if this is outdated, it is <a id="id407" class="indexterm"/>fully functional for Xamarin projects. You can find the page at <a class="ulink" href="https://github.com/ayoung/Newtonsoft.Json">https://github.com/ayoung/Newtonsoft.Json</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ServiceStack.Text</strong></span>: You <a id="id408" class="indexterm"/>can find the page at <a class="ulink" href="https://github.com/ServiceStack/ServiceStack.Text">https://github.com/ServiceStack/ServiceStack.Text</a>.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec219"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Consuming web services</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Communicating with native APIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Communicating with native APIs</h1></div></div></div><p>In this recipe, we<a id="id409" class="indexterm"/> will discuss using native iOS APIs to connect and consume REST services.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec220"/>Getting ready</h2></div></div></div><p>For this recipe, we will work on the <code class="literal">ForecastApp</code> we created in the previous recipe, <span class="emphasis"><em>Consuming REST services</em></span>. Open the project in Xamarin Studio.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec221"/>How to do it…</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Comment out the code in the <code class="literal">ViewDidLoad</code> method and add the following code:<div class="informalexample"><pre class="programlisting">this.btnForecast.TouchUpInside += (sender, e) =&gt; {
  NSUrlRequest request = new NSUrlRequest(new NSUrl("http://api.ometfn.net/0.1/forecast/eu12/46.5,6.32/now.json"));
  NSUrlConnection connection = new NSUrlConnection(request, new ConnectionDelegate((response) =&gt; {
    JsonValue jsonObj = JsonValue.Parse(response);
    JsonArray tempArray = (JsonArray)jsonObj["temp"];
    double temp = (double)tempArray[0];
    JsonArray windSpeedArray = (JsonArray)jsonObj["wind_10m_ground_speed"];
    double windSpeed = (double)windSpeedArray[0];
    this.lblOutput.Text = string.Format("Temperature: { 0}\ nWind speed: { 1}", temp, windSpeed);
    }));
  connection.Start();
};</pre></div></li><li class="listitem">Add the<a id="id410" class="indexterm"/> following class to the project:<div class="informalexample"><pre class="programlisting">public class ConnectionDelegate : NSURLConnectionDelegate {
  private Action&lt;string&gt; finishedCallback;
  private StringBuilder responseData;
  public ConnectionDelegate(Action&lt;string&gt; callback) {
    this.finishedCallback = callback;
    this.responseData = new StringBuilder();
  }
  public override void ReceivedData(NSUrlConnection connection, NSData data) {
    if (null != data) {
      this.responseData.Append(data.ToString());
    }
  }
  public override FinishedLoading(NSUrlConnection connection) {
    if (null != this.finishedCallback) {
      this.finishedCallback(this.responseData.ToString());
    }
    this.responseData.Clear();
  }
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click on the <span class="strong"><strong>Get Forecast</strong></span> button to fetch and display the forecast data.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec222"/>How it works…</h2></div></div></div><p>The <code class="literal">NSUrlConnection</code> class is the native iOS class that provides basic connectivity functionality. We initialize it by passing <code class="literal">NSUrlRequest</code> and a delegate object, as follows:</p><div class="informalexample"><pre class="programlisting">NSUrlRequest request = new NSUrlRequest(new NSUrl("http://api.ometfn.net/0.1/forecast/eu12/46.5,6.32/now.json"));
  NSUrlConnection connection = new NSUrlConnection(request, new ConnectionDelegate((response) =&gt; {</pre></div><p>The <code class="literal">ConnectionDelegate</code> class that we created acts as the delegate object of our <code class="literal">NSUrlConnection</code>. Inside the class, we need to override the <code class="literal">ReceivedData</code> method to fill our internal buffer with the data received from the service, as follows:</p><div class="informalexample"><pre class="programlisting">public override void ReceivedData(NSUrlConnection connection, NSData data) { </pre></div><p>Similarly to reading data from the <code class="literal">Stream</code> object of <code class="literal">HttpWebResponse</code>, the <code class="literal">ReceivedData</code> method will be called as soon as new data becomes available. Inside <code class="literal">ReceivedData</code>, we make sure we append the data to our buffer. When all the data has been received <a id="id411" class="indexterm"/>and the response is finished, the <code class="literal">FinishedLoading</code> method will be called, as follows:</p><div class="informalexample"><pre class="programlisting">public override void FinishedLoading(NSUrlConnection connection) {</pre></div><p>After initializing the <code class="literal">NSUrlConnection</code> instance, we call its <code class="literal">Start</code> method to initiate the connection, as follows:</p><div class="informalexample"><pre class="programlisting">connection.Start();</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec223"/>There's more…</h2></div></div></div><p>If something goes wrong with the connection, the <code class="literal">FailedWithError</code> method of <code class="literal">NSUrlConnectionDelegate</code> will be called. We can override it to get information on the error that occurred, as follows:</p><div class="informalexample"><pre class="programlisting">public override void FailedWithError(NSUrlConnection connection, NSError error) {
  if (null != error) {
    Console.WriteLine("Connection error: {0}", error.LocalizedDescription);
  }
}</pre></div><div class="section" title="Synchronous NSUrlConnection"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec55"/>Synchronous NSUrlConnection</h3></div></div></div><p>Using the <code class="literal">NSUrlConnection</code> class<a id="id412" class="indexterm"/> with a delegate object means that the connection will take place asynchronously on the thread that it was started from. If we wanted to start a synchronous connection, we can use the <code class="literal">SendSynchronousRequest</code> static method, as follows:</p><div class="informalexample"><pre class="programlisting">NSUrlResponse response;
NSError error;
NSData data = NSUrlConnection.SendSyncrhonousRequest(request, out response, out error);
// do something with data</pre></div></div><div class="section" title="Usability"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec56"/>Usability</h3></div></div></div><p>As you might<a id="id413" class="indexterm"/> have already noticed, using <code class="literal">NSUrlConnection</code> is a bit more complicated than plain old Mono BCL classes. In general, using BCL classes is the best practice for most scenarios, as it helps us maintain a multi-platform code base, among other things.</p><p>There are some cases, however, where the native APIs are very useful and are the only available <a id="id414" class="indexterm"/>solution. For example, iOS supports certain connectivity features in the background, which are only possible with the native APIs.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec224"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Consuming REST services</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Updating data in the background</em></span> recipe in <a class="link" href="ch12.html" title="Chapter 12. Multitasking">Chapter 12</a>, <span class="emphasis"><em>Multitasking</em></span></li></ul></div></div></div>
<div class="section" title="Using WCF services"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Using WCF services</h1></div></div></div><p>In this recipe, we<a id="id415" class="indexterm"/> will learn how to consume WCF services with Xamarin.iOS.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>The WCF service support is only available in business and enterprise licenses of Xamarin.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec225"/>Getting ready</h2></div></div></div><p>For this project, we will need a running WCF service. A WCF service can be found in the code download of this chapter. To start the service, open a terminal and go to the project's directory. Start the service by running the <code class="literal">start_wcfservice.sh</code> shell script, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd &lt;code_directory&gt;/CH06_code/WcfService/WcfService</strong></span>
<span class="strong"><strong>./start_wcfservice.sh</strong></span>
</pre></div><p>After the service is started, create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">WcfServiceApp</code>. A machine running on Windows will also be needed.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec226"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the references to the <code class="literal">System.Runtime.Serialization</code> and <code class="literal">System.ServiceModel</code> namespaces of the project and their corresponding <code class="literal">using</code> directives in the <code class="literal">WcfServiceAppViewController.cs</code> file.</li><li class="listitem">Xamarin.iOS does not provide full support for WCF services. To generate a proxy for the client, we will need to use the <code class="literal">slsvcutil</code> tool on a Windows machine. Run the following command in the command prompt under Windows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>"c:\Program Files\Microsoft SDKs\Silverlight\v3.0\Tools\slsvcutil /noconfig http://192.168.0.113:8080/WcfService.svc?wsdl"</strong></span>
</pre></div><p>This command will produce a C# source file named <code class="literal">service.cs</code>. Add this file to the Xamarin.iOS project. Replace the IP address in the following highlighted code with your own to make it work correctly.</p></li><li class="listitem">Add a<a id="id416" class="indexterm"/> label and a button on the view of <code class="literal">WcfServiceAppViewController</code>. Add the following code in the <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.btnFetchData.TouchUpInside += (sender, e) =&gt; {
<span class="strong"><strong>  WcfTestServiceClient client = new WcfTestServiceClient (new BasicHttpBinding (), new EndpointAddress ("http://192.168.0.113:8080/WcfTestService.svc"));</strong></span>
    client.GetBookInfoCompleted += WcfTestServiceClient_GetBookInfoCompleted;
    client.GetBookInfoAsync ();
    UIApplication.SharedApplication.NetworkActivityIndicatorVisible = true;
};</pre></div></li><li class="listitem">Finally, add the following method:<div class="informalexample"><pre class="programlisting">private void WcfTestServiceClient_GetBookInfoCompleted (object sender, GetBookInfoCompletedEventArgs e)
{
  this.InvokeOnMainThread (delegate {
    UIApplication.SharedApplication.NetworkActivityIndicatorVisible = false;
    this.lblResponse.Text = String.Format ("Book title: {0}\nAuthor: {1}", e.Result.Title, e.Result.Name);
  } );
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click on the button and watch the data returned from the service get populated in the label.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec227"/>How it works...</h2></div></div></div><p>Xamarin.iOS relies on Mono Framework's support for WCF services, which is not complete. Although, the fact that WCF services can be used in iOS apps makes Xamarin.iOS more appealing to .NET developers.</p><p>However, there is no tool to create the client proxy on a Mac, and Xamarin Studio can not create a proper proxy either; so, we will need to have access to a Windows machine to do this with the Silverlight Service Model Proxy Generation Tool (<code class="literal">SLsvcUtil.exe</code>). The source file that this tool generates allows us to consume the WCF service in our project.</p><p>It is<a id="id417" class="indexterm"/> important to use Silverlight Version 3.0 <code class="literal">slsvcutil</code> to create the client proxy.</p><p>Apart from Mono Framework's support, there is another limitation, that is, the dynamic code generation is not allowed on iOS. This makes any code that relies on the <code class="literal">System.Reflection.Emit</code> namespace unusable. In fact, the <code class="literal">System.Reflection.Emit</code> namespace is not available at all in Xamarin.iOS.</p><p>After copying the produced file on Mac, we add it to the project, and we are ready to use the WCF service. The preceding highlighted code shows us how to instantiate the service object. Note that the default constructor of the service object cannot be used, as Xamarin.iOS does not support the <code class="literal">System.Configuration</code> namespace.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>The actual communication occurs by calling the method's asynchronous implementation after setting a handler to its corresponding completion event. Note that in this case, there is no alternative to using synchronous invocations or the <code class="literal">BeginInvoke</code> and <code class="literal">EndInvoke</code> pattern:</p><div class="informalexample"><pre class="programlisting">client.GetBookInfoCompleted += WcfTestServiceClient_GetBookInfoCompleted;
client.GetBookInfoAsync ();</pre></div><p>The result returned from the service can be retrieved through the specified <code class="literal">EventArgs</code> derivative's <code class="literal">Result</code> property:</p><div class="informalexample"><pre class="programlisting">this.labelResult.Text = String.Format ("Book title: {0}\nAuthor: {1}", e.Result.Title, e.Result.Name);</pre></div></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec228"/>There's more...</h2></div></div></div><p>When debugging a project that consumes WCF services, remember to set the address of the machine the service is running on, instead of localhost or 127.0.0.1. This is because when we run the app on the device, the app will fail to connect to the service.</p><div class="section" title="More information on Xamarin Studio's WCF support"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec57"/>More information on Xamarin Studio's WCF support</h3></div></div></div><p>There is <a id="id418" class="indexterm"/>an option of adding a WCF web reference through Xamarin Studio in the <span class="strong"><strong>Add Web References</strong></span> window shown in the <span class="emphasis"><em>Consuming web services</em></span> recipe. However, it is<a id="id419" class="indexterm"/> not yet complete and the proxy it generates will not work.</p></div><div class="section" title="WCF service creation"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec58"/>WCF service creation</h3></div></div></div><p>The object<a id="id420" class="indexterm"/> returned from the <code class="literal">WcfService</code> service and the actual service itself was created completely on a Mac as a Xamarin Studio project. As there is no WCF project template, the <span class="strong"><strong>Empty Project</strong></span> template was used.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec229"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Consuming web services</em></span> recipe</li></ul></div></div></div></body></html>