<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Concentration Gameplay"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Concentration Gameplay</h1></div></div></div><p>After talking a little bit about assets and having our <code class="literal">ResourceManager</code> in place, we'll start building the <span class="emphasis"><em>Concentration</em></span> gameplay. We'll talk about input handling, basic animations, and game states. These are the basis of gameplay implementation and will be useful from the smallest to the biggest game you develop using Moai SDK.</p><div class="section" title="Grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Grid</h1></div></div></div><p>The first thing we're going to do is to display a grid<a id="id131" class="indexterm"/> of tiles that will be our playground. Just to start with, we'll display the back of the tiles.</p><div class="section" title="Tilemaps"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec19"/>Tilemaps</h2></div></div></div><p>A commonly used technique in <a id="id132" class="indexterm"/>game development is the implementation of <a id="id133" class="indexterm"/>
<span class="strong"><strong>tilesets</strong></span>.</p><p>The idea is to create one image that includes more than one asset in it.</p><p>We're going to create a tileset<a id="id134" class="indexterm"/> called <code class="literal">tiles.png</code>. It consists of 12 tiles, 11 different colors (the gray one for the back of the tiles), and the "empty tile" (white). It looks somewhat like the following:</p><div class="mediaobject"><img src="graphics/5064_07_01.jpg" alt="Tilemaps"/></div><p>You should be aware that what we're going to do is to create a tiled image that will be indexed as follows:</p><div class="mediaobject"><img src="graphics/5064_07_02.jpg" alt="Tilemaps"/></div><p>This is the result of <a id="id135" class="indexterm"/>subdividing the actual image in two rows and six columns. We'll end up having twelve 62 x 62 tiles.</p></div><div class="section" title="The implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec20"/>The implementation</h2></div></div></div><p>Let's start with <a id="id136" class="indexterm"/>the implementation:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to create a file called <code class="literal">game.lua</code> that will hold all of the code for our gameplay.</li><li class="listitem">Open it and let's begin coding.<div class="informalexample"><pre class="programlisting">module("Game", package.seeall)
GRID_COLS = 5
GRID_ROWS = 4
GRID_TILE_WIDTH = 62
GRID_TILE_HEIGHT = 62
BACK_TILE = 1</pre></div></li><li class="listitem">These constants will become useful as they define the grid dimensions (rows, columns, and tile size). The last one is used to avoid magic numbers when setting the default grid state. As we saw, the gray tile that we'll use as the back of the tiles is indexed by the number <code class="literal">1</code> (because it's the first in our tileset).<div class="informalexample"><pre class="programlisting">local resource_definitions = {
 
  tiles = {
    type = RESOURCE_TYPE_TILED_IMAGE, 
    fileName = 'tiles.png', 
    tileMapSize = {6, 2},
  },
  
}</pre></div></li><li class="listitem">This should be familiar to you now. To define our tileset, we'll use the tiled image called <code class="literal">tiles.png</code> that we created earlier, which has six columns and two rows.<div class="informalexample"><pre class="programlisting">function Game:start ()
  -- Do the initial setup
  self:initialize ()
  
end</pre></div></li><li class="listitem">We're creating a method called <code class="literal">Game:start()</code> <a id="id137" class="indexterm"/>that will take care of initializing everything and controlling the game loop. This will be called from <code class="literal">main.lua</code> later. <a id="id138" class="indexterm"/>For now, we will only display our grid on initialization. So what we'll do here is call a function named <code class="literal">initialize()</code> that will take care of all the actual initialization. We'll be adding more code to this method later.</li><li class="listitem">The <code class="literal">initialize ()</code> function<a id="id139" class="indexterm"/> is as follows:<div class="informalexample"><pre class="programlisting">function Game:initialize ()

  self.layer = MOAILayer2D.new ()
  self.layer:setViewport ( viewport )</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We make a layer that will handle all of the rendering from the gameplay (including our grid) and configure the viewport on it.<div class="informalexample"><pre class="programlisting">  MOAIRenderMgr.setRenderTable ({ self.layer })</pre></div></li><li class="listitem">Then we set the render table using that layer.<div class="informalexample"><pre class="programlisting">  ResourceDefinitions:setDefinitions (resource_definitions)</pre></div></li><li class="listitem">The next step is to use <code class="literal">ResourceDefinitions</code> with a helper method called <code class="literal">setDefinitions ()</code>.<div class="informalexample"><pre class="programlisting">  self:initializeTiles ()</pre></div></li><li class="listitem">After loading the resource definitions, we call another auxiliary function that initializes the tiles.<div class="informalexample"><pre class="programlisting">end</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>The idea behind <code class="literal">setDefinitions ()</code> <a id="id140" class="indexterm"/>is to take a table of definitions and load all of them at once, instead of one by one. It was not created in the previous chapter, but it should be pretty simple to implement. Just iterate through the parameter table and call <code class="literal">setDefinitions ()</code> on each entry. Please go ahead and try to implement it by yourself. Remember, you can always download the book's code, and the method will be there.</p></div></div></li><li class="listitem">Now we need to take <a id="id141" class="indexterm"/>care of <code class="literal">initializeTiles ()</code>:<div class="informalexample"><pre class="programlisting">function Game:initializeTiles ()
  
  local grid = MOAIGrid.new ()  
  grid:setSize ( GRID_COLS, GRID_ROWS, 
                 GRID_TILE_WIDTH, GRID_TILE_HEIGHT )</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we create the grid using the<a id="id142" class="indexterm"/> <code class="literal">MOAIGrid</code> class. Then we set it up. We use the grid and tile dimensions we defined earlier to configure our new <code class="literal">MOAIGrid</code>.<div class="informalexample"><pre class="programlisting">  grid:setRow ( 1, BACK_TILE, BACK_TILE, 
                   BACK_TILE, BACK_TILE, BACK_TILE )
  grid:setRow ( 2, BACK_TILE, BACK_TILE, 
                   BACK_TILE, BACK_TILE, BACK_TILE )
  grid:setRow ( 3, BACK_TILE, BACK_TILE, 
                   BACK_TILE, BACK_TILE, BACK_TILE )
  grid:setRow ( 4, BACK_TILE, BACK_TILE, 
                   BACK_TILE, BACK_TILE, BACK_TILE ) )</pre></div></li><li class="listitem">Now <a id="id143" class="indexterm"/>we set up the actual grid. We call the <code class="literal">setRow()</code> method<a id="id144" class="indexterm"/> with the row number as the first parameter. (Start from <code class="literal">1</code>; remember, we're using Lua!) The following parameters are the values of the tiles we want to show for each column. We will show the back tile across all the grids as an initial state for our game; that's why, we pass <code class="literal">BACK_TILE</code> as the tile number.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>Go ahead and play a little bit, changing the values for these parameters. (Not the first one though; that's the row!) Put some numbers between <code class="literal">2</code> and <code class="literal">11</code>; you should expect to see some color on the gray sea.</p></div></div><div class="informalexample"><pre class="programlisting">  self.tiles = {}
  self.tiles.grid = grid
  self.tiles.tileset = ResourceManager:get ('tiles')

  self.tiles.prop = MOAIProp2D.new ()
  self.tiles.prop:setDeck ( self.tiles.tileset )
  self.tiles.prop:setGrid ( self.tiles.grid )</pre></div></li><li class="listitem">Then we create a table called <code class="literal">tiles</code> and store the tileset in there, as well as a new Prop. The usage of a Prop<a id="id145" class="indexterm"/> is basically the same as we did earlier; the only difference is that we now use <code class="literal">setGrid ()</code> <a id="id146" class="indexterm"/>in order to make the Prop follow the size and configuration of that grid.<div class="informalexample"><pre class="programlisting"> self.tiles.prop:setLoc ( - GRID_COLS/2 * GRID_TILE_WIDTH,
                         - GRID_ROWS/2 * GRID_TILE_HEIGHT )</pre></div></li><li class="listitem">Since grids don't center over their elements (they just draw them from offsets), we need to center them ourselves. In this case, <code class="literal">(0,0)</code> is at the bottom-left corner of the Prop (instead of the middle). We need to offset it, and that's what we do by calling the<a id="id147" class="indexterm"/> <code class="literal">setLoc()</code> method; we move it by half of its columns times the tile's width (in the <span class="emphasis"><em>x</em></span> axis), and by half of its rows times the tile's height (in the <span class="emphasis"><em>y</em></span> axis).<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Moai SDK <a id="id148" class="indexterm"/>has a family of methods to deal with position, rotation, and scale. There are three families, namely the <code class="literal">set*</code> methods (that force a specific value), the <code class="literal">move*</code> methods (that generate animations applying a delta over time), and the <code class="literal">seek*</code> methods (that generate animations by going from the actual value to the specified value in a certain amount of time). To modify position you use <code class="literal">Loc</code>, for rotation <code class="literal">Rot</code>, and for scale <code class="literal">Scl</code>. So, for example, if you wanted to rotate the <code class="literal">tiles</code> Prop by 30 degrees within 10 seconds, you'd call <code class="literal">self.tiles.prop:moveRot (30, 10)</code>.</p><p>There's some more to these methods (like the curve they use to interpolate the values); you should check them out at <a class="ulink" href="http://getmoai.com/docs/class_m_o_a_i_transform2_d.html">http://getmoai.com/docs/class_m_o_a_i_transform2_d.html</a>.</p></div></div><div class="informalexample"><pre class="programlisting">  self.layer:insertProp ( self.tiles.prop )
end</pre></div></li><li class="listitem">We add the Prop to the layer and we're done.</li></ol></div></li><li class="listitem">The only thing remaining is to call this from <code class="literal">main.lua</code>. Below the viewport definition add the following code:<div class="informalexample"><pre class="programlisting">  function mainLoop ()
    Game:start ()
  end
  gameThread = MOAICoroutine.new ()
  gameThread:run ( mainLoop )</pre></div></li></ol></div><p>We will run our game in a separate Lua coroutine; this is done in order to allow it to have a game loop that is detached from the main coroutine flow. This will be handy for processing input.</p><p>That should be<a id="id149" class="indexterm"/> it; if you run the project now, you should see the grid with all 20 back tiles.</p></div></div></div>
<div class="section" title="Input"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Input</h1></div></div></div><p>The next step in our journey is to add<a id="id150" class="indexterm"/> input handling. We have to create a file called <code class="literal">input_manager.lua</code>; it will be in charge of listening to input events and will be queried by our game when needed. We will create it so that it will be usable with both mouse devices and touchscreens.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Generally speaking, all hosts are supposed to implement their own input schema. We won't see this in detail in this book, but so you understand where this comes from, take a look at the hosts that are shipped with Moai SDK.</p><p>Search for all the references to the <code class="literal">AKUReserveInputDevice*</code> and <code class="literal">AKUSetInputDevice*</code> method calls in <code class="literal">moai-sdk/hosts/src/GlutHost.cpp</code>.</p></div></div><p>We'll now inspect only the most important methods; please take a look at the full code in order to understand how everything fits together.</p><div class="informalexample"><pre class="programlisting">function InputManager:initialize ()
  
  if MOAIInputMgr.device.pointer then
  
  local pointerCallback = function ( x, y )
    previousX, previousY = pointerX, pointerY
    pointerX, pointerY = x, y
   
    if touchCallbackFunc then
      touchCallbackFunc ( MOAITouchSensor.TOUCH_MOVE, 1,
        pointerX, pointerY, 1 )
    end
  end
  
  MOAIInputMgr.device.pointer:setCallback ( pointerCallback )

end</pre></div><p>As you can see, this method checks if we have a pointer, and if we do, it creates a callback function (<code class="literal">pointerCallback</code>) that is passed to that pointer in order to update the <code class="literal">x</code> and <code class="literal">y</code> positions. It also talks to the touch sensor (<code class="literal">MOAITouchSensor</code>) in order to do the same in case we're not using a mouse but a touch-screen instead.</p><p>Besides this, <a id="id151" class="indexterm"/>another important method is<a id="id152" class="indexterm"/> <code class="literal">isDown ()</code>, which is used to know if we're clicking or touching the screen.</p><div class="informalexample"><pre class="programlisting">function InputManager:isDown ()

  if MOAIInputMgr.device.touch then

    return MOAIInputMgr.device.touch:isDown ()

  elseif MOAIInputMgr.device.pointer then

    return (
      MOAIInputMgr.device.mouseLeft:isDown ()
    )
  end
end</pre></div><p>This method is querying both the mouse and the touch sensor asking if we're clicking or touching respectively. We'll use this in our game loop to identify input. Remember to include this file in <code class="literal">main.lua</code> after the <code class="literal">require 'resource_manager'</code> statement.</p></div>
<div class="section" title="Gameplay"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Gameplay</h1></div></div></div><p>Now let's take a look at what<a id="id153" class="indexterm"/> we need in order to implement the gameplay. First of all, we need to create all of the structures (and initialize them) for the game state. We'll be using another grid, this time to store a randomized distribution of numbers.</p><div class="section" title="Initialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec21"/>Initialization</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a call at the <a id="id154" class="indexterm"/>bottom of the <code class="literal">Game:initialize ()</code> method <a id="id155" class="indexterm"/>to an auxiliary function.<div class="informalexample"><pre class="programlisting">  self:restartGamePlay ()</pre></div></li><li class="listitem">Add the auxiliary function as well.<div class="informalexample"><pre class="programlisting">function Game:restartGamePlay ()
  self.distributionGrid = MOAIGrid.new ()
  self.distributionGrid:setSize (GRID_COLS, GRID_ROWS)</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we create a grid that will hold the distribution of our colors. This grid also has a dimension of 5 x 4. Note that we don't need to set the tile size now as this grid won't be rendered.<div class="informalexample"><pre class="programlisting">  local tiles = {
    2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 
    7, 7, 8, 8, 9, 9, 10, 10, 11, 11
  }</pre></div></li><li class="listitem">This table<a id="id156" class="indexterm"/> is just a temporary array of tiles; as you see, we start from <code class="literal">2</code> (<code class="literal">1</code> is the back tile, remember?) and repeat each number twice. These numbers represent the color (or the tile offset) on our tileset.<div class="informalexample"><pre class="programlisting">    for x=1, GRID_COLS, 1 do
      for y=1, GRID_ROWS, 1 do
        local random =  math.random ( 1, #tiles )
        local value = tiles[random]
        table.remove ( tiles, random )
        self.distributionGrid:setTile ( x, y, value )
      end
    end</pre></div></li><li class="listitem">The next thing we do is to iterate over all of the grid cells, assign one of the values to the <code class="literal">tiles</code> table at random, and remove it from the table so it doesn't get selected more than once. In this way, we fill our <code class="literal">distributionGrid</code> with a randomized order of the color pairs. Nice.<div class="informalexample"><pre class="programlisting">  self.selectedCells = { nil, nil } 
end</pre></div></li><li class="listitem">The next thing we need is a place to store the cells that were selected in the current turn. We'll use a table called <code class="literal">selectedCells</code>, and it will start displaying two <code class="literal">nil</code> cells because we haven't selected anything yet.</li></ol></div></li></ol></div><p>And that's it for the gameplay initialization part.</p></div><div class="section" title="Input processing"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec22"/>Input processing</h2></div></div></div><p>Now we need to <a id="id157" class="indexterm"/>process input from the user.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to append some code to the <code class="literal">Game:start ()</code> method (below the call to <code class="literal">Game:initialize ()</code>):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  self.wasClicking = false</strong></span>
</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We want to know if in the previous simulation step the user was clicking or tapping the screen. We'll store that information in <code class="literal">wasClicking</code>.<div class="informalexample"><pre class="programlisting">  while (true) do
    self:processInput ()
    coroutine.yield ()
  end </pre></div></li><li class="listitem">Then we add an infinite loop (beware of algorithms!) that <span class="emphasis"><em>processes input</em></span> and uses the magical method <code class="literal">coroutine.yield()</code> <a id="id158" class="indexterm"/>that delegates the flow to the main routine, allowing <code class="literal">MOAISim</code> to do another simulation step. In this way, we avoid having an endless loop that freezes the game. Instead, we do all the rendering, Action Tree and Node Graph processing; and when all of that is done, it comes back to our coroutine to process the input once more.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>If you expect your game to update the screen (render) and it's not doing it, it's likely that you've forgotten to run <code class="literal">coroutine.yield()</code> to allow rendering before continuing with your code. Think about the loading screens for example.</p></div></div></li></ol></div></li><li class="listitem">Now the <a id="id159" class="indexterm"/>next method we'll take care of is the one that actually processes the input.<div class="informalexample"><pre class="programlisting">function Game:processInput ()
  if InputManager:isDown () and not self.wasClicking then</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If the player is clicking now and was not clicking in the previous simulation step (to avoid selecting multiple times when holding the mouse button), we want to select a tile.<div class="informalexample"><pre class="programlisting">    x, y = InputManager:position ()</pre></div></li><li class="listitem">The way we choose the tile is a pretty neat trick. We gather the mouse position that is represented in the window coordinate system.<div class="informalexample"><pre class="programlisting">    worldX, worldY = self.layer:wndToWorld ( x, y )
    modelX, modelY = self.tiles.prop:worldToModel ( worldX, worldY )</pre></div></li><li class="listitem">We need to transform them into model coordinates to do our trick by first converting them to world coordinates (through the layer). After these conversions, what we get in <code class="literal">modelX</code> and <code class="literal">modelY</code> is the offset in pixels from the bottom-left corner of our grid.<div class="informalexample"><pre class="programlisting">  cellColumn = math.floor ( modelX / GRID_TILE_WIDTH ) + 1
  cellRow = math.floor ( modelY / GRID_TILE_HEIGHT ) + 1</pre></div></li><li class="listitem">If we divide <code class="literal">modelX</code> and <code class="literal">modelY</code> by the dimensions of the cells, we'll get the cell column and row indices. Nice <span class="emphasis"><em>mathemagics</em></span>. Now it's just a matter of calling an auxiliary function that will take care of the consequences of that click:<div class="informalexample"><pre class="programlisting">    self:choseCell ( cellColumn, cellRow )
  end
  
  self.wasClicking = InputManager:isDown ()
  
end</pre></div></li><li class="listitem">Oh! <a id="id160" class="indexterm"/>And don't forget to update <code class="literal">wasClicking</code>. We need to store the value of <code class="literal">InputManager:isDown ()</code> on it because we'll need it in the next simulation step.</li></ol></div></li></ol></div></div><div class="section" title="Choosing a cell"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec23"/>Choosing a cell</h2></div></div></div><p>Now we have to implement the following <a id="id161" class="indexterm"/>cell-choosing method:</p><div class="informalexample"><pre class="programlisting">function Game:choseCell ( column, row )
  
  if not self.selectedCells[1] then</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If no cell was selected previously (the first one is nil), we have to select it.<div class="informalexample"><pre class="programlisting">    if not self:alreadySelectedTile ( column, row ) then</pre></div></li><li class="listitem">We always need to check that the cell we're clicking has not been removed from the game.<div class="informalexample"><pre class="programlisting">      self.selectedCells[1] = {column, row}</pre></div></li><li class="listitem">We put the selected cell's column and row in the <code class="literal">selectedCells</code> table.<div class="informalexample"><pre class="programlisting">      self:swapTile ( column, row )</pre></div></li><li class="listitem">Then we swap it to reveal its color.<div class="informalexample"><pre class="programlisting">    end
  else</pre></div></li><li class="listitem">We continue with the case if a tile was selected previously.<div class="informalexample"><pre class="programlisting">    if (self.selectedCells[1][1] == column) and (self.selectedCells[1][2] == row) then
      self.selectedCells[2] = {column, row}
      self:resetTiles ()</pre></div></li><li class="listitem">If the player clicked the same tile, what we want is to swap it back. Set the same tile as the second selected cell (<code class="literal">selectedCells[2]</code>) and reset them.<div class="informalexample"><pre class="programlisting">    else
      
      if not self:alreadySelectedTile ( column, row ) then</pre></div></li><li class="listitem">Remember to check that the cell we're clicking has not been removed from the game.<div class="informalexample"><pre class="programlisting">        self.selectedCells[2] = {column, row}
        self:swapTile ( column, row )</pre></div></li><li class="listitem">The <a id="id162" class="indexterm"/>same logic is applied here to select the cell and swap it. (Oh no! code duplication!)</li><li class="listitem">Now the core of the gameplay:<div class="informalexample"><pre class="programlisting">        local value1 = self.distributionGrid:getTile (
                         unpack(self.selectedCells[1]) )

        local value2 = self.distributionGrid:getTile (
                         unpack(self.selectedCells[2]) )</pre></div></li><li class="listitem">We gather both values and store them in <code class="literal">value1</code> and <code class="literal">value2</code> respectively. These variables contain the color of the tiles that the user selected.<div class="informalexample"><pre class="programlisting">        if (value1 == value2) then
          self:removeTiles ()</pre></div></li><li class="listitem">If the colors are the same, we remove the tiles.<div class="informalexample"><pre class="programlisting">        else
          self:resetTiles ()</pre></div></li><li class="listitem">If they differ, we swap them back. And that's it.<div class="informalexample"><pre class="programlisting">        end
      end
    end
  end
end</pre></div></li></ol></div><p>After a nice tail of <code class="literal">end</code> sentences, we're ready to implement the auxiliary methods.</p></div><div class="section" title="Tile swapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec24"/>Tile swapping</h2></div></div></div><p>To swap our<a id="id163" class="indexterm"/> tiles, we'll create the following<a id="id164" class="indexterm"/> <code class="literal">swapTile ()</code> method:</p><div class="informalexample"><pre class="programlisting">function Game:swapTile ( column, row )
  local value = self.distributionGrid:getTile ( column, row )
  self.tiles.grid:setTile ( column, row, value )
end</pre></div><p>What we do here is retrieve the color value from our <code class="literal">distributrionGrid</code> and set it into the rendered grid. This is really magical; don't you love it?</p><p>The result is that the tile changes its color according to the distribution on our <code class="literal">distributionGrid</code>.</p><p>Every <a id="id165" class="indexterm"/>distribution is randomized, so this will be different every time you play.</p></div><div class="section" title="Resetting tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec25"/>Resetting tiles</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need two<a id="id166" class="indexterm"/> more constants at<a id="id167" class="indexterm"/> the top of <code class="literal">game.lua</code> for the next methods (we will use these constants to avoid magic numbers):<div class="informalexample"><pre class="programlisting">EMPTY_TILE = 12</pre></div><p>
<code class="literal">EMPTY_TILE</code> is the white space that we have after all the tiles; we'll use it to remove the tiles that are not in the game. That's the index <code class="literal">12</code>.</p><div class="informalexample"><pre class="programlisting">DELAY_TIME = 0.5</pre></div><p>
<code class="literal">DELAY_TIME</code> is a time in seconds that we will use to defer the swapping back of the tiles, in order to allow the user to see what's the second color he has chosen. (In fact, after finishing the chapter, change it to zero and see what happens).</p></li><li class="listitem">And now, we create our<a id="id168" class="indexterm"/> <code class="literal">resetTiles ()</code> method:<div class="informalexample"><pre class="programlisting">function Game:resetTiles ()  
  sleepCoroutine(DELAY_TIME)</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We freeze the coroutine during <code class="literal">DELAY_TIME</code> seconds. We'll implement <code class="literal">sleepCoroutine</code> in the following code snippet:<div class="informalexample"><pre class="programlisting">  self.tiles.grid:setTile (
    self.selectedCells[1][1], 
    self.selectedCells[1][2], BACK_TILE )

  self.tiles.grid:setTile (
    self.selectedCells[2][1], 
    self.selectedCells[2][2], BACK_TILE )</pre></div></li><li class="listitem">This one may seem tricky, but what we're doing is telling our rendering grid that the cells in <code class="literal">selectedCells</code> should render <code class="literal">BACK_TILE</code>. We use the coordinates of each selected cell and pass them to <code class="literal">setTile</code> as the first two parameters. The third one is the color, so we use <code class="literal">BACK_TILE</code>.<div class="informalexample"><pre class="programlisting">  self.selectedCells = {}</pre></div></li><li class="listitem">We clear the <a id="id169" class="indexterm"/>selected cells to start over.<div class="informalexample"><pre class="programlisting">end</pre></div></li></ol></div></li></ol></div><p>That's it. Now <a id="id170" class="indexterm"/>we need to take care of removing the tiles.</p></div><div class="section" title="Removing tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec26"/>Removing tiles</h2></div></div></div><p>The following<a id="id171" class="indexterm"/> method will be used to remove the tiles that <a id="id172" class="indexterm"/>are equal and to swap the user correctly.</p><div class="informalexample"><pre class="programlisting">function Game:removeTiles ()
  sleepCoroutine ( DELAY_TIME )

  self.tiles.grid:setTile ( self.selectedCells[1][1], self.selectedCells[1][2], EMPTY_TILE )
  self.tiles.grid:setTile ( self.selectedCells[2][1], self.selectedCells[2][2], EMPTY_TILE )</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">This is pretty similar to the what we do when resetting tiles. The only difference is that we use the <code class="literal">EMPTY_TILE</code> constant<a id="id173" class="indexterm"/> here to make the tile disappear.<div class="informalexample"><pre class="programlisting">  self.selectedCells = {}</pre></div></li><li class="listitem">We clear the selected cells to start over.<div class="informalexample"><pre class="programlisting">end</pre></div></li></ol></div></div><div class="section" title="Other auxiliary methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec27"/>Other auxiliary methods</h2></div></div></div><p>There are two more auxiliary methods<a id="id174" class="indexterm"/> pending; one to see if a tile was already removed from the game and another to make the coroutine sleep. So here they are:</p><div class="informalexample"><pre class="programlisting">function Game:alreadySelectedTile ( column, row )
  return self.tiles.grid:getTile ( column, row ) == EMPTY_TILE
end</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">This method is used to identify if we removed a given tile or not. Basically we compare it's color value to <code class="literal">EMPTY_TILE</code>. If it's equal, then that tile was removed previously.</li><li class="listitem">Now for the strange (and extremely useful) one:<div class="informalexample"><pre class="programlisting">function sleepCoroutine (time)
  local timer = MOAITimer.new ()
  timer:setSpan ( time )
  timer:start()
  MOAICoroutine.blockOnAction ( timer )
end</pre></div></li></ol></div><p>In this method, what we<a id="id175" class="indexterm"/> do is freeze the coroutine for a given time. We use <code class="literal">MOAITimer</code> to achieve this. The magic here is created by the fact that the timer inherits from <code class="literal">MOAIAction</code>, and as a consequence, we can use the built-in<a id="id176" class="indexterm"/> <code class="literal">MOAICoroutine.blockOnAction()</code> method, which basically waits until the action is finished, to continue execution on the current thread.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>This is an important method, as you will see. It's used to create animation sequences in Moai SDK, when you have to wait for an action to finish before the other one starts (for example, a translation and a rotation done in sequence instead of in parallel).</p></div></div><p>Well, the game is pretty much ready for play. You'll obviously need to add a couple of things to this for it to be a ready-to-ship game (for example, a winning condition, a nice menu, a ticking clock, and so on), but the gameplay is there, and that's what we were looking for.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we learned how to use a grid to display tiles on the screen and also to represent gameplay data. We learned the basics of input handling and how to implement the actual gameplay of <span class="emphasis"><em>Concentration</em></span>. We also had our first approach to how Moai SDK uses coroutines. Now it's a good time to take some rest since the next chapters are juicy; we'll build a platformer prototype that uses Box2D for physics!</p></div></body></html>