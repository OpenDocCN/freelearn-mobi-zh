- en: Chapter 6. Running Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure the quality of any app or library, having automated tests is important.
    For a long time, the Android development tools lacked support for automated tests,
    but recently, Google has put in a lot of effort to make it easier for developers
    to get started with tests. Some old frameworks have been updated, and new frameworks
    have been added to make sure we can thoroughly test apps and libraries. We can
    run them not only from Android Studio, but also directly from the command-line
    interface, using Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the different ways to test Android apps and
    libraries. We will also look at how Gradle can help to automate the testing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having well-written unit tests in your project does not only assure quality,
    it also makes it easy to check if new code breaks any functionality. Android Studio
    and the Gradle Android plugin have native support for unit tests, but you need
    to configure a few things before you can use them.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JUnit** is an extremely popular unit testing library that has been around
    for over a decade. It makes it easy to write tests while making sure that they
    are also easy to read. Keep in mind that these particular unit tests are only
    useful for testing business logic and not code that is related to the Android
    SDK.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can start writing JUnit tests for your Android project, you need
    to create a directory for the tests. By convention, this directory is called `test`
    and it should be on the same level as your main directory. The directory structure
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can then create test classes in `src/test/java/com.example.app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of the latest features in JUnit, use JUnit version 4\. You can
    ensure this by adding a dependency for the test build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are using `testCompile` instead of `compile` here. We use this
    configuration to make sure that the dependency is only built when running the
    tests, and not when packaging the app for distribution. Dependencies added with
    `testCompile` will never be included in the APK releases generated by the regular
    assemble tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have any special conditions in one of your build types or product flavors,
    it is possible to add a test-only dependency to that specific build alone. For
    example, if you only want to add JUnit tests to your paid flavor, you can do that
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When everything is set up, it is time to start writing some tests. Here is
    a simple example of a class that tests a method adding two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To run all tests with Gradle, just execute `gradlew` test. If you only want
    to run the tests on a certain build variant, simply add the name of the variant.
    If you want to run the tests on only the debug variant, for example, execute `gradlewtestDebug`.
    If a test fails, Gradle prints the error message in the command-line interface.
    If all the tests run smoothly, Gradle shows the regular **BUILD SUCCESSFUL** message.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single failed test causes the `test` task to fail, halting the entire process
    immediately. This means that not all of your tests are executed in case of a failure.
    If you want to make sure the entire test suite is executed for all build variants,
    use the `continue` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also write tests specifically for a certain build variant by storing
    the tests class in the corresponding directory. For example, if you want to test
    specific behavior in the paid version of your app, put the test class in `src/testPaid/java/com.example.app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want to run the entire test suite, but only the tests for a particular
    class, you can use the tests flag like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Executing the test task does not only run all the tests, but also creates a
    test report, which can be found at a`pp/build/reports/tests/debug/index.html`.
    This report makes it easy to find the issues if there are any failures, and is
    particularly useful in situations where tests are executed automatically. Gradle
    will create a report for every build variant that you run the tests on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all your tests run successfully, your unit test report will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JUnit](img/B01061_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also run the tests within Android Studio. When you do that, you get
    immediate feedback in the IDE, and you can click on failed tests to navigate to
    the corresponding code. If all your tests pass, the **Run** tool window will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JUnit](img/B01061_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to test parts of your code that contain references to Android-specific
    classes or resources, regular unit tests are not ideal. You may have already tried
    and run into the `java.lang.RuntimeException: Stub!` error. To fix this, you would
    need to implement every method in the Android SDK yourself, or use a mocking framework.
    Luckily, several libraries exist that have taken care of the Android SDK. The
    most popular of those libraries is Robolectric, which provides an easy way to
    test Android functionality, without the need for a device or emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: Robolectric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Robolectric, you can write tests that make use of the Android SDK and resources,
    while still running tests inside the Java Virtual Machine. This means that you
    do not need a running device or emulator to make use of Android resources in your
    tests, thus making it a lot faster to test the behavior of UI components of an
    app or library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Robolectric, you need to add a few test dependencies. Besides
    Robolectric itself, you also need to include JUnit, and, if you make use of the
    support library, you also need the Robolectric shadow classes to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Robolectric tests classes should be created in the `src/test/java/com.example.app`
    directory, just like regular unit tests. The difference is that you can now write
    tests that involve Android classes and resources. For example, this test validates
    that the text of a certain `TextView` changes after clicking on a specific `Button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Robolectric has some known issues with Android Lollipop and the compatibility
    library. If you run into errors that mention missing resources related to the
    compatibility library, there is a fix for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add a file to the module called `project.properties`, and add these
    lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will help Robolectric find the compatibility library resources.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional tests** are used to test whether several components of an app
    work together as expected. For example, you can create a functional test to confirm
    that tapping a certain button opens a new `Activity`. There are several functional
    testing frameworks for Android, but the easiest way to get started with functional
    testing is using the Espresso framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Espresso
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google created **Espresso** to make it easier for developers to write functional
    tests. The library is provided through the Android support repository, so you
    can install it using the SDK Manager.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run tests on a device, you need to define a test runner. Through
    the testing support library, Google provides the `AndroidJUnitRunner` test runner,
    which helps you run JUnit test classes on Android devices. The test runner will
    load the app APK and the test APK to a device, run all the tests, and then build
    the reports with the test results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided you have downloaded the testing support library, this is how you should
    set up the test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to set up a few dependencies before you can start using Espresso:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You need to reference the testing support library and `espresso-core` to get
    started with Espresso. The last dependency, `espresso-contrib`, is a library with
    features that supplement Espresso, but are not part of the core library.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that these dependencies use the `androidTestCompile` configuration, instead
    of the `testCompile` configuration we used earlier. This is to make a distinction
    between unit tests and functional tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to try to run the test build at this point, you would run into
    this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The error itself is very descriptive. Gradle cannot complete the build because
    of a duplicate file. Luckily, it is just a license description, so we can strip
    it out of the build. The error itself contains information on how to do that as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build file is set up, you can start adding tests. Functional tests
    are placed in a different directory than the regular unit tests. Just like with
    the dependency configurations, you need to use `androidTest` instead of just test,
    so the correct directory for functional tests is `src/androidTest/java/com.example.app`.
    Here is an example of a test class that checks whether the text of `TextView`
    in `MainActivity` is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you can run Espresso tests, you need to make sure you have a device
    or emulator. If you forget to connect a device, trying to execute the test task
    will throw this exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you have connected a device or started an emulator, you can run your Espresso
    tests using `gradlewconnectedCheck`. This task will execute both `connectedAndroidTest`
    to run all tests for the debug build on all the connected devices, and `createDebugCoverageReport`
    to create a test report.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the generated test reports in the app directory under `build/outputs/reports/androidTests/connected`.
    Open `index.html` to view the report, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Espresso](img/B01061_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The functional test report shows which device and Android version the tests
    are run on. You can run these tests on multiple devices at the same time, so the
    device information makes it easier to find device- or version-specific bugs.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get feedback on your tests within Android Studio, set up a run/debug
    configuration to run the tests directly from the IDE. A run/debug configuration
    represents a set of run/debug startup properties. The Android Studio toolbar has
    a configuration picker, where you can select the run/debug configuration that
    you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Espresso](img/B01061_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To set up a new configuration, open the configuration editor by clicking on
    **Edit Configurations…** and then create a new Android tests configuration. Select
    the module and specify the instrumentation runner to be `AndroidJUnitRunner`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Espresso](img/B01061_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you save this new configuration, you can select it in the configuration
    picker and click on the **Run** button to run all tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Espresso tests from Android Studio has one caveat: the test report
    is not generated. The reason for this is that Android Studio executes the `connectedAndroidTest`
    task instead of `connectedCheck`, and `connectedCheck` is the task that takes
    care of generating the test report.'
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you start writing tests for your Android projects, it is good to know how
    much of your code base is covered by tests. There are plenty of test coverage
    tools for Java, but **Jacoco** is the most popular one. It is also included by
    default, which makes it easy to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Jacoco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enabling coverage reports is very easy. You just need to set `testCoverageEnabled
    = true` on the build type that you are testing. Enable test coverage for the debug
    build type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When you enable test coverage, the coverage reports are created when you execute
    `gradlew connectedCheck`. The task that creates the report itself is `createDebugCoverageReport`.
    Even though it is not documented, and it does not appear in the task list when
    you run `gradlew tasks`, it is possible to run it directly. However, because `createCoverageReport`
    depends on `connectedCheck`, you cannot execute them separately. The dependency
    on `connectedCheck` also means that you need a connected device or emulator to
    generate the test coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the task is executed, you can find the coverage report in the `app/build/outputs/reports/coverage/debug/index.html`
    directory. Every build variant has its own directory for reports, because each
    variant can have different tests. The test coverage report will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jacoco](img/B01061_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The report shows a nice overview of the coverage on the class level, and you
    can click through to get more information. In the most detailed view, you can
    see which lines are tested, and which ones are not, in a useful color-coded file
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to specify a particular version of Jacoco, simply add a Jacoco
    configuration block to the build type, defining the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, explicitly defining a version is not necessary; Jacoco will work regardless.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at several options to test Android apps and libraries.
    We started out with simple unit tests, and then looked at more Android-specific
    testing with Robolectric. Then we covered functional tests and getting started
    with Espresso. Finally, we looked at enabling test coverage reports to see where
    the test suite needs to be improved. Now that you know how to run the entire test
    suite with Gradle and Android Studio, and you can generate coverage reports, there
    are no excuses not to write tests. In [Chapter 8](ch08.html "Chapter 8. Setting
    Up Continuous Integration"), *Setting Up Continuous Integration*, we will look
    at more ways to automate tests with continuous integration tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter covers one of the most important aspects of customizing the
    build process: creating custom tasks and plugins. The chapter also includes a
    short introduction to Groovy. This will not only help when creating tasks and
    plugins, but will also make it easier to understand how Gradle works.'
  prefs: []
  type: TYPE_NORMAL
