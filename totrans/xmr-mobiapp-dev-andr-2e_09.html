<html><head></head><body><h1 id="e-xX2I">Chapter 9. Making POIApp Location Aware</h1>
<p id="e-s9tC">One of the most interesting aspects of mobile development is interacting with device capabilities such as motion sensors, cameras, and location sensors. Such features are contextual for most applications and carry a great deal of value to the users. In this chapter, we will walk you through adding location awareness to POIApp. We will cover the following topics:</p>
<ul id="e-vcin">
<li id="e-m3PY">Setting application permissions</li>
<li id="e-qIwR">Obtaining the current longitude and latitude</li>
<li id="e-YIYI">Obtaining the address for a longitude and latitude</li>
<li id="e-NIB9">Calculating the distance between two geo points</li>
<li id="e-AoLJ">Displaying a POI within the map app</li>
</ul>
<h1 id="e-wUmm">Working with location services</h1>
<p id="e-wwex">Integrating the location service in the Android platform is more complicated than it looks.</p>
<p id="e-ofPx">You need to consider different location providers, location accuracy, user movements, and most importantly the nominal device battery power consumption. While working with location services on the Android platform, you will primarily work with an instance of <code>LocationManager</code>. The <code>LocationManager</code> class provides you with the ability to obtain periodic updates of the device geo location or fires an event when the device enters the proximity of a given geographical location.</p>
<p id="e-oRXG">Android devices generally provide two different means of determining a location: <strong>GPS</strong> and <strong>Network</strong>. When requesting location change notifications, you may specify the provider you wish to receive updates from. The Android platform defines a set of string constants for the following providers:</p>
<p id="e-t8ku">Provider name</p>
<p id="e-LnuK">Description</p>
<p id="e-p2Gv"><code>GPS_PROVIDER</code> (GPS)</p>
<p id="e-O2bT">This provider determines a location using satellites. Depending on conditions, this provider may take a while to return a location fix. This requires the <code>ACCESS_FINE_LOCATION</code> permission.</p>
<p id="e-K5q3"><code>NETWORK_PROVIDER</code> (network)</p>
<p id="e-XFbP">This provider determines a location based on the availability of a cell tower and Wi-Fi access points. Its results are retrieved by means of a network lookup. This requires the <code>ACCESS_COARSE_LOCATION</code> permission.</p>
<p id="e-RJ5I"><code>PASSIVE_PROVIDER</code> (passive)</p>
<p id="e-ekV7">This provider can be used to passively receive location updates when other applications or services request them without actually having to request for the locations yourself. It requires the <code>ACCESS_FINE_LOCATION</code> permission. If the GPS is not enabled, this provider might only return coarse fixes.</p>
<p id="e-Vmht">The process of integrating the location service to an Android application includes the following steps:</p>
<ol id="e-Py6G">
<li id="e-ELZB">Obtain a reference to an instance of <code>LocationManager</code>.</li>
<li id="e-lc5H">Use the instance of <code>LocationManager</code> to request location change notifications, either ongoing or a single notification.</li>
<li id="e-ece9">Process the <code>LocationListener</code> callback methods. These methods will be fired only if the location is requested with the <code>RequestLocationUpdates(string, long, float, ILocationListener)</code> method.</li>
</ol>
<p id="e-bzrn">Accessing the location service in Android applications requires specific permissions to be added, depending on the provider you want to use.</p>
<h2 id="e-Cfwc">Setting the app permissions</h2>
<p id="e-gIZg">To access location services in Android, you must provide permissions to the application <code>AndroidManifest.xml</code> file. Android applications use two permissions to access the location API: <code>ACCESS_COARSE_LOCATION</code> and <code>ACCESS_FINE_LOCATION</code>. The <code>ACCESS_FINE_LOCATION</code> includes the permission for both the <code>GPS_PROVIDER</code> and <code>NETWORK_PROVIDER</code> providers. The <code>ACCESS_COARSE_LOCATION</code> permission includes permission only for <code>NETWORK_PROVIDER</code>.</p>
<p id="e-PJEg">To add the appropriate permissions to your application descriptor, perform the following steps:</p>
<ol id="e-hsxW">
<li id="e-rUZC">Double-click on <code>Properties</code>/<code>AndroidManifest.xml</code> in the <strong>Solution</strong> pad. The file will be opened in the manifest editor. There are two tabs at the bottom of the screen, <strong>Application</strong> and <strong>Source</strong>, which can be used to toggle between viewing a form for editing the file or the raw XML.</li>
<li id="e-Ca4s">In the <strong>Required permissions</strong> list, check <strong>AccessCoarseLocation</strong>, <strong>AccessFineLocation</strong>, and <strong>Internet</strong>. Navigate to <strong>File</strong> | <strong>Save</strong>:<img data-width="800" data-height="469" src="XhBPQB1a.jpg"/>
</li>
<li id="e-Actj">Switch to the <strong>Source</strong> view to view the XML as follows:<img data-width="800" data-height="219" src="r8qghy6E.jpg"/>
</li>
</ol>
<h2 id="e-SK3W">Configuring the emulator</h2>
<p id="e-WS5T">To use an <strong>emulator</strong> for development, this chapter will require the emulator to be configured with Google APIs so that the address lookup and navigation to map the app works.</p>
<p id="e-sMRk">To install and configure <strong>Google APIs</strong>, perform the following steps:</p>
<ol id="e-Ou21">
<li id="e-ob30">From the main menu, navigate to <strong>Tools</strong> and open <strong>Android SDK Manager</strong>.</li>
<li id="e-MT6Q">Select the platform version you are using, check <strong>Google APIs</strong>, and click on <strong>Install 1 package...</strong>, as shown in the following screenshot:<img data-width="599" data-height="644" src="dsor4qaj.jpg"/>
</li>
<li id="e-weg1">After the installation is complete, close the Android SDK Manager, and from the main menu, navigate to <strong>Tools</strong> | Open <strong>Android Emulator Manager</strong>.</li>
<li id="e-refC">Select the emulator you want to configure and click on <strong>Edit</strong>.</li>
<li id="e-iN67">In <strong>Target</strong>, select the <strong>Google APIs</strong> entry for the API level you want to work with.</li>
<li id="e-o3xP">Click on <strong>OK</strong> to save.</li>
</ol>
<h2 id="e-c3Pv">Obtaining an instance of LocationManager</h2>
<p id="e-iQRQ">The <code>LocationManager</code> class is a system service that provides access to the location and bearing of a device, if the device supports these services. You do not explicitly create an instance of <code>LocationManager</code>; instead, you request an instance from a <code>Context</code> object using the <code>GetSystemService()</code> method. In most cases, the <code>Context</code> object is a subtype of activity. The following code depicts declaring a reference of a <code>LocationManager</code> class and requesting an instance:</p>
<pre id="e-zerl">LocationManager locMgr;
. . .
locMgr = (LocationManager) GetSystemService (Context.LocationService);</pre>

<h1 id="e-Cq6s">Requesting location change notifications</h1>
<p id="e-DKNg">The <code>LocationManager</code> class provides a series of overloaded methods that can be used to request location update notifications. If you simply need a single update, you can call <code>RequestSingleUpdate()</code>; to receive ongoing updates, call <code>RequestLocationUpdate()</code>.</p>
<p id="e-hkFZ">Prior to requesting location updates, you must identify the location provider that should be used. In our case, we simply want to use the most accurate provider available at the time. This can be accomplished by specifying the criteria for the desired provider using an instance of <code>Android.Location.Criteria</code>. The following code example shows how to specify the minimum criteria:</p>
<pre id="e-cfkp">Criteria criteria = new Criteria();
criteria.Accuracy = Accuracy.NoRequirement;
criteria.PowerRequirement = Power.NoRequirement;</pre>
<p id="e-cMpy">Now that we have the criteria, we are ready to request updates as follows:</p>
<pre id="e-IECL">locMgr.RequestSingleUpdate (criteria, this, null);</pre>
<h2 id="e-pqWT">Implementing ILocationListener</h2>
<p id="e-xigf">You will notice that the second parameter to <code>RequestSingleUpdate()</code> must be an object that implements <code>ILocationListener</code>, which defines the following methods:</p>
<pre id="e-ptvo">void OnLocationChanged (Location location);
void OnProviderDisabled (string provider);
void OnProviderEnabled (string provider);
void OnStatusChanged (string provider, Availability status, Bundle extras);</pre>
<p id="e-yItu">For the most part, we will create blank stubs for all of the methods except <code>OnLocationChanged()</code>. While writing more sophisticated applications, it will be useful to provide implementations for some of the other methods. For example, you might call <code>RequestLocationUpdate()</code> to begin receiving updates and then receive a notification via <code>OnProviderEnabled()</code> that a preferred provider is now available, in which case you would want to stop the updates and start them again using the preferred provider.</p>

<h1 id="e-rDpF">Adding location services to POIApp</h1>
<p id="e-NYDF">In <code>POIApp</code>, we have the following two different scenarios for requesting location updates:</p>
<ul id="e-EZDd">
<li id="e-sKRG">In the POI list, we need to calculate the distance of each of the listed POIs. In this scenario, we want to request location change notifications on an ongoing basis and use the most current location to calculate the distance.</li>
<li id="e-U6BU">In <code>POIDetailFragment</code>, we would like to request the current location when adding a new POI. In this scenario, we would want to request a single location change notification.</li>
</ul>
<h2 id="e-tz81">Adding location services to the POI list</h2>
<p id="e-Suf2">Now that we have some idea of how to add location services to an app, let's add location services to <code>POIListFragment</code> as follows:</p>
<ol id="e-Sf3s">
<li id="e-V1JO">Declare a private instance of <code>LocationManager</code> and obtain a reference in the <code>OnCreateView()</code> method as follows:<pre id="e-fY5y">LocationManager locMgr;
...
public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
{
  View view = inflater.Inflate(Resource.Layout.POIListFragment, container, false);
  progressBar = view.FindViewById&amp;lt;ProgressBar&amp;gt; (Resource.Id.progressBar);
  SetHasOptionsMenu (true);
  locMgr = (LocationManager) Activity.GetSystemService (Context.LocationService);
  return view;
}</pre>
</li>
<li id="e-nA4d">Include the <code>Android.Locations</code> namespace in <code>POIListFragment</code> and implement the <code>ILocationListener</code> interface:<pre id="e-MDwY">public class POIListFragment: ListFragment, ILocationListener
{
  ...
}</pre>
</li>
<li id="e-O2hL">From the code editor right-click on <code>ILocationListenerinterface</code>, select <strong>Refactor</strong> | <strong>Implement interface</strong> to implement the stub methods. Remove any code placed by default in the stub methods; we will provide logic for <code>OnLocationChange()</code>
</li>
<li id="e-CYW6">In <code>OnResume()</code>, obtain the best location provider and call <code>RequestLocationUpdates()</code> to start receiving updates as follows:<pre id="e-IU7G">public override void OnResume ()
{
  base.OnResume ();
  DownloadPoisListAsync ();
   Criteria criteria = new Criteria ();
  criteria.Accuracy = Accuracy.NoRequirement;
  criteria.PowerRequirement = Power.NoRequirement;
  string provider = locMgr.GetBestProvider (criteria, true);
  locMgr.RequestLocationUpdates (provider, 2000, 100, this);
}</pre>
</li>
<li id="e-upRf">Override the <code>OnPause()</code> method on the <code>POIListFragment</code> class and add a call to <code>RemoveUpdates()</code>. This eliminates unnecessary processing of location changes when the <code>POIListFragment</code> class is not visible, as shown in the following code:<pre id="e-DaDf">protected override void OnPause ()
{
  base.OnPause ();
  locMgr.RemoveUpdates (this);
}</pre>
</li>
<li id="e-Tm0A">Add a <code>CurrentLocation</code> property to <code>POIListViewAdapter</code>. The <code>POIListFragment</code> class will use this property to communicate location changes to the adapter:<pre id="e-Ksgl">public Location CurrentLocation { get; set; }</pre>
</li>
<li id="e-XSiG">Add a logic to <code>OnLocationChanged()</code> to set <code>CurrentLocation</code> on <code>POIListViewAdapter</code> when a location change is received and call <code>NotifyDataSetChange()</code> to cause the <code>ListView</code> to be refreshed as follows:<pre id="e-zlOq">public void OnLocationChanged (Location location)
{
(this.ListAdapter as POIListViewAdapter).CurrentLocation = location;this.ListView.InvalidateViews ();     
}</pre>
</li>
<li id="e-YIR5">Add a logic to the <code>GetView()</code> method on <code>POIListViewAdapter</code> to calculate the distance between the <code>CurrentLocation</code> and a POI's location properties and update <code>distanceTextView</code> with the results. The calculation should only be done if <code>CurrentLocation</code> is not <code>null</code>, and the <code>Latitude</code> and <code>Longitude</code> properties for the POI being added to the <code>ListView</code> are not null. If any of these values are <code>null</code>, simply place <code>??</code> in the distance field to indicate that it cannot be calculated at this time as follows:<pre id="e-aBeX">var distanceTextView = view.FindViewById&amp;lt;TextView&amp;gt; (Resource.Id.distanceTextView);
if ((CurrentLocation != null) &amp;amp;&amp;amp; (poi.Latitude.HasValue) &amp;amp;&amp;amp; (poi.Longitude.HasValue)) {
  Location poiLocation = new Location ("");
  poiLocation.Latitude = poi.Latitude.Value;
  poiLocation.Longitude = poi.Longitude.Value;
  float distance = CurrentLocation.DistanceTo (poiLocation) * 0.000621371F;
  distanceTextView.Text = String.Format("{0:0,0.00}  miles", distance);
}
else {
  distanceTextView.Text = "??";
}</pre>
</li>
</ol>
<p id="e-uyR4">Now, run <code>POIApp</code> and view the results in <code>POIListView</code>.</p>
<h2 id="e-KXPP">Adding location services to POI details</h2>
<p id="e-rICi">The steps for adding location services to <code>POIDetailFragment</code> will be very similar to the previous section, but will be slightly simpler.</p>
<h3 id="e-tYSd">Updating the user interface</h3>
<p id="e-Ybjv">Prior to adding the logic, we need to add a few buttons to our app; one to get our location and one to navigate to the map, which we will cover later in this chapter. We can add these as a row of buttons at the bottom of <code>POIDetailFragment.axml</code>, as shown in the following screenshot:</p>
<img data-width="312" data-height="233" src="vIgVMhdy.jpg"/><p id="e-Jysg">Using <code>ImageButton</code> allows a <code>drawable</code> class to be specified. To add the <code>ImageButton</code> widgets, perform the following steps:</p>
<ol id="e-Q66b">
<li id="e-Addr">Add a <code>LinearLayout</code> instance to the bottom of <code>POIDetailFragment.axml</code> just below the <code>TableLayout</code> used to arrange the latitude and longitude content. The orientation should be <code>horizontal</code>.</li>
<li id="e-arKe">On the <code>LinearLayout</code> instance, the orientation should be <code>horizontal</code>, the content should be wrapped (both height and width), and it should be centered horizontally in the parent. The layout gravity can be used to center the content horizontally within its parent. The top and bottom padding of <code>10dp</code> will provide a good spacing for the buttons.</li>
<li id="e-XgHt">Add the two <code>ImageButton</code> widgets: <code>locationImageButton</code> and <code>mapImageButton</code>, in the <code>LinearLayout</code> instance. Images for these buttons can be found in the <code>drawable</code> folder in the <code>assets</code> location.</li>
<li id="e-XVzx">The following XML code shows the result:<pre id="e-YlAg">.. . &amp;lt;/TableLayout&amp;gt; 
&amp;lt;LinearLayout
         p1:orientation="horizontal"
         p1:layout_width="wrap_content"
         p1:layout_height="wrap_content"
         p1:layout_gravity="center_horizontal"
         p1:minWidth="25px"
         p1:minHeight="25px"
         p1:layout_marginTop="10dp"
         p1:layout_marginBottom="10dp"&amp;gt;
         &amp;lt;ImageButton
           p1:src="@drawable/ic_locate"
           p1:layout_width="wrap_content"
           p1:layout_height="wrap_content"
           p1:id="@+id/locationImageButton" /&amp;gt;
         &amp;lt;ImageButton
           p1:src="@drawable/ic_map"
           p1:layout_width="wrap_content"
           p1:layout_height="wrap_content"
           p1:id="@+id/mapImageButton" /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;</pre>
</li>
</ol>
<h3 id="e-raze">Adding the code</h3>
<p id="e-OZOm">Now that we have buttons on the UI, we can add the code to obtain the location as follows:</p>
<ol id="e-Z5xQ">
<li id="e-cC3s">Declare a private instance of <code>LocationManager</code> and obtain a reference in <code>OnCreate()</code> in the same way we did for <code>POIListView</code> in the previous section:<pre id="e-oggV">locMgr = (LocationManager) Activity.GetSystemService (Context.LocationService);</pre>
</li>
<li id="e-vaSI">Add a <code>GetLocationClicked</code> event handler and hook it up to the <code>ImageButton</code> as follows:<pre id="e-NRCi">_locationImageButton = FindViewById&amp;lt;ImageButton&amp;gt;
         (Resource.Id.locationImageButton);
       _locationImageButton.Click += GetLocationClicked;</pre>
</li>
<li id="e-SwAD">Add a call to <code>RequestSingleUpdate()</code> in <code>GetLocationClicked()</code>. The <code>RequestSingleUpdate()</code> method allows a <code>Criteria</code> object to be passed in so that we do not need a separate call to <code>GetBestProvider()</code> as follows:<pre id="e-xF6b">protected void GetLocationClicked(object sender, EventArgs   e)
       {
         Criteria criteria = new Criteria();
         criteria.Accuracy = Accuracy.NoRequirement;
         criteria.PowerRequirement = Power.NoRequirement;
         locMgr.RequestSingleUpdate (criteria, this, null);
       }</pre>
</li>
<li id="e-I2aP">Specify that <code>POIDetailFragment</code> implements <code>Android.Locations</code>. The <code>ILocationListener</code> implements stub methods using the Refactor | Implement interface. Remove any code placed in the stub methods; we will provide a logic for <code>OnLocationChange()</code>.</li>
<li id="e-MHfM">Add a logic to <code>OnLocationChange()</code> to update the location fields as follows:<pre id="e-mX8s">public void OnLocationChanged (Location location)
       {
         _latEditText.Text = location.Latitude.ToString();
         _longEditText.Text = location.Longitude.ToString ();
       }</pre>
</li>
</ol>
<h2 id="e-YJgT">Mocking location data for testing</h2>
<p id="e-PCat">Run <code>POIApp</code> and try adding a new POI and getting the location. While running the app in the emulator, you will notice that apparently nothing happens when you click on the location button. The app is actually waiting for a callback to <code>OnLocationChanged()</code> from the location manager. To trigger this callback, you must use the <strong>Android Device Monitor</strong> (<strong>ADM</strong>) to mock the location data.</p>
<p id="e-zGc5">To trigger <code>OnLocationChanged()</code>, perform the following steps:</p>
<ol id="e-W3EW">
<li id="e-KPfp">Start ADM and select the emulator instance on the left-hand side of the screen.</li>
<li id="e-wRpW">Click on the <strong>Emulator Control</strong> tab on the right-hand side of the screen. If the <strong>Emulator Control</strong> tab is not present, navigate to <strong>Window</strong> | <strong>Show View</strong> to display the tab. Notice that, at the bottom of the panel, there is a nested tab titled <strong>Location Controls</strong>, as shown in the following screenshot:<img data-width="800" data-height="397" src="LFvh8keh.jpg"/>
</li>
<li id="e-spR4">Select the <strong>Manual</strong> tab, adjust <strong>Longitude</strong> and <strong>Latitude</strong>, if desired, and click on <strong>Send</strong>. This will cause the <code>OnLocationChanged()</code> method to be fired on <code>POIDetailFragment</code>.</li>
</ol>
<p id="e-R1J8">Note the other two tabs under <strong>Location Controls</strong>: <strong>GPX</strong> and <strong>KML</strong>. These tabs can be used to load a series of location updates from a file and play them back to your app to test more sophisticated scenarios.</p>
<h2 id="e-jKCD">Getting an address for a location</h2>
<p id="e-GN3b">Another useful feature provided by the Android platform is called <strong>Geocoding</strong>. This is the process of obtaining the location in terms of latitude and longitude from a known address. Android also supports reverse geocoding, which is what you would expect from the name, obtaining an address from a known location.</p>
<p id="e-Bfpc">The <code>Android.Locations.Geocoder</code> class is the class used to perform geocoding and reverse geocoding. It's a very straightforward process to use, as shown in the following steps:</p>
<ol id="e-uNsH">
<li id="e-flHT">Create an instance of <code>Android.Locations.Geocoder</code>.</li>
<li id="e-aCcR">Call <code>GetFromLocation()</code> by passing in the location you would like to find the address for.</li>
<li id="e-kgCF">Process the <code>IList&amp;lt;Address&amp;gt;</code> collection returned. The collection of addresses returned from <code>GetFromLocation()</code> vary in specifics, which means that some are specific street addresses, some specify a city, country, and so on. The first address is always the most specific, so we will automatically choose it using the following code:<pre id="e-Xn7f">public void OnLocationChanged (Location location)
{
    _latEditText.Text = location.Latitude.ToString();
    _longEditText.Text = location.Longitude.ToString ();
    Geocoder geocdr = new Geocoder(activity);
    IList&amp;lt;Address&amp;gt; addresses = geocdr.GetFromLocation (location.Latitude, location.Longitude, 5);
    if (addresses.Any()) {
        UpdateAddressFields (addresses.First ());
    } 
}</pre>
</li>
</ol>
<p id="e-FjyM">Notice that the number <code>5</code> parameter in the <code>GetFromLocation()</code> method call represents the maximum number of results that are known to describe the area, surrounding the latitude and longitude.</p>
<p id="e-c4qD">You can see that we chose to call a method to format the address information. The <code>FeatureName</code> property may contain a title such as <em>Golden Gate Bridge</em> or <em>Empire State Building</em>. More times than not, <code>FeatureName</code> will simply contain the street number. The address contains a list of address lines, which we combine and place in <code>_addrEditText</code> as follows:</p>
<pre id="e-rE7d">protected void UpdateAddressFields(Address addr)
{
    if (String.IsNullOrEmpty(_nameEditText.Text))
        _nameEditText.Text = addr.FeatureName;
    if (String.IsNullOrEmpty(_addrEditText.Text)) 
    {
      for (int i = 0; i &amp;lt; addr.MaxAddressLineIndex; i++) {
        if (!String.IsNullOrEmpty(_addrEditText.Text))
              _addrEditText.Text += System.Environment.NewLine;
        _addrEditText.Text += addr.GetAddressLine (i);
      }
    } 
}</pre>
<p id="e-Ilt9">Now, run <code>POIApp</code> and try adding a new POI and getting the address for a location.</p>
<h2 id="e-SPZ4">Keeping the user informed</h2>
<p id="e-FGNe">After using the get location button, you will notice that requests for location information take some amount of time to process; generally, a few seconds or more. It would be best to keep users informed that processing is taking place so that they don't continually click on the button.</p>
<p id="e-tQ8a">This can be achieved in two ways. You can either attach a <code>ProgressBar</code> directly to the details fragment layout as we did for <code>POIListFragment</code>, or we can use a <code>ProgressDialog</code> class. The <code>ProgressDialog</code> class provides a simple means of displaying a dialog with a spinning progress widget and text description of what process is taking place. Ever since the <code>DialogFragment</code> class is added to Android, Google recommends that you use the <code>DialogFragment</code> class instead of <code>ProgressDialog</code>. Here, in this example, we will create a <code>DialogFragment</code> class that displays the loading progress that is similar to the <code>DeleteDialogFragment</code> class.</p>
<p id="e-UwbT">The following steps will guide you to add a dialog fragment to display the loading progress:</p>
<ol id="e-tdQT">
<li id="e-MHiR">Let's add a new fragment named <code>ProgressDialogFragment</code> and extend it from the <code>DialogFragment</code> class.</li>
<li id="e-VtZX">Override the <code>OnCreateDialog()</code> method and add the following code blocks:<pre id="e-JJcP">public class ProgressDialogFragment : DialogFragment
{
  public override Dialog OnCreateDialog (Android.OS.Bundle savedInstanceState)
  {
    Cancelable = false;
    ProgressDialog _progressDialog = new ProgressDialog (Activity);
    _progressDialog.SetMessage ("Getting location...");
    _progressDialog.Indeterminate = true;
    _progressDialog.SetProgressStyle (ProgressDialogStyle.Spinner);
    return _progressDialog;
  }
}</pre>
</li>
<li id="e-ol64">We are not ready with the <code>ProgressDialogFragment</code> fragment. Let's add the following code snippets to the <code>GetLocationClicked()</code> method to display the loading progress when a user clicks on the location button from <code>POIDetailFragment</code>:<pre id="e-MDM1">FragmentTransaction ft = FragmentManager.BeginTransaction();
var dialogFragment = new ProgressDialogFragment ();
dialogFragment.Show(ft, "progress_dialog");</pre>
</li>
<li id="e-vMbS">Now we need to remove the loading progress dialog once the location is retrieved from the location manager. Add the following code snippets to the <code>OnLocationChanged()</code> callback to remove the progress dialog:<pre id="e-lC00">FragmentTransaction ft = FragmentManager.BeginTransaction();
ProgressDialogFragment dialogFragment = (ProgressDialogFragment) FragmentManager.FindFragmentByTag("progress_dialog");
if (dialogFragment != null) {
  ft.Remove (dialogFragment).Commit();
}</pre>
</li>
</ol>
<p id="e-zgjO">Now, run <code>POIApp</code> and check the new progress dialog, as shown in the following screenshot:</p>
<img data-width="450" data-height="800" src="P6XvjrOb.jpg"/>
<h1 id="e-GPmX">Adding map integration</h1>
<p id="e-y3PL">Maps are another truly cool part of mobile computing. They provide a means of navigation, finding points of interest in an area, as well as supporting many other useful scenarios.</p>
<p id="e-LzDM">There are two basic approaches to interfacing with maps from an app as follows:</p>
<ul id="e-NpVA">
<li id="e-qw9Y">Navigate to the existing Android map app installed on the device to display a point of interest. Most recent Android devices are preinstalled with the Google Map application. However, it is not guaranteed.</li>
<li id="e-hfb6">Integrate with the Google Maps API. This approach integrates the map view directly to your application using Google Play services. You must create an application in the Google Developer Console and obtain a copy of the API key for your app.</li>
</ul>
<p id="e-uBBq">The first option is much easier to implement, whereas the second option allows tighter integration and control of the maps at the cost of more code and complexity. The second option requires very specific versions of the Xamarin.Android binding libraries corresponding to Google Play libraries. We chose to go with the first option for the <code>POIApp</code> example for the following reasons:</p>
<ul id="e-GULa">
<li id="e-zCVq">It is very difficult to get the second option working inside an emulator, which means that you would have to test and view the results of the code on an actual device, which may not be an option for all readers</li>
<li id="e-VPcb">We would need to dedicate more time than we have available in this chapter to get the second option up and running</li>
</ul>
<p id="e-GLKm">Xamarin's official website contains articles with all the details required to get the second option working.</p>
<h2 id="e-FDgr">Navigating to the Map app</h2>
<p id="e-Ts3f">To navigate to the Map app, we will rely on the <code>Intent</code> class we used earlier in the book; however, rather than specifying the <code>Activity</code> class we want to start, we will specify the type of information we would like to view using a URI. Android contains a registry of apps that can display different types of information and will launch the most appropriate app.</p>
<p id="e-z9Az">The Android platform defines a set of <code>Intent</code> classes that can be used to launch Google apps on Android devices. The following table summarizes the <code>Intent</code> classes related to locations:</p>
<p id="e-IQK6">URI</p>
<p id="e-R4KW">Action</p>
<p id="e-Joq8"><code>geo:latitude,longitude</code></p>
<p id="e-Pzvn">This action opens the Map application centered at a latitude or longitude</p>
<p id="e-ZZre"><code>geo:latitude,longitude?z=zoom</code></p>
<p id="e-hU4q">This action opens the Map application centered at a latitude or longitude and zoomed to the specified level</p>
<p id="e-XdH8"><code>geo:0,0?q=my+street+address</code></p>
<p id="e-efG8">This action opens the Map application to the location of a street address</p>
<p id="e-bNXa"><code>geo:0,0?q=business+near+city</code></p>
<p id="e-YNby">This action opens the Map application and displays the annotated search results</p>
<p id="e-YUBY">In our case, we have a street address, latitude and longitude, or both. If the street address is present, we should build the <code>Intent</code> class with it because this will cause the street address to appear in the Map app, making it more user friendly. If the street address is not present, we will build the <code>Intent</code> class using latitude and longitude. The following code shows the logic for building the <code>Intent</code> class:</p>
<pre id="e-BGK7">Android.Net.Uri geoUri;
if (String.IsNullOrEmpty (_addrEditText.Text)) {
  geoUri = Android.Net.Uri.Parse (String.Format("geo:{0},{1}", _poi.Latitude, _poi.Longitude));
}
else {
  geoUri = Android.Net.Uri.Parse (String.Format("geo:0,0?q={0}", _addrEditText.Text));
}
Intent mapIntent = new Intent (Intent.ActionView, geoUri);</pre>
<p id="e-MNJI">Prior to launching the <code>Intent</code> class, we need to be sure there is an app that can handle the <code>Intent</code> class; otherwise, we might end up with an unhandled exception from <code>StartActivity()</code>.</p>
<h2 id="e-UHuz">Checking for registered map apps</h2>
<p id="e-JGca">Apps provide information about any capabilities they provide (the <code>Intent</code> classes) in their manifest files as an <code>&amp;lt;intent-filter/&amp;gt;</code> element. Since we are relying on an external map app to display our location for us, we should check whether such an app exists on the device we are running on. We can accomplish this with a few calls to the <code>PackageManager</code> class. The <code>PackageManager</code> class allows you to retrieve various types of information about the application packages installed on a device. The <code>QueryIntentActivities()</code> method allows you to check whether there are any apps available to handle a specific <code>Intent</code> class. The following code demonstrates the use of <code>QueryIntentActivities()</code>:</p>
<pre id="e-iJm7">PackageManager packageManager = Activity.PackageManager;
IList&amp;lt;ResolveInfo&amp;gt; activities = packageManager.QueryIntentActivities(mapIntent, 0);
if (activities.Count == 0) {
  Toast.MakeText (activity, "No map app available.", ToastLength.Short).Show ();
} 
else
{
  StartActivity (mapIntent);
}</pre>
<p id="e-qXjW">Create a <code>MapClicked()</code> event handler and attach it to the <code>_mapImageButton</code>. The following code snippet represents the complete <code>MapClicked()</code> code that is used to open a Map application:</p>
<pre id="e-Zh5b">protected void MapClicked(object sender, EventArgs   e){
  Android.Net.Uri geoUri;
  if (String.IsNullOrEmpty (_addrEditText.Text)) {
    geoUri = Android.Net.Uri.Parse (String.Format("geo:{0},{1}", _poi.Latitude, _poi.Longitude));
  }
  else {
    geoUri = Android.Net.Uri.Parse (String.Format("geo:0,0?q={0}", _addrEditText.Text));
  }
  Intent mapIntent = new Intent (Intent.ActionView, geoUri);
   PackageManager packageManager = Activity.PackageManager;
  IList&amp;lt;ResolveInfo&amp;gt; activities = packageManager.QueryIntentActivities(mapIntent, 0);
  if (activities.Count == 0) {
    Toast.MakeText (activity, "No map app available.", ToastLength.Short).Show ();
  } 
  else
  {
    StartActivity (mapIntent);
  }
}</pre>
<p id="e-uEOz">Run <code>POIApp</code> and click on the <strong>Map</strong> button from the POI details page. You will notice that the Map app will be opened with the POI location. You have the option of choosing to navigate to it from your current location.</p>

<h1 id="e-tDpa">Summary</h1>
<p id="e-QApz">In this chapter, we saw how to use device location services to find the current position. We also integrated <code>POIApp</code> with the native device map to position the POI on the map. In the next chapter, we will continue integrating with device capabilities by adding integration with the camera.</p>
</body></html>