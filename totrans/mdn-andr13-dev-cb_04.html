<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-109"><a id="_idTextAnchor190"/>4</h1>
<h1 id="_idParaDest-110"><a id="_idTextAnchor191"/>Navigation in Modern Android Development</h1>
<p>In Android development, navigation is the interaction that allows your Android application users to navigate to, from, and back out from the different screens within your app, an action that is very vital in the mobile ecosystem.</p>
<p>Jetpack navigation has simplified navigation between screens, and in this chapter, we will learn how to implement navigation with a simple view click, from the bottom navigation bar, which is most commonly used, by navigating with arguments, and more.</p>
<p>In this chapter, we’ll cover the following recipes:</p>
<ul>
<li>Implementing a bottom navigation bar using navigation destinations</li>
<li>Navigating to a new screen in Compose</li>
<li>Navigating with arguments</li>
<li>Creating deep links for destinations</li>
<li>Writing tests for navigation</li>
</ul>
<h1 id="_idParaDest-111"><a id="_idTextAnchor192"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_four">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_four</a>.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor193"/>Implementing a bottom navigation bar using navigation destinations</h1>
<p>In Android development, having a bottom navigation bar is very common; it helps inform your <a id="_idIndexMarker275"/>users that <a id="_idIndexMarker276"/>there are different sections in your application. In addition, other apps opt to include a navigation drawer activity, which holds a profile and additional information about the application.</p>
<p>An excellent example of an app that utilizes both – a navigation drawer and bottom navigation – is Twitter. It is also important to mention that some companies prefer to have a top navigation bar as a preference. In addition, others such as Google Play Store have both bottom and drawer navigation<a id="_idTextAnchor194"/>.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor195"/>Getting ready</h2>
<p>Create a new Android project with your preferred editor or Android Studio, or you can use any project from previous recipes.<a id="_idTextAnchor196"/></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor197"/>How to do it…</h2>
<p>In this recipe, we are going to create a new project and call it <code>BottomNavigationBarSample</code>:</p>
<ol>
<li>After creating our new empty <code>Activity BottomNavigationBarSample</code> project, we will start by adding the required navigation dependency in <code>build.gradle</code>, and then sync the project:<pre class="source-code">
implementation 'android.navigation:navigation-compose:2.5.2'</pre></li>
<li>As noticed in a previous new project, when you create a new project, there is code that comes with it, the <code>Greeting()</code> function; you can go ahead and delete that code.</li>
<li>After deleting that code, let us go ahead and create a <code>sealed</code> class in the main package directory and call it <code>Destination.kt</code>, where we will define our <code>route</code> string, <code>icon:</code> <code>Int</code>, and <code>title: String</code> for our bottom navigation items:<pre class="source-code">
sealed class Destination(val route: String, val icon: Int, val title: String) {...}</pre></li>
</ol>
<p>Strictly speaking, we might not need the <code>sealed</code> class, but it is a nicer way to implement navigation. A <code>sealed</code> class in Kotlin represents a restricted class hierarchy that provides more control over inheritance. Alternatively, you can think of it as a class that, in its value, can have one of the types from a limited set, but it cannot have any other types.</p>
<ol>
<li value="4">Inside the <code>sealed</code> class, now let’s go ahead and create our destinations. For our <a id="_idIndexMarker277"/>sample, we <a id="_idIndexMarker278"/>will assume we are creating a budgeting app. Hence, the destinations we can have are <code>Transactions</code>, <code>Budgets</code>, <code>Tasks</code>, and <code>Settings</code>. See the next step on how to get the icons; in addition, you will need to import them. For good practice, you can extract the <code>String</code> resource and save it in the <code>String</code> XML file. You can try this as a small exercise:<pre class="source-code">
sealed class Destination(val route: String, val icon: Int, val title: String) {</pre><pre class="source-code">
    object Transaction : Destination(</pre><pre class="source-code">
        route = "transactions", icon =</pre><pre class="source-code">
            R.drawable.ic_baseline_wallet,</pre><pre class="source-code">
            title = "Transactions"</pre><pre class="source-code">
    )</pre><pre class="source-code">
    object Budgets : Destination(</pre><pre class="source-code">
        route = "budget", icon =</pre><pre class="source-code">
            R.drawable.ic_baseline_budget,</pre><pre class="source-code">
            title = "Budget"</pre><pre class="source-code">
    )</pre><pre class="source-code">
    object Tasks : Destination(route = "tasks", icon =</pre><pre class="source-code">
        R.drawable.ic_add_task, title = "Tasks")</pre><pre class="source-code">
    object Settings : Destination(</pre><pre class="source-code">
        route = "settings", icon =</pre><pre class="source-code">
            R.drawable.ic_settings,</pre><pre class="source-code">
            title = "Settings"</pre><pre class="source-code">
    )</pre><pre class="source-code">
    companion object {</pre><pre class="source-code">
        val toList = listOf(Transaction, Budgets,</pre><pre class="source-code">
        Tasks, Settings)</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>For the icons, you <a id="_idIndexMarker279"/>can access them easily <a id="_idIndexMarker280"/>but clicking on the resource folder (<code>res</code>), then navigating to <strong class="bold">Vector Assets</strong> | <strong class="bold">Clip Art</strong>, which will launch and bring up free icons that you can use, as shown in <em class="italic">Figure 4</em><em class="italic">.1</em>:</li>
</ol>
<div><div><img alt="Figure 4.1 – How to access Vector Asset" src="img/Figure_4.1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – How to access Vector Asset</p>
<ol>
<li value="6">You can <a id="_idIndexMarker281"/>also upload an SVG file and access it through <strong class="bold">Asset Studio</strong>. For more <a id="_idIndexMarker282"/>icons, you can check out this link: <a href="https://fonts.google.com/icons">https://fonts.google.com/icons</a>.</li>
</ol>
<div><div><img alt="Figure 4.2 – Asset Studio" src="img/Figure_4.2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Asset Studio</p>
<ol>
<li value="7">Now, for the destinations we just added, let’s go ahead and add dummy text to verify that, indeed, when we navigate, we are on the right screen. Create a new file and <a id="_idIndexMarker283"/>name it <code>AppContent.kt</code>. Inside <code>AppContent</code>, we will add our <code>Transaction</code> function, which <a id="_idIndexMarker284"/>will be our home screen, where new users enter the app the first time; then later, they can navigate to other screens:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun Transaction(){</pre><pre class="source-code">
    Column(</pre><pre class="source-code">
        modifier = Modifier</pre><pre class="source-code">
            .fillMaxSize()</pre><pre class="source-code">
            .wrapContentSize(Alignment.Center)</pre><pre class="source-code">
    ) {</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Go ahead and add the remaining three screens, <code>Task</code>, <code>Budget</code>, and <code>Settings</code>, using the same composable pattern.</li>
<li>We <a id="_idIndexMarker285"/>now need to create a bottom navigation bar composable and tell the <code>Composable</code> function <a id="_idIndexMarker286"/>how to react when clicked, and also restore the state when re-selecting a previously selected item:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun BottomNavigationBar(navController: NavController, appItems: List&lt;Destination&gt;) {</pre><pre class="source-code">
    BottomNavigation(</pre><pre class="source-code">
        backgroundColor = colorResource(id =</pre><pre class="source-code">
            R.color.purple_700),</pre><pre class="source-code">
            contentColor = Color.White</pre><pre class="source-code">
    ) {</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now, let’s go to <code>MainActivity</code> and create <code>NavHost</code> and a few composable functions, <code>AppScreen()</code>, <code>AppNavigation()</code>, and <code>BottomNavigationBar()</code>. Each nav controller must be associated with a single nav host composable because it connects the controller with a nav graph that helps specify the composable directions:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun AppNavigation(navController: NavHostController) {</pre><pre class="source-code">
    NavHost(navController, startDestination =</pre><pre class="source-code">
    Destination.Transaction.route) {</pre><pre class="source-code">
        composable(Destination.Transaction.route) {</pre><pre class="source-code">
            Transaction()</pre><pre class="source-code">
        }</pre><pre class="source-code">
        composable(Destination.Budgets.route) {</pre><pre class="source-code">
            Budget()</pre><pre class="source-code">
        }</pre><pre class="source-code">
        composable(Destination.Tasks.route) {</pre><pre class="source-code">
            Tasks()</pre><pre class="source-code">
        }</pre><pre class="source-code">
        composable(Destination.Settings.route) {</pre><pre class="source-code">
            Settings()</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, let’s go <a id="_idIndexMarker287"/>ahead and glue everything together by creating another composable <a id="_idIndexMarker288"/>function and calling it <code>AppScreen()</code>. We will call this function inside <code>setContent</code> in the <code>onCreate()</code> function:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun AppScreen() {</pre><pre class="source-code">
    val navController = rememberNavController()</pre><pre class="source-code">
    Scaffold(</pre><pre class="source-code">
        bottomBar = {</pre><pre class="source-code">
            BottomNavigationBar(navController =</pre><pre class="source-code">
            navController, appItems =</pre><pre class="source-code">
            Destination.toList) },</pre><pre class="source-code">
        content = { padding -&gt;</pre><pre class="source-code">
            Box(modifier = Modifier.padding(padding))</pre><pre class="source-code">
            {</pre><pre class="source-code">
                AppNavigation(navController =</pre><pre class="source-code">
                    navController)</pre><pre class="source-code">
            }</pre><pre class="source-code">
        }</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>Then, call this <a id="_idIndexMarker289"/>created function inside <code>setContent{}</code>; the import should be <code>import androidx.activity.compose.setContent</code>, based on the fact that <a id="_idIndexMarker290"/>sometimes it might happen that you import the wrong one. Run the application. You will notice a screen with four tabs, and when you select a tab, the selected one gets highlighted, as shown in <em class="italic">Figure 4</em><em class="italic">.3</em>:</li>
</ol>
<div><div><img alt="Figure 4.3 – The bottom na﻿vigation bar" src="img/Figure_4.3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The bottom na<a id="_idTextAnchor198"/>vigation bar</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor199"/>How it works…</h2>
<p>In Compose, navigation has a crucial term called <strong class="bold">route</strong>. The key is the string that defines the pathway to your <a id="_idIndexMarker291"/>composable. The key basically is the source of truth – or think of it as a deep link that takes you to a specific destination, and each destination should have a unique route.</p>
<p>Furthermore, each <a id="_idIndexMarker292"/>destination should consist of a unique key route. In our example, we added <a id="_idIndexMarker293"/>icons and a title. The icons, as seen in <em class="italic">Figure 4</em><em class="italic">.3</em>, show what the bottom navigation entails, and the title describes the specific screen we are browsing at that exact time. In addition, these are optional and only needed for some routes.</p>
<p><code>NavController()</code> is the main API for our navigation component, and it keeps track of every back stack entry for the composables that make up the screens in our application and the state of each screen. We created this using <code>rememberNavController</code>: as we mentioned in the previous chapter, <code>remember</code>, as the name suggests, remembers the value; in this instance, we are remembering <code>NavController</code>:</p>
<pre class="source-code">
val navController = rememberNavController()</pre>
<p><code>NavHost()</code>, on the other hand, requires the <code>NavController()</code> previously created through <code>rememberNavController()</code> and the destination route of the entry point of our graph. In addition, <code>rememberNavController()</code> returns <code>NavHostController</code>, which is a subclass of <code>NavController()</code> that offers some additional APIs that <code>NavHost</code> requires.</p>
<p>This is very <a id="_idIndexMarker294"/>similar to how <a id="_idIndexMarker295"/>Android developers build navigation before composing fragments. The steps include creating a bottom navigation menu with the <code>menu</code> items, as shown in the following code block:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu &gt;
    &lt;item
        android:id="@+id/transaction_home"
        android:icon="@drawable/card"
        android:title="@string/transactions"/&gt;
    &lt;item
         android:id="@+id/budget_home"
         android:icon="@drawable/ic_shopping_basket_black_
             24dp"
         android:title="@string/budgets"
    /&gt;
...
&lt;/menu&gt;</pre>
<p>Then, we <a id="_idIndexMarker296"/>create another <a id="_idIndexMarker297"/>resource in the <code>navigation</code> package that points to the screens (fragments):</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;navigation 
    app:startDestination="@+id/transaction_home"&gt;
    &lt;fragment
        android:id="@+id/transaction_home"
        android:name="com.fragments.TransactionsFragment"
        android:label="@string/title_transcation"
        tools:layout="@layout/fragment_transactions" &gt;
        &lt;action
            android:id="@+id/action_transaction_home_to_
                budget_home"
            app:destination="@id/budget_home" /&gt;
    &lt;/fragment&gt;
    &lt;fragment
        android:id="@+id/budget_home"
        android:name="com.fragments.BudgetsFragment"
        android:label="@string/title_budget"
        tools:layout="@layout/fragment_budget" &gt;
        &lt;action
            android:id="@+id/action_budget_home_to_tasks_
                home"
            app:destination="@id/tasks_home" /&gt;
    &lt;/frag<a id="_idTextAnchor200"/>ment&gt;
&lt;/navigation&gt;</pre>
<h1 id="_idParaDest-116"><a id="_idTextAnchor201"/>Navigating to a new screen in Compose</h1>
<p>We will build a register screen prompt on our login page for registering first-time users of our application. This is <a id="_idIndexMarker298"/>a standard pattern because we need <a id="_idIndexMarker299"/>to save the user’s credentials so that the next time they log in to our application, we just log them in witho<a id="_idTextAnchor202"/>ut registering again.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor203"/>Getting ready</h2>
<p>You should have completed the previous recipe, <em class="italic">Implementing a bottom navigation bar using navigation destinations</em>, before getting s<a id="_idTextAnchor204"/>tarted with this one.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor205"/>How to do it…</h2>
<p>In this recipe, we will need to use our <code>SampleLogin</code> project and add a new screen that users can navigate to if it is their first time using the application. This is a typical use case in many applications:</p>
<ol>
<li>Open your <code>SampleLogin</code> project, create a new <code>sealed</code> class, and call it <code>Destination</code>. To also ensure we maintain great packaging, add this class to <code>util</code>. Also, just like the bottom bar, we will have a route, but this time, we do not need any icons or titles:<pre class="source-code">
sealed class Destination (val route: String){</pre><pre class="source-code">
    object Main: Destination("main_route")</pre><pre class="source-code">
    object LoginScreen: Destination("login_screen")</pre><pre class="source-code">
    object RegisterScreen:</pre><pre class="source-code">
        Destination("register_screen")</pre><pre class="source-code">
}</pre></li>
<li>After creating the destinations, we now need to go ahead and add clickable text in <code>LoginContent</code> to ask users whether it is their first time using the application. They <a id="_idIndexMarker300"/>should click <code>RegisterContent</code>. You can open the project by checking out the <em class="italic">Technical requirements</em> section if you need to refer to any step:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun LoginContent(</pre><pre class="source-code">
    ...</pre><pre class="source-code">
    onRegister: () -&gt; Unit</pre><pre class="source-code">
) {</pre><pre class="source-code">
ClickableText(</pre><pre class="source-code">
    modifier = Modifier.padding(top = 12.dp),</pre><pre class="source-code">
    text = AnnotatedString(stringResource(id =</pre><pre class="source-code">
        R.string.register)),</pre><pre class="source-code">
    onClick = { onRegister.invoke() },</pre><pre class="source-code">
    style = TextStyle(</pre><pre class="source-code">
       colorResource(id = R.color.purple_700),</pre><pre class="source-code">
       fontSize = 16.sp</pre><pre class="source-code">
    )</pre><pre class="source-code">
)</pre></li>
<li>Now, when you click on <code>ClickableText</code>, our clickable text is text that you can click, and it will help users navigate to the registration screen via <strong class="bold">First-time user? Sign UP</strong>. Once you click on this, it should navigate to a different screen where users can now sign up, as shown in <em class="italic">Figure 4</em><em class="italic">.4</em>:</li>
</ol>
<div><div><img alt="Figure 4.4 – A new Register screen" src="img/Figure_4.4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – A new Register screen</p>
<ol>
<li value="4">For the <strong class="bold">Register</strong> screen, you can get the entire code in the <em class="italic">Technical requirements</em> section. We <a id="_idIndexMarker302"/>will reuse the user input fields <a id="_idIndexMarker303"/>that we created and just change the text:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun PasswordInputField(</pre><pre class="source-code">
    text: String</pre><pre class="source-code">
) {</pre><pre class="source-code">
    OutlinedTextField(</pre><pre class="source-code">
        label = { Text(text = text) },</pre><pre class="source-code">
...</pre><pre class="source-code">
}</pre></li>
<li>In <code>MainActivity</code>, we <a id="_idIndexMarker304"/>will have a <code>Navigation()</code> function, <a id="_idIndexMarker305"/>as follows:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun Navigation(navController: NavHostController) {</pre><pre class="source-code">
    NavHost(navController, startDestination =</pre><pre class="source-code">
    Destination.LoginScreen.route) {</pre><pre class="source-code">
        composable(Destination.LoginScreen.route) {</pre><pre class="source-code">
            LoginContentScreen(loginViewModel =</pre><pre class="source-code">
                hiltViewModel(),</pre><pre class="source-code">
            onRegisterNavigateTo = {</pre><pre class="source-code">
                navController.navigate(</pre><pre class="source-code">
                    Destination.RegisterScreen.route)</pre><pre class="source-code">
            })</pre><pre class="source-code">
        }</pre><pre class="source-code">
        composable(Destination.RegisterScreen.route) {</pre><pre class="source-code">
            RegisterContentScreen(registerViewModel =</pre><pre class="source-code">
                hiltViewModel())</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>In <code>PasswordInputField</code>, we will name each input appropriately for reusability:<pre class="source-code">
PasswordInputField(</pre><pre class="source-code">
    text = stringResource(id = R.string.password),</pre><pre class="source-code">
    authState = uiState,</pre><pre class="source-code">
    onValueChanged = onPasswordUpdated,</pre><pre class="source-code">
    passwordToggleVisibility =</pre><pre class="source-code">
        passwordToggleVisibility)</pre></li>
<li>Moreover, you <a id="_idIndexMarker306"/>can also navigate to the previous <strong class="bold">Sign in</strong> screen <a id="_idIndexMarker307"/>by clicking on the hardware <strong class="bold">Back</strong> button.</li>
<li>Finally, in <code>setContent</code>, we will need to update the code to accommodate the new navigation:<pre class="source-code">
@AndroidEntryPoint</pre><pre class="source-code">
class MainActivity : ComponentActivity() {</pre><pre class="source-code">
    override fun onCreate(savedInstanceState: Bundle?)</pre><pre class="source-code">
    {</pre><pre class="source-code">
        super.onCreate(savedInstanceState)</pre><pre class="source-code">
        setContent {</pre><pre class="source-code">
            SampleLoginTheme {</pre><pre class="source-code">
                // A surface container using the</pre><pre class="source-code">
                   'background' color from the theme</pre><pre class="source-code">
                Surface(</pre><pre class="source-code">
                    modifier = Modifier.fillMaxSize(),</pre><pre class="source-code">
                    color =</pre><pre class="source-code">
                       MaterialTheme.colors.background</pre><pre class="source-code">
                ) {</pre><pre class="source-code">
                    val navController =</pre><pre class="source-code">
                        rememberNavController()</pre><pre class="source-code">
                    Navigation(navController =</pre><pre class="source-code">
                        navController)</pre><pre class="source-code">
                }</pre><pre class="source-code">
            }</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Run the code and click on the <strong class="bold">Sign up</strong> text, and you should n<a id="_idTextAnchor206"/>ow be taken to a new screen.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor207"/>How it works…</h2>
<p>You will notice that we have just created a different destination entry point, where <code>ClickableText</code> is used to navigate to the newly created screen. Furthermore, in order to navigate to a composable destination in the nav graph, you must use <code>navController.navigate(Destination.RegisterScreen.route)</code>, and as mentioned earlier, the string represents the destination route.</p>
<p>In addition, <code>navigate()</code> adds our destination to the back stack by default, but if we need to <a id="_idIndexMarker308"/>modify the behavior, we can easily do that by <a id="_idIndexMarker309"/>adding additional nav options to our <code>navigate()</code> call.</p>
<p>Suppose you want to work with animations when navigating. In that case, you can easily do that by <a id="_idIndexMarker310"/>using the Accompanist library – <a href="https://github.com/google/accompanist">https://github.com/google/accompanist</a> –which offers a group of libraries that aim to supplement Jetpack Compose with features that are required mainly by developers and are not available yet.</p>
<p>You can utilize <code>enterTransition</code>, which explicitly specifies the animation that runs when you navigate to a particular destination, whereas <code>exitTransition</code> does the opposite:</p>
<pre class="source-code">
AnimatedNavHost(
    modifier = Modifier
        .padding(padding),
    navController = navController,
    startDestination = Destination.LoginScreen.route,
    route = Destination.LoginScreen.route,
    enterTransition = { fadeIn(animationSpec = tween(2000)) },
    exitTransition = { fadeOut(animationSpec = tween(200))
    }
)</pre>
<p>You can also <a id="_idIndexMarker311"/>use <code>popEnterTransition</code>, which <a id="_idIndexMarker312"/>specifies the animation that runs when the destination re-enters the screen after going through <code>popBackStack()</code>, or <code>popExitTranstion</code>, which does the opposite.</p>
<p class="callout-heading">Important note</p>
<p class="callout">It is crucial to note a good practice that becomes relevant for hoisting the state is when you expose events from your composable functions to callers in your application that know how to handle that logic properly. In addition, under-the-hood <a id="_idTextAnchor208"/>navigatio<a id="_idTextAnchor209"/>n is all state-managed.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor210"/>See also</h2>
<p>For more <a id="_idIndexMarker313"/>about <code>AnimatedNavHost</code>, you can find details here: <a href="https://google.github.io/accompanist/navigation-animation/">https://google.github.io/accompanist/navigation-animation/</a>.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor212"/>Navigating with arguments</h1>
<p>Passing data <a id="_idIndexMarker314"/>between destinations is very vital in Android development. The new Jetpack navigation allows developers to attach data to a navigation operation by defining an argument for a destination. Readers will learn how to pass data between destinations using arguments.</p>
<p>A good use case is, say, you load an API with data and want to show more description on the data you just displayed; you can navigate with u<a id="_idTextAnchor213"/>nique arguments to the next screen.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor214"/>Getting ready</h2>
<p>We will explore the most common interview project requirement, which is to fetch data from an API and display one screen and add an additional screen for extra points.</p>
<p>Let’s assume the API is the GitHub API, and you want to display all organizations. Then, you want to navigate to another screen and see the numbe<a id="_idTextAnchor215"/>r of repositories each company has.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor216"/>How to do it…</h2>
<p>For this recipe, we will look at an example of navigating with arguments as a concept since there is little more to do other than create the basic arguments to pass to utilize an already-built project – <code>SampleLogin</code>:</p>
<ol>
<li>Let’s go ahead and create <code>SearchScreen</code>, and this screen will have just a search function, <code>EditText</code>, and a column to display the data returned from an API:<pre class="source-code">
SearchScreen(</pre><pre class="source-code">
    viewModel = hiltViewModel(),</pre><pre class="source-code">
    navigateToRepositoryScreen = { orgName -&gt;</pre><pre class="source-code">
        navController.navigate(</pre><pre class="source-code">
            Destination.BrowseRepositoryScreen.route +</pre><pre class="source-code">
            "/" + orgName</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre><pre class="source-code">
)</pre></li>
<li>And now, when setting up navigation to <code>BrowseRepository</code>, you will need to add the <a id="_idIndexMarker315"/>following code. This piece of code is for passing a mandatory data parameter from one screen to another, but adding the example of passing an optional argument; a default value will help the user:<pre class="source-code">
composable(</pre><pre class="source-code">
    route = Destination.BrowseRepositoryScreen.route +</pre><pre class="source-code">
            "/{org_name}",</pre><pre class="source-code">
    arguments = listOf(navArgument("org_name") { type</pre><pre class="source-code">
        = NavType.StringType }),</pre><pre class="source-code">
    enterTransition = { scaleIn(tween(700)) },</pre><pre class="source-code">
    exitTransition = { scaleOut(tween(700)) },</pre><pre class="source-code">
) {</pre><pre class="source-code">
    BrowseRepositoryScreen(</pre><pre class="source-code">
        viewModel = hiltViewModel(),</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
</ol>
<p>We also use the <code>enter</code> and <code>exit</code> transition for animations. In this recipe, we have just touched on the concept of navigating with arguments, wh<a id="_idTextAnchor217"/>ich can be applied to many projects.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor218"/>How it works…</h2>
<p>When you want to pass an argument to the destination, which is something that might be required, you need <a id="_idIndexMarker316"/>to explicitly attach it to the route when initiating the <code>navigate</code> function call, as you can see in the following code snippet:</p>
<pre class="source-code">
navController.navigate(Destination.BrowseScreen.route + "/" + orgName)</pre>
<p>We added an argument placeholder to our route, similar to how we added arguments to a deep link when using the base navigation library.</p>
<p>There is also a list of what the navigation library supports; if you have a different use case, you can look into this document: <a href="https://developer.android.com/guide/navigation/navigation-pass-data#supported_argument_types">https://developer.android.com/guide/navigation/navigation-pass-data#supported_argument_types</a>.</p>
<div><div><img alt="Figure 4.5 – Navigation support argument t﻿ype (credit: developers.android.com)" src="img/Figure_4.5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Navigation support argument t<a id="_idTextAnchor219"/>ype (credit: developers.android.com)</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor220"/>There’s more…</h2>
<p>There is more to learn about navigation and, for a more thorough way to look into how you can navigate with arguments, retrieve complex data when navigating, and add additional <a id="_idIndexMarker317"/>arguments in depth, you can read more here: <a href="https://developer.android.com/jetpack/compose/navigation">https://developer.android.com/jetpack/compose/navigation</a>.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor222"/>Creating deep links for destinations</h1>
<p>In Modern Android <a id="_idIndexMarker318"/>Development, deep links are very vital. A link that helps you navigate directly to a specific destination within an app is called a <code>Navigation</code> component lets you create two types of deep links: <strong class="bold">explicit</strong> and <strong class="bold">implicit</strong>.</p>
<p>Compose navigation <a id="_idIndexMarker319"/>supports implicit deep links, which can be part of your Composable functions. It is also fair <a id="_idIndexMarker320"/>to mention there is no huge difference between how y<a id="_idTextAnchor223"/>ou would handle these using XML layouts.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor224"/>Getting ready</h2>
<p>Since we don’t have a deep link use case in our application, in this recipe, we will look into how we can utilize the knowledge by learni<a id="_idTextAnchor225"/>ng how to implement implicit deep links.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor226"/>How to do it…</h2>
<p>You can <a id="_idIndexMarker321"/>match deep links using a <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URI</strong>), intent actions, or <strong class="bold">Multipurpose Internet Mail Extensions</strong> (<strong class="bold">MIME</strong>) types. Furthermore, you can easily specify multiple types that match for <a id="_idIndexMarker322"/>a deep link single but remember that the URI argument comparison is always prioritized, followed by the intent action, then the MIME type.</p>
<p>Compose has made it easier for developers to work with deep links. The <code>composable</code> function accepts a parameter list of <code>NavDeepLinks</code>, which can be easily created using the <code>navDeepLink</code> method:</p>
<ol>
<li>We will start by making the deep link externally available by adding the appropriate intent filter to our <code>AndroidManifest.xml</code> file:<pre class="source-code">
&lt;activity&gt;</pre><pre class="source-code">
    &lt;intent-filter&gt;</pre><pre class="source-code">
      ...</pre><pre class="source-code">
      &lt;data android:scheme="https"</pre><pre class="source-code">
      android:host="www.yourcompanieslink.com" /&gt;</pre><pre class="source-code">
    &lt;/intent-filter&gt;</pre><pre class="source-code">
&lt;/activity&gt;</pre></li>
<li>Now in our <code>composable</code> function, we can use the <code>deepLinks</code> parameter, specify the list of <code>navDeepLink</code>, and then pass the URI pattern:<pre class="source-code">
val uri = "www.yourcompanieslink.com"</pre><pre class="source-code">
composable(deepLinks = listOf(navDeepLink { uriPattern = "$uri/{id}" }))</pre><pre class="source-code">
{...}</pre></li>
<li>Please note that navigation will automatically deep-link into that composable when another application triggers the deep link.</li>
</ol>
<p>Many <a id="_idIndexMarker323"/>applications still use <code>launchMode</code> when navigating. This is when using the Navigation Jetpack component, as seen in the following code snippet:</p>
<pre class="source-code">
override fun onNewIntent(intent: Intent) {
    super.onNewIntent(intent)
    navigationController.handleDeepLink(intent)
}</pre>
<ol>
<li value="4">Finally, you can also utilize <code>deepLinkPendingIntent</code> like any other <code>PendingIntent</code> to start your Android application at the deep link destination.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">When triggering an implicit deep link, the back stack state depends on when the implicit intent was launched with <code>Intent.FLAG_ACTIVITY_NEW_TASK</code>. Furthermore, if the flag is set, the back stack task is cleared and then replac<a id="_idTextAnchor227"/>ed with the intended deep link destination.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor228"/>How it works…</h2>
<p>In Android development, a deep link refers to a specific destination for the application. For instance, when you invoke the deep link, the link opens up your application’s corresponding destination when a user clicks on the specified link.</p>
<p>This refers to <a id="_idIndexMarker324"/>where the link is meant to lead once clicked. The explicit deep link is a single instance that uses <code>PendingIntent</code> to take users to a specific location within your application. A good use case<a id="_idTextAnchor229"/> is when using notifications or app widgets.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor230"/>There’s more…</h2>
<p>There is more to learn about deep links; for instance, how to create an explicit deep link. You can learn more about deep links here: <a href="https://developer.android.com/training/app-links/deep-linking">https://developer.android.com/training/app-links/deep-linking</a>.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor231"/>Writing tests for navigation</h1>
<p>Now that we <a id="_idIndexMarker325"/>have created a new screen for our <code>SampleLogin</code> project, we <a id="_idIndexMarker326"/>need to fix the broken test and add new tests for the UI package. If you can recall, in <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and Using Hilt</em>, we did unit tests and not UI tests. This means after adding all the <code>ViewModel</code> instances, our UI tests are now broken. In this recipe, we will fi<a id="_idTextAnchor232"/>x the failing tests and add a navigation test.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor233"/>Getting ready</h2>
<p>In this recipe, you do not need to create any new project;<a id="_idTextAnchor234"/> use the already-created project, <code>SampleLogin</code>.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor235"/>How to do it…</h2>
<p>You can apply these concepts to test the bottom navigation bar we created. Hence, we will not be writing tests for the <code>BottomNavigationBarSample</code> project. Open <code>SampleLogin</code> and navigate to the <code>androidTest</code> package. We will add tests here for the new <code>RegisterScreen()</code> a Composable function, and also fix the broken tests:</p>
<ol>
<li>Let’s open <a id="_idIndexMarker327"/>the <code>LoginContentTest</code> class. Now, let’s <a id="_idIndexMarker328"/>move the <code>LoginContent</code> class to a helper class that we will create to help us with testing the UI logic:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun contentLoginForTest(</pre><pre class="source-code">
    uiState: AuthenticationState =</pre><pre class="source-code">
    AuthenticationState(),</pre><pre class="source-code">
    onUsernameUpdated : (String) -&gt; Unit = {},</pre><pre class="source-code">
    onPasswordUpdated :(String) -&gt; Unit = {},</pre><pre class="source-code">
    onLogin : () -&gt; Unit = {},</pre><pre class="source-code">
    passwordToggleVisibility: (Boolean) -&gt; Unit = {},</pre><pre class="source-code">
    onRegisterNavigateTo: () -&gt; Unit = {}</pre><pre class="source-code">
) {</pre><pre class="source-code">
    LoginContent(</pre><pre class="source-code">
        uiState = uiState,</pre><pre class="source-code">
        onUsernameUpdated = onUsernameUpdated,</pre><pre class="source-code">
        onPasswordUpdated = onPasswordUpdated,</pre><pre class="source-code">
        onLogin = onLogin,</pre><pre class="source-code">
        passwordToggleVisibility =</pre><pre class="source-code">
            passwordToggleVisibility,</pre><pre class="source-code">
        onRegister = onRegisterNavigateTo</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>Inside the <code>LoginContentTest</code> class, now, we will replace <code>LoginContent</code> with the newly created <code>contentLoginForTest()</code> function inside the <code>initCompose</code> function:<pre class="source-code">
private fun initCompose() {</pre><pre class="source-code">
    composeRuleTest.activity.setContent {</pre><pre class="source-code">
        SampleLoginTheme {</pre><pre class="source-code">
            contentLoginForTest()</pre><pre class="source-code">
            launchRegisterScreenWithNavGraph()</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now that <a id="_idIndexMarker329"/>we have fixed the tests, we can now add a <code>test</code> tag <a id="_idIndexMarker330"/>for our newly created clickable, <code>TextView</code>:<pre class="source-code">
const val REGISTER_USER = "register_user"</pre></li>
<li>Once that is done, we now need to create <code>lateint var NavHostController</code>, and a <code>launchRegisterScreenWithNavGraph</code> function to help us set up the navigation:<pre class="source-code">
private fun launchRegisterScreenWithNavGraph() {</pre><pre class="source-code">
    composeRuleTest.activity.setContent {</pre><pre class="source-code">
        SampleLoginTheme {</pre><pre class="source-code">
            navController = rememberNavController()</pre><pre class="source-code">
            NavHost(</pre><pre class="source-code">
                navController = navController,</pre><pre class="source-code">
                startDestination =</pre><pre class="source-code">
                    Destination.LoginScreen.route</pre><pre class="source-code">
            ) {</pre><pre class="source-code">
                composable(Destination.LoginScreen</pre><pre class="source-code">
                .route) {</pre><pre class="source-code">
                LoginContentScreen(</pre><pre class="source-code">
                onRegisterNavigateTo = {</pre><pre class="source-code">
                    navController.navigate(</pre><pre class="source-code">
                        Destination.RegisterScreen</pre><pre class="source-code">
                        .route)</pre><pre class="source-code">
                }, loginViewModel = hiltViewModel())</pre><pre class="source-code">
                }</pre><pre class="source-code">
                composable(</pre><pre class="source-code">
                    Destination.RegisterScreen</pre><pre class="source-code">
                    .route) {</pre><pre class="source-code">
                        RegisterContentScreen(</pre><pre class="source-code">
                            hiltViewModel())</pre><pre class="source-code">
                    }</pre><pre class="source-code">
            }</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
</ol>
<p>You can call the <a id="_idIndexMarker331"/>created function inside the <code>initCompose</code> function <a id="_idIndexMarker332"/>or in the new test function that we will create.</p>
<ol>
<li value="5">Now, let’s create a test function and name it <code>assertRegisterClickableButtonNavigatesToRegisterScreen()</code>. In this test case, we will set our route and then use <code>assert</code> when the correct <code>TextView</code> is clicked; we will navigate to the correct destination:<pre class="source-code">
@Test</pre><pre class="source-code">
fun assertRegisterClickableButtonNavigatesToRegisterScreen() {</pre><pre class="source-code">
    initCompose()</pre><pre class="source-code">
    composeRuleTest.onNodeWithTag(</pre><pre class="source-code">
        TestTags.LoginContent.REGISTER_USER)</pre><pre class="source-code">
            .performClick(</pre><pre class="source-code">
    )</pre><pre class="source-code">
    val route =</pre><pre class="source-code">
        navController.currentDestination?.route</pre><pre class="source-code">
    assert(route.equals(</pre><pre class="source-code">
        Destination.RegisterScreen.route))</pre><pre class="source-code">
}</pre></li>
<li>Finally, run <a id="_idIndexMarker333"/>the test, and the UI test should pass,<a id="_idTextAnchor236"/> as <a id="_idIndexMarker334"/>seen in <em class="italic">Figure 4</em><em class="italic">.6</em>:</li>
</ol>
<div><div><img alt="Figure 4.6 – Tests passing" src="img/Figure_4.6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Tests passing</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor237"/>How it works…</h2>
<p>We created the <code>contentLoginForTest</code> that can help us verify our navigation. That is, when a user <a id="_idIndexMarker335"/>enters a valid username and password, they can <a id="_idIndexMarker336"/>navigate to a home screen. Furthermore, we created <code>launchRegisterScreenWithNavGraph()</code>, a helper function that creates the testing graph for our navigation test case.</p>
<p>If you are using <code>FragmentScenario</code>, there are great tips for testing your navigation that you <a id="_idIndexMarker337"/>can see here: <a href="https://developer.android.com/guide/navigation/navigation-testing">https://developer.android.com/guide/navigation/navigation-testing</a>.</p>
</div>
</body></html>