<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Activities</h1></div></div></div><p>This chapter covers the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Declaring an activity</li><li class="listitem" style="list-style-type: disc">Starting a new activity with an intent object</li><li class="listitem" style="list-style-type: disc">Switching between activities</li><li class="listitem" style="list-style-type: disc">Passing data to another activity</li><li class="listitem" style="list-style-type: disc">Returning a result from an activity</li><li class="listitem" style="list-style-type: disc">Saving an activity's state</li><li class="listitem" style="list-style-type: disc">Storing persistent activity data</li><li class="listitem" style="list-style-type: disc">Understanding the activity lifecycle</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>The Android SDK provides a powerful tool to program mobile devices, and the best way to master such a tool is to jump right in. Though you can read this book from beginning to end, as it is a cookbook, it is specifically designed to allow you to jump to specific tasks and get the results immediately.</p><p>
<strong>Activities</strong> <a id="id0" class="indexterm"/>are the fundamental building block of most Android applications as the activity class provides the interface between the application and screen. Most Android applications will have at least one activity, if not several (but they are not required). A background service application will not necessarily require an activity if there is no user interface.</p><p>This chapter explains how to <em>declare</em> and <em>launch</em> activities within an application and how to manage several activities at once by sharing data between them, requesting results from them, and calling one activity from within another.</p><p>This chapter also briefly explores the<a id="id1" class="indexterm"/> <strong>intent</strong> object, which is often used in conjunction with activities. Intents can be used to transfer data between activities in your own application, as well as in external applications, such as those included with the Android operating system (a common example would be to use an intent to launch the default web browser).</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>To begin developing Android applications, head over to the <strong>Android Studio</strong> page to download the new Android Studio IDE and the <a id="id2" class="indexterm"/>
<strong>Android SDK</strong> bundle:</p><p>
<a class="ulink" href="http://developer.android.com/sdk/index.html">http://developer.android.com/sdk/index.html</a>
</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Declaring an activity</h1></div></div></div><p>Activities and other<a id="id3" class="indexterm"/> application components, such as <a id="id4" class="indexterm"/>
<strong>services</strong>, are declared in the <code class="literal">AndroidManifest</code> XML file. Declaring an activity is how we tell the system about our activity and how it can be requested. For example, an application will usually indicate that at least one activity should be visible as a desktop icon and serve as the main entry point to the application.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Getting ready</h2></div></div></div><p>Android Studio is the new tool used to develop Android applications, replacing the now-deprecated <a id="id5" class="indexterm"/>
<strong>Eclipse ADT</strong> solution. Android Studio will be used for all the recipes shown in this book, so if you have not already installed it, visit the Android Studio website (the link has been provided earlier) to install the IDE and the SDK bundle.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How to do it...</h2></div></div></div><p>For this first example, we'll guide you through creating a new project. Android Studio provides a <strong>Quick Start</strong> wizard, which makes the process extremely easy. Follow these steps to get started:</p><div><ol class="orderedlist arabic"><li class="listitem">Launch Android Studio, which brings up the <strong>Welcome to Android Studio</strong> dialog.</li><li class="listitem">Click on the <strong>Start a new Android Studio project</strong> option.</li><li class="listitem">Enter an application name; for this example, we have used <code class="literal">DeclareAnActivity</code>. Click on <strong>Next</strong>.</li><li class="listitem">On the <strong>Add an Activity to Mobile</strong> dialog, click on the <strong>Blank Activity</strong> button, and then click on <strong>Next</strong>.</li><li class="listitem">On the <strong>Target Android Devices</strong> dialog, chose <strong>Android 6.0 (API 23)</strong> as the minimum SDK (for this example, it really doesn't matter which API level you chose, as activities have existed since API level 1, but choosing the latest release is considered to be the best practice). Click on <strong>Next</strong>.</li><li class="listitem">Since we chose the <strong>Blank Activity</strong> option earlier, the <strong>Customize the Activity</strong> dialog is shown. You can leave the defaults as provided, but note the default activity name is <code class="literal">MainActivity</code>. Click on <strong>Finish</strong>.</li></ol></div><p>After <a id="id6" class="indexterm"/>finishing the wizard, Android Studio will create the project files. For this recipe, the two files that we will examine are <code class="literal">MainActivity.java</code> (which corresponds to the activity name mentioned in Step 6) and <code class="literal">AndroidManifest.xml</code>.</p><p>If you take a look at the <code class="literal">MainActivity.java</code> file, you will realize that it's pretty basic. This is because we chose the <strong>Blank Activity</strong> option (in Step 4). Now look at the <code class="literal">AndroidManifest.xml</code> file. This is where we actually declare the activity. Within the <code class="literal">&lt;application&gt;</code> element is the <code class="literal">&lt;activity&gt;</code> element:</p><div><pre class="programlisting">
<strong>&lt;activity</strong>
    android:name=".MainActivity"
    android:label="@string/app_name"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN"/&gt;

        &lt;category android:name="android.intent.category.LAUNCHER"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</pre></div><div><div><h3 class="title"><a id="note03"/>Note</h3><p>When viewing this <code class="literal">xml</code> within Android Studio, you may notice that the label element shows the actual text as defined in the <code class="literal">strings.xml</code> resource file. This is just a small example of enhancements in the new IDE.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How it works...</h2></div></div></div><p>Declaring an activity is a simple matter of declaring the <code class="literal">&lt;activity&gt;</code> element and specifying the name of the activity class with the <code class="literal">android:name</code> attribute. By adding the <code class="literal">&lt;activity&gt;</code> element to the <a id="id7" class="indexterm"/>
<strong>Android Manifest</strong>, we are specifying our intention to include this component within our application. Any activities (or any other component for that matter) that are not declared in the manifest will not be included in the application. Attempting to access or utilize an undeclared component will result in an exception being thrown at runtime.</p><p>In the preceding code, there is another attribute—<code class="literal">android:label</code>. This attribute indicates the title<a id="id8" class="indexterm"/> shown on the screen as well as the icon label if this is the Launcher activity.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>For a complete list of available <a id="id9" class="indexterm"/>application attributes, take a look at this resource:</p><p>
<a class="ulink" href="http://developer.android.com/guide/topics/manifest/activity-element.html">http://developer.android.com/guide/topics/manifest/activity-element.html</a>
</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Starting a new activity with an intent object</h1></div></div></div><p>The <a id="id10" class="indexterm"/>Android application model can be seen as a <a id="id11" class="indexterm"/>service-oriented one, with activities as components and intents as the messages sent between them. Here, an intent is used to start an activity that displays the user's call log, but intents can be used to do many things and we will encounter them throughout this book.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Getting ready</h2></div></div></div><p>To keep things simple, we are going to use an intent object to start one of Android's built-in applications rather than create a new one. This only requires a very basic application, so start a new Android project with Android Studio and call it <code class="literal">ActivityStarter</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How to do it...</h2></div></div></div><p>Again, to keep the example simple so that we can focus on the task at hand, we will create a function to show an intent in action and call this function from a button on our activity.</p><p>Once your new project is created in Android Studio, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">MainActivity.java</code> class and add the following function:<div><pre class="programlisting">public void launchIntent(View view) {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse("https://www.packtpub.com/"));
    startActivity(intent);
}</pre></div><p>While you are typing this code, Android Studio will give this warning on View and intent: <strong>Cannot resolve symbol 'Intent'</strong>.</p><p>This <a id="id12" class="indexterm"/>means that you need to add<a id="id13" class="indexterm"/> the library reference to the project. You can do this manually by entering the following code in the <code class="literal">import</code> section:</p><div><pre class="programlisting">import android.view.View;

import android.content.Intent;</pre></div><p>Alternatively, just click on the words (in the red font), hit <em>Alt</em> + <em>Enter</em>, and let Android Studio add the library reference for you.</p></li><li class="listitem">Open the <code class="literal">activity_main.xml</code> file and add the following XML:<div><pre class="programlisting">&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Launch Browser"
    android:id="@+id/button"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    android:onClick="launchIntent"/&gt;</pre></div><div><img src="img/05057_01_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Now it's<a id="id14" class="indexterm"/> time to run the application<a id="id15" class="indexterm"/> and see the intent in action. You will need to either create an Android emulator (in Android Studio, go to <strong>Tools | Android | AVD Manager</strong>) or connect a physical device to your computer.</li><li class="listitem">When you press the <strong>Launch Browser</strong> button, you will see the default web browser open with the URL specified.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How it works...</h2></div></div></div><p>Though simple, this app demonstrates much of the power behind the Android OS. The intent object is just a message object. Intents can be used to communicate across your application's components (such as services and broadcast receivers) as well as with other applications on the device (as we did in this recipe).</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>To test on a physical device, you may need to install drivers for your device (the drivers are specific to the hardware manufacturer). You will also need to enable Developer Mode on your device. Enabling Developer Mode varies according to the Android OS version. If you do not see the Developer Mode option in your device settings, open the <strong>About Phone</strong> option and begin tapping <strong>Build Number</strong>. After three taps, you should see a <strong>Toast</strong> message<a id="id16" class="indexterm"/> telling you that you are on your way to be a developer. Four more taps will enable the option.</p></div></div><p>In this recipe, we created an intent object by specifying <code class="literal">ACTION_VIEW</code> as what we want to do (our intention). You may have noticed that when you typed <code class="literal">Intent</code> and then the period, Android Studio provided a pop-up list of possibilities (this is the autocomplete feature), like this:</p><div><img src="img/05057_01_02.jpg" alt="How it works..."/></div><p>
<code class="literal">ACTION_VIEW</code>, along with a URL in the data, indicates that the intention is to view the website, so the default browser is launched (different data could launch different apps). In this example, our intent is just to <a id="id17" class="indexterm"/>view the URL, so we call the intent with just <a id="id18" class="indexterm"/>the <code class="literal">startActivity()</code> method. There are other ways to call the intent depending on our needs. In the <em>Returning a result from an activity</em> recipe, we will use the <code class="literal">startActivityForResult()</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>There's more...</h2></div></div></div><p>It's very common for Android users to download their favorite apps for web browsing, taking photos, text messaging, and so on. Using intents, you can let your app utilize your user's favorite apps instead of trying to reinvent all of this functionality.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>See also</h2></div></div></div><p>To start an activity from a menu selection, refer to the <em>Handling menu selections</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Menus">Chapter 4</a>, <em>Menus</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Switching between activities</h1></div></div></div><p>Often we will want to <a id="id19" class="indexterm"/>activate one activity from within another activity. Although this is not a difficult task, it will require a little more setting up to be done than the previous recipes as it requires two activities. We will create two activity classes and declare them both in the manifest. We'll also create a button, as we did in the previous recipe, to switch to the activity.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Getting ready</h2></div></div></div><p>We'll create a new project in Android Studio, just as we did in the previous recipes, and call this one <code class="literal">ActivitySwitcher</code>. Android Studio will create the first activity, <code class="literal">ActivityMain</code>, and automatically declare it in the manifest.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Since the Android Studio <a id="id20" class="indexterm"/>New Project wizard has already created the first activity, we just need to create the second activity. Open the <strong>ActivitySwitcher</strong> project and navigate to <strong>File</strong> | <strong>New</strong> | <strong>Activity</strong> | <strong>Blank</strong> <strong>Activity</strong>, as shown in this screenshot:<div><img src="img/05057_01_03.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <a id="id21" class="indexterm"/><strong>Customize the Activity</strong> dialog, you can leave the default <strong>Activity Name</strong> as it is, which is <code class="literal">Main2Activity</code>, or change it to <code class="literal">SecondActivity</code>, as shown here:<div><img src="img/05057_01_04.jpg" alt="How to do it..."/></div></li><li class="listitem">Open the <code class="literal">MainActivity.java</code> file and add the following function:<div><pre class="programlisting">public void onClickSwitchActivity(View view) {
    Intent intent = new Intent(this, SecondActivity.class);
    startActivity(intent);
}</pre></div></li><li class="listitem">Now, open the <code class="literal">activity_main.xml</code> file located in the <code class="literal">\res\layout</code> folder and add the following XML to create the button:<div><pre class="programlisting">&lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    android:text="Launch SecondActivity"
    android:onClick="onClickSwitchActivity"/&gt;</pre></div></li><li class="listitem">You can actually run the code at this point and see the second activity come up. We're going to go further and add a button to <code class="literal">SecondActivity</code> to close it, which will bring us back to the first activity. Open the <code class="literal">SecondActivity.java</code> file and add this function:<div><pre class="programlisting">public void onClickClose(View view) {
    finish();
}</pre></div></li><li class="listitem">Finally, add the <strong>Close</strong> button to the <code class="literal">SecondActivity</code> layout. Open the <code class="literal">activity_second.xml</code> file and add the following <code class="literal">&lt;Button&gt;</code> element just after the <code class="literal">&lt;TextView&gt;</code> element that was generated automatically:<div><pre class="programlisting">&lt;Button
    android:id="@+id/buttonClose"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Close"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    android:onClick="onClickClose"/&gt;</pre></div></li><li class="listitem">Run the application on your device or emulator and see the buttons in action.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How it works...</h2></div></div></div><p>The real work <a id="id22" class="indexterm"/>of this exercise is in the <code class="literal">onClickSwitchActivity()</code> method from Step 3. This is where we declare the second activity for the intent using <code class="literal">SecondActivity.class</code>. We went one step further by adding the close button to the second activity to show a common real-world situation—launching a new activity, then closing it, and returning to the original calling activity. This behavior is accomplished in the <code class="literal">onClickClose()</code> function. All it does is call <code class="literal">finish()</code>, but that tells the system that we're done with the activity. Finish doesn't actually return us to the calling activity or any specific activity for that matter; it just closes the current activity and relies on the <a id="id23" class="indexterm"/>
<strong>back stack</strong>. If we want a specific activity, we can again use the intent object (we just change the class name while creating the intent).</p><p>This activity switching does not make a very exciting application. Our activity does nothing but demonstrate how to switch from one activity to another, which of course will form a fundamental aspect of almost any application that we develop.</p><p>If we had manually created the activities, we would need to add them to the manifest. By using these steps, Android Studio has already taken care of the XML. To see what Android Studio did, open the <code class="literal">AndroidManifest.xml</code> file and look at the <code class="literal">&lt;application&gt;</code> element:</p><div><pre class="programlisting">&lt;activity
    android:name=".MainActivity"
    android:label="@string/app_name"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN"/&gt;
        &lt;category android:name="android.intent.category.LAUNCHER/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;activity
    android:name=".SecondActivity"
    android:label="@string/title_activity_second"&gt;
&lt;/activity&gt;</pre></div><p>One thing to note <a id="id24" class="indexterm"/>in the preceding autogenerated code is that the second activity does not have the <code class="literal">&lt;intent-filter&gt;</code> element. The main activity is generally the entry point when starting the application. That's why <code class="literal">MAIN</code> and <code class="literal">LAUNCHER</code> are defined—so that the system will know which activity to launch when the application starts.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To learn more about embedding widgets such as the Button, visit <a class="link" href="ch03.html" title="Chapter 3. Views, Widgets, and Styles">Chapter 3</a>, <em>Views, Widgets, and Styles</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Passing data to another activity</h1></div></div></div><p>The intent <a id="id25" class="indexterm"/>object is<a id="id26" class="indexterm"/> defined as a messaging object. As a message object, its purpose is to communicate with other components of the application. In this recipe, we'll show you how to pass information with the intent and how to get it out again.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Getting ready</h2></div></div></div><p>This recipe will pick up from where the previous one ended. We will call this project <code class="literal">SendData</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How to do it...</h2></div></div></div><p>Since this recipe is building on the previous recipe, most of the work is already done. We'll add an <code class="literal">EditText</code> element to the main activity so that we have something to send to <code class="literal">SecondActivity</code>. We'll use the (autogenerated) <code class="literal">TextView</code> view to display the message. Here are the complete steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open<a id="id27" class="indexterm"/> <code class="literal">activity_main.xml</code>, remove<a id="id28" class="indexterm"/> the existing <code class="literal">&lt;TextView&gt;</code> element, and add the following <code class="literal">&lt;EditText&gt;</code> element:<div><pre class="programlisting">&lt;EditText
    android:id="@+id/editTextData"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/&gt;</pre></div><p>The <code class="literal">&lt;Button&gt;</code>  element that we created in the previous recipe doesn't change.</p></li><li class="listitem">Now, open the <code class="literal">MainActivity.java</code> file and change the <code class="literal">onClickSwitchActivity()</code> method as follows:<div><pre class="programlisting">public void onClickSwitchActivity(View view) {
    EditText editText = (EditText)findViewById(R.id.editTextData);
    String text = editText.getText().toString();
    Intent intent = new Intent(this, SecondActivity.class);
    intent.putExtra(Intent.EXTRA_TEXT,text);
    startActivity(intent);
}</pre></div></li><li class="listitem">Next, open the <code class="literal">activity_second.xml</code> file and modify the<code class="literal">&lt;TextView&gt;</code> element to include the ID attribute:<div><pre class="programlisting">&lt;TextView
    android:id="@+id/textViewText"
    android:text="@string/hello_world"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"/&gt;</pre></div></li><li class="listitem">The last change is to edit the second activity to look for this new data and display it on the screen. Open <code class="literal">SecondActivity.java</code> and edit <code class="literal">onCreate()</code> as follows:<div><pre class="programlisting">
<strong>protected void </strong>onCreate(Bundle savedInstanceState) {
    <strong>super</strong>.onCreate(savedInstanceState);
    setContentView(R.layout.<strong>activity_second</strong>);
    TextView textView = (TextView)findViewById(R.id.<strong>textViewText</strong>);
    <strong>if</strong> (getIntent()!=<strong>null</strong> &amp;&amp; getIntent().hasExtra(Intent.<strong>EXTRA_TEXT</strong>)) {
        textView.setText(getIntent().getStringExtra(Intent.<strong>EXTRA_TEXT</strong>));
    }
}</pre></div></li><li class="listitem">Now run the project. Type some text on the main activity and press <strong>Launch Second Activity</strong> to see it send the data.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How it works...</h2></div></div></div><p>As expected, the <a id="id29" class="indexterm"/>intent object is doing all the work. We created an intent <a id="id30" class="indexterm"/>just as in the previous recipe and then added some extra data. Did you notice the <code class="literal">putExtra()</code> method call? In our example, we used the already defined <code class="literal">Intent.EXTRA_TEXT</code> as the identifier, but we didn't have to. We can use any key we want (you've seen this concept before if you're familiar with name/value pairs).</p><p>The key point about using name/value pairs is that you have to use the same name to get the data back out. That's why we used the same key identifier when we read the extra data with <code class="literal">getStringExtra()</code>.</p><p>The second activity was launched with the intent that we created, so it's simply a matter of getting the intent and checking for the data sent along with it. We do this in <code class="literal">onCreate()</code>:</p><div><pre class="programlisting">textView.setText(getIntent().getStringExtra(Intent.EXTRA_TEXT));</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>There's more...</h2></div></div></div><p>We aren't limited to just sending <code class="literal">String</code> data. The intent object is very flexible and already supports basic data types. Go back to Android Studio and click on the <code class="literal">putExtra</code> method. Then hit <em>Ctrl</em> and the <em>Spacebar</em>. Android Studio will bring up the autocomplete list so that you can see the different data types that you can store.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Returning a result from an activity</h1></div></div></div><p>Being able to start one activity from another is all well and good, but we will often need to know how the called activity has fared in its task or even which activity has been called. The <code class="literal">startActivityForResult()</code> method provides the solution.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>Getting ready</h2></div></div></div><p>Returning a result from an <a id="id31" class="indexterm"/>activity is not very different from the way we just <a id="id32" class="indexterm"/>called the activity in the previous recipes. You can either use the project from the previous recipe, or start a new project and call it <code class="literal">GettingResults</code>. Either way, once you have a project with two activities and the code needed to call the second activity, you're ready to begin.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How to do it...</h2></div></div></div><p>There are only a few changes needed to get the results:</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, open <code class="literal">MainActivity.java</code> and add the following constant to the class:<div><pre class="programlisting">public static final String <strong>REQUEST_RESULT="REQUEST_RESULT"</strong>;</pre></div></li><li class="listitem">Next, change the way the intent is called by modifying the <code class="literal">onClickSwitchActivity()</code> method to expect a result:<div><pre class="programlisting">public void onClickSwitchActivity(View view) {
    EditText editText = (EditText)findViewById(R.id.editTextData);
    String text = editText.getText().toString();
    Intent intent = new Intent(this, SecondActivity.class);
    intent.putExtra(Intent.EXTRA_TEXT,text);
    startActivityForResult(intent,1);
}</pre></div></li><li class="listitem">Then, add this new method to receive the result:<div><pre class="programlisting">@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (resultCode==RESULT_OK) {
        Toast.makeText(this, Integer.toString(data.getIntExtra(REQUEST_RESULT, 0)), Toast.LENGTH_LONG).show();
    }
}</pre></div></li><li class="listitem">Finally, modify <code class="literal">onClickClose</code> in <code class="literal">SecondActivity.java</code> to set the return value as follows:<div><pre class="programlisting">public void onClickClose(View view) {
    Intent returnIntent = new Intent();
    returnIntent.putExtra(MainActivity.REQUEST_RESULT,42);
    setResult(RESULT_OK, returnIntent);
    finish();
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How it works...</h2></div></div></div><p>As you can see, getting<a id="id33" class="indexterm"/> the results back is relatively straightforward. We<a id="id34" class="indexterm"/> just call the intent with <code class="literal">startActivityForResult</code>, so it knows that we want a result. We set up the <code class="literal">onActivityResult()</code> callback handler to receive the results. Finally, we make sure that the second activity returns a result with <code class="literal">setResult()</code> before closing the activity. In this example, we are just setting a result with a static value. We just display what we receive to demonstrate the concept.</p><p>It's good practice to check the result code to make sure that the user didn't cancel the action. It's technically an integer, but the system uses it as a boolean value. Check for either <code class="literal">RESULT_OK</code> or <code class="literal">RESULT_CANCEL</code> and proceed accordingly. In our example, the second activity doesn't have a cancel button, so why bother to check? What if the user hits the back button? The system will set the result code to <code class="literal">RESULT_CANCEL</code> and the intent to null, which will cause our code to throw an exception.</p><p>We made use of the <a id="id35" class="indexterm"/>
<strong>Toast</strong> object, which is a convenient pop-up <strong>message</strong>
<a id="id36" class="indexterm"/> that can be used to unobtrusively notify the user. It also functions as a handy method for debugging as it doesn't need a special layout or screen space.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>There's more...</h2></div></div></div><p>Besides the result code, <code class="literal">onActivityResults()</code> also includes a <a id="id37" class="indexterm"/>
<strong>Request Code</strong>. Are you wondering where that came from? It is simply the integer value that was passed with the <code class="literal">startActivityForResult()</code> call, which takes this form:</p><div><pre class="programlisting">startActivityForResult(Intent intent, int requestCode);</pre></div><p>We didn't check the request code because we knew we had only one result to handle—but in trivial applications with several activities, this value can be used to identify where the request originated.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>If <code class="literal">startActivityForResult()</code> is called with a negative request code, it will behave exactly as if it were a call to <code class="literal">startActivity()</code>—that is, it will not return a result.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To learn more about creating new activity classes, refer to the <em>Switching between activities</em> recipe</li><li class="listitem" style="list-style-type: disc">For more information about Toasts, check out the <em>Making a Toast</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Alerts and Notifications">Chapter 7</a>, <em>Alerts and Notifications</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Saving an activity's state</h1></div></div></div><p>The mobile environment is <a id="id38" class="indexterm"/>very dynamic, with users changing tasks much more often than on desktops. With generally fewer resources on a mobile device, it should be expected that your application will be interrupted at some point. It's also very possible that the system will shut down your app completely to give additional resources to the task at hand. It's the nature of mobiles.</p><p>A user might start typing something in your app, be interrupted by a phone call, or switch over to another app to send a text message, and by the time they get back to your app, the system may have closed it down completely to free up the memory. To provide the best user experience, you need to expect such behavior and make it easier for your user to resume from where they left off. The good thing is that the Android OS makes this easier by providing callbacks to notify your app of state changes.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>Simply rotating your device will cause the OS to destroy and recreate your activity. This might seem a bit heavy-handed, but it's done for good reason—it's very common to have different layouts for portrait and landscape, so this ensures that your app is using the correct resources.</p></div></div><p>In this recipe, you'll see how to handle the <code class="literal">onSaveInstanceState()</code> and <code class="literal">onRestoreInstanceState()</code> callbacks to save your application's state. We will demonstrate this by creating a counter variable and increment it each time the <strong>Count</strong> button is pressed. We will also have an <code class="literal">EditText</code> and a <code class="literal">TextView</code> widget to see their default behavior.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>Create a new project in<a id="id39" class="indexterm"/> Android Studio and name it <code class="literal">StateSaver</code>. We need only a single activity, so the autogenerated main activity is sufficient. However, we will need a few widgets, including <code class="literal">EditText</code>, <code class="literal">Button</code>, and <code class="literal">TextView</code>. Their layout (in <code class="literal">activity_main.xml</code>) will look like this:</p><div><pre class="programlisting">&lt;EditText
    android:id="@+id/editText"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentTop="true"
    android:layout_alignParentStart="true"/&gt;

&lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerInParent="true"
    android:text="Count"
    android:onClick="onClickCounter"/&gt;

&lt;TextView
    android:id="@+id/textViewCounter"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_below="@id/button"/&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it...</h2></div></div></div><p>Perform the following set of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To keep track of the counter, we need to add a global variable to the project, along with a key for saving and restoring. Add the following code to the <code class="literal">MainActivity.java</code> class:<div><pre class="programlisting">static final String KEY_COUNTER = "COUNTER";
private int mCounter=0;</pre></div></li><li class="listitem">Then add the code needed to handle the button press; it increments the counter and displays the result in the <code class="literal">TextView</code> widget:<div><pre class="programlisting">public void onClickCounter(View view) {
    mCounter++;
    ((TextView)findViewById(R.id.textViewCounter)).setText("Counter: " + Integer.toString(mCounter));
}</pre></div></li><li class="listitem">To receive notifications of application state change, we need to add the <code class="literal">onSaveInstanceState()</code> and<code class="literal"> onRestoreInstanceState()</code> methods to our application. Open <code class="literal">MainActivity.java</code> and add the following:<div><pre class="programlisting">@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putInt(KEY_COUNTER,mCounter);
}

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
    mCounter=savedInstanceState.getInt(KEY_COUNTER);
}</pre></div></li><li class="listitem">Run the program and try changing the orientation to see how it behaves (if you're using the emulator, <em>Ctrl</em> + <em>F11</em> will rotate the device).</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How it works...</h2></div></div></div><p>All activities <a id="id40" class="indexterm"/>go through multiple states during their lifetime. By setting up callbacks to handle the events, we can have our code save important information before the activity is destroyed.</p><p>Step 3 is where the actual saving and restoring occurs. The system sends a <strong>Bundle</strong> (a data object that also uses name/value pairs) to the methods. We use the <code class="literal">onSaveInstanceState()</code> callback to save the data and pull it out in the <code class="literal">onRestoreInstanceState()</code> callback.</p><p>But wait! Did you try typing text in the <code class="literal">EditText</code> view before rotating the device? If so, you'd have noticed that the text was also restored, but we don't have any code to handle that view. By default, the system will automatically save the state, provided it has a unique ID (not all views automatically have their state saved, such as the <code class="literal">TextView</code>, but we can manually save it if we want).</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Note that if you want Android to automatically save and restore the state of a view, it must have a unique ID (specified with the <code class="literal">android:id=</code> attribute in the layout). Beware; not all view types automatically save and restore the state of a view.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>There's more...</h2></div></div></div><p>The <code class="literal">onRestoreInstanceState()</code> callback<a id="id41" class="indexterm"/> is not the only place where the state can be restored. Look at the signature of <code class="literal">onCreate()</code>:</p><div><pre class="programlisting">
<code class="literal">onCreate(Bundle savedInstanceState)</code>
</pre></div><p>Both methods receive the same <code class="literal">Bundle</code> instance named <code class="literal">savedInstanceState</code>. You could move the restore code to the <code class="literal">onCreate()</code> method and it would work the same. But one catch is that the <code class="literal">savedInstanceState</code> bundle will be null if there is no data, such as during the initial creation of the activity. If you want to move the code from the <code class="literal">onRestoreInstanceState()</code> callback, just check to make sure that the data is not null, as follows:</p><div><pre class="programlisting">if (savedInstanceState!=null) {
    mCounter = savedInstanceState.getInt(KEY_COUNTER);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Storing persistent activity data</em> recipe will introduce persistent storage.</li><li class="listitem" style="list-style-type: disc">Take a look at <a class="link" href="ch06.html" title="Chapter 6. Working with Data">Chapter 6</a>, <em>Working with Data</em>, for more examples on Android activities.</li><li class="listitem" style="list-style-type: disc">The <em>Understanding the activity lifecycle</em> recipe explains the Android Activity Lifecycle.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Storing persistent activity data</h1></div></div></div><p>Being able to<a id="id42" class="indexterm"/> store information about our activities on a temporary basis is very useful, but more often than not, we will want our application to remember information across multiple sessions.</p><p>Android supports SQLite, but that could be a lot of overhead for simple data, such as the user's name or a high score. Fortunately, Android also provides a lightweight option for these scenarios, with <code class="literal">SharedPreferences</code>.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>You can either use the project from the previous recipe or start a new project and call it <code class="literal">PersistentData</code> (in a real-world application, you'll likely be doing both anyway). In the previous recipe, we saved <code class="literal">mCounter</code> in the session state. In this recipe, we'll add a new method to handle <code class="literal">onPause()</code> and save <code class="literal">mCounter</code> to <code class="literal">SharedPreferences</code>. We'll restore the value in <code class="literal">onCreate()</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it...</h2></div></div></div><p>We have only two <a id="id43" class="indexterm"/>changes to make, and both are in <code class="literal">MainActivity.java</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following <code class="literal">onPause()</code> method to save the data before the activity closes:<div><pre class="programlisting">@Override
protected void onPause() {
    super.onPause();

    SharedPreferences settings = getPreferences(MODE_PRIVATE);
    SharedPreferences.Editor editor = settings.edit();
    editor.putInt(KEY_COUNTER, mCounter);
    editor.commit();
}</pre></div></li><li class="listitem">Then add the following code at the end of <code class="literal">onCreate()</code> to restore the counter:<div><pre class="programlisting">SharedPreferences settings = getPreferences(MODE_PRIVATE);

int defaultCounter = 0;
mCounter = settings.getInt(KEY_COUNTER, defaultCounter);</pre></div></li><li class="listitem">Run the program and try it out.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec39"/>How it works...</h2></div></div></div><p>As you can see, this is very similar to saving state data, because it also uses name/value pairs. Here, we just stored an <code class="literal">int</code>, but we can just as easily store one of the other primitive data types. Each data type has equivalent getters and setters, for example, <code class="literal">SharedPreferences.getBoolean()</code> or <code class="literal">SharedPreferences.setString()</code>.</p><p>Saving our data requires the services of <code class="literal">SharedPreferences.Editor</code>. This is evoked with <code class="literal">edit()</code> and accepts <code class="literal">remove()</code> and <code class="literal">clear()</code> procedures as well as setters such as <code class="literal">putInt()</code>. Note that we must conclude any storing that we do here with the <code class="literal">commit()</code> statement.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec40"/>There's more...</h2></div></div></div><p>There is a slightly more sophisticated variant of the <code class="literal">getPreferences()</code> accessor: <code class="literal">getSharedPreferences()</code>. It can be used to store multiple preference sets.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Using more than one preference file</h3></div></div></div><p>Using <code class="literal">getSharedPreferences()</code> is no different from using its counterpart, but it allows for more than one preference file. It takes the following form:</p><div><pre class="programlisting">getSharedPreferences(String name, int mode)</pre></div><p>Here, <code class="literal">name</code> is the file. The <code class="literal">mode</code> <a id="id44" class="indexterm"/>can be either <code class="literal">MODE_PRIVATE</code>, <code class="literal">MODE_WORLD_READABLE</code>, or <code class="literal">MODE_WORLD_WRITABLE</code> and describes the file's access levels.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec41"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="link" href="ch06.html" title="Chapter 6. Working with Data">Chapter 6</a>, <em>Working with Data</em>, for more examples on data storage</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Understanding the activity lifecycle</h1></div></div></div><p>The Android OS is a <a id="id45" class="indexterm"/>dangerous place for an activity. The demand for resources on a battery-operated platform is managed quite ruthlessly by the system. Our activities can be dumped from memory when it's running low, without even a moment's notice and along with any data they contain. Therefore, it is essential to understand the activity lifecycle.</p><p>The following diagram shows the stages through which an activity passes during its lifetime:</p><div><img src="img/05057_01_05.jpg" alt="Understanding the activity lifecycle"/></div><p>Along with the stages, the diagram also shows the methods that can be overridden. As you can see, we've already utilized most of these methods in the preceding recipes. Hopefully, getting the big picture will help in your understanding.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec42"/>Getting ready</h2></div></div></div><p>Create a new project in <a id="id46" class="indexterm"/>Android Studio with a <strong>Blank Activity</strong>, and call it <code class="literal">ActivityLifecycle</code>. We will use the (autogenerated) <code class="literal">TextView</code> method to display the state information.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec43"/>How to do it...</h2></div></div></div><p>To see the application move through the various stages, we will create methods for all the stages:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">activity_main.xml</code> and add an ID to the autogenerated <code class="literal">TextView</code>:<div><pre class="programlisting">android:id="@+id/textViewState"</pre></div></li><li class="listitem">The remaining steps will be in <code class="literal">MainActivity.java</code>. Add the following global declaration:<div><pre class="programlisting">private TextView mTextViewState;</pre></div></li><li class="listitem">Modify the <code class="literal">onCreate()</code> method to save <code class="literal">TextView</code> and set the initial text:<div><pre class="programlisting">mTextViewState = (TextView)findViewById(R.id.textViewState);
mTextViewState.setText("onCreate()\n");</pre></div></li><li class="listitem">Add the following methods to handle the remaining events:<div><pre class="programlisting">@Override
protected void onStart() {
    super.onStart();
    mTextViewState.append("onStart()\n");
}

@Override
protected void onResume() {
    super.onResume();
    mTextViewState.append("onResume()\n");
}

@Override
protected void onPause() {
    super.onPause();
    mTextViewState.append("onPause()\n");
}

@Override
protected void onStop() {
    super.onStop();
    mTextViewState.append("onStop()\n");
}

@Override
protected void onRestart() {
    super.onRestart();
    mTextViewState.append("onRestart()\n");
}

@Override
protected void onDestroy() {
    super.onDestroy();
    mTextViewState.append("onDestroy()\n");
}</pre></div></li><li class="listitem">Run the application and observe what happens when the activity is interrupted by pressing the Back and Home keys. Try other actions, such as task switching, to see how they impact your application.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec44"/>How it works...</h2></div></div></div><p>Our activity can exist in<a id="id47" class="indexterm"/> one of these three states: <strong>active</strong>, <strong>paused</strong>, or <strong>stopped</strong>. There <a id="id48" class="indexterm"/>is also a fourth state, <strong>destroyed</strong>, but <a id="id49" class="indexterm"/>we can <a id="id50" class="indexterm"/>safely ignore it:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An activity is in the <code class="literal">active</code> state when its interface is available for the user. It persists from <code class="literal">onResume()</code> until <code class="literal">onPause()</code>, which is brought about when another activity comes to the foreground. If this new activity does not entirely obscure our activity, then ours will remain in the <code class="literal">paused</code> state until the new activity is finished or dismissed. It will then immediately call <code class="literal">onResume()</code> and continue.</li><li class="listitem" style="list-style-type: disc">When a newly started activity fills the screen or makes our activity invisible, then our activity will enter the <code class="literal">stopped</code> state, and the resumption will always invoke a call to <code class="literal">onRestart()</code>.</li><li class="listitem" style="list-style-type: disc">When an activity is in either the <code class="literal">paused</code> or <code class="literal">stopped</code> state, the operating system can (and will) remove it from the memory when the memory is low or when other applications demand it.</li><li class="listitem" style="list-style-type: disc">It is worth noting that we never actually see the results of the <code class="literal">onDestroy()</code> method, as the activity is removed by this point. If you want to explore these methods further, then it is well worth employing <code class="literal">Activity.isFinishing()</code> to see whether the activity is really finishing before <code class="literal">onDestroy()</code> is executed, as seen in the following snippet:<div><pre class="programlisting">@Override
  public void onPause() {
  super.onPause();
  mTextView.append("onPause()\n ");
  if (isFinishing()){
    mTextView.append(" ... finishing");
  }
}</pre></div></li></ul></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>When implementing these methods, always call the superclass before doing any work.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec45"/>There's more...</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Shutting down an activity</h3></div></div></div><p>To shut down an <a id="id51" class="indexterm"/>activity, directly call its <code class="literal">finish()</code> method, which in turn calls <code class="literal">onDestroy()</code>. To perform the same action from a child activity, use <code class="literal">finishFromChild(Activity child)</code>, where <code class="literal">child</code> is the calling subactivity.</p><p>It is often useful to know whether an activity is being shut down or merely paused, and the <code class="literal">isFinishing(boolean)</code> method returns a value that indicates which of these two states the activity is in.</p></div></div></div></body></html>