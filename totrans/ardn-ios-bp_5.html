<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. TV Set Constant Volume Controller</h1></div></div></div><p>I don't watch TV much, but when I do, I usually completely relax and fall asleep. I know that TV is not meant for putting you to sleep, but it does this to me. Unfortunately, commercials are transmitted at a very high volume and they wake me up. How can I relax if commercials wake me up every five minutes?</p><p>Can<a id="id330" class="indexterm"/> you believe it? During one of my naps between two commercials, I came up with a solution based on iOS and Arduino.</p><p>It's nothing complex. An iOS device listens to the TV set's audio, and when the audio level becomes higher than a preset threshold, the iOS device sends a message (via Bluetooth) to Arduino, which controls the TV set volume, emulating the traditional IR remote control. Exactly the same happens when the volume drops below another threshold. The final result is that the TV set volume is almost constant, independent of what is on the air. This helps me sleep longer!</p><p>The techniques that you are going to learn in this chapter are useful in many different ways. You can use an IR remote control for any purpose, or you can control many different devices, such as a CD/DVD player, a stereo set, Apple TV, a projector, and so on, directly from an Arduino and iOS device. As always, it is up to your imagination.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Constant Volume Controller requirements</h1></div></div></div><p>Our<a id="id331" class="indexterm"/> aim is to design an Arduino-based device, which can make the TV set's volume almost constant by emulating the traditional remote controller, and an iOS application, which monitors the TV and decides when to decrease or increase the TV set's volume.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Hardware</h1></div></div></div><p>Most TV sets can be controlled by an IR remote controller, which sends signals to control the volume, change the channel, and control all the other TV set functions.</p><p>IR <a id="id332" class="indexterm"/>remote controllers use a carrier signal (usually at 38 KHz) that is easy to isolate from noise and disturbances.</p><p>The carrier signal is turned on and off by following different rules (encoding) in order to transmit the 0 and 1 digital values.</p><p>The IR receiver removes the carrier signal (with a low pass filter) and decodes the remaining signal by returning a clear sequence of 0 and 1.</p><div><h3 class="title"><a id="tip39"/>Tip</h3><p>
<strong>The IR remote control theory</strong>
</p><p>You <a id="id333" class="indexterm"/>can find more information about the IR remote control at <a class="ulink" href="http://bit.ly/1UjhsIY">http://bit.ly/1UjhsIY</a>.</p></div><p>Our circuit will emulate the IR remote controller by using an IR LED, which will send specific signals that can be interpreted by our TV set.</p><p>On the other hand, we can receive an IR signal with a phototransistor and decode it into an understandable sequence of numbers, by designing a demodulator and a decoder.</p><p>Nowadays, electronics is very simple; an IR receiver module (Vishay 4938) will manage the complexity of signal demodulation, noise cancellation, triggering, and decoding. It can be directly connected to Arduino, making everything very easy.</p><p>In the project in this chapter, we need an IR receiver to discover the coding rules that are used by our own IR remote controller (and the TV set).</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Additional electronic components</h2></div></div></div><p>In <a id="id334" class="indexterm"/>this project, we need the following additional components:</p><div><ul class="itemizedlist"><li class="listitem">IR LED Vishay TSAL6100</li><li class="listitem">IR Receiver module Vishay TSOP 4838</li><li class="listitem">Resistor 100Ω</li><li class="listitem">Resistor 680Ω</li><li class="listitem">Electrolytic capacitor 0.1μF</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Electronic circuit</h2></div></div></div><p>The <a id="id335" class="indexterm"/>following picture shows the electrical diagram of the circuit that we need for the project:</p><div><img src="img/image00207.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>The IR receiver will be used only to capture the TV set's remote controller signals so that our circuit can emulate them.</p><p>However, an IR LED is constantly used to send commands to the TV set. The other two LEDs will show when Arduino increases or decreases the volume. They are optional and can be omitted.</p><p>As usual, the Bluetooth device is used to receive commands from the iOS device.</p><div><h3 class="title"><a id="tip40"/>Tip</h3><p>
<strong>Powering the IR LED in the current limits of Arduino</strong>
</p><p>From the<a id="id336" class="indexterm"/> datasheet of the TSAL6100, we know that the forward voltage is 1.35V. The voltage drop along R1 is then <em>5-1.35 = 3.65V</em>, and the current provided by Arduino to power the LED is about <em>3.65/680=5.3 mA</em>. The maximum current that is allowed for each PIN is 40 mA (the recommended value is 20 mA). So, we are within the limits. In case your TV set is far from the LED, you may need to reduce the R1 resistor in order to get more current (and the IR light). Use a new value of R1 in the previous calculations to check whether you are within the Arduino limits. For more information about the <a id="id337" class="indexterm"/>Arduino PIN current, check out <a class="ulink" href="http://bit.ly/1JosGac">http://bit.ly/1JosGac</a>.</p></div><p>The<a id="id338" class="indexterm"/> following diagram shows how to mount the circuit on a breadboard:</p><div><img src="img/image00208.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Arduino code</h1></div></div></div><p>The <a id="id339" class="indexterm"/>entire code of this project can<a id="id340" class="indexterm"/> be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>.</p><p>To understand better the explanations in the following paragraphs, open the downloaded code while reading them.</p><p>In this project, we are going to use the IR remote library, which helps us code and decode IR signals.</p><p>The library<a id="id341" class="indexterm"/> can be downloaded from <a class="ulink" href="http://bit.ly/1Isd8Ay">http://bit.ly/1Isd8Ay</a>, and installed by using the following procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Navigate to the release page of <a class="ulink" href="http://bit.ly/1Isd8Ay">http://bit.ly/1Isd8Ay</a> in order to get the latest release and download the <code class="literal">IRremote.zip</code> file.</li><li class="listitem">Unzip the file whatever you like.</li><li class="listitem">Open<a id="id342" class="indexterm"/> the <strong>Finder</strong> and then the <code class="literal">Applications</code> folder (<em>Shift</em> + <em>Control</em> + <em>A</em>).</li><li class="listitem">Locate the Arduino application.</li><li class="listitem">Right-click on it and select <strong>Show Package Contents</strong>.</li><li class="listitem">Locate the <code class="literal">Java</code> folder and then <code class="literal">libraries</code>.</li><li class="listitem">Copy the <code class="literal">IRremote</code> folder (unzipped in step 2) into the <code class="literal">libraries</code> folder.</li><li class="listitem">Restart Arduino if you have it running.</li></ol><div></div><p>In this project, we need the following two Arduino programs:</p><div><ul class="itemizedlist"><li class="listitem">One is used to acquire the codes that your IR remote controller sends to increase and decrease the volume</li><li class="listitem">The other is the main program that Arduino has to run to automatically control the TV set volume</li></ul></div><p>Let's start with the code that is used to acquire the IR remote controller codes.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Decoder setup code</h2></div></div></div><p>In<a id="id343" class="indexterm"/> this section, we will be referring to the downloaded <code class="literal">Decode.ino</code> program that is used to discover the codes that are used by your remote controller.</p><p>Since the setup code is quite simple, it doesn't require a detailed explanation; it just initializes the library to receive and decode messages.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Decoder main program</h2></div></div></div><p>In this section, we will be <a id="id344" class="indexterm"/>referring to the downloaded <code class="literal">Decode.ino</code> program; the main code receives signals from the TV remote controller and dumps the appropriate code, which will be included in the main program to emulate the remote controller itself.</p><p>Once the program is run, if you press any button on the remote controller, the console will show the following:</p><div><pre class="programlisting">For IR Scope: 
+4500 -4350 … 

For Arduino sketch: 
unsigned int raw[68] = {4500,4350,600,1650,600,1600,600,1600,…};</pre></div><p>The second row is what we need. Please<a id="id345" class="indexterm"/> refer to the <em>Testing and tuning</em> section for a detailed description of how to use this data.</p><p>Now, we will take a look at the main code that will be running on Arduino all the time.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Setup code</h2></div></div></div><p>In this<a id="id346" class="indexterm"/> section, we will be referring to the <code class="literal">Arduino_VolumeController.ino</code> program. The setup function initializes the nRF8001 board and configures the pins for the optional monitoring LEDs.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Main program</h2></div></div></div><p>The <code class="literal">loop</code> function just calls the <code class="literal">polACI</code> function <a id="id347" class="indexterm"/>to allow the correct management of incoming messages from the nRF8001 board.</p><p>The program accepts the following two messages from the iOS device (refer to the <code class="literal">rxCallback</code> function):</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">D</code> to decrease the volume</li><li class="listitem"><code class="literal">I</code> to increase the volume</li></ul></div><p>The following two functions perform the actual increasing and decreasing of volume by sending the two <code class="literal">up</code> and <code class="literal">down</code> buffers through the IR LED:</p><div><pre class="programlisting">void volumeUp() {
  irsend.sendRaw(up, VOLUME_UP_BUFFER_LEN, 38);
  delay(20);
}

void volumeDown() {
  irsend.sendRaw(down, VOLUME_DOWN_BUFFER_LEN, 38);
  delay(20);
  irsend.sendRaw(down, VOLUME_DOWN_BUFFER_LEN, 38);
  delay(20);
}</pre></div><p>The <code class="literal">up</code> and <code class="literal">down</code> buffers, <code class="literal">VOLUME_UP_BUFFER_LEN</code> and <code class="literal">VOLUME_DOWN_BUFFER_LEN</code>, are prepared with the help of the Decode.ino <a id="id348" class="indexterm"/>program (see the <em>Testing and tuning</em> section).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>iOS code</h1></div></div></div><p>In<a id="id349" class="indexterm"/> this chapter, we are going to look at <a id="id350" class="indexterm"/>the iOS application that monitors the TV set volume and sends the volume down or volume up commands to the Arduino board in order to maintain the volume at the desired value.</p><p>The full<a id="id351" class="indexterm"/> code of this project can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>.</p><p>To understand better the explanations in the following paragraphs, open the downloaded code while reading them.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Creating the Xcode project</h2></div></div></div><p>We <a id="id352" class="indexterm"/>will create a new project as we already did in the previous chapters. The following are the steps that you need to follow:</p><p>The following<a id="id353" class="indexterm"/> are the parameters for the new project:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Project Type</strong>: Tabbed application</li><li class="listitem"><strong>Product Name</strong>: VolumeController</li><li class="listitem"><strong>Language</strong>: Objective-C</li><li class="listitem"><strong>Devices</strong>: Universal</li></ul></div><p>To set a capability for this project, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the project in the left pane of Xcode.</li><li class="listitem">Select <strong>Capabilities</strong> in the right pane.</li><li class="listitem">Turn on the <strong>Background Modes</strong> option and select <strong>Audio and AirPlay </strong>(refer to the following picture). This allows an iOS device to listen to audio signals too when the iOS device screen goes off, or the app goes in the background:<div><img src="img/image00209.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div><p>Since<a id="id354" class="indexterm"/> the structure of this project is very close to the Pet Door Locker, we can reuse a part of the user interface and the code by performing the following steps (for more details, go back to the iOS guider rover project in <a class="link" title="Chapter 4. iOS Guided Rover" href="part0033.xhtml#aid-VF2I1">Chapter 4</a>, <em>iOS Guided Rover</em>, where we did almost the same thing):</p><div><ol class="orderedlist arabic"><li class="listitem">Select <strong>FirstViewController.h</strong> and <strong>FirstViewController.m</strong>, right-click on them, click on <strong>Delete</strong>, and select <strong>Move to Trash</strong>.</li><li class="listitem">With the same procedure, delete<em> </em><strong>SecondViewController</strong><em> </em>and <strong>Main.storyboard</strong>.</li><li class="listitem">Open the <strong>PetDoorLocker</strong> project in Xcode.</li><li class="listitem">Select the following files and drag and drop them to this project (refer to the following picture).<div><ul class="itemizedlist"><li class="listitem"><strong>BLEConnectionViewController.h</strong></li><li class="listitem"><strong>BLEConnectionViewController.m</strong></li><li class="listitem"><strong>Main.storyboard</strong></li></ul></div><p>Ensure that <strong>Copy items if needed</strong> is selected and then click on <strong>Finish</strong>.</p></li><li class="listitem">Copy the icon that was used for the BLEConnectionViewController view controller.</li><li class="listitem">Create a new View Controller class and name it <code class="literal">VolumeControllerViewController</code>.</li><li class="listitem">Open the <strong>Main.storyboard</strong> and locate the main View Controller.</li><li class="listitem">Delete all the graphical components.</li><li class="listitem">Open the Identity Inspector and change the <strong>Class</strong> to <strong>VolumeControllerViewController</strong>.</li></ol><div></div><p>Now, we<a id="id355" class="indexterm"/> are ready to create what we need for the new application.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Designing the user interface for VolumeControllerViewController</h2></div></div></div><p>This view controller is <a id="id356" class="indexterm"/>the main view controller of the application, and contains just the following components:</p><div><ul class="itemizedlist"><li class="listitem">The switch that turns on and off the volume control</li><li class="listitem">The slider that sets the desired volume of the TV set</li></ul></div><p>Once you have added the components and their layout constraints, you will end up with something that looks like the following screenshot:</p><div><img src="img/image00210.jpeg" alt="Designing the user interface for VolumeControllerViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Once the GUI components are linked <a id="id357" class="indexterm"/>with the code of the view controller, we end with the following code:</p><div><pre class="programlisting">@interface VolumeControllerViewController ()

@property (strong, nonatomic) IBOutlet UISlider     *volumeSlider;

@end

and with:
- (IBAction)switchChanged:(UISwitch *)sender {
…
}
- (IBAction)volumeChanged:(UISlider *)sender {
…
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Writing code for BLEConnectionViewController</h2></div></div></div><p>Since we copied this View Controller <a id="id358" class="indexterm"/>from the Pet Door Locker project, we don't need to change it apart from replacing the key, which was used to store the peripheral UUID, from <code class="literal">PetDoorLockerDevice</code> to <code class="literal">VolumeControllerDevice</code>.</p><p>We saved some work!</p><p>Now, we are ready to work on the VolumeControllerViewController, which is much more interesting.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Writing code for VolumeControllerViewController</h2></div></div></div><p>This is the main part<a id="id359" class="indexterm"/> of the application; almost everything happens here.</p><p>We need some properties, as follows:</p><div><pre class="programlisting">@interface VolumeControllerViewController ()

@property (strong, nonatomic) IBOutlet UISlider  *volumeSlider;

@property (strong, nonatomic) CBCentralManager   *centralManager;
@property (strong, nonatomic) CBPeripheral       *arduinoDevice;
@property (strong, nonatomic) CBCharacteristic   *sendCharacteristic;

@property (nonatomic,strong) AVAudioEngine       *audioEngine;

@property float                                  actualVolumeDb;
@property float                                  desiredVolumeDb;
@property float                                  desiredVolumeMinDb;
@property float                                  desiredVolumeMaxDb;

@property NSUInteger                             increaseVolumeDelay;

@end</pre></div><p>Some are used to manage the Bluetooth communication and don't need much explanation. The <code class="literal">audioEngine</code> is the instance of <code class="literal">AVAudioEngine</code>, which allows us to transform the audio signal captured by the iOS device microphone in numeric samples. By analyzing these samples, we can obtain the power of the signal that is directly related to the TV set's volume (the higher the volume, the greater the signal power).</p><div><h3 class="title"><a id="tip41"/>Tip</h3><p>
<strong>Analog-to-digital conversion</strong>
</p><p>The <a id="id360" class="indexterm"/>operation of transforming an analog signal into a digital sequence of numbers, which represent the amplitude of the signal itself at different times, is called analog-to-digital conversion. Arduino analog inputs perform exactly the same operation. Together with the digital-to-analog conversion, it is a basic operation of digital signal processing and <a id="id361" class="indexterm"/>storing music in our devices and playing it with a reasonable quality. For more details, visit <a class="ulink" href="http://bit.ly/1N1QyXp">http://bit.ly/1N1QyXp</a>.</p></div><p>The <code class="literal">actualVolumeDb</code> property stores the actual<a id="id362" class="indexterm"/> volume of the signal measured in dB (short for decibel).</p><div><h3 class="title"><a id="tip42"/>Tip</h3><p>
<strong>Decibel (dB)</strong>
</p><p>The decibel (dB) is a logarithmic unit that expresses the ratio between two values <a id="id363" class="indexterm"/>of a physical quantity. Referring to the power of a signal, its value in decibel is calculated with the following formula:</p><div><img src="img/image00211.jpeg" alt="Writing code for VolumeControllerViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Here, P is the power of the signal and P<sub>0</sub> is a reference power. You can find out more <a id="id364" class="indexterm"/>about decibel at <a class="ulink" href="http://bit.ly/1LZQM0m">http://bit.ly/1LZQM0m</a>. We have to point out that if P &lt; P<sub>0</sub>, the value of P<sub>dB</sub> if lower of zero. So, decibel values are usually negative values, and 0dB indicates the maximum power of the signal.</p></div><p>The <code class="literal">desiredVolumeDb</code> property stores the desired volume measured in dB, and the user controls this value through the volume slider in the main tab of the app; <code class="literal">desiredVolumeMinDb</code> and <code class="literal">desiredVolumeMaxDb</code> are derived from the <code class="literal">desiredVolumeDb</code>.</p><p>The most significant part of the code is in the <code class="literal">viewDidLoad</code> method (refer to the downloaded code).</p><p>First, we instantiate the <code class="literal">AudioEngine</code> and get the default input node, which is the microphone, as follows:</p><div><pre class="programlisting">    _audioEngine = [[AVAudioEngine alloc] init];
    AVAudioInputNode *input = [_audioEngine inputNode];</pre></div><p>The <code class="literal">AVAudioEngine</code> is a very powerful class, which allows digital audio signal processing. We are just going to scratch its capabilities.</p><div><h3 class="title"><a id="tip44"/>Tip</h3><p>
<strong>AVAudioEngine</strong>
</p><p>You <a id="id365" class="indexterm"/>can find out more about AVAudioEngine by visiting <a class="ulink" href="http://apple.co/1kExe35">http://apple.co/1kExe35</a> (AVAudioEngine in practice) and <a class="ulink" href="http://apple.co/1WYG6Tp">http://apple.co/1WYG6Tp</a>.</p></div><p>The <code class="literal">AVAudioEngine</code> and other<a id="id366" class="indexterm"/> functions that we are going to use require that we add the following imports:</p><div><pre class="programlisting">#import &lt;AVFoundation/AVFoundation.h&gt;
#import &lt;Accelerate/Accelerate.h&gt;</pre></div><p>By installing an audio tap on the bus for our input node, we can get the numeric representation of the signal that the iOS device is listening to, as follows:</p><div><pre class="programlisting">[input installTapOnBus:0 bufferSize:8192 format:[input inputFormatForBus:0] block:^(AVAudioPCMBuffer* buffer, AVAudioTime* when) {
…
…
}];</pre></div><p>As soon as a new buffer of data is available, the code block is called and the data can be processed. Now, we can take a look at the code that transforms the audio data samples into actual commands to control the TV set:</p><div><pre class="programlisting">for (UInt32 i = 0; i &lt; buffer.audioBufferList-&gt;mNumberBuffers; i++) {

    Float32 *data = buffer.audioBufferList-&gt;mBuffers[i].mData;
    UInt32 numFrames = buffer.audioBufferList-&gt;mBuffers[i].mDataByteSize / sizeof(Float32);
            
  // Squares all the data values
    vDSP_vsq(data, 1, data, 1, numFrames*buffer.audioBufferList-&gt;mNumberBuffers);
            
            // Mean value of the squared data values: power of the signal
    float meanVal = 0.0;
    vDSP_meanv(data, 1, &amp;meanVal, numFrames*buffer.audioBufferList-&gt;mNumberBuffers);
            
    // Signal power in Decibel
    float meanValDb = 10 * log10(meanVal);
            
    _actualVolumeDb = _actualVolumeDb + 0.2*(meanValDb - _actualVolumeDb);
            

    if (fabsf(_actualVolumeDb) &lt; _desiredVolumeMinDb &amp;&amp; _centralManager.state == CBCentralManagerStatePoweredOn &amp;&amp; _sendCharacteristic != nil) {
        
        //printf("Decrease volume\n");
                
        NSData* data=[@"D" dataUsingEncoding:NSUTF8StringEncoding];
        [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
                
        _increaseVolumeDelay = 0;
    }
            
    if (fabsf(_actualVolumeDb) &gt; _desiredVolumeMaxDb &amp;&amp; _centralManager.state == CBCentralManagerStatePoweredOn &amp;&amp; _sendCharacteristic != nil) {
                                
        _increaseVolumeDelay++;
    }
            
    if (_increaseVolumeDelay &gt; 10) {
                
        //printf("Increase volume\n");
                
        _increaseVolumeDelay = 0;
                
        NSData* data=[@"I" dataUsingEncoding:NSUTF8StringEncoding];
                [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
            }
        }</pre></div><p>In our case, the <code class="literal">for</code> cycle is executed just once, because we have just one buffer and we are using only one channel.</p><p>The power of a signal, represented by <em>N</em> samples, can be calculated by using the following formula:</p><div><img src="img/image00212.jpeg" alt="Writing code for VolumeControllerViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Here, <em>v</em> is the value of the nth signal sample.</p><p>Because the power calculation has to performed in real time, we are going to use the following functions, which are provided by the Accelerated Framework:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">vDSP_vsq</code>: This function calculates the square of each input vector element</li><li class="listitem"><code class="literal">vDSP_meanv</code>: This function calculates <a id="id367" class="indexterm"/>the mean value of the input vector elements</li></ul></div><div><h3 class="title"><a id="tip45"/>Tip</h3><p>
<strong>The Accelerated Framework</strong>
</p><p>The <a id="id368" class="indexterm"/>Accelerated Framework is an essential tool that is used for digital signal processing. It saves you time in implementing the most used algorithms and mostly providing implementation of algorithms that are optimized in terms of memory footprint and performance. More information on the Accelerated Framework <a id="id369" class="indexterm"/>can be found at <a class="ulink" href="http://apple.co/1PYIKE8">http://apple.co/1PYIKE8</a> and <a class="ulink" href="http://apple.co/1JCJWYh">http://apple.co/1JCJWYh</a>.</p></div><p>Eventually, the signal power is stored in <code class="literal">_actualVolumeDb</code>. When the modulus of <code class="literal">_actualVolumeDb</code> is lower than the <code class="literal">_desiredVolumeMinDb</code>, the TV set's volume is too high, and we need to send a message to Arduino to reduce it. Don't forget that <code class="literal">_actualVolumeDb </code>is a negative number; the modulus decreases this number when the TV set's volume increases. Conversely, when the TV set's volume decreases, the <code class="literal">_actualVolumeDb </code>modulus increases, and when it gets higher than<code class="literal"> _desiredVolumeMaxDb</code>, we need to send a message to Arduino to increase the TV set's volume.</p><p>During pauses in dialogues, the power of the signal tends to decrease even if the volume of the speech is not changed. Without any adjustment, the increasing and decreasing messages are continuously sent to the TV set during dialogues. To avoid this misbehavior, we send the volume increase message only when the signal power stays over the threshold for some time (when <code class="literal">_increaseVolumeDelay</code> is greater than 10).</p><p>We can take a look at the other view controller methods that are not complex.</p><p>When the view belonging at the view controller appears, the following method is called:</p><div><pre class="programlisting">-(void)viewDidAppear:(BOOL)animated {

     [super viewDidAppear:animated];
    
    NSError* error = nil;
    
    [self connect];
    
    _actualVolumeDb = 0;
    [_audioEngine startAndReturnError:&amp;error];
    
    if (error) {
        NSLog(@"Error %@",[error description]);
    }

}</pre></div><p>In this function, we connect to the Arduino<a id="id370" class="indexterm"/> board and start the audio engine in order to start listening to the TV set.</p><p>When the view disappears from the screen, the <code class="literal">viewDidDisappear</code> method is called, and we disconnect from the Arduino and stop the audio engine, as follows:</p><div><pre class="programlisting">-(void)viewDidDisappear:(BOOL)animated {
    
     [self viewDidDisappear:animated];

    [self disconnect];
    
    [_audioEngine pause];
}</pre></div><p>The method that is called when the switch is operated (<code class="literal">switchChanged</code>) is pretty simple:</p><div><pre class="programlisting">- (IBAction)switchChanged:(UISwitch *)sender {
    
    NSError* error = nil;
    
    if (sender.on) {
        [_audioEngine startAndReturnError:&amp;error];
        
        if (error) {
            NSLog(@"Error %@",[error description]);
        }
        _volumeSlider.enabled = YES;
    }
    else {
        [_audioEngine stop];
        _volumeSlider.enabled = NO;
    }
}</pre></div><p>The method that is called when the volume slider changes is as follows:</p><div><pre class="programlisting">- (IBAction)volumeChanged:(UISlider *)sender {
    
    _desiredVolumeDb = 50.*(1-sender.value);
    _desiredVolumeMaxDb = _desiredVolumeDb + 2;
    _desiredVolumeMinDb = _desiredVolumeDb - 3;
}</pre></div><p>We just set the desired volume and <a id="id371" class="indexterm"/>the lower and upper thresholds.</p><p>The other methods that are used to manage the Bluetooth connection and data transfer don't require any explanation, because they are exactly like in the previous projects.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Testing and tuning</h2></div></div></div><p>We are <a id="id372" class="indexterm"/>now ready to test our new amazing <a id="id373" class="indexterm"/>system and spend more and more time watching TV (or taking more and more naps!) Let's perform the following procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Load the <code class="literal">Decoder.ino</code> sketch and open the Arduino IDE console.</li><li class="listitem">Point your TV remote controller to the TSOP4838 receiver and press the button that increases the volume. You should see something like the following appearing on the console:<div><pre class="programlisting">For IR Scope: 
+4500 -4350 … 

For Arduino sketch: 
unsigned int raw[68] = {4500,4350,600,1650,600,1600,600,1600,…};</pre></div></li><li class="listitem">Copy all the values between the curly braces.</li><li class="listitem">Open the <code class="literal">Arduino_VolumeController.ino</code> and paste the values for the following:<div><pre class="programlisting">unsigned int up[68] = {9000, 4450, …..,};</pre></div></li><li class="listitem">Check whether the length of the two vectors (68 in the example) is the same and modify it, if needed.</li><li class="listitem">Point your TV remote controller to the TSOP4838 receiver, and press the button that decreases the volume. Copy the values and paste them for:<div><pre class="programlisting">unsigned int down[68] = {9000, 4400, ….,};</pre></div></li><li class="listitem">Check whether the length of the two vectors (68 in the example) is the same and modify it, if needed.</li><li class="listitem">Upload the <code class="literal">Arduino_VolumeController.ino</code> to Arduino and point the IR LED towards the TV set.</li><li class="listitem">Open the iOS application, scan for the nRF8001, and then go to the main tab.</li><li class="listitem">Tap on connect and then set the desired volume by touching the slider.</li><li class="listitem">Now, you should see the blue LED and the green LED flashing. The TV set's volume should stabilize to the desired value.</li></ol><div></div><p>To <a id="id374" class="indexterm"/>check whether everything is properly <a id="id375" class="indexterm"/>working, increase the volume of the TV set by using the remote control; you should immediately see the blue LED flashing and the volume getting lower to the preset value. Similarly, by decreasing the volume with the remote control, you should see the green LED flashing and the TV set's volume increasing.</p><p>Take a nap, and the commercials will not wake you up!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>How to go further</h1></div></div></div><p>The <a id="id376" class="indexterm"/>following are some improvements that can be implemented in this project:</p><div><ol class="orderedlist arabic"><li class="listitem">Changing channels and controlling other TV set functions.</li><li class="listitem">Catching handclaps to turn on or off the TV set.</li><li class="listitem">Adding a button to mute the TV set.</li><li class="listitem">Muting the TV set on receiving a phone call.</li></ol><div></div><p>Anyway, you can use the IR techniques that you have learned for many other purposes. For example, you can modify the rover project in <a class="link" title="Chapter 4. iOS Guided Rover" href="part0033.xhtml#aid-VF2I1">Chapter 4</a>, <em>iOS Guided Rover</em>, to control the robot via an IR remote controller. Take a look at the other functions provided by the IRremote library to learn the other provided options. You can find all the available functions in the <code class="literal">IRremote.h</code> that is stored in the <code class="literal">IRremote</code> library folder.</p><p>On the iOS side, try to experiment with the AV Audio Engine and the Accelerate Framework that is used to process signals.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>This chapter focused on an easy but useful project and taught you how to use IR to transmit and receive data to and from Arduino. There are many different applications of the basic circuits and programs that you learned here.</p><p>On the iOS platform, you learned the very basics of capturing sounds from the device microphone and the DSP (digital signal processing). This allows you to leverage the processing capabilities of the iOS platform to expand your Arduino projects.</p><p>The next chapter will be amazing. You are going to open your garage door magically; you don't even need to touch your iOS device to do this. You will also learn a lot about the iBeacon technology. Your imagination will be your only limit!</p></div></body></html>