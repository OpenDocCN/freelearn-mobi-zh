- en: 'Chapter 3. Building our First Game: Breakout'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have gone through some important basics of programming in Lua
    and applying some code to run in the Corona simulator. Knowing the terminology
    is a small part of learning how to make an application. We'll need to take a step
    further and get some hands on experience on what it's like to structure a project
    from beginning to finish. We're going to accomplish this by creating our first
    game from scratch. This will push you further into understanding larger chunks
    of code and applying some game logic to make a functional game.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring game files in a Corona project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating variables for the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding game objects to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an alert message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying score and level number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the fun begin!
  prefs: []
  type: TYPE_NORMAL
- en: Breakout—bringing back old-school gaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have probably seen many forms of the game Breakout in the past couple of
    decades, especially during the Atari days. To give you a good idea of what the
    game is about, here is a brief editorial by Big Fish Games about the history of
    Breakout: [http://www.bigfishgames.com/blog/the-history-of-breakout/](http://www.bigfishgames.com/blog/the-history-of-breakout/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breakout—bringing back old-school gaming](img/1888_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the game screen, there are several columns and rows of bricks placed near
    the top of the screen. A ball travels across the screen, bouncing off the top
    and side walls of the screen. When a brick is hit, the ball bounces away and the
    brick is destroyed. The player loses the round when the ball touches the bottom
    of the screen. To prevent this from happening, the player has a movable paddle
    to bounce the ball upward, keeping it in play.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be creating a clone using touch events and the accelerometer
    for paddle movement that will be controlled by the player. We'll be adding some
    physics to the ball so it can bounce throughout the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be adding the movement of the game objects, collision
    detection, score keeping, and win/lose conditions. Right now, we're going to focus
    on how to set up the game template of Breakout.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Corona physics API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Corona has made it convenient to add physics to your games, especially if you've
    never worked on one before. The engine uses **Box2D** and takes only a few lines
    to incorporate it into your application than what it normally takes to have it
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the physics engine in Corona is fairly easy. You use display objects
    and set them as a physical body in your code. Images, sprites, and vector shapes
    can be turned into a physical object. This is substantial in visualizing how you
    want your objects to react in an environment you have created. You can see results
    right away rather than guessing how they might act in a physical world.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the physics world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making the physics engine available in your app requires the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`local physics = require "physics"`'
  prefs: []
  type: TYPE_NORMAL
- en: Starting, pausing, and stopping physics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three main functions that affect the physics simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`physics.start():` This will start or resume the physical environment. It is
    usually activated at the beginning of the application for physics bodies to take
    effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.pause():` This stops the physics engine temporarily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.stop():`This basically destroys the physical world altogether.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: physics.setGravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function returns the x and y parameters of the global gravity vector, in
    units of meter per second square (acceleration units). The default is (0, 9.8)
    to simulate standard Earth gravity, pointing downwards on the y-axis. For example,
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `physics.setGravity(gx, gy)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: physics.getGravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function returns the x and y parameters of the global gravity vector, in
    units of meter per second square (acceleration units).
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `gx, gy = physics.getGravity()`'
  prefs: []
  type: TYPE_NORMAL
- en: Tilt-based gravity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you have physics.setGravity(gx, gy) and accelerometer API applied, implementing
    tilt-based dynamic gravity is simple. The following is an example of creating
    the tilt-based function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The accelerometer is not present in the Corona Simulator; a device build must
    be created to see the effect.
  prefs: []
  type: TYPE_NORMAL
- en: physics.setScale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the internal pixels-per-meter ratio used in converting between
    the onscreen Corona coordinates and simulated physics coordinates. This should
    be done before any physical objects are instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: The default scaling value is 30\. For devices of higher resolution like iPad,
    Android, or iPhone 4, you may wish to increase this value to 60 or more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `physics.setScale( value )`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: physics.setDrawMode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three rendering modes for the physics engine. This can be altered
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `physics.setDrawMode( mode )`'
  prefs: []
  type: TYPE_NORMAL
- en: '`physics.setDrawMode( "debug" ):` This mode shows collision engine outlines
    only![physics.setDrawMode](img/1888_03_02.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.setDrawMode( "hybrid" ):` This mode overlays collision outlines on
    normal Corona objects![physics.setDrawMode](img/1888_03_03.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`physics.setDrawMode( "normal" ):` This mode is the default Corona renderer,
    with no collision outlines![physics.setDrawMode](img/1888_03_04.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The physics data is displayed using color-coded vector graphics, which reflect
    different object types and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orange**—dynamic physics bodies (the default body type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dark blue**—kinematic physics bodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**—static physics bodies such as the ground or walls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gray**—a body that is *sleeping* due to lack of activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Light blue**—joints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: physics.setPositionIterations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the accuracy of the engine's position calculations. The default
    value is `8`, meaning that the engine will iterate through eight position approximations
    per frame for every object but will increase processor engagement, so it should
    be handled carefully because it might slow down the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `physics.setPositionIterations( value )`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: physics.setVelocityIterations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the accuracy of the engine's velocity calculations. The default
    value is `3`, meaning that the engine will iterate through three velocity approximations
    per frame for every object but will increase processor engagement, so it should
    be handled carefully because it might slow down the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `physics.setVelocityIterations( value )`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tutorial is compatible for both iOS and Android devices. The graphics have
    been designed to accommodate the varying screen dimensions of both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Build configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all items displayed on all device screens are shown in portrait
    mode. We'll be creating this game specifically in landscape mode, so we'll have
    to alter some build settings and configure how all the items on screen will be
    displayed. Playing the game in landscape mode will actually add more player interactivity
    since the paddle will have more screen space to move about and less airtime for
    the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding build.settings file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build-time properties can be provided in an optional `build.settings` file,
    which uses Lua syntax. The `build.settings` file is used to set application orientation
    and auto-rotation behavior, along with a variety of platform-specific build parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project folder on your desktop called `Breakout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your preferred text editor, make a new file called `build.settings` and save
    it to your project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and close. The `build.settings` file is completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default orientation setting determines the initial launch orientation on
    the device, and also the initial orientation of the Corona simulator.
  prefs: []
  type: TYPE_NORMAL
- en: The default orientation doesn't affect Android devices. The orientation is initialized
    to the actual orientation of the device (unless only one orientation is specified).
    Also, the only supported orientations are `landscapeRight` and portrait. On a
    device, you can flip to either `landscapeRight` or `landscapeLeft`, but the operating
    system only reports one flavor of landscape, and Corona's orientation event chooses
    `landscapeRight`.
  prefs: []
  type: TYPE_NORMAL
- en: We have created this application to work with landscape orientations, supporting
    `landscapeRight`. We have set this orientation as its default so it won't switch
    to `landscapeLeft` or even any portrait mode. While working on an iOS device,
    if the `build.settings` aren't set before launching the application, it will go
    to the default portrait mode.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently our project is not scaled to display evenly for cross-platform development.
    The contents will still display on the device, but most likely not in the correct
    aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: For example, iPhone projects are designed for a 320 pixel wide screen and can
    be up scaled to the 480 pixel wide screen for Android devices. This makes porting
    easier, since the code and art assets do not need to be revised.
  prefs: []
  type: TYPE_NORMAL
- en: Corona can target builds made for iPhone 4 and other current iOS devices that
    display double resolution art assets while remaining iOS 3.0-compatible. This
    means that pre-iPhone 4 content will no longer upscale automatically to the larger
    iPhone 4 screen resolution. As iOS development progresses, content scaling will
    generally be required in new iPhone apps to be compatible with devices such as
    the iPhone 3GS and lower.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding config.lua file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If no content size is specified, the content width and height returned will
    be the same as the physical screen width and height of the device. If you specify
    a different content width and height in `config.lua`, the content width and height
    will take on those values.
  prefs: []
  type: TYPE_NORMAL
- en: In your text editor, create a new file called `config.lua` and save it to your
    project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and close your file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The content width and height allow you to choose a virtual screen size that
    is independent of the physical device screen size. We have set the size to target
    the original iPhone since it displays the smallest dimensions across all the devices
    on both iOS and Android platforms. The original iPhone has dimensions of 320 x
    480\. With this configuration, it'll still scale evenly for the iPad, which has
    dimensions of 768 x 1024.
  prefs: []
  type: TYPE_NORMAL
- en: The scale used for this application is set to `letterbox`. It will uniformly
    scale up content as much as possible, while still showing all content on the screen.
    This will create a widescreen look, which will be compatible with the Droid, which
    has a longer screen than the iPhone 3GS.
  prefs: []
  type: TYPE_NORMAL
- en: We set `fps = 60`. By default, the frame rate is 30 fps. In this application,
    this will make the movement of the ball appear faster and allow us to increase
    the speed conveniently. We can stretch the frame rate to a maximum of 60 fps that
    Corona can allow.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have configured our application to landscape mode and set the display
    contents to scale on multiple devices, we''re ready to start designing the game.
    Before we start writing some code for the game, we need to add in some art assets
    that will be displayed on the screen. You can find them in the `Chapter 3 Resources`
    folder. You can download the project files accompanying this book from the Packt
    website. The following files that you''ll need to add to your `Breakout` project
    folder are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: alertBox.png
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bg.png
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mmScreen.png
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ball.png
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: paddle.png
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: brick.png
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: playbtn.png
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important function we'll be introducing in this game is `display.newGroup().`
    Groups allow you to add and remove child display objects. Initially, there are
    no children in a group. The local origin is at the parent object's origin; the
    reference point is initialised to this local origin. You can easily organize your
    display objects in separate groups and refer to them by their group name. For
    example, in Breakout, we'll combine menu items such as the **Title** screen and
    **Play** button in a group called `menuScreenGroup`. Every time we access `menuScreenGroup,`
    any display object defined by the group name will be called.
  prefs: []
  type: TYPE_NORMAL
- en: display.newGroup()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function creates a group in which you can add and remove child display
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `display.newGroup()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Working with system functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The system functions we're going to introduce in this chapter will return information
    about the system (get device information, current orientation) and control system
    functions (enabling Multi-touch, controlling the idle time, Accelerometer, GPS).
    We'll be using the following system functions to return environment information
    on which our application will be running and the response frequency for accelerometer
    events.
  prefs: []
  type: TYPE_NORMAL
- en: system.getInfo()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function returns information about the system on which the application
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `system.getInfo( param )`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Valid values for parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"name"`—returns the name. For example, on the iTouch, this would be the name
    of the phone as it appears in iTunes, *Pat''s iTouch*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"model"`—returns the device type. These include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"iPhone"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"iPad"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"iPhone Simulator"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Nexus One"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Droid"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"myTouch"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Galaxy Tab"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"deviceID"`—returns the unique id of the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"environment"`—returns the environment that the app is running in. These include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"simulator":` The Corona Simulator'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"device":` iOS, Android device, and the Xcode Simulator'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"platformName"`—returns the platform name (the OS name), that is, one of the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mac OS X (Corona Simulator on Mac)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Win (Corona Simulator on Windows))
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: iPhone OS (all iOS devices))
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Android (all Android devices))
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"platformVersion"`—returns a string representation of the platform version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"version"`—returns the version of Corona used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"build"`—returns the Corona build string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"textureMemoryUsed"`—returns the texture memory usage in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"maxTextureSize"`—returns the maximum texture width or height supported by
    the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"architectureInfo"`—returns a string describing the underlying CPU architecture
    of the device you are running on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: system.setAccelerometerInterval()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function sets the frequency of accelerometer events. The minimum frequency
    is 10 Hz and the maximum is 100 Hz on the iPhone. Accelerometer events are a significant
    drain on battery; so only increase the frequency when you need faster responses
    in games. Always try to lower the frequency whenever possible to conserve battery
    life.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax: `system.setAccelerometerInterval( frequency )`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function sets the sample interval in Hertz. Hertz is cycles per second,
    the number of measurements to take per second. If you set the frequency to 75,
    then the system will take 75 measurements per second.
  prefs: []
  type: TYPE_NORMAL
- en: After you have added the assets from the Chapter 3 Resources folder into your
    project folder, let's begin writing some code!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—creating variables for the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any application to start we'll need to make a `main.lua` file. This has
    been discussed in the previous chapter when we worked with some sample code and
    ran it with the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will be structured accordingly in your `main.lua` by the time the
    game is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Necessary Classes` (For example: physics or ui)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Variables and Constants`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Main Function`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object Methods`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Call Main Function` (This always has to be called or your application will
    not run)'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting your code to make it look like the preceding structure is good practice
    on keeping things organized and running your application efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll be introducing the display group that will show the **Main
    Menu** screen and a **Play** button that the user will be able to interact with
    to move on to the **Main Game** screen. All in-game elements such as the paddle,
    ball, brick objects, and heads-up display elements follow after the player interacts
    with the **Play** button. We'll also be introducing win and lose conditions that
    will be referred to as the `alertDisplayGroup`. All these game elements will be
    initialized in the beginning of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `main.lua` file in your text editor and save it to your project
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to hide the status bar (specifically for iOS devices) and load the
    physics engine. Corona uses the Box2D engine that is already built into the SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information on the Corona Physics API can be found on the Corona website
    at: [http://developer.anscamobile.com/content/game-edition-box2d-physics-engine](http://developer.anscamobile.com/content/game-edition-box2d-physics-engine).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Box2D physics engine used in Corona SDK was written by Erin Catto of Blizzard
    Entertainment. More information on Box2D can be found at: [http://box2d.org/manual.pdf](http://box2d.org/manual.pdf).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add in the menu screen objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in the in-game screen objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add in HUD elements for the score and level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The HUD is also known as the heads-up display. It is a method of visually representing
    character information on the game screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll add in the alert display group for the win/lose conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following variables hold the values for the bricks display group, score,
    ball velocity, and in game events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Accelerometer events can only be tested on a device, so we're going to add a
    variable for touch events on the paddle by calling the`"simulator"` environment.
    This is so we can test the paddle movement in the Corona simulator. If you were
    to test the application on a device, the event listeners for touch and accelerometer
    on the paddle won't conflict.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, add in the `main()` function. This will start our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `display.setStatusBar(display.HiddenStatusBar)` is only applicable to iOS
    devices. It hides the appearance of the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: A new Corona API we added to this game is the physics engine. We'll be adding
    physics parameters to the main game objects (paddle, ball, and bricks) for collision
    detection. Having `setGravity(0,0)` will allow the ball to bounce throughout the
    playing field freely.
  prefs: []
  type: TYPE_NORMAL
- en: '`local menuScreenGroup, local alertDisplayGroup`, and `local bricks` are all
    forms of display groups we can separate and organize our display objects to. For
    example, `local menuScreenGroup` is designated for the objects that show up on
    the **Main Menu** screen; that way they can be removed as a group and not as individual
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the variables added already have values that are applied to certain
    game objects. There is already a set velocity for the ball using `local vx = 3`
    and `local vy = -3`. The x and y velocity determines how the ball moves on the
    game screen. Depending on the position the ball collides with an object, the ball
    will follow a continuous path. The `brickWidth` and `brickHeight` have a value
    that will stay constant throughout the application so we can line the brick objects
    evenly onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: '`local gameEvent = " "` will store the game events such as`"win", "lose"`,
    and`"finished"`. When a function checks the game status for any of these events,
    it will display the proper condition onscreen.'
  prefs: []
  type: TYPE_NORMAL
- en: We have added some system functions as well. We created `local isSimulator =
    "simulator" == system.getInfo("environment")` so that it returns information about
    the system on which the application is running. This will be directed to the paddle
    touch events so that we can test the application in the simulator. If the build
    was to be ported on a device, you would only be able to use the accelerometer
    to move the paddle. The simulator can't test accelerometer events. The other system
    function is `system.setAccelerometerInterval( 100 )`. It sets the frequency of
    accelerometer events. The minimum frequency is 10 Hz and the maximum is 100 Hz
    on the iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: The empty function `main()` set will start out the display hierarchy. Think
    of it as a storyboard. The first thing you see is an introduction and then some
    action happens in the middle that tells you about the main content. In this case,
    the main content is the gameplay. The last thing you see is some kind of ending
    or closure to tie the story altogether. The ending is the display of the win/lose
    conditions at the end of a level.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding events and listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events are sent to listeners. Functions or objects can be event listeners. When
    an event occurs, the listener is called by a table representing the event. All
    events will have a property name that identifies the kind of event.
  prefs: []
  type: TYPE_NORMAL
- en: Register events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Display objects and global Runtime objects can be event listeners. You can
    add and remove listeners for events using the following object methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`object:addEventListener( ):` It adds a listener to the object''s list of listeners.
    When the named event occurs, the listener will be invoked and be supplied with
    a table representing the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object:removeEventListener( ):` It removes the specified listener from the
    object''s list of listeners so that it no longer is notified of events corresponding
    to the specified event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, an image display object registers to receive a touch
    event. Touch events are not broadcast globally. Display objects that register
    for the event and lie underneath it will be candidates for receiving the touch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Runtime events are sent by the system. They broadcast to all listeners. The
    following is an example of registering for an `enterFrame` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Runtime events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application we''re creating uses runtime events. Runtime events have no
    specific target and are only sent to the global Runtime. They broadcast to all
    registered listeners. The following events all have string names and will be applied
    to the Breakout game:'
  prefs: []
  type: TYPE_NORMAL
- en: enterFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`enterFrame` events occur at the frame interval of the application. They are
    only sent to the global Runtime object. For example, if the frame rate is 30fps,
    then it will occur approximately 30 times per second.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties are available in this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string`"enterFrame".`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.time` is the time in milliseconds since the start of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: accelerometer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerometer events let you detect movements and determine the device's orientation
    in relation to gravity. These events are only sent to devices that support accelerometer.
    They are only sent to the global Runtime object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following properties are available for this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string`"accelerometer".`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.xGravity` is the acceleration due to gravity in the x-direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.yGravity` is the acceleration due to gravity in the y-direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.zGravity` is the acceleration due to gravity in the z-direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.xInstant` is the instantaneous acceleration in the x-direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.yInstant` is the instantaneous acceleration in the y-direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.zInstant` is the instantaneous acceleration in the z-direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.isShake` is true when the user shakes the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user's finger touches the screen, a hit event is generated and dispatched
    to display objects in the display hierarchy. Only those objects that intersect
    with the location of the finger on the screen will receive the event.
  prefs: []
  type: TYPE_NORMAL
- en: touch (single touch)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Touch events are a special kind of hit event. When a user's finger touches the
    screen, they are starting a sequence of touch events, each with different phases.
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string`"touch".`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.x` is the x-position in screen coordinates of the touch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.y` is the y-position in screen coordinates of the touch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.xStart` is the x-position of the touch from the`"began"` phase of the
    touch sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.yStart` is the y-position of the touch from the`"began"` phase of the
    touch sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.phase` is a string identifying where in the touch sequence the event
    occurred:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"began"` a finger touched the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"moved"` a finger moved on the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"ended"` a finger was lifted from the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"cancelled"` the system cancelled tracking of the touch.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: tap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: tap generates a hit event when the user touches the screen. The event is dispatched
    to display objects in the display hierarchy. This is similar to the `touch` event
    except a hit count (number of taps) is available in the event callback.
  prefs: []
  type: TYPE_NORMAL
- en: '`event.name` is the string`"tap"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.numTaps` returns the number of taps on the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.x` is the x-position in screen coordinates of the tap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.y` is the y-position in screen coordinates of the tap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be touching base with `transition.to()` and `transition.from()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`transition.to():` It animates a display object''s properties over time using
    the `easing` transitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Syntax: `handle = transition.to( target, params )`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`transition.from():` It is similar to `transition.to()` except the starting
    property values are specified in the function''s parameter table and the final
    values are the corresponding property values in the target prior to the call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Syntax: `handle = transition.from( target, params )`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The parameters used are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`target` - A display object that will be the target of the transition.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`params` - A table that specifies the properties of the display object, which
    will be animated, and one or more of the following optional non-animated properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`params.time:` It specifies the duration of the transition in milliseconds.
    By default, the duration is 500 ms (0.5 seconds).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.transition:` It is by default `easing.linear`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.delay:` It specifies the delay, in milliseconds, (none by default)
    before the tween begins.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.delta:` It is a boolean specifying whether non-control parameters are
    interpreted as final ending values or as changes in value. The default is `nil`
    meaning false.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.onStart:` It is a function or table listener called before the tween
    begins.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params.onComplete:` It is a function or table listener called after the tween
    completes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how two display objects transition throughout the
    space on a device screen. The `square` display object from it's current position
    will move to a new location of x = 250 and y = 400 in 1500 milliseconds. The `square2`
    display object will transition from x = 275 and y = 0 to it's initial location
    in 1500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Creating menu screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having menu screens allows the player to transition through different parts
    of your application. Typically a game will start out with some kind of screen
    displaying the game title with an interactive user interface button labeled **Play**
    or **Start** to give the player the option to play the game. It is standard in
    any mobile application to have a menu screen before transitioning to the main
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding the main menu screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Main Menu** screen will be the first thing in our menu system that the
    player interacts with after the application is launched. It's a great way to introduce
    the title of the game and also it gives the player an idea of what type of gaming
    environment they should expect. We wouldn't want the player to jump abruptly into
    the app without any proper notification. It's important to allow the player to
    prepare for what is to come when they launch the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a function called `mainMenu()` to introduce the title
    screen. So after `function main()` ends, add in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll be adding in a display group and two display objects to this function.
    One display object is the image that will represent the **Main Menu** screen and
    the other will be a UI button called **Play**. Add them inside of `function mainMenu()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember the empty `main()` function set? We need to call `mainMenu()inside`
    of it. The entire function should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `mainMenu()` function, we're going to create another function called
    `loadGame()`. It will initiate the event from `playbtn` to transition to the main
    game screen. The event will change the alpha of `menuScreenGroup` to `0`, which
    makes it appear invisible on the screen. Complete the transition by calling the
    `addGameScreen()` function (`addGameScreen()` will be discussed later in the chapter
    in *Adding Game Objects* section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add in an event listener to `playBtn` so when it is tapped,
    it will call the `loadGame()` function. Add the following line in the `mainMenu()`
    function after the last method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project in the simulator. You should see the **Main Menu** screen display
    **Breakout** and the **Play** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a **Main Menu** screen only requires a couple of blocks of code. For
    `loadGame(event)`, we set a parameter called `event`. When the `if` statement
    is called, it takes `playbutton`, which references the display object `playBtn`
    and checks to see if it is true. Since it is, the `menuScreenGroup` will be removed
    from the stage and wil call on the `addGameScreen()` function. At the same time
    the event listener for `playBtn` is removed from the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—creating a help screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now the design of the menu system is set up so that it goes from the **Main
    Menu** screen and then transitions to the **Gameplay** screen. You have the option
    to extend the menu screens without jumping into the game right away. After the
    **Main Menu** screen, we can add an additional **Help Menu** screen that will
    explain the player how to play the game.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new image in your preferred image editing program and write out steps
    on how to play the game. You can then create a new button called **Next** and
    add both art assets to your project folder. In your code, you'll have to create
    a new function and event listener for your **Next** button that will transition
    to the gameplay screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gameplay scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a menu system in place, we can start on the gameplay elements
    of the application. We'll start adding all of the main game objects that the player
    will interact with. One thing to think about when adding in game objects is their
    placement on the screen. Given that this game will be played in landscape mode,
    we have to remember that there is plenty of space available in the x-direction
    and a smaller amount in the y-direction. Based on the original design of the game,
    the bottom wall of the screen causes the player to lose the level or turn if the
    ball lands in that area. So if you were to pinpoint an area to place the paddle
    object, we wouldn't set it near the top of the screen. It makes more sense for
    the paddle to be as close to the bottom of the screen to protect the ball better.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—adding game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add in the display objects the player will see while in gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `loadGame()` function, we''re going to create another function that
    will display all our game objects on screen. The following lines will display
    the art assets that were created for this tutorial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we'll add in the text that will display the score and level number during
    the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To build the first game level we're going to call the `gameLevel1()` function,
    which will be explained later in this chapter. Don't forget to close the `addGameScreen()`
    function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `addGameScreen()` function displays all the game objects shown during gameplay.
    We have added the `background, paddle`, and `ball` from the art assets provided
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have added text for the score and level at the top of the game screen. `scoreNum`
    is initially set to `0`. We'll discuss in the next chapter how we will update
    the score number when a brick collision is made. `levelNum` starts at `1` and
    updates when the level is completed and moves on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the function by calling `gameLevel1()` which will be implemented in
    the next section to start the first level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—building bricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bricks are the last of the game objects we need to add in for this application.
    We'll be creating two different levels for this game. Each one will have a different
    brick layout from the other.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to create the function for the first level. Let's create a new function,
    `gameLevel1()`. We will also set the `currentLevel = 1` since the application
    begins at **Level 1**. Then we'll add in the `bricks` display group and set it
    `toFront()` so that it appears in front of the game background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The method, `object:toFront( )` moves the target object to the visual front
    of its parent group (object.parent). In this case, we are setting the `bricks`
    group to appear as the front most display group during gameplay so it appears
    in front of the background image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, add some local variables that will show how many rows and columns of bricks
    will be displayed on screen and where in the playing field each brick will be
    placed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create double `for` loops, one for `numOfRows` and the other for `numOfColumns`.
    Create a brick instance placed according to its width, height, and the number
    corresponding to `numOfRows` and `numOfColumns`. The art asset for the brick display
    object is provided with this chapter. Afterwards, close the function with `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The set up for **Level 2** is similar to how **Level 1** is arranged. The code
    is almost the same except our new function is called `gameLevel2(), currentLevel
    = 2`, and the values for `numOfRows` and `numOfColumns` have different values.
    Add this block after the `gameLevel1()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your file and relaunch the simulator. You'll be able to interact with the
    **Play** button and see the transition from the **Main Menu** screen to the game
    screen. You will see the game layout for **Level 1** displayed on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bricks` display group is set `bricks:toFront()`. This means that the group
    will always be put in front of the display hierarchy apart from the `background,
    paddle`, and `ball` display objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`gameLevel1()` has set values for the amount of brick objects displayed in
    the playing field. They will be centered based on the `contentWidth` of the device
    shell and set at 50 in the y-direction. The brick group is placed near the top
    left-hand corner by `brickPlacement` and takes the middle of the screen and subtracts
    it by half the width of all the brick objects put together. Then we add 20 more
    pixels in the x-direction to center it with the paddle.'
  prefs: []
  type: TYPE_NORMAL
- en: We created double `for` loops for `numOfRows` and `numOfColumns`, which start
    the creation of the brick objects from the left-hand corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the `brick` display object is given the name`"brick"`. Just remember
    that`"brick"` cannot be used the same way as `brick` when calling the object.`"brick"`
    is an instance of `brick`. It is merely used as a string when event parameters
    are called on. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The physics body of `brick` is set to`"static"` so it is not affected by gravity
    pulling down. And then it is added to `bricks` group under `bricks.insert(bricks,
    brick)`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—focused platform gaming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upon completing this chapter and the following, feel free to redesign the display
    images to focus on a specific platform. For example, you can easily convert the
    code to be compatible with all iOS devices. This can be done by converting display
    objects to `display.newImageRect( [parentGroup,] filename [, baseDirectory] w,
    h )` so you can substitute higher resolution images on devices with retina display,
    (that is iPhone 4/iPod Touch 4G). Remember that you'll have to adjust your configuration
    settings to have the changes applied. This pertains to adding the `@2x` image
    suffix (or your preferred suffix naming convention) to your `config.lua` file.
  prefs: []
  type: TYPE_NORMAL
- en: Red alert!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every game there is some kind of message that tells you the status of your
    progress when the main action has ended. For this application, we need a way to
    let the player know if they have won or lost a round, how they can play again
    or when the game is officially completed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—displaying game messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up some win/lose notifications so we can display these events occur
    in game:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function called `alertScreen()` and pass two parameters called
    `title` and `message`. Add in a new display object called `alertbox` and have
    it transition from an `xScale` and `yScale` of 0.5 using `easing.outExpo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Store the `title` parameter in the text object called `conditionDisplay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Store the `message` parameter in the text object called `messageText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new display group called `alertDisplayGroup` and insert all the objects
    into the group. Close the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your file and run the project in the simulator. The functionality of the
    **Play** button still goes to the gameplay screen for **Level 1**. None of the
    objects have movement at the moment. We'll be adding touch events, ball movement,
    and collisions in the next chapter. All the game objects should be laid out like
    in the following screenshot:![Time for action—displaying game messages](img/1888_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set up the alert system for the game, but it is not operable at the
    moment until we add in more game functions to set the game objects in motion.
    The next chapter will demonstrate how the `alertScreen()` function passes two
    parameters, `title` and `message`. An `alertBox` display object is added as a
    background to the alert texts when they pop up after a condition occurs. When
    the `alertBox` pops up, it transitions from 0.5 of the `xScale` and `yScale` to
    full image scale in 500 milliseconds. That is basically the equivalent of half
    a second.
  prefs: []
  type: TYPE_NORMAL
- en: The `conditionDisplay` object passes the `title` parameter. This will be the
    text that displays, **You Win** or **You Lose**.
  prefs: []
  type: TYPE_NORMAL
- en: The `messageText` object passes the `message` parameter. The text with this
    parameter displays a message such as **Play Again** or **Continue** after a condition
    is reached.
  prefs: []
  type: TYPE_NORMAL
- en: All the objects in this function are then inserted into `alertDisplayGroup =
    display.newGroup()`. It will act as one group instead of individual objects when
    it will appear on and off the stage.
  prefs: []
  type: TYPE_NORMAL
- en: When running the code in the simulator; if errors pop up in your terminal window,
    be sure to check the line(s) causing the errors. Sometimes a simple capitalization
    error or even a comma or quotation mark that is missing can keep your app from
    running in the simulator. Make sure you're aware of those common mistakes. They
    can be easily overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the `Breakout - Part 1` folder in the `Chapter 3` folder to
    see how the first half of the code for this tutorial is set up.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz—building a game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When adding the physics engine in your code, which functions are valid to add
    to your application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `physics.start()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `physics.pause()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `physics.stop()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Which is correct when adding an event listener?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `button:addeventlistener("touch", listener )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `button:AddEventListener("touch", listener )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `button:addEventListener(touch, listener )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. `button:addEventListener("touch", listener )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the correct way to have the following display object transition to x
    = 300, y = 150, have the alpha changed to 0.5, in 2 seconds?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: a. `transition.to( square, { time=2000, x=300, y=150, alpha=0.5 } )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: b. `transition.from( square, { time=2000, x=300, y=150, alpha=0.5 } )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: c. `transition.to( square, { time=2, x=300, y=150, alpha=0.5 } )`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d. None of the above
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have completed the first half of this game tutorial. Understanding how to
    structure a Corona project properly makes it easier to keep your code organized
    and tracks your assets better. We have gotten a taste of working with blocks of
    code that pertain to a small dose of the game logic needed to allow the application
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we have:'
  prefs: []
  type: TYPE_NORMAL
- en: Specified the build configuration on displaying the content for Android and
    iOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduced the main variables and constants that will run in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiated the physics engine and began to apply them to the game objects
    that require physical bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created transitions between menus to gameplay screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added display objects and game messages to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's quite an accomplishment of how much we've done so far, including learning
    some new API in the process of coding the application. We still have a lot more
    to add before the game can be fully functional. We still have a lot more to add
    before the game can be fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be finishing the last half of this game tutorial.
    We'll be working with collision detection of the paddle, ball, brick, and wall
    objects. Also, we'll learn how to update the score when a brick is removed from
    the scene and get our win/lose conditions active as well. We're in the home stretch.
    Let's keep going!
  prefs: []
  type: TYPE_NORMAL
