<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using Kismet and Matinee</h1></div></div></div><div><blockquote class="blockquote"><p>In the previous chapters, we have learned how the basic interface of UDK works and how to build a basic environment. This is all well and good, but at the moment, all we can do is walk in the world while looking around. Don't we wish we could do something there?</p><p>In this chapter, we are going to take a look at<strong> Kismet</strong> and<strong> Matinee</strong>, two of the most popular ways to create motion in our otherwise static world. This should help breathe life into the world of our game. After all, actions do speak louder than words.</p></blockquote></div><p>In this chapter we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn what Kismet is and what we can do with it</li><li class="listitem" style="list-style-type: disc">Use Kismet to change our project's viewpoint to a third-person perspective</li><li class="listitem" style="list-style-type: disc">Discuss Kismet and the benefits and drawbacks of its usage</li><li class="listitem" style="list-style-type: disc">Learn about the Matinee editor</li><li class="listitem" style="list-style-type: disc">Create a cinematic using Matinee</li><li class="listitem" style="list-style-type: disc">Use both Kismet and Matinee to create an automatic door</li><li class="listitem" style="list-style-type: disc">Learn about sequence objects specifically made for mobile devices</li><li class="listitem" style="list-style-type: disc">Learn about Mobile Input and add functionality to our iOS game</li></ul></div><p>But before we dive into creating new things for our game, first let's get an understanding for what Kismet actually is and what it can be used for.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Defining Kismet</h1></div></div></div><p>
<strong>Kismet?</strong> is a system of visual scripting in UDK that makes it possible for people to affect the game world and design gameplay events. For teams without a programmer, Kismet can be a Godsend; it makes it possible for someone without any coding knowledge to do things that would otherwise require the use of<strong> UnrealScript</strong>, a programming language that the Unreal Engine uses.<a class="indexterm" id="id239"/>
</p><p>In order to create a? sequence of events, you have to connect a series of sequence objects together. This, in turn, generates code when the game is run, which causes it to do the things that you said it should do. It would be easy for me to write a book entirely about things that can be done in Kismet, but as we are planning on creating a third person shooter for the iOS, I will refrain from straying too far from that. However, we will be discussing the creation of more and more complex sequences as the book progresses.<a class="indexterm" id="id240"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Creating your first Kismet sequence</h1></div></div></div><p>Now that we've learned what Kismet is and what it can do for us, let's see it used in action and see how easy it is to get results!</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Time for action—changing the level to a third-person perspective</h1></div></div></div><p>The? default perspective given to players in UDK is first-person. Let's say we want it to be in third-person instead. It will be quite easy to do so due to Epic's console command which does just that. However, in order to first simplify learning Kismet as much as possible and practice what we've learned in previous chapters, we are going to be starting from scratch with a new level.<a class="indexterm" id="id241"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">First, create a new map by selecting<strong> File</strong> |<strong> New...</strong> and then choose one of the four options at the top. I personally chose<strong> Midday Lighting</strong>.<p>Bring up the <strong>World Properties</strong> menu by selecting <strong>View</strong> | <strong>World Properties</strong> from the menu bar at the top of the UDK interface. Type <code class="literal">Game Type</code> in the <strong>Search</strong> bar at the top of the <strong>World Properties</strong> menu, which will bring up the <strong>Game Type</strong> menu and the options relevant to us. From there, change the drop-down menus on both <strong>Default Game Type</strong> and <strong>Game Type for PIE</strong> to <strong>UTDeathmatch</strong>. While we are there in the <strong>Zone Info</strong> section, under <strong>KillZ</strong>, set the value to <code class="literal">-1000</code>.
</p><div><img alt="Time for action—changing the level to a third-person perspective" height="82" src="img/image_1901_04_01.jpg"/></div></li><li class="listitem">Now, before we get into Kismet, I want to explain what it is exactly that we are doing. Start up your game using the<strong> Play</strong> |<strong> InEditor</strong> option?. This starts up your game as it would be seen on the PC, so it is not representative of how the project will look on an iOS? device, but it will be easier to demonstrate the following change. When the game appears, press the<em> Tab</em> key and you will see a black bar appear on the screen. This is the console window, which can be used to execute different commands that Unreal has built in. The one we are going to be using right now, will toggle first and third person modes. With the console open, type in<code class="literal"> behindview 1</code> and press<em> Enter</em>:<a class="indexterm" id="id242"/><div><h3 class="title"><a id="tip04"/>Tip</h3><p>You can also press the tilde (<code class="literal">~</code>) key to access the console window which will show all things logged during play as well as commands you've previously entered.</p></div><div><img alt="Time for action—changing the level to a third-person perspective" height="189" src="img/image_1901_04_02(2).jpg"/></div></li><li class="listitem">As you can see, the game switches your character to a third person mode. One of the? cool things about Kismet is we can, in fact, call these commands for the player, which is what we'll be doing in this demonstration.<a class="indexterm" id="id243"/></li><li class="listitem">Open up the Kismet interface by clicking on the<strong> K</strong> icon at the top of the UDK interface on the main toolbar. You should see a new window pop up that may look a bit daunting, but it's not too bad once you know what everything is.<div><img alt="Time for action—changing the level to a third-person perspective" src="img/image_1901_04_02.jpg" width="361"/></div></li><li class="listitem">Underneath the menu bars, you will see a large area with a lot of 1s and 0s on it. This is our workspace and where we will be placing all of the Sequence Objects that we create.<a class="indexterm" id="id244"/></li><li class="listitem">The bottom two bars are the<strong> Properties</strong> and<strong> Sequences</strong> windows. The<strong> Properties</strong> window will hold all of the data that we will want to set within the sequence objects, that we will be creating which can be accessed when we left-click on them. All of our work in this chapter will be in the same sequence, so we will not need to use the<strong> Sequences</strong> window, but we will be going over it in <a class="link" href="ch05.html" title="Chapter 5. Action Sequences for Urban Warrior">Chapter 5</a>, <em>Acti on Sequences for Urban Warrior</em>.</li><li class="listitem">Right-click anywhere inside the large area in the upper portion of the interface. Choose to create a<strong> Player Spawned</strong> event by choosing<strong> New Event</strong> |<strong> Player</strong> |<strong> Player Spawned</strong> from the menu that pops up.</li><li class="listitem">Left-click? on the<strong> Player Spawned Event Sequence</strong> object so that the<strong> Properties</strong> window comes up and change the value of<strong> Max Trigger Count</strong> from<code class="literal"> 1</code> to<code class="literal"> 0</code>.<a class="indexterm" id="id245"/><div><img alt="Time for action—changing the level to a third-person perspective" height="60" src="img/image_1901_04_03.jpg"/></div><p>Having a value of 0 means that it can be triggered an infinite number of times.
</p></li><li class="listitem">Right-click under the instigator connection (the purple/pink arrow) and select<strong> Create New Object Variable</strong>.</li><li class="listitem">Right-click and create a<strong> Console Command</strong> action by choosing<strong> New Action</strong> |<strong> Misc</strong> |<strong> Console Command</strong> from the menus.</li><li class="listitem">Inside the properties, type<code class="literal"> behindview 1</code> as the value for<strong> Commands[0]</strong>.<div><img alt="Time for action—changing the level to a third-person perspective" height="72" src="img/image_1901_04_04.jpg"/></div></li><li class="listitem">Connect the output from the<strong> Player Spawned</strong> event to the input of the<strong> Console Command</strong> action by clicking on the square on the right-hand side of the<strong> Out</strong> text on the<strong> Player Spawned</strong> event and dragging your mouse, until it reaches the black square on the left-hand side of the<strong> In</strong> text.</li><li class="listitem">Connect the connector of both the<strong> Instigator</strong> and<strong> Target</strong> to the<strong> Object</strong> variable we created earlier.<p>By this point your Kismet should look similar to the following screenshot:
</p><div><img alt="Time for action—changing the level to a third-person perspective" src="img/image_1901_04_05.jpg" width="119"/></div></li><li class="listitem">Now start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar.? You will see the following screenshot:<a class="indexterm" id="id246"/><div><img alt="Time for action—changing the level to a third-person perspective" src="img/image_1901_04_06.jpg" width="216"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec01"/>What just happened?</h2></div></div></div><p>Upon starting the game, when the player is spawned (the<strong> Player Spawned</strong> event is activated), we change our perspective to be in the third person (the<strong> Console Command</strong> action is called).? We've also learned some fundamentals in working with Kismet and have an understanding of how sequence objects connect to create different effects. Not too shabby for only using two sequence objects.<a class="indexterm" id="id247"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec04"/>Kismet primer</h1></div></div></div><p>While working? with Kismet, some of the terms may be difficult to understand at first, so I would like to quickly go over some aspects of Kismet in general.<a class="indexterm" id="id248"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec02"/>Parts of a sequence object</h2></div></div></div><p>Every node we work with is called a<strong> sequence object</strong>, because it is an object within a sequence. We will be talking more about sequences in <a class="link" href="ch06.html" title="Chapter 6. Bringing it All Together">Chapter 6</a>,<em> Bringing It All Together</em>, but for now let's talk about the parts that make up a Kismet node.<a class="indexterm" id="id249"/>
</p><div><img alt="Parts of a sequence object" height="76" src="img/image_1901_04_07.jpg"/></div><p>The left-hand side of a sequence object is? called the<strong> Input</strong>; while the right-hand side is called the<strong> Output</strong>. The following are the variables that are either values given to us, or that we set depending on the object.<a class="indexterm" id="id250"/>
</p><p>There are four different kinds of sequence objects, three of which we will be using in this chapter and we will be using the fourth in <a class="link" href="ch05.html" title="Chapter 5. Action Sequences for Urban Warrior">Chapter 5</a>,<em> Action sequences For Urban Warrior</em>. The following screenshot shows the sequence objects:</p><div><img alt="Parts of a sequence object" height="157" src="img/image_1901_04_08.jpg"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Events</strong>: This is what all other sequence? objects get called from. Code in Kismet only gets called if a certain thing happens, like the<strong> Player Spawned</strong> event that was called when the player spawns in our level. These objects are red and are shaped like diamonds.<a class="indexterm" id="id251"/></li><li class="listitem" style="list-style-type: disc"><strong>Actions</strong>: These perform a defined task when an event is triggered. This is the most used item, so it is the object with the most variety. The<strong> Console Command</strong> action, as well as the<strong> Delay</strong> used previously, is an example of an action. Actions are presented as rectangles.<a class="indexterm" id="id252"/></li><li class="listitem" style="list-style-type: disc"><strong>Variables</strong>: These are what hold information within our level. If another sequence object has squares underneath it, that is a spot that holds a variable. They are colored differently depending on what the variable actually is. The instigator in the<strong> Player Spawned</strong> event? is a variable that is filled with our player's information when it is called, and the<strong> Blue</strong> number under the<strong> Delay</strong> variable in the previous screenshot is a float variable with the value of<code class="literal"> 2.0</code>. We will be using variables extensively in <a class="link" href="ch06.html" title="Chapter 6. Bringing it All Together">Chapter 6</a>,<em> Bringing It All Together</em>. Variables are represented as circles.<a class="indexterm" id="id253"/></li><li class="listitem" style="list-style-type: disc"><strong>Conditions</strong>: These actions are special in the fact? that they can do different things based on the values of different objects used for comparing numbers or objects. They are used to control the flow of things within a sequence. The<strong> Compare Objects</strong> condition is an example of a condition. Conditions are traditionally blue and are rectangular.<a class="indexterm" id="id254"/></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Benefits and drawbacks of using Kismet</h1></div></div></div><p>As with any job, it is important to use the tool that is appropriate for it. UDK provides three ways of giving interactivity to the game world: Kismet (which we are discussing), Matinee (which we are going to discuss), and UnrealScript (which is out of the scope of this book, but it is covered extremely well in<em> Unreal Development Kit Game Programming with UnrealScript: Beginner's Guide</em> by<em> Rachel Cordone</em> which is also available from Packt Publishing). All three have specific advantages and disadvantages to them, but Kismet is the one that I use most often.</p><p>As you expand your research into UDK after reading this book, you may see forum posts with people asking how to do something in Kismet. A lot of people will reply to telling them to learn UnrealScript instead. While they may seem arrogant, there are some reasons why they are saying to use that tool. I've included a list of pros and cons of Kismet which may help you, afterwards, in deciding if it is the correct tool for what you're working on.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec03"/>Benefits of using Kismet</h2></div></div></div><p>Kismet is a wonderful tool and is a great starting point when first starting out with UDK. Some other benefits associated with Kismet are:<a class="indexterm" id="id255"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Having a lower barrier to entry</strong>: No programming knowledge is needed so it is easier to get started and you can start creating games now.</li><li class="listitem" style="list-style-type: disc"><strong>Great for prototyping gameplay mechanics</strong>: Saying a mechanic is going to be fun is one thing, but no one is going to believe you unless you can prove it. Kismet makes it extremely easy to get something up quickly. As a designer, having something to show a programmer will make it much easier for them to translate to code.</li><li class="listitem" style="list-style-type: disc"><strong>Great for one-off events</strong>: If your level needs to have something specific or only at a specific time or level events like an explosion, Kismet is a great tool to use.</li><li class="listitem" style="list-style-type: disc"><strong>Easier to see the flow of events</strong>: If you are more of a visual thinker or like to stare at something to see the big picture, it is a lot easier to use Kismet. The Sequence Objects and colors all mean something specific to make it easy to discern what is going on within a specific scene.</li><li class="listitem" style="list-style-type: disc"><strong>Easily extendable with UnrealScript</strong>: With knowledge of how UnrealScript works, it is possible to create custom sequence objects of your own to create actions of your very own. If your game would have a dialogue system, creating a custom<strong> Show Dialog</strong> action would be possible in Kismet to make it easy to create entire dialog trees within Kismet.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec04"/>Drawbacks</h2></div></div></div><p>However, Kismet is not the be-all and end-all solution for everything that can possibly be done with UDK. Here are some of the drawbacks that using Kismet may have:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Complexity issues</strong>: As you get more comfortable using Kismet, you will probably try to? do more and more complex things with it (I know I have). If you are not careful you may have problems reading what your code is actually doing. Basically, the more complex a sequence gets, the harder it is to read.<a class="indexterm" id="id256"/></li><li class="listitem" style="list-style-type: disc"><strong>Reiterations</strong>: Many times in a game, you will want to have the same thing happen if you interact with a similar or identical object, like a door. If you want the same behavior with multiple objects or multiple levels, you have to paste it every single time you want to have that action happen. This can quickly stockpile into a really large amount of sequence objects which could be avoided if you wrote an UnrealScript file with the same behavior and made that object use that file to execute the actions within it.</li><li class="listitem" style="list-style-type: disc"><strong>Level Specific</strong>: In much the same way Kismet is also specific to just the level that it is created in. For instance, if we wanted to create ten levels in our game, we would have to do the console command event in every single level. With UnrealScript, this would be built into the code base for the game and be automatic for all levels of the game.</li><li class="listitem" style="list-style-type: disc"><strong>Kismet can't do everything you'd like to in a game</strong>: The truth is that the game Unreal Engine 3 was created to make a<strong> First Person Shooter</strong> (<strong>FPS</strong>), and the further you stray from that path, the harder it is going to be to create your game. That's not to say UDK can't be used to create other games. It's just going to be much more difficult as the sequence objects in Kismet are meant to create an FPS.</li><li class="listitem" style="list-style-type: disc"><strong>More custom behavior requires UnrealScript</strong>: Continuing with the previous point, most of the time a game does something such as a game mechanics that UDK doesn't seem to do (like the Scarecrow boss battles in<em> Batman: Arkham Asylum</em>, "Plasmids" in<em> Bioshock 1</em> and<em> 2</em>, or the jet packs in<em> Dark Void</em>). These examples probably use UnrealScript or C++ code to achieve the desired result.</li><li class="listitem" style="list-style-type: disc"><strong>Kismet is slower than UnrealScript</strong>: While it will not matter with the project that we are creating now, as Kismet is basically a prewritten UnrealScript executed in a certain order, Kismet is slower than what could be achieved using just UnrealScript, and something that your game will continuously use would best be done with UnrealScript.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec05"/>Have a go hero—Kismet</h2></div></div></div><p>Console commands can do a lot of different things, giving you access to a lot of prewritten code including opening other maps (<code class="literal">open levelname</code>), and quitting the game (<code class="literal">quit</code>).</p><p>Try to make the game open another map when you start the level.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Defining Matinee</h1></div></div></div><p>The<strong> Matinee</strong> tool is the driving force of all cinematic effects within the Unreal Engine. It gives users the ability to be the director within your game, giving you control over the camera, actor's movement, sound, as well as different cuts and animation effects. Think of any moment in an Unreal game where you didn't have direct control over the character, like a cutscene. Chances are, that was done in Matinee. However, Matinee can be used for many other things which we will discuss later.<a class="indexterm" id="id257"/>
</p><p>In order to create a Matinee, we will use the (aptly named) Matinee Editor which can be accessed from within the Kismet menu.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec07"/>Creating your first Matinee movie</h1></div></div></div><p>Having defined what Matinee is used for, let's begin using it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Time for action—opening cutscene</h1></div></div></div><p>As things are, when the game begins we are brought straight into the action with no prior warning. In order to prepare the player and give them an idea of where they are, let's create a cutscene!<a class="indexterm" id="id258"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Go to the<strong> Actor Classes</strong> browser<strong> View</strong> |<strong> Browser Windows</strong> |<strong> Actor Classes</strong>. From there, you will see a list of classes that we can place within our level. Left-click on the<strong> CameraActor</strong> selection.<div><img alt="Time for action—opening cutscene" height="112" src="img/image_1901_04_09.jpg"/></div></li><li class="listitem">Close out the<strong> Actor Classes</strong> browser and right-click anywhere in your level. From the menu that pops up, select<strong> Create CameraActor Here</strong>. This will create an actor on the ground, in the spot in the spot where you clicked. It may be a good idea to position the camera above the player and looking at it.<a class="indexterm" id="id259"/><div><img alt="Time for action—opening cutscene" height="105" src="img/image_1901_04_10.jpg"/></div></li><li class="listitem">If it isn't already up, open the Kismet editor by clicking on the<strong> K</strong> icon at the top of the UDK interface on the main toolbar.</li><li class="listitem">Create a new Matinee by right-clicking inside the large area in the upper portion of the interface and selecting<strong> New Matinee</strong>. You should see an orange square pop out with a lot of different inputs and outputs.<div><img alt="Time for action—opening cutscene" src="img/image_1901_04_11.jpg" width="115"/></div></li><li class="listitem">Double-click on the object to enter the Matinee editor as shown in the following screenshot:<a class="indexterm" id="id260"/><div><img alt="Time for action—opening cutscene" src="img/image_1901_04_12.jpg" width="376"/></div></li><li class="listitem">Minimize Matinee and select your<strong> CameraActor</strong> on the main screen by left-clicking on it and then bringing Matinee up. Right-click inside the<strong> Group List</strong> (the dark-grey column below all the tabs with text and at left-hand side to the timeline.) From the<strong> Context</strong> menu that appears, click on<strong> Add New Camera Group</strong>. When prompted for a name type in<code class="literal"> Camera</code>.<a class="indexterm" id="id261"/><div><img alt="Time for action—opening cutscene" height="115" src="img/image_1901_04_13.jpg"/></div></li><li class="listitem">If you click on the little camera icon in the top-left of the<strong> Camera</strong> group, you will see the<strong> Perspective</strong> viewport changes into the camera's view.</li><li class="listitem">If the camera icon doesn't show up, that means the camera is not connected to the group. To fix this, left-click on your camera inside the editor and then go back into Kismet. From there, right-click below the<strong> Camera</strong> text in the Matinee that we have created and select<strong> Create New Object Var Using CameraActor_0</strong> and connect it to the<strong> Camera</strong> slot.<div><img alt="Time for action—opening cutscene" src="img/image_1901_04_14.jpg" width="99"/></div></li><li class="listitem">Click on the<strong> Movement</strong> track on the<strong> Camera</strong> and then click on the first keyframe (the red triangle located in the timeline). You will notice that the bottom of the<strong> Perspective</strong> viewport changes its text to<strong> ADJUST KEY Movement0</strong>. Now if you move within the viewport, it will transfer over to the Camera actor that we have created. Once you have moved your camera to the spot where? you want it, click outside of the keyframe in the Matinee window.<a class="indexterm" id="id262"/></li><li class="listitem">Right-click underneath<strong> Camera</strong> and select<strong> Add New Director Group</strong>.</li><li class="listitem">Left-click on the<strong> Director</strong> track and then click on the<strong> Add Key</strong> icon which is the first icon just below the<strong> File</strong> menu (circled in the following screenshot in red) to add a new keyframe,to say, we want to use a different camera at this position. Select to use<strong> Camera for the Cut To Group</strong> and click on<strong> OK</strong>.<div><img alt="Time for action—opening cutscene" height="82" src="img/image_1901_04_15.jpg"/></div></li><li class="listitem">Left-click on the<strong> Movement</strong> track again. Drag the time slider from<strong> 0.00</strong> to the<strong> 2.00</strong> second mark, to the grey bar along the bottom of the Matinee area where all of the numbers are located.</li><li class="listitem">Left-click on the<strong> Add Key</strong> icon to add a new keyframe to our movie. If all goes well, you should see something similar to the following screenshot:<a class="indexterm" id="id263"/><div><img alt="Time for action—opening cutscene" src="img/image_1901_04_16.jpg" width="280"/></div></li><li class="listitem">With the keyframe selected, move the camera closer to the player. At this point, if you drag the time slider, you will notice that the camera moves between the? two points that we have created over the course of two seconds.<a class="indexterm" id="id264"/></li><li class="listitem">Left-click somewhere else on the timeline to remove the focus on the keyframe. Move the mouse scroller down in order to zoom-out from the timeline. You will notice a pink triangle pointing outwards at the 5.00 mark. That object marks the ending of the Matinee sequence, so click on it and drag it to the second mark.</li><li class="listitem">You can also right-click on it and select<strong> Move to Longest Track Endpoint</strong> and it will automatically snap to the last keyframe added.</li><li class="listitem">Close up Matinee and bring Kismet back up. Right-click next to the<strong> Console Command</strong> action that we created earlier, and select<strong> NewAction</strong> |<strong> Toggle</strong> |<strong> ToggleCinematicMode</strong>.</li><li class="listitem">Inside the properties for the<strong> ToggleCinematicMode</strong>, disable the<strong> HidePlayer</strong> option. Connect the<strong> Target</strong> to the<strong> Instigator</strong> from the<strong> Player Spawned</strong> event we created in the previous example. Left-click on the sequence object and copy it by pressing<em> Ctrl</em> +<em> C</em>.</li><li class="listitem">Paste the sequence object by pressing<em> Ctrl</em> +<em> V</em> and move the created sequence object to the right-hand side of the Matinee by holding<em> Ctrl</em> and dragging while it is selected.</li><li class="listitem">Remove the connections to the<strong> Console Command</strong> action by holding the<em> Alt</em> key and clicking on the<strong> In</strong> and<strong> Out</strong> connectors. Drag the action next to the second?<strong> Toggle Cinematic Mode</strong> action by clicking on it, holding<em> Ctrl</em> and dragging it over. Connect the<strong> Out</strong> from the<strong> Player Spawned</strong> action to the<strong> Enable</strong> of the first<strong> Toggle Cinematic Mode</strong>. Connect that<strong> Out</strong> to the<strong> Play</strong> of the Matinee, connect the<strong> Completed</strong> output to the<strong> Disable</strong> input of the second Toggle Cinematic Mode, and finally, connect the<strong> Out</strong> on the<strong> Toggle Cinematic Mode</strong> to the input on the<strong> Console Command</strong>.<a class="indexterm" id="id265"/><div><img alt="Time for action—opening cutscene" height="115" src="img/image_1901_04_17.jpg"/></div></li><li class="listitem">Save your project (<strong>File</strong> |<strong> Save</strong>) and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar.<div><img alt="Time for action—opening cutscene" src="img/image_1901_04_18.jpg" width="244"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec06"/>What just happened?</h2></div></div></div><p>We have created our first cinematic moment in Unreal! Now when our game starts, we zoom into our character enabling our players to get ready for the action leading up ahead. While it may have been a bit of a hassle to get such a simple movement, it is easy to see the great potential to create many exciting things with the Matinee tool!<a class="indexterm" id="id266"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec07"/>Have a go hero—Matinee</h2></div></div></div><p>You can easily add more key points to this opening cutscene and extend its length to as long as you want. You can also add another<strong> CameraActor</strong> and switch between cameras while the movie is going on. Take some time to coast through your level and maybe spin around the player as the game begins.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec09"/>With our powers combined...</h1></div></div></div><p>Now that we have learned some fundamentals of using Kismet and Matinee, let's do a non-trivial example of something that can be done with them both together.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Time for action—creating an automatic door</h1></div></div></div><p>If your game takes place somewhere that humans reside, chances are you are going to have a door, and as a? player, we are drawn to them to continue a level. With that in mind, let's create a door that will automatically open for us when someone comes near it, and close when it is empty.<a class="indexterm" id="id267"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Go back into the main editor window and access the<strong> Content Browser</strong> via<strong> View</strong> |<strong> BrowserWindows</strong> |<strong> ContentBrowser</strong>.</li><li class="listitem">In the<strong> Object Type</strong> tab, check the<strong> Static Meshes</strong> option as we only want to see Static Meshes. In the top search bar, type in<code class="literal"> doorway</code>. Left-click on the mesh selected and close the<strong> Content Browser</strong>.<div><img alt="Time for action—creating an automatic door" src="img/image_1901_04_19.jpg" width="395"/></div></li><li class="listitem">Right-click somewhere in your level and select<strong> AddActor</strong> |<strong> LoadStaticMesh:S_LT_Doors_SM_DoorWar04</strong>. Right-click again and select<strong> Add Static StaticMesh:S_LT_Doors_SM_DoorWar04</strong>.<a class="indexterm" id="id268"/></li><li class="listitem">Right-click on the door we placed and select<strong> Convert</strong> |<strong> ConvertStaticMeshActortoMover?</strong>.<a class="indexterm" id="id269"/></li><li class="listitem">Go into the properties for the door (<em>F4</em>) and type<code class="literal"> collision</code> into the search bar. Change the<strong> CollisionType</strong> variable on the bottom to<strong> COLLIDE_BlockAll</strong>.</li><li class="listitem">Use the<strong> Builder Brush</strong> and<strong> Additive Geometry</strong> discussed in <a class="link" href="ch02.html" title="Chapter 2. Beginning Urban Warrior, a Third-person Shooter">Chapter 2</a>,<em> Beginning Urban Warrior; a First Person Shooter</em> to build a brush on each side of the door and one on top that covers the entire distance above the door.<div><img alt="Time for action—creating an automatic door" height="106" src="img/image_1901_04_20.jpg"/></div><p>Notice how the brush does not go all the way to the door and, if we make the brush larger, it will cover part? of the door. Luckily for us, there is an easy way to make the walls flush with the door we want to use.
<a class="indexterm" id="id270"/>
</p></li><li class="listitem">Use the<strong> Side</strong> viewport and click on the button that looks like a 3D cube to go into<strong> Geometry Mode</strong>. Click on the right side brush and make sure you are in translation mode by either clicking on the menu icon that looks like four arrows crossing, or by pressing<em> Spacebar</em> until you see the arrows to translate. Click on the top square at left-hand side to turn it red so that it is selected and drag it over to the edge of the door Do the opposite for the other brush.<p>I will be going over <strong>Geometry Mode</strong> and how it can be used to create gameplay areas and allow for fast prototyping of gameplay areas in <a class="link" href="ch06.html" title="Chapter 6. Bringing it All Together">Chapter 6</a>, <em>Bringing It All Together</em>.</p><div><img alt="Time for action—creating an automatic door" height="115" src="img/image_1901_04_21.jpg"/></div></li><li class="listitem">Use the<strong> Top</strong> viewport and create a brush that is in the middle of the door with space in front and behind the door. Right-click on that brush and select<strong> Convert</strong> |<strong> ConverttoVolume</strong> |<strong> Trigger Volume?</strong> to change the brush into a trigger volume. After this, save your map and click on<strong> Build All</strong>.<a class="indexterm" id="id271"/><div><img alt="Time for action—creating an automatic door" src="img/image_1901_04_22.jpg" width="293"/></div></li><li class="listitem">Click on the<strong> Trigger Volume</strong> that we've created to select it and open the Kismet editor by clicking on the<strong> K</strong> icon at the top of the UDK interface on the main toolbar.</li><li class="listitem">Right-click anywhere inside the large area in the upper portion of the interface. Create a<strong> Trigger Volume Touch</strong> event by choosing<strong> New Event using TriggerVolume_0</strong> |<strong> Touch</strong> from the menu that pops up.</li><li class="listitem">Left-click on the<strong> TriggerVolume_0 Touch</strong> event object so that the properties window comes up and change the value of<strong> MaxTriggerCount</strong> from<code class="literal"> 1</code> to<code class="literal"> 0</code>.</li><li class="listitem">We want to have a sound play when the door opens and when it closes, so create two<strong> Play Sound</strong> actions using<strong> NewAction</strong> |<strong> Sound</strong> |<strong> PlaySound</strong>.</li><li class="listitem">Go into the<strong> Content Browser</strong> and change the object type you're looking for to<strong> SoundCue</strong> and change the search to just<strong> door</strong>. Select the first SoundCue<strong> A_Door_Metal03_CloseStartCue</strong> and go back into Kismet.</li><li class="listitem">Select the bottom<strong> Play Sound</strong> action. Inside the properties, you should see an icon that looks like a green arrow pointing at the left-hand side, next to the<strong> PlaySound</strong> property. Click on that button and it should fill the box with the value of what you have selected in the<strong> Content Browser</strong>.</li><li class="listitem">Repeat steps from step 13 to step 14 using<strong> A_Door_Metal03_OpenStartCue</strong> and the top<strong> PlaySound</strong> respectively.<a class="indexterm" id="id272"/></li><li class="listitem">Back in the editor, click on the door and go back into Kismet. Create a new Matinee object by right-clicking next to the<strong> Touch Event</strong> and selecting<strong> NewMatinee</strong>.</li><li class="listitem">Go into the Matinee editor by double-clicking on the Matinee. Right-click inside the<strong> Group List</strong> and click on<strong> AddNewCameraGroup</strong>. When prompted for a name, type in<code class="literal"> Door</code>.</li><li class="listitem">Create a keyframe at the<code class="literal"> 0.50</code> position and, with it selected, left-click on the door in the<strong> Perspective</strong> viewport. Move the door to the left-hand side till it completely leaves the opening, making it possible for people to pass through.</li><li class="listitem">Right-click on the end of the Matinee sequence (the pink triangle pointing out) and select<strong> MovetoLongestTrackEndpoint</strong>. Close Matinee and bring Kismet back up.</li><li class="listitem">Connect the<strong> Target</strong> of both<strong> Play Sound</strong> actions to be the door in our Matinee sequence, so that we will hear the sound coming from the door.</li><li class="listitem">From the<strong> TriggerVolume_0 Touch</strong> event connect the<strong> Touched</strong> output to the<strong> Play</strong> input on the top<strong> Play Sound</strong> event. Then, connect the<strong> Empty</strong> output to the<strong> Play</strong> input on the bottom<strong> Play Sound</strong> event. Connect the<strong> Out</strong> on the top<strong> Play Sound</strong> to the<strong> Play</strong> on the Matinee sequence. Connect the<strong> Out</strong> on the bottom<strong> Play Sound</strong> to the<strong> Reverse</strong> input on the Matinee sequence.<div><img alt="Time for action—creating an automatic door" height="176" src="img/image_1901_04_23.jpg"/></div></li><li class="listitem">Save your project (<strong>File</strong> |<strong> Save</strong>) and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar.<a class="indexterm" id="id273"/><div><img alt="Time for action—creating an automatic door" src="img/image_1901_04_24.jpg" width="260"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec08"/>What just happened?</h2></div></div></div><p>We have created one of the most used interactive objects within games: a door. With this basic idea, it is possible to do many similar things, such as moving platforms and elevators, as well as complex things like machinima using a game engine to create a cinematic production like<em> Rooster Teeth's Red versus Blue</em> or Epic's own<em> Samaritan</em> demo. There's plenty more you can do with Matinee, but it is best for you to explore on your own to discover things through experimentation.<a class="indexterm" id="id274"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec11"/>Kismet for mobile devices</h1></div></div></div><p>All of the examples we have seen can be and are used in the normal version of UDK and transfer to? our mobile iOS game nicely. Most things in Kismet will work on mobiles as well, as long as the GameType supports it. Since it started supporting mobile devices, UDK has provided a set of sequence objects that are targeted for the mobile platform.<a class="indexterm" id="id275"/>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec12"/>Mobile Kismet—actions</h1></div></div></div><p>Unlike the traditional UDK game that would require either changing<code class="literal"> .ini</code> files or writing UnrealScript to accept and respond to input, UDK gives mobile developers the ability to do things how they want directly in Kismet. This allows developers to change input on a per-level basis.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec09"/>Add Input Zone</h2></div></div></div><p>
<strong>Add Input Zone</strong> displays an additional input zone to the screen. Zones need to have a unique name and will be referenced by their<strong> Zone Name</strong> property in other sequence objects when using them. We will be using this action later in the chapter in order to add buttons to our UI and learn how to create different kinds of zones for use in our project.<a class="indexterm" id="id276"/>
</p><div><img alt="Add Input Zone" height="27" src="img/image_1901_04_25.jpg"/></div><p>This action is found in<strong> NewAction</strong> |<strong> Mobile</strong> |<strong> AddInputZone</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec10"/>Clear Input Zone</h2></div></div></div><p>This action removes all of the zones that were created or loaded at runtime. This basically leaves you with a clean slate to build an input scheme of your own. This is great if you are creating a game that does not require movement, or uses a different way of moving than what the provided ones do.<a class="indexterm" id="id277"/>
</p><div><img alt="Clear Input Zone" height="25" src="img/image_1901_04_26.jpg"/></div><p>This action is found in<strong> NewAction</strong> |<strong> Mobile</strong> |<strong> ClearInputZones</strong>.</p><div><h3 class="title"><a id="note09"/>Note</h3><p>Using this action would also remove the<strong> UberStickMoveZone</strong> and<strong> UberStickLookZone</strong> joystick inputs leaving only the<strong> UberLookZoneInput</strong> zone left. Be sure to add them back if you'd like to have them within your project. However, that being said, it is likely best for users to avoid using this Event unless it is for a specific purpose within a single level. If we don't want parts of the default input zones for all levels, it is best that we modify the<strong> RequiredMobileInputConfigs</strong> of the<code class="literal"> DefaultGameUDK.ini</code> file to fit our purposes.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Remove Input Zone</h2></div></div></div><p>This action allows you to remove an input zone by name; it is useful if you want to make an interaction?? only available at certain times of a game, like a save menu or a<strong> Talk</strong> button used for dialog. The<strong> Zone Name</strong> property can be found within the properties of the sequence object.<a class="indexterm" id="id278"/>
</p><div><img alt="Remove Input Zone" height="26" src="img/image_1901_04_27.jpg"/></div><p>This action is found in<strong> NewAction</strong> |<strong> Mobile</strong> |<strong> RemoveInputZone</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Save/Load values</h2></div></div></div><p>This, as the name suggests, saves or loads variables created within Kismet from the hard drive using Kismet. You can hook up multiple variables to the same action allowing you to?? have as many variables as you like, but each variable needs to have a name within the<strong> Var Name</strong> property to be saved. I recommend that you use the same action for both loading and saving the same values. This way the order in which the variables are loaded are the same in which they were saved. If you have ten integers hooked to the same<strong> Int Vars</strong> holder Kismet does not guarantee the order in which it decides to place it and using the same action saves you the headache.<a class="indexterm" id="id279"/>
</p><div><img alt="Save/Load values" height="76" src="img/image_1901_04_07.jpg"/></div><p>This action is found in<strong> NewAction</strong> |<strong> Mobile</strong> |<strong> Save/LoadValues</strong>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec13"/>Mobile Kismet—events</h1></div></div></div><p>Taking the input from input zones, as well as the iPod's own gyroscopes and gadgets, we can make use of certain functionality with events, as well as create our own<strong> HUD</strong> graphics.<a class="indexterm" id="id280"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Analog Input</h2></div></div></div><p>Working on PC, Console, and Mobile,<strong> Analog Input</strong> will fire whenever an analog input, used with the<strong> Input Name</strong> that you set with, has a value.</p><p>Some values that you can use include<code class="literal"> MobileYaw</code> and<code class="literal"> MobilePitch</code> which give values from the device's gyroscope. These will give you float values inside of the<strong> Float Value</strong> variable.<strong> DeviceAccelerometerRawData</strong> will return a vector with the<code class="literal"> Roll, Portrait Pitch</code>, and<code class="literal"> Landscape Pitch</code> in the<strong> Vector Value</strong> variable.<a class="indexterm" id="id281"/>
</p><p>It is important to note that unless you set<strong> Trap</strong> input to<strong> FALSE</strong> (by unchecking it), nothing else will be able to receive any input events, including touches.</p><div><img alt="Analog Input" height="100" src="img/image_1901_04_28.jpg"/></div><p>This action is found in<strong> New Event</strong> |<strong> Input</strong> |<strong> AnalogInput</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Mobile Button Access</h2></div></div></div><p>If you are not referencing something that was already created from a<code class="literal"> .ini</code> file, you will be using<strong> Mobile Button Access</strong> to trigger stuff within Kismet. This is similar to how the<strong> Touch</strong> event was shown previously. The property<strong> Target Zone Name</strong> should contain the name of an already created input zone. There are some properties that you can use, such as<strong> Send Press Only On Touch Down</strong> which will only call the<strong> Input Pressed Output</strong> when you click on the button and<strong> Send Press Only On Touch Up</strong> which will only be called when you remove your finger. Otherwise, as long as the button is held down, the action will be called.<a class="indexterm" id="id282"/>
</p><div><img alt="Mobile Button Access" src="img/image_1901_04_29.jpg" width="101"/></div><p>This action is found in<strong> New Event</strong> |<strong> Input</strong> |<strong> Mobile Button Access</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Mobile Input Access</h2></div></div></div><p>The Mobile Input Access action is used whenever you have an input zone set with the value of<strong> Mobile Input Zone</strong> to<strong> ZoneType_Joystick. Input Active</strong> is called in each frame when the joystick is being used, while<strong> Input Inactive</strong> is used when it is released. Creating variables for the bottom sections gives you access to different values that you can use for interpreting how you are going to use the data.<strong> X-Axis</strong> and<strong> Y-Axis</strong> give you a value between<strong> -1.0</strong> and<strong> 1.0</strong>, where<strong> -1.0</strong> is all the way down or left, and<strong> 1.0</strong> is up or right. If you would prefer to be more precise, the four other values give you the pixel values of where the joystick's center and current position are.<a class="indexterm" id="id283"/>
</p><div><img alt="Mobile Input Access" height="110" src="img/image_1901_04_30.jpg"/></div><p>This action is found in<strong> New Event</strong> |<strong> Input</strong> |<strong> MobileInputAccess</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Mobile Look</h2></div></div></div><p>Mobile Look is extremely similar to the<strong> Mobile Input Access</strong> event, in that they both have the same type of outputs and are used with an input zone with<strong> ZoneType_Joystick</strong> as the<strong> Mobile Input Zone</strong>. However, the<strong> Mobile Look</strong> action takes the data and converts it into a Vector that represents the current vertical and horizontal axes of the joystick, instead of individual values which can be easily applied to a pawn using<strong> New Action</strong> |<strong> Actor</strong> |<strong> Set Actor Location</strong>. The<strong> Yaw?</strong> represents the direction the joy stick is moving in<strong> Unreal Rotator</strong> units where<strong> 0</strong> is straight up and the rotation increases clockwise. The<strong> Strength</strong> gives the distance of the current location of the touch to the center of the joystick in pixels. This can be quite useful for top-down games.<a class="indexterm" id="id284"/>
</p><div><img alt="Mobile Look" src="img/image_1901_04_31.jpg" width="116"/></div><p>This action is found in<strong> New Event</strong> |<strong> Input</strong> |<strong> Mobile Look</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Mobile Object Picker</h2></div></div></div><p>
<strong>Mobile Object Picker</strong> is a simple way to check if target object with collision is being touched by a<strong> Touch</strong> input if it is within the<strong> Trace Distance</strong> away from the player. It will only call once unless you set<strong> Check on Touch</strong> to<strong> TRUE</strong>, then it will call once every frame. Like everything that does an action every frame, it is advised to set a<strong> Re Trigger Delay</strong> to some value such as<code class="literal"> 0.2</code> in order to put less strain on the hardware.</p><div><img alt="Mobile Object Picker" src="img/image_1901_04_32.jpg" width="93"/></div><p>This action is found in<strong> New Event</strong> |<strong> Input</strong> |<strong> Mobile Object Picker</strong>.<a class="indexterm" id="id285"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Mobile Simple Swipes</h2></div></div></div><p>The<strong> Mobile Simple Swipes</strong> event provides a simplistic form of swipe detection using different outputs depending on the swipe's direction. The<strong> Tolerance</strong> variable can be set to allow a swipe to occur on a more or less straight line and the<strong> Min Distance</strong> variable sets how long the swipe needs to be to be considered a swipe to make the move more or less drastic. The bottom value in purple,<strong> Touched Actors List</strong>, returns an object list which contains all of the actors with collision that were touched in the process of the swipe.<a class="indexterm" id="id286"/>
</p><div><img alt="Mobile Simple Swipes" src="img/image_1901_04_33.jpg" width="85"/></div><p>This action is found in<strong> New Event</strong> |<strong> Input</strong> |<strong> Mobile Simple Swipes</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Touch Input</h2></div></div></div><p>Any time the user touches the screen, it is considered a<strong> Touch</strong> event. The input system has the ability to track multiple touches at the same time by using the<strong> Touch Index</strong> with the<strong> Touchpad Index</strong> to refer to the input zone values that you provided.<strong> Touch X</strong> and<strong> Touch Y</strong> will give you the value in pixels of where in screen space they are and<strong> Instigator</strong> will refer to the<strong> Player Controller</strong> that did the touching. You may choose to use<strong> Pressed</strong> for a triggered event with<strong> Repeated</strong> to continue while the touch exists.<strong> Released</strong> will be called whenever the player removes his finger from the<strong> Touch</strong> event.<a class="indexterm" id="id287"/>
</p><div><img alt="Touch Input" height="99" src="img/image_1901_04_34.jpg"/></div><p>This action is found in<strong> New Event</strong> |<strong> Input</strong> |<strong> Touch Input</strong>.</p><div><h3 class="title"><a id="note10"/>Note</h3><p>Unless you set<strong> Trap Input</strong> to<strong> FALSE</strong> by unchecking it, you will be unable to use any other input zones while using this event.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Draw Image</h2></div></div></div><p>The<strong> Draw Image</strong> action displays the<strong> Texture2D</strong> image in<strong> Display Texture</strong> as a<strong> HUD</strong> of sorts for players to use within your game as long as<strong> Active/Is Active</strong> are set to be<strong> TRUE</strong>. The<strong> XL</strong> and<strong> YL</strong> values are used to show how large the image should be to display<strong> 1.0</strong> means to fill the screen 100% within the respective axis.<strong> U</strong> and<strong> L</strong> are the location of the top-left corner of that texture to draw.<strong> UL</strong> and<strong> VL</strong> are the horizontal and vertical width in pixels of the portion of the texture to be drawn. Make sure to change the<strong> Display Color</strong> to white as that is the color that it will be modulated by.<a class="indexterm" id="id288"/>
</p><p>There is a variable called<strong> Authored Global Scale</strong>, which specifies the scale factor of the display the content is being used in. A value of<code class="literal"> 2.0</code> is useful for high resolution screens like the iPhone 4S and new iPad, while<code class="literal"> 1.0</code> is useful for standard resolution screens such as the iPad and older iPhones/iPod Touches. It is also worth noting that the<strong> Out</strong> output does not actually get called.<a class="indexterm" id="id289"/>
</p><div><img alt="Draw Image" src="img/image_1901_04_35.jpg" width="134"/></div><p>This action is found in<strong> New Event</strong> |<strong> HUD</strong> |<strong> Draw Image</strong>.</p><div><h3 class="title"><a id="note11"/>Note</h3><p>This will not work with the gametype of<strong> UTDeathmatch</strong>. We will make use of this for our Main Menu, which we will be creating in <a class="link" href="ch07.html" title="Chapter 7. Advanced Content Creation for Urban Warrior">Chapter 7</a>, <em>Advanced Content Creati on for Urban Warrior</em>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Draw Text</h2></div></div></div><p>This event will display a string of text provided by<strong> Display Text</strong> on the screen. Be sure to set a value for??<strong> Display Font</strong> using one of the fonts provided in the<strong> Content Browser</strong>. There are two<strong> Text Draw Method</strong> choices in how the text is going to be drawn on the screen;<strong> DRAW_CenterText</strong> which centers the text horizontally from the<strong> Display Location</strong> variable and<strong> DRAW_WrapText</strong> which draws the text wrapped starting from the<strong> Display Location</strong>. The text will be displayed as long as<strong> Active/Is Active</strong> are set to<strong> TRUE</strong>. The<strong> Target</strong> is the player that we want this information to be displayed to and will typically be the Player.<a class="indexterm" id="id290"/>
</p><p>Like our<strong> Draw Image</strong> event, there is a variable called<strong> Authored Global Scale</strong> which specifies the scale factor of the display the content is being used in. A value of<strong> 2.0</strong> is useful for high resolution screens like the iPhone 4S and new iPad, while<strong> 1.0</strong> is useful for standard resolution screens such as the iPad and older iPhones/iPod Touches. It is also worth noting that the<strong> Out</strong> output does not actually get called.<a class="indexterm" id="id291"/>
</p><div><h3 class="title"><a id="note12"/>Note</h3><p>This will not work with the gametype of<strong> UTDeathmatch</strong>. We will make use of this for our Main Menu, which we will be creating in <a class="link" href="ch07.html" title="Chapter 7. Advanced Content Creation for Urban Warrior">Chapter 7</a>, <em>Advanced Content Creati on for Urban Warrior</em>.</p></div><div><img alt="Draw Text" height="88" src="img/image_1901_04_36.jpg"/></div><p>This action is found in<strong> New Event</strong> |<strong> HUD</strong> |<strong> Draw Text</strong>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec14"/>Give some input to the situation</h1></div></div></div><p>With that basic overview of the different mobile-specific sequence objects, let's put that knowledge to some good use.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec15"/>Time for action—adding input</h1></div></div></div><p>Right now in our game, we use the two joysticks that are provided in order to move around and glance around the world. If you tap the middle of the screen, the gun will fire, but there are other things that players can do that are already pre-written into the gametype. With a few of the new Kismet sequence objects we have learned about, we are going to create buttons that will allow the player to shoot, use their alternative fire, and jump.<a class="indexterm" id="id292"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Open up the Kismet editor by pressing the<strong> K</strong> button.</li><li class="listitem">Create an<strong> Add Input Zone</strong> action by right-clicking and selecting<strong> New Action</strong> |<strong> Mobile</strong> |<strong> Add Input Zone</strong>.</li><li class="listitem">Expand the<strong> Seq Act Mobile Add Input Zones</strong> tab and set the value of<strong> Zone Name</strong> to<strong> AltFire</strong>.</li><li class="listitem">Click on the blue triangle icon on the far end of<strong> New Zone</strong>, and then click on<strong> MobileInputZone</strong> to create a new zone we can use.</li><li class="listitem">Expand the<strong> Zone</strong> tab and set the value of<strong> Caption</strong> to<strong> AltFire</strong>.<a class="indexterm" id="id293"/></li><li class="listitem">Expand the<strong> Input</strong> tab and set the value of<strong> Input Key</strong> to<code class="literal"> GBA_AltFire</code>.</li><li class="listitem">Expand the<strong> Bounds</strong> tab and set the value of<strong> X</strong> to<strong> -100.0</strong> and<strong> Y</strong> to<strong> -300</strong>.<p>The <strong>X</strong> and <strong>Y</strong> values of the bounds, if positive, will be moved from the top-left of the screen. Placing a negative number in either of the axes will cause the <strong>HUD</strong> to move the display to the bottom right-hand side edge of the viewport, which is what we want to achieve. We want to place our <strong>HUD</strong> buttons on the bottom right-hand side near the joystick used for glancing, so we use a negative number for each axis. Note that these values given were meant for the iPhone; they will need to be adjusted for use on other iOS devices.
<a class="indexterm" id="id294"/>
</p></li><li class="listitem">Expand the<strong> Rendering</strong> tab and click on<strong> Render Color</strong>. Change it to some value that will be easily seen in your level. I picked blue for this level.</li><li class="listitem">Copy the<strong> Add Input Zone</strong> action and paste two copies of them inside our Kismet workspace. In the first copy, change the<strong> Zone Name</strong> and<strong> Caption</strong> variables to<strong> Jump</strong> and set the<strong> Input Key</strong> to<strong> GBA_Jump</strong> with a position of (<strong>-200</strong>,<strong> -350</strong>) in the<strong> Bounds</strong>. For the second one, change the<strong> Zone Name</strong> and<strong> Caption</strong> variables to<strong> Fire</strong> and set the<strong> Input Key</strong> to<strong> GBA_Fire</strong> with a position of (<strong>-300</strong>,<strong> -300</strong>) in the<strong> Bounds</strong>.</li><li class="listitem">From the<strong> Out</strong> output of the<strong> Console Command</strong> Mode, connect our<strong> Add Input Zone</strong> sequence objects one after the other.<div><img alt="Time for action—adding input" height="93" src="img/image_1901_04_37.jpg"/></div></li><li class="listitem">Save your project (<strong>File</strong> |<strong> Save</strong>) and start your game by clicking on the<strong> Start Mobile Previewer</strong> button on the main toolbar.<div><img alt="Time for action—adding input" src="img/image_1901_04_38.jpg" width="298"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>What just happened?</h2></div></div></div><p>We've now created our own custom input buttons allowing us to jump, fire, and shoot our alternative fire while? retaining the original movement options. This will be quite useful when we get new weapons such as the rocket launcher, or if we want to provide platforming of a sort to our game.<a class="indexterm" id="id295"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Have a go hero—mobile sequence objects / adding input</h2></div></div></div><p>Using the sequence objects described previously, it would be very simple to create many different kinds of games, including a hidden object game, where you are given two images that are almost exactly the same, aside from a few differences. Upon touching one of the differences, it would be hidden and you'd be closer to finding all of them. Prototype this functionality by using the<strong> Mobile Object Picker</strong> event, and the<strong> Toggle Hidden</strong> action to hide the door object we created when you click on it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Pop quiz</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Which of the following is not a Kismet object type?<p>a. Events</p><p>b. Actions</p><p>c. Console Command</p><p>d. Conditions</p></li><li class="listitem">What effect does changing the Max Trigger Count to 0 do?<p>a. The event will be triggered an infinite amount of times.</p><p>b. It is not used anymore but exists for backwards compatibility, so there is no effect.</p><p>c. Tells UDK how many Trigger/Trigger Volume may exist in our level.</p><p>d. The event will not be triggered until its value is larger.</p></li><li class="listitem">What Kismet Event would I use to get information from the iOS device's gyroscope?<p>a. Touch Input</p><p>b. Analog Input</p><p>c. Mobile Input Access</p><p>d. Mobile Simple Swipes</p></li><li class="listitem">How would I remove the two joysticks that are included in our gametype?<p>a. Clear Input Zones</p><p>b. Remove Input Zone for each joystick</p><p>c. Modify the RequiredMobileInputConfigs of DefaultGameUDK.ini</p><p>d. All of the above</p></li><li class="listitem">What type of actor do we use in order to change the player's vision?<p>a. Player Spawned</p><p>b. Matinee</p><p>c. VisionActor</p><p>d. CameraActor</p></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec16"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about Unreal's advanced systems of Kismet in Matinee. We've implemented them both individually and together to see how they can be used to create a more interesting and dynamic experience within our game world. Using this fundamental knowledge, you can basically create any type of game you want; the possibilities are limitless!</p><p>In this short period of time, we've managed to cover quite a lot of things. We've specifically learned the following</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What Kismet is and how it can be used to create level-based events and prototyping</li><li class="listitem" style="list-style-type: disc">How to call console commands at runtime allowing us to change to a third-person perspective</li><li class="listitem" style="list-style-type: disc">What Kismet should be used for and reasons why we would or would not decide to use it</li><li class="listitem" style="list-style-type: disc">How Matinee is the cinematic tool of the Unreal Engine and allows designers to give exact direction in how things work in the engine</li><li class="listitem" style="list-style-type: disc">How to create an introductory cutscene bringing players into our world</li><li class="listitem" style="list-style-type: disc">What the implementation of an automatic door using aspects of both Kismet and Matinee would look like</li><li class="listitem" style="list-style-type: disc">How Kismet is different on the Mobile platform and the extra functionality we get from that</li><li class="listitem" style="list-style-type: disc">How to add functionality missing from the gametype using Sequence Objects we discussed previously</li></ul></div><p>Now that we've learned about the basics of Kismet and Matinee, we're ready to explore how we can take our knowledge of Kismet to the next level and begin taking more steps towards building our Urban Warrior project.</p><p>In the next chapter, we will be creating some dynamic action sequences by creating more complex systems, such as regenerating health (the console FPS favorite) and spawning enemies whose behavior and placement seem as realistic as possible.</p></div></body></html>