<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Data</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Storing simple data</li><li class="listitem" style="list-style-type: disc">Read and write a text file to internal storage</li><li class="listitem" style="list-style-type: disc">Read and write a text file to external storage</li><li class="listitem" style="list-style-type: disc">Including resource files in your project</li><li class="listitem" style="list-style-type: disc">Creating and using an SQLite database</li><li class="listitem" style="list-style-type: disc">Access data in the background using a Loader</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Introduction</h1></div></div></div><p>Since almost any application, big or small, requires saving some kind of data, Android offers many options. From saving a simple value to creating full databases using SQLite, storage options include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Shared preferences: simple name/value pairs</li><li class="listitem" style="list-style-type: disc">Internal storage: data files in private storage</li><li class="listitem" style="list-style-type: disc">External storage: data files in private or public storage</li><li class="listitem" style="list-style-type: disc">SQLite database: private data can expose the data through a Content Provider</li><li class="listitem" style="list-style-type: disc">Cloud storage: Private server or Service Provider</li></ul></div><p>There are benefits and tradeoffs to using internal and external storage. We will list some of the differences here to help you decide whether to use internal or external storage:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Internal storage</strong>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unlike<a id="id334" class="indexterm"/> external storage, internal storage is always available, but generally has less free space</li><li class="listitem" style="list-style-type: disc">Files are not accessible to the user (unless the device has root access)</li><li class="listitem" style="list-style-type: disc">Files are automatically deleted when your app is uninstalled (or with the Clear <a id="id335" class="indexterm"/>Cache/Cleanup File option in the App Manager)</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>External storage</strong>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id336" class="indexterm"/>device may not have external storage or it may be inaccessible (such as when it's connected to a computer)</li><li class="listitem" style="list-style-type: disc">Files are accessible to the user (and other apps) without requiring root access</li><li class="listitem" style="list-style-type: disc">Files are not deleted when your app is uninstalled (unless you use <code class="literal">getExternalFilesDir()</code> to get app-specific public storage)</li></ul></div></li></ul></div><p>In this chapter, we will demonstrate working with shared preferences, internal and external storage, and SQLite databases. For cloud storage, take a look at the Internet recipes in <a class="link" href="ch12.html" title="Chapter 12. Telephony, Networks, and the Web">Chapter 12</a>,<em> Telephony, Networks, and the Web</em> and Online Service Providers in <a class="link" href="ch15.html" title="Chapter 15. The Backend as a Service Options">Chapter 15</a>, <em>Backend as a Service Options</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Storing simple data</h1></div></div></div><p>It's a common<a id="id337" class="indexterm"/> requirement to store simple data, and Android makes it simple using the Preferences API. It's not limited to just user preferences either; you can store any of the primitive data types using a name/value pair.</p><p>We'll demonstrate saving a name from an <code class="literal">EditText</code> and displaying it when the application starts. The following screenshot shows how the application looks the first time with no saved name, and then on startup, after a name is saved:</p><div><img src="img/B05057_06_01.jpg" alt="Storing simple data"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec162"/>Getting ready</h2></div></div></div><p>Create a <a id="id338" class="indexterm"/>new project in Android Studio and call it: <code class="literal">Preferences</code>. Use the default <strong>Phone &amp; Tablet </strong>options and select <strong>Empty Activity</strong> when prompted for the <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec163"/>How to do it...</h2></div></div></div><p>We'll use the existing <strong>TextView</strong> to display a <strong>Welcome back</strong> message and create a new <code class="literal">EditText</code> button to save the name. Start by opening <code class="literal">activity_main.xml</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Replace the <a id="id339" class="indexterm"/>existing <strong>TextView</strong> and add the following new views:<div><pre class="programlisting">&lt;TextView
    android:id="@+id/textView"
    android:text="Hello World!"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" /&gt;

&lt;EditText
    android:id="@+id/editTextName"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    android:hint="Enter your name" /&gt;

&lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Save"
    android:layout_centerHorizontal="true"
    android:layout_below="@id/editTextName"
    android:onClick="saveName"/&gt;</pre></div></li><li class="listitem">Open <code class="literal">ActivityMain.java</code> and add the following global declarations:<div><pre class="programlisting">private final String NAME="NAME";
private EditText mEditTextName;</pre></div></li><li class="listitem">Add the following code to <code class="literal">onCreate()</code> to save a reference to the <code class="literal">EditText</code> and to load any saved name:<div><pre class="programlisting">TextView textView = (TextView)findViewById(R.id.textView);
SharedPreferences sharedPreferences = getPreferences(MODE_PRIVATE);
String name = sharedPreferences.getString(NAME,null);
if (name==null) {
    textView.setText("Hello");
} else {
    textView.setText("Welcome back " + name + "!");
}
mEditTextName = (EditText)findViewById(R.id.editTextName);</pre></div></li><li class="listitem">Add the following <code class="literal">saveName()</code> method:<div><pre class="programlisting">public void saveName(View view) {
    SharedPreferences.Editor editor = getPreferences(MODE_PRIVATE).edit();
    editor.putString(NAME, mEditTextName.getText().toString());
    editor.commit();
}</pre></div></li><li class="listitem">Run the program on a device or emulator. Since we are demonstrating persisting data, it loads the name during the <code class="literal">onCreate()</code>, so save a name and restart the program to see it load.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec164"/>How it works...</h2></div></div></div><p>To load the <a id="id340" class="indexterm"/>name, we first get a reference to <code class="literal">SharedPreference</code> so we can call the <code class="literal">getString()</code> method. We pass in the key for our name/value pair and the default value to return if the key is not found.</p><p>To save the preference, we first need to get a reference to the Preference Editor. We use <code class="literal">putString()</code> and follow it with <code class="literal">commit().</code> Without <code class="literal">commit()</code>, the change will not be saved.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec165"/>There's more...</h2></div></div></div><p>Our example stores all the preferences in a single file. We can also store preferences in different files using <code class="literal">getSharedPreferences()</code> and passing in the name. This option can be used if you want to have separate profiles for multiple users.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Read and write a text file to internal storage</h1></div></div></div><p>When simple name/value<a id="id341" class="indexterm"/> pairs are not sufficient, Android also<a id="id342" class="indexterm"/> supports regular file operations including working with text and binary data.</p><p>The following recipe <a id="id343" class="indexterm"/>demonstrates how to read and write a file to <a id="id344" class="indexterm"/>internal or private storage.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec166"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">InternalStorageFile</code>. Use the default <strong>Phone &amp; Tablet </strong>options and select <strong>Empty Activity</strong> when prompted for the <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec167"/>How to do it...</h2></div></div></div><p>To demonstrate both reading and writing text, we'll need a layout with an <code class="literal">EditText</code> and two buttons. Start by opening <code class="literal">main_activity.xml</code> and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Replace the <a id="id345" class="indexterm"/>existing <code class="literal">&lt;TextView&gt;</code> <a id="id346" class="indexterm"/>element with the following views:<div><pre class="programlisting">&lt;EditText
    android:id="@+id/editText"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:inputType="textMultiLine"
    android:ems="10"
    android:layout_above="@+id/buttonRead"
    android:layout_alignParentTop="true"
    android:layout_centerHorizontal="true" /&gt;
&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Read"
    android:id="@+id/buttonRead"
    android:layout_centerVertical="true"
    android:layout_centerHorizontal="true"
    android:onClick="readFile"/&gt;
&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Write"
    android:id="@+id/buttonWrite"
    android:layout_below="@+id/buttonRead"
    android:layout_centerHorizontal="true"
    android:onClick="writeFile"/&gt;</pre></div></li><li class="listitem">Now <a id="id347" class="indexterm"/>open <code class="literal">ActivityMain.java</code> and add the<a id="id348" class="indexterm"/> following global variables:<div><pre class="programlisting">private final String FILENAME="testfile.txt";
EditText mEditText;</pre></div></li><li class="listitem">Add the following to the <code class="literal">onCreate()</code> method, after <code class="literal">setContentView ()</code>:<div><pre class="programlisting">mEditText = (EditText)findViewById(R.id.editText);</pre></div></li><li class="listitem">Add the following <code class="literal">writeFile()</code> method:<div><pre class="programlisting">public void writeFile(View view) {
    try {
        FileOutputStream fileOutputStream = openFileOutput(FILENAME, Context.MODE_PRIVATE);
        fileOutputStream.write(mEditText.getText().toString().getBytes());
        fileOutputStream.close();
    } catch (java.io.IOException e) {
        e.printStackTrace();
    }
}</pre></div></li><li class="listitem">Now add the <code class="literal">readFile()</code> method:<div><pre class="programlisting">public void readFile(View view) {
    StringBuilder stringBuilder = new StringBuilder();
    try {
        InputStream inputStream = openFileInput(FILENAME);
        if ( inputStream != null ) {
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
            String newLine = null;
            while ((newLine = bufferedReader.readLine()) != null ) {
                stringBuilder.append(newLine+"\n");
            }
            inputStream.close();
        }
    } catch (java.io.IOException e) {
        e.printStackTrace();
    }
    mEditText.setText(stringBuilder);
}</pre></div></li><li class="listitem">Run the<a id="id349" class="indexterm"/> program <a id="id350" class="indexterm"/>on a <a id="id351" class="indexterm"/>device <a id="id352" class="indexterm"/>or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec168"/>How it works...</h2></div></div></div><p>We use the <code class="literal">InputStream</code> and <code class="literal">FileOutputStream</code> classes to read and write, respectively. Writing to the file is as simple as getting the text from the <code class="literal">EditText</code> and calling the <code class="literal">write()</code> method.</p><p>Reading back the contents is a little more involved. We could use the <code class="literal">FileInputStream</code> class for reading, but when working with text, the helper classes make it easier. In our example, we open the file with <code class="literal">openFileInput()</code>, which returns an <code class="literal">InputStream</code> object. We then use the <code class="literal">InputStream</code> to get a <code class="literal">BufferedReader</code>, which offers the <code class="literal">ReadLine()</code> method. We loop through each line in the file and append it to our <code class="literal">StringBuilder</code>. When we're finished reading the file, we assign the text to the <code class="literal">EditText</code>.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>Our previous file was created in the app's private data folder. To view the contents of the file, you can use the Android Device Monitor to pull the file to your computer. The full file path is: <code class="literal">/data/data/com.packtpub.androidcookbook.</code> <code class="literal">internalstoragetile/files/testfile.txt</code>.</p></div></div><p>The following<a id="id353" class="indexterm"/> screenshot shows how the file appears when <a id="id354" class="indexterm"/>viewed<a id="id355" class="indexterm"/> through <a id="id356" class="indexterm"/>the <strong>Android Device Monitor</strong>:</p><div><img src="img/B05057_06_02.jpg" alt="How it works..."/></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>You will need a device with root access to view the private folder shown previously.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec169"/>There's more...</h2></div></div></div><p>Let's see some additional information that can be helpful.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec11"/>Cache Files</h3></div></div></div><p>If all you need is to temporarily <a id="id357" class="indexterm"/>store data, you can also use the cache folder. The following method returns the cache folder as a <code class="literal">File</code> object (the next recipe demonstrates working with the <code class="literal">File</code> object):</p><div><pre class="programlisting">getCacheDir()</pre></div><p>The main benefit of the cache folder is that the system can clear the cache if running low on storage space. (The user can also clear the cache folder from Apps Management in Settings.)</p><p>For example, if your app downloads news articles, you could store those in the cache. When your app starts, you can display the news already downloaded. These are files that are not required to make your app work. If the system is low on resources, the cache can be cleared without adversely affecting your app. (Even though the system may clear the cache, it's still a good idea for your app to remove old files as well.)</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec170"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next recipe, <em>Read and write a text file to external storage</em>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Read and write a text file to external storage</h1></div></div></div><p>The process of <a id="id358" class="indexterm"/>reading and writing files to external storage is <a id="id359" class="indexterm"/>basically the same as using internal storage. The<a id="id360" class="indexterm"/> difference is in obtaining a reference to the<a id="id361" class="indexterm"/> storage location. Also, as mentioned in the <em>Introduction</em>, external storage may not be available, so it's best to check availability before attempting to access it.</p><p>This recipe will read and write a text file, as we did in the previous recipe. We'll also demonstrate how to check the external storage state before we access it.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec171"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">ExternalStorageFile</code>. Use the default <strong>Phone &amp; Tablet </strong>options and select <strong>Empty Activity</strong> when prompted for the <strong>Activity Type</strong>. We will use the same layout as the previous recipe, so you can just copy and paste if you typed it in already. Otherwise, use the layout from Step 1 in the previous recipe, <em>Read and write a text file to internal storage</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec172"/>How to do it...</h2></div></div></div><p>As mentioned previously in the <em>Getting ready</em> section, we'll use the layout from the previous recipe. With the layout file done, the first step will be to add permission to access the write to <a id="id362" class="indexterm"/>external storage. Here are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <a id="id363" class="indexterm"/>Android Manifest and add the <a id="id364" class="indexterm"/>following <a id="id365" class="indexterm"/>permission:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</pre></div></li><li class="listitem">Next, open <code class="literal">ActivityMain.java</code> and add the following global variables:<div><pre class="programlisting">private final String FILENAME="testfile.txt";
EditText mEditText;</pre></div></li><li class="listitem">Add the following to the <code class="literal">onCreate()</code> method, after <code class="literal">setContentView ()</code>:<div><pre class="programlisting">mEditText = (EditText)findViewById(R.id.editText);</pre></div></li><li class="listitem">Add the following two methods to check the storage state:<div><pre class="programlisting">public boolean isExternalStorageWritable() {
    if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
        return true;
    }
    return false;
}

public boolean isExternalStorageReadable() {
    if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||
            Environment.MEDIA_MOUNTED_READ_ONLY.equals(Environment.getExternalStorageState())) {
        return true;
    }
    return false;
}</pre></div></li><li class="listitem">Add the following <code class="literal">writeFile()</code> method:<div><pre class="programlisting">public void writeFile(View view) {
    if (isExternalStorageWritable()) {
        try {
            File textFile = new File(Environment.getExternalStorageDirectory(), FILENAME);
            FileOutputStream fileOutputStream = new FileOutputStream(textFile);
            fileOutputStream.write(mEditText.getText().toString().getBytes());
            fileOutputStream.close();
        } catch (java.io.IOException e) {
            e.printStackTrace();
            Toast.makeText(this, "Error writing file", Toast.LENGTH_LONG).show();
        }
    } else {
        Toast.makeText(this, "Cannot write to External Storage", Toast.LENGTH_LONG).show();
    }
}</pre></div></li><li class="listitem">Add<a id="id366" class="indexterm"/> the <a id="id367" class="indexterm"/>following<a id="id368" class="indexterm"/> <code class="literal">readFile()</code><a id="id369" class="indexterm"/>method:<div><pre class="programlisting">public void readFile(View view) {
    if (isExternalStorageReadable()) {
        StringBuilder stringBuilder = new StringBuilder();
        try {
            File textFile = new File(Environment.getExternalStorageDirectory(), FILENAME);
            FileInputStream fileInputStream = new FileInputStream(textFile);
            if (fileInputStream != null ) {
                InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);
                BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
                String newLine = null;
                while ( (newLine = bufferedReader.readLine()) != null ) {
                    stringBuilder.append(newLine+"\n");
                }
                fileInputStream.close();
            }
            mEditText.setText(stringBuilder);
        } catch (java.io.IOException e) {
            e.printStackTrace();
            Toast.makeText(this, "Error reading file", Toast.LENGTH_LONG).show();
        }
    } else {
        Toast.makeText(this, "Cannot read External Storage", Toast.LENGTH_LONG).show();
    }
}</pre></div></li><li class="listitem">Run the program on a device or emulator with external storage.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec173"/>How it works...</h2></div></div></div><p>Reading and <a id="id370" class="indexterm"/>writing files are basically the same for both<a id="id371" class="indexterm"/> internal and external storage. The main<a id="id372" class="indexterm"/> difference is that we should check for the<a id="id373" class="indexterm"/> availability of the external storage before attempting to access it, which we do with the <code class="literal">isExternalStorageWritable()</code> and <code class="literal">isExternalStorageReadable()</code> methods. When checking the storage state, <code class="literal">MEDIA_MOUNTED</code> means we can read and write to it.</p><p>Unlike the internal storage example, we request the working path as we do in this line of code:</p><div><pre class="programlisting">File textFile = new File(Environment.getExternalStorageDirectory(), FILENAME);</pre></div><p>The actual reading and writing is done with the same classes, as it is just the location that is different.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>It is not safe to hard code an external folder path. The path can vary between versions of the OS and especially between hardware manufacturers. It is always best to call <code class="literal">getExternalStorageDirectory()</code>, as shown.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec174"/>There's more...</h2></div></div></div><p>Some additional information are discussed as follows.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec12"/>Getting public folders</h3></div></div></div><p>The <code class="literal">getExternalStorageDirectory()</code> method returns the root folder of the external storage. If you want<a id="id374" class="indexterm"/> to obtain specific public folders, such as the <code class="literal">Music</code> or <code class="literal">Ringtone</code> folder, use <code class="literal">getExternalStoragePublicDirectory()</code> and pass in the desired folder type, for example:</p><div><pre class="programlisting">getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec13"/>Checking available space</h3></div></div></div><p>One issue consistent between<a id="id375" class="indexterm"/> internal and external storage is limited space. If you know how much space you will need ahead of time, you can call the <code class="literal">getFreeSpace()</code> method on the <code class="literal">File</code> object. (<code class="literal">getTotalSpace()</code> will return the total space.) Here is a simple example to using the call to <code class="literal">getFreeSpace()</code>:</p><div><pre class="programlisting">if (Environment.getExternalStorageDirectory().getFreeSpace() &lt; RQUIRED_FILE_SPACE) {
    //Not enough space
} else {
    //We have enough space
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec14"/>Deleting a file</h3></div></div></div><p>There are many <a id="id376" class="indexterm"/>helper methods available through the <code class="literal">File</code> object, including deleting a file. If we wanted to delete the text file we created in the example, we could call <code class="literal">delete()</code> as follows:</p><div><pre class="programlisting">textFile.delete()</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec15"/>Working with directories</h3></div></div></div><p>Though<a id="id377" class="indexterm"/> it's called a <code class="literal">File</code> object, it supports directory commands as well, such as making and removing directories. If you want to make or remove a directory, build the <code class="literal">File</code> object, then call the respective methods: <code class="literal">mkdir()</code> and <code class="literal">delete()</code>. (There's also a method called <code class="literal">mkdirs()</code> (plural) that will create parent folders as well.) See the following link for a complete list.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec16"/>Preventing files from being included in galleries</h3></div></div></div><p>Android employs a <strong>media scanner</strong>
<a id="id378" class="indexterm"/> that automatically includes sound, video, and image files in the system collections, such as the Image Gallery. To exclude your <a id="id379" class="indexterm"/>directory, create an empty file called <code class="literal">.nomedia</code> (note the preceding period) in the same directory as the files you wish to exclude.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec175"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a complete list of methods available in the <a id="id380" class="indexterm"/><code class="literal">File</code> class, visit <a class="ulink" href="http://developer.android.com/reference/java/io/File.html">http://developer.android.com/reference/java/io/File.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Including resource files in your project</h1></div></div></div><p>Android provides two<a id="id381" class="indexterm"/> options for including files in your project: the <code class="literal">raw</code> folder and the <code class="literal">Assets</code> folder. Which option you use depends on your requirements. To start, we'll give a brief overview of each option to help you decide when to use each option:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Raw files</strong><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Included in the <a id="id382" class="indexterm"/>resource directory: <code class="literal">/res/raw</code></li><li class="listitem" style="list-style-type: disc">As a resource, accessed through the raw identifier: <code class="literal">R.raw.&lt;resource&gt;</code></li><li class="listitem" style="list-style-type: disc">A good place for storing media files such as MP3, MP4, and OOG files</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Asset files</strong><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creates a filesystem <a id="id383" class="indexterm"/>compiled in your APK (does <em>NOT</em> provide a resource ID)</li><li class="listitem" style="list-style-type: disc">Access files using their file names, generally making them easier to use with dynamically created names</li><li class="listitem" style="list-style-type: disc">Some APIs do not support a Resource Identifier and therefore require including as an Asset</li></ul></div></li></ul></div><p>Generally, <code class="literal">raw</code> files are easier to work with since they are accessed through the resource identifier. As we'll demonstrate in this recipe, the main difference is how you access the file. In this example, we will load both a <code class="literal">raw</code> text file and an <code class="literal">asset</code> text file and display the contents.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec176"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">ReadingResourceFiles</code>. Use the default <strong>Phone &amp; Tablet </strong>options and select <strong>Empty Activity</strong> when prompted for the <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec177"/>How to do it...</h2></div></div></div><p>To demonstrate<a id="id384" class="indexterm"/> reading content from both resource locations, we'll create a split layout. We also need to create both resource folders as they are not included in the default Android project. Here are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">activity_main.xml</code> and replace the contents with the following layout:<div><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout 
    
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;
    &lt;TextView
        android:id="@+id/textViewRaw"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:gravity="center_horizontal|center_vertical"/&gt;
    &lt;TextView
        android:id="@+id/textViewAsset"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:gravity="center_horizontal|center_vertical"/&gt;
&lt;/LinearLayout&gt;</pre></div></li><li class="listitem">Create the <code class="literal">raw</code><a id="id385" class="indexterm"/> resource folder in the res folder. It will read as: <code class="literal">res/raw</code>.</li><li class="listitem">Create a new text file by right-clicking on the <code class="literal">raw</code> folder and select <strong>New</strong> | <strong>File</strong>. Name the file <code class="literal">raw_text.txt</code> and type some text in the file. (This text will display when you run the application.)</li><li class="listitem">Create the <code class="literal">asset</code> folder. The <code class="literal">asset</code> folder is trickier because of the location. Fortunately, Android Studio provides a menu option that makes creating it very easy. Go to the <strong>File</strong> menu (or right-click on the <strong>app</strong> node) and select <strong>New</strong> | <strong>Folder</strong> | <strong>Assets Folder</strong> as shown in this screenshot:<div><img src="img/B05057_06_03.jpg" alt="How to do it..."/></div></li><li class="listitem">Create<a id="id386" class="indexterm"/> another text file in the asset folder called <code class="literal">asset_text.txt</code>. Again, whatever text you type here will be shown when you run the app. Here's how the final result should look after both text files are created:<div><img src="img/B05057_06_04.jpg" alt="How to do it..."/></div></li><li class="listitem">Now it's <a id="id387" class="indexterm"/>time for the code. Open <code class="literal">MainActivity.java</code> and add the following method to read the text file (which is passed into the method):<div><pre class="programlisting">private String getText(InputStream inputStream) {
    StringBuilder stringBuilder = new StringBuilder();
    try {;
        if ( inputStream != null ) {
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
            String newLine = null;
            while ((newLine = bufferedReader.readLine()) != null ) {
                stringBuilder.append(newLine+"\n");
            }
            inputStream.close();
        }
    } catch (java.io.IOException e) {
        e.printStackTrace();
    }
    return stringBuilder.toString();
}</pre></div></li><li class="listitem">Finally, add the following code to the <code class="literal">onCreate()</code> method:<div><pre class="programlisting">TextView textViewRaw = (TextView)findViewById(R.id.textViewRaw);
textViewRaw.setText(getText(this.getResources().openRawResource(R.raw.raw_text)));

TextView textViewAsset = (TextView)findViewById(R.id.textViewAsset);
try {
    textViewAsset.setText(getText(this.getAssets().open("asset_text.txt")));
} catch (IOException e) {
    e.printStackTrace();
}</pre></div></li><li class="listitem">Run the program on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec178"/>How it works...</h2></div></div></div><p>To summarize, the<a id="id388" class="indexterm"/> only difference is in how we get a reference to each file. This line of code reads the <code class="literal">raw</code> resource:</p><div><pre class="programlisting">this.getResources().openRawResource(R.raw.raw_text)</pre></div><p>And this code reads the <code class="literal">asset</code> file:</p><div><pre class="programlisting">this.getAssets().open("asset_text.txt")</pre></div><p>Both calls return an <code class="literal">InputStream</code>, which the <code class="literal">getText()</code> method uses to read the file contents. It is worth noting, though, that the call to open the <code class="literal">asset</code> text file requires an additional <code class="literal">try</code>/<code class="literal">catch</code>. As noted in the recipe introduction, resources are indexed so we have compile time verification, which the <code class="literal">asset</code> folder does not have.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec179"/>There's more...</h2></div></div></div><p>A common approach is to include resources in your APK, but download new resources as they become available. (See the network communication in <a class="link" href="ch12.html" title="Chapter 12. Telephony, Networks, and the Web">Chapter 12</a>, <em>Telephony, Networks, and the Web</em>.) If new resources aren't available, you can always fall back on the resources in your APK.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec180"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Network communication recipes in <a class="link" href="ch12.html" title="Chapter 12. Telephony, Networks, and the Web">Chapter 12</a>, <em>Telephony, Networks, and the Web.</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Creating and using an SQLite database</h1></div></div></div><p>In this recipe, we're <a id="id389" class="indexterm"/>going to <a id="id390" class="indexterm"/>demonstrate working with an SQLite database. If you are already familiar with SQL databases from other platforms, then much of what you know will apply. If you are new to SQLite, take a look at the reference links in the "See also" section as this recipe assumes a basic understanding of database concepts including schemas, tables, cursors, and raw SQL.</p><p>To get you up and running with an SQLite database quickly, our example implements the basic CRUD operations. Generally, when creating a database in Android, you create a class that extends <code class="literal">SQLiteOpenHelper</code>, which is where your database functionality is implemented. Here is a list of the functions to provide each of the basic operations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create: <code class="literal">insert()</code></li><li class="listitem" style="list-style-type: disc">Read: <code class="literal">query()</code> and <code class="literal">rawQuery()</code></li><li class="listitem" style="list-style-type: disc">Update: <code class="literal">update()</code></li><li class="listitem" style="list-style-type: disc">Delete: <code class="literal">delete()</code></li></ul></div><p>To demonstrate a fully working database, we will create a simple <code class="literal">Dictionary</code> database, so we can store words and their definitions. We'll demonstrate the CRUD operations by allowing adding new words (with their definitions) and updating existing word definitions. We'll show words in a <code class="literal">ListView</code> using a cursor. Pressing a word in the <code class="literal">ListView</code> will read the definition from the database and display it in a Toast message. A long press will delete the word.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec181"/>Getting ready</h2></div></div></div><p>Create a new project in<a id="id391" class="indexterm"/> Android Studio and call it: <code class="literal">SQLiteDatabase</code>. Use the <a id="id392" class="indexterm"/>default <strong>Phone &amp; Tablet </strong>options and select <strong>Empty Activity</strong> when prompted for the <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec182"/>How to do it...</h2></div></div></div><p>First, we'll create the UI, which will consist of two <code class="literal">EditText</code> fields, a button, and a <code class="literal">ListView</code>. As we add words to the database, they will populate the <code class="literal">ListView</code>. To start, open <code class="literal">activity_main.xml</code> and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Replace the existing <code class="literal">&lt;TextView&gt;</code> with these new views:<div><pre class="programlisting">&lt;EditText
    android:id="@+id/et_word"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_alignParentTop="true"
    android:layout_alignParentLeft="true"
    android:layout_alignParentStart="true"
    android:hint="Word"/&gt;
&lt;EditText
    android:id="@+id/et_definition"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_below="@+id/editTextWord"
    android:layout_alignParentLeft="true"
    android:layout_alignParentStart="true"
    android:hint="Definition"/&gt;
&lt;Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Save"
    android:id="@+id/button_add_update"
    android:layout_alignParentRight="true"
    android:layout_alignParentTop="true" /&gt;
&lt;ListView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:id="@+id/listView"
    android:layout_below="@+id/et_definition"
    android:layout_alignParentLeft="true"
    android:layout_alignParentBottom="true" /&gt;</pre></div></li><li class="listitem">Add a new <a id="id393" class="indexterm"/>Java class to the project named <code class="literal">DictionaryDatabase</code>. This<a id="id394" class="indexterm"/> class extends from <code class="literal">SQLiteOpenHelper</code> and handles all the SQLite functions. Here is the class declaration:<div><pre class="programlisting">public class DictionaryDatabase extends SQLiteOpenHelper {</pre></div></li><li class="listitem">Below the declaration, add the following constants:<div><pre class="programlisting">private static final String DATABASE_NAME = "dictionary.db";
private static final String TABLE_DICTIONARY = "dictionary";

private static final String FIELD_WORD = "word";
private static final String FIELD_DEFINITION = "definition";
private static final int DATABASE_VERSION = 1;</pre></div></li><li class="listitem">Add the following constructor, <code class="literal">OnCreate()</code> and <code class="literal">onUpgrade()</code> methods:<div><pre class="programlisting">DictionaryDatabase(Context context) {
    super(context, DATABASE_NAME, null, DATABASE_VERSION);
}

@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL("CREATE TABLE " + TABLE_DICTIONARY +
            "(_id integer PRIMARY KEY," +
            FIELD_WORD + " TEXT, " +
            FIELD_DEFINITION + " TEXT);");
}

@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    //Handle database upgrade as needed
}</pre></div></li><li class="listitem">The following <a id="id395" class="indexterm"/>methods are responsible for creating, updating, and <a id="id396" class="indexterm"/>deleting the records:<div><pre class="programlisting">public void saveRecord(String word, String definition) {
    long id = findWordID(word);
    if (id&gt;0) {
        updateRecord(id, word,definition);
    } else {
        addRecord(word,definition);
    }
}

public long addRecord(String word, String definition) {
    SQLiteDatabase db = getWritableDatabase();

    ContentValues values = new ContentValues();
    values.put(FIELD_WORD, word);
    values.put(FIELD_DEFINITION, definition);
    return db.insert(TABLE_DICTIONARY, null, values);
}

public int updateRecord(long id, String word, String definition) {
    SQLiteDatabase db = getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("_id", id);
    values.put(FIELD_WORD, word);
    values.put(FIELD_DEFINITION, definition);
    return db.update(TABLE_DICTIONARY, values, "_id = ?", new String[]{String.valueOf(id)});
}
public int deleteRecord(long id) {
    SQLiteDatabase db = getWritableDatabase();
    return db.delete(TABLE_DICTIONARY, "_id = ?", new String[]{String.valueOf(id)});
}</pre></div></li><li class="listitem">And these <a id="id397" class="indexterm"/>methods <a id="id398" class="indexterm"/>handle reading the information from the database:<div><pre class="programlisting">public long findWordID(String word) {
    long returnVal = -1;
    SQLiteDatabase db = getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT _id FROM " + TABLE_ DICTIONARY + " WHERE " + FIELD_WORD + " = ?", new String[]{word});
    Log.i("findWordID","getCount()="+cursor.getCount());
    if (cursor.getCount() == 1) {
        cursor.moveToFirst();
        returnVal = cursor.getInt(0);
    }
    return returnVal;
}

public String getDefinition(long id) {
    String returnVal = "";
    SQLiteDatabase db = getReadableDatabase();
    Cursor cursor = db.rawQuery("SELECT definition FROM " + TABLE_ DICTIONARY + " WHERE _id = ?", new String[]{String.valueOf(id)});
    if (cursor.getCount() == 1) {
        cursor.moveToFirst();
        returnVal = cursor.getString(0);
    }
    return returnVal;
}

public Cursor getWordList() {
    SQLiteDatabase db = getReadableDatabase();
    String query = "SELECT _id, " + FIELD_WORD + " FROM " + TABLE_DICTIONARY + " ORDER BY " + FIELD_WORD + " ASC";
    return db.rawQuery(query, null);
}</pre></div></li><li class="listitem">With the database class finished, open <code class="literal">MainActivity.java</code>. Add the following global variables below the class declaration:<div><pre class="programlisting">EditText mEditTextWord;
EditText mEditTextDefinition;
DictionaryDatabase mDB;
ListView mListView;</pre></div></li><li class="listitem">Add the following method to save the fields when the button is clicked:<div><pre class="programlisting">private void saveRecord() {
    mDB.saveRecord(mEditTextWord.getText().toString(), mEditTextDefinition.getText().toString());
    mEditTextWord.setText("");
    mEditTextDefinition.setText("");
    updateWordList();
}</pre></div></li><li class="listitem">Add this method to populate the <code class="literal">ListView</code>:<div><pre class="programlisting">private void updateWordList() {
    SimpleCursorAdapter simpleCursorAdapter = new SimpleCursorAdapter(
        this,
        android.R.layout.simple_list_item_1,
        mDB.getWordList(),
        new String[]{"word"},
        new int[]{android.R.id.text1},
        0);
    mListView.setAdapter(simpleCursorAdapter);
}</pre></div></li><li class="listitem">Finally, add<a id="id399" class="indexterm"/> the<a id="id400" class="indexterm"/> following code to <code class="literal">onCreate()</code>:<div><pre class="programlisting">mDB = new DictionaryDatabase(this);

mEditTextWord = (EditText)findViewById(R.id.editTextWord);
mEditTextDefinition = (EditText)findViewById(R.id.editTextDefinition);

Button buttonAddUpdate = (Button)findViewById(R.id.buttonAddUpdate);
buttonAddUpdate.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        saveRecord();
    }
});

mListView = (ListView)findViewById(R.id.listView);
mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
        Toast.makeText(MainActivity.this, mDB.getDefinition(id),Toast.LENGTH_SHORT).show();
    }
});
mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
    @Override
    public boolean onItemLongClick(AdapterView&lt;?&gt; parent, 
        View view, int position, long id) {
        Toast.makeText(MainActivity.this, "Records deleted = " + mDB.deleteRecord(id), Toast.LENGTH_SHORT).show();
        updateWordList();
        return true;
    }
});
updateWordList();</pre></div></li><li class="listitem">Run the program on a device or emulator and try it out.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec183"/>How it works...</h2></div></div></div><p>We'll start by <a id="id401" class="indexterm"/>explaining<a id="id402" class="indexterm"/> the <code class="literal">DictionaryDatabase</code> class as that's the heart of an SQLite database. The first item to note is the constructor:</p><div><pre class="programlisting">DictionaryDatabase(Context context) {
    super(context, DATABASE_NAME, null, DATABASE_VERSION);
}</pre></div><p>Notice <code class="literal">DATABASE_VERSION</code>? Only when you make changes to your database schema do you need to increment this value.</p><p>Next is <code class="literal">onCreate()</code>, where the database is actually created. This is only called the first time the database is created, not each time the class is created. It's also worth noting the <code class="literal">_id</code> field. Android does not require tables to have a primary field, except for some classes such as <code class="literal">SimpleCursorAdapter</code>, require <code class="literal">_id</code>.</p><p>We're required to implement the <code class="literal">onUpgrade()</code> callback, but as this is a new database, there's nothing to do. This method will be called when the database version is incremented.</p><p>The <code class="literal">saveRecord()</code> method handles calling <code class="literal">addRecord()</code> or <code class="literal">updateRecord()</code>, as appropriate. Since we are going to modify the database, both methods call <code class="literal">getWritableDatabase()</code> so we can make changes. A writeable database requires more resources so if you don't need to make changes, get a read-only database instead.</p><p>The last method to note is <code class="literal">getWordList()</code>, which returns all the words in the database using a cursor object. We use this cursor to populate the <code class="literal">ListView</code>, which brings us to <code class="literal">ActivityMain.java</code>. The <code class="literal">onCreate()</code> method does the standard initialization we've seen before and also creates an instance of the database with the following line of code:</p><div><pre class="programlisting">mDB = new DictionaryDatabase(this);</pre></div><p>The <code class="literal">onCreate()</code> method is also where we set up the events to show the word definition (with a Toast) when an item is pressed and to delete the word on a long press. Probably the most complicated code is in <code class="literal">updateWordList()</code>.</p><p>This isn't the first<a id="id403" class="indexterm"/> time we've used an adapter, but this is the first cursor adapter, so we'll<a id="id404" class="indexterm"/> explain. We use the <code class="literal">SimpleCursorAdapter</code> to create a mapping between our field in the cursor and the <code class="literal">ListView</code> item. We use the <code class="literal">layout.simple_list_item_1</code> layout, which only includes a single text field with ID <code class="literal">android.R.id.text1</code>. In a real application, we'd probably create a custom layout and include the definition in the <code class="literal">ListView</code> item, but we wanted to demonstrate a method to read the definition from the database.</p><p>We call <code class="literal">updateWordList()</code> in three places—during <code class="literal">onCreate()</code> to create the initial list, then again after we add/update a list, and lastly when deleting a list.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec184"/>There's more...</h2></div></div></div><p>Though this is a fully functioning example of SQLite, it is still just the basics. A whole book can, and has, been written on SQLite for Android.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec17"/>Upgrading a database</h3></div></div></div><p>As we<a id="id405" class="indexterm"/> mentioned previously, when we increment the database version, the <code class="literal">onUpgrade()</code> method will be called. What you do here is dependent on the change(s). If you changed an existing table, ideally you'll want to migrate the user data to the new format by querying the existing data and inserting it into the new format. Keep in mind, there is no guarantee the user will upgrade in consecutive order—so they could jump from version 1 to version 4, for example.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec185"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SQLite <a id="id406" class="indexterm"/>Home Page: <a class="ulink" href="https://www.sqlite.org/">https://www.sqlite.org/</a></li><li class="listitem" style="list-style-type: disc">SQLite Database<a id="id407" class="indexterm"/> Android Reference: <a class="ulink" href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html">http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Access data in the background using a Loader</h1></div></div></div><p>Any potentially <a id="id408" class="indexterm"/>long-running operations should not be done <a id="id409" class="indexterm"/>on the UI thread, as this can cause your application to be slow or become non-responsive. The Android OS will bring up the <strong>Application Not Responding</strong> (<strong>ANR</strong>) dialog when apps become non-responsive.</p><p>Since querying databases can be time-consuming, Android introduced the Loader API in Android 3.0. A Loader processes the query on a background thread and notifies the UI thread when it finishes.</p><p>The two primary benefits to Loaders include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Querying the database is (automatically) handled on a background thread</li><li class="listitem" style="list-style-type: disc">The Query auto-updates (when using a Content Provider data source)</li></ul></div><p>To demonstrate a Loader, we will modify the previous SQLite database example to use a <code class="literal">CursorLoader</code> to populate the <code class="literal">ListView</code>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec186"/>Getting ready</h2></div></div></div><p>We will use the project from the previous example, <em>Creating and using an SQLite database,</em> as the base for this recipe. Create a new project in Android Studio and call it: <code class="literal">Loader</code>. Use the default <strong>Phone &amp; Tablet </strong>options and select <strong>Empty Activity</strong> when prompted for the <strong>Activity Type</strong>. Copy the <code class="literal">DictionaryDatabase</code> class and the layout from the previous recipe. Though we will use parts of the previous <code class="literal">ActivityMain.java</code> code, we will start at the beginning in this recipe to make it easier to follow.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec187"/>How to do it...</h2></div></div></div><p>With the project set up as described previously, we will start by creating two new Java classes, and then tie it all together in <code class="literal">ActivityMain.java</code>. Here are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new Java class called <code class="literal">DictionaryAdapter</code> that extends <code class="literal">CursorAdapter</code>. This class replaces the <code class="literal">SimpleCursorAdapater</code> we used in the previous recipe. Here is the full code:<div><pre class="programlisting">public class DictionaryAdapter extends CursorAdapter {
    public DictionaryAdapter(Context context, Cursor c, int flags) {
        super(context, c, flags);
    }

    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
        return LayoutInflater.from(context).inflate(android.R.layout.simple_list_item_1,parent,false);
    }

    @Override
    public void bindView(View view, Context context, Cursor cursor) {
        TextView textView = (TextView)view.findViewById(android.R.id.text1);
        textView.setText(cursor.getString(getCursor().getColumnIndex("word")));
    }
}</pre></div></li><li class="listitem">Next, create <a id="id410" class="indexterm"/>another new Java class and call<a id="id411" class="indexterm"/> this one <code class="literal">DictionaryLoader</code>. Though this is the class that handles the data loading on the background thread, it's actually very simple:<div><pre class="programlisting">public class DictionaryLoader extends CursorLoader {
    Context mContext;
    public DictionaryLoader(Context context) {
        super(context);
        mContext = context;
    }

    @Override
    public Cursor loadInBackground() {
        DictionaryDatabase db = new DictionaryDatabase(mContext);
        return db.getWordList();
    }
}</pre></div></li><li class="listitem">Next, open <code class="literal">ActivityMain.java</code>. We need to change the declaration to implement the <code class="literal">LoaderManager.LoaderCallbacks&lt;Cursor&gt;</code> interface as follows:<div><pre class="programlisting">public class MainActivity extends AppCompatActivity implements {</pre></div></li><li class="listitem">Add the adapter to the global declarations. The complete list is as follows:<div><pre class="programlisting">EditText mEditTextWord;
EditText mEditTextDefinition;
DictionaryDatabase mDB;
ListView mListView;
DictionaryAdapter mAdapter;</pre></div></li><li class="listitem">Change <code class="literal">onCreate()</code> to use the new adapter and add a call to update the Loader after <a id="id412" class="indexterm"/>deleting a record. The final <code class="literal">onCreate()</code> method <a id="id413" class="indexterm"/>should look as follows:<div><pre class="programlisting">protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    mDB = new DictionaryDatabase(this);

    mEditTextWord = (EditText) findViewById(R.id.editTextWord);
    mEditTextDefinition = (EditText) findViewById(R.id.editTextDefinition);

    Button buttonAddUpdate = (Button) findViewById(R.id.buttonAddUpdate);
    buttonAddUpdate.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            saveRecord();
        }
    });

    mListView = (ListView) findViewById(R.id.listView);
    mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
            Toast.makeText(MainActivity.this, mDB.getDefinition(id), Toast.LENGTH_SHORT).show();
        }
    });
    mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
        @Override
        public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
            Toast.makeText(MainActivity.this, "Records deleted = " + mDB.deleteRecord(id), Toast.LENGTH_SHORT).show();
            getSupportLoaderManager().restartLoader(0, null, MainActivity.this);
            return true;
        }
    });
    getSupportLoaderManager().initLoader(0, null, this);
    mAdapter = new DictionaryAdapter(this,mDB.getWordList(),0);
    mListView.setAdapter(mAdapter);
}</pre></div></li><li class="listitem">We no longer have the <code class="literal">updateWordList()</code> method, so change <code class="literal">saveRecord()</code> as follows:<div><pre class="programlisting">private void saveRecord() {
    mDB.saveRecord(mEditTextWord.getText().toString(), mEditTextDefinition.getText().toString());
    mEditTextWord.setText("");
    mEditTextDefinition.setText("");
    getSupportLoaderManager().restartLoader(0, null, MainActivity.this);
}</pre></div></li><li class="listitem">Finally, implement<a id="id414" class="indexterm"/> these three methods for the <a id="id415" class="indexterm"/>Loader interface:<div><pre class="programlisting">@Override
public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {
    return new DictionaryLoader(this);
}

@Override
public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) {
    mAdapter.swapCursor(data);
}

@Override
public void onLoaderReset(Loader&lt;Cursor&gt; loader) {
    mAdapter.swapCursor(null);
}</pre></div></li><li class="listitem">Run the program on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec188"/>How it works...</h2></div></div></div><p>The default <code class="literal">CursorAdapter</code> requires a Content Provider URI. Since we are accessing the SQLite database directly (and not through a Content Provider), we don't have a URI to pass, so instead we created a custom adapter by extending the <code class="literal">CursorAdapter</code> class. <code class="literal">DictionaryAdapter</code> still performs the same functionality as the previous <code class="literal">SimpleCursorAdapter</code> from the previous recipe, namely mapping the data from the cursor to the item layout.</p><p>The next class we added was <code class="literal">DictionaryLoader</code>, which is the actual Loader. As you can see, it's actually very simple. All it does is return the cursor from <code class="literal">getWordList()</code>. The key here is that this query is being handled in a background thread and will call the <code class="literal">onLoadFinished()</code> callback (in <code class="literal">MainActivity.java</code>) when it finishes. Fortunately, most of the heavy lifting is handled in the base class.</p><p>This takes us to <code class="literal">ActivityMain.java</code>, where we implemented the following three callbacks from the <code class="literal">LoaderManager.LoaderCallbacks</code> interface:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onCreateLoader()</code>: It's initially called in <code class="literal">onCreate()</code> with the <code class="literal">initLoader()</code> call. It's called again with the <code class="literal">restartLoader()</code> call, after we make changes to the database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onLoadFinished()</code>: It's called when the Loader <code class="literal">loadInBackground()</code> finishes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onLoaderReset()</code>: It's called when the Loader is being recreated (such as with the <code class="literal">restart()</code> method). We set the old cursor to <code class="literal">null</code> because it will be invalidated and we don't want a reference kept around.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec189"/>There's more...</h2></div></div></div><p>As you saw in the previous<a id="id416" class="indexterm"/> example, we need to manually notify the<a id="id417" class="indexterm"/> Loader to requery the database using <code class="literal">restartLoader()</code>. One of the benefits of using a Loader is that it can auto-update, but it requires a Content Provider as the data source. A Content Provider supports using an SQLite database as the data source, and for a serious application, would be recommended. See the following Content Provider link to get started.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec190"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>AsyncTask</em> recipe in <a class="link" href="ch14.html" title="Chapter 14. Getting your app ready for the Play Store">Chapter 14</a>, <em>Getting Your App Ready for the Play Store</em>.</li><li class="listitem" style="list-style-type: disc">Creating a <a id="id418" class="indexterm"/>Content Provider: <a class="ulink" href="http://developer.android.com/guide/topics/providers/content-provider-creating.html">http://developer.android.com/guide/topics/providers/content-provider-creating.html</a></li></ul></div></div></div></body></html>