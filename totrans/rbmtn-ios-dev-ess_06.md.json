["```swift\n    imagePicker.sourceType = UIImagePickerControllerSourceTypeCamera;\n\n    ```", "```swift\n    imagePicker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;\n\n    ```", "```swift\n    imagePicker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;\n\n    ```", "```swift\n    motion create CameraExample\n\n    ```", "```swift\n    class AppDelegate\n      def application(application, didFinishLaunchingWithOptions:launchOptions)\n         @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)\n         @window.rootViewController = CameraController.alloc.init\n         @window.makeKeyAndVisible\n         true\n      end\n    end\n    ```", "```swift\n    class CameraController < UIViewController\n\n      def viewDidLoad\n        view.backgroundColor = UIColor.underPageBackgroundColor\n        load_view\n      end\n\n      def load_view\n        @camera_button = UIButton.buttonWithType(UIButtonTypeRoundedRect)\n        @camera_button.frame  = [[50, 20], [200, 50]]\n        @camera_button.setTitle(\"Click from camera\", forState:UIControlStateNormal)\n        @camera_button.addTarget(self, action: :start_camera, forControlEvents:UIControlEventTouchUpInside)\n        view.addSubview(@camera_button)\n\n        @gallery_button = UIButton.buttonWithType(UIButtonTypeRoundedRect)\n        @gallery_button.frame  = [[50, 100], [200, 50]]\n        @gallery_button.setTitle(\"Chose from Gallery\", forState:UIControlStateNormal)\n        @gallery_button.addTarget(self, action: :open_gallery, forControlEvents:UIControlEventTouchUpInside)\n        view.addSubview(@gallery_button)\n\n        @image_picker = UIImagePickerController.alloc.init\n        @image_picker.delegate = self \n      end\n\n      def imagePickerController(picker, didFinishPickingImage:image, editingInfo:info)\n        self.dismissModalViewControllerAnimated(true)\n        @image_view.removeFromSuperview if @image_view\n        @image_view = UIImageView.alloc.initWithImage(image)\n        @image_view.frame = [[50, 200], [200, 180]]\n        view.addSubview(@image_view)\n      end\n\n      def start_camera\n        if camera_present?\n          @image_picker.sourceType = UIImagePickerControllerSourceTypeCamera\n          presentModalViewController(@image_picker, animated:true)\n        else\n          show_alert\n        end\n      end\n      def open_gallery\n        @image_picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary\n        presentModalViewController(@image_picker, animated:true)\n      end\n      def show_alert\n        alert = UIAlertView.new  \n        alert.message = ‘No Camera in device'\n        alert.show\n      end\n      def camera_present?\n        UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceTypeCamera)\n      end\n    end\n    ```", "```swift\n$rake\n\n```", "```swift\n  def load_view\n    @camera_button = UIButton.buttonWithType(UIButtonTypeRoundedRect)\n    @camera_button.frame  = [[50, 20], [200, 50]]\n    @camera_button.setTitle(\"Click from camera\", forState:UIControlStateNormal)\n    @camera_button.addTarget(self, action: :start_camera, forControlEvents:UIControlEventTouchUpInside)\n    view.addSubview(@camera_button)\n    @gallery_button = UIButton.buttonWithType(UIButtonTypeRoundedRect)\n    @gallery_button.frame  = [[50, 100], [200, 50]]\n    @gallery_button.setTitle(\"Choose from Gallery\", forState:UIControlStateNormal)\n    @gallery_button.addTarget(self, action: :open_gallery, forControlEvents:UIControlEventTouchUpInside)\n    view.addSubview(@gallery_button)\n\n    @image_picker = UIImagePickerController.alloc.init\n    @image_picker.delegate = self \n  end\n```", "```swift\n  def start_camera\n    if camera_present?\n      @image_picker.sourceType = UIImagePickerControllerSourceTypeCamera\n      presentModalViewController(@image_picker, animated:true)\n    else\n      show_alert\n    end\n  end\n\n  def open_gallery\n    @image_picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary\n    presentModalViewController(@image_picker, animated:true)\n  end\n  def show_alert\n    alert = UIAlertView.new  \n    alert.message = ‘No Camera in device'\n    alert.show\n  end\n```", "```swift\n  def imagePickerController(picker, didFinishPickingImage:image, editingInfo:info)\n    self.dismissModalViewControllerAnimated(true)\n    @image_view.removeFromSuperview if @image_view\n    @image_view = UIImageView.alloc.initWithImage(image)\n    @image_view.frame = [[50, 200], [200, 180]]\n    view.addSubview(@image_view)\n  end\n```", "```swift\n    $motion create LocationManager \n\n    ```", "```swift\n    class AppDelegate\n      def application(application, didFinishLaunchingWithOptions:launchOptions)\n         @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)\n         @window.rootViewController = LocationController.alloc.init\n         @window.makeKeyAndVisible\n        true\n      end\n    end\n    ```", "```swift\n    app.frameworks = [‘CoreLocation', ‘MapKit']\n    ```", "```swift\n    class LocationController < UIViewController\n      def viewDidLoad\n        view.backgroundColor = UIColor.underPageBackgroundColor\n        create_location_label\n        check_location\n\n      end \n\n      def check_location\n        if (CLLocationManager.locationServicesEnabled)\n         @location_manager = CLLocationManager.alloc.init\n         @location_manager.desiredAccuracy = KCLLocationAccuracyKilometer\n         @location_manager.delegate = self\n         @location_manager.purpose = \" Our applications functionality \n    is based on your current location \"\n         @location_manager.startUpdatingLocation\n        else\n          show_error_message(‘Please enable the Location Services for this app in Settings.')\n        end\n      end\n      def create_location_label\n      @latitudeLabel =  UILabel.alloc.initWithFrame( [[25, 30], [250, 40]] )\n      @latitudeLabel.backgroundColor = UIColor.clearColor\n\n      @longitudeLabel =  UILabel.alloc.initWithFrame( [[25, 80], [250, 40]] )\n      @longitudeLabel.backgroundColor = UIColor.clearColor\n\n       @latitudeLabel.text = \"Latitude:\"\n       @longitudeLabel.text = \"Longitude:\"\n       view.addSubview(@latitudeLabel)\n       view.addSubview(@longitudeLabel)\n      end\n      def locationManager(manager, didUpdateToLocation:newLocation, fromLocation:oldLocation)\n       @latitudeLabel.text =  @latitudeLabel.text + newLocation.coordinate.latitude.to_s\n       @longitudeLabel.text =  @longitudeLabel.text + newLocation.coordinate.longitude.to_s\n      end\n\n      def locationManager(manager, didFailWithError:error)\n\n         show_error_message(‘Please enable the Location Services for this app in Settings.')\n      end\n      def show_error_message msg\n        alert = UIAlertView.new\n        alert.message =  msg\n        alert.show\n      end\n\n    end\n    ```", "```swift\n    @location_manager = CLLocationManager.alloc.init\n\n    ```", "```swift\n     @location_manager.desiredAccuracy = KCLLocationAccuracyKilometer\n\n    ```", "```swift\n     @location_manager.delegate = self\n    @location_manager.purpose = \"Our application provides functionality based on your current location\"\n\n    ```", "```swift\n    def locationManager(manager, didUpdateToLocation:newLocation, fromLocation:oldLocation)\n       @latitudeLabel.text =  @latitudeLabel.text + newLocation.coordinate.latitude.to_s\n       @longitudeLabel.text =  @longitudeLabel.text + newLocation.coordinate.longitude.to_s\n      end\n    ```", "```swift\n    @location_manager.startUpdatingLocation\n\n    ```", "```swift\n$rake\n\n```", "```swift\n      def show_map\n         map= MKMapView.alloc.initWithFrame( [[20,190], [275, 150]] )\n         map.mapType = MKMapTypeStandard\n         self.view.addSubview(map)\n      end\n    ```", "```swift\n      def viewDidLoad\n        view.backgroundColor = UIColor.underPageBackgroundColor\n        location_label\n        check_location\n        show_map\n      end\n    ```", "```swift\n    $rake\n\n    ```", "```swift\n      def show_map\n         map= MKMapView.alloc.initWithFrame( [[20,190], [275, 150]] )\n         map.mapType = MKMapTypeStandard\n     location = CLLocationCoordinate2D.new(@latitude, @longitude) \n     map.setRegion( MKCoordinateRegionMake(location, MKCoordinateSpanMake(1, 1)),animated:true )\n     pointer = MyAnnotation.alloc.initWithCoordinate(location, title:\"Title\", andSubTitle:\"Sub Title\")\n     map.addAnnotation(pointer)\n         self.view.addSubview(map)\n      end\n    ```", "```swift\n    class MyAnnotation \n      def initWithCoordinate(coordinate, title:title, andSubTitle:subtitle)\n        @coordinate = coordinate\n        @title = title\n        @subtitle = subtitle\n        self\n      end\n\n      def coordinate\n        @coordinate\n      end\n      def title\n        @title\n      end\n      def subtitle\n        @subtitle\n      end\n    end\n    ```", "```swift\n      def locationManager(manager, didUpdateToLocation:newLocation, fromLocation:oldLocation)\n     @latitude = newLocation.coordinate.latitude\n     @longitude = newLocation.coordinate.longitude\n        @latitudeLabel.text =  @latitudeLabel.text + newLocation.coordinate.latitude.to_s\n        @longitudeLabel.text =  @longitudeLabel.text + newLocation.coordinate.longitude.to_s\n     @location_manager.stopUpdatingLocation\n     show_map\n      end\n    ```", "```swift\n    $rake\n\n    ```", "```swift\n    $motion create gesture\n\n    ```", "```swift\n    class AppDelegate\n      def application(application, didFinishLaunchingWithOptions:launchOptions)\n\n           @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)\n           @window.rootViewController = UINavigationController.alloc.initWithRootViewController(GestureController.new)\n           @window.makeKeyAndVisible \n        true\n      end\n    end\n    ```", "```swift\n    class GestureController <  UIViewController\n      def viewDidLoad\n        view.backgroundColor = UIColor.whiteColor\n\n        longPressRecognizer = UILongPressGestureRecognizer.alloc.initWithTarget(self, action:'longPressGestureRecognizer:')\n        tap_gesture_recognizer = UITapGestureRecognizer.alloc.initWithTarget(self,action:'tabGestureRecognizer:')\n        rotate_gesture_recognizer = UIRotationGestureRecognizer.alloc.initWithTarget(self, action:'rotationGestureRecognizer:')\n        swipe_gesture_recognizer = UISwipeGestureRecognizer.alloc.initWithTarget(self, action:'swipeGestureRecognizer:')\n        pan_gesture_recognizer = UIPanGestureRecognizer.alloc.initWithTarget(self, action:'panGestureRecognizer:')\n        pinch_gesture_recognizer = UIPinchGestureRecognizer.alloc.initWithTarget(self, action:'pinchGestureRecognizer:')\n\n        self.view.addGestureRecognizer(longPressRecognizer)\n        self.view.addGestureRecognizer(tap_gesture_recognizer)\n        self.view.addGestureRecognizer(rotate_gesture_recognizer) \n        self.view.addGestureRecognizer(swipe_gesture_recognizer)\n        self.view.addGestureRecognizer(pan_gesture_recognizer)\n        self.view.addGestureRecognizer(pinch_gesture_recognizer)\n        load_labels\n      end\n        def longPressGestureRecognizer(longPressRecognizer)  \n        show_alert(\"You've pressed the screen long enough!\") if UIGestureRecognizerStateEnded == longPressRecognizer.state\n      end\n      def tabGestureRecognizer(tap_gesture_recognizer)\n        show_alert(\"You've tapped the screen!\")\n      end\n      def rotationGestureRecognizer(rotate_gesture_recognizer)\n        show_alert(\"You've rotated the screen!\") if UIGestureRecognizerStateEnded == rotate_gesture_recognizer.state\n      end\n      def swipeGestureRecognizer(swipe_gesture_recognizer)\n        show_alert(\"You've just swiped!\") if UIGestureRecognizerStateEnded == swipe_gesture_recognizer.state\n      end\n      def panGestureRecognizer(pan_gesture_recognizer)\n        show_alert(\"You've Panned!\") if UIGestureRecognizerStateEnded == pan_gesture_recognizer.state\n      end\n      def pinchGestureRecognizer(pinch_gesture_recognizer)\n        show_alert(\"You've Pinched!\") if UIGestureRecognizerStateEnded == pinch_gesture_recognizer.state\n      end\n\n      def load_labels\n        label = UILabel.new\n        label.frame = [[10,50],[300,100]]\n        label.lineBreakMode = UILineBreakModeWordWrap;\n        label.numberOfLines = 0\n        label.text = \" Try a different gesture such as tap, rotate, swipe, pan and pinch \"\n        view.addSubview(label) \n      end\n      def show_alert(message)\n        alert_box = UIAlertView.alloc.initWithTitle(\"Gesture Action\",\n        message:message,\n        delegate: nil,\n        cancelButtonTitle: \"ok\",\n        otherButtonTitles:nil)\n\n        alert_box.show\n      end\n    end\n    ```", "```swift\n    $rake\n\n    ```", "```swift\n    longPressRecognizer = UILongPressGestureRecognizer.alloc.initWithTarget(self, action:'longPressGestureRecognizer:')\n    tap_gesture_recognizer = UITapGestureRecognizer.alloc.initWithTarget(self,action:'tabGestureRecognizer:')\n    rotate_gesture_recognizer = UIRotationGestureRecognizer.alloc.initWithTarget(self, action:'rotationGestureRecognizer:')\n    swipe_gesture_recognizer = UISwipeGestureRecognizer.alloc.initWithTarget(self, action:'swipeGestureRecognizer:')\n    pan_gesture_recognizer = UIPanGestureRecognizer.alloc.initWithTarget(self, action:'panGestureRecognizer:')\n    pinch_gesture_recognizer = UIPinchGestureRecognizer.alloc.initWithTarget(self, action:'pinchGestureRecognizer:')\n```", "```swift\n    self.view.addGestureRecognizer(longPressRecognizer)\n    self.view.addGestureRecognizer(tap_gesture_recognizer)\n    self.view.addGestureRecognizer(rotate_gesture_recognizer)\n    self.view.addGestureRecognizer(swipe_gesture_recognizer)\n    self.view.addGestureRecognizer(pan_gesture_recognizer)\n    self.view.addGestureRecognizer(pinch_gesture_recognizer)\n```", "```swift\ndef pinchGestureRecognizer(pinch_gesture_recognizer)\n    show_alert(\"You have Pinch\") if UIGestureRecognizerStateEnded == pinch_gesture_recognizer.state\n  end\n```", "```swift\n    $motion create CoreDataExample\n\n    ```", "```swift\n    app.frameworks += [‘CoreData']\n    ```", "```swift\n    class Employee < NSManagedObject\n      #Attribute Name, Data Type, Default Value, Is Optional, Is Transient, Is Indexed\n      @attributes ||= [\n        [‘name', NSStringAttributeType, ‘', false, false, false],\n        [‘age', NSInteger32AttributeType, 0, false, false, false]   \n      ]\n    end\n    ```", "```swift\n    class NSEntityDescription\n      def self.newEntityDescriptionWithName(name, attributes:attributes)\n        entity = self.alloc.init\n        entity.name = name\n        entity.managedObjectClassName = name\n\n        attributes = attributes.each.map do |name, type, default, optional, transient, indexed|\n          property = NSAttributeDescription.alloc.init\n          property.name = name\n          property.attributeType = type\n          property.defaultValue = default if default != nil\n          property.optional = optional\n          property.transient = transient\n          property.indexed = indexed\n          property\n        end\n        entity.properties = attributes \n        entity\n      end \n    end\n    ```", "```swift\n      def self.entity\n        @entity ||= NSEntityDescription.newEntityDescriptionWithName(name, attributes:@attributes)\n      end\n\n      def self.objects\n        # Use if you do not want any section in your table view\n        @objects ||= NSFetchRequest.fetchObjectsForEntityForName(name, withSortKey:@sortKey, ascending:false, inManagedObjectContext:Store.shared.context)\n      end\n\n    end\n\n    class NSManagedObject\n      def self.entity\n        @entity ||= NSEntityDescription.newEntityDescriptionWithName(name, attributes:@attributes)\n      end\n      def self.objects\n        # Use if you do not want any section in your table view\n        @objects ||= NSFetchRequest.fetchObjectsForEntityForName(name, withSortKey:@sortKey, ascending:false, inManagedObjectContext:Store.shared.context)\n      end\n    end\n    ```", "```swift\n    class AppDelegate\n      def application(application, didFinishLaunchingWithOptions:launchOptions)      \n          setting_core_data\n          true\n      end \n\n      def setting_core_data\n\n        # First we need to create the NSManagedObjectModel with all the entities and their relationships. \n        managed_object_model = NSManagedObjectModel.alloc.init\n        managed_object_model.entities = [Employee.entity]\n\n        # The next object needed is the NSPersistentStoreCoordinator which will allow Core Data to persist the information.\n        persistent_store_coordinator = NSPersistentStoreCoordinator.alloc.initWithManagedObjectModel(managed_object_model)\n\n        # Now lets get a URL for where we want Core Data to create the persist file, in this case a SQLite Database File\n        persistent_store_file_url = NSURL.fileURLWithPath(File.join(NSHomeDirectory(), \n                                                                    ‘Documents', \n                                                                    ‘EmployeeStore.sqlite'))\n\n        error_pointer = Pointer.new(:object)\n\n        # Add a new Persistent Store to our Persistent Store Coordinator which means that we are telling the Persistent Store Coordinator where to perform the save of our objects.\n        # In this case we are stating that our objects must be stored in a SQLite database in the path we already created previously\n       unless persistent_store_coordinator.addPersistentStoreWithType(NSSQLiteStoreType,\n    configuration: nil,                                                                   URL: persistent_store_file_url,\n    options: nil,                                                                   error: error_pointer)\n          # In case we can't initialize the Persistance Store File\n     raise \"Cannot initialize Core Data Persistance Store Coordinator: #{error_pointer[0].description}\"\n        end\n        # Finally our most important object, the Managed Object Context, is responsible for creating, destroying, and fetching the objects\n\n        @managed_object_context = NSManagedObjectContext.alloc.init\n        @managed_object_context.persistentStoreCoordinator = persistent_store_coordinator\n      end\n    end\n    ```", "```swift\n    $rake\n\n    ```", "```swift\n      def application(application, didFinishLaunchingWithOptions:launchOptions)   \n          setting_core_data\n          employee_view_controller = EmployeeViewController.alloc.init\n\n     # We need to pass the Managed Object Context to the next controller so we can use it later for creating, fetching or deleting objects\n     employee_view_controller.managed_object_context = @managed_object_context\n     @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)\n     @window.rootViewController  = UINavigationController.alloc.initWithRootViewController(employee_view_controller)\n     @window.makeKeyAndVisible\n\n          true\n      end\n    ```", "```swift\n    class EmployeeViewController < UIViewController\n     attr_accessor :managed_object_context\n     def loadView\n       # Set up the title for the View Controller\n       self.title = ‘Employee'\n\n       # Create a new Table View for showing the Text Fields\n       table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,\n                                                    style:UITableViewStyleGrouped)\n       table_view.dataSource = self\n       self.view = table_view\n\n       # Create a new Bar Button Item with the Add System Default\n       add_new_employee_item= UIBarButtonItem.alloc.initWithBarButtonSystemItem(UIBarButtonSystemItemAdd,\n                                                                                     target: self,\n                                                                                     action: ‘add_new_employee')\n       # Add the Bar Button Item to the Navigation Bar\n       self.navigationItem.rightBarButtonItem = add_new_employee_item\n     end\n\n     def viewWillAppear(animated)\n       super\n       reload_data\n     end\n    ```", "```swift\n    def reload_data\n    fetch_request = NSFetchRequest.alloc.init\n\n    entity = NSEntityDescription.entityForName(Employee.name, \n                                                           inManagedObjectContext:@managed_object_context)\n       fetch_request.setEntity(entity)\n\n       # Sort the Employee by employee name\n       fetch_sort = NSSortDescriptor.alloc.initWithKey(‘name',\n                                                       ascending: true)\n       fetch_request.setSortDescriptors([fetch_sort])\n\n       # Update the fetch employee array and reload the table view\n       update_fetched_employee_with_fetch_request(fetch_request)\n     end\n\n     def update_fetched_employee_with_fetch_request(fetch_request)\n\n       # Create a new pointer for managing the errors\n       error_pointer = Pointer.new(:object)\n\n       # Using the NSManagedObjectContext execute the fetch request\n       @fetched_employee = @managed_object_context.executeFetchRequest(fetch_request,\n                                                                     error: error_pointer)\n\n       # If the returning array of the fetch request is nil\n       # means that a problem has occurred\n       unless @fetched_employee\n         raise \"Error fetching employee: #{error_pointer[0].description}\"\n       end\n       # refresh table view to reload its data\n       self.view.reloadData\n     end\n\n     # UITableView Data Source\n     def tableView(tableView, numberOfRowsInSection: section)\n       @fetched_employee.count\n     end\n\n     def tableView(tableView, cellForRowAtIndexPath: indexPath)\n       cell_identifier = ‘EmployeeCell'\n       cell = tableView.dequeueReusableCellWithIdentifier(cell_identifier)\n       # If we are not cells to use we need to create one\n       if cell == nil\n         # Lets create a new UITableViewCell with the identifier\n         cell = UITableViewCell.alloc.initWithStyle(UITableViewCellStyleValue1, reuseIdentifier:cell_identifier)\n         cell.selectionStyle = UITableViewCellSelectionStyleNone\n       end\n\n       employee = @fetched_employee[indexPath.row]\n       cell.textLabel.text = employee.name\n       cell.detailTextLabel.text = employee.age.to_s\n       cell\n     end\n\n     def add_new_employee\n       add_employee_view_controller = AddEmployeeViewController.alloc.init\n\n       # We need to pass the Managed Object Context to the next controller so we can use it later for creating, fetching or deleting objects\n       add_employee_view_controller.managed_object_context = @managed_object_context\n       self.navigationController.pushViewController(add_employee_view_controller, \n                                                    animated:true)\n     end\n\n    end\n    ```", "```swift\n    @fetched_employee = @managed_object_context.executeFetchRequest(fetch_request,\n                                                                     error: error_pointer)\n    ```", "```swift\n    class AddEmployeeViewController < UIViewController\n      attr_accessor :managed_object_context\n\n      def viewDidLoad\n        self.view.backgroundColor = UIColor.whiteColor\n        self.title = ‘Add Employee'\n        save_bar_button_item = UIBarButtonItem.alloc.initWithTitle(‘Save',\n        style: UIBarButtonItemStyleDone,\n        target: self,\n        action: ‘save_employee')\n       self.navigationItem.rightBarButtonItem = save_bar_button_item\n        load_form\n      end\n\n      def save_employee\n        # Using Core Data create a new instance of the object employee\n        employee = NSEntityDescription.insertNewObjectForEntityForName(Employee.name, \n        inManagedObjectContext: @managed_object_context)\n        # Assign the text of the name text field to the employee\n        employee.name = @name.text\n        employee.age = @age.text.intValue\n\n        # Create a new pointer for managing the errors\n        error_pointer = Pointer.new(:object)\n\n        # Lets persist the new Movie object, saving the managed object context that contains it\n        unless @managed_object_context.save(error_pointer)\n          raise \"Error saving a new Director: #{error_pointer[0].description}\"\n        end\n\n        # Pop the Director View Controller\n        self.navigationController.popViewControllerAnimated(true)\n      end\n\n      def load_form \n        @name = UITextField.alloc.initWithFrame([[50,50],[200,30]])\n        @name.borderStyle = UITextBorderStyleRoundedRect\n        @name.placeholder = \"Name\"\n        self.view.addSubview(@name)\n        @age = UITextField.alloc.initWithFrame([[50,100],[200,30]])\n        @age.borderStyle = UITextBorderStyleRoundedRect\n        @age.placeholder = \"Age\"\n        self.view.addSubview(@age)\n      end\n    end\n    ```", "```swift\n    employee = NSEntityDescription.insertNewObjectForEntityForName(Employee.name, \n                                                                    inManagedObjectContext: @managed_object_context)\n    ```", "```swift\n    $ rake\n\n    ```", "```swift\n    def tableView(tableView, canEditRowAtIndexPath: indexPath)\n       true\n     end\n\n    def tableView(tableView, commitEditingStyle: editingStyle, forRowAtIndexPath: indexPath)\n\n       employee = @fetched_employee[indexPath.row]\n       # Ask the NSManagedObjectContext to delete the object\n       @managed_object_context.deleteObject(employee)\n\n       # Create a new pointer for managing the errors\n       error_pointer = Pointer.new(:object)\n\n       # Lets persist the deleted employee object, saving the managed object context that contains it\n       unless @managed_object_context.save(error_pointer)\n         raise \"Error deleting an Employee: #{error_pointer[0].description}\"\n       end   \n\n       # Create a new mutable copy of the fetched_employee array\n       mutable_fetched_employee = @fetched_employee.mutableCopy\n\n       # Remove the employee from the array\n       mutable_fetched_employee.delete(employee)\n\n       # Assign the modified array to our fetched_employee property\n       @fetched_employee = mutable_fetched_employee\n\n       # Tell the table view to delete the row\n       tableView.deleteRowsAtIndexPaths([indexPath], \n                                        withRowAnimation:UITableViewRowAnimationFade)\n     end\n    ```", "```swift\n       @managed_object_context.deleteObject(employee)\n    ```", "```swift\n    $rake\n\n    ```", "```swift\n    $motion create AddressBook_example\n\n    ```", "```swift\n    class AppDelegate\n      def application(application, didFinishLaunchingWithOptions:launchOptions)\n\n      @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)\n      @window.rootViewController = AddressbookController.alloc.init\n      @window.makeKeyAndVisible\n\n        true\n      end\n    end\n    ```", "```swift\n    def viewDidLoad\n        view.backgroundColor = UIColor.underPageBackgroundColor\n        load_button\n        load_labels\n    end\n\n    def load_button\n\n           @phonebook_button = UIButton.buttonWithType(UIButtonTypeRoundedRect)\n           @phonebook_button.frame = [[50, 20], [200, 50]]\n           @phonebook_button.setTitle(\"Click from Contacts\", forState:UIControlStateNormal)\n    \t    @phonebook_button.addTarget(self, action: :phonebook_access, forControlEvents:UIControlEventTouchUpInside)\n           view.addSubview(@phonebook_button)    \n    end\n\n    def load_labels\n\n           @first_name = UILabel.new\n           @first_name.text = ‘First Name'\n           @first_name.frame = [[100,100],[150,50]]\n\n           @phone_number = UILabel.new\n           @phone_number.text = ‘Phone Number'\n           @phone_number.frame = [[100,200],[150,50]]\n\n           view.addSubview(@first_name)\n           view.addSubview(@phone_number)\n\n    end\n    ```", "```swift\n    $rake\n\n    ```", "```swift\n    def addressbook_access\n        @people_picker = ABPeoplePickerNavigationController.alloc.init\n        @people_picker.peoplePickerDelegate = self\n         presentModalViewController(@people_picker, animated:true)\n    end\n    ```", "```swift\n    def peoplePickerNavigationController(peoplePicker, shouldContinueAfterSelectingPerson:person)\n       self.displayPerson(person)\n       self.dismissModalViewControllerAnimated(true)\n\n    end\n    ```", "```swift\n    def displayPerson(person)\n       firstname = ABRecordCopyValue(person, KABPersonFirstNameProperty)\n       phoneNumbers = ABRecordCopyValue(person, KABPersonPhoneProperty)\n       phone = ABMultiValueCopyValueAtIndex(phoneNumbers, 0)\n       @phone_number.text = phone\n       @first_name.text = firstname\n\n    end\n    ```", "```swift\ndef peoplePickerNavigationControllerDidCancel(peoplePicker)\n    self.dismissModalViewControllerAnimated(true)\nend\n```"]