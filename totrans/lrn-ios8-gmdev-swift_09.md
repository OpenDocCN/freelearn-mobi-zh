# 第9章. 金属

在我们开始创建游戏之前，您应该了解如何在屏幕上显示内容。这总是被理所当然地认为，因为所有框架都有一个名为`sprite`的类，我们只需提供一个`.png`或`.jpg`文件，并说`addChild`，然后“砰”的一声，图像就出现在屏幕上。此外，仅通过一些简单的函数，如移动、缩放和旋转，我们甚至可以变换精灵的位置、大小和旋转。实际上，这个`sprite`类只是为了在屏幕上显示图像而做了一大堆工作。

在本章中，我们将探讨Metal——苹果公司开发的一个新的图形库。这个图形库将帮助我们显示屏幕上的对象。它是一个通信工具，与处理器、内存、**图形处理单元**（**GPU**）和屏幕进行通信。

如果您来自DirectX或OpenGL的背景，您会发现显示内容到屏幕上的过程，也就是所谓的图形管线，在Metal中非常相似。Metal的图形管线可以使用着色语言进行编程，该语言以C++11为基础。我们将在本章中详细介绍它。让我们开始使用Metal吧！

本章我们将涵盖以下主题：

+   概述

+   图形管线和着色器

+   基本的Metal项目

+   着色四边形项目

+   纹理四边形项目

# 概述

Metal是一个用于在屏幕上显示任何内容的图形API。Metal非常特定于iOS 8及以上版本；此外，它只能在配备A7芯片及以上的设备上运行。据说它的运行速度比OpenGLES快十倍。OpenGLES是另一个图形库。与Metal不同，OpenGLES是开源的，并且可以在跨平台上工作。这里的权衡是，您可以使其运行速度快十倍，这意味着您可以在屏幕上添加更多的粒子和其他对象，然而，您无法在其他操作系统（如Android和Windows Phone）上运行您的游戏。使用OpenGLES开发的游戏可以在其他设备上运行，只需对代码进行少量修改。实际上，SpriteKit和SceneKit就是使用OpenGLES开发的。那么，您是想制作一个屏幕上有更多对象的游戏，还是更希望您的游戏可以在其他平台上运行？选择权在您手中。

在Metal中，要在屏幕上渲染任何内容，您必须分两个阶段进行。第一个阶段是准备或初始化阶段，下一个阶段是绘制阶段。在准备阶段，我们首先获取对GPU的访问权限，准备资源，如顶点和缓冲区，并准备渲染管线和您希望对象渲染到的视图。准备阶段完成后，我们就可以进入“绘制”阶段，实际绘制图像。

# 图形管线和着色器

让我们详细看看这些阶段。我们首先看看准备阶段。

## 准备/初始化阶段

此阶段包括以下步骤：

1.  获取设备。

1.  命令队列。

1.  资源。

1.  渲染管线。

1.  查看视图。

我们将逐个查看每个步骤。

### 获取设备

首先，我们必须获取将负责渲染我们的对象的设备。这将让我们了解GPU在性能和功能方面的能力。在Metal中，它将基本上告诉我们我们在哪个设备上运行游戏，即是否在iPhone、iPad或OS X上运行。它还会告诉我们设备的哪个版本，以及它是否是iPhone 6、5、4或其他任何设备。

### 命令队列

一旦我们知道了正在处理的设备，我们就可以获取队列中的下一个命令。信息以异步方式从CPU发送到GPU。这意味着CPU和GPU不会在特定时间处理相同的项。当CPU完成计算后，信息被传递给GPU。如果GPU正忙，信息必须等待，直到CPU处理下一个进程。为此，我们需要一个队列。所以基本上，GPU的命令在执行之前会等待在队列中。因此，在这个步骤中，我们获取队列中的下一个空闲槽位，以便信息可以从CPU传递到GPU。

### 资源

在这个步骤中，我们准备顶点，这是我们想要传递给GPU的信息。我们将声明每个顶点具有的属性（例如，在基本层面上每个顶点的坐标）。我们还可以提供其他信息，例如每个坐标的颜色。我们还需要将这些数据存储在内存中，以便在命令执行时，GPU可以检索信息。信息存储在缓冲区中。对于顶点的每个属性，都会创建一个缓冲区。正如我们在第一章中看到的，缓冲区不过是内存中的一个位置。

在下面的屏幕截图中，我们可以看到指定了四个坐标**a**、**b**、**c**和**d**，每个都有自己的顶点和颜色属性：

![资源](img/B04014_09_01.jpg)

### 渲染管道

这个步骤被分解为两个步骤。在第一步中，你必须创建一个描述符。描述符是初始化管道的地方。我们将告诉像素在光栅化图像时使用哪种格式。我们还将在这里传递我们的顶点着色器和像素着色器函数。一旦描述符准备就绪，我们就可以将其传递给*渲染管道*状态。现在，状态包含管道所需的所有信息，以便可以轻松传递。我们将在稍后的部分查看着色器，因为它们在实际操作中更容易理解。

### 注意

从[第1章](ch01.html "第1章。入门")，*入门*中回顾以下内容：

+   **顶点/几何着色器**：信息随后被传递到顶点着色器。顶点着色器可以通过着色器语言进行编程。这种语言类似于C。使用这种语言，我们可以改变位置，使对象移动、缩放或旋转，就像你在游戏循环中的`update`函数中做的那样。

+   **像素/片段着色器**：与顶点着色器类似，在顶点着色器中你可以进行顶点修改，像素着色器将使你能够进行基于像素的操作。由于这是一个着色器，你知道这也是可编程的。使用像素着色器，你可以创建诸如更改纹理的颜色和透明度等效果。

### 视图

最后一步是设置和准备视图。在视图阶段，我们实际上需要访问将要绘制对象的视图所附加的层。层就像一个准备绘制的空白画布。我们获取视图的层，以便我们可以在其上继续绘制和擦除。

我们已经完成了初始化阶段；接下来，我们将看到实际开始在屏幕上绘制内容的步骤。

## 绘制阶段

在这里，我们将最终绘制我们在第一阶段发送的顶点。这一阶段也有一些需要遵循的步骤：

1.  开始渲染过程。

1.  获取命令缓冲区。

1.  绘制。

1.  提交命令缓冲区。

### 开始渲染过程

我们为绘制对象准备层。我们将层分配给要绘制的对象，并使用默认颜色清除表面。

### 获取命令缓冲区

命令缓冲区是存储渲染命令的地方。我们需要获取对命令缓冲区的访问权限以执行命令。

### 绘制

最后，绘制发生在层上。这是通过一个渲染命令编码器完成的，它将命令缓冲区中的代码编码成机器语言以渲染图像。我们传递管道状态和顶点缓冲区，然后绘制图像。这一整个过程是在屏幕外完成的。

### 提交命令缓冲区

这是最终阶段，图像渲染已经完成，图像准备在屏幕上显示。

现在我们已经拥有了所有这些理论知识，让我们将其付诸实践，看看我们如何在屏幕上显示可以观看的内容。

# 基本Metal项目

在这个第一个项目中，我们将创建一个基本的三角形并在设备上显示它。

创建一个新的Xcode项目。选择项目技术为 **Metal**，语言为 **Swift**：

![基本Metal项目](img/B04014_09_02.jpg)

选择保存项目的位置。在 `GameViewController.swift` 文件中，我们删除 `viewDidLoad` 函数的所有内容，以便我们可以从绝对基础开始。

如概述中所述，我们必须做的第一件事是获取应用程序将要工作的设备。添加以下行：

[PRE0]

我们创建了一个名为 `device` 的新常量，其类型为 `MTLDevice`，并将其分配给 `MTLCreateSytemDefaultDevice`。因此，我们现在可以直接访问设备。

接下来，我们必须为设备创建 `commandQueue`：

[PRE1]

我们从设备获取命令并将其分配给一个名为 `commandQueue` 的新变量。

在下一步中，我们准备资源，如顶点信息和顶点缓冲区。要创建顶点定义，在文件顶部创建一个名为`vertexArray`的数组，如图下代码所示：

[PRE2]

假设屏幕的形状是一个矩形，其宽度和高度各为2个像素，屏幕中心是原点。因此，在前面的数组中，第0个、第2个和第4个值是*x*坐标，而第1个、第3个和第5个项是对应的*y*坐标。

在这里，我们传递了三对`x`和`y`值来绘制一个三角形。对于第一个值，`x`位于原点，`y`在屏幕中心的*y*方向上为`.75`。接下来的两个坐标位于原点的左下角和右下角。

因此，我们现在已经有了顶点。接下来，我们必须创建一个顶点缓冲区，以便我们可以将其存储在其中。创建一个新的变量`vertexBuffer`，类型为`MTLBuffer`，如图所示，并将我们创建的`vertexArray`变量及其数组大小和`nil`作为`options`赋值。

![基本的Metal项目](img/B04014_09_03.jpg)

[PRE3]

接下来，我们必须创建我们的顶点着色器和片段着色器。

着色器是运行时编译的小段代码。有两种类型的着色器：**顶点**和**片段**：

+   **顶点着色器**：这允许我们在游戏代码外部执行顶点操作。通过顶点操作，我们指的是移动、旋转和转换每个顶点，从而整个对象。这是基本级别；我们可以通过使用顶点着色器执行更复杂的操作。顶点着色器的调用次数与我们传递的坐标数量相同。因此，在这种情况下，它将被调用三次。

+   **片段着色器**：这些着色器可以用于在像素级别进行操作。它们可以用来实现各种效果，如模糊、像素化、赛博着色等。与顶点着色器不同，像素或片段着色器可以根据需要多次调用，以填充三角形内的颜色或纹理空间。

让我们看看如何编写我们的第一个着色器文件。首先，我们将编写一个顶点着色器。在项目文件中，你将已经有一个名为`Shaders.metal`的新文件。这是Metal的着色器文件，其中你将编写你的顶点着色器和像素着色器。

拥有OpenGL或DirectX背景知识的人可能会想知道其他文件在哪里。这是Metal与其他着色语言之间的一大区别。Metal只使用一个文件，在这个文件中，你可以编写所有的着色器。每个着色器不是一个文件，而是一个函数。因此，当我们将在管道描述符中传递着色器时，我们不会给出着色器的文件名，而是给出函数名。

你可以创建多个着色器文件，在一个文件中编写顶点着色器，在另一个文件中编写像素着色器，或者反之亦然。Metal 实际上并不关心你将什么放在哪个文件中，只要确保你调用的是正确的函数。

要创建额外的金属着色器文件，你可以转到 **文件** | **新建** | **文件** | **源文件** 并选择 **Metal 文件**：

![基本的 Metal 项目](img/B04014_09_04.jpg)

在 `Shaders.metal` 文件中，删除所有内容并添加以下代码，因为我们将从基础开始：

[PRE4]

在顶部，我们包含金属标准库并使用命名空间 metal。对于有 C++ 经验的人来说，金属着色器语言使用的是 C++11 的修改版，会感到很熟悉。

随后的第一个函数是顶点着色器函数。着色器函数以 `vertex` 或 `fragment` 关键字开头，以表示该函数是顶点着色器还是片段着色器。

因此，在顶点着色器中，函数具有 `vertex` 关键字，并返回一个 `float4`。一个 float 4 就像是一个包含四个 float 值的结构：`x`、`y`、`z` 和 `w`；或者 `r`、`g`、`b` 和 `a`。

### 注意

着色器也有它们自己的数据类型，例如 `float`、`float2`、`float3` 和 `float4` 或 `int`、`int2`、`int3` 和 `int4`。由于着色器通常处理顶点或颜色，这些是具有 `x`、`y` 和 `z` 值的 `float3` 以及具有 `r`、`g`、`b` 和 `a` 值的 `float4`。

你也可以对这些值执行数学运算。例如，如果你有两个名为 `vert1` 和 `vert2` 的 `float3` 变量，并且将 `vert1` 和 `vert2` 相乘，那么生成的结果 `vert3` 将使用 `x` 值相乘来创建一个新的 `x` 值。同样，`y` 和 `z` 值将与 `vert1` 和 `vert2` 相乘，以创建具有新 `x`、`y` 和 `z` 值的 `vert3`。

在返回类型之后，我们指定函数的名称。

函数接受两个属性。双矩形括号表示它是一个属性。属性就像属性一样。在这里，我们通过我们创建的缓冲区传递 `vertexArray`。在属性中，我们通过索引 `0` 的缓冲区传递顶点数组。稍后，你会看到我们为 `vertexBuffer` 分配一个索引值，它指的是这里的 `0` 位置，这样着色器就知道哪个缓冲区是顶点缓冲区。

函数接受的下一个属性是顶点 ID。这会根据我们传递的顶点数量自动生成。我们传递三对 `x` 和 `y` 坐标，因此将为这个生成三个顶点 ID。

接下来，在函数中，它为每个顶点ID返回一个`float4`顶点。由于我们必须返回一个float 4，我们在末尾添加了额外的`0`和`1`。你可能想知道我们如何返回四个值，而实际上只返回了三个值：`vertex_array[vid]`、`0`和`1`。在着色器语言中，你可以在单个变量中将`x`和`y`组合在一起。在这里，`vertex_array[vid]`是一个变量，但实际上它包含两个对象，即该坐标的`x`和`y`值。

我们首先为片段着色器创建函数。与顶点着色器类似，我们首先指定着色器类型，然后是返回类型，接着提供函数的名称。目前我们还没有向函数传递任何内容。它确实返回一个`float4`值。由于它是一个片段着色器，而片段着色器用于像素操作，这里的四个值是颜色的RGBA值。因此，我们将绘制的三角形将是紫色的。如果你想让所有四个颜色值相同，我们可以执行以下操作：

[PRE5]

这将返回所有RGBA值都等于`0.56`。因此，三角形将是灰色的，并且由于alpha `a`的值也是`0.56`，它将是透明的。这种写值的方式看起来非常奇怪，因为我们通常不遵循常规数学中的这种做法，但通过不断使用，你会习惯它，实际上你会欣赏它，因为它对编写着色器来说更加方便。

### 注意

片段着色器也可以称为像素着色器，因为大部分情况下它们是相同的，但确保在创建像素着色器函数时使用`fragment`关键字，否则Metal无法理解你在说什么。

因此，我们已经完成了着色器文件；现在让我们继续在`GameViewController.swift`文件中的常规代码。

我们已经将着色器函数添加到我们的着色器库中。一旦着色器被编译，它就会被添加到`shader`库中，以便以后可以检索它，从而节省再次编译着色器的努力。

从设备获取库并将着色器函数添加到其中。我们还创建了新的常量，用于从设备获取顶点和着色器函数，这些将在渲染描述符中需要，如下面的代码所示：

[PRE6]

接下来，我们创建渲染管线描述符。首先，我们必须创建一个描述符，稍后将其分配给状态。所以，让我们创建一个新的管线描述符，如下面的代码所示：

[PRE7]

在描述符中，我们提供了顶点和着色器函数以及要使用的像素格式，如下面的代码所示：

[PRE8]

像素格式指定了颜色组件的顺序、每个组件的位深度和数据类型。有二十多种格式。要了解更多关于不同类型的像素格式，您可以访问苹果的文档，网址为[https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalConstants_Ref/#//apple_ref/c/tdef/MTLPixelFormat)。

然后，我们根据描述符创建了一个`RenderPipeline`状态，如下面的代码所示：

[PRE9]

创建了一个新的变量`pipelineState`，其类型为`MTLRenderPipeLineState`，并将`pipeLibeStateDescriptor`常量传递给它。

然后，我们创建一个类型为`CAMetalLayer`的图层并将其添加到当前视图中，这样我们就可以在上面绘制对象。因此，添加以下代码来准备视图并将其图层添加到其中：

[PRE10]

我们将`metalLayer`常量分配给设备、图层的像素格式（与我们在管道描述符中分配的相同），以及框架大小，它等于视图框架的大小（框架大小与屏幕大小相同）。最后，将`metalLayer`作为子图层添加到当前视图图层。

这就是设置所有所需的内容。我们可以继续到下一个阶段，即实际绘制三角形。

在下一步中，我们创建渲染通道描述符。然而，在我们可以创建它之前，我们需要从图层获取下一个可绘制纹理的引用，因为它将被传递到渲染描述符中：

[PRE11]

接下来，我们创建渲染描述符：

[PRE12]

现在，我们创建一个新的常量`renderPassDescriptor`，其类型为`MTLRenderPassDescriptor`。首先，我们分配可绘制图层的纹理，以便渲染的内容被绘制在纹理上。因此，可绘制图层的纹理被传递进来。

接下来，调用加载操作。一旦加载，图层首先用颜色清除。然后，我们传递一个颜色，图层将用这个颜色清除。在这里，我们传递了一个紫色。

在此基础上，我们的描述符就准备好了。接下来，我们必须渲染图层和三角形。所以首先，我们从命令队列中获取命令缓冲区。这些是存储在内存中的命令：

[PRE13]

所有这些命令都需要通过`MTLRenderCommandEncoder`编码成机器语言。我们在这里传递`renderPassDescriptor`变量来编码渲染代码：

[PRE14]

接下来，我们必须在编码器中设置管道和顶点缓冲区状态。在传递`vertexBuffer`时，我们必须传递偏移量和索引缓冲区值。由于我们创建了一个新的缓冲区，偏移量值是`0`，对于索引，我们传递`0`。这个索引值是顶点着色器所引用并传递到`[[buffer(0)]]`的值：

[PRE15]

最后，我们可以通过创建原语类型来绘制三角形。最终，所有形状都是由三角形组成的，正如我们在第一章中关于船的例子中所看到的。顶点的数量和它们的位置定义了物体的形状。在这里，我们创建一个单独的三角形形状，因此我们传递三个顶点来创建一个三角形。这个相同的三角形原语用于制作正方形、立方体、茶壶、球体等等：

[PRE16]

我们已经绘制完毕，因此我们可以结束编码：

[PRE17]

尽管我们已经绘制了三角形，但我们仍然需要在屏幕上呈现它。在下一步中，我们将提供纹理并将其提交到视图中：

[PRE18]

那就是全部了。最后，你将能够在屏幕上看到紫色三角形和黄色背景，如下面的截图所示：

![基本的 Metal 项目](img/B04014_09_05.jpg)

恭喜！你已经成功完成了。

所有这些只是为了绘制三角形，但我希望你现在能够欣赏到所做的努力。问题是，如果你在任何一个步骤中出错，三角形可能不会显示出来。

代码也保持得很简单。我们绝对可以通过添加渲染器类和创建独立的类来创建顶点数组来优化代码。

在下一个例子中，我们将创建一个正方形。这次，我们将为每个坐标传递颜色，而不是在片段着色器函数中键入颜色值。

# 彩色四边形项目

要创建一个彩色正方形，我们需要对 `vertexArray` 进行一些修改，因为我们需要传递六个顶点而不是三个。我们必须传递六个顶点，因为，正如你之前所看到的，我们只能绘制三角形。因此，我们需要三个点来形成正方形的顶部，还需要另外三个点来形成其底部：

[PRE19]

你会看到 `a` 和 `c` 点被重复以形成第二个三角形，因为正方形的对角线与第一个三角形的点是相同的。

![彩色四边形项目](img/B04014_09_06.jpg)

注意，在顶点数组中，我们现在为每个顶点传递四个值，而不是像三角形那样传递两个值。这将简化修改着色器函数的过程。

提供的坐标值是 `x`、`y` 和 `z` 值，还有一个额外的第四个参数 `w` 也被传递进来。就像二维空间中的 `z` 值一样，它目前并没有太多意义。稍后，当你创建一个三维对象时，`w` 参数将发挥重要作用。但，就目前而言，让这个值保持为 `1`。

此外，正如我们在创建三角形时所见，视图是一个以中心为原点的 2 x 2 矩形。由于我们在 *x*-*y* 方向上传递的坐标在 `1` 和 `-1` 之间，实际上这个矩形将覆盖整个屏幕。如果你仍然想看到黄色背景，将值 `1` 改为更小的值，就像我们在三角形的情况下所做的那样。不要更改与 `0` 对应的值。

类似于传递顶点，我们也将通过代码将这些坐标的颜色值作为缓冲区传递，以创建一个新的数组`colorArray`，如下面的行所示：

[PRE20]

这些是相应坐标的简单RGBA值。在这里，`a`表示红色`red` = `1`，绿色`green` = `0`，蓝色`blue` = `0`，透明度`alpha` = `1`。这些值的每个都在`0`和`1`之间。因此，`a`将呈现全红色。我们可以通过保持红色为`1`并添加更多绿色或蓝色来创建自定义颜色，例如在`c`和`d`的情况下。

接下来，类似于我们创建`vertexBuffer`的方式，我们必须创建一个类型为`MTLBuffer`的`colorBuffer`：

[PRE21]

我们传递了我们创建的`colorArray`以及整个数组的大小。

在代码中，我们不需要对设备、层或渲染管线进行任何更改。但我们需要更改顶点和着色器函数，因为我们将要传递关于颜色的信息。

在任何着色器语言中，我们也可以创建自己的数据类型。通过在着色器文件中使用结构体创建了一个名为`VertexInOut`的新数据类型。因此，在`Shader.metal`文件中输入以下代码：

[PRE22]

我们创建了一个包含两个`float4`值的结构体，其中一个用于位置，另一个用于颜色。使用双方括号的位置表示我们将通过位置属性传递和检索位置属性。

`vertex`函数已更改，如下面的代码行所示：

### 注意

压缩变量意味着你不能单独访问每个组件，这与常规的`float4`不同。例如，在一个具有位置数据的常规`float4`中，我们可以访问`x`、`y`、`z`和`w`值，但在压缩的`float`中，我们无法这样做。

[PRE23]

在这里，我们首先使用`vertex`关键字来声明`vertex`函数类型；我们返回一个之前创建的名为`VertexInOut`的类型，并提供函数名称。我们将顶点ID、索引为`0`的位置缓冲区和索引为`1`的颜色缓冲区传递给函数。

在函数中，我们创建了一个名为`outVertex`的新变量，其类型为`VertexInOut`，为每个顶点ID分配位置和颜色值，然后返回`outVertex`变量。

我们还需要更改片段着色器函数，因为通过缓冲区传入的颜色需要应用到立方体上：

[PRE24]

在片段着色器中，我们使用`fragment`关键字来指定这是一个片段着色器，返回一个`half4`（类似于`float4`但占用更少的内存），并为`shader`函数提供一个名称。该函数接收`VertexInOut`变量。`[[stage_in]]`部分用于表示操作将需要在每个像素的基础上进行。在函数中，我们要求它返回类型转换后的颜色值。

### 注意

更多关于`stage_in`的信息可以在[https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/func-var-qual/func-var-qual.html#//apple_ref/doc/uid/TP40014364-CH4-SW13)找到。

由于我们添加了一个新的颜色缓冲区并增加了顶点数量，我们必须对`renderEncoder`进行修改，如下面的代码所示：

[PRE25]

我们设置了一个新的顶点缓冲区，并传递了颜色缓冲区和索引值`1`。在`drawPrimitives`中，我们仍然在创建一个三角形类型的原始图形，但这次它有六个顶点。

最后，由于我们更改了着色器函数，我们需要更新管道中的名称，如下面的代码所示：

[PRE26]

现在一切都已经构建完成，我们可以看到彩色的正方形，或者通常所说的四边形：

![彩色的四边形项目](img/B04014_09_07.jpg)

你可能想知道，当你只为四个顶点传递了四个颜色时，为什么整个屏幕都被着色，颜色也在混合。

顶点着色器函数根据传入的顶点数量被调用。因此，顶点着色器函数被调用了六次。另一方面，片段着色器函数实际上被调用，直到填满每个三角形原始图形生成的区域。颜色根据坐标的距离进行插值。在这个例子中，左下角的坐标传递了绿色颜色值。随着它从左下角移动，颜色逐渐与其他颜色混合，从而降低了绿色的值。所以在中心，我们有了所有颜色的混合。这是任何片段着色器的一般特性。

# 纹理四边形项目

在下一个项目中，我们将创建一个纹理四边形对象。这是精灵类的基本构建块。在这里，我们将取一个图像并将其粘贴到我们在早期项目中创建的四边形或正方形上。

我之所以说它是精灵类的基本构建块，是因为我们无法移动、旋转或缩放精灵；我们只是在屏幕上显示精灵。

回到将精灵添加到任何四边形的过程，类似于将壁纸贴到墙上，我们可以在墙上正着或倒着贴壁纸。同样，在将图像添加到四边形时，我们必须指定哪个方向是向上的，否则精灵将被粘贴到四边形的倒置或侧置。

为了做到这一点，我们必须传递一个额外的坐标数组，这些坐标被称为纹理坐标。纹理坐标与顶点坐标不同，因为顶点坐标是以屏幕坐标系统为参考的，屏幕中心是原点。请参考提供的图像。

### 注意

我们在2D空间中工作，因此我们可以称之为屏幕坐标系，目前为了方便，它与世界坐标系相同，但在3D中实际上是世界坐标系。

纹理坐标系相对于每个四边形或矩形。此外，四边形的左上角是纹理坐标系统的原点。因此，为了在屏幕上移动四边形，您将更改顶点数组中的值。纹理坐标将改变，以便在四边形内实际移动图像。

因此，在所有理论都讲完之后，让我们创建一个新的数组，称为`textureCoordsArray`，如图所示。但在那之前，更改`vertexArray`并减小我们之前创建的四边形的尺寸，以便我们可以更好地理解纹理坐标所发生的情况：

[PRE27]

接下来，添加纹理坐标数组：

[PRE28]

在创建纹理四边形时，有两件事我们需要特别注意：

+   为每个三角形集提供的`vertex`数组需要按逆时针方向排列。因此，对于顶点数组中的前三个位置顶点，两个三角形分别需要按`abc`和`acd`的顺序排列，否则纹理将无法正确显示。

+   `vertex`数组和纹理坐标的顺序必须相同；如果顶点数组顺序是`abc`和`acd`，那么纹理坐标顺序也必须按相同顺序指定。

![纹理四边形项目](img/B04014_09_08.jpg)

在前面的图像中，红色字母**a**、**b**、**c**和**d**表示顶点坐标，绿色坐标表示纹理坐标。红色原点是顶点坐标的原点，绿色原点是纹理坐标的原点。

纹理坐标准备好后，我们必须创建一个类型为`MTLBuffer`的纹理缓冲区，并将纹理坐标数组传递给它，同时传递数组的大小。这与我们之前为相应数组创建缓冲区的方式类似：

[PRE29]

接下来，我们必须加载我们想要粘贴到四边形上的纹理。为此，我们导入在SpriteKit项目中使用的`Bg2.png`文件。在初始化阶段的末尾添加以下代码行。

首先，我们从本地包位置获取文件。通过传递文件名及其扩展名来获取文件的路径。然后，必须使用`NSData`方法检索数据，方法中传递路径，如图所示：

[PRE30]

接下来，我们从数据中获取图像并将其存储在类型为`UIImage`的常量中：

[PRE31]

然后，我们获取图像的宽度和高度，并指定图像的颜色空间。颜色空间决定了颜色如何被解释。除了RGBA值之外，还有其他存储颜色的方式；例如，我们可以提供CMYK格式的颜色。由于图像中的颜色值是以RGB指定的，因此我们必须在这里指定它。

宽度和高度是通过 `CGImage` 类获得的，因此在这一步我们将图像从 `UIImage` 类型转换为 `CGImage` 类型：

[PRE32]

为了存储图像的每个像素，我们需要指定整个图像数据的大小，因此为要写入的数据创建内存。每个像素占用4字节内存空间。因此，为了获取整个图像占用的内存，我们需要将宽度乘以高度，然后将这些值乘以四，这将给出位图图像的数据值。这个值存储在 `bitmapData` 常量中，如下所示：

[PRE33]

如前所述，我们将每像素字节数赋值给一个名为 `bytesPerPixel` 的常量。同时，我们创建一个 `bytesPerRow` 常量来获取每行的字节数：

[PRE34]

我们还需要指定像素中每个组件占用多少位。一个像素由 `R`、`G`、`B` 和 `A` 值组成。为了存储每个值，我们需要每个值8位。因此，为了存储每个RGBA值，我们需要总共32位。由于我们稍后需要使用每像素组件的位数，我们在这里将值存储在一个名为 `bitsPerComponent` 的常量中：

[PRE35]

然后，我们创建一个上下文，通过存储图像所需的所有数据来创建环境。我们必须向上下文提供 `bitmapData`、图像的宽度和高度、每组件的位数、每行的字节数，以及最后的 `colorSpace` 和 `bitmapInfo`。

在位图信息中，我们指定图像中是否存在alpha通道，alpha通道的位置，以及值是整数还是浮点值：

[PRE36]

接下来，我们获取图像的矩形尺寸。我们创建一个类型为 `CGRect` 的 `rect` 变量，并传入图像的起点、宽度和高度，如下面的代码行所示：

[PRE37]

接下来，我们获取图像并将RGBA数据通过上下文存储到 `bitmapData` 中。我们首先清除上下文，然后传入上下文、矩形和图像：

[PRE38]

为了将纹理加载到Metal中，我们需要一个纹理描述符，它存储所有相关信息。我们创建一个新的常量 `textureDescriptor` 和一个具有RGBA8均匀正常像素格式的纹理描述符，并传入宽度、高度以及如果想要图像进行**mipmap**处理的数据。

Mipmap，正如我们在SceneKit中看到的，将创建图像的较低分辨率版本，并在相机远离纹理时显示它，以减少系统的负载，如下所示：

[PRE39]

我们创建一个类型为 `MTLTexture` 的纹理，并传入纹理描述符：

[PRE40]

最后，我们使用`MTLTexture`类型的替换区域函数，用存储在`bitmapData`中的图像数据替换像素。我们传入的区域基本上是一个矩形，然后我们指定`mipmapLevel`，它保持在`0`并切割以确定我们将图像粘贴到四边形的哪个表面，因为我们只指定了一个四边形，其值为`0`。如果我们有更多的四边形，例如一个立方体，我们不得不为其他面指定除`0`之外的其他值。接下来，我们传入`bitmapData`，其中存储了图像的RGBA值；然后，我们传入`bytesPerRow`和`bytesPerImage`值，如下面的代码行所示：

[PRE41]

由于我们传递了一个纹理坐标缓冲区并且需要绘制一个纹理，我们必须对着色器文件进行一些修改。所以，转到着色器文件。

首先，修改`VertexInOut`结构体，如下所示：

[PRE42]

在高亮显示的代码中，当在着色器中指定用户定义的属性时使用了用户关键字：

[PRE43]

由于`textureCoordinate`缓冲区需要传递，以及位置和颜色信息，我们使用缓冲区索引`2`将其传递。同时，在返回`outVertex`时，我们将在函数中为该顶点ID分配纹理坐标。

接下来，我们还需要对`fragment`着色器函数进行修改，因为我们将要传递纹理到片段着色器中。所以，在四边形上绘制，如下面的代码行所示：

[PRE44]

除了我们上次传递的`stage_in`参数外，我们还将以`0`的索引值将纹理传递到片段着色器中。

在实际选择颜色的函数中，使用了一个采样器。采样器将决定如何从传入的纹理中选取颜色。采样器被设置为`constexpr`，即类似于`const`类型的常量表达式。

采样器根据使用`text2D.sample`函数提供的纹理坐标从2D纹理中选取颜色。结果颜色被存储并由片段着色器返回。

接下来，在`renderEncoder`中添加以下高亮显示的行：

[PRE45]

注意，尽管`vertexBuffer`和纹理具有相同的索引，但它们被处理方式不同，因为`vertexBuffer`是一种与纹理分开的独立缓冲区。由于`textureCoordinate`缓冲区是一种类型缓冲区，我们必须传入索引值`2`，因为我们已经为顶点和颜色缓冲区分别传入了`0`和`1`。

最后，修改管道描述符以使用新创建的片段着色器，如下所示：

[PRE46]

最后，还有一件事要做，那就是构建并运行它！

![纹理四边形项目](img/B04014_09_09.jpg)

通过这样，我们在本书中完成了整个循环。在2D SpriteKit游戏开发中，你首先学习的是如何将图像添加到场景中。我们输入了三行代码，图像就出现在屏幕上了。

实际上，我们必须做所有这些事情才能将一个简单的图像显示在屏幕上。但是，正如我之前所说的，这只是一个开始；我们还没有看到如何移动、旋转或缩放四边形。

我们还没有查看深度缓冲区，它决定了图像的某个部分是否需要根据当前对象前面的任何其他对象绘制到屏幕上。

此外，我们只看了二维的情况。我们还没有创建一个立方体，这需要额外的顶点。需要更深入地了解代数、三角学和矩阵。还需要对投影和模型空间、世界空间、视图空间和屏幕空间有更深入的理解，这些都是图形编程的不可或缺的部分。

不用说，这些主题远远超出了本书的范围。事实上，可以有一整本书专门讲述使用Metal的图形编程，而另一本书可以专门讲述使用Metal着色器语言创建酷炫效果。

对于学习Metal，我建议先学习OpenGLES，因为它已经存在了这么多年。一旦你对它有了很好的理解，你就可以将知识应用到Metal的实验中。

对于学习OpenGLES，我推荐《使用OpenGLES构建Android游戏》。尽管它教授的是Android开发，因为OpenGLES是跨平台的，你可以用同样的概念进行iOS游戏开发。视频链接可以在[https://www.packtpub.com/game-development/building-android-games-opengl-es-video](https://www.packtpub.com/game-development/building-android-games-opengl-es-video)找到。

# 摘要

在本章中，你看到了如何创建一个简单的三角形、四边形和一个纹理四边形，以及如何将这些显示到屏幕上。你只是触及了图形编程的表面，并学习了诸如顶点、缓冲区、纹理和着色器等术语的含义。

这仅仅是学习过程的开始；图形编程是一个庞大而深奥的主题，为此专门设计了课程，还有很多东西要学习。

希望这一章激发了你对该主题的兴趣；至少，我认为你至少会对那些坐几个小时开发框架和引擎以供你制作梦想中的游戏的人有所赞赏，而你对此一无所知。

说到梦想，在下一章中，你将看到如何最终将游戏发布到iOS App Store。
