<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Exposing the C API</h1></div></div></div><p>In this chapter, you will learn all about the <strong>C API</strong> (<strong>C application programming interface</strong>) and, through code, make use of it in your <a class="indexterm" id="id217"/>application. By having over 200 API calls to this light, small, and expanding API set, SQLite will surprise you with how it can achieve what you want from a mobile and flexible database.</p><p>You will look at some of the syntax and usage and see how to actually extend the functionality of SQLite by using its vast arsenal of API calls.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>SQLite C components' functionality</h1></div></div></div><p>SQLite has<a class="indexterm" id="id218"/> been written using C language, and its creator has enabled it to be exposed and has enhanced its functionality by having an API, the C API. In general, SQLite has many different API calls, for example, about 200 APIs for different functionalities. As a programmer, you may find it hard to accept, but the APIs are designed for specific tasks, for example, the <code class="literal">sqlite3_reset()</code> function clears the object connected with the SQLite prepared statement and resets it to its original state and value.</p><p>To start with, the two core objects are the database connection and the prepared statement objects. The order and the types of functions give you an idea of how to write an SQL transaction to connect to a database, create a table and an index, and populate it with an <code class="literal">insert</code> statement. These functions form the main elements of the SQL-C interface functions, allowing data to be connected and passed from code to SQLite.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec19"/>sqlite3_open()</h2></div></div></div><p>The<a class="indexterm" id="id219"/> <code class="literal">sqlite3_open(const char *filename, sqlite ** Db_name)</code> will<a class="indexterm" id="id220"/> open a connection to the SQLite database file at your chosen location and return the database connection object, which will be used by other SQLite components or functions.</p><p>The <code class="literal">sqlite3_open()</code> function is required to make a connection before any other operation can take place. It will enable the rest of the operations to follow.</p><p>If, in the <code class="literal">sqlite3_open</code> function, the filename does not contain a <code class="literal">NULL</code>, the function will use a value from the provided values, or if no database file already exists, SQLite will attempt to open a new database using the name. Once a database connection via the <code class="literal">sqlite_open()</code> function had been achieved, <a class="indexterm" id="id221"/>commands such as <code class="literal">sqlite_prepare()</code> can go forward. An example<a class="indexterm" id="id222"/> of <code class="literal">sqlite3_open()</code> is shown here:</p><div><img alt="sqlite3_open()" src="img/B04725_05_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec20"/>sqlite3_prepare()</h2></div></div></div><p>With a <a class="indexterm" id="id223"/>new database connection, we will get a pointer address that will <a class="indexterm" id="id224"/>serve as the input for the <code class="literal">sqlite_prepare()</code> command. The statements will compile the source SQL statements into the object code. The functionality of the <code class="literal">sqlite3_prepare()</code> function is to bind and set up the relevant parameters to link up your query strings as part of the data process. Here is a brief example outlining the process for <code class="literal">sqlite3_prepare()</code>:</p><div><img alt="sqlite3_prepare()" src="img/B04725_05_02.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec21"/>sqlite3_step()</h2></div></div></div><p>The<a class="indexterm" id="id225"/> <code class="literal">sqlite3_step()</code> statement will analyze, inspect, and evaluate<a class="indexterm" id="id226"/> the output object code from the previous the <code class="literal">sqlite3_prepare()</code> statement. It will execute a <code class="literal">prepare</code> statement and will return an SQLite status code. If there is data, then the <code class="literal">SQLITE_ROW</code> status code will be returned. When the statement has finished executing, the <code class="literal">SQLITE_DONE</code> status code will be returned. Any other returned value will be regarded as an error. <code class="literal">SQLite3_step()</code> must be reset for it to be used again.</p><p>This method is mainly used for the <code class="literal">SELECT</code> statement. Other statements such as <code class="literal">DELETE</code>, <code class="literal">UPDATE</code>, or <code class="literal">INSERT</code> will execute to completion from the first record to the last:</p><div><img alt="sqlite3_step()" src="img/B04725_05_03.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec22"/>sqlite3_column()</h2></div></div></div><p>As <a class="indexterm" id="id227"/>the <code class="literal">SQLITE3_prepare</code> statement is being evaluated, the <code class="literal">SQLITE3_column</code> statement <a class="indexterm" id="id228"/>displays a single column as part of the result set. <code class="literal">SQLITE3_column</code> performs a placeholder function within the <code class="literal">SQLITE</code> API and is the centerpoint for a variety of other functions, such as <code class="literal">SQLite_column_count()</code>.</p><p>See the following for more information:</p><div><img alt="sqlite3_column()" src="img/B04725_05_04.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec23"/>sqlite3_finalize()</h2></div></div></div><p>As the name <a class="indexterm" id="id229"/>suggests, this statement will finalize and seal all <a class="indexterm" id="id230"/>prepared statements. Once the <code class="literal">sqlite3_finalize</code> statement has been executed, any memory is deallocated and internal process resources are released. Once completed, the statement cannot be reused and is not valid internally. See the following command for more information:</p><div><img alt="sqlite3_finalize()" src="img/B04725_05_05.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec24"/>sqlite3_close()</h2></div></div></div><p>This is the last<a class="indexterm" id="id231"/> component to be <a class="indexterm" id="id232"/>executed, namely the <code class="literal">sqlite3_close</code> command, which will close the database using the pointer and reference from the database connection, and previously created prepared statements will have to be finished before the connection is closed.</p><p>As mentioned previously, in order to call or run SQL statements within SQLite or any other database, you must connect to the database and once you finish your work, you must disconnect.</p><p>The preceding <code class="literal">SQLite_open()</code> statement is a way of using the C API directly without any implementation of the Swift language. The following are two methods for using the open database statement, in C API and in Swift. There are two types of approach:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <strong>C API</strong> with the open database statement</li><li class="listitem" style="list-style-type: disc">Using Swift with the open database statement</li></ul></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec01"/>Using the C API with the open database statement</h3></div></div></div><p>Have <a class="indexterm" id="id233"/>a look at the<a class="indexterm" id="id234"/> following<a class="indexterm" id="id235"/> code:</p><div><pre class="programlisting">var db1 = SQLiteDatabase();
db1.open("/path/to/database1.sqlite");</pre></div><p>A variable of <code class="literal">db1</code> is defined to call the <code class="literal">SQLiteDatabase()</code> function. Then the <code class="literal">db1.open()</code> method is used with the data within the brackets to point to the <code class="literal">database1</code> database, as shown in the preceding code.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Using Swift with the open database statement</h3></div></div></div><p>An alternative way to open the database using Swift is as follows:</p><div><pre class="programlisting">let datadocuments = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String

let databasepath = documents.stringByAppendingPathComponent("tester.sqlite")

// open the database

var databasedb: DBPointer = nil

if sqlite3_open(path, &amp;databasedb) != SQLITE_OK
{
     println("error opening database")
}</pre></div><p>Remember that for Swift, you have to import the <code class="literal">sqlite3.h</code> file and add the <code class="literal">libsqlite3.0.dylib</code> SQLite library to your project.</p><p>To add this <a class="indexterm" id="id236"/>
<code class="literal">libsqlite3.0.dylib</code> to your project, follow<a class="indexterm" id="id237"/> these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the target and framework within the project editor.</li><li class="listitem">Click on <strong>Build Phases</strong> at the top of the editor and open the link with the libraries section.</li><li class="listitem">Click on <strong>+</strong> to add the framework or, in our case, the <code class="literal">libsqlite3.0.dylib</code> SQLite library.<div><img alt="Using Swift with the open database statement" src="img/B04725_05_06.jpg"/></div></li><li class="listitem">A <a class="indexterm" id="id238"/>search <code class="literal">NSSearchPAthForDirectoriesinDomains</code> is used to set up the <code class="literal">datadocuments</code> variable, and then the <code class="literal">databasepath</code> variable is set up as a place for the <code class="literal">sqlite</code> file.</li><li class="listitem">A variable of <code class="literal">databasedb</code> is set up and a check is performed to see if the <code class="literal">sqlite3_open()</code> function with the input parameters actually works to open the database, otherwise an error message is shown.</li></ol></div><p>The beauty of SQLite is its flexibility and the extensions of the product, which include extendable SQL features such as collating sequences, and SQL functions that enable your application to be different and unique. The range of change and ability to extend the app is growing.</p><p>The extension you build can be linked to your app and you can use of a function such as <code class="literal">SQLite_extension_init</code> as a pointer or address to ensure names don't conflict.</p><p>The SQLite <a class="indexterm" id="id239"/>extension is classed as a <strong>DLL</strong> (a <strong>dynamic link library</strong>—a collection of programs that are used when required by larger applications).</p><p>DLLs by<a class="indexterm" id="id240"/> definition require an entry or starting point to engage with a program. It is where processes attach themselves to the DLL <a class="indexterm" id="id241"/>and a join or connection is made to exchange information and use functionality. The entry point function is used to perform cleanup tasks or initialization when engaged. When a process uses the entry point function, it can be used for allocating memory or virtual address space.</p><p>SQLite can use load extensions, which are coded outside SQLite and tested and deployed as necessary. Once developed, these extensions can easily link up to SQLite. If there was some functionality SQLite did not have, a third party could develop it and make it available to potential customers or users in a particular industry, for example.</p><p>When creating an extension for SQLite, the extension differs for each operating system:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some<a class="indexterm" id="id242"/> Unix systems use the <code class="literal">.so</code> file extension</li><li class="listitem" style="list-style-type: disc">Windows systems use the <code class="literal">.dll</code> extension</li><li class="listitem" style="list-style-type: disc">OS X (Mac) systems use the <code class="literal">.Dylib</code> extension</li></ul></div><p>This shows the great flexibility of the software, which can cater to a variety of operating systems and, therefore, allow the SQLite database to be applied to different systems and technologies.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec25"/>load_extension()</h2></div></div></div><p>The <code class="literal">load_extension(X,Y)</code> function <a class="indexterm" id="id243"/>is another capable <a class="indexterm" id="id244"/>function that allows functions/extensions to be loaded. Its methods are similar to that of the <code class="literal">sqlite3_load_extension()</code> C interface. Both these methods use entry points, and a name is required as an identifier. Null pointers can be passed in for the input argument.</p><p>There are commands that change the database and don't return any results, such as the <code class="literal">Update</code> statement. The<a class="indexterm" id="id245"/> function that carries out this task is <code class="literal">sqlite3_exec()</code>. This method is faster and is not difficult to <a class="indexterm" id="id246"/>learn or execute.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec26"/>sqlite3_exec()</h2></div></div></div><p>The<a class="indexterm" id="id247"/> <code class="literal">sqlite3_exec()</code> process <a class="indexterm" id="id248"/>has a pointer to an open database, a single or a list of SQL statements using a pointer to the callback function as part of its functionality. It will use one or several SQL statements combined with a null-terminated string for processing. Each row of the query will have a pointer to a callback function. There will also be a pointer sent ahead as part of the first argument to a callback function. A pointer to an error string variable is included.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>sqlite3_config()</h2></div></div></div><p>The functionality of <code class="literal">sqlite3_config()</code> is<a class="indexterm" id="id249"/> useful for allowing changes<a class="indexterm" id="id250"/> to be made at a global level. The <code class="literal">sqlite3_config()</code> must be called before opening the database. The <code class="literal">sqlite3_config()</code> interface will allow SQLite's memory allocation to be adjusted, producing an error log for the whole process. It sets up and configures the <code class="literal">SQLite</code> library, controlling many aspects of memory allocation and related resources.</p><p>To extend SQLite, further functions and routines such as <code class="literal">sqlite3_create_collation()</code>, <code class="literal">sqlite3_create_function()</code>, <code class="literal">sqlite3_create_module()</code>, and <code class="literal">sqlite3_vfs_register()</code> are investigated and used as necessary to improve the product functionality. Maintenance of these systems will be limited to those who know and use the technology.</p><p>The following is an example of using some of the database functions using the <code class="literal">select</code>, <code class="literal">update</code>, <code class="literal">delete</code>, and <code class="literal">insert</code> commands with Apple's new language, Swift.</p><p>As mentioned previously, there are different SQLite wrappers out there, some specifically written for Swift (not many), but the most common one is <a class="indexterm" id="id251"/>
<strong>FMDB</strong>, which has been tested for different apps:</p><div><ol class="orderedlist arabic"><li class="listitem">In order to bring Objective-C into Swift, a "bridging header" is required, namely <code class="literal">sqlite3.h</code>. To use this header, use the following command:<div><pre class="programlisting">#import &lt;sqlite3.h&gt;</pre></div></li><li class="listitem">Add the <code class="literal">libsqlite3.0.dylib</code> SQLite library to your project, as discussed previously.</li><li class="listitem">Once the <code class="literal">libsqlite3.0.dylib</code> library has been added to the project, the next task is to create the database.</li><li class="listitem">Next, use the <code class="literal">sqlite3_exec</code> functionality <a class="indexterm" id="id252"/>to perform the <code class="literal">create table...</code> SQL statement, for example, as part of using Swift:<div><pre class="programlisting">if sqlite3_exec(databasedb, "create table if not exists test table (id integer primary key autoincrement, name2 text)", nil, nil, nil) != SQLITE_OK {
    let errmsg = String.fromCString(sqlite3_errmsg(db))

    println("error creating new table: \(errmsg)") }</pre></div></li><li class="listitem">The next statement to use <a class="indexterm" id="id253"/>is an <code class="literal">Insert</code> statement to enter data into the newly created <code class="literal">test</code> table. The following information will show how to prepare, bind, and step the SQL statement. The <code class="literal">sqlite3_prepare_v2</code> function will be used to prepare the SQL using a placeholder of <code class="literal">?</code> to bind the required value:<div><pre class="programlisting">var statement: DBPointer = nil
if sqlite3_prepare_v2(databasedb, "insert into test (name) values (?)", -1, &amp;statement, nil) != SQLITE_OK
{
    let errmsg = String.fromCString(sqlite3_errmsg(databasedb))
           println("error preparing insert: \(errmsg)")
} 

if sqlite3_bind_text(statement, 1, "data", -1, SQLITE_TRANSIENT) != SQLITE_OK
{
    let errmsg = String.fromCString(sqlite3_errmsg(databasedb))
    println("failure binding record data: \(errmsg)") }

if sqlite3_step(statement) != SQLITE_DONE
{
    let errmsg = String.fromCString(sqlite3_errmsg(databasedb))
    println("failure inserting record data: \(errmsg)") }</pre></div></li><li class="listitem">A constant, <code class="literal">SQLITE_TRANSIENT</code>, can be used as a part of the following process:<div><pre class="programlisting">let SQLITE_STATIC = sqlite3_destructor_type(DBPointer(bitPattern: 0))
let SQLITE_TRANSIENT = sqlite3_destructor_type(DBPointer(bitPattern: -1))</pre></div></li></ol></div><p>This is the<a class="indexterm" id="id254"/> standard way of using these variables. Sometimes<a class="indexterm" id="id255"/> these variables don't work if they have not been included as part of the <code class="literal">.h</code> file or as defined in the following section. They are not supported in Swift because of "unsafe pointer casting."</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>The prepare statement</h2></div></div></div><p>As part <a class="indexterm" id="id256"/>of <a class="indexterm" id="id257"/>the <code class="literal">prepare</code> statement, the functionality of <code class="literal">sqlite3_prepare_v2</code> is used with the SQL statement, using the question mark (<code class="literal">?</code>) as a placeholder to bind input values. This is shown in the following example:</p><div><pre class="programlisting">var statement: DBPointer = nil
if sqlite3_prepare_v2(databasedb, "insert into testtable (name) values (?)", -1, &amp;statement, nil) != SQLITE_OK
{
    let errmsg = String.fromCString(sqlite3_errmsg(db)) println("error preparing the insert: \(errmsg)")
}
if sqlite3_bind_text(statement, 1, "Bind1", -1, SQLITE_TRANSIENT) != SQLITE_OK
{
    let errmsg = String.fromCString(sqlite3_errmsg(db)) println("failure binding this statement: \(errmsg)")
}
if sqlite3_step(statement) != SQLITE_DONE
{
    let errmsg = String.fromCString(sqlite3_errmsg(db)) println("failure on inserting data : \(errmsg)") }</pre></div><p>The standard was of using the <code class="literal">SQLITE_STATIC</code> and <code class="literal">SQLITE_TRANSIENT</code> as setup is as follows:</p><div><pre class="programlisting">#define SQLITE_STATIC((sqlite3_destructor_type)0)
#define SQLITE_TRANSIENT((sqlite3_destructor_type)-1)4</pre></div><p>In Swift 2, the code could change, as shown in the following:</p><div><pre class="programlisting">"Internal let SQLITE_STATIC = unsafeBitCast(0, sqlite3_destructor_type.self) internal let SQLITE_TRANSIENT = unsafeBitCast(-1, sqlite3_destructor_type.self)"</pre></div><p>Next, let's <a class="indexterm" id="id258"/>perform <a class="indexterm" id="id259"/>an <code class="literal">insert</code> statement using a <code class="literal">NULL</code> value to prove that SQL does work:</p><div><pre class="programlisting">if sqlite3_reset(statement) != SQLITE_OK
{
    let errmsg = String.fromCString(sqlite3_errmsg(databasedb))

    println("error resetting prepared statement: \(errmsg)")
}

if sqlite3_bind_null(statement, 1) != SQLITE_OK
{
    let errmsg = String.fromCString(sqlite3_errmsg(databasedb))

    println("failure binding the null value: \(errmsg)")
}

if sqlite3_step(statement) != SQLITE_DONE
{
    let errmsg = String.fromCString(sqlite3_errmsg(databasedb))

    println("failure inserting null: \(errmsg)")
}</pre></div><p>As mentioned previously, SQLite can work by allowing each SQL statement to be prepared once, evaluated, executed, and then destroyed, but it also has the facility to prepare the same system and be evaluated several different times by using the routines like the <code class="literal">sqlite3_reset()</code> and <code class="literal">sqlite3_bind()</code> functions. SQLite is a good and functional database that would work for different applications without any adjustments.</p><p>The following code is then used to close the database after the work has been done:</p><div><pre class="programlisting">if sqlite3_close(databasedb) != SQLITE_OK
{
     println("error closing the database")
}databasedb = nil</pre></div><p>This is the advantage of the language having built-in SQL functionality.</p><p>The information in this chapter has focused on the functionality of the C API. Developers today will extend and use different types of functionalities, as required, for their apps, but embedding the use of Swift, Objective-C, Java, or other languages.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, you learned how to extend the C API and produce code, which can be used to build some interesting, exciting, new, and intelligent data-driven applications and promote the use of SQLite. The language used is Swift. In the next chapter, you will learn briefly how to use Swift with IOS and SQLite, and you will be shown how to install Xcode and work with Swift and an SQLite library.</p></div></body></html>