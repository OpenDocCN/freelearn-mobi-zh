- en: Chapter 11. Case Study – Developing an iOS Application with the FP and OOP Paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we covered a variety of concepts and techniques. We
    started with FP paradigms and explored related topics in detail. Also, in the
    previous chapter, we covered other paradigms such as OOP, FRP, and POP, and mixing
    them together. In this chapter, we will create a simple application using those
    paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Most of iOS applications need a backend to be able to provide advanced functionalities
    such as integration with other systems. In this chapter, we will create a simple
    backend with Swift that is going to be used as a Todo application rest API. Then,
    we will develop an iOS application that will leverage our backend and provide
    some essential functionality such as listing and updating Todo items coming from
    the backend. Also, iOS application will be able to create new Todo items. Our
    iOS application development will include FP, OOP, POP, and FRP paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirement specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift Package Manager
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vapor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Application development
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CocoaPods dependency management configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party libraries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend communication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON parsing and model mapping
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State management
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing items with a UITableView
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating and creating items
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering items
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents the requirements for our case study. Since the focus of
    this book is not requirement engineering, we will define very simple requirements.
    This section does not present best practices for requirements engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for the iOS application user are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Users should be able to list Todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should be able to see the details of each item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should be able to modify items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should be able to create a new item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should be able to filter items by their status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains the high-level design of the frontend and backend.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application design follows a slightly different version of the **Model-View-Controller**
    (**MVC**) pattern, with the addition of the `Actions` , `Store`, `State`, and
    `Communication` layers to simplify the controller layer of traditional iOS application
    MVC pattern. All application layers are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Plain old model structures. These models do not have any logic and only consist
    of properties. There are four types of models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TodoRequest**: This is a struct that is used in backend request calls and
    conforms to `RequestProtocol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Todo**: This is a struct that represents the Todo data, and uses the **Argo**
    and **Curry** libraries to decode the object from JSON'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TodoViewModel and TodosViewModel**: These structs represent data and are
    used in views and shown to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TodoLens**: These lenses modify the Todo model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the aforementioned models are immutable value types.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have two View subclasses: one to provide a custom `UITableViewCell` called
    `TodoTableViewCell` and a subclass of `UIView` named `FooterView`.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these Views are subclasses of iOS SDK-provided classes. Besides these
    classes, we will have our `UIViewController` scenes in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: ViewController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ViewController` is a subclass of `UIViewController` or `UITableViewController`,
    and it connects views to logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MasterViewController:** This is a subclass of `UITableViewController` to
    present Todo items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DetailsViewController:** This is a subclass of `UIViewController` to present
    details of each Todo item to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To develop iOS applications, we have to rely on iOS SDK-provided classes such
    as `UIViewController` and `UITableViewController`. The `ViewController` and `UIView`
    subclasses are the only classes that will be used in this case study.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In iOS application development, we need to handle states. We use the Delta and
    ReactiveCocoa libraries to manage our `Todo` App's state.
  prefs: []
  type: TYPE_NORMAL
- en: Delta takes an App that has custom state management spread throughout all the
    `ViewControllers` and simplifies it by providing a simple interface to change
    state and subscribe to its changes.
  prefs: []
  type: TYPE_NORMAL
- en: ReactiveCocoa is a FRP cocoa framework that provides APIs for composing and
    transforming streams of values over time.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a `State` struct that will provide the `observable` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `Store` struct will wrap the `State` struct and provide properties to observe
    its changes. `Store` conforms to the Delta library's `StoreType` protocol, which
    defines the storage of an observable state and dispatch methods to modify it.
    Also, `Store` uses ReactiveCocoa's `MutableProperty` value and allows observation
    of its changes in a thread-safe manner.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actions are structs that conform to the `ActionType` protocol from the Delta
    library. `ActionType` is used when we want to make modifications to the store's
    state. All changes to the store go through this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will develop the following actions in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClearCompletedTodosAction`: This is used to delete completed Todo items from
    the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateTodoAction`: This is used to create a new Todo item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteTodoAction`: This is used to delete a Todo item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetailsTodoAction`: This is used to present the details of an item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadTodosAction`: This is used to list all Todo items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetFilterAction`: This is used to filter Todo items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToggleCompletedAction`: This is used to mark a Todo item as completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateTodoAction`: This is used to update a Todo item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TodoManager` provides global functions to handle backend API calls and JSON
    payload mapping. `TodoManager` uses `WebServiceManager` for backend calls and
    the Argo library to map JSON payloads to the `Todo` model. Also, `TodoManager`
    will update the `State` in the `Store` through `Lenses` and `Action`.'
  prefs: []
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The communication layer is responsible for backend communication. It includes
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebServiceManager`: This provides a global function named `sendRequest` that
    is used by `TodoManager` to call the backend API. Also, it uses `configureHeaders` to
    perform a reflection on request to get its properties and respective values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Urls`: This enum provides a proper HTTP request method and a full URL address
    by pattern matching and extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Alamofire`: This is a library that is used by `WebServiceManager` for HTTP
    request handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Argo`: This library maps model objects from and to JSON functionally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application uses closures and `ReactiveCocoa` signals for communication between
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following third-party libraries/frameworks are used in our iOS application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alamofire**: This is a web service calling and management framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Argo**: This is a functional JSON parsing library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CocoaPods**: This is responsible for dependency management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delta**: This is the state management library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReactiveCocoa**: This is a **Functional Reactive Programming** (**FRP**)
    library to handle signals and streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick**: This is a behavior-driven development framework used for unit testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-cutting concerns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section explains cross-cutting concerns such as error management, exception
    handling, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Error management and exception handling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed in previous chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Crash reporting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will use **Crashlytics**, which is a part of `fabric.io` offering by Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: Analytics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will use `fabric.io` **Answers** to monitor application usage. There are
    other analytics services such as **Google Analytics**, **Flurry**, and Mixpanel
    that can be used for this case study. We are going to use Answers for the sake
    of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tools We will use Xcode to develop our application. AppCode by JetBrains is
    another IDE for iOS application development with better refactoring capabilities
    that can be used for this case study.
  prefs: []
  type: TYPE_NORMAL
- en: Backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various web framework and HTTP servers for Swift, which are works-in-progress.
    **Kitura**, **Perfect**, and Vapor are three of the most popular ones. None of
    them are designed and developed in FP style. We will use Vapor in our example
    to provide a backend that can be leveraged by our frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Vapor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vapor ([https://github.com/qutheory/vapor](https://github.com/qutheory/vapor))
    is a popular Laravel/Lumen-inspired web framework that is MIT-licensed. It is
    purely written in Swift and is modular.
  prefs: []
  type: TYPE_NORMAL
- en: Vapor provides CLI tools to simplify building and running Vapor applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`vapor new <project-name>` can be used to create a new project, `vapor build`
    can be used to build the project and download dependencies, `vapor xcode` can
    be used to create Xcode project, and `vapor run` can be used to run the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vapor uses **Swift Package Manager** (**SPM**) as the dependency manager and
    starting an application with Vapor is as easy as importing Vapor and adding the
    following lines to the `main` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Routing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Routing in Vapor is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Adding the preceding code to the main file will make our web application respond
    to all `GET` requests to `localhost:8080/welcome` with the string `Hello, World`.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is easy to respond with JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code responds to all `GET` requests to `localhost:8080/version`
    with the JSON dictionary `{"version": "0.1"}` and `Content-Type: application/json`.'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every route call gets passed a `request` object that can be used to grab query
    and path parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to access JSON, Query, and form-encoded data
    from the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we read the request data and return a string.
  prefs: []
  type: TYPE_NORMAL
- en: Vapor also provides the means for session management, database connection, and
    view responses with HTML or Stencil template-included HTML pages. There is an
    example Vapor project ([https://github.com/qutheory/vapor-example](https://github.com/qutheory/vapor-example))
    that can be used and modified for our purposes. We are not going to explore Vapor
    in depth since it is still in a work-in-progress.
  prefs: []
  type: TYPE_NORMAL
- en: SPM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SPM is an open source build and dependency management tool provided for Swift
    3.0\. It is integrated with the Swift build system to automate the process of
    downloading, compiling, and linking dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vapor uses SPM and to create a Vapor project we need to add the following dependency
    to the `Packages.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As stated in the *Vapor* section, we can use Vapor CLI tools to build and run
    the application with SPM.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to read more about Vapor and SPM since we do not cover most
    of the related topics in this book. In the following section, we will develop
    a very simple backend with Vapor.
  prefs: []
  type: TYPE_NORMAL
- en: Backend development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to develop a very simple backend for a Todo application.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating our model. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This class imports Vapor and includes some of the `Todo`-related properties
    as well as an `init` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to pass this model into JSON arrays and dictionaries, we need to
    extend a protocol called `JsonRepresentable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Then we want to store list of Todo items in memory. To be able to achieve this,
    we will create a new class called `TodoStore`. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of simplicity, we make this class a singleton that stores a list
    of Todo items. Also, we make the `init` method `private` to avoid non-shared instance
    initiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow instances of Todo to be passed into JSON arrays and dictionaries as
    if it were a native JSON type, we will need to extend our `TodoStore` by conforming
    to `JSONRepresentable` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As the names suggest, these methods will be used for adding and listing items.
    We will need a very simple find method, so let''s develop it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `index` and `map` higher-order functions to find the index and
    return the respective array element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will need to develop `update` and `delete` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can combine add and update as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our `TodoStore` is capable of all CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step will be developing routing, request, and response handling. For
    the sake of simplicity, we will modify `main.swift` in the Vapor example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to make our changes after the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Posting a new Todo item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step will be to develop a post method to create a Todo item as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is going to create a Todo item. First, we check if the
    API user is provided with all the necessary HTTP headers with a guard expression
    and then we use our `addItem()` method in the `TodoStore` class to add that specific
    item. In the preceding code example, we needed to convert `completed` from `Bool`
    to `String`, so we extended the `String` function as follows and we called `toBool()`
    on `completed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to build and run our backend app with the `vapor build` and `vapor
    run` directives in the terminal application. At this point, we should get the
    following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Posting a new Todo item](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we point to localhost 8080 in a web browser, we should see Vapor up and
    running. Also, we can use the **curl** tool to test our post method in the terminal
    by copying and pasting the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Posting a new Todo item](img/image_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the screenshot, we received a JSON response that includes
    our added Todo item.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a list of Todo items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our post call returns the list of items. Also, we can get items with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will build and run our application with Vapor CLI again and we can test
    this get request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Getting a specific Todo item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding call retrieves all the items. If we want to get a specific item,
    we can do that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check for the existence of headers and use the `listItems()` method
    in our `TodoStore` class to retrieve that specific item. We can test it in curl
    by executing the following commands in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Deleting an item and deleting all Todo items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next operation that we need to implement is deleting items from our `TodoStore`.
    Let''s implement the `delete` and `deleteAll` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the delete functionality, we can execute the following commands in
    the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the `deleteAll` functionality, we can execute the following commands
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Updating a Todo item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we want to be able to update an item in our Todo list to complete
    it or take some notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check for the headers first and, if they are present, we use the update
    method in `TodoStore` to update a specific item in our store. We can test it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should have a simple backend API to create, list, update,
    and delete todo items in memory. In the next section, we will develop an iOS application
    to leverage this API.
  prefs: []
  type: TYPE_NORMAL
- en: iOS application development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we looked into requirements, discussed a high-level design, and developed
    a simple backend API. Now, we are going to develop an iOS application that will
    leverage the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start our application development using CocoaPods ([https://cocoapods.org/](https://cocoapods.org/)).
    We can install it by executing the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a folder using **Finder** or simply execute the following
    command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a **Single View Application** project in Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration](img/image_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are going to name it `TodoApp` and provide an organization name and identifier.
    The programming language is going to be **Swift**, and **Devices** will be **Universal**.
    Now, we can close the project and go back to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, we will execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will create a file named `Podfile`. This is where we define our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uncomment the first and third line so it becomes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define dependencies for our target. We can go to [https://cocoapods.org/](https://cocoapods.org/)
    and search for any dependency, copy the definition, and paste it into our `Podfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can save and close our `Podfile` and move on to the terminal application.
    In the terminal application, we will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This directive will create a workspace, download all dependencies, and link
    them as frameworks into our project. Now, we can open `TodoApp.xcworkspace` with
    Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the workspace, we will see two projects: `TodoApp` and `Pods`. Pods will
    contain all the dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create a folder hierarchy to organize our workspace. In the workspace,
    right-click on a folder and select **Show In Finder**. Here, we will create the
    following folders and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Actions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Communication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controllers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Extensions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Managers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Models`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Views`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will add these folders to our project by right-clicking on the `TodoApp`
    folder and selecting **Add Files to "TodoApp"**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration](img/image_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we can move `ViewController` to `Controllers` and any images
    to the `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are done with our application, the folder and file hierarchy will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration](img/image_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since our backend does not comply with security policies enforced by Apple,
    we will need to set the `NSAllowsArbitraryLoads` key to `YES` under the `NSAppTransportSecurity`
    dictionary in our `.plist` file.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Obviously, we can use the `Todo` model we have used in our backend example,
    but we want to make our frontend application as functional as possible. There
    is a great functional JSON parsing library named Argo that we can leverage. Let''s
    define our `Todo` model with Argo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we import two libraries: Argo and Curry. Curry provides convenient
    currying functionalities. Although currying is going to be removed from Swift
    and returning closures will be the norm, it will be safe to use the Curry library.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `Todo` model becomes a `struct`, and then we extend our `struct` by conforming
    to a `protocol` named `Decodable`. To conform to this protocol, we need to implement
    the `decode` function. This function takes a `JSON` payload and returns a decoded
    `Todo` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the body of the function, we will use the currying and custom operators.
    According to the Argo documentation, currying allows us to partially apply the
    `init` function over the course of the decoding process. This basically means
    that we can build up the `init` function call bit by bit, adding one parameter
    at a time, if (and only if) Argo can successfully decode them. If any of the parameters
    do not meet our expectations, Argo will skip the `init` call and return a special
    failure state. Let''s check the syntax of Curry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `curry` function takes a function that has five parameters `A` to `E` and
    returns `F`, that is, `curry` returns *A -> B -> C -> D -> E -> F*.
  prefs: []
  type: TYPE_NORMAL
- en: This enables us to partially apply our `init` method.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will discuss the different custom infix operators now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<^>` to map a function over a value conditionally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<*>` to apply a function with context to a value with context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<|` to decode a value at the specific key into the requested type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<|?` to decode an optional value at the specific key into the requested type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<||` to decode an array of values at the specific key into the requested type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <^>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our first operator in the decoding process, `<^>`, is used to map our curried
    `init` method over a value. The definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: <*>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `<*>` operator is used to conditionally apply the other parameters to our
    curried init method. The definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <|
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `<|` operator is used to decode a value at the specified key path into
    the requested type. This operator uses a function named `flatReduce` that reduces
    and flattens the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: <|?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `<|?` operator is used to decode an optional value at the specified key
    path into the requested type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <||
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `<||` operator is used to decode an array of values at a specific key into
    the requested type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using Argo models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever we receive a JSON payload from the backend, we will be able to use
    the `decode` function to decode our `JSON` payload to our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can see that Argo is a great FP library that can be leveraged as an example
    to master lots of FP paradigms. Using Argo, Curry, and custom operators, we are
    able to parse and decode JSON payloads to our model objects declaratively. Also,
    our models become immutable value types that we can use in our applications without
    being concerned about mutability.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we defined an `enum` called `TodoFilter`. We will use this `enum` to filter
    items.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will have two `viewModel`, one for each `ViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We will use `TodosViewModel` to list `Todo` items in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We will use `TodoViewModel` to present each `Todo` item's details.
  prefs: []
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have a backend API that we can use to CRUD `Todo` items and we have
    models in our iOS application. Let's examine how we can communicate with our backend
    and populate our models with received payloads.
  prefs: []
  type: TYPE_NORMAL
- en: Request protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need to define a protocol for our request models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined `protocol` and we extended the protocol to be able to reflect
    the object and get properties and their values.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we added `subscript` to our protocol, which any `struct` that wants to
    conform to this protocol should implement.
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to a request protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s create a request model named `TodoRequest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, this `struct` conforms to `RequestProtocol`.
    You might wonder why we have done this. First of all, this is an example of POP and
    second we will use this request model in our post web service call.
  prefs: []
  type: TYPE_NORMAL
- en: WebServiceManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a file named `WebServiceManager` and add a function in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our `sendRequest` function takes two parameters. The first one is the HTTP request
    method and the second one is the type of `RequestProtocol`. Here, using the implemented
    protocol function called `getPropertyNames`, we prepare the header and send a
    request to our backend using `Alamofire`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have a working communication layer. At this point, we need to develop
    managers and `viewController` to handle the logic and show the results to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by testing our communication layer in our `MasterViewController`
    and will move the respective code to our `managers`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Todo item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a Todo item, we can call the `sendRequest` function in our `MasterViewController
    viewDidLoad()` method to be sure that it is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This should add a new `Todo` item to our backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `sendRequest` method is incomplete and it does not provide a call back
    to receive the data. Let''s improve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a closure as the function argument and called the closure in the body
    of the function. To test it, we will update our call in `MasterViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we pass a trailing closure in our call; once it is called, we receive
    the response or error. Importing and using Argo, we can map the payload to our
    model. We called this function only for testing and we need to move this call
    to the proper place. After all, none of our `MasterViewController` classes will
    be able to call this function directly and they have to go through other objects.
    Also, we will need to improve our `sendRequest` function to take the proper `url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define an `enum` and extend it. In our `httpMethodUrl` function, we
    perform pattern matching to return a tuple consisting of an HTTP request method
    and the full `url`. We need to change our `sendRequest` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function call should be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Listing Todo items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve all Todo items, unlike our post call, we do not need to pass any
    header parameters, just cookie information. So, we add the following `struct`
    to handle this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can retrieve the list of `Todo` items using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Although we added better error printing, we need to improve it further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extract the preceding function calls, create a Swift file named `TodoManager`,
    and put these functions in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will develop two other functions: one adds or updates a `Todo`
    item and the other only updates a specific `Todo` item. Deleting items will be
    easy to implement as well. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In these functions, there are concepts that we have not yet covered in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dispatch`: This function dispatches an action (here, `UpdateTodoAction`) by
    settings the state''s value to the result of calling its `reduce` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`todoSyncedLens`: This is a `Lens` to modify the synced property of the `todo`
    item. We will define these lenses in an upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateTodoAction`: This is a `struct` that conforms to `ActionType`, which
    is used when we want to make modifications to the `State` of the `Store`. All
    changes to the `Store` go through this type. We will define our actions in an
    upcoming section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State`: This is a `struct` that will be used to manage the `State`. We will
    define it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Store`: As the name suggests, this is where we store the `State`. We will
    define it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use lenses to modify our `Todo` item. Each of the following lenses
    will be used to modify a part of the `Todo` item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our application, we need to manage states to keep the state management code
    as declarative as possible. We will use a library named `Delta`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delta will be used along with ReactiveCocoa to manage states and state changes
    reactively. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we extend the ReactiveCocoa library's `MutableProperty`
    by conforming to `Delta.ObservablePropertyType`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ObservablePropertyType` protocol must be implemented by the `State` that
    is held by `Store`. To use a custom `State` type, this protocol must be implemented
    on that object.
  prefs: []
  type: TYPE_NORMAL
- en: '`MutableProperty` creates a mutable property of type value and allows observation
    of its changes in a thread-safe way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using extended `MutableProperty`, our `State` objects become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will store the state in our `Store` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`Store` conforms to the `StoreType` protocol declared in the `Delta` library.
    The `StoreType` protocol defines the storage of an observable state and dispatch
    methods to modify it.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create a `MutableProperty` as `state` and store it in `Store`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define properties to access and modify our state properly, so we
    extend our `Store` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In our store, we use ReactiveCocoa's `SignalProducer` to create observable signals.
    We will observe these signals in other objects and react to signal changes.
  prefs: []
  type: TYPE_NORMAL
- en: Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actions are structs that conform to the `ActionType` protocol from the `Delta`
    library. `ActionType` is used when we want to make modifications to the store''s
    state. All changes to the `Store` go through this type. Let''s examine one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In our manager, we had a call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `dispatch` method call on `store` with the `UpdateTodoAction` will call
    the `reduce` method of `UpdateTodoAction`. It will also make modifications on
    the state and return a new version of it. This is the only place where changes
    to `State` are permitted; therefore, any changes to state should go through an
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define other actions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user will be able to list `Todo` items from the backend, toggle to mark
    an item as complete, or swipe left to access functionalities such as **Details**
    and **Delete**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Views](img/image_11_006.jpg)![Views](img/image_11_007.jpg)![Views](img/image_11_008.jpg)![Views](img/image_11_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can design these screens in the storyboard. We will need to implement a
    custom `UITableViewCell` as shown here to be able to show the proper data on TableView:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The only interesting piece in this class is the `configure` method. It will
    be called in our `cellForRowAtIndexPath` method of `TableViewController` to create
    a `Signal` from the producer, then to add exactly one observer to the `Signal`,
    which will invoke the given callback when next events are received.
  prefs: []
  type: TYPE_NORMAL
- en: ViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will have two ViewController subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MasterViewController`: This will list the `Todo` items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DetailViewController`: This will present and modify the details of each item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MasterViewController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will present a list of items to the user in `MasterViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We have `viewModel`, which is a computed property. In `viewDidLoad`, we list
    the `Todo` items from our backend and we store them in `State` using `LoadTodosAction`.
    Then, we define observations to change our `viewModel` and to sync changed items
    with the backend.
  prefs: []
  type: TYPE_NORMAL
- en: IBActions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will need to define two `IBAction`, one to add a new item to the list and
    the other to filter the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the `addTapped` method, we use `createTodoAction` to add an item to the list
    with the `completed` and `synced` values as `false`. Therefore, `store.notSyncedWithBackend.startWithNext`
    in `viewDidLoad` will observe this item as not synced and will sync it with the
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: TableView Delegates and DataSource
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, we need to implement the `delegates` and `datasource` methods for
    `UITableViewController`. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use `DeleteTodoAction` to delete an item by swiping
    to the left and selecting **Delete**. We use `ToggleCompletedAction` to mark an
    item as completed when we tap on any item on the list, and we use `DetailsTodoAction`
    to navigate to the details page when we swipe to the left and select **Details**.
  prefs: []
  type: TYPE_NORMAL
- en: DetailsViewController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use `viewController` to present the details of a `Todo` item and modify
    it. We will have three `textField` and a switch. We will observe the changes in
    the UI and modify the `State` and backend. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In our `viewDidLoad` method, we look for the selected item in `MasterViewController`
    before navigating to `DetailsViewController`. We will also set the `UITextField`
    and `UISwitch` initial values. We will subscribe to changes in the UI, use lenses
    to update the `Todo` item, and change the state via `UpdateTodoAction`. Any item
    change will set synced as false. Since this property is observed in `MasterViewController`,
    any changes to the UI in `DetailsViewController` will be synced with the backend
    without any extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a backend with Swift Vapor library that handles
    the `Todo` items `POST`, `GET`, and `DELETE`. Then, we developed a frontend iOS
    application that leverages functional programming, reactive programming, and state
    management techniques declaratively. We started by developing our `Todo` model
    in a functional style, and then we developed `Store` and its extensions to handle
    `State` storage and `Action` to handle `State` changes. We defined and used `Lens`
    to modify our properties and a `WebServiceManager` with reflection techniques
    to request for backend resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this case study, we were able to use value types such as `struct` and `enum`
    and avoid classes. In fact, the only four classes in this case study are related
    to the iOS SDK (`UIViewController`, `UITableViewController`, `UITableViewCell`,
    and `UIView` subclasses). We were able to centralize all state mutations into
    `Store` only using `Action` to change the `State` in the `Store`. Although we
    did not develop any unit test cases, it is recommended that you explore functional
    programming unit testing libraries such as **Quick** to ensure the quality of
    code.
  prefs: []
  type: TYPE_NORMAL
