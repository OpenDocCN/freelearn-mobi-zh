["```swift\n{\n ...\n  \"issue_search_url\": \"https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}\",\n  \"issues_url\": \"https://api.github.com/issues\",\n  \"repository_url\": \"https://api.github.com/repos/{owner}/{repo}\",\"user_url\": \"https://api.github.com/users/{user}\"  \"user_repositories_url\": \"https://api.github.com/users/{user}/repos{?type,page,per_page,sort}\", }\n```", "```swift\n{\n  ...\n  \"login\": \"alblue\",\n  \"avatar_url\": \"https://avatars.githubusercontent.com/u/76791?v=2\",\n  \"repos_url\": \"https://api.github.com/users/alblue/repos\",\n  \"name\": \"Alex Blewitt\",\n  \"blog\": \"http://alblue.bandlem.com\",\n  \"location\": \"Milton Keynes, UK\",\n  ...\n}\n```", "```swift\n[{ \n  \"name\": \"com.packtpub.e4.swift.essentials\",\n  \"html_url\":\n    \"https://github.com/alblue/com.packtpub.swift.essentials\",\n  \"clone_url\":\n    \"https://github.com/alblue/com.packtpub.swift.essentials.git\",\n  \"description\": \"Swift Essentials\",\n},{\n  \"name\": \"com.packtpub.e4\",\n  \"html_url\":\n    \"https://github.com/alblue/com.packtpub.e4\",\n  \"clone_url\":\n    \"https://github.com/alblue/com.packtpub.e4.git\",\n  \"description\":\n    \"Eclipse Plugin Development by Example: Beginners Guide\",\n},{\n  \"name\": \"com.packtpub.e4.advanced\",\n  \"html_url\":\n    \"https://github.com/alblue/com.packtpub.e4.advanced\",\n  \"clone_url\":\n    \"https://github.com/alblue/com.packtpub.e4.advanced.git\",\n  \"description\":\n    \"Advanced Eclipse plug-in development\",\n}...]\n```", "```swift\nimport XCTest\nclass URITemplateTests: XCTestCase {\n  func testURITemplate() {\n    let template = \"http://example.com/{blah}/blah/{?blah}\"\n    let replacement = URITemplate.replace(\n     template,values: [\"blah\":\"foo\"])\n    XCTAssertEqual(\"http://example.com/foo/blah/\",\n     replacement,\"Template replacement\")\n  }\n}\n```", "```swift\nimport Foundation\nclass URITemplate {\n  class func replace(template:String, values:[String:String])\n   -> String {\n    var replacement = template\n    while true {\n      // replace until no more {…} are present\n    }\n    return replacement\n  }\n}\n```", "```swift\n// replace until no more {…} are present\nif let parameterRange = replacement.rangeOfString(\n  \"\\\\{[^}]*\\\\}\",\n  options: NSStringCompareOptions.RegularExpressionSearch) {\n  // perform a replacement of parameterRange\n} else {\n  break\n}\n```", "```swift\n// perform a replacement of parameterRange\nvar value:String\nlet parameter = replacement.substringWithRange(parameterRange)\nif parameter.hasPrefix(\"{?\") {\n  value = \"\"\n} else {\n  // substitute with real replacement\n}\nreplacement.replaceRange(parameterRange, with: value)\n```", "```swift\n// substitute with real replacement\nlet start = parameterRange.startIndex.successor()\nlet end = parameterRange.endIndex.predecessor()\nlet name = replacement.substringWithRange(\n Range<String.Index>(start:start,end:end))\nvalue = values[name] ?? \"\"\n```", "```swift\nimport Foundation\nclass Threads {\n  class func runOnBackgroundThread(fn:()->()) {\n    dispatch_async(dispatch_get_global_queue(\n     DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),fn)\n  }\n  class func runOnUIThread(fn:()->()) {\n    if NSMainThread.isMainThread() {\n      fn()\n    } else {\n      dispatch_async(dispatch_get_main_queue(), fn)\n    }\n  }\n}\n```", "```swift\nimport XCTest\nclass ThreadsTest: XCTestCase {\n  func testThreads() {\n    Threads.runOnBackgroundThread {\n      XCTAssertFalse(NSThread.isMainThread(), \n       \"Running on background thread\")\n      Threads.runOnUIThread {\n        XCTAssertTrue(NSThread.isMainThread(),\n         \"Running on UI thread\")\n      }\n    }\n  }\n}\n```", "```swift\nimport Foundation\nextension NSURL {\n  func withJSONDictionary(fn:[String:String] -> ()) {\n    let session = NSURLSession.sharedSession()\n    session.dataTaskWithURL(self) {\n      data,response,error -> () in\n      if let json = try? NSJSONSerialization.JSONObjectWithData(\n        data!, options: .AllowFragments) as? [String:AnyObject] {\n        fn(json!) // will give a compile time error\n      } else {\n        fn([String:String]())\n      }\n    }.resume()\n  }\n}\n```", "```swift\nfunc toStringString(dict:[String:AnyObject]) -> [String:String] {\n  var result:[String:String] = [:]\n  for (key,value) in dict {\n    if let valueString = value as? String {\n      result[key] = valueString\n    } else {\n      result[key] = \"\\(value)\"\n    }\n  }\n  return result\n}\n```", "```swift\nfn(toStringString(json!)) // fixes compile time error\n```", "```swift\nimport XCTest\nclass NSURLExtensionsTest: XCTestCase {\n  func testNSURLJSON() {\n    let json = \"{\\\"test\\\":\\\"value\\\"}\".\n     dataUsingEncoding(NSUTF8StringEncoding)!\n    let base64 = json.base64EncodedDataWithOptions(     .EncodingEndLineWithLineFeed)\n    let data = String(data: base64, \n     encoding: NSUTF8StringEncoding)!\n    let dataURL = NSURL(string:\"data:text/plain;base64,\\(data)\")!\n    dataURL.withJSONDictionary {\n      dict in\n      XCTAssertEqual(dict[\"test\"] ?? \"\", \"value\",\n       \"Value is as expected\")\n    }\n    sleep(1)\n  }\n}\n```", "```swift\nfunc withJSONArrayOfDictionary(fn:[[String:String]] -> ()) {\n  … \n  if let json = try? NSJSONSerialization.JSONObjectWithData(\n   data, options: .AllowFragments) as? [[String:AnyObject]] {\n    fn(json!.map(toStringString))\n  } else {\n    fn([[String:String]]())\n  }\n```", "```swift\nlet json = \"[{\\\"test\\\":\\\"value\\\"}]\".\n dataUsingEncoding(NSUTF8StringEncoding)!\n…\ndataURL.withJSONArrayOfDictionary {\n  dict in XCTAssertEqual(dict[0][\"test\"] ?? \"\", \"value\",\n \"Value is as expected\")\n}\n```", "```swift\nimport Foundation\nclass GitHubAPI {\n  let base:NSURL\n  let services:[String:String]\n  let cache = NSCache()\n  class func connect() -> GitHubAPI? {\n    return connect(\"https://api.github.com\")\n  }\n  class func connect(url:String) -> GitHubAPI? {\n    if let nsurl = NSURL(string:url) {\n      return connect(nsurl)\n    } else {\n      return nil\n    }\n  }\n  class func connect(url:NSURL) -> GitHubAPI? {\n    if let data = NSData(contentsOfURL:url) {\n      if let json = try? NSJSONSerialization.JSONObjectWithData(\n       data,options:.AllowFragments) as? [String:String] {\n        return GitHubAPI(url,json!)\n      } else {\n       return nil\n      }\n    } else {\n      return nil\n    }\n  }\n  init(_ base:NSURL, _ services:[String:String]) {\n    self.base = base\n    self.services = services\n  }\n}\n```", "```swift\nimport XCTest\nclass GitHubAPITests: XCTestCase{\n  func testApi() {\n    let bundle = NSBundle(forClass:GitHubAPITests.self)\n if let url = bundle.URLForResource(\"api/index\",\n withExtension:\"json\") {\n      if let api = GitHubAPI.connect(url) {\n        XCTAssertTrue(true,\"Created API \\(api)\")\n      } else {\n        XCTAssertFalse(true,\"Failed to parse \\(url)\")\n      }\n    } else {\n      XCTAssertFalse(true,\"Failed to find sample API\")\n    }\n  }\n}\n```", "```swift\nfunc getURLForUserRepos(user:String) -> NSURL {\n  let key = \"r:\\(user)\"\n  if let url = cache.objectForKey(key) as? NSURL {\n    return url\n  } else {\n    let userRepositoriesURL = services[\"user_repositories_url\"]!\n    let userRepositoryURL = URITemplate.replace(\n     userRepositoriesURL, values:[\"user\":user])\n    let url = NSURL(string:userRepositoryURL, relativeToURL:base)!\n    cache.setObject(url, forKey:key)\n    return url\n  }\n}\n```", "```swift\nfunc withUserRepos(user:String, fn:([[String:String]]) -> ()) {\n  let key = \"repos:\\(user)\"\n  if let repos = cache.objectForKey(key) as? [[String:String]] {\n    fn(repos)\n  } else {\n    let url = getURLForUserRepos(user)\n    url.withJSONArrayOfDictionary {\n      repos in\n      self.cache.setObject(repos,forKey:key)\n      fn(repos)\n    }\n  }\n}\n```", "```swift\napi.withUserRepos(\"alblue\") {\n  array in\n  XCTAssertEqual(24,array.count,\"Number of repos\")\n}\n```", "```swift\nclass AppDelegate {\n  var api:GitHubAPI!\n  var users:[String] = []\n  var repos:[String:[[String:String]]] = [:]\n  func application(application: UIApplication,\n   didFinishLaunchingWithOptions: [NSObject: AnyObject]?)\n   -> Bool {\n    api = GitHubAPI.connect()\n    users = [\"alblue\"]\n    return true\n  }\n}\n```", "```swift\nfunc loadRepoNamesFor(user:String, fn:([[String:String]])->()) {\n  repos[user] = []\n  api.withUserRepos(user) {\n    results in\n    self.repos[user] = results\n    fn(results)\n  }\n}\n```", "```swift\nclass MasterViewController:UITableViewController {\n  var app:AppDelegate!\n  override func viewDidLoad() {\n    app = UIApplication.sharedApplication().delegate\n     as? AppDelegate\n    …\n  }\n}\n```", "```swift\noverride func numberOfSectionsInTableView(tableView: UITableView)\n -> Int {\n  return app.users.count\n}\noverride func tableView(tableView: UITableView,\n titleForHeaderInSection section: Int) -> String? {\n  return app.users[section]\n}\n```", "```swift\noverride func tableView(tableView: UITableView,\n numberOfRowsInSection section: Int) -> Int {\n  let user = app.users[section]\n  if let repos = app.repos[user] {\n    return repos.count\n  } else {\n    app.loadRepoNamesFor(user) { _ in\n      Threads.runOnUIThread {\n        tableView.reloadSections(\n         NSIndexSet(index: section),\n         withRowAnimation: .Automatic)\n      }\n    }\n    return 0\n  }\n}\n```", "```swift\noverride func tableView(tableView: UITableView,\n cellForRowAtIndexPath indexPath: NSIndexPath)\n -> UITableViewCell {\n  let cell = tableView.dequeueReusableCellWithIdentifier(\n   \"Cell\", forIndexPath: indexPath)\n  let user = app.users[indexPath.section]\n  let repo = app.repos[user]![indexPath.row]\n  cell.textLabel!.text = repo[\"name\"] ?? \"\"\n  return cell\n}\n```", "```swift\nfunc addUser(user:String) {\n  users += [user]\n  users.sortInPlace({ $0 < $1 })\n}\n```", "```swift\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  let addButton = UIBarButtonItem(barButtonSystemItem: .Add,\n   target: self, action: \"insertNewObject:\")\n  self.navigationItem.rightBarButtonItem = addButton\n  …\n}\n```", "```swift\nfunc insertNewObject(sender: AnyObject) {\n  let alert = UIAlertController(\n   title: \"Add user\",\n   message: \"Please select a user to add\",\n   preferredStyle: .Alert)\n  alert.addAction(UIAlertAction(\n   title: \"Cancel\", style: .Cancel, handler: nil))\n  alert.addAction(UIAlertAction(\n   title: \"Add\", style: .Default) {\n    alertAction in\n    let username = alert.textFields![0].text\n    self.app.addUser(username!)\n    Threads.runOnUIThread {\n      self.tableView.reloadData()\n    }\n  })\n  alert.addTextFieldWithConfigurationHandler {\n    textField -> Void in\n    textField.placeholder = \"Username\";\n  }\n  presentViewController(alert, animated: true, completion: nil)\n}\n```", "```swift\n@IBOutlet weak var userLabel: UILabel?\n@IBOutlet weak var repoLabel: UILabel?\n@IBOutlet weak var issuesLabel: UILabel?\n@IBOutlet weak var watchersLabel: UILabel?\n```", "```swift\nvar user: String? { didSet { configureView() } }\nvar repo: String? { didSet { configureView() } }\nvar data:[String:String]? { didSet { configureView() } }\n```", "```swift\noverride func viewDidLoad() { configureView() }\n```", "```swift\nfunc configureView() {\n  if let label = userLabel { label.text = user }\n  if let label = repoLabel { label.text = repo }\n  if let label = issuesLabel {\n    label.text = self.data?[\"open_issues_count\"]\n  }\n  if let label = watchersLabel {\n    label.text = self.data?[\"watchers_count\"]\n  }\n}\n```", "```swift\nfunc splitViewController(\n splitViewController: UISplitViewController,\n collapseSecondaryViewController \n  secondaryViewController:UIViewController!,\n ontoPrimaryViewController\n  primaryViewController:UIViewController!) -> Bool {\n  return true\n}\n```", "```swift\noverride func prepareForSegue(segue: UIStoryboardSegue,\n sender: AnyObject?) {\n  if segue.identifier == \"showDetail\" {\n    if let indexPath = self.tableView.indexPathForSelectedRow {\n      // get the details controller\n      // set the details\n    }\n  }\n}\n```", "```swift\n// get the details controller\nlet controller = (segue.destinationViewController as!\n UINavigationController).topViewController\n as! DetailViewController\n// set the details\n```", "```swift\nlet user = app.users[indexPath.section]\nlet repo = app.repos[user]![indexPath.row]\ncontroller.repo = repo[\"name\"] ?? \"\"\ncontroller.user = user\ncontroller.data = repo\n```", "```swift\ncontroller.navigationItem.leftBarButtonItem =\n self.splitViewController?.displayModeButtonItem()\ncontroller.navigationItem.leftItemsSupplementBackButton = true\n```", "```swift\n{\n  … \n  \"avatar_url\": \"https://avatars.githubusercontent.com/u/76791?v=2\",\n  … \n}\n```", "```swift\nfunc getURLForUserInfo(user:String) -> NSURL {\n  let key = \"ui:\\(user)\"\n  if let url = cache.objectForKey(key) as? NSURL {\n    return url\n  } else {\n    let userURL = services[\"user_url\"]!\n    let userSpecificURL = URITemplate.replace(userURL,\n     values:[\"user\":user])\n    let url = NSURL(string:userSpecificURL, relativeToURL:base)!\n    cache.setObject(url,forKey:key)\n    return url\n  }\n}\n```", "```swift\n  \"user_url\": \"https://api.github.com/users/{user}\",\n```", "```swift\nimport UIKit\n...\nfunc withUserImage(user:String, fn:(UIImage -> ())) {\n  let key = \"image:\\(user)\"\n  if let image = cache.objectForKey(key) as? UIImage {\n    fn(image)\n  } else {\n    let url = getURLForUserInfo(user)\n    url.withJSONDictionary {\n      userInfo in\n      if let avatar_url = userInfo[\"avatar_url\"] {\n        if let avatarURL = NSURL(string:avatar_url,\n         relativeToURL:url) {\n          if let data = NSData(contentsOfURL:avatarURL) {\n            if let image = UIImage(data: data) {\n              self.cache.setObject(image,forKey:key)\n              fn(image)\n} } } } } } }\n```", "```swift\noverride func tableView(tableView: UITableView,\n viewForHeaderInSection section: Int) -> UIView? {\n  let cell = UITableViewHeaderFooterView()\n  let user = app.users[section]\n  cell.textLabel!.text = user\n  app.api.withUserImage(user) {\n    image in\n    let minSize = min(cell.frame.height, cell.frame.width)\n    let squareSize = CGSize(width:minSize, height:minSize)\n    let imageFrame = CGRect(origin:cell.frame.origin,\n     size:squareSize)\n    Threads.runOnUIThread {\n      let imageView = UIImageView(image:image)\n      imageView.frame = imageFrame\n      cell.addSubview(imageView)\n      cell.setNeedsLayout()\n      cell.setNeedsDisplay()\n    }\n  }\n  return cell\n}\n```"]