<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Swift and SwiftUI Recap</h1>
<p>Firstly, I would like to thank you for reading my book, be it bought or borrowed, or whether you’re having a sneak peek in the Amazon preview, I thank you.</p>
<p>This chapter will recap Swift and SwiftUI. We will first cover the coding standards used throughout the book for our upcoming projects and the history of Swift and SwiftUI. Then, we will take a look at the requirements for going through the projects in this book. Coding standards can be very polarizing for programmers, but they really shouldn’t be. If there are any you disagree with, feel free to tweet me at <code>@SonarSystems</code> and let me know why. But don’t let that detract from the book and what you can get from it.</p>
<p>Afterward, we will look at some specific SwiftUI code examples along with previews to close off the recap. We will look at how we can use views and controls; these are the visual building blocks of your application’s user interface. We will use them throughout the book to draw and organize our application’s content on screen. Next, we will look at layouts and presentations to learn how we can combine views in stacks, create groups and lists of views dynamically, and define view presentations and hierarchy. Hope you enjoy the chapter!</p>
<p>If you have any questions, feel free to join my Discord: <a href="https://discord.gg/7e78FxrgqH">https://discord.gg/7e78FxrgqH</a>.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What is Swift?</li>
<li>What is SwiftUI?</li>
<li>Understanding and implementing views</li>
<li>Understanding and implementing layouts</li>
</ul>
<p>By the end of this chapter, you will have learned the history of Swift and SwiftUI, and how to implement basic components from SwiftUI; this will serve as the foundation for the projects we will create in this book.</p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements and standards</h1>
<p>This book requires you to download Xcode version 14 or above from Apple’s App Store.</p>
<p>To install Xcode, just search for <code>Xcode</code> in the App Store and select and download the latest version. Open Xcode and follow any additional installation instructions. Once Xcode has opened and launched, you’re ready to go.</p>
<p>Version 14 of Xcode has the following features/requirements:</p>
<ul>
<li>Includes SDKs for iOS 16, iPadOS 16, macOS 12.3, tvOS 16, and watchOS 9.</li>
<li>Supports on-device debugging in iOS 11 or later, tvOS 11 or later, and watchOS 4 or later.</li>
<li>Requires a Mac running macOS Monterey 12.5 or later.</li>
</ul>
<p>Download the sample code from the following GitHub link:</p>
<p><a href="https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects">https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects</a></p>
<p>Here are the hardware requirements:</p>
<ul>
<li>You need an Intel or Apple Silicon Mac</li>
<li>4GB RAM or more</li>
</ul>
<p>Here are the software requirements:</p>
<ul>
<li>macOS 11.3 (Big Sur or later)</li>
<li>Xcode 14</li>
<li>iOS 16 for iPad/iPhone real device testing</li>
<li>watchOS 9.0 for Watch real device testing</li>
<li>tvOS 16.0 for Apple TV real device testing</li>
</ul>
<p>Here are some extra requirements:</p>
<ul>
<li>Intermediate knowledge of Swift</li>
<li>Intermediate knowledge of another object-oriented programming language such as C++ or Objective-C</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout"><a id="_idTextAnchor017"/>Though you can test the applications in the simulator that Xcode provides, it is highly recommended to test them on real devices.</p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Standards used</h1>
<p>In this section, we will look at the coding standards that are used throughout this book. It is important to have consistent standards and know what the standards are.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Why do we need coding standards?</h2>
<p>It is<a id="_idIndexMarker000"/> important to write good code and good code isn’t just code that runs well but code that is easily maintainable and readable. Good code is an art form.</p>
<p>In the following sections, we will go through a set of standards that are used in the Swift programming language and these will be used throughout this book. If you do not fully agree with the standards, that is fine, but I felt it important to list the standards used in case you come across something you have never seen before, such as Yoda conditions – do any of you use them? If so, tweet me at <code>@SonarSystems</code>.<a id="_idTextAnchor020"/></p>
<h3>Indentation</h3>
<p>You should always indent<a id="_idIndexMarker001"/> your code to be aligned with other code in the same<a id="_idIndexMarker002"/> hierarchy level. Use real tabs instead of spaces for indenting code. You can see this in the following code snippet:</p>
<pre class="source-code">
if ( 10 == counter ){
    print( "Counter is 10" )
    print( "Well done" )
}
else
{ print( "Wrong" )<a id="_idTextAnchor021"/> }</pre>
<p>This is <a id="_idIndexMarker003"/>helpful because you can easily see where in the hierarchy the <a id="_idIndexMarker004"/>code belongs. Xcode provides a handy little shortcut for indenting code; simply press <em class="italic">^ + I</em> on the keyboard.</p>
<h3>Brace style</h3>
<p>You <a id="_idIndexMarker005"/>should always use Allman braces (named after <em class="italic">Eric Allman</em>) when writing<a id="_idIndexMarker006"/> code for structures, even if it is only one line (one line doesn’t require braces in many languages, such as C++, but they should be used for ease of readability). If you only have one line of code in the structure, put the braces and code on one line. I prefer not to put the opening brace on the structure’s first line. The only situation in which I would put the braces on the same line would be if there was no code in the structure yet; then, put the opening and closing brace on the same line with a space.</p>
<p>The following code snippet shows the preferred brace style:</p>
<pre class="source-code">
if ( 10 == counter ){
    print( "Counter is 10" )
    print( "Well done" )
}
else
{ print( "Wron<a id="_idTextAnchor022"/>g" ) }</pre>
<p>This is helpful because it helps maintain the code and helps with readability when trying to figure out where the structure starts and ends. This is especially useful when going through loads of files really fast and trying to figure out pro<a id="_idTextAnchor023"/>blems.</p>
<h3>Space<a id="_idTextAnchor024"/> usage</h3>
<p>The use of<a id="_idIndexMarker007"/> spaces and lines varies depending on what you are using in your code. Remove <a id="_idIndexMarker008"/>any trailing whitespace (whitespace at the end of the line). You can see this in the following code snippet:</p>
<pre class="source-code">
print( "Well<a id="_idTextAnchor025"/> done" )</pre> <p>Some editors automatically remove trailing whitespace, but some don’t. This can cause merge conflicts. You should coordinate with the people you’re working with (colleagues and the open source crowd) and what strategy everybody is using and make sure you all use the same s<a id="_idTextAnchor026"/>trategy.</p>
<h3>Comma and col<a id="_idTextAnchor027"/>on usage</h3>
<p>When<a id="_idIndexMarker009"/> using commas/colons, put a<a id="_idIndexMarker010"/> single space after the comma/colon. You<a id="_idIndexMarker011"/> can see this in the following example:</p>
<pre class="source-code">
func Greet( person: String, alreadyGreeted: Bool <a id="_idTextAnchor028"/>) -&gt; String</pre> <p>This makes it easi<a id="_idTextAnchor029"/>er to read.</p>
<h3>Spaces in <a id="_idTextAnchor030"/>parenthesis</h3>
<p>Put a single <a id="_idIndexMarker012"/>space on either side of both the opening and closing <a id="_idIndexMarker013"/>parentheses for <code>if</code>, <code>else</code>, <code>else if</code>, <code>for</code>, <code>while</code>, and other control structures (some languages may have other control structures, so just apply these standards to those structures). You can see this in the following code snippet:</p>
<pre class="source-code">
if ( 10<a id="_idTextAnchor031"/> == counter )</pre> <p>These spaces make it easier to understand, especially<a id="_idTextAnchor032"/> at a glance.</p>
<h3>Un<a id="_idTextAnchor033"/>ary operators</h3>
<p>When using <a id="_idIndexMarker014"/>unary operators<a id="_idIndexMarker015"/> such as <code>++</code> and <code>–</code> in a statement, put a single space after them. You can see this in the following snippet:</p>
<pre class="source-code">
for ( i = <a id="_idTextAnchor034"/>0; i &lt; 5; i++ )</pre> <p>The spaces keep it <a id="_idIndexMarker016"/>consistent with <a id="_idIndexMarker017"/>the rest of the code and make it easie<a id="_idTextAnchor035"/>r to glance over.</p>
<h3>Parentheses spa<a id="_idTextAnchor036"/>ces for functions</h3>
<p>When <a id="_idIndexMarker018"/>defining a function, put a single space on the inside of the opening <a id="_idIndexMarker019"/>and closing parentheses. You can see this in the following snippet:</p>
<pre class="source-code">
func G<a id="_idTextAnchor037"/>etString( id: Int )</pre> <p>The spaces keep it consisten<a id="_idTextAnchor038"/>t and easy to read.</p>
<h3>Funct<a id="_idTextAnchor039"/>ion calling spacing</h3>
<p>Calling a<a id="_idIndexMarker020"/> function also follows the exact same rules as defining a function. You<a id="_idIndexMarker021"/> can see this in the following code snippet:</p>
<pre class="source-code">
Adder<a id="_idTextAnchor040"/>( num1: 10, num2: 5 )</pre> <p>It’s easier to read this way, and ae<a id="_idTextAnchor041"/>sthetically pleasing.</p>
<h3>S<a id="_idTextAnchor042"/>quare bracket spacing</h3>
<p>When using <a id="_idIndexMarker022"/>square brackets, do not use any spaces on the inside of the<a id="_idIndexMarker023"/> opening and closing brackets. You can see this in the following code snippet:</p>
<pre class="source-code">
let vectors : [[Int]] =<a id="_idTextAnchor043"/> [[1, 2, 3], [4, 5, 6]]</pre> <p>Although this is different from parentheses, it looks better this way. Line lengths should generally be no longer than 80 characters, but if it helps with the readability, then <a id="_idTextAnchor044"/>exceptions c<a id="_idTextAnchor045"/>an be made.</p>
<h3>Typecasting</h3>
<p>When <a id="_idIndexMarker024"/>typecasting, always enclose the type in parentheses and not the <a id="_idIndexMarker025"/>variable, and use a single space inside the parentheses but not outside the closing parenthesis. You can see this in the follo<a id="_idTextAnchor046"/>wing snippet:</p>
<pre class="source-code">
( Int )age</pre> <p>This way, it’s easier to<a id="_idIndexMarker026"/> read and aesthetically pleasing. It also makes figuring<a id="_idIndexMarker027"/> out the association between variables an<a id="_idTextAnchor047"/>d casts easier when nested.</p>
<h3>Naming conventions</h3>
<p>This<a id="_idIndexMarker028"/> section will cover the naming conventions used throughout this <a id="_idIndexMarker029"/>book. Always use meaningful but not long names. Let the code be self-documenting as much as possible but <code>scoreForThePlayerForLevel1</code>; instead, use something such as <code>scorePlayerLevel1</code>).</p>
<ul>
<li><code>EpicFunction</code></li>
<li><code>epicVariable</code></li>
<li><strong class="bold">Constants</strong> – ALL LETTERS UPPERCASE</li>
</ul>
<p>All variables belonging to an object such as a class should start with an underscore – for example, <code>_localVariable.</code></p>
<p>This is helpful because it keeps the code consistent, which improves efficiency, readability, and maintenance. It helps others understand your cod<a id="_idTextAnchor048"/>e better. It also looks nice.</p>
<h3>Yoda conditions</h3>
<p>When<a id="_idIndexMarker030"/> comparing variables and values, always compare the value to the <a id="_idIndexMarker031"/>variable and not the variable to the value. You can see this in the following code block:</p>
<pre class="source-code">
if ( 10 == counter )</pre> <p>This is helpful because it prevents you from accidentally assigning a value to the variable instead of comparing it and thus results in a true value and makes t<a id="_idTextAnchor049"/>he if statement equate to true.</p>
<h3>Comments</h3>
<p>This<a id="_idIndexMarker032"/> is an area that most people hate, and a lot of people miss out or <a id="_idIndexMarker033"/>leave until the end and then come to the realization that it’s a lot of effort at that stage, so I would recommend commenting in the code as you go along.</p>
<p>When commenting in code, use <code>//</code> for single-line comments and <code>/*  */</code> for multiline comments (the way your comment may vary based upon the programming language you are using) and all letters should be lowercase. You can see this in the following example:</p>
<pre class="source-code">
/*    This checks if the counter is 10
    If successful then inform user
*/
if ( 10 == counter )
{
    print( "Counter is 10" )
    // Print congratulation m<a id="_idTextAnchor050"/>essage
    print( "Well done" )
}</pre>
<p>This is useful <a id="_idIndexMarker034"/>when trying to understand what your code does, especially if it is complex and/or you are reading it after a prolonged period of time. It is also useful when other people/programmers are trying to understand your code, as you may code <a id="_idIndexMarker035"/>differently to other people and comments can be crucial to helpin<a id="_idTextAnchor051"/>g them understand what is going on.</p>
<h3>No magic numbers</h3>
<p>A magic number<a id="_idIndexMarker036"/> is a number that looks like it is randomly placed in the code and doesn’t have any <a id="_idIndexMarker037"/>context or obvious meaning. This is what we would call an anti-pattern since reading and understanding code becomes very difficult to maintain. It is important that the code is intentional and that, just at a quick glance, you are able to understand it; this is fundamental to code quality.</p>
<p>Use constants and variables. <code>MAX_COUNT</code> is used instead of an arbitrary number such as 10. You can see this in<a id="_idIndexMarker038"/> the following code snippet:</p>
<pre class="source-code">
if ( MAX_COUNT == counter ){
    print( "Counter is 10" )
    print( "Well done" )
}</pre>
<p>This makes the code base easier to manage and understand.</p>
<p>In this section, we looked at the coding standards I use. I felt it very important to explain them not necessarily to persuade you to use the ones that I opt for, but so you have a reference point if you see anything in the book that seems different from your own normal standards. Above all, else be consistent with your standards and consistent with any teammates that are collaborating with you. This is the most important thing; the specific standards used are secondary, but the consistency is primary.</p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor052"/>What is Swift?</h1>
<p>In this section, we will cover what Swift is, its history, and how it works on a macro level. If you are an expert and just want to read about SwiftUI, feel free to skip this section.</p>
<p>Swift is a<a id="_idIndexMarker039"/> programming language created by Apple and the open source community. It is a general-purpose, compiled, and multi-paradigm programming language. It was released in 2014 as a replacement for Apple’s previous language, Objective-C. Due to the fact that Objective-C had remained virtually the same since the early 1980s, it was missing many features that modern languages have. Hence, the creation of Swift began; it has taken the Apple developer ecosystem by storm and is a hugely popular programming language. It is demanded by companies all over the world with excellent remuneration offered to those that know how to leverage its immense features. According to the PYPL index seen in the following figure, Swift is in the top 10 most popular languages, making it a must-have in any programmer’s arsenal:</p>
<div><div><img alt="Figure 1.1 – Popularity of Programming Language index (Source: https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg)" src="img/Figure_1.01_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Popularity of Programming Language index (Source: <a href="https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg">https://www.stackscale.com/wp-content/uploads/2022/09/PYPL-index-popular-programming-languages-2022.jpg</a>)</p>
<p>Swift has been used to create many apps, including but not limited to the following:</p>
<ul>
<li>LinkedIn</li>
<li>Firefox</li>
<li>WordPress</li>
<li>Wikipedia</li>
<li>Lyft</li>
</ul>
<p>Apple’s Cocoa and Cocoa<a id="_idIndexMarker040"/> Touch frameworks work with Swift out of the box. Furthermore, it works flawlessly with Apple’s previous programming language Objective-C, which has been used by developers for decades. This makes it one of the most modern but accessible languages around. Gone are the days when you would need to wait for frameworks to be released/updated for your chosen language; instead, thousands of projects already exist in Objective-C to use in the meantime.</p>
<p>Swift was built <a id="_idIndexMarker041"/>using the <strong class="bold">Low-Level Virtual Machine</strong> (<strong class="bold">LLVM</strong>) compiler framework, which is open source, is <a id="_idIndexMarker042"/>bundled with Xcode (since version 6), and was also released in 2014. It uses the Objective-C runtime library on Apple devices, thus allowing code written in C, Objective-C, C++, and Swift to work together in a single application. The following figure explains the relationship between programming languages such as Swift, LLVM, and the different architectures from a macro level:</p>
<div><div><img alt="Figure 1.2 – LLVM and language relationship (Source: https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg) " src="img/Figure_1.02_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – LLVM and language relationship</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">(Source: <a href="https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg">https://miro.medium.com/max/1024/1*VWogVHhCagxopvAKVFjBeA.jpeg</a>)</p>
<p>LLVM uses Clang on the frontend, which is a compiler for programming languages such as C, C++, CUDA, or swiftc for Swift. This then turns the code into a format that LLVM uses to convert into the machine code, which is then run/executed on the hardware.</p>
<p>For more information on <a id="_idIndexMarker043"/>LLVM, feel free to use the following links:</p>
<ul>
<li><a href="https://llvm.org/">https://llvm.org/</a></li>
<li><a href="https://en.wikipedia.org/wiki/LLVM">https://en.wikipedia.org/wiki/LLVM</a></li>
<li><a href="https://github.com/llvm/llvm-project">https://github.com/llvm/llvm-project</a></li>
<li><a href="https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&amp;ab_channel=Fireship">https://www.youtube.com/watch?v=BT2Cv-Tjq7Q&amp;ab_channel=Fireship</a></li>
<li><a href="https://www.youtube.com/watch?v=IR_L1xf4PrU&amp;ab_channel=tanmaybakshi">https://www.youtube.com/watch?v=IR_L1xf4PrU&amp;ab_channel=tanmaybakshi</a></li>
<li><a href="https://www.youtube.com/watch?v=ZQds2aGHwDA&amp;ab_channel=LexFridman">https://www.youtube.com/watch?v=ZQds2aGHwDA&amp;ab_channel=LexFridman</a></li>
<li><a href="https://www.youtube.com/watch?v=yCd3CzGSte8&amp;ab_channel=LexFridman">https://www.youtube.com/watch?v=yCd3CzGSte8&amp;ab_channel=LexFridman</a></li>
</ul>
<p>To understand the<a id="_idIndexMarker044"/> features available to you as a developer in Swift from a macro perspective, take a look at the following diagram:</p>
<div><div><img alt="Figure 1.3 – Swift language reference" src="img/Figure_1.03_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Swift language reference</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">(Source: <a href="https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg">https://gogeometry.com/software/swift/swift-language-reference-mind-map.jpg</a>)</p>
<p>The preceding diagram is a mind map showing all the high-level features provided by Swift and their su<a id="_idTextAnchor053"/>bfeatures and how they all link together.</p>
<p>In this section, we covered what Sw<a id="_idTextAnchor054"/>ift is, how it works, and its popularity.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor055"/>What is SwiftUI?</h1>
<p>In this section, we will cover what <a id="_idIndexMarker045"/>SwiftUI is and the features provided that we will leverage throughout this book to create our projects. If you feel comfortable with SwiftUI and just want to see projects, then feel free to skip the remainder of this chapter.</p>
<p>SwiftUI is a user interface framework built on top of the Swift programming language. It provides many components for creating your app’s user interface; the following is a macro list of these components:</p>
<ul>
<li>Views and controls</li>
<li>Shapes</li>
<li>Layout containers</li>
<li>Collection containers</li>
<li>Presentation containers</li>
</ul>
<p>In addition to the components in the preceding list, SwiftUI provides us with event handlers, allowing our apps to react to taps, gestures, and all other types of input they may receive from the user. The framework provides tools to manage the flow of data from the models to the views and controls that the end user interacts with.</p>
<p>Now we will look at the different core features of Swift, including examples that you can take a<a id="_idTextAnchor056"/>way, modify, and use in your own projects.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor057"/>Views and Controls</h2>
<p>Views<a id="_idIndexMarker046"/> and controls<a id="_idIndexMarker047"/> are the foundational blocks of your application’s UI. Using views, we can build the UI you want for your app. Its complexity can be whatever you desire, simple or immensely complex – it’s totally up to you – and we will see this in more detail in the upcoming sections.</p>
<p>Views can be any of the following:</p>
<ul>
<li>Text</li>
<li>Images</li>
<li>Shapes</li>
<li>Custom drawings</li>
<li>A combination of all of these</li>
</ul>
<p>Controls <a id="_idIndexMarker048"/>enable user interaction with APIs that adapt <a id="_idTextAnchor058"/>to the platform and context they are used in.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor059"/>Shapes</h2>
<p>Shapes<a id="_idIndexMarker049"/> in SwiftUI are 2D objects such as circles and rectangles. Custom paths can also be leveraged to set the parameters of your own shape/structure; we will see shapes in more detail in the coming sections.</p>
<p>Shapes provide features to add styling, including but not limited to the following:</p>
<ul>
<li>Environment-aware color</li>
<li>Rich gradients<a id="_idTextAnchor060"/></li>
<li>Material effects in the <a id="_idTextAnchor061"/>foreground</li>
<li>Background</li>
<li>Outlines for your shapes</li>
</ul>
<h2 id="_idParaDest-24"><a id="_idTextAnchor062"/>Layout Containers</h2>
<p>Layouts have the job<a id="_idIndexMarker050"/> of organizing the elements of your app’s UI. Stacks and grids are used to update and modify the positions of the child views that are within them in response to changes in content or interface dimensions. Layouts can be nested within one another; this can be done to as many levels as desired, thus allowing you to create complex layouts. Custom layouts can also be designed for further flexibility; we will take a lo<a id="_idTextAnchor063"/>ok at layout containers in more depth later on.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor064"/>Collection Containers</h2>
<p>Collections<a id="_idIndexMarker051"/> can be used to assemble dynamic views with complex functionality. For example, you can create a List view that allows you to scroll through a large set of data. The list automatically provides basic functionality, but in addition to this, you can add other functionality with minimal configuration, such as swiping, double tapping, and pull-to-refresh.</p>
<p>If only a simple grid or stack configuration is required, use a Layout container instead; we will lo<a id="_idTextAnchor065"/>ok at code examples to further illustrate these.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor066"/>Presentation Containers</h2>
<p>Presentation containers<a id="_idIndexMarker052"/> are used to provide structure to your app’s UI. This provides users with easier navigation for jumping around the app. This is extremely useful as the complexity of it increases and it contains more views. For example, you can enable navigating backward and forward through a set of views using a <code>NavigationStack</code>, and choosing whic<a id="_idTextAnchor067"/>h view to display from a tab bar using a <code>TabView</code>.</p>
<p>In this section, we covered the different features provided by SwiftUI on a macro level; we also disc<a id="_idTextAnchor068"/>ussed what sub-features they have and their uses.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor069"/>Understanding and implementing views</h1>
<p>In this section, we will look at views and how we can implement them in SwiftUI. W<a id="_idTextAnchor070"/>e will also take a look at combining these views.</p>
<p>Views are the<a id="_idIndexMarker053"/> fundamental building blocks of an application’s user interface. A view object renders content within its rectangle boun<a id="_idTextAnchor071"/>ds and handles any interactions with that content.</p>
<p>In the following sections, we will show the source code and examples for each type of view. If you would like further information, visit Apple’s documentation at <a href="https://developer.apple.com/documentation/uikit/views_and_controls">https://developer.apple.com/documentation/uikit/views_and_controls</a>.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor073"/>What are text views?</h2>
<p>It is very <a id="_idIndexMarker054"/>common to need to display text in our app, and we do this by using a text view, which <a id="_idIndexMarker055"/>draws a string. By default, it has a font assigned to it that is best for the platform it is being displayed on; however, you c<a id="_idTextAnchor074"/>an change the font using the <code>font(_:)</code> view modifier.</p>
<p>The following snippet shows the code used to implement a text view:</p>
<pre class="source-code">
var body: some View{
    VStack
    {
        Text( "Hello World" )
    }
    .padding( )
}</pre>
<p>The text view was inserted into a <code>VStack</code> for padding purposes, but this is not a requirement.</p>
<p>The preceding <a id="_idIndexMarker056"/>code shows how to simply display a string using the Text view by passing a string of what you need to display.</p>
<p>The foll<a id="_idTextAnchor075"/>owing figure shows the <a id="_idIndexMarker057"/>output of<a id="_idTextAnchor076"/> the preceding code:</p>
<div><div><img alt="Figure 1.4 – Text view preview" src="img/Figure_1.04_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Text view preview</p>
<p>The next sect<a id="_idTextAnchor077"/>ion will cover image views and how to implement them.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor078"/>What are Image views?</h2>
<p>Image views can be used to render<a id="_idIndexMarker058"/> images inside your SwiftUI layouts. Images are an excellent <a id="_idIndexMarker059"/>way of providing more context and improving the overall user experience. Image views can load images from your bundle, from system icons, from a <code>UIImage</code>, and more, but loading from your bundle <a id="_idTextAnchor079"/>and system icons will be the most commonly used method.</p>
<p>The following snippet shows the code used to implement an image view:</p>
<pre class="source-code">
var body: some View{
    VStack
    {
        Image( systemName: "cloud.heavyrain.fill" )
    }
    .padding( )
}</pre>
<p>In the preceding code, we implement an Image View with a system icon but you can easily specify your own image file. We will do this later in this chapter.</p>
<p>In this example, a system icon was used but the <a id="_idTextAnchor080"/>process is similar for using your bundle and a <code>UIImage</code>.</p>
<p>The fo<a id="_idTextAnchor081"/>llowing figure shows the output of the preceding code:</p>
<div><div><img alt="Figure 1.5 – Image view preview" src="img/Figure_1.05_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Image view preview</p>
<p>The next section will cover the different<a id="_idTextAnchor082"/> shape views available to us and the code to use them.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor083"/>What are shape views?</h2>
<p>SwiftUI provides us with five <a id="_idIndexMarker060"/>primitive shapes that are commonly used. These shapes are <a id="_idIndexMarker061"/>rectangles, rounded rectangles, circles, ellipses, and capsules. The last three are very subtly different in how they behave based on what sizes you provide.</p>
<p>The following code shows how you can simply implement any of the following shapes:</p>
<ul>
<li><code>Rectangle</code></li>
<li><code>Rou<a id="_idTextAnchor084"/>ndedRectangle</code></li>
<li><code>Capsul<a id="_idTextAnchor085"/>e</code></li>
<li><code><a id="_idTextAnchor086"/></code><code>Ellipse</code></li>
<li><code>Cir<a id="_idTextAnchor087"/>cle</code></li>
</ul>
<p>He<a id="_idTextAnchor088"/>re’s the snippet:</p>
<pre class="source-code">
var<a id="_idTextAnchor089"/> body: some View{
    VStac<a id="_idTextAnchor090"/>k
    {
        Rectangle( )
            .fill<a id="_idTextAnchor091"/>( .white <a id="_idTextAnchor092"/>)
            .frame( width: 128, height: 128 )
        <a id="_idTextAnchor093"/>RoundedRectangle( cornerRad<a id="_idTextAnchor094"/>ius: 30, style: .continuous )
            .fil<a id="_idTextAnchor095"/>l( .blue <a id="_idTextAnchor096"/>)
            .fram<a id="_idTextAnchor097"/>e( width: 128, height: 128<a id="_idTextAnchor098"/> )
        Capsule( )
            .f<a id="_idTextAnchor099"/>ill( .red<a id="_idTextAnchor100"/> )
            .fra<a id="_idTextAnchor101"/>me( width: 128, height: 50 )
<a id="_idTextAnchor102"/>
        Ellipse( )
            .fill<a id="_idTextAnchor103"/>( .orange<a id="_idTextAnchor104"/> )
            .fr<a id="_idTextAnchor105"/>ame( width: 128, height: 50 )<a id="_idTextAnchor106"/>
        Circle( )
            .fill<a id="_idTextAnchor107"/>( .yel<a id="_idTextAnchor108"/>low )
          <a id="_idTextAnchor109"/>  .frame( width: 128, height: 50 )
    }
    .padding( )
}</pre>
<p>The shapes were inserted into a <code>VStack</code> to arrange vertically and have padding around them.</p>
<p>The preceding code shows how to implement the diffe<a id="_idTextAnchor110"/>rent shape views and the parameters needed for each one.</p>
<p>The following <a id="_idIndexMarker062"/>figure shows<a id="_idIndexMarker063"/> the<a id="_idTextAnchor111"/> output of the preceding code:</p>
<div><div><img alt="Figure 1.6 – Shape views" src="img/Figure_1.06_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Shape views</p>
<p>In the next section, we will take a look at how we can use the views <a id="_idTextAnchor112"/>we have covered to combine and create more complex views.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor113"/>What are custom and combination views?</h2>
<p>For all frontend developers, one of the most crucial aspects of the development process is the implementation of the UI. We can create<a id="_idIndexMarker064"/> a simple UI with a <a id="_idIndexMarker065"/>combination of pre-made in-built views that we have leveraged thus far, but this is sometimes not enough; there are often cases when developers need to draw custom views programmatically to meet UI requirements, and if we are not able to draw those, it<a id="_idIndexMarker066"/> creates a problem. We are able to leverage the power of SwiftUI to<a id="_idIndexMarker067"/> create custom views, which are effectively a combination of the other views we learned about previously.</p>
<p>The following code shows us an implementation of multiple views to create our own custom view that displays a mini profile:</p>
<pre class="source-code">
import SwiftUIstruct Employee
{
    var name: String
    var jobTitle: String
    var emailAddress: String
    var profilePicture: String
}
struct ProfilePicture: View
{
    var imageName: String
    var body: some View
    {
        Image( imageName )
            .resizable( )
            .frame( width: 100, height: 100 )
            .clipShape( Circle( ) )
    }
}
struct EmailAddress: View
{
    var address: String
    var body: some View
    {
        HStack
        {
            Image( systemName: "envelope" )
            Text( address )
        }
    }
}
struct EmployeeDetails: View
{
    var employee: Employee
    var body: some View
    {
        VStack( alignment: .leading )
        {
            Text( employee.name )
                .font( .largeTitle )
                .foregroundColor( .primary )
            Text( employee.jobTitle )
                .foregroundColor( .secondary )
            EmailAddress( address: employee.emailAddress )
        }
    }
}
struct EmployeeView: View
{
    var employee: Employee
    var body: some View
    {
        HStack
        {
            ProfilePicture( imageName: employee.profilePicture )
            EmployeeDetails( employee: employee )
        }
    }
}
struct ContentView: View
{
    let employee = Employee( name: "Frahaan Hussain", jobTitle: "CEO &amp; Founder", emailAddress: "frahaan@hussain.com", profilePicture: "FrahaanHussainIMG" )
    var body: some View
    {
        EmployeeView( employee: employee )
    }
}
struct ContentView_Previews: PreviewProvider
{
    static var previews: some View
    {
        ContentView( )
    }
}</pre>
<p>The preceding code shows how we can combine views to create custom views and how we can combine <a id="_idIndexMarker068"/>custom views to create<a id="_idTextAnchor114"/> more complex views. This also makes the mini<a id="_idIndexMarker069"/> views reusable.<a id="_idTextAnchor115"/></p>
<p>The following figure shows the output of the preceding code:</p>
<div><div><img alt="Figure 1.7 – Custom view (mini profile)" src="img/Figure_1.07_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Custom view (mini profile)</p>
<p>In this section, we looked at combining the views from the previous sections to make <a id="_idTextAnchor116"/>reusable and combinable objects and create more complex views.</p>
<p>In the next section, we will t<a id="_idTextAnchor117"/>ake a look at layouts to help organize the content in our app.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor118"/>Understanding and implementing layouts</h1>
<p>This section will cover how we can arrange our views using layouts for a more dynamic user experience.</p>
<p>SwiftUI layouts allow us as developers to arrange views in your app’s interface using the layout tools provided. Layouts <a id="_idIndexMarker070"/>tell SwiftUI how to place a set of views, and how much space it needs to do so to provide the desired layout.</p>
<p>Layouts can be but are not limited to any of the following:</p>
<ul>
<li>Lazy stacks</li>
<li>Spacers:<ul><li><code>ScrollViewReader</code></li></ul></li>
<li>Grids:<ul><li><code>PinnedScrollableViews</code></li></ul></li>
</ul>
<p>In the following sections, we will show you the source code and examples for each type of layout.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you would like further information, visit Apple’s documentation: <a href="https://developer.apple.com/documentation/uikit/view_layout">https://developer.apple.com/documentation/uikit/view_layout</a>.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor119"/>What are lazy stacks?</h2>
<p>Lazy stacks are<a id="_idIndexMarker071"/> views that arrange their children in a line that expands vertically, creating items only as needed.</p>
<p>SwiftUI provides two different types of lazy stacks, <code>LazyVStack</code> and <code>LazyHStack</code>. By default, <code>VStack</code> and <code>HStack</code> load all the content upfront, which will be slow if you use them inside a scroll view, as these views can contain a lot of content. If you want to load content in a lazy fashion, so it is only loaded when it appears in the view, and not when the view is generally visible but the content is not, you should use <code>LazyVStack</code> and <code>LazyHStack</code> as appropriate.</p>
<p>The word lazy, as explained by Apple, refers to the stack view not creating items until they are needed. What this means to you is that the performance of these stack views is already optimized by default.</p>
<p><code>LazyVStack</code> and <code>LazyHStack</code> are only available in iOS 14.0+, iPadOS 14.0+, macOS 11.0+, Mac Catalyst 14.0+, tvOS 14.0+, and watchOS 7.0+. More information can be found at the following links:</p>
<ul>
<li><code>LazyVStack</code> – <a href="https://developer.apple.com/documentation/swiftui/lazyvstack">https://developer.apple.com/documentation/swiftui/lazyvstack</a></li>
<li><code>LazyHStack</code> – <a href="https://developer.apple.com/documentation/swiftui/lazyhstack">https://developer.apple.com/documentation/swiftui/lazyhstack</a></li>
</ul>
<p>The following code shows how we can use a <code>LazyVStack</code> to organize views vertically while also being efficient with large sums of data:</p>
<pre class="source-code">
import SwiftUIstruct ContentView: View
{
    var body: some View
    {
        ScrollView
        {
            LazyVStack
            {
                ForEach( 1...1000, id: \.self )
                {
                    value in
                    Text( "Line \( value )" )
                }
            }
        }
        .frame( height: 256 )
    }
}
struct ContentView_Previews: PreviewProvider
{
    static var previews: some View
    {
        ContentView( )
    }
}</pre>
<p>The preceding code implements a <code>LazyVStack</code> with <code>1000</code> text views. The text views are added using a loop to make it easier and more efficient.</p>
<p>The following figure <a id="_idIndexMarker072"/>shows the output of the preceding code:</p>
<div><div><img alt="Figure 1.8 – Lazy stacks" src="img/Figure_1.08_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Lazy stacks</p>
<p>In the next section, we w<a id="_idTextAnchor120"/>ill take a look at spacers, which help us space out our content.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor121"/>What are spacers?</h2>
<p>A spacer <a id="_idIndexMarker073"/>creates a view that is adaptive with no content that expands as much as it can. For example, when placed within an <code>HStack</code>, a spacer expands horizontally as is allowed by the stack, moving views out of the way, within the size limits of<a id="_idTextAnchor122"/> the stack.</p>
<p>In <a id="_idTextAnchor123"/>t<a id="_idTextAnchor124"/>he following code, we imp<a id="_idTextAnchor125"/>le<a id="_idTextAnchor126"/>ment text and spacers:</p>
<pre class="source-code">
i<a id="_idTextAnchor127"/>mport <a id="_idTextAnchor128"/>SwiftUIstruct ContentVie<a id="_idTextAnchor129"/>w: View
{<a id="_idTextAnchor130"/>
    var body: some View
    {
        Text( "L<a id="_idTextAnchor131"/>abel 1" )
        Space<a id="_idTextAnchor132"/>r(<a id="_idTextAnchor133"/> <a id="_idTextAnchor134"/>).frame( height: 64 )
        Text( <a id="_idTextAnchor135"/>"L<a id="_idTextAnchor136"/>abel 2" )
    }
}
struct ContentVi<a id="_idTextAnchor137"/>ew_Pre<a id="_idTextAnchor138"/>views: PreviewProvider
<a id="_idTextAnchor139"/>{
    <a id="_idTextAnchor140"/>static var previews: some View
    {
        ContentView( )
    }
}</pre>
<p>The preceding code <a id="_idIndexMarker074"/>used a spacer with a height of <code>64</code> to separate the two text vi<a id="_idTextAnchor141"/>ews.</p>
<p>The following figure shows the output of the preceding code:</p>
<div><div><img alt="Figure 1.9 – Spacer preview" src="img/Figure_1.09_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Spacer preview</p>
<p>In the next section, we will lo<a id="_idTextAnchor142"/>ok at <code>ScrollViewReader</code>, which enables us to move to any location.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor143"/>What are ScrollView and ScrollViewReader?</h2>
<p><code>ScrollView</code> allows<a id="_idIndexMarker075"/> users to view content within a scrollable region. The user can perform platform-specific scroll gestures to adjust the visible portion of the content. <code>ScrollView</code> can scroll both horizontally and vertically but does not support zooming. If you want to programmatically move <code>ScrollView</code> to a specific location, you should add a <code>ScrollViewReader</code> inside <a id="_idIndexMarker076"/>it. This provides a method called <code>scrollTo()</code>, which moves to any<a id="_idTextAnchor144"/> view inside the parent <code>ScrollView</code>, simply by providing its anchor.</p>
<p>All of this can be achieved with a few simple lines of code. You can see this code as follows:</p>
<pre class="source-code">
import SwiftUIstruct ContentView: View
{
    var body: some View
    {
        let colors: [Color] = [.red, .green, .blue, .white, .yellow]
        ScrollView
        {
            ScrollViewReader
            {
                value in
                Button( "Go to Number 45" )
                {
                    value.scrollTo( 45 )
                }
                .padding( )
                ForEach( 0..&lt;1000 )
                {
                    i in
                    Text( "Example \( i )" )
                        .font( .title )
                        .frame( width: 256, height: 256 )
                        .background( colors[i % colors.count] )
                        .id( i )
                }
            }
        }
        .frame( height: 512 )
    }
}
struct ContentView_Previews: PreviewProvider
{
    static var previews: some View
    {
        ContentView( )
    }
}</pre>
<p>The preceding<a id="_idIndexMarker077"/> code implemented <code>ScrollViewReader</code> inside <code>ScrollView</code>. Inside that, we <a id="_idIndexMarker078"/>added a button to scroll to the text view, which has an <code>id</code> va<a id="_idTextAnchor145"/>lue of <code>45</code>. We used a loop to display <code>1000</code> text views with unique IDs.</p>
<p>The following figure shows the out<a id="_idTextAnchor146"/>put of the preceding code:</p>
<div><div><img alt="Figure 1.10 – ScrollViewReader preview" src="img/Figure_1.10_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – ScrollViewReader preview</p>
<p>In the next section, we will look at gr<a id="_idTextAnchor147"/>ids, which allow us to organize our content in a table-like fashion.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor148"/>What are grids?</h2>
<p>When SwiftUI was first <a id="_idIndexMarker079"/>released, it didn’t come with a collection view built in. Developers were left with one of two options – either to build their own or use a third-party solution. In WWDC 2020, Apple introduced new features for the SwiftUI framework. One of them was to address the need for grid views. SwiftUI now provides two new components, <code>LazyVGrid</code> and <code>LazyHGrid</code>. One is for vertical grids and the other is for horizontal grids<a id="_idTextAnchor149"/>.</p>
<p>The following<a id="_idTextAnchor150"/> <a id="_idTextAnchor151"/>code shows how we can imp<a id="_idTextAnchor152"/>le<a id="_idTextAnchor153"/>ment a grid with two ro<a id="_idTextAnchor154"/>ws:</p>
<pre class="source-code">
i<a id="_idTextAnchor155"/>mport SwiftUI<a id="_idTextAnchor156"/>struct<a id="_idTextAnchor157"/> ContentView: View
{
    let items<a id="_idTextAnchor158"/> = 1...50
    let rows =
    [
        <a id="_idTextAnchor159"/>GridItem( .fixed( 32 ) )<a id="_idTextAnchor160"/>,
    <a id="_idTextAnchor161"/>    GridItem( .fixed( 32 ) )
    ]<a id="_idTextAnchor162"/>
    <a id="_idTextAnchor163"/>var body: some View
    {
        ScrollView( .horizonta<a id="_idTextAnchor164"/>l )
        {
<a id="_idTextAnchor165"/>            LazyHGrid( rows: rows, alignment:<a id="_idTextAnchor166"/> .center )
            {
                ForEa<a id="_idTextAnchor167"/>ch( items, id: \.self )
                {
                    it<a id="_idTextAnchor168"/>em in
                    Image(systemName: "<a id="_idTextAnchor169"/>\( item ).circle.f<a id="_idTextAnchor170"/>ill" )
                        .font( .largeTitl<a id="_idTextAnchor171"/>e )
      <a id="_idTextAnchor172"/>      <a id="_idTextAnchor173"/>  <a id="_idTextAnchor174"/>  }
            }
            .frame( height: <a id="_idTextAnchor175"/>12<a id="_idTextAnchor176"/>8 )
        }
    }
}
struct Conte<a id="_idTextAnchor177"/>ntView<a id="_idTextAnchor178"/>_Previews: PreviewProvi<a id="_idTextAnchor179"/>der
{
<a id="_idTextAnchor180"/>    static var previews: some View
    {
        ContentView( )
    }
}</pre>
<p>In the preceding code snippet, we implement a grid of images set over two rows using a loop. <code>GridItem</code> components were used; Apple says these are descriptions of rows or columns in a lazy grid. What does this actually mean? Well, it’s essentially a method for specifying how many columns/rows we want, thus setting the layout pattern. <code>LazyGrid</code> uses this layout <a id="_idIndexMarker080"/>pattern when iterating through the items that are displayed and positioning them accordingly. If you are coming from a web backgro<a id="_idTextAnchor181"/>und, you can think of it like the grid systems in responsive websites.</p>
<p>The following figure<a id="_idTextAnchor182"/> shows the output of the preceding code:</p>
<div><div><img alt="Figure 1.11 – Grid preview" src="img/Figure_1.11_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Grid preview</p>
<p>The next section will cover <code>PinnedScrollableViews</code>, which<a id="_idTextAnchor183"/> allow certain views to stick on the page as others scroll past them.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor184"/>What is PinnedScrollableView?</h2>
<p>SwiftUI can provide<a id="_idIndexMarker081"/> a <code>PinnedScrollableView</code> inside a <code>ScrollView</code>. Pinned vie<a id="_idTextAnchor185"/>ws are sticky views and can be applied to either a header or a footer.</p>
<p>The following code shows how we ca<a id="_idTextAnchor186"/>n pin a view to<a id="_idTextAnchor187"/> <a id="_idTextAnchor188"/>provide context to o<a id="_idTextAnchor189"/>th<a id="_idTextAnchor190"/>er views as they scroll <a id="_idTextAnchor191"/>past i<a id="_idTextAnchor192"/>t:</p>
<pre class="source-code">
import Swift<a id="_idTextAnchor193"/>UIstruct<a id="_idTextAnchor194"/> MyCell: View
{
    var b<a id="_idTextAnchor195"/>ody: some View
    {
        VStack<a id="_idTextAnchor196"/>
        {
            Rectangle( )
              <a id="_idTextAnchor197"/>  .fill( Color.red <a id="_idTextAnchor198"/>)
            <a id="_idTextAnchor199"/>    .frame( width: 128, height: 128 <a id="_idTextAnchor200"/>)
            HStack
            {
                Text( "Line text" )
                <a id="_idTextAnchor201"/>    .foregroun<a id="_idTextAnchor202"/>dColor( .yellow )
                    .font(<a id="_idTextAnchor203"/> .headline )
            }
            Text<a id="_idTextAnchor204"/>( "PinnedScrollableViews" )
          <a id="_idTextAnchor205"/>      .for<a id="_idTextAnchor206"/>egroun<a id="_idTextAnchor207"/>dC<a id="_idTextAnchor208"/>o<a id="_idTextAnchor209"/>lor( .green )
                .font( .subheadline )
        }
    }
}<a id="_idTextAnchor210"/>
struct ContentView: View
{
    var stickyHeaderView: some View
  <a id="_idTextAnchor211"/>  {
        RoundedRectangle( co<a id="_idTextAnchor212"/>rnerRadius: 25.0, style: .continuous )
            .fill( Color.gray )
    <a id="_idTextAnchor213"/>        .frame( maxWid<a id="_idTextAnchor214"/>th: .infinity )
            .frame<a id="_idTextAnchor215"/>( height: 64 )
            .overlay(
                Text( "Section" )
                    .f<a id="_idTextAnchor216"/>oregroundColor<a id="_idTextAnchor217"/>( Colo<a id="_idTextAnchor218"/>r.white )
              <a id="_idTextAnchor219"/>      <a id="_idTextAnchor220"/>.font( .largeTitle )
  <a id="_idTextAnchor221"/>          <a id="_idTextAnchor222"/>)
    }
    var body: s<a id="_idTextAnchor223"/>ome View
    {<a id="_idTextAnchor224"/>
        NavigationView
        {
            ScrollView
            {
                LazyVStack( ali<a id="_idTextAnchor225"/>gnment: .center, s<a id="_idTextAnchor226"/>pacing: 50, pinnedViews: [.sectionHeaders], conten<a id="_idTextAnchor227"/>t:
                {
                    ForEach( 0...5<a id="_idTextAnchor228"/>0, id: \.self )
                    {
                      <a id="_idTextAnchor229"/>  count in
                        Section( header: stickyHeader<a id="_idTextAnchor230"/>View )
                        {
                            MyCell(<a id="_idTextAnchor231"/> )
                        }
    <a id="_idTextAnchor232"/>                }
                } )
            }
        }
    }
}
struct Cont<a id="_idTextAnchor233"/>entVie<a id="_idTextAnchor234"/>w_Previews: PreviewProv<a id="_idTextAnchor235"/>ider
{<a id="_idTextAnchor236"/>
    static var previews: some View
    {
        ContentView( )
    }
}</pre>
<p>In the preceding code snippet, we<a id="_idIndexMarker082"/> implemented a sticky view, which acted as the section header as the other views dynamically moved past it, but the sticky view moved off the screen when another section was reached, and it had its own sti<a id="_idTextAnchor237"/>cky view.</p>
<p>The following figure shows the output of the preceding code:</p>
<div><div><img alt="Figure 1.12 – PinnedScrollableViews preview" src="img/Figure_1.12_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – PinnedScrollableViews preview</p>
<p>In this section, we covered the different layouts we have access to. These allow us to organize the data in a more pleasing fashion. In the next section, we will look at the different device previews for the projects that we will create throughout this book.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor238"/>Device Previews</h1>
<p>One of the many hurdles we will<a id="_idIndexMarker083"/> overcome is the differences between the four main Apple product categories. These categories are as follows:</p>
<ul>
<li>Mac – iMac, Mac Pro, MacBook, anything that runs macOS, even Hackintosh</li>
<li>iPad – Mini, regular, Air, Pro, all of them</li>
<li>iPhone – Mini, Pro, Pro Max, all iPhones</li>
<li>Apple Watch – small, big, old, or new</li>
</ul>
<p>The obvious thing you <a id="_idIndexMarker084"/>will notice is that they get smaller and smaller. They naturally have different purposes; an Apple Watch won’t replace a Mac and vice versa. That is why the next eight chapters are grouped into pairs, one for each product category. We will uncover the design decisions and restrictions we have when creating our a<a id="_idTextAnchor239"/>pplications. Let’s take a look at <a id="_idTextAnchor240"/>the settings in each product categor<a id="_idTextAnchor241"/>y:</p>
<p><strong class="bold">Mac</strong></p>
<div><div><img alt="Figure 1.13 – Mac settings" src="img/Figure_1.13_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Mac settings</p>
<p><strong class="bold">iPad</strong><strong class="bold"><a id="_idTextAnchor242"/></strong></p>
<div><div><img alt="Figure 1.14 – iPad settings" src="img/Figure_1.14_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – iPad settings</p>
<p><strong class="bold">iPhone</strong></p>
<div><div><img alt="Figure 1.15 – iPhone settings" src="img/Figure_1.15_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – iPhone settings</p>
<p><strong class="bold">Apple Watch</strong>:</p>
<div><div><img alt="Figure 1.16 – Apple Watch settings" src="img/Figure_1.16_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Apple Watch settings</p>
<p>At a quick glance, it is <a id="_idIndexMarker085"/>immediately apparent that there are differences. These are the very differences we will discuss during the remainder of this book. The next section <a id="_idTextAnchor243"/>will summarize this chapter before heading over to our first project.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor244"/>Summary</h1>
<p>In this chapter, we covered the history of Swift and SwiftUI, the features provided to us on a macro level, and how Swift and SwiftUI work on a technical level. Then, we looked at the difference between Swift and SwiftUI and what features are offered, along with code samples for you to take away and use in your own projects. After that, we took a look at the requirements necessary for developing applications with Swift and SwiftUI. Then, we took a look at the coding standards that are used throughout this book, providing a reference point for any coding style that is unfamiliar to your own. Then, we looked at the views and controls provided by SwiftUI for creating our own user experiences, including custom views by combining the fundamentals. Finally, we took a look at how we can or<a id="_idTextAnchor245"/>ganize these views using layouts and checked the device previews too.</p>
<p>In our next chapter, we’ll take a look at designing our first project, the tax calculator app that we will create.</p>
</div>
</body></html>