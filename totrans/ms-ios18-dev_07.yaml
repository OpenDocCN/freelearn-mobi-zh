- en: <st c="0">7</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">7</st>
- en: <st c="2">Improving Feature Exploration with TipKit</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">使用TipKit改进功能探索</st>
- en: <st c="43">In the previous chapter, we learned about SwiftUI animations.</st>
    <st c="106">We know now that SwiftUI animations are a great way to teach users
    how to use</st> <st c="184">our app.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了SwiftUI动画。<st c="106">现在我们知道，SwiftUI动画是教用户如何使用</st> <st c="184">我们的应用的一个很好的方法。</st>
- en: '<st c="192">However, sometimes, it’s not enough, and we need more than fancy
    animations.</st> <st c="270">This is where TipKit comes in.</st> <st c="301">TipKit’s
    goal is to provide a solution for another important topic: feature exploration.</st>
    <st c="390">Feature exploration affects our app users’ engagement and usage, eventually
    affecting user satisfaction</st> <st c="494">and experience.</st>'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="192">然而，有时这还不够，我们需要比花哨的动画更多的东西。</st> <st c="270">这就是TipKit的作用所在。</st>
    <st c="301">TipKit的目标是提供另一个重要主题的解决方案：功能探索。</st> <st c="390">功能探索影响我们的应用用户参与度和使用情况，最终影响用户满意度和体验。</st>
- en: <st c="509">In this chapter, we will cover the</st> <st c="545">following topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="509">在本章中，我们将涵盖以下主题：</st> <st c="545">以下主题：</st>
- en: <st c="562">Learning the importance of tips in a</st> <st c="600">mobile app</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="562">在移动应用中学习提示的重要性</st>
- en: <st c="610">Adding a new tip – inline</st> <st c="637">and popover</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="610">添加新的提示——内联</st> <st c="637">和弹出视图</st>
- en: <st c="648">Customizing our tip’s feel</st> <st c="676">and look</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="648">自定义我们的提示的感觉</st> <st c="676">和外观</st>
- en: <st c="684">Supporting</st> <st c="696">tip actions</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="684">支持</st> <st c="696">提示操作</st>
- en: <st c="707">Defining display rules for</st> <st c="735">our tips</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="707">为我们的提示定义显示规则</st> <st c="735">我们的提示</st>
- en: <st c="743">Grouping tips</st> <st c="758">using TipGroup</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="743">使用TipGroup对提示进行</st> <st c="758">分组</st>
- en: <st c="772">Adjusting</st> <st c="783">display frequency</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="772">调整</st> <st c="783">显示频率</st>
- en: <st c="800">Now, let’s start with the fundamental question – why do we</st>
    <st c="860">need TipKit?</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="800">现在，让我们从基本问题开始——为什么我们需要TipKit？</st> <st c="860">需要TipKit？</st>
- en: <st c="872">Technical requirements</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="872">技术要求</st>
- en: <st c="895">For this chapter, it’s essential to download Xcode version 16.0
    or higher from the</st> <st c="979">App Store.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="895">对于本章，从App Store下载Xcode版本16.0或更高版本是必要的。</st> <st c="979">App Store。</st>
- en: <st c="989">Ensure that you’re operating on the most recent version of macOS
    (Ventura or newer).</st> <st c="1075">Just search for Xcode in the App Store,
    choose the latest version, and proceed with the download.</st> <st c="1173">Open
    Xcode and complete any further setup instructions that appear.</st> <st c="1241">After
    Xcode is completely up and running, you</st> <st c="1287">can begin.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="989">确保您正在使用最新的macOS版本（Ventura或更高版本）。</st> <st c="1075">只需在App Store中搜索Xcode，选择最新版本，然后继续下载。</st>
    <st c="1173">打开Xcode并完成出现的任何进一步设置说明。</st> <st c="1241">Xcode完全运行后，您就可以开始了。</st>
- en: <st c="1297">Download the sample code from the following GitHub</st> <st c="1349">link:</st>
    [<st c="1355">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%207</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%207)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1297">从以下GitHub链接下载示例代码：</st> <st c="1349">链接：</st> [<st c="1355">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%207</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%207)
- en: <st c="1440">Learning the importance of tips</st>
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1440">学习提示的重要性</st>
- en: <st c="1472">One of the challenges of creating an app for a small screen, such
    as a smartphone screen, is to provide ways for the user to explore valuable features.</st>
    <st c="1625">Making users use more features is part of improving user engagement
    – measuring how much the user is actively involved and connected to</st> <st c="1761">our
    product.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1472">为小屏幕（如智能手机屏幕）创建应用的一个挑战是为用户提供探索有价值功能的方法。</st> <st c="1625">让用户使用更多功能是提高用户参与度的一部分——衡量用户在多大程度上积极参与并连接到</st>
    <st c="1761">我们的产品。</st>
- en: <st c="1773">That feature exploration is a real challenge.</st> <st c="1820">On
    the one hand, we aim to create a clean and straightforward user interface and,
    on the other hand, we aim to add more features that can be extremely useful to</st>
    <st c="1981">our users.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1773">功能探索是一个真正的挑战。</st> <st c="1820">一方面，我们旨在创建一个干净直观的用户界面，另一方面，我们旨在添加更多对用户极其有用的功能。</st>
    <st c="1981">我们的用户。</st>
- en: <st c="1991">Every product manager struggles with this challenge – sometimes,
    the solution is to create a</st> **<st c="2085">What’s new</st>** <st c="2095">popup,
    send a marketing email, or add more information to the in-app</st> <st c="2165">FAQ
    screen.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1991">每个产品经理都会面临这个挑战 – 有时，解决方案是创建一个</st> **<st c="2085">什么是新功能</st>**
    <st c="2095">弹出窗口，发送营销邮件，或在应用内</st> <st c="2165">FAQ屏幕中添加更多信息。</st>
- en: <st c="2176">One of the most valuable techniques is to provide a tip – a small
    text box that pops up in the right place at the right time to explain a new feature
    and can even add an action to help the user</st> <st c="2371">use it.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2176">最有价值的技巧之一是提供一个提示 – 一个在正确的时间和地点弹出以解释新功能的小文本框，甚至可以添加一个动作来帮助用户</st>
    <st c="2371">使用它。</st>
- en: <st c="2378">Let’s try to drill down a bit and discuss the basics of tips in
    Apple’s</st> <st c="2451">TipKit framework.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2378">让我们深入探讨一下，并讨论苹果的</st> <st c="2451">提示框架（TipKit）</st>中的提示基础。</st>
- en: <st c="2468">Understanding the basics of TipKit</st>
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2468">理解提示框架的基础</st>
- en: <st c="2503">Some may</st> <st c="2513">think that the primary challenge with
    displaying tips is creating views that contain relevant information and</st> <st
    c="2623">presenting it.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2503">有些人可能</st> <st c="2513">认为显示提示的主要挑战是创建包含相关信息并</st> <st c="2623">展示信息的视图。</st>
- en: <st c="2637">However, if that were the case, we wouldn’t need a whole framework.</st>
    <st c="2706">Instead, we should consider TipKit a</st> <st c="2743">complete system.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2637">然而，如果是那样的话，我们就不需要一个完整的框架。</st> <st c="2706">相反，我们应该将提示框架视为一个</st>
    <st c="2743">完整的系统。</st>
- en: <st c="2759">Let’s look at</st> *<st c="2774">Figure 7</st>**<st c="2782">.1</st>*<st
    c="2784">:</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2759">让我们看看</st> *<st c="2774">图7</st>**<st c="2782">.1</st>*<st c="2784">：</st>
- en: '![Figure 7.1: Tip infrastructure](img/B21795_07_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：提示基础设施](img/B21795_07_1.jpg)'
- en: '<st c="2906">Figure 7.1: Tip infrastructure</st>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2906">图7.1：提示基础设施</st>
- en: '*<st c="2936">Figure 7</st>**<st c="2945">.1</st>* <st c="2947">presents the
    essential components of the structure of TipKit in iOS.</st> <st c="3017">First,
    there is the</st> **<st c="3037">tip center</st>**<st c="3047">, a singleton that
    manages all the tips’ appearances in the app.</st> <st c="3112">The tip</st> <st
    c="3120">center has</st> <st c="3131">several responsibilities:</st>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2936">图7</st>**<st c="2945">.1</st>* <st c="2947">展示了iOS中提示框架结构的必要组件。</st>
    <st c="3017">首先，有</st> **<st c="3037">提示中心</st>**<st c="3047">，一个单例，负责管理应用中所有提示的出现。</st>
    <st c="3112">提示中心有几个职责：</st>'
- en: <st c="3156">Ensures that a tip stops appearing once invalidated or dismissed
    by</st> <st c="3225">the user</st>
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3156">确保提示在用户取消或删除后不再显示</st> <st c="3225">的</st>
- en: <st c="3233">Triggers the tips such that tips don’t overlay</st> <st c="3281">each
    other</st>
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3233">触发提示，以确保提示不会相互重叠</st> <st c="3281">的</st>
- en: <st c="3291">Displays tips according to</st> <st c="3319">specific rules</st>
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3291">根据</st> <st c="3319">特定规则</st>显示提示
- en: <st c="3333">Right after the tip center, we have the</st> **<st c="3374">tip
    model</st>** <st c="3383">– a structure representing a specific tip declaration.</st>
    <st c="3439">Based on the tip model, we can create and display an instance using
    a</st> **<st c="3509">tip view</st>** <st c="3517">– a visual representation of</st>
    <st c="3547">the tip.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3333">在提示中心之后，我们有</st> **<st c="3374">提示模型</st>** <st c="3383">– 一个表示特定提示声明的结构。</st>
    <st c="3439">基于提示模型，我们可以使用</st> **<st c="3509">提示视图</st>** <st c="3517">来创建和显示一个实例
    – 这是提示的视觉表示。</st>
- en: <st c="3555">The TipKit infrastructure looks more complex than it is – many
    iOS frameworks work with some framework center, models, and views.</st> <st c="3685">However,
    the idea here is to show you that while TipKit provides visual components, its
    core functionality lies in the rules that determine when and where</st> <st c="3841">they
    appear.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3555">提示框架的基础结构看起来比实际更复杂 – 许多iOS框架都与某些框架中心、模型和视图一起工作。</st> <st c="3685">然而，这里的想法是向你展示，虽然提示提供了视觉组件，但其核心功能在于确定它们何时何地出现的规则。</st>
- en: <st c="3853">Now, enough of the theoretical introduction.</st> <st c="3899">Let’s
    see what tips</st> <st c="3919">look like!</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3853">现在，理论介绍就到这里。</st> <st c="3899">让我们看看提示是什么样子！</st>
- en: <st c="3929">What do tips look like?</st>
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3929">提示是什么样子？</st>
- en: <st c="3953">The result</st> <st c="3965">of adding a tip is a view that shows
    the new feature to the user (</st>*<st c="4031">Figure 7</st>**<st c="4040">.2</st>*<st
    c="4042">):</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3953">添加提示的结果</st> <st c="3965">是一个向用户展示新功能的视图（</st>*<st c="4031">图7</st>**<st
    c="4040">.2</st>*<st c="4042">）：</st>
- en: '![Figure 7.2: Two different ways to display tips in TipKit](img/B21795_07_2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：在 TipKit 中显示技巧的两种不同方式](img/B21795_07_2.jpg)'
- en: '<st c="4591">Figure 7.2: Two different ways to display tips in TipKit</st>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4591">图 7.2：在 TipKit 中显示技巧的两种不同方式</st>
- en: <st c="4647">Based on</st> *<st c="4657">Figure 7</st>**<st c="4665">.2</st>*<st
    c="4667">, we can</st> <st c="4676">see that there are two ways of displaying</st>
    <st c="4718">a tip:</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4647">根据</st> *<st c="4657">图 7</st>**<st c="4665">.2</st>*<st c="4667">，我们可以</st>
    <st c="4676">看到有两种显示</st> <st c="4718">技巧的方式：</st>
- en: '**<st c="4724">Inline tip</st>**<st c="4735">: Inline tips</st> <st c="4750">embed
    themselves as part of the screen layout, and their appearance modifies and pushes
    the other views accordingly.</st> <st c="4867">Inline tips</st> <st c="4879">are
    a great fit in</st> **<st c="4898">VStacks</st>** <st c="4905">or</st> **<st c="4909">Lists</st>**<st
    c="4914">, and we can view them without</st> <st c="4945">interfering with the</st>
    <st c="4966">screen interaction.</st>'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4724">内联技巧</st>**<st c="4735">：内联技巧会嵌入到屏幕布局中，其出现会相应地修改和推动其他视图。</st>
    <st c="4750">内联技巧</st> <st c="4879">非常适合</st> **<st c="4898">VStacks</st>** <st
    c="4905">或</st> **<st c="4909">Lists</st>**<st c="4914">，我们可以在不</st> <st c="4945">干扰屏幕交互</st>
    <st c="4966">的情况下查看它们。</st>'
- en: '**<st c="4985">Popover tip</st>**<st c="4997">: Unlike</st> <st c="5007">inline
    tips, popover tips appear above the current screen, mostly linked to a button
    or another control.</st> <st c="5112">With popover tips, the user must dismiss
    the tip or perform its action to continue with the app.</st> <st c="5209">Also,
    we cannot display multiple popover tips at the</st> <st c="5262">same time.</st>'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4985">弹出提示</st>**<st c="4997">：与内联提示不同，弹出提示出现在当前屏幕上方，通常与按钮或其他控件相关联。</st>
    <st c="5112">使用弹出提示时，用户必须关闭提示或执行其操作才能继续使用应用程序。</st> <st c="5209">此外，我们无法同时显示多个弹出提示。</st>'
- en: <st c="5272">At first glance, the two ways to display tips are just a matter
    of design.</st> <st c="5348">Showing a popover tip is not only a different experience
    but also a different use case.</st> <st c="5436">In the inline tip, we include
    the view in a non-intrusive way that allows the user to discover new features
    gradually.</st> <st c="5555">In contrast, the popover tip is excellent for contextual
    help or complex features</st> <st c="5637">requiring guidance.</st> <st c="5657">Remember
    that adding more views to our device’s small screen can sometimes be overwhelming,
    and we must make this</st> <st c="5771">decision carefully.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5272">乍一看，显示技巧的两种方式只是设计上的问题。</st> <st c="5348">显示弹出提示不仅是一种不同的体验，也是一种不同的用例。</st>
    <st c="5436">在内联技巧中，我们以一种非侵入性的方式包含视图，使用户能够逐渐发现新功能。</st> <st c="5555">相比之下，弹出提示非常适合上下文帮助或需要指导的复杂功能。</st>
    <st c="5637">记住，将更多视图添加到我们设备的小屏幕上有时可能会让人感到不知所措，我们必须谨慎做出这个</st> <st c="5771">决定。</st>
- en: <st c="5790">Let’s add our first tip and convince users to use our new</st>
    **<st c="5849">mark as</st>** **<st c="5857">favorite</st>** <st c="5865">feature.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5790">让我们添加我们的第一个技巧，并说服用户使用我们新的</st> **<st c="5849">标记为</st>** **<st
    c="5857">收藏</st>** <st c="5865">功能。</st>
- en: <st c="5874">Adding our first tip</st>
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5874">添加我们的第一个技巧</st>
- en: <st c="5895">Even though we are excited and can’t wait to add our first tip,
    we still need to do a small amount</st> <st c="5995">of preparation first, and
    that’s setting up our persistent store for the</st> <st c="6068">tips state.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5895">尽管我们兴奋不已，迫不及待地想要添加我们的第一个技巧，但我们仍然需要先做一些小准备，那就是为</st> <st c="5995">技巧状态设置我们的持久存储。</st>
    <st c="6068">技巧状态。</st>
- en: <st c="6079">Why do we need to set up a persistent store?</st> <st c="6125">TipKit
    needs to manage the tips’ state over time, even after we close our app.</st> <st
    c="6204">This is because we don’t want our tips to show up again if the user (or
    the app) decides to</st> <st c="6296">dismiss them.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6079">为什么我们需要设置持久存储？</st> <st c="6125">TipKit 需要在关闭我们的应用程序后管理技巧的状态。</st>
    <st c="6204">这是因为我们不希望用户（或应用程序）决定</st> <st c="6296">关闭它们后，提示再次出现。</st>
- en: <st c="6309">We can set up the persistent store using a static function</st>
    <st c="6369">called</st> `<st c="6376">configure()</st>`<st c="6387">:</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6309">我们可以使用一个名为</st> <st c="6369">`configure()`</st> <st c="6387">的静态函数来设置持久存储：</st>
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="6464">In our code example, we can see that we call the</st> `<st c="6514">configure</st>`
    <st c="6523">function part of the app initialization process because we need TipKit
    to have all its information once the first screen</st> <st c="6645">is loaded.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6655">We can also share the tips’ states store with more of our apps
    and extensions by defining it in a</st> <st c="6754">group container:</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="6867">In this</st> <st c="6876">example, we configured the tips’ state
    data store in a group container called</st> `<st c="6954">MyAppGroupContainer</st>`<st
    c="6973">. Don’t worry – from the app’s perspective, the user experience will
    stay</st> <st c="7047">the same.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7056">What is a group container?</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7083">A group</st> <st c="7092">container is a directory shared among
    multiple apps and extensions within the same app group.</st> <st c="7186">It allows
    us to share data between</st> <st c="7221">our apps.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7230">Our next step is to define our</st> `<st c="7262">T</st><st c="7263">ip</st>`
    <st c="7265">model.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7272">Defining our Tip model</st>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="7295">The</st> `<st c="7300">Tip</st>` <st c="7303">model (based</st>
    <st c="7317">on the</st> **<st c="7324">Tip protocol</st>**<st c="7336">) defines
    our tip’s behavior</st> <st c="7366">and appearance.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7381">Let’s see</st> <st c="7392">a simple</st> <st c="7401">tip declaration:</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="7680">In this code example, we declared a struct named</st> `<st c="7730">MarkAsFavoriteTip</st>`<st
    c="7747">, which conforms</st> <st c="7764">to the</st> `<st c="7771">Tip</st>`
    <st c="7774">protocol.</st> <st c="7785">We can see that</st> `<st c="7801">MarkAsFavoriteTip</st>`
    <st c="7818">has several properties.</st> <st c="7843">The title, message, and
    image define the content of the tip view, as we can see in</st> *<st c="7926">Figure
    7</st>**<st c="7934">.3</st>*<st c="7936">:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: The Save as a Favorite tip view](img/B21795_07_3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: '<st c="8027">Figure 7.3: The Save as a Favorite tip view</st>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8070">In</st> *<st c="8074">Figure 7</st>**<st c="8082">.3</st>*<st c="8084">,
    we can see the tip view with all the content we declared in</st> `<st c="8146">MarkAsFavoriteTip</st>`<st
    c="8163">. Now, let’s see how we add this tip to our</st> <st c="8207">SwiftUI
    view:</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="8389">This code example has a SwiftUI view that presents a list of workouts.</st>
    <st c="8461">To display a tip on top of</st> <st c="8488">the list, we created
    an instance of the</st> `<st c="8528">MarkAsFavoriteTip</st>` <st c="8545">structure
    from earlier and then a</st> `<st c="8580">TipView</st>` <st c="8587">view, passing
    that</st> <st c="8607">tip instance.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="8620">Figure 7</st>**<st c="8629">.4</st>* <st c="8631">shows what
    it</st> <st c="8646">looks like:</st>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: A workout list with an inline tip view](img/B21795_07_4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: '<st c="9058">Figure 7.4: A workout list with an inline tip view</st>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="9108">Figure 7</st>**<st c="9117">.4</st>* <st c="9119">shows how the
    tip fits nicely on the screen, pushing the list down the</st> `<st c="9191">VStack</st>`
    <st c="9197">view.</st> <st c="9204">Tapping on the tip’s close button removes
    the tip from the screen and pushes the list up to take</st> <st c="9301">its place.</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="9108">图7</st>**<st c="9117">.4</st>* <st c="9119">展示了提示如何很好地适应屏幕，将列表向下</st>
    `<st c="9191">VStack</st>` <st c="9197">视图。</st> <st c="9204">轻触提示的关闭按钮将提示从屏幕上移除，并将列表向上推以占据</st>
    <st c="9301">其位置。</st>'
- en: <st c="9311">Pretty simple, huh?</st> <st c="9332">Now, let’s see how to add
    a</st> <st c="9360">popover tip.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9311">很简单，对吧？</st> <st c="9332">现在，让我们看看如何添加一个</st> <st c="9360">弹出提示。</st>
- en: <st c="9372">Adding a popover tip</st>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="9372">添加弹出提示</st>
- en: <st c="9393">As mentioned, a popover tip serves different use cases than an
    inline tip.</st> <st c="9469">It blocks the user’s interaction</st> <st c="9502">with
    other elements on the screen and is more contextual.</st> <st c="9560">In a popover
    tip, we link the popover view to a specific control on the screen – usually a
    button or</st> <st c="9661">a toggle.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9393">如前所述，弹出提示与内联提示服务于不同的用例。</st> <st c="9469">它阻止了用户与屏幕上其他元素的交互，并且更具上下文性。</st>
    <st c="9502">在弹出提示中，我们将弹出视图链接到屏幕上的特定控件——通常是按钮或</st> <st c="9661">切换器。</st>
- en: <st c="9670">The way we add a popover tip is by using a view modifier called</st>
    `<st c="9735">popoverTip</st>`<st c="9745">, passing our tip instance (</st>`<st
    c="9773">tip</st>`<st c="9777">) (just like in an inline tip) and an optional</st>
    <st c="9825">arrow direction:</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9670">我们添加弹出提示的方式是通过使用一个名为</st> `<st c="9735">popoverTip</st>`<st c="9745">的视图修改器，传递我们的提示实例（</st>`<st
    c="9773">tip</st>`<st c="9777">）（就像在内联提示中一样）和一个可选的</st> <st c="9825">箭头方向：</st>
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="10113">Our code example shows a similar pattern to the one we saw in
    the inline tip.</st> <st c="10192">We create a tip instance, and this time, we
    add the tip to our screen by using a view modifier attached to the screen toolbar
    button.</st> *<st c="10326">Figure 7</st>**<st c="10334">.5</st>* <st c="10336">shows
    how</st> <st c="10347">it looks:</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10113">我们的代码示例显示了与我们在内联提示中看到相似的图案。</st> <st c="10192">我们创建了一个提示实例，这次，我们通过将提示添加到屏幕上的视图修改器（屏幕工具栏按钮）来将提示添加到我们的屏幕上。</st>
    *<st c="10326">图7</st>**<st c="10334">.5</st>* <st c="10336">展示了它的外观：</st>
- en: '![Figure 7.5: A popover tip](img/B21795_07_5.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：弹出提示](img/B21795_07_5.jpg)'
- en: '<st c="10484">Figure 7.5: A popover tip</st>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10484">图7.5：弹出提示</st>
- en: <st c="10509">What’s nice</st> <st c="10522">about the popover tip is that we
    don’t need to care about things such as positioning, depth, or creating the popover
    pointer – this is all done for us, similar to the popover</st> <st c="10697">view
    modifier.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10509">关于弹出提示的优点</st> <st c="10522">是，我们不需要关心诸如定位、深度或创建弹出指针等问题——这一切都由我们完成，类似于弹出视图</st>
    <st c="10697">修改器。</st>
- en: <st c="10711">We see that both inline and popover tips have a close button.</st>
    <st c="10774">Let’s discuss it further because this is where we start to reveal
    the tip’s real</st> <st c="10855">added value.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10711">我们看到内联和弹出提示都有关闭按钮。</st> <st c="10774">让我们进一步讨论这个问题，因为这是我们开始揭示提示真正</st>
    <st c="10855">附加价值的地方。</st>
- en: <st c="10867">Dismissing tips</st>
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10867">忽略提示</st>
- en: <st c="10883">You are probably wondering how dismissing a tip view is related
    to the tip’s</st> <st c="10961">added value.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10883">你可能想知道忽略提示视图与提示的</st> <st c="10961">附加价值有何关系。</st>
- en: <st c="10973">We discussed</st> <st c="10987">that the real power of tips is
    not the UI layer but its presentation logic.</st> <st c="11063">Whenever we dismiss
    a tip, TipKit marks it as invalidated and won’t show it again.</st> <st c="11146">TipKit
    also stores the invalidation status permanently, meaning it won’t be displayed
    after the</st> <st c="11242">app relaunch.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10973">我们讨论了</st> <st c="10987">真正的提示力量不在于UI层，而在于其展示逻辑。</st> <st c="11063">每次我们忽略一个提示，TipKit都会将其标记为无效，并且不会再显示。</st>
    <st c="11146">TipKit还会永久存储无效状态，这意味着在应用重新启动后，它也不会显示。</st>
- en: <st c="11255">Another way to dismiss a tip, besides closing it, is to invalidate
    it in code.</st> <st c="11335">Let’s look at the inline tip from the code example
    earlier again (under</st> *<st c="11407">Defining our Tip Model</st>*<st c="11429">).</st>
    <st c="11433">The tip in that example helps the user explore the app’s favorites
    feature.</st> <st c="11509">It also means that whenever the user marks one of
    the workouts as a favorite, we can assume that the tip is no longer needed and
    invalidate</st> <st c="11649">it ourselves.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11255">除了关闭提示外，还可以通过在代码中使提示失效来关闭提示。</st> <st c="11335">让我们再次看看之前的代码示例中的内联提示（在</st>
    *<st c="11407">定义我们的提示模型</st> *<st c="11429">部分下）。</st> <st c="11433">该示例中的提示帮助用户探索应用程序的收藏功能。</st>
    <st c="11509">这也意味着每当用户将一项锻炼标记为收藏时，我们可以假设提示不再需要，并自行使其失效</st> <st c="11649">。</st>
- en: <st c="11662">To invalidate a tip, we need to call the tip’s</st> `<st c="11710">invalidate()</st>`
    <st c="11722">function:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11662">要使提示失效，我们需要调用提示的</st> `<st c="11710">invalidate()</st>` <st c="11722">函数：</st>
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="11858">In this code example, we call the</st> `<st c="11893">invalidate()</st>`
    <st c="11905">function whenever the user taps the</st> <st c="11942">favorite
    button.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11858">在这个代码示例中，我们每次用户点击</st> `<st c="11893">invalidate()</st>` <st c="11905">函数时都调用它。</st>
- en: <st c="11958">Remember</st> <st c="11968">that SwiftUI is a declarative framework
    – the tip status is part of the view state, and SwiftUI refreshes the screen after</st>
    <st c="12091">a change.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11958">记住</st> <st c="11968">SwiftUI是一个声明式框架——提示状态是视图状态的一部分，SwiftUI在更改后刷新屏幕。</st>
- en: <st c="12100">Another thing we can see in that code example is the reason for
    invalidation.</st> <st c="12179">In this case, we send</st> `<st c="12201">actionPerformed</st>`
    <st c="12216">because this is precisely what happened – the user performed the
    action suggested by</st> <st c="12302">the tip.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12100">在代码示例中，我们还可以看到失效的原因。</st> <st c="12179">在这种情况下，我们发送了`<st c="12201">actionPerformed</st>`
    <st c="12216">，因为这正是发生的事情——用户执行了提示建议的操作。</st>
- en: '<st c="12310">Another question may arise at this point: how does TipKit know
    whether that specific tip has already been shown?</st> <st c="12424">Also, is
    there a way to reset the persistent data and show the</st> <st c="12487">tip again?</st>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12310">此时可能还会出现另一个问题：TipKit如何知道那个特定的提示是否已经显示过？</st> <st c="12424">此外，是否有方法可以重置持久数据并再次显示</st>
    <st c="12487">提示？</st>
- en: <st c="12497">That’s where the tip ID</st> <st c="12522">comes in.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12497">提示ID</st> <st c="12522">就派上用场了。</st>
- en: <st c="12531">Defining the tip ID</st>
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12531">定义提示ID</st>
- en: <st c="12551">If you went</st> <st c="12564">over the code example under the</st>
    *<st c="12596">Defining our tip model</st>* <st c="12618">section, you may have
    noticed the</st> <st c="12653">following line:</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12551">如果你阅读了</st> <st c="12564">“定义我们的提示模型”</st> <st c="12596">部分下的代码示例，你可能已经注意到了</st>
    <st c="12618">以下这一行：</st>
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="12702">The</st> `<st c="12707">id</st>` <st c="12709">variable is part
    of the</st> `<st c="12734">Tip</st>` <st c="12737">protocol; we use that property
    to define a specific identifier for each tip.</st> <st c="12815">TipKit uses that
    identifier to manage the different</st> <st c="12867">tip statuses.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12702">`<st c="12707">id</st>` <st c="12709">变量是`<st c="12734">Tip</st>`
    <st c="12737">协议的一部分；我们使用该属性为每个提示定义一个特定的标识符。</st> <st c="12815">TipKit使用该标识符来管理不同的</st>
    <st c="12867">提示状态。</st>
- en: '<st c="12880">You can do a small experiment: create a small app with a tip
    (or use the code examples in our GitHub repository) and invalidate the tip.</st>
    <st c="13018">Relaunch the app and see that the tip doesn’t show again.</st> <st
    c="13076">Now, modify the tip identifier to have a different name.</st> <st c="13133">Relaunch
    the app, and you’ll see that the tip is visible again.</st> <st c="13197">Also,
    reinstalling the app (after deletion) will reset the local</st> <st c="13262">persistent
    store.</st>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12653">你可以做一个小的实验：创建一个带有提示的小程序（或使用我们GitHub仓库中的代码示例）并使提示失效。</st> <st c="13018">重新启动应用程序，你会看到提示不再显示。</st>
    <st c="13076">现在，修改提示标识符以使用不同的名称。</st> <st c="13133">重新启动应用程序，你会看到提示再次可见。</st>
    <st c="13197">此外，删除应用程序后重新安装应用程序（删除后）将重置本地</st> <st c="13262">持久存储。</st>
- en: <st c="13279">Another way to reset the local persistent store is to call the
    static</st> `<st c="13350">resetDatastore</st>` <st c="13364">function on</st>
    <st c="13377">app launch:</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13279">另一种重置本地持久存储的方法是在应用程序启动时调用静态</st> `<st c="13350">resetDatastore</st>`
    <st c="13364">函数：</st>
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="13470">Notice that</st> <st c="13483">we call the</st> `<st c="13495">resetDatastore</st>`
    <st c="13509">function before the</st> `<st c="13530">configure</st>` <st c="13539">function.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`<st c="13530">configure</st>`函数之前调用了`<st c="13495">resetDatastore</st>`函数。
- en: <st c="13549">The tip identifier is part of the</st> `<st c="13584">Tip</st>`
    <st c="13587">protocol, and in this example, the identifier is shared across all
    the</st> <st c="13659">struct instances:</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提示标识符是`<st c="13584">Tip</st>`协议的一部分，在这个例子中，标识符在所有`<st c="13659">struct</st>`实例之间共享：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="13710">Since the identifier is shared, all the tip views based on the</st>
    `<st c="13774">struct</st>` <st c="13780">instances will be dismissed once you
    invalidate one</st> <st c="13833">of them.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标识符是共享的，一旦你使其中一个无效，基于`<st c="13774">struct</st>`实例的所有提示视图都将关闭。
- en: <st c="13841">In most cases, that’s considered normal behavior and best practice.</st>
    <st c="13910">If the user marks a specific row as a favorite, they already know
    about this feature, even if it appears on</st> <st c="14018">another screen.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这被认为是正常行为和最佳实践。如果用户将特定行标记为收藏夹，他们已经了解这个功能，即使它出现在另一个屏幕上。
- en: <st c="14033">However, that’s not always the case, so plan</st> <st c="14079">identifiers
    accordingly.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并不总是如此，因此相应地规划标识符。
- en: <st c="14103">Now we know how to present a tip, both inline and popover.</st>
    <st c="14163">We also know how to dismiss it and even reset the persistent state.</st>
    <st c="14231">However, TipKit provides even more than that.</st> <st c="14277">Let’s
    see how we can customize</st> <st c="14308">our tips.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何展示提示，无论是内联还是弹出式。我们也知道如何关闭它，甚至重置持久状态。然而，TipKit提供了更多功能。让我们看看我们如何自定义我们的提示。
- en: <st c="14317">Customizing our tips</st>
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义我们的提示
- en: <st c="14338">So, TipKit provides</st> <st c="14359">an excellent infrastructure
    for presenting persistence-based tips in our app.</st> <st c="14437">However,
    the TipKit framework’s developers knew that handling tips requires more thought
    than just invalidating an ordinary view with an image and</st> <st c="14584">two
    texts.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TipKit为我们应用中展示基于持久性的提示提供了一个优秀的基础设施。然而，TipKit框架的开发者知道，处理提示需要比仅仅用图像和两个文本使普通视图无效更多的思考。
- en: <st c="14594">Let’s see how we can customize tips to our own needs.</st> <st
    c="14649">We’ll start with</st> <st c="14666">their appearance.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何根据我们的需求自定义提示。我们将从它们的显示风格开始。
- en: <st c="14683">Customizing our tips’ appearance</st>
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义我们的提示显示风格
- en: <st c="14716">Unlike many other UI-based frameworks Apple has provided, TipKit
    lets us customize the tip views nicely.</st> <st c="14822">This may be because
    SwiftUI is a declarative framework, and expressing visual content</st> <st c="14908">becomes
    more natural.</st> <st c="14930">However, in the case of TipKit, Apple understood
    developers’ need to align the TipKit design with</st> <st c="15028">their apps.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与苹果提供的许多其他基于UI的框架不同，TipKit允许我们很好地自定义提示视图。这可能是因为SwiftUI是一个声明性框架，表达视觉内容变得更加自然。然而，在TipKit的情况下，苹果理解开发者将TipKit设计与其应用程序对齐的需求。
- en: <st c="15039">There are two ways to customize our tip’s appearance.</st> <st
    c="15094">The first is to modify the tip’s properties and apply basic changes
    without changing the tip’s layout</st> <st c="15196">and components.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以自定义提示的显示风格。第一种是修改提示的属性，应用基本更改而不改变提示的布局和组件。
- en: '<st c="15211">The second way is to implement a new tip view style, which allows
    you to fully control the tip’s feel and look.</st> <st c="15324">Let’s start with
    the first way: modifying the</st> <st c="15370">tip properties.</st>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是实现一个新的提示视图样式，这允许你完全控制提示的感觉和外观。让我们从第一种方式开始：修改提示属性。
- en: <st c="15385">Modifying the tip properties</st>
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改提示属性
- en: <st c="15414">As I mentioned earlier, one of the great things about SwiftUI
    is its expressive framework, and we</st> <st c="15513">can use view modifiers
    to adjust the tip’s appearance to</st> <st c="15570">our style.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，SwiftUI的其中一个优点是其表达性框架，我们可以使用视图修饰符来调整提示的显示风格以符合我们的风格。
- en: <st c="15580">Let’s look at the tip’s</st> `<st c="15605">title</st>` <st c="15610">property
    again:</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看提示的`<st c="15605">title</st>` `<st c="15610">属性</st>`：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="15673">Notice that we are not returning a</st> `<st c="15709">String</st>`
    <st c="15715">but a</st> `<st c="15722">Text</st>` <st c="15726">value, which
    is a SwiftUI view.</st> <st c="15759">This means we can modify its look to look
    like any other</st> <st c="15816">SwiftUI view.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们返回的不是`<st c="15709">String</st>` `<st c="15715">而是</st>` `<st c="15722">Text</st>`
    `<st c="15726">值</st>`，这是一个SwiftUI视图。`<st c="15759">这意味着我们可以修改其外观，使其看起来像任何其他</st>`
    `<st c="15816">SwiftUI视图</st>`。
- en: <st c="15829">For example, we can change the title text color by applying the</st>
    `<st c="15894">foregroundStyle</st>` <st c="15909">view modifier:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过应用`<st c="15894">foregroundStyle</st>` `<st c="15909">视图修饰符</st>`来改变标题文本颜色：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<st c="15994">The code example is straightforward: we took the text view and
    changed its look.</st> <st c="16075">Moreover, because we can build a</st> `<st
    c="16108">Text</st>` <st c="16112">view by compounding multiple text views, we
    can mix styles</st> <st c="16172">and colors:</st>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例很简单：我们取了文本视图并改变了其外观。`<st c="16075">此外，因为我们可以通过组合多个文本视图来构建一个</st>` `<st c="16108">Text</st>`
    `<st c="16112">视图，所以我们可以混合样式和颜色</st>` `<st c="16172">：</st>`。
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="16302">In</st> <st c="16305">this example, we took our</st> `<st c="16331">Save
    as a Favorite</st>` <st c="16349">text and changed the</st> `<st c="16371">Favorite</st>`
    <st c="16379">text to be red and bold to distinguish it from the rest of</st>
    <st c="16439">the title.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们取了我们的`<st c="16331">Save as a Favorite</st>` `<st c="16349">文本</st>`并将`<st
    c="16371">Favorite</st>` `<st c="16379">文本</st>`改为红色和粗体，以区分它与其他`<st c="16439">标题</st>`。
- en: <st c="16449">We can also perform changes to the</st> `<st c="16485">Image</st>`
    <st c="16490">property, such as changing its colors or</st> <st c="16532">rendering
    mode:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对`<st c="16449">Image</st>` `<st c="16485">属性</st>`进行修改，例如改变其颜色或`<st c="16532">渲染模式</st>`：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="16656">In</st> [*<st c="16659">Chapter 6</st>*](B21795_06.xhtml#_idTextAnchor212)<st
    c="16668">, we learned that SF symbols have multiple layers so that we can apply
    different colors to different layers.</st> <st c="16777">In this example, we changed
    the rendering mode for our symbol</st> <st c="16839">to</st> `<st c="16842">multicolor</st>`<st
    c="16852">.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[*<st c="16659">第6章</st>*](B21795_06.xhtml#_idTextAnchor212)`中，我们了解到SF符号有多个层级，这样我们就可以将不同的颜色应用到不同的层级。在这个例子中，我们将我们的符号的渲染模式改为`<st
    c="16842">多色</st>` `<st c="16852">。</st>`。
- en: <st c="16853">Modifying the tip properties is a great way to add a basic touch
    to our tip view user interface.</st> <st c="16951">However, we know how crucial
    design is in iOS apps, and sometimes, changing colors and font style just isn’t
    enough.</st> <st c="17068">For this reason, we can use</st> `<st c="17096">TipViewStyle</st>`
    <st c="17108">for</st> <st c="17113">further customization.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 修改提示属性是给我们的提示视图用户界面添加基本触感的好方法。然而，我们知道设计在iOS应用中是多么关键，有时，仅仅改变颜色和字体样式是不够的。因此，我们可以使用`<st
    c="17096">TipViewStyle</st>` `<st c="17108">进行</st>` `<st c="17113">进一步定制</st>`。
- en: <st c="17135">Using TipViewStyle</st>
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`<st c="17135">TipViewStyle</st>`
- en: <st c="17154">The given tip view design only works if we need a different UI
    layout or an even more complex tip view.</st> <st c="17259">So, we must consider
    a different design pattern to meet</st> <st c="17315">that requirement.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的提示视图设计仅在我们需要不同的UI布局或更复杂的提示视图时才有效。因此，我们必须考虑不同的设计模式来满足该需求。
- en: <st c="17332">One of</st> <st c="17340">the most critical development principles
    I love to mention is the separation of concerns principle – the idea that different
    components should have</st> <st c="17488">other responsibilities.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢提到的最重要的开发原则之一是关注点分离原则——即不同的组件应该有不同的责任。
- en: <st c="17511">Some responsibilities are mixed up when we look at how the</st>
    `<st c="17571">Tip</st>` <st c="17574">protocol works.</st> <st c="17591">On the
    one hand, the Tip protocol structure defines the content of our tip – the title,
    message, and image.</st> <st c="17699">On the other hand, the structure also defines
    its design, which may be a</st> <st c="17772">different responsibility.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`<st c="17571">Tip</st>` `<st c="17574">协议</st>`的工作方式时，一些责任被混合在一起。一方面，Tip协议结构定义了我们的提示内容——标题、消息和图像。另一方面，结构也定义了其设计，这可能是不同的责任。
- en: <st c="17797">The fact that these responsibilities are mixed also limits how
    we design our tips – we can’t define a new layout as part of</st> <st c="17922">the
    structure.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17936">However, content and design are part of SwiftUI’s nature and one
    of its strengths as a declarative language.</st> <st c="18046">Fortunately, we
    have a solution for that:</st> **<st c="18088">View Styles</st>**<st c="18099">.
    A View Style is a</st> <st c="18119">way to define the appearance of a</st> <st
    c="18153">view component.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18168">Here’s an example of defining a</st> <st c="18201">bordered button:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'struct ImageAtTheCornerViewStyle: TipViewStyle { <st c="18495">func makeBody(configuration:
    Configuration) -> some</st>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18546">View</st> {
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: VStack {
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if let title = configuration.title, let message
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: = configuration.message {
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: title
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .multilineTextAlignment(.center)
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .font(.title2) <st c="18691">Divider()</st> message
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .multilineTextAlignment(.leading)
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .font(.body)
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: HStack {
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Spacer()
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Image(systemName: "star")'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .padding()
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'TipView(tip) <st c="19288">TipView</st> view has our new custom style and layout,
    and it looks like this (*<st c="19362">Figure 7</st>**<st c="19371">.6</st>*):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Customizing our tip with TipViewStyle](img/B21795_07_6.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="19466">Figure 7.6: Customizing our tip with TipViewStyle</st>'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19515">It is a</st> <st c="19524">good practice to name the</st> `<st
    c="19550">TipViewStyle</st>` <st c="19562">protocol with a generic and descriptive
    name such as</st> `<st c="19616">ImageAtTheCornerViewStyle</st>`<st c="19641">,
    so it will be easier to share it with the rest of</st> <st c="19693">our tips.</st>
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19702">Up to now, we’ve learned how to define a tip, present it in different
    places, and design it however we want.</st> <st c="19812">However, our journey
    with enriching our tips doesn’t end here, as we can also add some user interactions
    by</st> <st c="19920">adding</st> **<st c="19927">actions</st>**<st c="19934">.</st>
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19935">Adding actions</st>
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19950">Actions are very valuable additions to tips.</st> <st c="19996">In
    many cases, our tips suggest that the user take</st> <st c="20047">an action –
    go to the settings screen, add a new task, or enter our app’s new edit mode, for
    example.</st> <st c="20149">What’s better than adding a button that performs that
    specific action inside the</st> <st c="20230">tip view?</st>
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20239">Besides the title, message, and image, the tip protocol also contains
    an actions property – an array of structures describing the buttons our tip</st>
    <st c="20386">will display.</st>
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20399">Let’s see that property in</st> <st c="20427">an example:</st>
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="20601">The code example shows a</st> `<st c="20626">ChangeEmailTip</st>`
    <st c="20640">structure with two actions.</st> <st c="20669">(Notice that this
    tip is partial; assume that we already implemented the rest of the properties,
    such as</st> `<st c="20774">title</st>` <st c="20779">and</st> `<st c="20784">message</st>`<st
    c="20791">.)</st>
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20601">代码示例展示了</st> `<st c="20626">ChangeEmailTip</st>` <st c="20640">结构包含两个操作。</st>
    <st c="20669">(注意这个提示是部分展示的；假设我们已经实现了其余的属性，例如</st> `<st c="20774">标题</st>` <st
    c="20779">和</st> `<st c="20784">消息</st>`<st c="20791">。) </st>
- en: <st c="20793">Each action initialization function has two parameters:</st> `<st
    c="20850">title</st>` <st c="20855">and</st> `<st c="20860">id</st>`<st c="20862">.
    The</st> `<st c="20868">title</st>` <st c="20873">parameter</st> <st c="20884">represents
    the title that appears on the button.</st> <st c="20933">The</st> `<st c="20937">id</st>`
    <st c="20939">parameter describes the goal of this action, and we use it to determine
    which button the</st> <st c="21029">user tapped.</st>
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20793">每个操作初始化函数有两个参数：</st> `<st c="20850">标题</st>` <st c="20855">和</st>
    `<st c="20860">id</st>`<st c="20862">。 `<st c="20868">标题</st>` <st c="20873">参数</st>
    <st c="20884">表示按钮上显示的标题。</st> `<st c="20933">id</st>` <st c="20937">参数描述了这个操作的目标，我们用它来确定用户点击了哪个按钮。</st>
- en: '*<st c="21041">Figure 7</st>**<st c="21050">.7</st>* <st c="21052">shows how
    the actions look in a</st> <st c="21085">popover tip:</st>'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="21041">图7</st>**<st c="21050">.7</st>* <st c="21052">展示了操作在弹出提示中的外观：</st>'
- en: '![Figure 7.7: Two actions in a popover tip view](img/B21795_07_7.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.7：弹出提示视图中的两个操作](img/B21795_07_7.jpg)'
- en: '<st c="21222">Figure 7.7: Two actions in a popover tip view</st>'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21222">图7.7：弹出提示视图中的两个操作</st>
- en: <st c="21267">Like the rest of the properties, TipKit decides what layout to
    present the actions in and how the</st> <st c="21366">buttons look.</st>
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21267">与其它属性一样，TipKit决定如何布局显示操作，以及按钮的外观。</st> <st c="21366">按钮的外观。</st>
- en: <st c="21379">Now that we have defined and presented the actions, let’s see
    how we respond to user selection.</st> <st c="21476">Responding to an action is
    easy now that we have an ID for each action.</st> <st c="21548">The</st> `<st
    c="21552">popoverTip</st>` <st c="21562">view modifier we discussed in the</st>
    *<st c="21597">Adding a popover tip</st>* <st c="21617">section has an additional
    closure that handles action selection.</st> <st c="21683">Let’s see a code example</st>
    <st c="21708">for that:</st>
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21379">现在我们已经定义并展示了操作，让我们看看我们如何响应用户的选择。</st> <st c="21476">现在我们为每个操作都有一个ID，响应用户的选择变得容易了。</st>
    <st c="21548">我们在</st> *<st c="21597">添加弹出提示</st> * <st c="21617">部分讨论的</st> `<st
    c="21552">popoverTip</st>` <st c="21562">视图修饰符有一个额外的闭包来处理操作选择。</st> <st c="21683">让我们看看一个代码示例：</st>
    <st c="21708">来展示这个：</st>
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="21912">This code example shows the exact popover tip implementation,
    now with the closure that handles</st> <st c="22008">the selected action.</st>
    <st c="22029">Within the closure, we check for the action ID and perform the desired
    action (for example, navigate to the</st> <st c="22137">settings screen).</st>
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21912">这个代码示例展示了精确的弹出提示实现，现在包含处理</st> <st c="22008">所选操作</st> <st c="22029">的闭包。</st>
    <st c="22029">在闭包内部，我们检查操作ID并执行所需操作（例如，导航到设置屏幕）。</st>
- en: <st c="22154">It’s much nicer to add these ids in static constants</st> <st
    c="22208">for clarity:</st>
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22154">将这些ID添加到静态常量中更清晰：</st>
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="22656">This code example shows how beautiful Swift can be when applying</st>
    <st c="22722">best practices!</st>
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22656">这个代码示例展示了在应用</st> <st c="22722">最佳实践</st> <st c="22737">时Swift可以多么美丽！</st>
- en: <st c="22737">Speaking</st> <st c="22747">of beautiful, we discussed how to
    design our tips using</st> `<st c="22803">TipViewStyle</st>`<st c="22815">, so
    we can also design our actions using the</st> <st c="22861">same technique:</st>
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22737">说到美丽，我们讨论了如何使用</st> `<st c="22803">TipViewStyle</st>`<st c="22815">来设计我们的提示，因此我们也可以使用相同的技巧来设计我们的操作：</st>
    <st c="22861">以下是一个代码示例：</st>
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="22976">In this code example, we create a list of buttons, each handling
    a different action.</st> <st c="23062">We need to add that code snippet to the</st>
    `<st c="23102">makeBody</st>` <st c="23110">function we learned about in the</st>
    *<st c="23144">Using</st>* *<st c="23150">TipViewStyle</st>* <st c="23162">section.</st>
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22976">在这个代码示例中，我们创建了一个按钮列表，每个按钮处理不同的操作。</st> <st c="23062">我们需要将这段代码添加到</st>
    `<st c="23102">makeBody</st>` <st c="23110">函数中，我们在</st> *<st c="23144">使用</st>
    * *<st c="23150">TipViewStyle</st> * <st c="23162">部分学到的。</st>
- en: <st c="23171">At this point, we’ve learned so much about tips!</st> <st c="23221">The
    good news is that we have more surprises up our sleeves.</st> <st c="23282">Let’s
    reveal them and discuss the</st> **<st c="23316">rules</st>** <st c="23321">feature.</st>
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23171">到目前为止，我们已经学到了很多关于提示的知识！</st> <st c="23221">好消息是我们还有更多惊喜。</st>
    <st c="23282">让我们揭示它们并讨论**<st c="23316">规则</st>**<st c="23321">功能。</st>
- en: <st c="23330">Adding tips rules</st>
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23330">添加提示规则</st>
- en: <st c="23348">Throughout this chapter, we have focused mainly on the UI side
    of displaying tips so far.</st> <st c="23439">However, we already know that tips
    are more than just nice views – they must correspond</st> <st c="23527">to some
    app logic or states.</st> <st c="23556">For example, maybe there are tips that
    we present when the user is logged in.</st> <st c="23634">In a photo app, we can
    show a tip suggesting adding an album after the user takes a certain number</st>
    <st c="23733">of photos.</st>
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23348">在本章中，我们迄今为止主要关注提示显示的UI方面。</st> <st c="23439">然而，我们已经知道提示不仅仅是美观的视图——它们必须与某些应用逻辑或状态相对应。</st>
    <st c="23527">例如，也许当用户登录时，我们会展示一些提示。</st> <st c="23556">在照片应用中，当用户拍摄了一定数量的照片后，我们可以显示一个提示，建议添加相册。</st>
- en: <st c="23743">Tips must often be</st> *<st c="23763">made aware</st>* <st c="23773">of
    users’ flows and states.</st> <st c="23802">That’s why TipKit also contains a
    feature</st> <st c="23844">called rules.</st>
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23743">提示必须经常让用户意识到他们的流程和状态。</st> *<st c="23763">让用户意识到</st>** <st c="23773">用户的状态。</st>
    <st c="23802">这就是为什么TipKit还包含一个名为规则的功能。</st>
- en: <st c="23857">There are two</st> <st c="23872">rule types:</st>
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23857">有两种规则类型：</st>
- en: '**<st c="23883">Based on state</st>**<st c="23898">: Show or hide the tip based
    on a specific state.</st> <st c="23949">The user logged in, performed a particular
    action,</st> <st c="24000">and more.</st>'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="23883">基于状态</st>**<st c="23898">：根据特定状态显示或隐藏提示。</st> <st c="23949">用户登录，执行特定操作，</st>
    <st c="24000">等等。</st>'
- en: '**<st c="24009">Events tracking</st>**<st c="24025">: Show or hide the tip
    based on the number of events the user performed.</st> <st c="24099">For example,
    if the user entered a specific screen in the settings a few times in the past
    week, we could offer for them to create a shortcut for</st> <st c="24245">that
    screen.</st>'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="24009">事件跟踪</st>**<st c="24025">：根据用户执行的事件数量显示或隐藏提示。</st> <st c="24099">例如，如果用户在过去一周内多次进入设置中的特定屏幕，我们可以为他们提供创建该屏幕的快捷方式。</st>
    <st c="24245">的屏幕。</st>'
- en: <st c="24257">Let’s start with adding a rule based on</st> <st c="24298">a state.</st>
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24257">让我们从添加基于状态的规则开始。</st>
- en: <st c="24306">Adding a rule based on a state</st>
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24306">添加基于状态的规则</st>
- en: <st c="24337">Creating rules</st> <st c="24353">based on a state is the common
    way to establish</st> <st c="24401">tip display logic.</st> <st c="24420">What
    is a state?</st> <st c="24437">A state can be an authentication state (is the
    user logged in?), unlocking goods, features usage,</st> <st c="24535">and more.</st>
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24337">基于状态创建规则</st> <st c="24353">是建立提示显示逻辑的常见方法。</st> <st c="24401">什么是状态？</st>
    <st c="24420">状态可以是一个认证状态（用户是否已登录？），解锁商品，功能使用，</st> <st c="24535">等等。</st>
- en: <st c="24544">There are three steps for implementing a rule that is based on</st>
    <st c="24608">a state:</st>
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24544">实现基于状态的规则有三个步骤：</st>
- en: '**<st c="24616">Adding a parameter</st>**<st c="24635">: We need to add a variable
    on which the rule will</st> <st c="24687">be based.</st>'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="24616">添加参数</st>**<st c="24635">：我们需要添加一个规则将基于的变量。</st>'
- en: '**<st c="24696">Define the rule</st>**<st c="24712">: The rules are defined
    inside the tip and should consider the parameter</st> <st c="24786">we discussed.</st>'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="24696">定义规则</st>**<st c="24712">：规则在提示内部定义，应考虑我们讨论的参数。</st>'
- en: '**<st c="24799">Connect the parameter to the app logic</st>**<st c="24838">:
    If we want the rule to be based on our app’s real state, we need to maintain and
    synchronize it with the</st> <st c="24946">app state.</st>'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="24799">将参数连接到应用逻辑</st>**<st c="24838">：如果我们想让规则基于我们应用的真正状态，我们需要维护并与其同步应用状态。</st>'
- en: <st c="24956">Believe it or not, implementing a rule-based tip is even easier
    than it looks!</st> <st c="25036">Let’s try to build a tip encouraging our users
    to use a premium-only feature such as changing the</st> <st c="25134">app theme.</st>
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24956">信不信由你，基于规则的提示实现甚至比看起来还要简单！</st> <st c="25036">让我们尝试构建一个提示，鼓励我们的用户使用仅限高级功能的操作，比如更改应用主题。</st>
    <st c="25134">应用主题。</st>
- en: <st c="25144">Adding a parameter</st>
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25144">添加参数</st>
- en: <st c="25163">The rule needs to rely on persistent data that the app can easily
    modify to track an app state.</st> <st c="25260">To do</st> <st c="25266">that,
    we use the</st> `<st c="25283">@parameter</st>` <st c="25293">macro to add a tracking
    state variable to</st> <st c="25336">our tip.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25163">规则需要依赖于应用可以轻松修改的持久数据来跟踪应用状态。</st> <st c="25260">为了做到这一点，我们使用</st>
    <st c="25283">@parameter</st> <st c="25293">宏将跟踪状态变量添加到</st> <st c="25336">我们的提示中。</st>
- en: <st c="25344">What is a macro?</st>
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25344">宏是什么？</st>
- en: <st c="25361">A macro is</st> <st c="25373">a Swift feature that helps the compiler
    generate code based on the current code and parameters.</st> <st c="25469">You
    can read about macros in</st> [*<st c="25498">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="25508">.</st>
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25361">宏是</st> <st c="25373">Swift的一个特性，它帮助编译器根据当前代码和参数生成代码。</st> <st
    c="25469">您可以在</st> [*<st c="25498">第10章</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="25508">中了解更多关于宏的信息。</st>
- en: <st c="25509">Let’s add a parameter called</st> `<st c="25539">isPremiumUser</st>`
    <st c="25552">to track</st> <st c="25562">premium eligibility:</st>
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25509">让我们添加一个名为</st> `<st c="25539">isPremiumUser</st>` <st c="25552">的参数来跟踪</st>
    <st c="25562">高级资格：</st>
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="25700">Expanding the macro reveals a</st> <st c="25731">simple implementation:</st>
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25700">展开宏可以看到一个</st> <st c="25731">简单的实现：</st>
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="25941">Let’s delve into the macro implementation.</st> <st c="25985">Since
    TipKit wants to work with a generic type, the macro creates another variable called</st>
    `<st c="26075">$isPremiumUser</st>` <st c="26089">of the</st> `<st c="26097">Tips.</st>
    <st c="26103">Parameter</st>` <st c="26112">type (based on</st> `<st c="26128">Bool</st>`<st
    c="26132">) and a default value of</st> `<st c="26158">false</st>` <st c="26163">(as
    initially defined in our</st> <st c="26193">static variable).</st>
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25941">让我们深入了解宏的实现。</st> <st c="25985">由于TipKit想要与通用类型一起工作，宏创建了一个名为</st>
    `<st c="26075">$isPremiumUser</st>` <st c="26089">的变量，它是</st> `<st c="26097">Tips</st>`
    <st c="26103">参数</st> <st c="26112">类型（基于</st> `<st c="26128">Bool</st>`<st c="26132">）的，并且默认值为</st>
    `<st c="26158">false</st>` <st c="26163">（如我们最初在静态变量中定义的那样）。</st>
- en: <st c="26210">The macro</st> <st c="26221">also creates a</st> **<st c="26236">getter</st>**
    <st c="26242">and a</st> **<st c="26249">setter</st>** <st c="26255">so our tip
    can respond to app</st> <st c="26286">state changes.</st>
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26210">该宏</st> <st c="26221">还创建了一个</st> **<st c="26236">获取器</st>** <st
    c="26242">和一个</st> **<st c="26249">设置器</st>** <st c="26255">，这样我们的提示就可以响应应用</st>
    <st c="26286">状态变化。</st>
- en: '<st c="26300">However, the macro handles another thing that helps us: making
    our parameter value</st> **<st c="26384">persistent</st>**<st c="26394">. In this
    case, the answer to the question “Is the user premium?” is probably persistent
    anyway.</st> <st c="26491">However, there are cases where it’s not that obvious.</st>
    <st c="26545">For example, feature usage tracking is not</st> <st c="26588">normally
    persistent.</st>'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26300">然而，宏处理了另一件有助于我们的事情：使我们的参数值</st> **<st c="26384">持久化</st>**<st
    c="26394">。在这种情况下，对于“用户是否是高级用户？”这个问题，答案可能已经是持久的了。</st> <st c="26491">然而，有些情况并不那么明显。</st>
    <st c="26545">例如，功能使用跟踪通常不是</st> <st c="26588">持久的。</st>
- en: <st c="26608">Now that we have a parameter let’s add our first</st> <st c="26658">display
    rule.</st>
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26608">现在我们有了参数，让我们添加第一个</st> <st c="26658">显示规则。</st>
- en: <st c="26671">Defining our display rules</st>
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26671">定义我们的显示规则</st>
- en: <st c="26698">Are we defining display “rules”,</st> <st c="26732">in plural?</st>
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26698">我们是在定义显示“规则”</st> <st c="26732">（复数形式）吗？
- en: <st c="26742">Yes!</st> <st c="26748">TipKit</st> <st c="26755">supports multiple
    display rules to support more complex situations.</st> <st c="26823">However,
    first, let’s start with</st> <st c="26856">one tip:</st>
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26742">是的！</st> <st c="26748">TipKit</st> <st c="26755">支持多个显示规则以支持更复杂的情况。</st>
    <st c="26823">然而，首先，让我们从</st> <st c="26856">一个提示</st> <st c="26863">开始：</st>
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="27016">In this code example, we use a macro to build a data type called</st>
    `<st c="27081">Rule</st>` <st c="27085">that contains a predicate expression.</st>
    <st c="27124">That predicate expression compares the given type to a</st> <st
    c="27179">specific value.</st>
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27016">在这个代码示例中，我们使用宏创建了一个名为</st> `<st c="27081">Rule</st>` <st c="27085">的数据类型，它包含一个谓词表达式。</st>
    <st c="27124">该谓词表达式将给定的类型与一个</st> <st c="27179">特定值进行比较。</st>
- en: <st c="27194">In this case, we compare the</st> `<st c="27224">$isPremiumUser</st>`
    <st c="27238">value</st> <st c="27245">to</st> `<st c="27248">true</st>`<st c="27252">.</st>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27194">在这种情况下，我们比较了</st> `<st c="27224">$isPremiumUser</st>` <st c="27238">的值</st>
    <st c="27245">与</st> `<st c="27248">true</st>`<st c="27252">。</st>
- en: <st c="27253">Now, let’s go</st> <st c="27268">back to the</st> `<st c="27280">rules</st>`
    <st c="27285">variable.</st> <st c="27296">We can add more rules that support
    our tip display logic.</st> <st c="27354">TipKit performs an</st> `<st c="27373">AND</st>`
    <st c="27376">operator between the different tips, and if the result is true,
    then the tip is displayed (unless the user or the app dismisses</st> <st c="27505">it,
    obviously).</st>
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27253">现在，让我们回到</st> <st c="27268">rules</st> <st c="27285">变量。</st>
    <st c="27296">我们可以添加更多支持我们的提示显示逻辑的规则。</st> <st c="27354">TipKit 在不同的提示之间执行一个</st>
    `<st c="27373">AND</st>` <st c="27376">运算符，如果结果是 true，则显示提示（除非用户或应用显然将其关闭）。</st>
- en: <st c="27520">How can we modify the value the rule is based on?</st> <st c="27571">Let’s
    see.</st>
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27520">我们如何修改规则所依据的值？</st> <st c="27571">让我们看看。</st>
- en: <st c="27581">Connecting the parameter to our app logic</st>
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27581">将参数连接到我们的应用逻辑</st>
- en: <st c="27623">We need to connect the tip parameters to our app logic to finalize
    our work.</st> <st c="27701">Notice that the parameter</st> <st c="27727">is a
    static variable.</st> <st c="27749">This means that we can modify it from anywhere
    in our app, even if we don’t have a reference for the</st> <st c="27850">tip instance.</st>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27623">我们需要将提示参数连接到我们的应用逻辑以完成我们的工作。</st> <st c="27701">注意参数</st> <st
    c="27727">是一个静态变量。</st> <st c="27749">这意味着我们可以从我们的应用的任何地方修改它，即使我们没有提示实例的引用。</st>
- en: <st c="27863">Let’s see an essential</st> <st c="27887">parameter modification:</st>
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27863">让我们看看一个重要的</st> <st c="27887">参数修改：</st>
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="28070">This code example shows a basic UI with a button that toggles
    the static</st> `<st c="28144">isPremiumUser</st>` <st c="28157">variable, which
    we created in our tip earlier.</st> <st c="28205">Toggling that value also shows
    and hides the</st> `<st c="28250">TipView</st>` <st c="28257">view down</st> <st
    c="28268">the VStack.</st>
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28070">此代码示例展示了具有一个切换静态</st> `<st c="28144">isPremiumUser</st>` <st c="28157">变量（我们在之前的提示中创建）的按钮的基本
    UI。</st> <st c="28205">切换该值也会在 VStack 中显示和隐藏</st> `<st c="28250">TipView</st>`
    <st c="28257">视图。</st>
- en: <st c="28279">However, adding a button that toggles a tip is not a real-world
    example of using a rule parameter.</st> <st c="28379">A more practical example
    would be connecting it directly to the user’s premium state using a</st> `<st
    c="28472">Combine</st>` <st c="28479">stream – something like the</st> <st c="28508">following
    code:</st>
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28279">然而，添加一个切换提示的按钮并不是使用规则参数的真实世界示例。</st> <st c="28379">一个更实际的例子是将它直接连接到用户的付费状态，使用一个</st>
    `<st c="28472">Combine</st>` <st c="28479">流 – 类似于以下代码：</st>
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'struct AddListTip: Tip { <st c="29926">static let didAddATaskEvent = Event(id:</st>'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct AddListTip: Tip { <st c="29926">静态 let didAddATaskEvent = Event(id:</st>'
- en: '<st c="29965">"didAddATaskEvent")</st> var rules: [Rule] { <st c="30006">#Rule(Self.didAddATaskEvent)
    {</st>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="29965">"didAddATaskEvent")</st> var rules: [Rule] { <st c="30006">#Rule(Self.didAddATaskEvent)
    {</st>'
- en: <st c="30036">$0.donations.count > 3</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30036">$0.donations.count > 3</st>
- en: <st c="30059">}</st> }
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30059">}</st> }
- en: '}'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'struct EventRuleTipExample: View {'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct EventRuleTipExample: View {'
- en: let tip = AddListTip()
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let tip = AddListTip()
- en: '@State var todos: [Todo] = []'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@State var todos: [Todo] = []'
- en: 'var body: some View {'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var body: some View {'
- en: VStack {
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: TipView(tip)
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: TipView(tip)
- en: List(todos) { todo in
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: List(todos) { todo in
- en: Text(todo.title)
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text(todo.title)
- en: '}'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: Spacer()
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Spacer()
- en: Button("Add task") {
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Button("添加任务") {
- en: 'todos.append(Todo(title: "New Task")) <st c="30745">Task{ await</st>'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'todos.append(Todo(title: "新建任务")) <st c="30745">任务{ await</st>'
- en: <st c="30756">AddListTip.didAddATaskEvent.donate()}</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30756">AddListTip.didAddATaskEvent.donate()</st>
- en: <st c="30794">}</st> }
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30794">}</st> }
- en: '}'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: $0.donations.donatedWithin(.days(3)).count > 3
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: $0.donations.donatedWithin(.days(3)).count > 3
- en: $0.donations.donatedWithin(.week).count < 3
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: $0.donations.donatedWithin(.week).count < 3
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="32007">@State var tips = TipGroup(.ordered) {</st>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32007">@State var tips = TipGroup(.ordered) {</st>
- en: <st c="32046">FirstTip()</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32046">FirstTip()</st>
- en: <st c="32057">SecondTip()</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32057">SecondTip()</st>
- en: '<st c="32069">}</st> var body: some View {'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="32069">}</st> var body: some View {'
- en: Button("Settings") {
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Button("设置") {
- en: '}.popoverTip(<st c="32128">tips.currentTip</st>)'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}.popoverTip(<st c="32128">tips.currentTip</st>)'
- en: '}'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '@State var tips = TipGroup(.ordered) {'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '@State var tips = TipGroup(.ordered) {'
- en: SettingsTip()
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: SettingsTip()
- en: ProfileTip()
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ProfileTip()
- en: '}'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'var body: some View {'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var body: some View {'
- en: Button("Settings") {
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Button("设置") {
- en: '}.popoverTip(<st c="33381">tips.currentTip as?</st> <st c="33402">SettingsTip</st>)'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}.popoverTip(<st c="33381">tips.currentTip as?</st> <st c="33402">SettingsTip</st>)'
- en: Button("Profile") {
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Button("个人资料") {
- en: '}.popoverTip(<st c="33449">tips.currentTip as?</st> <st c="33470">ProfileTip</st>)'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}.popoverTip(<st c="33449">tips.currentTip as?</st> <st c="33470">ProfileTip</st>)'
- en: '}'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'public func popoverTip(_ tip: (any Tip)?...)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'public func popoverTip(_ tip: (any Tip)?...)'
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'struct AddListTip: Tip {'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct AddListTip: Tip {'
- en: 'var options: [TipOption] { <st c="34849">Tips.MaxDisplayCount(2)</st> }'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var options: [TipOption] { <st c="34849">最大显示次数(2)</st> }'
- en: '}'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE30]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'struct MyApp: App {'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct MyApp: App {'
- en: init() { <st c="35536">try?</st> <st c="35541">Tips.configure([.displayFrequency(.daily)])</st>
    }
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: init() { <st c="35536">try?</st> <st c="35541">配置显示频率为每日</st> }
- en: '}'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'struct AddListTip: Tip {'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct AddListTip: Tip {'
- en: 'var options: [TipOption] { <st c="35990">Tips.IgnoresDisplayFrequency(true)</st>
    }'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var options: [TipOption] { <st c="35990">忽略显示频率</st> }'
- en: '}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
