<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;OpenGL ES 3.0 Essentials"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. OpenGL ES 3.0 Essentials</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building prototypes using the GLPI framework</li><li class="listitem" style="list-style-type: disc">Implementing touch events</li><li class="listitem" style="list-style-type: disc">Rendering primitives with vertex arrays</li><li class="listitem" style="list-style-type: disc">Drawing APIs in OpenGL ES 3.0</li><li class="listitem" style="list-style-type: disc">Efficient rendering with Vertex Buffer Object</li><li class="listitem" style="list-style-type: disc">Transformations with the model, view, and projection analogies</li><li class="listitem" style="list-style-type: disc">Understanding the projection system in GLPI</li><li class="listitem" style="list-style-type: disc">Culling in OpenGL ES 3.0</li><li class="listitem" style="list-style-type: disc">Depth testing in OpenGL ES 3.0</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Introduction</h1></div></div></div><p>This chapter will provide a detailed description of the basic concepts that are required to understand 3D graphics and implement them using OpenGL ES 3.0. In the beginning of this chapter, we will build a mini portable 3D engine that will be helpful in creating small prototype-based projects quickly. It manages the code effortlessly in the OpenGL ES 3.0 programmable pipeline. You will learn event handling to manage gestures on the screen surface under Android and iOS platforms. These will be helpful in implementing gesture-based applications.</p><p>As we move on, we will discuss the fundamental transformation in the 3D graphics with the help of the model, view, and projection analogy. At the core side, we will look at the different types of available primitives to render a given geometry in OpenGL ES 3.0 and discuss optimization <a id="id97" class="indexterm"/>techniques that could increase rendering performance using <span class="strong"><strong>Vertex Buffer Object</strong></span> (<span class="strong"><strong>VBO</strong></span>). As we approach the end, we will understand geometry culling. It controls the rendering of front or back faces of an object. The last recipe of the chapter will implement depth testing, which is a very important aspect of computational graphics.</p></div></div>
<div class="section" title="Building prototypes using the GLPI framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Building prototypes using the GLPI framework</h1></div></div></div><p>The GLPI is an <a id="id98" class="indexterm"/>OpenGL ES platform-independent framework. It is a mini 3D engine that is highly useful for developing prototype <a id="id99" class="indexterm"/>applications rapidly. It provides higher-level utility classes to render engines, shader compilations, 3D transformations, mesh management, buffer management, textures, and many more. The framework primarily supports Android and iOS platforms and is designed to be easily portable to other platforms such as WinCE, Blackberry, Bada, and so on. We will go through each module of this framework in detail in this chapter.</p><p>This framework provides dedicated modules for rapid development of the OpenGL ES 3.0 prototype applications. It comprises of three main modules, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/5527OT_02_01.jpg" alt="Building prototypes using the GLPI framework"/></div><p>Let's look at each of them in detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GLPI module</strong></span>: This <a id="id100" class="indexterm"/>module is the backbone of the GLPI framework. It contains the following classes inside it:<div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Class</p>
</th><th style="text-align: left" valign="bottom">
<p>Function</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Program Manager</code></p>
</td><td style="text-align: left" valign="top">
<p>This class is responsible for creating the shader program from program objects. It maintains all the program objects in a single manageable piece that other modules can use as and when required.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Shader Manager</code></p>
</td><td style="text-align: left" valign="top">
<p>This class is responsible for generating the shader's object. It automates the processes of loading, compiling, and generating the shader object for the program manager.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Transform</code></p>
</td><td style="text-align: left" valign="top">
<p>This class provides high-level APIs for 3D transformation operations. It also provides wrapper functions to mimic fixed function pipeline APIs, such as transformation, model-view-projection matrices, push and pop matrix operation, and so on.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GLUtils</code></p>
</td><td style="text-align: left" valign="top">
<p>This class provides helper functions for the GLPI module.</p>
</td></tr></tbody></table></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Model module</strong></span>: This <a id="id101" class="indexterm"/>module will help us create custom models for our application. A <code class="literal">Model</code> class essentially represents any type of geometric object that we are interested in rendering on the device screen. This class provides the model's initialization, state management, processing, and rendering routines. It also provides touch events handling within the model.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>The <code class="literal">Model</code> class of the renderer module represents any kind of 3D rendering object that we are interested to render on the screen. For example, if we are willing to render a triangle, then we should be creating a <code class="literal">Triangle</code> class that must be derived from the <code class="literal">Model</code> class and should be added to the <code class="literal">Renderer</code> class as a child member.</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Renderer module</strong></span>: This is the rendering engine's manager that acts as an interface <a id="id102" class="indexterm"/>between the underlying platform (such as Android or iOS) and our platform-independent graphics framework. It manages the entire graphics system rendering life cycle. In <a id="id103" class="indexterm"/>addition to this, the custom <a id="id104" class="indexterm"/>models created by us will also be managed by it.</li></ul></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>How to do it...</h2></div></div></div><p>In the previous chapter, we implemented the Hello World Triangle recipe for Android and iOS platforms. Now, you will learn to use the GLPI framework by reimplementing the same recipe in GLPI. You can refer to the source code of this recipe by locating <code class="literal">GLPIFrameworkIntro</code> in the sample code of this chapter. In the following steps, we will set up the GLPI framework for Android/iOS platforms and learn to use it.</p><p><span class="strong"><strong>Follow these instructions to set up GLPI for the Android platform</strong></span>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">Android.mk</code> makefile as. The makefile includes the path of the <code class="literal">zlib</code> makefile for compilation purpose. It is used to read/write compressed files. The <code class="literal">zlib</code> file is compiled as a shared library and included in the project. The additional libraries include <code class="literal">-lEGL -lGLESv3</code>, which provides support for EGL, and OpenGL ES 3.0 and <code class="literal">-llog</code>, which allow log information that would be helpful in debugging the application:<div class="informalexample"><pre class="programlisting"># Get the current local of the working directory
MY_CUR_LOCAL_PATH := $(call my-dir)

# Initialize variables to store relative directories
FRAMEWORK_DIR      = ../../../../GLPIFramework
SCENE_DIR          = ../../Scene
GLM_SRC_PATH       = $(FRAMEWORK_DIR)/glm
ZLIB_DIR           = $(FRAMEWORK_DIR)/zlib

# Clear the any garbage variable and include ZLIB
include $(CLEAR_VARS)
include $(MY_CUR_LOCAL_PATH)/../../../../GLPIFramework/zlib/Android.mk

LOCAL_PATH := $(MY_CUR_LOCAL_PATH)
include $(CLEAR_VARS)

# Name of the library
LOCAL_MODULE     :=   glNative

# Include the library and GLPI framework files
LOCAL_C_INCLUDES :=   $(GLM_SRC_PATH)/core \
                      $(GLM_SRC_PATH)/gtc \
                      $(GLM_SRC_PATH)/gtx \
                      $(GLM_SRC_PATH)/virtrev \
                      $(ZLIB_DIR) \
                      $(FRAMEWORK_DIR) \
                      $(SCENE_DIR)

# Specify the source files to compile
LOCAL_SRC_FILES :=    $(FRAMEWORK_DIR)/GLutils.cpp \
                      $(FRAMEWORK_DIR)/Cache.cpp \
                      $(FRAMEWORK_DIR)/ShaderManager.cpp \
   $(FRAMEWORK_DIR)/ProgramManager.cpp \
   $(FRAMEWORK_DIR)/Transform.cpp \
   $(SCENE_DIR)/Model.cpp \
   $(SCENE_DIR)/Renderer.cpp \
   $(SCENE_DIR)/Triangle.cpp \
   ../../NativeTemplate.cpp

# include necessary libraries
LOCAL_SHARED_LIBRARIES    := zlib
LOCAL_LDLIBS              :=  -llog -lEGL -lGLESv3

# Build as shared library
include $(BUILD_SHARED_LIBRARY)</pre></div></li><li class="listitem">Create a <a id="id105" class="indexterm"/>new make-file <code class="literal">Application.mk</code> in the same directory and add STL, RTTI, and exception support to your project as shown in the following lines of code. For OpenGL ES 3.0, the Android platform API level must be 18 or greater:<div class="informalexample"><pre class="programlisting">APP_PLATFORM    := android-18
APP_STL         := gnustl_static
APP_CPPFLAGS    := -frtti –fexceptions</pre></div></li><li class="listitem">The chapters from now onwards contain two separate sections for Android and iOS development. These sections will be identified by folder names called Android and iOS. <code class="literal">NativeTemplate.h</code> and <code class="literal">NativeTemplate.cpp</code> (as described in the first chapter) are placed next to these folders. If we look at these files now, we will realize that they are much cleaner and contain lesser code than <a id="id106" class="indexterm"/>earlier. We have moved <a id="id107" class="indexterm"/>the code from these files to other files in the <code class="literal">Scene</code> folder:<div class="mediaobject"><img src="graphics/5527OT_02_02.jpg" alt="How to do it..."/></div></li><li class="listitem">The <code class="literal">Scene</code> folder contains the <code class="literal">Model</code> and <code class="literal">Renderer</code> classes that take care of generating models and rendering them. Another class that is present in this folder is the <code class="literal">Triangle</code> class. It contains the code to render the blue triangle. Make sure that all classes are included in <code class="literal">Android.mk</code>:<div class="mediaobject"><img src="graphics/5527OT_02_03.jpg" alt="How to do it..."/></div></li><li class="listitem">Create a new folder called <code class="literal">Shader</code> under the <code class="literal">assets</code> folder and create the shader files (<code class="literal">BlueTriangleVertex.glsl</code> and <code class="literal">BlueTriangleFragment.glsl</code>) inside this folder. Move the shader programs that were earlier present in <code class="literal">NativeTemplate.cpp</code> (in the form of a string) into the newly created <code class="literal">Shader</code> folder. From now on, we will manage our shader programs in this folder.<div class="mediaobject"><img src="graphics/5527OT_02_04.jpg" alt="How to do it..."/></div></li></ol></div><p><span class="strong"><strong>For iOS, the steps to set up the framework are relatively easy and are listed here</strong></span>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import (<span class="strong"><strong>Xcode</strong></span> | <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Add Files to &lt;Project&gt;</strong></span>) all the GLPI framework contents into your project, except the <code class="literal">zlib</code> library. This library is only used for Android for file management. It is not required by iOS.</li><li class="listitem">In the imported contents, go to the <code class="literal">glm</code> library and remove the <code class="literal">core</code> folder (this folder contains some sample programs that may cause errors in the existing project because of the presence of multiple <code class="literal">main()</code> entries).</li><li class="listitem">Import the <a id="id108" class="indexterm"/>shader files by going to <a id="id109" class="indexterm"/><code class="literal">Android</code> | <code class="literal">Asset</code> | <code class="literal">Shader</code> folder (<code class="literal">BlueTriangleVertex.glsl</code> and <code class="literal">BlueTriangleFragment.glsl</code> ) into the current project.</li><li class="listitem">Set the <code class="literal">"FILESYSTEM"</code> environment variable in <code class="literal">main.m</code>. This will provide the current path of the application in the device:<div class="informalexample"><pre class="programlisting">setenv( "FILESYSTEM", argv[ 0 ], 1 );</pre></div><div class="mediaobject"><img src="graphics/5527OT_02_05.jpg" alt="How to do it..."/></div></li></ol></div><p>The use of the GLPI framework is very simple. We must follow this set of rules in order to render our 3D geometric models:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new custom model class that is derived from the <code class="literal">Model</code> class. For example, we have created the <code class="literal">Triangle</code> class that was derived from the <code class="literal">Model</code> class in <code class="literal">Triangle.h</code>:<div class="informalexample"><pre class="programlisting">class Triangle : public Model{
private:
    // variables for holding attribute values
    GLuint positionAttribHandle,colorAttribHandle;
    GLuint radianAngle;
    
    float degree; // Rotation in degree form
    float radian; // Rotation in radian form

public:
    Triangle(Renderer* parent = 0); // Constructor
    ~Triangle();                    // Destructor

    void InitModel();  // Initialize the model here
    void Render();    // Perform the rendering
};</pre></div></li><li class="listitem">Open <code class="literal">constant.h</code> and edit enum <code class="literal">ModelType</code>. Add the enumeration of your choice to <a id="id110" class="indexterm"/>recognize the model type. For example, there are two enums added for <code class="literal">Triangle</code> and <code class="literal">Cube</code>. This <a id="id111" class="indexterm"/>enumeration will be helpful for the renderer to manage model objects:<div class="informalexample"><pre class="programlisting">enum ModelType{
   //! The Triangle Model identifier.
   TriangleType    = 0,
   CubeType        = 1
};</pre></div></li><li class="listitem">In the constructor of <code class="literal">Triangle</code>, define <code class="literal">ModelType</code>. Each model contains the renderer object as its parent. It also contains reference to <code class="literal">ProgramManager</code> and <code class="literal">Transform</code>:<div class="informalexample"><pre class="programlisting">Triangle::Triangle( Renderer* parent ){
   if (!parent) return;

   RenderHandler      = parent;
   ProgramManagerObj  = parent-&gt;RendererProgramManager();
   TransformObj       = parent-&gt;RendererTransform();
   modelType          = TriangleType;
   degree             = 0;
}</pre></div></li><li class="listitem">Create the <code class="literal">VERTEX_SHADER_PRG</code> and <code class="literal">FRAGMENT_SHADER_PRG</code> macros in <code class="literal">Triangle.cpp</code> to define the relative path of the shader files in the iOS and Android platforms. These macros provides a platform-independent way to access the shader source code files from the project solution:<div class="informalexample"><pre class="programlisting">#ifdef __APPLE__
#define VERTEX_SHADER_PRG "BlueTriangleVertex.glsl"
#define FRAGMENT_SHADER_PRG "BlueTriangleFragment.glsl"
#else
#define VERTEX_SHADER_PRG "shader/BlueTriangleVertex.glsl"
#define FRAGMENT_SHADER_PRG "shader/BlueTriangleFragment.glsl"
#endif</pre></div></li><li class="listitem">Override the <a id="id112" class="indexterm"/><code class="literal">InitModel()</code> function. Here, we need to compile our shader and register it with <code class="literal">ProgramManager</code> for the future use. <code class="literal">ProgramManager</code> stores the compiled <a id="id113" class="indexterm"/>shaders in an optimal way to provide quick access to the queried attributes. Always provide a name to the shader (in our case, <code class="literal">Triangle</code>). <code class="literal">ProgramManager</code> uses it as a handle, which will be helpful to retrieve the shader from any type of model class:<div class="informalexample"><pre class="programlisting">void Triangle::InitModel(){
if(!(program = ProgramManagerObj-&gt;Program
 ( ( char* )"Triangle") )){
   program = ProgramManagerObj-&gt;ProgramInit
( ( char * )"Triangle" );
   ProgramManagerObj-&gt;AddProgram( program );
 }
 // Initialize Shader 
 program-&gt;VertexShader   = ShaderManager::ShaderInit
               (VERTEX_SHADER_PRG, GL_VERTEX_SHADER);
 program-&gt;FragmentShader = ShaderManager::ShaderInit
               (FRAGMENT_SHADER_PRG, GL_FRAGMENT_SHADER);
 
 // Allocate the buffer memory for shader source 
 CACHE *m = reserveCache( VERTEX_SHADER_PRG, true );
 if( m ) {
   if(!ShaderManager::ShaderCompile
     (program-&gt;VertexShader,(char*)m-&gt;buffer, 1)) exit(1);
      mclose( m );
 }

 m = reserveCache( FRAGMENT_SHADER_PRG, true );
 if( m ) {
   if(!ShaderManager::ShaderCompile
      (program-&gt;FragmentShader,(char*)m-&gt;buffer,1))exit(2);
       mclose( m );
 }
 // Link and Use the successfully compiled shader
 if(!ProgramManagerObj-&gt;ProgramLink(program,1)) exit(3);
 glUseProgram( program-&gt;ProgramID );
}</pre></div></li><li class="listitem">Override the <code class="literal">Render()</code> function. It is responsible for rendering the colored triangle on the screen surface. In this function, first, the shader program is used to query the respective attributes. These attributes are used to send the data to the <a id="id114" class="indexterm"/>shader. Each frame of the <a id="id115" class="indexterm"/>triangle is rotated by 1 degree and updated in the shader:<div class="informalexample"><pre class="programlisting">void Triangle::Render(){
   // Use the shader program for this render
   glUseProgram( program-&gt;ProgramID );

    radian = degree++/57.2957795;
    
    // Query and send the uniform variable.
    radianAngle = glGetUniformLocation
                (program-&gt;ProgramID, "RadianAngle");
    glUniform1f(radianAngle, radian);

    
    positionAttribHandle = ProgramManagerObj-&gt;
                   ProgramGetVertexAttribLocation
                   (program,(char*)"VertexPosition");
    colorAttribHandle = ProgramManagerObj-&gt;
                  ProgramGetVertexAttribLocation
                  (program, (char*)"VertexColor");
 
    // Send the data to the shader    
    glVertexAttribPointer(positionAttribHandle, 2,
          GL_FLOAT, GL_FALSE, 0, gTriangleVertices);
    glVertexAttribPointer(colorAttribHandle, 3, 
          GL_FLOAT, GL_FALSE, 0, gTriangleColors);
    
    // Enable the attribute and draw geometry 
    glEnableVertexAttribArray(positionAttribHandle);
    glEnableVertexAttribArray(colorAttribHandle);
    glDrawArrays(GL_TRIANGLES, 0, 3); 
  }</pre></div></li><li class="listitem">Destroy the shaders when they are not required. For this recipe, we will use the destructor:<div class="informalexample"><pre class="programlisting">  Triangle::~Triangle(){
    // Remove the shader in the destructor
    if (program = ProgramManagerObj-&gt;Program
                  ((char*) "Triangle"))
    {   ProgramManagerObj-&gt;RemoveProgram(program); }
  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The shader created in our class is publicly accessible to other models in our rendering engine. Therefore, it is completely up to us whether to destroy it or to keep it in the rendering engine.</p></div></div></li><li class="listitem">Inside <a id="id116" class="indexterm"/><code class="literal">Renderer.cpp</code>, add the <a id="id117" class="indexterm"/><code class="literal">Triangle</code> model in <code class="literal">Renderer::createModels()</code> after the <code class="literal">clearModels()</code> function:<div class="informalexample"><pre class="programlisting">void Renderer::createModels(){
  clearModels();
  addModel(new Triangle(this )); //Add custom models here
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The <code class="literal">clearModels()</code> ensures that there is no conflict in the rendering engine for the <code class="literal">Model</code> object and shaders. Therefore, it provides a clean approach to avoid any redundancy in OpenGL ES shaders.</p></div></div></li><li class="listitem">Override the <code class="literal">Render()</code> function. This function is responsible for making the rendering model to appear on the screen.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>How it works...</h2></div></div></div><p>The <code class="literal">Renderer</code> class is the manager of the rendering system. Each custom model defined in the GLPI framework acts as a registered member of <code class="literal">Renderer</code> and is recognized by its unique model type. <code class="literal">Renderer</code> provides services to the registered components through utility and helper classes such as <code class="literal">Transform</code> and <code class="literal">ProgramManager</code> interfaces. The rendering engine iterates through the entire registered models to define their life cycles. It ensures that the initialization, rendering, and destruction of the models takes place at the right time and in the right order.</p><p>The <code class="literal">ProgramManager</code> is responsible for compiling the shader and caches it for later use. Transform plays a vital role in the geometric transformation operations. For example, it helps in placing models in the 3D space using rotation, translation, and scaling operations.</p><p>For more information on the internals of the 3D transformation, you can refer to <span class="emphasis"><em>Understanding transformation in 3D graphics</em></span> in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0</em></span>. This topic covers types of transformation, transformation matrix conventions, homogenous coordinates, and transformation operations such as translation, scaling, and rotation.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>There's more...</h2></div></div></div><p>Inside the <a id="id118" class="indexterm"/>
<code class="literal">Renderer</code> class, the scene's projection can be adjusted using the <code class="literal">setUpProjection()</code> function. This function is responsible for <a id="id119" class="indexterm"/>setting the view clipping planes. The clipping plane can be defined in the form of frustum (perspective) or cuboid (orthographic) shape. We will discuss more about projections later in this chapter in the <span class="emphasis"><em>Understanding the projection system in GLPI</em></span> recipe.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Developing an Android OpenGL ES 3.0 application</em></span> and <span class="emphasis"><em>Developing an iOS OpenGL ES 3.0 application</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <span class="emphasis"><em>OpenGL ES 3.0 on Android/iOS</em></span></li></ul></div></div></div>
<div class="section" title="Implementing touch events"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Implementing touch events</h1></div></div></div><p>Today's <a id="id120" class="indexterm"/>smartphones are capable of interacting with applications through gestures. These gestures are made on the surface of the touch-sensitive device screen. When the device senses these gesture inputs, it reports the touch events to the corresponding application handler. The application handler receives these events and filters them out, according to the application's requirement. In this recipe, we will implement the touch events using OpenGL ES 3.0 on iOS and Android platforms. You will learn to receive the events and handle them in a platform-independent way.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>Getting ready</h2></div></div></div><p>The <code class="literal">GLSurfaceView</code> class in Android and <code class="literal">GLKViewController</code> in iOS provide the necessary APIs to implement touch events. These APIs report the nature of detected touch events, such as if the user has tapped or moved their figure on the device screen. These APIs are exposed to the GLPI framework through common touch event interfaces. These interfaces are responsible for reporting and propagating the touch events to the registered members. The base class of the registered member (<code class="literal">Model</code>) contains all the touch event interfaces that can be handled by the derived versions. Since these are the only interfaces, the registered members need to override them in order to use them according to their custom needs.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>How to do it...</h2></div></div></div><p>This section will provide a detailed description of how to set up and implement touch events on the Android and iOS platforms.</p><p>First, implement the common interfaces in the <code class="literal">NativeTemple</code> and <code class="literal">Renderer</code> classes that can receive the touch events in a common fashion, irrespective of the platform implementation.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare and <a id="id121" class="indexterm"/>define the touch event interface in the <code class="literal">Renderer</code> class. For example, the following code shows the tap event implementation:<div class="informalexample"><pre class="programlisting">   // Declaration
   void TouchEventDown(float x, float y);

   // Definition
   void Renderer::TouchEventDown( float x, float y ){
   for( int i=0; i&lt;RenderMemData.models.size(); i++ ){
       RenderMemData.models.at(i)-&gt;TouchEventDown(x, y);
   }
}</pre></div></li><li class="listitem">In <code class="literal">NativeTemple.h</code>/<code class="literal">.cpp</code>, call the renderer's touch events from the globally declared and defined wrapper functions:<div class="informalexample"><pre class="programlisting">void TouchEventDown( float x, float y ) // Declaration
void TouchEventDown( float x, float y ){ // Definition
   Renderer::Instance().TouchEventDown( x, y );
}</pre></div></li><li class="listitem">On the Android platform, we need to define new JNI native methods in <code class="literal">NativeTemplate.h</code>/<code class="literal">.cpp</code> that can communication with the Android framework in order to retrieve the touch events. For this, define the following interface for tap events in the <code class="literal">GLESNativeLib</code> Java class:<div class="informalexample"><pre class="programlisting">public static native void TouchEventStart(float x,float y);</pre></div></li><li class="listitem">In <code class="literal">NativeTemplate</code>, declare and define the JNI interface for the tap event declared earlier:<div class="informalexample"><pre class="programlisting">// Declaration of Tap event
JNIEXPORT void JNICALL 
Java_cookbook_gles_GLESNativeLib_TouchEventStart 
                         (JNIEnv * env, jobject obj, float x, float y );

// Definition of Tap event
JNIEXPORT void JNICALL
Java_cookbook_gles_GLESNativeLib_TouchEventStart
                         (JNIEnv * env, jobject obj, float x, float y )
{
   TouchEventDown(x ,y);
      }</pre></div></li><li class="listitem">Repeat steps 1 to 4 to implement the move and release touch events.</li><li class="listitem">Override <code class="literal">onTouchEvent()</code> of the <code class="literal">GLSurfaceView</code> class. This function provides various types of touch events. For example, the tap, move, single/multi touch, and so on are some of the important events. These events needs to be filtered in order that they can be used:<div class="informalexample"><pre class="programlisting">public boolean onTouchEvent( final MotionEvent e ){
  switch( event.getAction() ){
  case MotionEvent.ACTION_DOWN: // Tap event
  GLESNativeLib.TouchEventStart(e.getX(0),e.getY(0));
  break;
          
  case MotionEvent.ACTION_MOVE: // Move event
  GLESNativeLib.TouchEventMove (e.getX(0), e.getY(0)); 
  break;

  case MotionEvent.ACTION_UP: // Release event
  GLESNativeLib.TouchEventRelease(e.getX(0),e.getY(0));
  break;
  }
  return true;
}</pre></div></li><li class="listitem">On the iOS <a id="id122" class="indexterm"/>platform, the GLKit's <code class="literal">GLKViewController</code> class provides touch functions that need to be overridden in order that they can be used in our application. For example, have a look at the following code. It implements the tap, move, and release events similar to the Android case. Each of the definitions calls the global wrapper functions of <code class="literal">NativeTemplate.h</code>/<code class="literal">.cpp</code>:<div class="informalexample"><pre class="programlisting">- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent *)event{
   UITouch *touch; CGPoint pos;
   for( touch in touches ){
       pos = [ touch locationInView:self.view ];
       TouchEventDown( pos.x, pos.y ); //The global wrapper
   }
}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{
   UITouch *touch; CGPoint pos;
   for( touch in touches ){
      pos = [ touch locationInView:self.view ];
      TouchEventMove( pos.x, pos.y ); // The global wrapper
   }
}

- (void)touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event{
   UITouch *touch; CGPoint pos;
   for( touch in touches ){
      pos = [ touch locationInView:self.view ];
      TouchEventRelease(pos.x,pos.y); // The global wrapper
   }
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>How it works...</h2></div></div></div><p>When an Android or iOS application receives the touch event from the device, it is the responsibility of <code class="literal">GLSurfaceView</code> and <code class="literal">GLKViewController</code> to convey these touch events to the external world. These classes report the touch events to the global wrapper function that is defined in the <code class="literal">NativeTemple</code>. This file provides higher level cross-platform functions for touch events such as tap, move, and release. These functions are internally interfaced with the <a id="id123" class="indexterm"/>corresponding touch event interfaces of the <code class="literal">Renderer</code> class. The <code class="literal">Renderer</code> class provides the interface to handle touch events in an abstracted way in which it works seamlessly on either platform. These functions or interfaces are called from the Android or iOS platform through <code class="literal">NativeTemplates</code> global methods and propagated to all the registered models. For instance, the following example shows the handling of the move event:</p><div class="informalexample"><pre class="programlisting">void Renderer::TouchEventMove( float x, float y ){
   for( int i=0; i&lt;RenderMemData.models.size(); i++ ){
      // Handle the Touch events at model levels.
      RenderMemData.models.at(i)-&gt;TouchEventMove(x, y);
   }
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Depth testing in OpenGL ES 3.0</em></span></li></ul></div></div></div>
<div class="section" title="Rendering primitives with vertex arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Rendering primitives with vertex arrays</h1></div></div></div><p>In OpenGL ES 3.0, the vertex array is a simplest mean to draw the objects in the 3D space. The <a id="id124" class="indexterm"/>objects are drawn with the help of vertices, which are arranged in a specific order guided by the rendering primitives. The <a id="id125" class="indexterm"/>rendering primitives represent how an individual or a set of vertices can assemble to draw a geometry. For example, four vertices can be represented by a point, line, or triangle, as shown here:</p><div class="mediaobject"><img src="graphics/5527OT_02_06.jpg" alt="Rendering primitives with vertex arrays"/></div><p>The vertex array is the way in which the geometric data, such as vertex coordinates, normal coordinates, color information, and texture coordinates, are specified in the form of arrays. In this recipe, you will learn to program a vertex array in the GLPI framework. In addition to this, we will also demonstrate various available rendering primitives in OpenGL ES 3.0.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How to do it...</h2></div></div></div><p>Create a new class <a id="id126" class="indexterm"/>called <code class="literal">Primitive</code> derived from the <code class="literal">Model</code> class and follow this step-by-step procedure to implement the rendering primitive with the vertex array:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create <code class="literal">PrimitiveVertex.glsl</code> and <code class="literal">PrimitiveFragment.glsl</code> and use the following code for the vertex and fragment shaders:<div class="informalexample"><pre class="programlisting">// Source code PrimitiveVertex.glsl
#version 300 es
in vec4 VertexPosition, VertexColor;
out vec4 VarColor;
uniform mat4 ModelViewProjectMatrix;

void main(){
  gl_Position = ModelViewProjectMatrix * VertexPosition;
  VarColor    = VertexColor;
}

// Source code PrimitiveFragment.glsl
#version 300 es
precision mediump float;

in vec4 VarColor;
out vec4 FragColor;
void main() {
  FragColor = vec4(VarColor.x,VarColor.y,VarColor.z,1.0);
}</pre></div></li><li class="listitem">Create a set of 10 vertices, as shown in the following figure. Then, store the information into the vertices array and assign colors to each vertex. The color information is stored in the form of RGB in the colors array.<div class="mediaobject"><img src="graphics/5527OT_02_07.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <code class="literal">initModel</code> function, compile and link the vertex and fragment shaders. On successful creation of the shader program object, query the vertex attributes <code class="literal">VertexPosition</code> and <code class="literal">VertexColor</code> using a GLPI wrapper function called <code class="literal">ProgramGetVertexAttribLocation</code>. This function internally <a id="id127" class="indexterm"/>uses OpenGL ES 3.0 generic <a id="id128" class="indexterm"/>vertex attribute query APIs. Using the wrapper APIs decreases the chances of errors and increases the performance, as these queries are optimized:<div class="informalexample"><pre class="programlisting">  void Primitives::InitModel(){
   // Shaders are compiled and linked successfully
   // Many line skipped, please refer to the code
   glUseProgram( program-&gt;ProgramID ); 
   attribVertex=ProgramManagerObj-&gt;ProgramGetVertexAttribLocation        
               (program, (char*)"VertexPosition");
   attribColor=ProgramManagerObj-&gt;ProgramGetVertexAttribLocation
               (program, (char*)"VertexColor");
  }</pre></div><p><code class="literal">ProgramGetVertexAttribLocation</code> returns the generic attribute location ID. A negative value of the location ID specifies that no attribute with that name exists in the shader.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">char ProgramManager::ProgramGetVertexAttribLocation 
                            (PROGRAM *program, char* name);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the GLPI program object containing shader's information</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the name of the attribute in the shader source program</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Within the same <code class="literal">initModel</code> function, query the uniform using another wrapper API <a id="id129" class="indexterm"/>from the GLPI framework:<div class="informalexample"><pre class="programlisting">  mvp = ProgramManagerObj-&gt;ProgramGetUniformLocation 
               (program,(char*)"MODELVIEWPROJECTIONMATRIX");</pre></div><p><code class="literal">ProgramManager</code> in the GLPI framework provides a high-level wrapper function <code class="literal">ProgramGetUniformLocation</code> to query any uniform type variable from the shader program.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">GLint ProgramGetUniformLocation
                  (PROGRAM *program, char* name);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">program</code></p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id130" class="indexterm"/>is the GLPI program object containing shader's information</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the name of the uniform object in the shader source program</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Create a <code class="literal">RenderPrimitive</code> function and call it inside <code class="literal">Render</code>. Inside this function, send the uniform and per-vertex attribute data to the shader:<div class="informalexample"><pre class="programlisting">  void RenderPrimitives(){
    glDisable(GL_CULL_FACE); // Disable the culling
    glLineWidth(10.0f);      // Set the line width 

    glUniformMatrix4fv( mvp, 1, GL_FALSE,( float * )
     TransformObj-&gt;TransformGetModelViewProjectionMatrix() );
 
    glVertexAttribPointer(attribVertex, 2, GL_FLOAT, 
    GL_FALSE, 0, vertices);
    glVertexAttribPointer(attribColor, 3, GL_FLOAT, 
    GL_FALSE, 0, colors);
   }</pre></div></li><li class="listitem">Enable the vertex and color-generic attributes and draw various primitives using switch case statements:<div class="informalexample"><pre class="programlisting">  glEnableVertexAttribArray(attribVertex);
  glEnableVertexAttribArray(attribColor);
  glDrawArrays(primitive, 0, numberOfElement);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>How it works...</h2></div></div></div><p>This recipe has two arrays, vertices, and colors, which contains the vertex information and color information. There are 10 vertices, and each vertex stores an <code class="literal">X</code>, <code class="literal">Y</code> component. The color information also contains 10 different colors for each vertex. The color information is specified in the RGB color space in the range of 0.0 to 1.0.</p><p>The vertex shader contains two per-vertex attributes, <code class="literal">VertexPosition</code> and <code class="literal">VertexColor</code>. These attributes are uniquely recognized in the program via the attribute location. This location is queried using the <code class="literal">ProgramGetVertexAttribLocation</code> function. The queried attribute serves the purpose of binding vertex array information to the per-vertex attributes. The vertex attribute data is sent using <code class="literal">glVertexAttribPointer</code>.</p><p>Similarly, the uniform variable is also queried in the same fashion using a separate function called <code class="literal">ProgramGetUniformLocation</code>. The uniform variable is a 4 x 4 matrix of <code class="literal">ModelViewProjection</code>. Therefore, the data is sent to the shader using <code class="literal">glUniformMatrix4fv</code>. The <code class="literal">glLineWidth</code> function is meant for the <code class="literal">GL_LINE</code> variant primitives to define the width of the line as 10 pixels wide.</p><p>Finally, the OpenGL ES 3.0 primitives are rendered using <code class="literal">glDrawArrays</code>. Various primitive rendering <a id="id131" class="indexterm"/>can be seen in action by a simple tap on the <a id="id132" class="indexterm"/>screen. Upon tapping, the tap event will invoke the <code class="literal">TouchEventDown</code> function of the <code class="literal">Primitive</code> class, which is responsible for changing the current primitive type for rendering:</p><div class="mediaobject"><img src="graphics/5527OT_02_08.jpg" alt="How it works..."/></div><p>In computer 3D graphics, the polygon shapes are rendered using the triangle primitives. Using <code class="literal">GL_TRIANGLE_STRIP</code>, as compared to <code class="literal">GL_TRIANGLES</code>, is preferred because the number of vertices needed to specify the shape of the triangle is lesser when compared to <code class="literal">GL_TRIANGLES</code>. In the latter case, more data has to be sent from the CPU to the GPU, as adjacent edges share common vertices. In the former case, the vertices are arranged in a special order in which duplicate vertices from the shared edges are avoided. Hence, it requires less data. It is true that <code class="literal">GL_TRIANGLE_STRIP</code> may be better in certain cases due to lesser data needed to be defined. However, this needs to be considered on a case-by-case basis, depending on the 3D model format.</p><p>There are plenty of tools available that can be used to convert the geometry information in the triangle-strip form. For <a id="id133" class="indexterm"/>example, nVIDIA's <code class="literal">NvTriStrip</code> library generates triangle strips from an arbitrary 3D geometry. For more information, visit <a class="ulink" href="http://www.nvidia.com/object/nvtristrip_library.html">http://www.nvidia.com/object/nvtristrip_library.html</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>For more information on the drawing APIs, refer to the <span class="emphasis"><em>Drawing APIs in OpenGL ES 3.0</em></span> recipe. It demonstrates <code class="literal">glDrawArrays</code> and <code class="literal">glDrawElements</code>.</p></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>There's more…</h2></div></div></div><p>This section will focus <a id="id134" class="indexterm"/>on the basic rendering primitives available in OpenGL ES 3.0. Primitives are the simplest shapes that can be used to generate <a id="id135" class="indexterm"/>any complex shape in 3D graphics. The OpenGL ES 3.0 primitives can be categorized into three basic types: point, line and triangle. The rest are variations of these.</p><p>The following table describes all the variant primitives of point, line, and triangle available in OpenGL ES 3.0:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Primitive types</p>
</th><th style="text-align: left" valign="bottom">
<p>Input vertex</p>
</th><th style="text-align: left" valign="bottom">
<p>Output shape</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_POINTS</code></p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_09.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_10.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<p>A point on the screen that represents each vertex.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_LINES</code></p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_11.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_12.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<p>Each pair of vertices is used to render a line between them. We can use the <code class="literal">glLineWidth()</code> API to control the width of the line rendering.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_LINE_LOOP</code></p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_13.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_14.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<p>Each vertex makes a line between itself and the vertex preceding it. The last vertex always joins the first vertex to form a closed loop.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_LINE_STRIP</code></p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_15.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_16.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<p>Each vertex makes a line between itself and the vertex preceding it.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_TRIANGLES</code></p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_17.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_18.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<p>A set of three vertices is used to form a filled triangle.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_TRIANGLE_STRIP</code></p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_19.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_20.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<p>Every vertex makes a triangle with the preceding two vertices.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_TRIANGLE_FAN</code></p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_21.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/5527OT_02_22.jpg" alt="There's more…"/></div>
</td><td style="text-align: left" valign="top">
<p>Every vertex makes a triangle with the first vertex and the vertex preceding it. This generates a fan-like pattern.</p>
</td></tr></tbody></table></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <span class="emphasis"><em>Using uniform </em></span><a id="id136" class="indexterm"/><span class="emphasis"><em>variables to send data to a </em></span><a id="id137" class="indexterm"/><span class="emphasis"><em>shader</em></span> and <span class="emphasis"><em>Using per-vertex attribute to send data to a shader</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. OpenGL ES 3.0 on Android/iOS">Chapter 1</a>, <span class="emphasis"><em>OpenGL ES 3.0 on Android/iOS</em></span></li></ul></div></div></div>
<div class="section" title="Drawing APIs in OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Drawing APIs in OpenGL ES 3.0</h1></div></div></div><p>OpenGL ES 3.0 <a id="id138" class="indexterm"/>provides two types of rendering APIs: <code class="literal">glDrawArrays</code> and <code class="literal">glDrawElements</code>. These APIs allows us to render the geometric data on the screen in the form of <a id="id139" class="indexterm"/>primitives. In this recipe, you will learn how these APIs are used in programming and understand the difference between them.</p><p>This recipe will render a cube by using the two different rendering APIs mentioned earlier. The datasets used by these APIs are entirely different. Tap on the screen to see the difference between the two APIs.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>Getting ready</h2></div></div></div><p>The <code class="literal">glDrawArray</code> API reads the vertex information in the form of an array in sequential order, starting from the first index to total number of indexes specified by the count. The <code class="literal">glDrawArray</code> API renders primitives specified by the mode argument using vertex array data information.</p><p><span class="strong"><strong>Syntax</strong></span>:</p><div class="informalexample"><pre class="programlisting">void glDrawArrays( GLenum mode, GLint first, GLsizei count);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">mode</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the type of OpenGL ES primitive that needs to be rendered</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">first</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the start index of the data array</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">count</code></p>
</td><td style="text-align: left" valign="top">
<p>This denotes the total number of indices to be rendered</p>
</td></tr></tbody></table></div><p>For example, a square can be rendered as a set of two triangles:</p><div class="informalexample"><pre class="programlisting">   GLfloat  square[6][3] = {
      -1.0, -1.0, 1.0, /*Vertex0*/  1.0,-1.0, 1.0,  /*Vertex3*/
      -1.0,  1.0, 1.0, /*Vertex1*/  1.0, -1.0, 1.0, /*Vertex3*/
       1.0,  1.0, 1.0, /*Vertex2*/ -1.0,  1.0, 1.0, /*Vertex1*/
   };
  glDrawArrays(GL_TRIANGLES, 0, 18);</pre></div><p>In contrast, the <code class="literal">glDrawElement</code> API maps each vertex using an index similar to the one that accesses elements in an array using C++/Java. This method of rendering consumes less memory compared to <code class="literal">glDrawArray</code>, where each redundant vertex needs to be mentioned with its <code class="literal">X</code>, <code class="literal">Y</code>, and <code class="literal">Z</code> components. For example, take a case of regular cube geometry and <a id="id140" class="indexterm"/>calculate the memory saving offered by <a id="id141" class="indexterm"/>
<code class="literal">glDrawElement</code>.</p><p><span class="strong"><strong>Syntax</strong></span>:</p><div class="informalexample"><pre class="programlisting">void glDrawElements( GLenum mode, GLsizei count, GLenum type, const GLvoid * indices);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">mode</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the primitive type as described in the preceding table</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">count</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the number of elements to be rendered</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">type</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the data type of indices</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">indices</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the order of indices for vertex arrangement in an array form</p>
</td></tr></tbody></table></div><p>For example, the same square can be represented as follows using this API:</p><div class="informalexample"><pre class="programlisting">GLfloat square[4][3] = {
   -1.0, -1.0, 1.0, /*Vertex0*/  -1.0,  1.0, 1.0, /*Vertex1*/
    1.0,  1.0, 1.0, /*Vertex2*/   1.0, -1.0, 1.0, /*Vertex3*/
};
GLushort squareIndices[] = {0,3,1, 3,2,1};   // 6 indices
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, squareIndices);</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>How to do it...</h2></div></div></div><p>The following instructions will provide a step-by-step procedure to demonstrate the use of the <code class="literal">glDrawArrays</code> and <code class="literal">glDrawElements</code> APIs:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">Cube</code> class derived from <code class="literal">Model</code>. There is no change required in the vertex and fragment shaders. <code class="literal">Shaders</code> from the previous recipe can be reused.</li><li class="listitem">Define the <a id="id142" class="indexterm"/>vertex and color dataset for the <code class="literal">glDrawArray</code> API:<div class="mediaobject"><img src="graphics/5527OT_02_23.jpg" alt="How to do it..."/></div></li><li class="listitem">Similarly, define <a id="id143" class="indexterm"/>the dataset for the <code class="literal">glDrawElement</code> API:<div class="mediaobject"><img src="graphics/5527OT_02_24.jpg" alt="How to do it..."/></div></li><li class="listitem">In <code class="literal">InitModel</code>, compile and link the shaders. On successful compilation, query <code class="literal">ModelViewProjectionMatrix</code>, <code class="literal">VertexPosition</code>, <code class="literal">VertexColor</code> and store them into <code class="literal">MVP</code>, <code class="literal">attribVertex</code>, <code class="literal">attribColor</code>, respectively. Enable vertex and color-generic attributes:<div class="informalexample"><pre class="programlisting">   void Cube::InitModel(){
   . . . . . // Load shaders
   glUseProgram( program-&gt;ProgramID );
    
   MVP = ProgramManagerObj-&gt;ProgramGetUniformLocation
                (program, (char*)"ModelViewProjectionMatrix");
   attribVertex=ProgramManagerObj-&gt;ProgramGetVertexAttribLocation 
                (program, (char*)"VertexPosition");
   attribColor = ProgramManagerObj-&gt;ProgramGetVertexAttribLocation
                (program, (char*)"VertexColor");
   // Enable Vertex atrb
glEnableVertexAttribArray(attribVertex);
   // Enable Color atrb
glEnableVertexAttribArray(attribColor);
}</pre></div></li><li class="listitem">Inside the <a id="id144" class="indexterm"/>render function, implement the <a id="id145" class="indexterm"/>following code to demonstrate both APIs in action:<div class="informalexample"><pre class="programlisting">     glUseProgram( program-&gt;ProgramID );
     TransformObj-&gt;TransformRotate(k++, 1.0, 1.0, 1.0);
     glUniformMatrix4fv( MVP, 1, GL_FALSE,(float*)TransformObj-&gt;
    
      if ( useDrawElementAPI ){ //Toggle the flag by tap event
glVertexAttribPointer(attribColor, 3, GL_FLOAT, GL_FALSE, 0, cubeColors);
glVertexAttribPointer(attribVertex, 3, GL_FLOAT, GL_FALSE, 0, cubeVerts);
glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_SHORT, cubeIndices);
      }
      else{
         glVertexAttribPointer(attribColor, 3, GL_FLOAT, 
         GL_FALSE, 0, colorBufferData);
         glVertexAttribPointer (attribVertex, 3, GL_FLOAT, 
         GL_FALSE, 0, vertexBuffer);
         glDrawArrays(GL_TRIANGLES, 0, 36);
      }</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>How it works...</h2></div></div></div><p>The <code class="literal">glDrawArray</code> rendering API uses vertex attributes, such as vertex coordinates, color information, and texture coordinate, in the form of a continuous data array in which the data reading cannot be skipped or hopped. The information is highly redundant, as the same vertices share among the different face are repeatedly written. In this recipe, <code class="literal">vertexBuffer</code> and <code class="literal">colorBufferData</code> store vertex coordinates and color information. This information is sent to the vertex shader using <code class="literal">attribVertex</code> and <code class="literal">attribColor</code>. Finally, the <code class="literal">glDrawArray</code> call is made with parameters specifying the type of primitive and index of the vertices that need to go for rendering (the start and end index).</p><p>In contrast, <code class="literal">glDrawElement</code> uses <code class="literal">cubeVert</code> and <code class="literal">cubeColors</code>, which contain the nonredundant vertex and color information. It uses an additional array that contains the indices of the vertex information. Using this array, the primitives are rendered by hopping around the vertex arrays. Unlike <code class="literal">glDrawArray</code>, which works on the continuous set of vertex data, <code class="literal">glDrawElement</code> can jump from one vertex to another using the index information provided to <a id="id146" class="indexterm"/>it in the last parameter.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>There's more...</h2></div></div></div><p>In <a id="id147" class="indexterm"/>OpenGL ES 3.0, the polygons are drawn as a set of triangles. Each of these triangles has two faces: a front face and back face. For example, the following image represents a square geometry with vertices v0, v1, v2, and v3. It is made up of two triangles. The order of vertex winding (clockwise or anticlockwise) is used by OpenGL ES 3.0 to determine whether the triangle is front facing or back facing. In this case, the vertices are winded in an anticlockwise direction. By default, OpenGL ES 3.0 considers the anticlockwise windings as front facing. This convention can be changed by setting <code class="literal">glFrontFace</code> (counter clockwise) as <code class="literal">GL_CW</code> or <code class="literal">GL_CCW</code> (counter clockwise).</p><p>The winding order is always specified from the user's visualization point of view. The OpenGL ES pipeline takes care of this winding and displays them correctly from the camera's point of view. For example, when we specify the vertices of a cube geometry, it should be in the counter-clockwise order as per the default convention. However, we know very well that the faces that are parallel to each other have opposite winding orders when viewed from the camera's point of view, as shown in the following figure. OpenGL ES automatically generates the correct winding order from the camera's point of view.</p><p>The front and back faces are used in geometry culling. For more information on geometry culling and front/back face <a id="id148" class="indexterm"/>definitions, refer to the <span class="emphasis"><em>Culling in OpenGL ES 3.0</em></span> recipe later in this chapter.</p><div class="mediaobject"><img src="graphics/5527OT_02_25.jpg" alt="There's more..."/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Drawing </em></span><a id="id149" class="indexterm"/><span class="emphasis"><em>APIs in OpenGL ES 3.0</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Culling in OpenGL ES 3.0</em></span></li></ul></div></div></div>
<div class="section" title="Efficient rendering with Vertex Buffer Object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Efficient rendering with Vertex Buffer Object</h1></div></div></div><p>The <a id="id150" class="indexterm"/>vertex information comprises of geometric coordinates, color information, texture coordinates, and normal vectors. This information is stored in the form of an array and always resides in the local memory (RAM, which is <a id="id151" class="indexterm"/>accessible by the CPU) of the device. Each frame when rendering command is executed. This information is copied from the local memory and sent to the GPU. This vertex information is sent over the data bus, which has a slower speed compared to the GPU's processing speed. Additionally, the latency time on the local memory also adds a slight delay.</p><p>VBO is a faster way to render 3D objects. The VBO uses the full advantage of <span class="strong"><strong>Graphics Processor Unit</strong></span> (<span class="strong"><strong>GPU</strong></span>) and store the geometric data on GPU's memory instead of storing it on the local RAM <a id="id152" class="indexterm"/>memory. This helps OpenGL ES to avoid continuous sending of data from local memory to the GPU each time a draw call is made.</p><p>The implementation of the VBO can be divided into four steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new buffer object using <code class="literal">glGenBuffers()</code>.</li><li class="listitem">Bind this buffer object to pipeline with <code class="literal">glBindBuffer()</code>.</li><li class="listitem">Allocate memory to store data using <code class="literal">glBufferData()</code>.</li><li class="listitem">Store/modify the data into portions of the allocated buffer object with <code class="literal">glBufferSubData()</code>.</li></ol></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>How to do it...</h2></div></div></div><p>Follow this <a id="id153" class="indexterm"/>step-by-step procedure to implement the VBO recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a vertex buffer object using the <code class="literal">glGenBuffers</code> API. This API generates n number of vertex buffer objects, where each vertex buffer object is recognized by a unique name or handle returned by this API. This handle is an unsigned <code class="literal">int</code> ID that is used to perform various operations on the VBO.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glGenBuffers(GLsizei n, GLuint* buffers);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">N</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a number of buffer object names that need to be generated</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">buffers</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies an array that contains buffer objects on successful creation</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Bind the <a id="id154" class="indexterm"/>created vertex buffer object IDs to the underlying pipeline with the <code class="literal">glBindBuffer</code> API.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glBindBuffer(GLenum target, GLuint buffer);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">target</code></p>
</td><td style="text-align: left" valign="top">
<p>This specifies the symbolic constant target to which the buffer object name needs to be bound. It could accept <code class="literal">GL_ARRAY_BUFFER</code>, <code class="literal">GL_ELEMENT_ARRAY_BUFFER</code>, <code class="literal">GL_UNIFORM_BUFFER</code>, <code class="literal">GL_TRANSFORM_FEEDBACK_BUFFER</code>, and so on.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">buffers</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the name of the buffer object that we created using <code class="literal">glGenBuffer</code>.</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">Allocate and initialize the memory by specifying the size of the geometric arrays, such as vertex, color, normal, and so on, with <code class="literal">glBufferData</code>.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">target</code></p>
</td><td style="text-align: left" valign="top">
<p>This parameter is similar to what is defined in <code class="literal">glBindBuffer</code>, as described earlier.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">size</code></p>
</td><td style="text-align: left" valign="top">
<p>The size of the buffer needs to be allocated in bytes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">data</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a pointer to the data array that contains geometry information. If this is <code class="literal">NULL</code>, then no data would be copied. The data can be copied later using the <code class="literal">glBufferSubData</code> API.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">usage</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the expected type of pattern used for data store.</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">The <code class="literal">usage</code> <a id="id155" class="indexterm"/>parameter provides hints to the OpenGL ES system about how the data is patterned, so that it can be handled intelligently and efficiently when it comes to storing or accessing the data. This parameter can accept one of the following types:<div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Types</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_STREAM_DRAW</code></p>
</td><td style="text-align: left" valign="top">
<p>This type of vertex buffer data is rendered for a small number of times and then discarded</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_STATIC_DRAW</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a type of buffer data that is rendered many times, and its contents never changes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_DYNAMIC_DRAW</code></p>
</td><td style="text-align: left" valign="top">
<p>This type of buffer data is rendered many times, and its content changes during rendering</p>
</td></tr></tbody></table></div></li><li class="listitem">The <code class="literal">glBufferData</code> creates the buffer data store for the current bound target with the <a id="id156" class="indexterm"/>required size. If the data parameter is initialized with <code class="literal">NULL</code>, then the buffer remains uninitialized. This VBO can be initialized later using the <code class="literal">glBufferSubData</code> API.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void glBufferSubData(GLenum target, GLintptr offset,GLsizeiptr size, const GLvoid * data);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">target</code></p>
</td><td style="text-align: left" valign="top">
<p>This parameter is similar to what is defined in the <code class="literal">glBindBuffer</code> as described earlier</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">offset</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the index on the buffer store, specifying the start location from where the data will be written</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">size</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the data size in bytes that needs to be filled in the buffer store, starting from the offset position</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">data</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a pointer to the new data that will be copied into the data store</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem">The following <a id="id157" class="indexterm"/>program implements the VBO with all the APIs discussed earlier:<div class="informalexample"><pre class="programlisting">float size = 24*sizeof(float);
glGenBuffers(1, &amp;vId);

glBindBuffer(GL_ARRAY_BUFFER, vId );;
glBufferData(GL_ARRAY_BUFFER,size+size,0,GL_STATIC_DRAW);;
glBufferSubData(GL_ARRAY_BUFFER, 0, size, cubeVerts);
glBufferSubData(GL_ARRAY_BUFFER, size,size,cubeColors);

unsigned short indexSize = sizeof( unsigned short )*36;
glGenBuffers(1, &amp;iId);
glBindBuffer(GL_ARRAY_BUFFER, iId);
glBufferData(GL_ARRAY_BUFFER, indexSize,0,GL_STATIC_DRAW);
glBufferSubData(GL_ARRAY_BUFFER,0,indexSize,cubeIndices);
/* Once the VBO created and used, reset the array and element buffer array to its original state after use, this is done by binding 0 to array and element buffer*/ 
glBindBuffer( GL_ARRAY_BUFFER, 0 );
glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );</pre></div></li><li class="listitem">Finally, the rendering will be performed by binding the VBO and specifying the generic <a id="id158" class="indexterm"/>attribute data in terms of offset in the buffer object, as shown here:<div class="informalexample"><pre class="programlisting">// Specify VBO-ID for send attribute data 
glBindBuffer( GL_ARRAY_BUFFER, vId );
glVertexAttribPointer
   (attribVertex, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);glVertexAttribPointer
   (attribColor, 3, GL_FLOAT, GL_FALSE, 0,(void*)size);

// Specify VBO for element index array 
glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iId );
glDrawElements(GL_TRIANGLES,36,GL_UNSIGNED_SHORT,(void*)0);
glBindBuffer( GL_ARRAY_BUFFER, 0 );
glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How it works...</h2></div></div></div><p>The <code class="literal">glGenBuffers</code> API creates a number of vertex buffer objects specified by the first parameter <code class="literal">n</code>. It returns the VBO ID (handle) array if the vertex buffer objects are successfully created.</p><p>Once the VBO are created, they need to bind to the target with the <code class="literal">glBindBuffer</code> API. Basically, the target tells the VBO what type of vertex data it can store. This data can be either a vertex array or an index array data. The vertex array data contains vertex information, such as position, color, texture coordinate, and so on. However, the index array contains the order vertex index information. Therefore, the target could be specified as <code class="literal">GL_ARRAY_BUFFER</code> or <code class="literal">GL_ELEMENT_ARRAY_BUFFER</code>.</p><p>The data size required to fill into the bound vertex buffer object is specified using <code class="literal">glBufferData</code>. We also need to specify the nature of data the VBO is going to store. The final <code class="literal">step</code> is to fill in the buffer object with data. We can use <code class="literal">glBufferSubData</code> to fill the vertex data. The VBO allows us to specify multiple arrays in the same buffer object. We can use offset and size one after the other. Make sure that you bind the buffer object to the current rendering state before rendering with the <code class="literal">glBindBuffer</code> API. The VBO can be <a id="id159" class="indexterm"/>deleted using <code class="literal">glDeleteBuffers</code> <a id="id160" class="indexterm"/>as per the program requirement.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>If an application uses multiple VBO, then it is advisable to bind the VBO to <code class="literal">0</code> after rendering of the model. This way, the original states remain preserved.</p></div></div></div></div>
<div class="section" title="Transformations with the model, view, and projection analogies"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Transformations with the model, view, and projection analogies</h1></div></div></div><p>To define a <a id="id161" class="indexterm"/>rendering scene in computer 3D graphics, model, view, and projection is the cleanest approach. It dissects a scene into these three <a id="id162" class="indexterm"/>logical concepts that helps us visualize the scene clearly before it appears on paper or in the form of a program. It will not be <a id="id163" class="indexterm"/>wrong to say that it is a modular approach to scene visualization.</p><p><span class="strong"><strong>Object</strong></span>: An <a id="id164" class="indexterm"/>object is a defined by a set of vertices in the <a id="id165" class="indexterm"/>3D space. Each object has its own origin. For <a id="id166" class="indexterm"/>example, a cube contains eight vertices <a id="id167" class="indexterm"/>with respect to the origin at the center. The vertices used to define the object are called object coordinates:</p><div class="mediaobject"><img src="graphics/5527OT_02_26.jpg" alt="Transformations with the model, view, and projection analogies"/></div><p><span class="strong"><strong>Model</strong></span>: Modeling in 3D graphics is a transformation process where an object is displaced to an arbitrary position <a id="id168" class="indexterm"/>in the 3D space. This 3D space is called world <a id="id169" class="indexterm"/>space (also known as model <a id="id170" class="indexterm"/>space). For example, we can use several instances of <a id="id171" class="indexterm"/>our cube object and place them in the 3D space so that they form the English alphabet <span class="strong"><strong>T</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Modeling is achievable by a 4 x 4 matrix called the Model Matrix. Programmatically, an identity matrix, which is multiplied by transformation matrices, contains scale, translation, and rotation information. The resultant is the Model Matrix.</p></div></div><p><span class="strong"><strong>Viewing</strong></span>: In simpler terms, we can say that the view is a position in the 3D space from which the model needs to be <a id="id172" class="indexterm"/>viewed. For example, in engineering drawing, there are three types of views: the top, front, and side views. These are produced by moving the camera in the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axes and looking towards the origin of the viewing object. The viewing is a transformation that applies on the world coordinates to produce eye coordinates.</p><div class="mediaobject"><img src="graphics/5527OT_02_27.jpg" alt="Transformations with the model, view, and projection analogies"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Model-view analogy: The model and view concepts we discussed earlier are completely interchangeable. This means that we can do all the view transformations with model transformation and vice versa. For example, we can make the object scale by viewing it closer or placing it near the viewing location. Similarly, translation and rotation operations can also be performed on this object. Therefore, many books represent it as a model-view approach, so don't get confused with this term. Mathematically, model view is just another 4 x 4 matrix that is achieved by multiplying view matrix and the model matrix.</p></div></div><p><span class="strong"><strong>Projection</strong></span>: Projection transformation is the process where a scene is restricted by a clipping region in the form of a frustum or cuboidal. Both forms have six clipping planes that are helpful in restricting the objects, by clipping the objects present outside these clipping planes. This stage <a id="id173" class="indexterm"/>helps the graphics system increase the <a id="id174" class="indexterm"/>performance by considering only a <a id="id175" class="indexterm"/>finite set of objects within the frustum box. The <a id="id176" class="indexterm"/>following figure shows the role of frustum clipping planes. The result of the eye coordinates on projection system is clip coordinates:</p><div class="mediaobject"><img src="graphics/5527OT_02_28.jpg" alt="Transformations with the model, view, and projection analogies"/></div><p><span class="strong"><strong>Normalize view</strong></span>: The <a id="id177" class="indexterm"/>clip coordinates are used to create normalize device coordinates that shrink the clipped view to a unity range by dividing it by <span class="strong"><strong>W</strong></span>, where W is the constant used to create homogenous coordinates.</p><p><span class="strong"><strong>Viewport transformation</strong></span>: This is the final transformation in which the normalize device coordinates are <a id="id178" class="indexterm"/>converted into screen coordinates system (that is, window coordinates):</p><div class="mediaobject"><img src="graphics/5527OT_02_29.jpg" alt="Transformations with the model, view, and projection analogies"/></div><p>The preceding figure shows how the vertex processing takes place in 3D graphics that is transformed from object-coordinate system to appear onto the physical screen in the window-coordinate system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec74"/>Getting ready</h2></div></div></div><p>The model-view-projection is purely a mathematical transformation concept. This is not a part of OpenGL ES 3.0; it's entirely up to an end user to implement these transformations in its own way. This book uses transformations through an open source <code class="literal">maths</code> library called <code class="literal">glm</code> and uses the 0.9.4 version of this library.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p><span class="strong"><strong>OpenGL Mathematics</strong></span> (<span class="strong"><strong>GLM</strong></span>) is a header only C++ mathematics library for graphics software based on the <span class="strong"><strong>OpenGL Shading Language</strong></span> (<span class="strong"><strong>GLSL</strong></span>) specification. You can download this library at <a class="ulink" href="http://glm.g-truc.net">http://glm.g-truc.net</a>.</p><p>The transformation-based function of the GLM library is wrapped under a higher-level class called <code class="literal">Transform</code> in the GLPI framework.</p></div></div><p><span class="strong"><strong>Overview of transformation</strong></span>:</p><p>Transformation is a process by which one coordinate space is converted to another coordinate space, for example, translation, rotation, and scaling. There are two types of transformations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Geometric transformation</strong></span>: This specifies when an object undergoes the transformation relative to the coordinate system.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Coordinate transformation</strong></span>: This specifies when the coordinate system undergoes the transformation and the object remains still.</li></ul></div><p>On the computer, these transformations are stored in the form of 4 x 4 transformation matrices. The transformation matrix used for 3D systems contain 16 elements in a continuous memory location. There are two ways in which multidimensional arrays can be represented in the memory.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Row Major</strong></span>: The element in the memory location is stored row-wise</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Column Major</strong></span>: The element in the memory location is stored column-wise<div class="mediaobject"><img src="graphics/5527OT_02_37.jpg" alt="Getting ready"/></div></li></ul></div><p>Logical representation of matrix in <span class="strong"><strong>Row Major</strong></span> (<span class="strong"><strong>RM</strong></span>) and <span class="strong"><strong>Column Major</strong></span> (<span class="strong"><strong>CM</strong></span>):</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Offset</p>
</th><th style="text-align: left" valign="bottom">
<p>0</p>
</th><th style="text-align: left" valign="bottom">
<p>1</p>
</th><th style="text-align: left" valign="bottom">
<p>2</p>
</th><th style="text-align: left" valign="bottom">
<p>3</p>
</th><th style="text-align: left" valign="bottom">
<p>4</p>
</th><th style="text-align: left" valign="bottom">
<p>5</p>
</th><th style="text-align: left" valign="bottom">
<p>6</p>
</th><th style="text-align: left" valign="bottom">
<p>7</p>
</th><th style="text-align: left" valign="bottom">
<p>8</p>
</th><th style="text-align: left" valign="bottom">
<p>9</p>
</th><th style="text-align: left" valign="bottom">
<p>10</p>
</th><th style="text-align: left" valign="bottom">
<p>11</p>
</th><th style="text-align: left" valign="bottom">
<p>12</p>
</th><th style="text-align: left" valign="bottom">
<p>13</p>
</th><th style="text-align: left" valign="bottom">
<p>14</p>
</th><th style="text-align: left" valign="bottom">
<p>15</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>RM</p>
</td><td style="text-align: left" valign="top">
<p>e1</p>
</td><td style="text-align: left" valign="top">
<p>e5</p>
</td><td style="text-align: left" valign="top">
<p>e9</p>
</td><td style="text-align: left" valign="top">
<p>e13</p>
</td><td style="text-align: left" valign="top">
<p>e2</p>
</td><td style="text-align: left" valign="top">
<p>e6</p>
</td><td style="text-align: left" valign="top">
<p>e10</p>
</td><td style="text-align: left" valign="top">
<p>e14</p>
</td><td style="text-align: left" valign="top">
<p>e3</p>
</td><td style="text-align: left" valign="top">
<p>e7</p>
</td><td style="text-align: left" valign="top">
<p>e11</p>
</td><td style="text-align: left" valign="top">
<p>e15</p>
</td><td style="text-align: left" valign="top">
<p>e4</p>
</td><td style="text-align: left" valign="top">
<p>e8</p>
</td><td style="text-align: left" valign="top">
<p>e12</p>
</td><td style="text-align: left" valign="top">
<p>e16</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>CM</p>
</td><td style="text-align: left" valign="top">
<p>e1</p>
</td><td style="text-align: left" valign="top">
<p>e2</p>
</td><td style="text-align: left" valign="top">
<p>e3</p>
</td><td style="text-align: left" valign="top">
<p>e4</p>
</td><td style="text-align: left" valign="top">
<p>e5</p>
</td><td style="text-align: left" valign="top">
<p>e6</p>
</td><td style="text-align: left" valign="top">
<p>e7</p>
</td><td style="text-align: left" valign="top">
<p>e8</p>
</td><td style="text-align: left" valign="top">
<p>e9</p>
</td><td style="text-align: left" valign="top">
<p>e10</p>
</td><td style="text-align: left" valign="top">
<p>e11</p>
</td><td style="text-align: left" valign="top">
<p>e12</p>
</td><td style="text-align: left" valign="top">
<p>e13</p>
</td><td style="text-align: left" valign="top">
<p>e14</p>
</td><td style="text-align: left" valign="top">
<p>e15</p>
</td><td style="text-align: left" valign="top">
<p>e16</p>
</td></tr></tbody></table></div><p>In order to fix the pipeline OpenGL ES, the convention used for matrices is column major. Programmers have to abide by this convention. However, there is no restriction in the programmable pipeline to use either the row major or column major convention because all matrixes are managed by programmers themselves. It's advisable to stick to the column matrix representation as a convention to avoid any confusion.</p><p><span class="strong"><strong>Vertex representation in the matrix form</strong></span>: A vertex in 3D space is represented by three coordinates (x, y, and z). However, in reality, it's represented by four tuples(x, y, z, and w) instead of three. The forth tuple is called as homogeneous coordinate. In OpenGL ES, all three-dimensional coordinates and vectors use homogenous coordinates.</p><p><span class="strong"><strong>Homogenous coordinates</strong></span>: In homogenous coordinates, one set of coordinates can be represented by different types of coordinates. For example, for 1, 2, and 3, the various homogenous representations can be 5, 10, 15, and 5 or 4, 8, 12, and 4 because they can be simplified in a general form:</p><div class="informalexample"><pre class="programlisting">(a, b , c, w) =&gt; (a/w, b/w, c/w, w/w) =&gt; (a/w, b/w, c/w, 1)</pre></div><p>Therefore, the preceding two coordinates can be deduced as 5/5, 10/5, 15/5, and 5/5 or 4/4, 8/4, 12/4, and 4/4. This is logically equal to 1, 2, 3, and 1.</p><p>The perspective division stage in the fixed/programmable pipeline uses the <code class="literal">w</code> component of clip coordinates to normalize them. For translation purposes, always use the <code class="literal">w</code> component as 1. Therefore, any 3D vertex (x, y, and z) is represented as (x, y, z, and 1).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec75"/>How to do it...</h2></div></div></div><p>Perform the following procedure to implement the model-view-projection paradigm with the help of various mathematical transformation operations:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>For more information on the internals of the 3D transformation, you can refer to the <span class="emphasis"><em>There's more…</em></span> section in this recipe. This section covers transformation operations, such as translation, scaling, and rotation.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When a scene is rendered to the model-view-project information stored in the model, view, and projection matrices. In order to use any of these matrices, use the <code class="literal">TransformSetMatrixMode</code> function from the <code class="literal">Transform</code> class. This class allows you to set the relevant matrix as per the requirement of the application. This API accepts one parameter called mode, which tells the GLPI framework what kind of operation it is presently in; the accepted values of this parameter will be <code class="literal">MODEL_MATRIX</code> (modeling), <code class="literal">VIEW_MATRIX</code> (viewing), or <code class="literal">PROJECTION_MATRIX</code> (projection).<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void Transform::TransformSetMatrixMode( unsigned int mode )</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>You can manipulate these matrices in any arbitrary order before executing the drawing command. This book follows the convention of first processing the projection matrix, which is followed by view and model matrix operations.</p></div></div><p>The projection information is computed in the <code class="literal">Renderer::setupProjection</code> function. For this, the projection matrix needs to be activated first. For more information on projection systems and the working logic under this function, refer to the <span class="emphasis"><em>Understanding the projection system in GLPI</em></span> recipe. This function is responsible for defining the clipping planes for projection frustum; any object that stays in this frustum box will be visible:</p><div class="informalexample"><pre class="programlisting">void Renderer::setUpProjection(){
   Transform*   TransformObj = &amp;RenderMemData.TransformObj;

//Set up the PROJECTION matrix.
   TransformObj-&gt;TransformSetMatrixMode( PROJECTION_MATRIX );
   TransformObj-&gt;TransformLoadIdentity();
// Many lines skipped. 
// For more information refer to next recipe
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Whenever the current matrix is switched, it may contain some garbage or old transformation values. These values can be cleaned by setting the matrix as an identity matrix. This can be done using the <code class="literal">TransformLoadIdentity()</code> function from the <code class="literal">Transform</code> class.</p></div></div></li><li class="listitem">Activate the view matrix in the <code class="literal">Renderer::setupView</code> function. This function is responsible for viewing information. For example, in this recipe, the viewer is <code class="literal">-2</code> and <code class="literal">-15</code> units away from the origin (<code class="literal">0.0f</code>, <code class="literal">0.0f</code>, and <code class="literal">0.0f</code>):<div class="informalexample"><pre class="programlisting">void Renderer::setUpView(){
    Transform*  TransformObj = &amp;RenderMemData.TransformObj;
//Set up the VIEW matrix.
    TransformObj-&gt;TransformSetMatrixMode( VIEW_MATRIX );
    TransformObj-&gt;TransformLoadIdentity();
    
// The viewer is -2 and -15 units away on y and z axis 
    TransformObj-&gt;TransformTranslate(0, -2, -15);
}</pre></div></li><li class="listitem">Now, we are good to go; the rendering where the modeling transformation is preserved. The model matrix is activated in the <code class="literal">Renderer::setupModel</code>. From now on, any modeling transformation is always applied to the model matrix because it's the most recent activated matrix:<div class="informalexample"><pre class="programlisting">void Renderer::setUpModel(){
    Transform*    = &amp;R TransformObj enderMemData.TransformObj;
//Set up the MODEL matrix.
    TransformObj-&gt;TransformSetMatrixMode( MODEL_MATRIX );
    TransformObj-&gt;TransformLoadIdentity();
}</pre></div></li><li class="listitem">Render the drawing objects; the transformation applied to these objects will affect the model matrix.<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create eight simple 3D cubes, such as C1, C2, C3, C4, C5, C6, C7, and C8 each with a dimension of 2 x 2 x 2 logical units (length x breadth x height). Note that units in OpenGL ES are logical.</li><li class="listitem">Keep the C1 at origin. Displace C2 by 2 units, C3 by 4 units, and C4 by 6 units along positive <span class="emphasis"><em>y</em></span> axis.</li><li class="listitem">Displace C5 by 6 units in the positive <span class="emphasis"><em>y</em></span> axis and 2 units in the negative <span class="emphasis"><em>x</em></span> axis. Displace C6 by 6 units in the positive <span class="emphasis"><em>y</em></span> axis and 2 units in the positive <span class="emphasis"><em>x</em></span> axis.</li><li class="listitem">Displace C7 by 6 units in the positive <span class="emphasis"><em>y</em></span> axis and 6 units in the negative <span class="emphasis"><em>x</em></span> axis.</li><li class="listitem">Displace C8 by 6 units in the positive <span class="emphasis"><em>y</em></span> axis and 6 units in the positive <span class="emphasis"><em>x</em></span> axis:<div class="informalexample"><pre class="programlisting">void Cube::Render(){ 

   static float k = 0;
   Transform* TransformObj = MapRenderHandler-&gt;
RendererTransform();
    // Rotate the whole Geometry along Y-Axis
    TransformObj-&gt;TransformRotate(k++, 0, 1, 0);

    // Render C1 Box at Vertical 2 Units Up
    TransformObj-&gt;TransformPushMatrix();
    TransformObj-&gt;TransformTranslate( 0, 2, 0);
    RenderCubeVBO();
    TransformObj-&gt;TransformPopMatrix();

    // Render C2 Box at Vertical 4 Units Up
    TransformObj-&gt;TransformPushMatrix();
    TransformObj-&gt;TransformTranslate( 0, 4, 0);
    RenderCubeVBO();
    TransformObj-&gt;TransformPopMatrix();

    // Similarly, Render C3 to C8 boxes
}</pre></div></li></ol></div><div class="mediaobject"><img src="graphics/5527OT_02_30.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec76"/>How it works...</h2></div></div></div><p>A scene is a composition of model, view, and projection. Each of these has a specific responsibility. Model stores the modeling transformation that is applied to the rendering items, such as rotation or translation. The model matrix (<code class="literal">MODEL_MATRIX</code>) is activated in the <code class="literal">setupModel</code> function. From here on, any kind of model rendering transformation is applied to the model matrix. For example, in the present recipe, various transformations (such as rotation and translation) are applied to a simple 3D cube to render it to different spatial positions. When object coordinates of the cube geometry are applied to model transformations, it yields world coordinates. The selection of the required matrix (model, view, and projection) can be done using <code class="literal">TransformSetMatrixMode</code>.</p><p>The viewing transformation is the middle stage in the scene construction, which is responsible for setting up the view or camera in the 3D space. In other words, it tells you how a scene will be viewed in a 3D space. In the present recipe, the scene is viewed from a position 15 units away from the origin on the <span class="emphasis"><em>z</em></span> axis and <code class="literal">-2</code> units away from the <span class="emphasis"><em>y</em></span> axis. The view transformation is carried out in the <code class="literal">setupView</code> function and it affects the view matrix (<code class="literal">VIEW_MATRIX</code>). The view matrix is applied to world coordinates in order to produce eye coordinates.</p><p>The projection system defines a view volume and keeps track of all objects that falls in it. Only these objects will be rendered. The viewing volume or the frustum consists of six clipping planes. These are constructed in the <code class="literal">setupProject</code> function. Here, the transformation is carried out on the projection matrix (<code class="literal">PROJECTION_MATRIX</code>). This projection matrix uses eye coordinates and converts them to clipping coordinates.</p><p>The following diagram shows the complete process of the vertex life cycle for transformation purposes:</p><div class="mediaobject"><img src="graphics/5527OT_02_31.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec77"/>There's more...</h2></div></div></div><p><span class="strong"><strong>Transformation operation</strong></span>: There are mainly three types of transformations that are majorly used. Each of these transformations is stored in the mathematical column major matrix form under the OpenGL ES convention. These transformations are represented by a 4 x 4 matrix.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Translation</strong></span>: This translation operation occupies the 13th, 14th, and the 15th position in the 4 x 4 transformation matrix or in the row-column format, that is, [0, 3], [1, 3], and [2, 3]. The P vertex (Vx, Vy, and Vz) with T translation (Tx, Ty, and Tz) can be represented in a general form: <span class="emphasis"><em>P' = T.P</em></span>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>The <code class="literal">Transform</code> class provides the <code class="literal">TransformTranslate</code> API for the translation operation.</p></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void TransformTranslate(float Tx, float Ty, float Tz);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variables</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Tx</p>
</td><td style="text-align: left" valign="top">
<p>This specifies the translation distance in a logical unit along the <span class="emphasis"><em>x</em></span> axis</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Ty</p>
</td><td style="text-align: left" valign="top">
<p>This specifies the translation distance in a logical unit along the <span class="emphasis"><em>y</em></span> axis</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Tz</p>
</td><td style="text-align: left" valign="top">
<p>This specifies the translation distance in a logical unit along the <span class="emphasis"><em>z</em></span> axis</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scale</strong></span>: Scale components along <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> components in matrices are represented using diagonal elements. The P vertex (Vx, Vy, and Vz) scaled by the S factor (Sx, Sy, and Sz) can be generalized, as shown in the following figure:<div class="mediaobject"><img src="graphics/5527OT_02_38.jpg" alt="There's more..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>The <code class="literal">Transform</code> class provides the <code class="literal">TransformScale</code> API for the scale operation.</p></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void TransformScale(float Sx, float Sy, float Sz);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Sx</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="strong"><strong>This denotes scaling along the x axis</strong></span></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Sy</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="strong"><strong>This denotes scaling along the y axis</strong></span></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>Sz</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><span class="strong"><strong>This denotes scaling along the z axis</strong></span></p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rotation</strong></span>: This transformation along the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> axis through zero degree can be represented in the matrix form, as given in the following diagram:<p>Assume, cos (θ) = C and sin (θ) = S.</p><div class="mediaobject"><img src="graphics/5527OT_02_39.jpg" alt="There's more..."/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The <code class="literal">Transform</code> class provides the <code class="literal">TransformRotate</code> API for the rotation operation.</p></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void TransformRotate(float angle,float Rx,float Ry,float Rz);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">angle</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates the degree of rotation</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Rx</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates the degree of rotation along the <span class="emphasis"><em>x</em></span> axis</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Ry</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates the degree of rotation along the <span class="emphasis"><em>y</em></span> axis</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Rz</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates the degree of rotation along the <span class="emphasis"><em>z</em></span> axis</p>
</td></tr></tbody></table></div></li></ul></div></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec78"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Understanding the projection system in GLPI</em></span> recipe in <a class="link" href="apa.html" title="Appendix A. Supplementary Information on OpenGL ES 3.0">Appendix</a>, <span class="emphasis"><em>Supplementary Information on OpenGL ES 3.0</em></span></li></ul></div></div></div>
<div class="section" title="Understanding the projection system in GLPI"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Understanding the projection system in GLPI</h1></div></div></div><p>In this recipe, we <a id="id179" class="indexterm"/>will understand two types of projection systems <a id="id180" class="indexterm"/>that are very commonly used in 3D graphics: perspective projection system and orthographic projection system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Perspective projection system</strong></span>: This type of projection system creates a view <a id="id181" class="indexterm"/>that is similar to how our eyes view the objects. This means that the objects that are near to us will appear bigger when compared to the far off objects. This type of projection system uses a frustum-clipping region, as shown on the left-hand side of the next figure.<p>In the GLPI framework, the <code class="literal">Transform::TransformSetPerspective()</code> function can be used to create a perspective view.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void Transform::TransformSetPerspective( float fovy, float aspect_ratio, float clip_start, float clip_end, float screen_orientation )</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">fov</code></p>
</td><td style="text-align: left" valign="top">
<p>This defines the field of view</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">aspect_ratio</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the rendering aspect ratio (width/height)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">clip_start</code> and <code class="literal">clip_end</code></p>
</td><td style="text-align: left" valign="top">
<p>These are the near and far clipping planes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">screen_orientation</code></p>
</td><td style="text-align: left" valign="top">
<p>These are the vertical or horizontal orientation for scene rendering</p>
</td></tr></tbody></table></div></li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Orthographic projection system</strong></span>: This type of projection system is specially used in <a id="id182" class="indexterm"/>engineering applications where near and far objects always appear with the same dimensions. Therefore, the orthographic <a id="id183" class="indexterm"/>projection system retains the geometric <a id="id184" class="indexterm"/>dimensions. This projection system uses a clipping region in the cuboidal shape, as shown in the next figure.<p>The GLPI framework provides orthographic projection with the <code class="literal">TransformOrtho()</code> function. Any model rendered within this clipping plane range will be displayed on the screen, and the rest will be clipped out.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Syntax</strong></span>:<div class="informalexample"><pre class="programlisting">void Transform::TransformOrtho( float left, float right, float bottom,float top,float clip_start,float clip_end )</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">left</code> and <code class="literal">right</code></p>
</td><td style="text-align: left" valign="top">
<p>These are the left and right range of the clipping planes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">bottom</code> and <code class="literal">top</code></p>
</td><td style="text-align: left" valign="top">
<p>These are the bottom and top range of clipping planes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">clip_start</code> and <code class="literal">clip_end</code></p>
</td><td style="text-align: left" valign="top">
<p>These are the near and far clipping planes</p>
</td></tr></tbody></table></div></li></ul></div></li></ul></div><p>The following figure shows that the cubes nearer to the camera are appearing bigger compared to others placed at far distance. On the right-hand side, the projection generated by this is displayed. This projection clearly shows that irrespective of the distance of the cube from the camera, they all appear with same dimensions:</p><div class="mediaobject"><img src="graphics/5527OT_02_32.jpg" alt="Understanding the projection system in GLPI"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec79"/>How to do it...</h2></div></div></div><p>Here are the steps to implement the perspective and orthographic projection systems:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In order to apply a specific projection onto the scene, we will use the setup <code class="literal">Projection()</code> function in the <code class="literal">Renderer</code> class. This will be the first function that gets called before rendering each frame. It is very important to set the current matrix as the projection matrix using the <code class="literal">TransformSetMatrixMode</code> (<code class="literal">PROJECTION_MATRIX</code>) function. This will ensure that the projection matrix will be in current use. Now, the orthographic <a id="id185" class="indexterm"/>or perspective projection systems can be <a id="id186" class="indexterm"/>applied using the <code class="literal">TransformOrtho()</code> or <code class="literal">TransformSetPerspective()</code> function.</li><li class="listitem">After setting the projection system, it is important to set the current matrix as <code class="literal">VIEW_MATRIX</code> in order to set the camera position in the 3D space. Finally, before rendering the object's models, set the current matrix as <code class="literal">MODEL_MATRIX</code>, using <code class="literal">TransformSetMatrixMode</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Whenever the current matrix is switched, it may contain some garbage or old transformation values. These values can be cleaned by setting the matrix as identity matrix. This can be done using the <code class="literal">TransformLoadIdentity()</code> function.</p></div></div><div class="informalexample"><pre class="programlisting">void Renderer::setUpProjection(){
 RenderMemData.isPerspective   = true;
 float span                    = 10.0;
 
 //Set up the projection matrix.
 TransformObj-&gt;TransformSetMatrixMode( PROJECTION_MATRIX );
 TransformObj-&gt;TransformLoadIdentity();


 //Set up the Perspective/Orthographic projection.
 if (RenderMemData.isPerspective){
  TransformObj-&gt;TransformSetPerspective(60.0f, 1, 1.0, 100,0);
 }
 else{
  TransformObj-&gt;TransformOrtho( -span,span,-span,span,span,span);
 }

 // Set the camera 10 units away
 TransformObj-&gt;TransformSetMatrixMode( VIEW_MATRIX );
 TransformObj-&gt;TransformLoadIdentity();
 TransformObj-&gt;TransformTranslate(0.0f, 0.0f, -10.0f);

 // Make the scene ready to render models
 TransformObj-&gt;TransformSetMatrixMode( MODEL_MATRIX );
 TransformObj-&gt;TransformLoadIdentity();
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec80"/>How it works...</h2></div></div></div><p>This recipe renders a few cubes arranged in a linear manner in the perspective and orthographic projection systems. The projection systems can be switched on by a single tap on the screen.</p><p>This recipe first <a id="id187" class="indexterm"/>defines a 3D space volume (frustum or cuboid) using the projection system with the projection matrix. This 3D space volume consists of six planes that are responsible for displaying the object contents that are falling under this volume. The <a id="id188" class="indexterm"/>objects outside of this 3D volume will be clipped off. The view matrix is responsible for setting the eye or camera in the 3D space. In our recipe, the camera is 10 units away from the origin. Finally, set the model matrix to render the objects in the 3D space.</p></div></div>
<div class="section" title="Culling in OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Culling in OpenGL ES 3.0</h1></div></div></div><p>Culling is <a id="id189" class="indexterm"/>an important technique in 3D graphics. It is used to discard the faces that are not visible to the user. In an enclosed geometry, the faces pointing <a id="id190" class="indexterm"/>towards the camera hide the faces behind it, either partially or completely. These faces can be easily avoided during rendering by the culling technique. This is an easier way to speed up the performance in OpenGL ES graphics. There are two types of faces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Front face</strong></span>: The <a id="id191" class="indexterm"/>face in an enclosed 3D object that points outward are considered to be the front face</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Back face</strong></span>: The <a id="id192" class="indexterm"/>face in an enclosed 3D object that points inside of these faces are considered as to be the back face</li></ul></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec81"/>How to do it...</h2></div></div></div><p>Culling can be enabled in OpenGL ES 3.0 using the <code class="literal">glenable</code> API with <code class="literal">GL_CULL_FACE</code> as state flag. By default, OpenGL ES 3.0 culls the back face. This can be changed using the <code class="literal">glCullFace</code> API. Tap on the screen to switch between the front and back culling modes. This recipe will <a id="id193" class="indexterm"/>display the outside faces of the cube when back face culling is set; otherwise, it displays the inside faces when front face culling is enabled:</p><p><span class="strong"><strong>Syntax</strong></span>:</p><div class="informalexample"><pre class="programlisting">void glCullFace(GLenum mode);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">mode</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the <a id="id194" class="indexterm"/>mode argument parameter accepts symbolic constant <code class="literal">GL_FRONT</code> (front faces are discarded), <code class="literal">GL_BACK</code> (back faces are discarded), and <code class="literal">GL_FRONT_AND_BACK</code> (no facets are drawn)</p>
</td></tr></tbody></table></div><p>Depending on the application requirement, culling can be applied during initialization of the graphics engine or before rendering the primitives:</p><div class="informalexample"><pre class="programlisting">void Cube::Render(){
  glEnable( GL_CULL_FACE  ); // Enable the culling
  if (toogle){
    glCullFace( GL_FRONT ); // Culls geometries front face
  }
  else{
    glCullFace ( GL_BACK ); // Culls geometries back face
  }
 . . . . . . .}</pre></div><p>The following figure shows the back-face culling and front-face culling:</p><div class="mediaobject"><img src="graphics/5527OT_02_33.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec82"/>How it works...</h2></div></div></div><p>Unlike human eyes, the <a id="id195" class="indexterm"/>computer recognizes the front face and back face of an object from the order of the vertices winding. There are two ways in which these vertices can be arranged: clockwise and anticlockwise. In the following figure, the <a id="id196" class="indexterm"/>rectangle is comprised of two triangles whose vertices are specified in a counterclockwise direction:</p><div class="mediaobject"><img src="graphics/5527OT_02_34.jpg" alt="How it works..."/></div><p>When culling is enabled using the <code class="literal">glEnable</code> API, then the order of arrangement of vertices in the array data defines the orientation of vertices in a face. This orientation plays an important role in defining the front and back faces. Using <code class="literal">glCullFaces</code> APIs, the OpenGL ES knows which all faces can be discarded. All the faces that satisfy culling rules are discarded. By <a id="id197" class="indexterm"/>convention, the default way of orientation is counterclockwise. We can change this using the <code class="literal">glFrontFace</code> API by specifying the argument as <code class="literal">GL_CCW</code> (counter clockwise) or <code class="literal">GL_CW</code> (clockwise).</p></div></div>
<div class="section" title="Depth testing in OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Depth testing in OpenGL ES 3.0</h1></div></div></div><p>Depth testing <a id="id198" class="indexterm"/>allows us to render the object in the order of distance <a id="id199" class="indexterm"/>from the viewer. Without depth testing the rendering of the objects is similar to the painter's algorithm on the device screen. It will render the object on first-come-first-draw basis. For example, if there are three different colored triangles rendered in the order of, say, red, green, and blue, then as per painter's algorithm, it draws red first, green second, and blue at last. The result will appear on the screen in an opposite order, with blue on the top, green in the middle, and red at the bottom. This type of rendering does not take the distance of the triangle objects from the camera into consideration. In real life, the object closer to the camera hides the objects behind them. In order to deal with such real-time scenarios, depth testing is used. It renders the objects based on the depth of the distance from the camera, instead of using the drawing order (painter's algorithm).</p><p>In depth testing, each fragment's depth is stored in a special buffer called depth buffer. Unlike the color buffer that stores the color information, the depth buffer stores depth information of the primitive's corresponding fragment from the camera view. The depth buffer's dimension is usually the same as the color buffer. The depth buffer stores the depth information as 16-, 24-, or 32-bit float values.</p><p>Apart from rendering the objects in the correct depth order, there are many other applications in which the depth buffer is used. One of the most common use of depth buffer is to produce <a id="id200" class="indexterm"/>real-time shadows with the shadow-mapping <a id="id201" class="indexterm"/>technique. For more information, refer to the <span class="emphasis"><em>Creating shadows with shadow mapping</em></span> recipe in <a class="link" href="ch11.html" title="Chapter 11. Anti-aliasing Techniques">Chapter 11</a>, <span class="emphasis"><em>Anti-aliasing Techniques</em></span>.</p><div class="mediaobject"><img src="graphics/5527OT_02_35.jpg" alt="Depth testing in OpenGL ES 3.0"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec83"/>Getting ready</h2></div></div></div><p>For this recipe, we will render three objects and apply depth testing in the toggle fashion (enable/disable) to see the effect of depth test in rendering the scene. In order to toggle the behavior, single tap on the screen.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec84"/>How to do it...</h2></div></div></div><p>In this recipe, the triangle object is in the center, and two cubes are revolving around the triangle object. The depth testing is disabled by default in OpenGL ES 3.0. It needs to be enabled by using the <code class="literal">glEnable</code> API with the <code class="literal">GL_DEPTH_TEST</code> as symbolic constant. Once depth testing is enabled, then behind the curtains, OpenGL ES creates a depth buffer. This depth buffer is used during the rendering of scenes to predict the correct order of the appearance of model objects. Make sure that you clear the depth buffer before rendering each frame with <code class="literal">glClear(GL_DEPTH_BUFFER_BIT)</code>:</p><div class="informalexample"><pre class="programlisting">void Cube::Render(){
   static float k,j,l = 0;
  if (toogle){
      glEnable( GL_DEPTH_TEST );
    }
    else{
        glDisable( GL_DEPTH_TEST );
    }

    // Rotate Both Cube Models
    TransformObj-&gt;TransformPushMatrix();
    TransformObj-&gt;TransformRotate(k=k+1, 0, 1, 0);

    // Render and Rotate Cube model
    TransformObj-&gt;TransformPushMatrix();
        TransformObj-&gt;TransformTranslate( 0, 0, -3);
        TransformObj-&gt;TransformRotate(j=j+4, 0, 1, 0);
        RenderCubeVBO();
    TransformObj-&gt;TransformPopMatrix();
    
    // Render and Rotate Second Cube model
    TransformObj-&gt;TransformPushMatrix();
        TransformObj-&gt;TransformTranslate( 0, 0, 3);
        TransformObj-&gt;TransformRotate(l=l-2, 0, 1, 0);
        RenderCubeVBO();
    TransformObj-&gt;TransformPopMatrix();
    TransformObj-&gt;TransformPopMatrix();
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec85"/>How it works...</h2></div></div></div><p>The depth buffer is a kind of buffer that contains the depth information of all the fragments on the <a id="id202" class="indexterm"/>window screen. The depth buffer contains <code class="literal">z</code> (depth) values that range between 0.0 and 1.0. The depth buffer compares its content with <code class="literal">z</code> value of all the objects in the scene, as seen from the camera view. When the <code class="literal">glClear(GL_DEPTH_BUFFER_BIT)</code> function is called, it sets the <code class="literal">z</code> values of all fragments with the <a id="id203" class="indexterm"/>depth value as 1.0. Depth buffer with pixel value 0.0 is considered to be the closest to the camera position (at near plane), whereas a fragment value of 1.0 is considered to be the farthest (at far plane). When an object is rendered, the associated fragment depth is compared to the corresponding value already present in the depth buffer. This comparison is based on the <code class="literal">glDepthFunction</code> depth API.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>The depth test always passes if the depth test is disabled or no depth buffer exists.</p></div></div><p>The depth value can be controlled by the <code class="literal">glDepthFunction</code> API. This API specifies how the incoming depth values will be compared with the values already present in the depth buffer.</p><p><span class="strong"><strong>Syntax</strong></span>:</p><div class="informalexample"><pre class="programlisting">Void glDepthFunc(GLenum func);</pre></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">func</code></p>
</td><td style="text-align: left" valign="top">
<p>This indicates the condition under which the pixel will be drawn</p>
</td></tr></tbody></table></div><p>The following table specifies the conditional checks that can be used to pass or fail the depth test. Here are the <a id="id204" class="indexterm"/>defined meanings of the symbolic <a id="id205" class="indexterm"/>constants:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Symbolic constant</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_NEVER</code></p>
</td><td style="text-align: left" valign="top">
<p>Never passes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_LESS</code></p>
</td><td style="text-align: left" valign="top">
<p>Passes if the incoming depth value is less than the stored value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_EQUAL</code></p>
</td><td style="text-align: left" valign="top">
<p>Passes if the incoming depth value is equal to the stored value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_LEQUAL</code></p>
</td><td style="text-align: left" valign="top">
<p>Passes if the incoming depth value is less than or equal to the stored value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_GREATER</code></p>
</td><td style="text-align: left" valign="top">
<p>Passes if the incoming depth value is greater than the stored value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_NOTEQUAL</code></p>
</td><td style="text-align: left" valign="top">
<p>Passes if the incoming depth value is not equal to the stored value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_GEQUAL</code></p>
</td><td style="text-align: left" valign="top">
<p>Passes if the incoming depth value is greater than or equal to the stored value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GL_ALWAYS</code></p>
</td><td style="text-align: left" valign="top">
<p>Always passes</p>
</td></tr></tbody></table></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec86"/>There's more...</h2></div></div></div><p>The <code class="literal">z</code> value of an object in the view space could be any value in between frustum's near and far planes. Therefore, we need some conversion formulas to produce <code class="literal">z</code> values in the range 0.0 and 1.0. The following image shows the mathematical formula to calculate the depth of an object inside the frustum using a linear transformation.</p><p>In reality, the linear transformation to calculate the <code class="literal">z</code> value is hardly used because it gives constant precision at all depths. However, we need more precision for items that are closer to the viewer's eyes and less precision that are farther. For this purpose, a nonlinear function is used that is proportional to <code class="literal">1/z</code> to calculate the depth. Clearly in the second image, the nonlinear function produces an enormous precision at the near plane for the objects falling in the <a id="id206" class="indexterm"/>range <code class="literal">[1, 20]</code>. In contrast, the farther object has <a id="id207" class="indexterm"/>less precision that is fulfilling the ideal requirements:</p><div class="mediaobject"><img src="graphics/5527OT_02_36.jpg" alt="There's more..."/></div></div></div></body></html>