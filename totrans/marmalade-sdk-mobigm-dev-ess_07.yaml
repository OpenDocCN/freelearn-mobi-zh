- en: Chapter 7. Adding Sound and Video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your game may look stunning, but if it''s silent your audience will probably
    find it a dull experience. Fortunately, Marmalade allows us to remedy this with
    its support for sound and video playback. In this chapter we will learn about
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing back audio files recorded in formats such as MP3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding multiple simultaneous sound effects using sound samples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing back full-motion video clips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimedia support in Marmalade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern mobile phones and tablet devices are now capable of playing back good
    quality music and video, so it makes sense that Marmalade should provide ways
    in which we can harness these abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Marmalade provides three different API layers that apply to multimedia support.
    These are s3eSound, s3eAudio, and s3eVideo. Unsurprisingly, the latter relates
    to the playback of video files, but you may be wondering why there are two APIs
    provided relating to sound.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between s3eSound and s3eAudio is that the former is generally
    used for sound effects while the latter is normally used for music. The s3eSound
    API allows us to play several different sound effects at the same time, but by
    default only provides support for 16-bit mono-PCM sound samples. The s3eAudio
    API on the other hand allows us to play compressed formats such as MP3, but we
    are limited (on most devices) to playing a single audio track.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that most modern devices lets us have the best of both worlds
    by allowing both s3eSound and s3eAudio to be used at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections we'll look at how to make use of all three of these
    APIs and will also take a look at another module called `SoundEngine`, that makes
    using the s3eSound API a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: The s3eAudio API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the quickest and easiest way of allowing our games to stop
    being the strong, silent type.
  prefs: []
  type: TYPE_NORMAL
- en: The s3eAudio API allows us to play compressed music formats such as MP3 and
    AAC. Some devices may also allow us to play other formats, such as MIDI files.
    Marmalade makes use of whichever audio codecs a particular device may have built-in
    rather than decoding the audio itself, so be sure to check that your chosen audio
    format is supported by all the devices you wish to target.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to its ubiquity, it is recommended that you use MP3 as your format of choice.
    There are very few devices (if any) that can't play an MP3 file and the format
    itself allows you a wide variety of bit rates so you can trade-off between audio
    quality and file size.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at how we can get an audio track playing and what other
    functionality the s3eAudio API provides for us. There is nothing we need to add
    to our MKB file in order to allow us to use s3eAudio, as it is one of the low
    level APIs of Marmalade that is always available for use. All we need to do is
    include the header file `s3eAudio.h` in any source file that needs access to s3eAudio
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Starting audio playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of starting the playback of an audio track. The first allows
    us to specify the filename of the audio track we want to play and the number of
    times we would like the track to repeat, and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The filename is just a standard C, null-terminated string and is relative to
    the `data` directory when run from Windows or the application install directory
    on the device. Specifying a number for the repeat count will cause the audio track
    to play that many times, while setting it to zero will cause the track to loop
    continuously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method is to play the audio track from an area of memory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The parameters `apBuffer` and `aBufferLength` provide the memory location where
    the audio track resides and the length of audio data in bytes. The repeat count
    is specified in the same manner as with `s3eAudioPlay`.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases we will find that the first method is good enough since it is
    easy to use and doesn't require us to allocate blocks of memory and fill it with
    data. You may find that the buffer method provides slightly faster initial playback
    if you have preloaded the audio data, but on most recent devices the difference
    is negligible.
  prefs: []
  type: TYPE_NORMAL
- en: If you make a call to either of these functions while an audio track is currently
    playing, that track will be stopped and the new track will begin playing.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing, resuming, and stopping playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an audio track is playing, we can pause playback by calling the `s3eAudioPause`
    function. The audio can be started again from the point at which it was paused
    by calling `s3eAudioResume`. Finally, to stop playback completely just call `s3eAudioStop`.
  prefs: []
  type: TYPE_NORMAL
- en: All three of these functions take no parameters and will return `S3E_RESULT_SUCCESS`
    when no errors occur. An error is raised if any of these functions are called
    when it makes no sense to do so, for example calling `s3eAudioPause` when there
    is no audio playing.
  prefs: []
  type: TYPE_NORMAL
- en: Changing volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most of the low level APIs in Marmalade, s3eAudio features a pair of functions
    called `s3eAudioGetInt` and `s3eAudioSetInt` that are used to change attributes
    related to that API. In s3eAudio, one of the things we use these functions for
    is to change the volume of audio playback.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the playback volume we can make the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned example we set the volume to half of `S3E_AUDIO_MAX_VOLUME`,
    which is the maximum allowed volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the current volume we use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can also request the default volume for audio by passing in the value `S3E_AUDIO_VOLUME_DEFAULT`.
    This is the default volume level for playing audio and has been chosen by the
    Marmalade SDK so as to provide a fairly consistent volume level across all devices.
  prefs: []
  type: TYPE_NORMAL
- en: Other audio queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `s3eAudioGetInt` function allows us to make several other queries regarding
    audio playback. The following table shows which properties can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_AUDIO_STATUS` | Returns current audio status—one of `S3E_AUDIO_STOPPED`,
    `S3E_AUDIO_PLAYING`, `S3E_AUDIO_PAUSED`, or `S3E_AUDIO_FAILED`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_AUDIO_POSITION` | Returns the current position in the audio track in
    milliseconds, or `0` if no track is playing. Note that not all platforms support
    this feature. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_AUDIO_CHANNEL` | Returns the currently selected audio channel. This
    property can also be used in `s3eAudioSetInt` to select which audio channel the
    future audio commands will be applied to. See the following property for more
    on audio channels. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_AUDIO_NUM_CHANNELS` | Returns the number of audio channels available.
    On most platforms this will return `1` since most devices only allow a single
    audio track to be played at any time. Some devices provide more than one channel,
    meaning more than one audio track can be played simultaneously. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_AUDIO_MUTES_S3ESOUND` | Returns `1` if the hardware is not capable of
    outputting sound through both s3eAudio and s3eSound at the same time. In this
    instance playing an audio track will cause s3eSound processing to continue, but
    without actually producing any output. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_AUDIO_DURATION` | Returns the length, in milliseconds, of the track
    currently playing. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_AUDIO_PLAYBACK_FROM_HTTP_AVAILABLE` | Returns `1` if the hardware is
    able to play an audio track by streaming from a URL. |'
  prefs: []
  type: TYPE_TB
- en: End of track notification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two methods we can use to determine when an audio track has finished.
    One is to use a polled approach, the other is to make use of a callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'To poll whether an audio track has completed or not, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function returns `S3E_TRUE` if the audio is currently playing, or `S3E_FALSE`
    if it is stopped or paused. This function is actually just a shortcut for calling
    `s3eAudioGetInt` with the property `S3E_AUDIO_STATUS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback approach is also very simple to use, as the following code snippet
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The callback function will be called whenever an audio track finishes and will
    pass the pointer to user data supplied as the last parameter in the `s3eAudioRegister`
    call by using the `apUserData` argument. It will not be called if we have asked
    the audio track to be looped unless it is the last repetition. The function will
    also be called if the audio is stopped due to an error, such as a corrupted track.
    We can determine whether completion was caused due to error by calling the `s3eAudioGetError`
    function, which returns an error code of the enumerated type `s3eAudioError`.
    A complete list of error codes can be found in `s3eAudio.h`.
  prefs: []
  type: TYPE_NORMAL
- en: The decision of whether to use the polling or callback-based approach depends
    on your application, and indeed quite often in games we don't even really care
    that much about when an audio track has finished as we often just want the same
    track to loop forever until a new piece of audio is required. If you are just
    waiting for a jingle to finish during a splash screen, the polled method is probably
    adequate, but if you want to join several tracks together one after the other,
    the callback approach would probably lead to a clean solution.
  prefs: []
  type: TYPE_NORMAL
- en: The s3eSound API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to add spot sound effects to your game, such as laser bolts and
    explosions, the s3eSound API is what you need to use. This API allows multiple
    sound samples to be played simultaneously at different volumes and pitch by mixing
    them together into a single output.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of the s3eSound API, simply include the file `s3eSound.h` in your
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: The API expects all sound effects to be supplied as uncompressed 16-bit signed
    PCM. File formats such as WAV are not supported by the API, so you must write
    your own code to load and extract the sample data from such files.
  prefs: []
  type: TYPE_NORMAL
- en: As you read through this section you may start to think that there's an awful
    lot to do in order to play some sound effects. While this may appear to be the
    case, s3eSound is actually a very low-level API and provides enough flexibility
    to allow you to code your own complex sound routines.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter we will be covering the `SoundEngine` module, which comes
    with Marmalade to provide a wrapper for the s3eSound API. The `SoundEngine` module
    takes care of most of the hard work involved in using the s3eSound API for us
    and also includes the ability to load WAV files directly from a GROUP file.
  prefs: []
  type: TYPE_NORMAL
- en: Starting sound playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to play a sound sample using s3eSound, the first thing we have to
    do is allocate a free sound channel. The s3eSound API provides a limited number
    of channels (we''ll see later how to determine exactly how many are available)
    that allow us to specify a sound sample, volume, and playback rate. The sound
    data for all currently active channels is then mixed together in the inner workings
    of s3eSound into a single waveform and this is what is played through the device''s
    sound hardware. To allocate a free channel, we make the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will return the ID number of a free channel, or `-1` if no channel is available.
    Most of the time it is unlikely that a free channel will not be available, but
    if we are playing a lot of sound effects we might want to consider tagging each
    of our sound effects with a priority value and maintaining a list of currently
    active sounds. When we run out of channels, we can check the list of sounds and
    reclaim the channel being used by the lowest priority sound effect, assuming that
    it is at a lower priority than the sound we wish to start of course!
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a channel is available we must set up the playback rate of our sample
    data, which is done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the sound channel ID we just allocated. The second parameter
    indicates that we want to set the playback rate for that channel, and the third
    parameter is the actual desired playback rate in Hertz (Hz). The maximum frequency
    that can be set is specified by the define `S3E_SOUND_MAX_FREQ`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also set the volume that we want the sound to be played at, which
    is also done using the `s3eSoundChannelSetInt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The valid values for the `lVolume` parameter are from `0` to the define `S3E_SOUND_MAX_VOLUME`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to change the volume and playback rate at any time once the sound
    has started playing. This makes it possible to implement effects such as volume
    fades or pitch shifts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start playing our sound sample. We do this with the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unsurprisingly, we first pass in the channel ID we are using, followed by the
    address in memory where the 16-bit PCM sample data can be found in the `lSampleData`
    parameter. The `lNumSamples` parameter is the number of actual sound samples in
    our waveform (not the number of bytes), and `lRepeatCount` indicates how often
    we want the sound to repeat. A value of `0` will play the sound forever. Finally
    the `lLoopIndex` parameter allows us to specify which sample to start at if the
    sound repeats. This makes it possible to use sounds that only need to repeat a
    portion of the sample data.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing, resuming, and stopping playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a sound channel has started playing a sound sample, we might want to temporarily
    suspend its playback or stop it entirely. To pause a sound channel we use the
    function `s3eSoundChannelPause`, and we can start playing it again from the paused
    position using `s3eSoundChannelResume`. To stop a sound channel entirely we call
    `s3eSoundChannelStop`. Each of these functions takes a single parameter, which
    is the channel ID we want to affect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the current playback status of a particular sound channel we can
    use the `s3eSoundChannelGetInt` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that this function can also be used with the `S3E_CHANNEL_RATE` and `S3E_CHANNEL_VOLUME`
    properties to discover the current sample rate and volume for a particular channel.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is also possible to affect all currently active sound channels at
    once using the functions `s3eSoundPauseAllChannels`, `s3eSoundResumeAllChannels`,
    and `s3eSoundStopAllChannels`. These functions take no inputs and are extremely
    useful for handling situations like going in and out of pause mode, or when switching
    from one part of the game to another (for example, when exiting the title screen
    and entering the main game).
  prefs: []
  type: TYPE_NORMAL
- en: Global sound settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as being able to read and write settings on a per channel basis, we
    can also make settings that affect sound support globally. To do this we use the
    `s3eSoundSetInt` and `s3eSoundGetInt` functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the more useful values for the `lProperty` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_SOUND_VOLUME` | Can be used to read or write the current master sound
    volume. This will scale the volumes of each individual channel appropriately.
    The maximum value is determined by the define `S3E_SOUND_MAX_VOLUME`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_SOUND_DEFAULT_FREQ` | This is the default frequency that will be used
    when starting playback on a sound channel. If all our sound waveforms have the
    same sample rate, it is possible to write to this property once and not have to
    set the sample rate explicitly when playing each individual sound. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_SOUND_NUM_CHANNELS` | A read-only value indicating the maximum number
    of simultaneous sounds that can be played. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_SOUND_USED_CHANNELS` | A read-only value that shows which sound channels
    are currently in use. This is returned as a bit mask with the least significant
    bit relating to sound channel 0\. This value could be used to determine an available
    sound channel, but for future compatibility using `s3eSoundGetFreeChannel` to
    do this is recommended. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_SOUND_AVAILABLE` | A read-only value that returns `1` if s3eSound is
    available on the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_SOUND_VOLUME_DEFAULT` | A read-only value that is used as the default
    value for the global sound volume. It can vary from device to device and is intended
    to allow sound output to be at a similar volume across all devices. |'
  prefs: []
  type: TYPE_TB
- en: There are other values described in the Marmalade documentation, but we won't
    cover them here as they are used for purposes such as custom sound stream generation,
    which are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Sound notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen how to use a polled method of detecting whether or not
    a sound channel is currently playing, but sometimes it is useful to know exactly
    when a sound sample has finished playing, for example, so we can immediately start
    playing back a new sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The s3eSound API allows us to set several different callback functions on a
    per channel basis and we use the functions `s3eSoundChannelRegister` and `s3eSoundChannelUnRegister`
    to enable and disable them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As with all other Marmalade callbacks, we specify the code for the callback
    function by passing in a pointer to the function itself, and we can also register
    a block of user data that will be passed into this function when it is triggered.
    There are four different callback types called `S3E_CHANNEL_END_SAMPLE`, `S3E_CHANNEL_STOP_AUDIO`,
    `S3E_CHANNEL_GEN_AUDIO`, and `S3E_CHANNEL_GEN_AUDIO_STEREO`. We will only take
    a look at the first two of them here, as the latter two are concerned with generating
    custom audio streams and are beyond the scope of this book. For an example of
    how to use these callback types, take a look at the source code for the `SoundEngine`
    module, which we'll be covering in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: First let's look at the `S3E_CHANNEL_END_SAMPLE` callback, which allows us to
    loop sounds and join different sounds together as a sequence. The registered callback
    function is passed a pointer to an `s3eSoundEndSampleInfo` structure as its first
    parameter. The structure indicates which sound channel has ended by using its
    `m_Channel` member.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to start a completely new sound playing on this channel, we can set
    the `m_NewData` member of the `s3eSoundEndSampleInfo` structure to the start address
    of the new sample data, and the `m_NumSamples` member to the number of samples
    in the new waveform.
  prefs: []
  type: TYPE_NORMAL
- en: The structure also contains a member called `m_RepsRemaining`, which allows
    us to change the number of repetitions of the sample data we want on this sound
    channel. Note, though, that this callback will still be triggered every time the
    end of the sample data has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish the channel to continue playing sample data, be it the original data
    or a new sample specified using the `m_NewData` and `m_NumSamples` members of
    the `s3eSoundEndSampleInfo` structure, we must return a non-zero value from the
    callback function. If zero is returned, the sound channel will stop playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example puts the functionality described previosuly into
    practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The second callback type we'll consider is `S3E_CHANNEL_STOP_AUDIO`. This callback
    will occur whenever a sound channel finishes playing a sound completely (for example,
    if we have an `S3E_CHANNEL_END_SAMPLE` callback set and we return zero from it
    to end all playback). It is passed a pointer to an `s3eSoundEndSampleInfo` structure,
    but the only valid field is the `m_Channel` member.
  prefs: []
  type: TYPE_NORMAL
- en: The SoundEngine module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the previous section of this chapter shows, the basics of using s3eSound
    are actually fairly straightforward. The main issue that we have to deal with
    as developers is the fact that s3eSound can only support raw uncompressed 16-bit
    PCM samples, which means it is our responsibility to get the sound data into memory
    so it can be played.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common file formats for storing sound samples is the WAV file,
    so wouldn't it be great if we could use this format to store our sound effects?
    Wouldn't it also be great if we could load these files into memory using the same
    resource manager code that we've used for textures and 3D models?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to our prayers is the `SoundEngine` module, which is a layer that
    sits on top of s3eSound and allows us to easily load and access sound effects
    using the resource manager.
  prefs: []
  type: TYPE_NORMAL
- en: The `SoundEngine` module doesn't just stop there though. It also wraps up the
    s3eSound calls we've learnt about in this chapter and it allows us to support
    a further sound format that can be stored in WAV files—namely the compressed IMA
    ADPCM type. This is particularly useful given that sound sample data can be quite
    large in size; so this format helps us claw back some memory space at the expense
    of a slight drop in sound quality.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections give a brief introduction to using this module, but for
    full details you should refer to the source and header files to see all the functionality
    `SoundEngine` has to offer. The sound example project accompanying this chapter
    also makes use of this module, so take a look at that to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SoundEngine module to a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SoundEngine` module actually ships with the Marmalade SDK, but it lives,
    awkwardly, in the `examples` directory. The easiest way to solve this is to just
    copy the entire `SoundEngine` directory to the directory where your project resides
    and then reference it by adding `SoundEngine` to your MKB files subprojects. This
    is the same approach we used with the GUI and `Localise` modules that were introduced
    in the sample code for the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The location of the `SoundEngine` module in the `examples` folder means it isn't
    really considered part of the main Marmalade SDK. In practice it is highly unlikely
    that the `SoundEngine` code will suddenly disappear from the SDK, since the s3eSound
    API is unlikely to change drastically from what it is now; so you shouldn't have
    any concerns about using it directly in your own projects. If you prefer to write
    your own code, `SoundEngine` does at least serve the purpose of being a very good
    example of how to use the s3eSound API.
  prefs: []
  type: TYPE_NORMAL
- en: With the module added to our project, we can include the file `IwSound.h` in
    our code to make use of it. A call to `IwSoundInit` is needed to set everything
    up and a call to `IwSoundTerminate` cleans up at the end of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also add a custom resource handler to allow WAV files to be loaded
    by the resource manager. The following code snippet will do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a manager class that takes care of all sound-related events
    and we must ensure that we call the `Update` method of this class somewhere within
    the main game loop. We do this with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Loading and accessing sound resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To load a WAV file all we have to do is add a reference to its filename into
    a GROUP file, though we still need to do a little more in order to be able to
    play the sound back. What we need to do is declare an instance of the class `CIwSoundSpec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class allows us to reference a particular sound sample by name and lets
    us set a volume and pitch to play the sound at. We can also specify whether or
    not we want the sound to loop (note that `SoundEngine` currently provides no way
    of specifying the number of times to loop the sound; we can only indicate continuous
    looping). Here''s an example definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `pitch` and `vol` (volume) parameters are specified as fractional scales,
    where `1.0` indicates the default pitch or volume level of a sound. We can also
    specify a range for both these parameters that allows a random value to be chosen
    when starting the sound. Specifying a range for the pitch can be quite useful
    to add a bit of variety to the sound effects in your game without having to add
    lots of slightly different sound samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below shows how to specify ranges for the volume and pitch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful class that we have access to is `CIwSoundGroup`. This allows
    us to collect a number of different sound effects together and pause, resume,
    stop, or alter the volume or pitch of any that are currently being played all
    at the same time. Note that a sound group only allows a single volume or pitch
    value to be specified, not a random range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Sounds can be added to groups using the `addSpec` keyword, or alternatively
    you can add `CIwSoundSpec` to a group when it is defined by using the `group`
    keyword followed by the group name, in its definition. We can use either method,
    but the group or sound must have been declared before we make reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a sound specification or group, we just load the GROUP file and retrieve
    them using the resource manager in the normal way. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Playing, stopping, and altering sound parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have hold of a pointer to `CIwSoundSpec` we can start playing it by
    calling the `Play` method, which will do all the behind-the-scenes stuff of allocating
    a free channel and setting volume and playback speed. The `Play` method can be
    passed an optional parameter, which is an instance of the class `CIwSoundParams`,
    that allows the volume and pitch to be modified when starting the sound.
  prefs: []
  type: TYPE_NORMAL
- en: The `Play` method returns a pointer to a `CIwSoundInst` class, which has methods
    to allow that single instance of the sound to have its volume or pitch modified,
    and also provides methods called `Pause`, `Resume`, and `Stop`, which should be
    self explanatory! If no free sound channel is available, the `Play` method will
    return `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a pointer to `CIwSoundGroup` we can affect all currently playing
    instances of sounds contained within it. Again there are `Pause`, `Resume`, and
    `Stop` methods that do what you would expect, plus there are the methods `SetVol`
    and `SetPitch` that will scale the current volume and pitch of the sounds. These
    methods use the value `IW_GEOM_ONE` (4096) to indicate a scale of one.
  prefs: []
  type: TYPE_NORMAL
- en: The s3eVideo API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll finish our look at Marmalade's multimedia support by having a whirlwind
    look at support for playing video clips using the s3eVideo API. To make use of
    the functions it provides, we just need to include the `s3eVideo.h` file into
    our source code.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, there are two things to consider when using video clips in
    our games. The first is that while it is possible to specify where on the screen
    the video clip will appear, it will always be drawn on top of all other graphics.
    The second issue is that due to hardware limitations in many mobile devices, the
    s3eVideo API cannot be used at the same time as the s3eAudio and s3eSound APIs.
    In the case of s3eAudio, any currently playing track will be stopped (this also
    applies the other way around—starting an audio track will stop a currently playing
    video clip). The s3eSound API will continue processing its events while a video
    clip is playing, but its sound output will be silenced until the video clip is
    finished. For most games we would probably decide it is best to explicitly stop
    all s3eSound playback before starting a video clip, particularly if we are doing
    anything advanced like joining sound samples together using the callback system.
  prefs: []
  type: TYPE_NORMAL
- en: Starting video playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The s3eVideo API works in a similar manner to the s3eAudio API. To start playing
    a video clip we use the `s3eVideoPlay` function, specifying the filename of the
    video clip, the number of times we want it to loop, a screen position, and the
    size that we want to display it at, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The video clip will automatically resize to fit the rectangle, but no attempt
    is made to keep the correct aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Where possible it is usually best to try to make your video clips the same resolution
    as the rectangular area you want to display them in. This will avoid any unnecessary
    stretching of the image (which can look quite ugly!) and may lead to slightly
    better performance, though on most modern devices the resize will be happening
    in hardware and there will be no appreciable difference.
  prefs: []
  type: TYPE_NORMAL
- en: The actual size of the video file itself is also worth bearing in mind, since
    we often want to minimize the size of the final install package. Ultimately, we
    need to use a bit of trial and error until we get a result that ticks all the
    boxes for acceptable quality, performance, and file size.
  prefs: []
  type: TYPE_NORMAL
- en: Determining video codec support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The s3eVideo API makes use of the device's built-in video decoding, so not all
    video formats will be playable on all devices. To determine whether support for
    a particular codec is available, there is a function called `s3eVideoIsCodecSupported`
    that takes a value from the `s3eVideoCodec` enum. Take a look at the `s3eVideo.h`
    file or the Marmalade documentation for a complete list of possible values.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing, resuming, and stopping video playback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again the parallels with the s3eAudio API are apparent when it comes to controlling
    video playback. The functions `s3eVideoPause`, `s3eVideoResume`, and `s3eVideoStop`
    all take no parameters and are used to pause, resume, and finish video clip playback
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: End of video notification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the choice of polling or callbacks once more for detecting the end of
    video playback. Let's start with the polled method that involves a call to the
    function `s3eVideoIsPlaying`, which will return `S3E_TRUE` if a video is playing
    or `S3E_FALSE` if a video is paused or stopped. Quite simple really!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use the callback approach, the following code snippet illustrates
    what to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The callback will be triggered whenever video playback stops, either because
    we explicitly call `s3eVideoStop`, an error in playback such as a corrupted video
    file occurs, or if an audio track is started using `s3eAudioPlay`. Note that the
    callback is not triggered between repetitions of the video clip if we are looping
    it.
  prefs: []
  type: TYPE_NORMAL
- en: For most games, video clips will probably only be used during introductory sequences
    or tutorials, since using video in the game itself is probably not practical.
    With this in mind, a polled approach for detecting when a video clip is finished
    is normally sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Other video queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The s3eVideo API, like the s3eSound and s3eAudio APIs, also has a pair of functions
    for reading and writing global video parameters. They are called `s3eVideoGetInt`
    and `s3eVideoSetInt`. They are called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the values that can be used for the `lProperty` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_VIDEO_VOLUME` | This property is used to find the current volume level
    for the sound associated with the video clip and also to set a new volume. The
    maximum volume level is defined by the value `S3E_VIDEO_MAX_VOLUME`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_VIDEO_DEFAULT_VOLUME` | This is a read-only property that shows the
    default volume that will be used for playing back the sound in a video clip. Its
    value is intended to provide a similar level of volume across all device types.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_VIDEO_STATUS` | This is a read-only parameter showing the current status
    of the video playback. It will return one of the following values: `S3E_VIDEO_STOPPED`,
    `S3E_VIDEO_PLAYING`, `S3E_VIDEO_PAUSED`, or `S3E_VIDEO_FAILED`. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_VIDEO_POSITION` | This property returns the current playback position
    of the video in milliseconds, or `0` if no video is playing. This parameter cannot
    be written to, so it is not possible to jump to a particular point in a video
    clip. |'
  prefs: []
  type: TYPE_TB
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has three example projects associated with it and they are described
    in the following sections. The sound, audio, and video clips used in these projects
    were sourced from a couple of great websites that offer a vast variety of stock
    media for free! Links to these websites are provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.royalty-free-music-room.com](http://www.royalty-free-music-room.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.partnersinrhyme.com](http://www.partnersinrhyme.com)'
  prefs: []
  type: TYPE_NORMAL
- en: The Sound project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project demonstrates use of the s3eAudio API and the `SoundEngine` module
    (which in turn makes use of s3eSound).
  prefs: []
  type: TYPE_NORMAL
- en: On running the example you'll be presented with three clickable buttons that
    have been implemented using the GUI module introduced in the last chapter. The
    first button toggles an MP3 track on and off using s3eAudio, while the other two
    start some sound effects using `SoundEngine`.
  prefs: []
  type: TYPE_NORMAL
- en: The Video project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another simple example showing how to use the s3eVideo API to start
    and stop a video clip. A button at the bottom of the screen will start and stop
    a video clip, which is played in a continuous loop.
  prefs: []
  type: TYPE_NORMAL
- en: The Skiing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally we come to the Skiing project once again and it will come as no surprise
    that it has been enhanced by the addition of some music and sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: The main menu now plays an MP3 audio track while waiting for the player to press
    a button. On pressing a button, a confirmation sound effect is played.
  prefs: []
  type: TYPE_NORMAL
- en: In the game itself, several sounds have been added. A swooshing sound is produced,
    by using a looping sample, whenever the skier moves and the pitch of this sample
    is decreased as the player turns, to make things sound a little more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Other sounds that have been added include a selection of celebratory sounds
    for when the player passes through a gate, a painful-sounding yell for when the
    player collides with an obstacle, and a springy sound that gets played when the
    player collides with a flag pole and causes it to wobble.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this chapter draws to a close, our look at Marmalade's multimedia support
    has now given us the ability to play sound effects, music tracks, and also play
    back video clips.
  prefs: []
  type: TYPE_NORMAL
- en: There are very few games that don't feature sound or music of some sort, and
    adding a few sound effects can make a world of difference to your game. While
    not all games need to make use of video, it is nice to know we have it at our
    disposal should we ever need to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll be looking at how Marmalade can make it easier for
    us to target as wide a range of devices as possible, from entry-level handsets
    to top-of-the-range ones.
  prefs: []
  type: TYPE_NORMAL
