- en: Continuous Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续部署
- en: In this chapter, we will see how we can organize a workflow in which we automate
    the process of testing and delivering your app. You can do this for both the ad
    hoc and the public releases of your app. To make the build-measure-feedback loop
    really work for you, you need to release early and often.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何组织一个工作流程，在这个工作流程中，我们将自动化测试和交付您的应用的过程。您可以为应用的临时发布和公共发布都这样做。为了使构建-度量-反馈循环真正为您所用，您需要尽早且频繁地发布。
- en: You can install Jenkins or TeamCity on a build server or another dedicated machine
    to make a new build of your app each time a new feature becomes available. Basically
    it comes down to that, but there are many interesting strategies to consider.
    For example, what is your branching strategy (Git workflow)? Do you want to run
    unit or UI-tests on the build server? How can you support variants (Android) or
    targets (iOS) for your app? Let's find out in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在构建服务器或另一台专用机器上安装Jenkins或TeamCity，以便在每次新功能可用时构建您的新应用。基本上，就是这样，但还有许多有趣的策略可以考虑。例如，您的分支策略（Git工作流程）是什么？您想在构建服务器上运行单元测试或UI测试吗？您如何支持应用的变体（Android）或目标（iOS）？让我们在本章中找出答案。
- en: We will have a look at various tools that can help us with the ad hoc distribution
    of the app. Some of them can also help you with the deployment of your app to
    the Play Store or to the App Store.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨各种工具，这些工具可以帮助我们进行应用的临时分发。其中一些工具还可以帮助您将应用部署到Play Store或App Store。
- en: 'Specifically, in this chapter we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将涵盖以下主题：
- en: Learning the benefits of an automated workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习自动化工作流程的好处
- en: Seeing what Continuous Integration, Continuous Delivery, and Continuous Deployment
    are about
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解持续集成、持续交付和持续部署的内容
- en: Figuring out how a good branching strategy can help you to get things done
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解一个好的分支策略如何帮助您完成任务
- en: Learning about **TeamCity** and **Jenkins**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**TeamCity**和**Jenkins**
- en: Having a look at build variants or build targets to support different versions
    of an app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看构建变体或构建目标以支持应用的不同版本
- en: Examining how **Gradle** can help us create different build flavors and types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查**Gradle**如何帮助我们创建不同的构建风味和类型
- en: Seeing how we can distribute the app using **Fastlane**, **Fabric**, or **HockeyApp**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用**Fastlane**、**Fabric**或**HockeyApp**分发应用
- en: Continuous Deployment = Continuous Integration and Delivery
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续部署 = 持续集成和持续交付
- en: Why are Continuous Integration and Continuous Delivery important in the first
    place? There are number of answers to this question. One of them is that you need
    feedback as early as possible. Since you also want to ensure a certain quality
    level, there may be some friction here. Distributing and testing your app will
    take a large amount of time, however, you also need to release early and often.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么持续集成和持续交付最初很重要？对这个问题的答案有很多。其中之一是您需要尽早获得反馈。由于您还希望确保一定的质量水平，这里可能会有一些摩擦。分发和测试您的应用将花费大量时间，然而，您也需要尽早且频繁地发布。
- en: A build server can help you to accomplish this goal, because a build server
    can, among other things, verify if your code compiles and if your tests still
    succeed. In addition, it can distribute the app to beta testers or to the App
    or Play Store. At a specific time, or each time a new feature has been implemented,
    the build server will be triggered to perform these and other tasks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器可以帮助您实现这一目标，因为构建服务器可以验证您的代码是否编译成功，以及测试是否仍然通过。此外，它可以将应用分发给测试者或App或Play Store。在特定时间或每次新功能实施时，构建服务器将被触发以执行这些和其他任务。
- en: 'Having a smart-branch strategy is required if you want to set up a Continuous
    Deployment environment. It can also save you a lot of trouble. Here is an example
    of such an environment:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想设置持续部署环境，就需要有一个智能分支策略。这也可以为您节省很多麻烦。以下是一个这样的环境的例子：
- en: '![](img/a2309370-b420-47b7-8a46-916f25ad4b07.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2309370-b420-47b7-8a46-916f25ad4b07.png)'
- en: Continuous Integration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Typically, this event will be triggered when changes have been committed and
    pushed to a repository. The build server obtains the source from a specific repository
    and branch. It tries to build the code and it performs automated quality checks
    using **SonarQube**, for example, (QA).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，此事件将在更改被提交并推送到仓库时触发。构建服务器从特定的仓库和分支获取源代码。它尝试构建代码，并使用例如**SonarQube**进行自动质量检查（QA）。
- en: SonarQube is a great tool to measure code quality. It is an automated solution
    so it cannot fully replace code reviews, however, it is capable of finding issues
    that may be or may not become an issue for the quality or performance of your
    app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 是一个测量代码质量的优秀工具。它是一个自动化的解决方案，因此它不能完全取代代码审查，然而，它能够发现可能或可能不会成为您应用程序质量或性能问题的潜在问题。
- en: 'SonarQube will take care of:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 将负责：
- en: Architecture and design
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构和设计
- en: Coding rules
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码规则
- en: Duplications
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复代码
- en: Unit tests
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Code complexity
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂度
- en: Finding potential bugs
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现潜在的错误
- en: 'You can define custom rules or use the default ones that exist for more than
    20 programming languages, including Java (soon Kotlin will be also be fully supported),
    that you are probably using for your Android app. It can also check Objective-C
    code and Swift. You can find SonarQube here: [http://www.sonarqube.org](http://www.sonarqube.org).
    If the QA check succeeds, then the build server can also run the unit tests and
    even UI-tests.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义自定义规则或使用适用于超过 20 种编程语言的默认规则，包括您可能用于您的 Android 应用程序的 Java（很快 Kotlin 也将完全支持），Objective-C
    和 Swift。您可以在[http://www.sonarqube.org](http://www.sonarqube.org)找到 SonarQube。如果
    QA 检查成功，那么构建服务器还可以运行单元测试，甚至 UI 测试。
- en: You can configure the build server to make a daily build at a specific time
    or to start each time a new pull request is made. The best practice is to create
    a daily build from the development branch or each time you want to have an ad
    hoc release for your testers. For each new pull request, you can create a new
    build (with each new commit) for the specific feature branch. You will find more
    about branching strategies in the 'Repository and Git workflow' paragraph later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置构建服务器，使其在特定时间进行每日构建，或者在每次提交新的拉取请求时启动。最佳实践是从开发分支创建每日构建，或者每次您想要为测试人员提供一个临时发布版本时。对于每个新的拉取请求，您可以为特定的功能分支创建一个新的构建（与每个新的提交）。您将在后面的“仓库和Git工作流程”段落中了解更多关于分支策略的信息。
- en: The purpose of Continuous Integration is to review code and to test code as
    often as possible by running automated tests (unit and UI tests). The idea is
    that if anything during this flow fails, you will be notified as early as possible.
    This enables you to make changes before your app is distributed. The app is distributed
    only if all steps succeed. If the build breaks, members of your team (often developers)
    will be notified through email, Slack, or any other communication channel that
    you use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的目的是通过运行自动化测试（单元测试和UI测试）尽可能频繁地审查和测试代码。其理念是，如果在整个流程中任何环节失败，您将尽早得到通知。这使您能够在应用程序分发之前进行更改。只有当所有步骤都成功时，应用程序才会分发。如果构建失败，您的团队成员（通常是开发者）将通过电子邮件、Slack
    或您使用的任何其他通信渠道得到通知。
- en: Continuous Delivery
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付
- en: In this workflow, the built and tested code is made available as an ad hoc distribution
    to testers (or beta users). They can review the app and apply some manual tests
    to it. They can perform some functionality tests in particular, as a lot of tests,
    but not everything can be automated.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此工作流程中，构建和测试的代码作为临时分发提供给测试人员（或测试用户）。他们可以审查应用程序并对其进行一些手动测试。他们可以执行一些功能测试，尽管有很多测试，但并非所有测试都可以自动化。
- en: The build server can distribute an ad hoc version of your app by using Fabric,
    HockeyApp, The alpha/beta Play Store, or iTunes Beta (previously known as TestFlight).
    The deployment of your app needs to be as smooth as possible. A tool such as Fastlane
    can help you distribute an ad hoc version and can also you help you to publish
    your app in the Play Store or App Store.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器可以通过使用 Fabric、HockeyApp、alpha/beta Play Store 或 iTunes Beta（以前称为 TestFlight）来分发您应用程序的临时版本。您应用程序的部署需要尽可能平滑。Fastlane
    这样的工具可以帮助您分发临时版本，并还可以帮助您在 Play Store 或 App Store 上发布您的应用程序。
- en: Repository and Git workflow
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库和Git工作流程
- en: The build server needs to retrieve the code from a repository. It is always
    a smart idea to use a repository, even when you work alone. Two well-known Git-based
    repositories are GitHub and Bitbucket (also known as Stash). Both come with a
    free and a paid plan. GitHub offers private repositories only in the paid plan
    (see [https://github.com](https://github.com)). A private repository is accessible
    for your team members only. A public repository is available to anyone. Bitbucket
    offers private repositories in the free plan, so let's create a Bitbucket account
    at [https://bitbucket.org](https://bitbucket.org).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器需要从代码库中检索代码。即使你独自工作，使用代码库也是一个明智的选择。两个知名的基于Git的代码库是GitHub和Bitbucket（也称为Stash）。两者都提供免费和付费计划。GitHub仅在付费计划中提供私有代码库（见[https://github.com](https://github.com)）。私有代码库仅对团队成员可访问。公共代码库对任何人开放。Bitbucket在免费计划中提供私有代码库，因此让我们在[https://bitbucket.org](https://bitbucket.org)创建一个Bitbucket账户。
- en: A common Git workflow is shown as follows. For the development of each new feature,
    a feature branch will be created. Once completed, and code reviewed via a pull
    request, the feature branch can be merged into the development branch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了一个常见的Git工作流程。对于每个新功能的开发，都会创建一个功能分支。一旦完成，并通过拉取请求进行代码审查后，功能分支可以被合并到开发分支。
- en: 'Using a smart branching strategy, at least two important things can be accomplished:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用智能分支策略，至少可以完成以下两个重要任务：
- en: Only versions of the app that are fully tested and are accepted can be released
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有经过全面测试并被接受的应用程序版本才能发布
- en: Hotfixes can be applied quickly, without disturbing the continuous integration
    workflow
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热修复可以快速应用，而不会干扰持续集成工作流程
- en: 'This makes sense even when you are the only developer:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你是一个人开发，这也很有意义：
- en: '![](img/23f14c93-84d0-4a12-a092-183d8f12af55.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23f14c93-84d0-4a12-a092-183d8f12af55.png)'
- en: On the dev (or on the feature) branch, unit and UI tests can be run. If all
    tests are successful, the dev branch can be merged into the master branch and
    made ready for release. If, however, something seems to be broken while the app
    is live, you can use feature branching on the master branch to apply a hotfix,
    without disturbing the development of new features.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在dev（或功能）分支上，可以运行单元和UI测试。如果所有测试都成功，dev分支可以合并到master分支，并准备好发布。然而，如果应用程序运行时似乎出现了问题，您可以在master分支上使用功能分支来应用热修复，而不会干扰新功能的开发。
- en: This, of course, is just a simplified example, and you may want to do things
    differently depending on your needs. To learn more about the Git workflow, check
    the website at [https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows)
    or [https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows](https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简化的例子，根据您的需求，您可能希望以不同的方式做事。要了解更多关于Git工作流程的信息，请查看网站[https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows)或[https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows](https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows)。
- en: Automated tests
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: The build server can run the unit tests and even UI tests for your app. For
    UI tests, think of tools such as Espresso (Android) or Xcode UI testing (iOS).
    If you are looking for tools that support both platforms you can check out Appium,
    for example, (available for Android and iOS).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 构建服务器可以为您的应用程序运行单元测试甚至UI测试。对于UI测试，可以考虑像Espresso（Android）或Xcode UI测试（iOS）这样的工具。如果您正在寻找支持两个平台的工具，可以查看Appium，例如（适用于Android和iOS）。
- en: When it comes to testing, there are different approaches to consider. One of
    these approaches is **Test-driven Development** (**TDD**). If the functionality
    and all the requirements are known, we can define our tests before developing
    our app. Of course, all tests will fail initially, but that is actually a good
    thing because it will set an outline of what needs to be done and create focus
    to get things right. During the implementation of the features, your tests are
    going to succeed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到测试时，需要考虑不同的方法。其中一种方法是**测试驱动开发**（**TDD**）。如果功能以及所有需求都是已知的，我们可以在开发我们的应用程序之前定义我们的测试。当然，所有测试最初都会失败，但这实际上是一件好事，因为它将设定需要完成的工作大纲，并集中精力确保一切正确。在实现功能的过程中，你的测试将会成功。
- en: Espresso is suitable for writing concise and reliable Android UI tests. A test
    typically contains clicks, text input, and checks. To learn more about Espresso
    or Appium, see [https://google.github.io/android-testing-support-library/docs/espresso/](https://google.github.io/android-testing-support-library/docs/espresso/)
    and [http://appium.io](http://appium.io).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 浓缩咖啡适合编写简洁可靠的Android UI测试。一个测试通常包含点击、文本输入和检查。要了解更多关于Espresso或Appium的信息，请参阅[https://google.github.io/android-testing-support-library/docs/espresso/](https://google.github.io/android-testing-support-library/docs/espresso/)和[http://appium.io](http://appium.io)。
- en: Unit tests are often run for the feature branch, while integration and UI tests
    are often run for the development branch. After you pass all of your tests, your
    app can be deployed and released to an audience of beta or end users.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常在功能分支上运行，而集成和UI测试通常在开发分支上运行。在你通过所有测试之后，你的应用可以被部署并发布给测试用户或最终用户。
- en: An example of a continuous workflow for an Android app
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android应用的持续工作流程示例
- en: 'A picture of the ad hoc distribution of an Android app could look as follows.
    For Continuous Integration, in the picture shown next, TeamCity is used to retrieve
    the app source code from a repository, created at Bitbucket:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Android应用的即兴分发图可能看起来如下。对于持续集成，在下面的图片中，TeamCity用于从Bitbucket创建的存储库检索应用源代码：
- en: '![](img/a5ac8f4a-96a9-4ff8-8eaa-6e88b0d31777.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5ac8f4a-96a9-4ff8-8eaa-6e88b0d31777.png)'
- en: In the preceding diagram, we used **TeamCity** to instruct **Gradle** to build
    and sign the app and create a **Sonar** report to measure the quality of the code.
    Also, we ran unit tests and ran UI tests (using **Espresso**). Once configured,
    **TeamCity** will take care of all these steps. If they all succeed, then another
    step will upload the signed app (APK file) to **HockeyApp**, which, in turn, notifies
    users about a new version being available. If you prefer you can also use Jenkins
    as a build server, or use Fabric Beta instead of HockeyApp. We will discuss the
    highlights of CI/CD only. There are some interesting books available for both
    build servers. Have a look at [https://www.packtpub.com/](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment)
    for more information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们使用**TeamCity**来指示**Gradle**构建和签名应用，并创建一个**Sonar**报告来衡量代码的质量。此外，我们还运行了单元测试和UI测试（使用**Espresso**）。一旦配置完成，**TeamCity**将负责所有这些步骤。如果它们都成功，那么下一个步骤将上传签名的应用（APK文件）到**HockeyApp**，然后它会通知用户有新版本可用。如果你愿意，你也可以使用Jenkins作为构建服务器，或者使用Fabric
    Beta代替HockeyApp。我们只讨论CI/CD的亮点。对于构建服务器有一些有趣的书籍。有关更多信息，请参阅[https://www.packtpub.com/](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment)。
- en: Building variants
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建变体
- en: It is not unlikely that you will need to deliver more than one version of your
    app. In fact, it could be a smart thing to deliver your app under multiple names,
    each with a different look and feel. It is great for targeting more than one audience.
    Another example is that of delivering a light and paid (or free and pro) version
    of an app. Although a flavor often is used to customize the look and feel, there
    is no reason why you could not use it for enabling or disabling features.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要交付你应用的多个版本，这并不罕见。实际上，在多个名称下发布你的应用，每个名称都有不同的外观和感觉，这可能是一个明智的选择。这对于针对多个受众群体非常有用。另一个例子是发布一个轻量级和付费（或免费和高级）版本的应用。尽管通常使用风味来定制外观和感觉，但也没有理由不能用它来启用或禁用功能。
- en: 'In addition to a particular flavor, you might need to create build types with
    different configurations. Think of an app that is communicating against a backend.
    You probably want to test your app with a different endpoint than the one you
    use for your app in production. This allows you to safely test your app without
    the need to worry that it will mess up your production data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特定的风味之外，你可能需要创建具有不同配置的构建类型。想象一下一个与后端通信的应用。你可能希望使用与生产环境中不同的端点来测试你的应用。这允许你在不担心会破坏生产数据的情况下安全地测试你的应用：
- en: '![](img/7e0cc7d9-b431-4e03-906a-049e842263a2.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e0cc7d9-b431-4e03-906a-049e842263a2.png)'
- en: 'The **build flavor** term is reserved for customization, where the build type
    is for configuration purposes. The combination of a flavor and build type is called
    a **build variant**; well, at least it is like that for Android and Android Studio.
    If you have a light and full version of your app and you need to have at least
    one configuration to use as a test endpoint and one for production, then there
    will be four variants in total, for example like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建口味**这个术语是用于定制的，而构建类型是用于配置目的的。口味和构建类型的组合称为**构建变体**；嗯，至少对于Android和Android
    Studio来说是这样的。如果你有轻量版和完整版的应用，并且需要至少一个配置作为测试端点和一个用于生产，那么总共将有四个变体，例如像这样：'
- en: '![](img/e8bcc165-d993-495a-b33a-1262c7360748.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8bcc165-d993-495a-b33a-1262c7360748.png)'
- en: As we will see later, it is not difficult to accomplish this using Gradle. We
    can use multiple Gradle tasks to build each variant.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将会看到的，使用Gradle完成这个任务并不困难。我们可以使用多个Gradle任务来构建每个变体。
- en: 'Can we do the same for our iOS app? Yes, we can, but in a slightly different
    way. Xcode allows you to define multiple schemes, define a build target, which
    you can compare with a build flavor for Android and a build configuration, which
    indeed, has the same purpose as the build variant:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的iOS应用做同样的事情吗？是的，我们可以，但方式略有不同。Xcode允许你定义多个方案，定义构建目标，这可以与Android的构建口味和构建配置进行比较，实际上，它们具有与构建变体相同的目的：
- en: '![](img/9a0c3049-e3a2-4311-8d4c-93460788d928.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a0c3049-e3a2-4311-8d4c-93460788d928.png)'
- en: 'In Xcode, you will have four different schemes (two targets x two build configurations):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中，你将拥有四个不同的方案（两个目标乘以两个构建配置）：
- en: '![](img/1bdd8440-9cbf-4fe6-87b9-b618ee1b8897.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1bdd8440-9cbf-4fe6-87b9-b618ee1b8897.png)'
- en: If we use a build server, we can use the Xcode command-line tools to determine
    which scheme we want to use for which build.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用构建服务器，我们可以使用Xcode命令行工具来确定针对哪个构建使用哪个方案。
- en: The Gradle way
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle方法
- en: 'For Android, we can use Gradle to:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们可以使用Gradle来：
- en: Determine which resources to use and for which build flavor
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定要使用哪些资源和针对哪个构建口味
- en: Determine which configuration parameters to use for each build type
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定每个构建类型应使用哪些配置参数
- en: Build the app for each variant
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个变体构建应用
- en: Sign the app
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签署应用
- en: Download or clone the sample project from [https://github.com/mikerworks/packt-lean-mobile-app-development](https://github.com/mikerworks/packt-lean-mobile-app-development).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://github.com/mikerworks/packt-lean-mobile-app-development](https://github.com/mikerworks/packt-lean-mobile-app-development)下载或克隆示例项目。
- en: Or, more specifically check out [https://github.com/mikerworks/packt-lean-android-build-variants](https://github.com/mikerworks/packt-lean-android-build-variants).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更具体地，查看[https://github.com/mikerworks/packt-lean-android-build-variants](https://github.com/mikerworks/packt-lean-android-build-variants)。
- en: When we look at the `build.gradle` file (inside the `app` folder) of the sample
    Android app, it has a couple of sections that define how to deal with different
    product flavors. Although it is sufficient to just define the flavors and keep
    the debug and release build types for your project, the sections in the example
    project might prove useful to examine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看示例Android应用的`app`文件夹中的`build.gradle`文件时，它有几个部分定义了如何处理不同的产品口味。尽管仅定义口味并保留项目的调试和发布构建类型就足够了，但示例项目中的部分可能有助于检查。
- en: The sample project has a blue and green version, with a test and a production
    endpoint. Each configuration has a different application ID and config fields.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 样本项目有蓝色和绿色版本，包含测试和生产端点。每个配置都有一个不同的应用程序ID和配置字段。
- en: productFlavors
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: productFlavors
- en: 'In the `productFlavors` section, you can find the different flavors:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`productFlavors`部分，你可以找到不同的口味：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: sourceSets
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sourceSets
- en: 'In the `productFlavors` section, you can see which sources and resources each
    flavor refers to:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`productFlavors`部分，你可以看到每个口味引用哪些源和资源：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `java.srcDirs` and `res.srcDirs` objects determine which folder is being
    referred to for a particular flavor (or flavors).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.srcDirs`和`res.srcDirs`对象确定特定口味（或口味）所引用的文件夹。'
- en: 'In this project, resources such as text (`values.xml`) and colors (`colors.xml`)
    are defined under the `/src/main/res` folder:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此项目中，文本（`values.xml`）和颜色（`colors.xml`）等资源定义在`/src/main/res`文件夹下：
- en: '![](img/52765d2b-7043-4f4a-8641-55850d74852f.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52765d2b-7043-4f4a-8641-55850d74852f.png)'
- en: 'As you can see, there are, besides the `main` folder, two other folders: `blue`
    and `green`. Under the `blue/res` and `green/res` folders, you will find the files
    and values that override the default resources.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了 `main` 文件夹外，还有两个其他文件夹：`blue` 和 `green`。在 `blue/res` 和 `green/res` 文件夹下，您将找到覆盖默认资源的文件和值。
- en: 'For example, the `main` folder has this content for the `color.xml` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`main` 文件夹中的 `color.xml` 文件有如下内容：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example, you can see that, for the `green` flavor, the same resource file
    exists but this time with a different value for `colorBackground` (a nice green
    one):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以看到对于 `green` 香草，相同的资源文件存在，但这次 `colorBackground` 的值不同（一个漂亮的绿色）：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The same applies to the `values.xml` resource file, containing the texts for
    the app.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的，对于包含应用程序文本的 `values.xml` 资源文件也适用。
- en: buildTypes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: buildTypes
- en: 'In the `productFlavors` section, you can see the mapping between the signing
    configuration for the release of a particular flavor and the entry in the `signingConfigs`
    section, which we examine after the `buildTypes` section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `productFlavors` 部分，您可以看到特定香草的发布签名配置与 `signingConfigs` 部分条目的映射，我们将在 `buildTypes`
    部分之后检查：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: signingConfigs
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: signingConfigs
- en: 'In the `productFlavors` section, you see that we can use different signing
    using a different key store for each flavor:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `productFlavors` 部分，您可以看到我们可以为每个香草使用不同的签名，使用不同的密钥库：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the sake of simplicity, you will see all properties, such as `storeFile`,
    `storePassword`, `keyAlias`, and `keyPassword` here, which all refer to the equally
    named properties of the key store. It is a good practice to put these values in
    a separate signing file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，您将在这里看到所有属性，如 `storeFile`、`storePassword`、`keyAlias` 和 `keyPassword`，这些都指的是密钥库中同等名称的属性。将它们放在单独的签名文件中是一种良好的做法。
- en: 'In Android Studio, it will look like this if you open the Build Variants panel:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，如果您打开构建变体面板，它将看起来像这样：
- en: '![](img/8940826c-9181-429e-b228-782ef2102aea.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8940826c-9181-429e-b228-782ef2102aea.png)'
- en: 'Now, all you need to do is tell Gradle to build a particular variant, like
    this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需要告诉 Gradle 构建特定的变体，如下所示：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open a Terminal window to build each variant locally. Next, we will look at
    TeamCity and see how we can use it to build all variants automatically.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口以本地构建每个变体。接下来，我们将查看 TeamCity 并了解我们如何使用它来自动构建所有变体。
- en: Using TeamCity as build agent
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TeamCity 作为构建代理
- en: A build server, such as TeamCity or Jenkins, can be used to automate these processes.
    We will use TeamCity in our examples and you can download it for free at [https://www.jetbrains.com/teamcity/download/](https://www.jetbrains.com/teamcity/download/).
    If you prefer Jenkins, you can get it at [https://jenkins.io](https://jenkins.io).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用构建服务器，如 TeamCity 或 Jenkins，来自动化这些流程。在我们的示例中，我们将使用 TeamCity，您可以在 [https://www.jetbrains.com/teamcity/download/](https://www.jetbrains.com/teamcity/download/)
    免费下载它。如果您更喜欢 Jenkins，您可以在 [https://jenkins.io](https://jenkins.io) 获取它。
- en: 'Download, install, and configure TeamCity on a server or, if just for testing
    purposes, on your development machine. After installing TeamCity, you can start
    the build server. On OS X, open a Terminal window, locate the `bin` folder of
    the `teamcity` folder (for example, `/Users/mike/Dev/teamcity/bin`), and type
    the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上下载、安装和配置 TeamCity，或者如果只是为了测试目的，可以在您的开发机器上安装。安装 TeamCity 后，您可以启动构建服务器。在
    OS X 上，打开一个终端窗口，定位到 `teamcity` 文件夹的 `bin` 文件夹（例如，`/Users/mike/Dev/teamcity/bin`），然后输入以下命令：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start a browser and point it to [`http://localhost:8111`](http://localhost:8111).
    Wait until the setup of TeamCity has completed and then create a new project,
    shown as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 启动浏览器并将它指向 `http://localhost:8111`。等待 TeamCity 的设置完成，然后创建一个新项目，如下所示：
- en: '![](img/52d89b2f-dc4a-4765-8c89-bf682f786a42.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52d89b2f-dc4a-4765-8c89-bf682f786a42.png)'
- en: 'Now that we know how to use Gradle to build different variants, the picture
    shown next cannot be too challenging. We have a light and a full version. We want
    to have two built for each version: one that is consuming the data from the test
    endpoint and another one that is obtaining data from a production endpoint. This
    will result in four APK files in total:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 Gradle 构建不同的变体，接下来显示的图片不会太具有挑战性。我们有一个轻量和完整版本。我们希望为每个版本构建两个：一个从测试端点消耗数据，另一个从生产端点获取数据。这将总共产生四个
    APK 文件：
- en: '![](img/f7a91c9e-abf5-4a68-9599-697c5d5241c2.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7a91c9e-abf5-4a68-9599-697c5d5241c2.png)'
- en: Now we will create some build steps to create four APK files using Gradle, just
    like we did locally. First, we need to tell where TeamCity should get the repository
    from for this particular project. For this project we will use the same repository
    and branch for all flavors, but for more complex projects this may be different
    for flavors and it should be different for build types. This is because it makes
    sense to run your ad hoc tests on a development branch and to run your final tests
    on a production branch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一些构建步骤，使用 Gradle 创建四个 APK 文件，就像我们在本地做的那样。首先，我们需要告诉 TeamCity 应该从哪里获取此特定项目的存储库。对于此项目，我们将为所有口味使用相同的存储库和分支，但对于更复杂的项目，口味和构建类型可能会有所不同。这是因为在一个开发分支上运行您的临时测试，以及在产品分支上运行您的最终测试是有意义的。
- en: 'Define VCS Root for your project and choose Git as the type of VCS. Give it
    a name and choose the following URL as Fetch URL: [https://github.com/mikerworks/packt-lean-android-build-variants.git](https://github.com/mikerworks/packt-lean-android-build-variants.git).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 定义项目的 VCS 根并选择 Git 作为 VCS 类型。给它一个名称，并选择以下 URL 作为获取 URL：[https://github.com/mikerworks/packt-lean-android-build-variants.git](https://github.com/mikerworks/packt-lean-android-build-variants.git)。
- en: You do not need to enter credentials here (Anonymous for Authentication method)
    as this Bitbucket repository has public access.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要在此处输入凭据（认证方法为匿名），因为此 Bitbucket 存储库具有公开访问权限。
- en: 'Now you are ready to create your first build step. Choose Command Line for
    Runner type, so you can enter the same thing for the build script content as you
    did on your local machine:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已准备好创建第一个构建步骤。选择“命令行”作为运行类型，因此您可以为构建脚本内容输入与您在本地机器上相同的内容：
- en: '![](img/972a95fa-770b-48a0-b333-6c3745f9e6ea.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/972a95fa-770b-48a0-b333-6c3745f9e6ea.png)'
- en: For the Custom script field, enter`./gradlew assembleFlavorGreenTestRelease`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“自定义脚本”字段，输入`./gradlew assembleFlavorGreenTestRelease`。
- en: You can define additional build steps in TeamCity, for example, to run unit
    tests, UI tests, SonarCube QA check, and basically anything else that you can
    automate from a command line.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 TeamCity 中定义额外的构建步骤，例如，运行单元测试、UI 测试、SonarCube QA 检查，以及基本上您可以从命令行自动化的任何其他内容。
- en: Automated deploy and delivery
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动部署和交付
- en: 'Your app needs to be distributed once it is built, signed, and tested. There
    are multiple ways to do this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序在构建、签名和测试后需要分发。有多种方法可以做到这一点：
- en: Self-hosted website
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自托管网站
- en: HockeyApp or Fabric beta
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HockeyApp 或 Fabric 测试版
- en: Play Store alpha/beta or iTunes beta/TestFlight
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Play Store alpha/beta 或 iTunes beta/TestFlight
- en: Self hosted
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自托管
- en: You can upload the signed APK and make it available on your own website. For
    Android, it will be sufficient just to host the APK (although you need to do some
    additional configuration for IIS). For iOS, you can distribute your IPA file using
    an **Over the Air** (**OTA**) manifest. If you choose this option, you still need
    to register UDIDs and create a corresponding ad hoc provision profile.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以上传已签名的 APK 并将其发布到您自己的网站上。对于 Android，只需托管 APK 即可（尽管您可能需要为 IIS 进行一些额外的配置）。对于
    iOS，您可以使用 **Over the Air** (**OTA**) 清单分发您的 IPA 文件。如果您选择此选项，您仍然需要注册 UDIDs 并创建相应的临时配置文件。
- en: 'From a high-level perspective, this approach looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个高层次的角度来看，这种方法看起来是这样的：
- en: '![](img/f5b7815b-e1d9-4c45-b4ba-700ee8d116da.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5b7815b-e1d9-4c45-b4ba-700ee8d116da.png)'
- en: You also have to notify your users about a new version being available on your
    website.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须通知您的用户关于网站上有新版本可用。
- en: HockeyApp or Fabric beta
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HockeyApp 或 Fabric 测试版
- en: 'There are many SaaS solutions available to distribute and to notify your users
    of new ad hoc releases. One of them is HockeyApp. You can use a (**cURL**) script
    to upload your signed APK or IPA file to HockeyApp. HockeyApp can also notify
    your users of the new build, and each version can contain release notes, for example,
    by adding a build step running this command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 SaaS 解决方案可用于分发并通知您的用户新的临时发布。其中之一是 HockeyApp。您可以使用一个 (**cURL**) 脚本将您的已签名
    APK 或 IPA 文件上传到 HockeyApp。HockeyApp 还可以通知您的用户新的构建，并且每个版本都可以包含发布说明，例如，通过添加一个运行此命令的构建步骤：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using HockeyApp, the landscape will look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HockeyApp，界面将如下所示：
- en: '![](img/7d7f76bd-c4e6-47bd-868d-70659e513f80.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d7f76bd-c4e6-47bd-868d-70659e513f80.png)'
- en: HockeyApp is a paid service, and it diminishes the provisioning profile hassle
    for the distribution of your iOS app. Fabric Beta is another service that you
    can use for ad hoc distributions. Fabric beta is a freemium service and it works
    pretty much in the same way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: HockeyApp 是一项付费服务，它减轻了您在 iOS 应用程序分发中的配置文件烦恼。Fabric Beta 是另一个您可以用于临时分发的服务。Fabric
    beta 是一个免费增值服务，并且它的工作方式几乎相同。
- en: Fastlane, alpha/beta Play Store, and iTunes beta
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fastlane，alpha/beta Play Store，和 iTunes beta
- en: If you use fastlane in combination with beta Play Store or iTunes beta/Testflight
    distribution, then you probably can save yourself some time and headaches.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将 fastlane 与 beta Play Store 或 iTunes beta/Testflight 分发结合使用，那么您可能可以节省一些时间和麻烦。
- en: '**Fastlane** is a tool for delivering your app to a test or production environment.
    Because it is using iTunes beta for ad hoc distribution of your iOS app, it no
    longer requires you to obtain the UDIDs of your test users up front. The downside
    of this approach is that initially, although it is an ad hoc beta distribution,
    your app needs to be (pre-)approved by Apple, thus taking a little bit more time,
    before a test version becomes available for your test users.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fastlane** 是将您的应用程序交付到测试或生产环境的一种工具。因为它使用 iTunes beta 进行您的 iOS 应用程序的临时分发，所以它不再需要您事先获取测试用户的
    UDID。这种方法的一个缺点是，虽然它是一个临时的 beta 分发，但您的应用程序需要先由 Apple (预-)批准，这会花费更多的时间，直到测试版本对您的测试用户可用。'
- en: 'It changes the high-level picture to this one:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它将高级视图转换为这个：
- en: '![](img/fce1dfe7-8e0c-4e92-a375-91c53eaf4b62.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fce1dfe7-8e0c-4e92-a375-91c53eaf4b62.png)'
- en: The roadmap for fastlane looks like this. It will take care of each part of
    your distribution flow. It was originally developed for iOS app distribution.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: fastlane 的路线图看起来像这样。它将负责您分发流程的每个部分。它最初是为 iOS 应用程序分发开发的。
- en: '>![](img/c9056b75-6da3-4cd3-892b-d31bb2d7aa2e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/c9056b75-6da3-4cd3-892b-d31bb2d7aa2e.png)'
- en: 'Fastlane comes with various other interesting features that will enlighten
    your build automation life, such as:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Fastlane 带有各种其他有趣的功能，这些功能将使您的构建自动化生活更加光明，例如：
- en: Creating (localized) screenshots and uploading them
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建（本地化）截图并上传它们
- en: Sending updated metadata to the App Store
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 App Store 发送更新元数据
- en: Generating and renewing push notification in profiles
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置文件中生成和续订推送通知
- en: Running tests
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Fastlane is also available for Android. It probably is the easiest way to automate
    building and releasing your apps. You can find fastlane at [https://fastlane.tools](https://fastlane.tools).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Fastlane 也适用于 Android。这可能是自动化构建和发布您的应用程序的最简单方法。您可以在 [https://fastlane.tools](https://fastlane.tools)
    找到 fastlane。
- en: It will take some time (and some pain) to correctly set up CI/CD but it is worth
    the investment!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置 CI/CD 需要一些时间（和一些痛苦），但这值得投资！
- en: DevOps
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps
- en: Often you are not just the developer, but also the operator. A **DevOps** culture
    probably is most commonly found at start-up companies; however, more and more
    established companies are adopting its philosophy. DevOps establishes a culture
    and environment where building, testing, and releasing your app will happen fast,
    often, and more reliably, which is exactly what we want. Basically, the idea is
    that the whole process will become the responsibility of the team, from development
    to operation (configuration, monitoring, and moderation). If something in production
    is broken, you create a hotfix, test it, and re-release it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不仅是开发者，还是运营商。**DevOps** 文化最常见于初创公司；然而，越来越多的成熟公司正在采用其哲学。DevOps 建立了一种文化和环境，其中构建、测试和发布您的应用程序将快速、频繁且更可靠地发生，这正是我们所希望的。基本上，这个想法是，整个过程将成为从开发到运营（配置、监控和调节）团队的责任。如果在生产中出现故障，您将创建一个热修复，测试它，然后重新发布它。
- en: 'The Continuous Integration part of CI/CD is about the dev part (of DevOps)
    in particular. The delivery part is more about the Ops part. Together, these two
    cycles can correspond to the build-measure-feedback loop (from a higher perspective):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 的持续集成部分特别关注 DevOps 中的开发部分。交付部分更多地关注运维部分。这两个循环可以对应于构建-度量-反馈循环（从更高视角来看）：
- en: '![](img/ce01d54d-9379-4c3b-a5de-21de99a8d99e.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce01d54d-9379-4c3b-a5de-21de99a8d99e.png)'
- en: Continuous Delivery and DevOps are often used together. They have common goals,
    such as delivering small and quick changes with focused value to the end customer.
    Some of the differences between CD and DevOps are that the latter also focuses
    on the organization change to support great collaboration between the many functions
    involved. It requires good collaboration and communication skills from each of
    the team members. As your organization and your team(s) start to grow, this will
    become increasingly important.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付和DevOps经常一起使用。它们有共同的目标，例如向最终客户提供小而快速的变化，并专注于有价值的方面。CD和DevOps之间的一些区别在于，后者还关注组织变革，以支持涉及到的许多功能之间的良好协作。它要求每个团队成员都具备良好的协作和沟通技巧。随着您的组织和团队开始成长，这一点将变得越来越重要。
- en: CI/CD and DevOps make split testing and gathering feedback more easy to do.
    This approach will contribute significantly to the adoption of the lean start-up
    methodology (seen from a technical perspective). It will result in better quality,
    higher customer satisfaction, and more (and earlier!) releases.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD和DevOps使得分割测试和收集反馈变得更加容易。这种方法将显著促进精益创业方法（从技术角度）的采用。这将导致更好的质量，更高的客户满意度，以及更多（更早！）的发布。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen what CI and CD are, along with their benefits for you. Public or
    ad hoc distribution can be initiated by the build server. You can use a build
    server, such as TeamCity or Jenkins to build and test your app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了CI和CD是什么，以及它们为您带来的好处。公共或临时的分发可以由构建服务器启动。您可以使用构建服务器，例如TeamCity或Jenkins来构建和测试您的应用程序。
- en: Ad hoc releases can be distributed using HockeyApp, Fabric Beta, or the beta
    programs of the Play Store or App Store. Fastlane can help you with these and
    other tasks. By now, you probably have learned a lot already.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用HockeyApp、Fabric Beta或Play Store或App Store的测试版程序来分发临时的发布。Fastlane可以帮助您完成这些和其他任务。到目前为止，您可能已经学到了很多。
- en: CI and CD are important if you want to improve and maintain the quality of your
    code and if you want to optimize your workflow. It allows you to gather feedback
    since you are able to release early and often. CI/CD and a DevOps culture can
    help you with the optimization of the build-measure-feedback loop.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: CI和CD对于您想要提高和维护代码质量，以及想要优化工作流程来说非常重要。它允许您收集反馈，因为您能够提前和频繁地发布。CI/CD和DevOps文化可以帮助您优化构建-度量-反馈循环。
- en: In the next chapter we will learn why building an unfair advantage is important
    if you want to succeed and if you want to survive as a company.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习为什么如果您想成功，如果您想作为一个公司生存下去，构建不公平的优势是重要的。
