- en: Continuous Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see how we can organize a workflow in which we automate
    the process of testing and delivering your app. You can do this for both the ad
    hoc and the public releases of your app. To make the build-measure-feedback loop
    really work for you, you need to release early and often.
  prefs: []
  type: TYPE_NORMAL
- en: You can install Jenkins or TeamCity on a build server or another dedicated machine
    to make a new build of your app each time a new feature becomes available. Basically
    it comes down to that, but there are many interesting strategies to consider.
    For example, what is your branching strategy (Git workflow)? Do you want to run
    unit or UI-tests on the build server? How can you support variants (Android) or
    targets (iOS) for your app? Let's find out in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a look at various tools that can help us with the ad hoc distribution
    of the app. Some of them can also help you with the deployment of your app to
    the Play Store or to the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the benefits of an automated workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing what Continuous Integration, Continuous Delivery, and Continuous Deployment
    are about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figuring out how a good branching strategy can help you to get things done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about **TeamCity** and **Jenkins**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a look at build variants or build targets to support different versions
    of an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining how **Gradle** can help us create different build flavors and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing how we can distribute the app using **Fastlane**, **Fabric**, or **HockeyApp**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Deployment = Continuous Integration and Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are Continuous Integration and Continuous Delivery important in the first
    place? There are number of answers to this question. One of them is that you need
    feedback as early as possible. Since you also want to ensure a certain quality
    level, there may be some friction here. Distributing and testing your app will
    take a large amount of time, however, you also need to release early and often.
  prefs: []
  type: TYPE_NORMAL
- en: A build server can help you to accomplish this goal, because a build server
    can, among other things, verify if your code compiles and if your tests still
    succeed. In addition, it can distribute the app to beta testers or to the App
    or Play Store. At a specific time, or each time a new feature has been implemented,
    the build server will be triggered to perform these and other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a smart-branch strategy is required if you want to set up a Continuous
    Deployment environment. It can also save you a lot of trouble. Here is an example
    of such an environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2309370-b420-47b7-8a46-916f25ad4b07.png)'
  prefs: []
  type: TYPE_IMG
- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, this event will be triggered when changes have been committed and
    pushed to a repository. The build server obtains the source from a specific repository
    and branch. It tries to build the code and it performs automated quality checks
    using **SonarQube**, for example, (QA).
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube is a great tool to measure code quality. It is an automated solution
    so it cannot fully replace code reviews, however, it is capable of finding issues
    that may be or may not become an issue for the quality or performance of your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'SonarQube will take care of:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture and design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding potential bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define custom rules or use the default ones that exist for more than
    20 programming languages, including Java (soon Kotlin will be also be fully supported),
    that you are probably using for your Android app. It can also check Objective-C
    code and Swift. You can find SonarQube here: [http://www.sonarqube.org](http://www.sonarqube.org).
    If the QA check succeeds, then the build server can also run the unit tests and
    even UI-tests.'
  prefs: []
  type: TYPE_NORMAL
- en: You can configure the build server to make a daily build at a specific time
    or to start each time a new pull request is made. The best practice is to create
    a daily build from the development branch or each time you want to have an ad
    hoc release for your testers. For each new pull request, you can create a new
    build (with each new commit) for the specific feature branch. You will find more
    about branching strategies in the 'Repository and Git workflow' paragraph later.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of Continuous Integration is to review code and to test code as
    often as possible by running automated tests (unit and UI tests). The idea is
    that if anything during this flow fails, you will be notified as early as possible.
    This enables you to make changes before your app is distributed. The app is distributed
    only if all steps succeed. If the build breaks, members of your team (often developers)
    will be notified through email, Slack, or any other communication channel that
    you use.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this workflow, the built and tested code is made available as an ad hoc distribution
    to testers (or beta users). They can review the app and apply some manual tests
    to it. They can perform some functionality tests in particular, as a lot of tests,
    but not everything can be automated.
  prefs: []
  type: TYPE_NORMAL
- en: The build server can distribute an ad hoc version of your app by using Fabric,
    HockeyApp, The alpha/beta Play Store, or iTunes Beta (previously known as TestFlight).
    The deployment of your app needs to be as smooth as possible. A tool such as Fastlane
    can help you distribute an ad hoc version and can also you help you to publish
    your app in the Play Store or App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Repository and Git workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build server needs to retrieve the code from a repository. It is always
    a smart idea to use a repository, even when you work alone. Two well-known Git-based
    repositories are GitHub and Bitbucket (also known as Stash). Both come with a
    free and a paid plan. GitHub offers private repositories only in the paid plan
    (see [https://github.com](https://github.com)). A private repository is accessible
    for your team members only. A public repository is available to anyone. Bitbucket
    offers private repositories in the free plan, so let's create a Bitbucket account
    at [https://bitbucket.org](https://bitbucket.org).
  prefs: []
  type: TYPE_NORMAL
- en: A common Git workflow is shown as follows. For the development of each new feature,
    a feature branch will be created. Once completed, and code reviewed via a pull
    request, the feature branch can be merged into the development branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a smart branching strategy, at least two important things can be accomplished:'
  prefs: []
  type: TYPE_NORMAL
- en: Only versions of the app that are fully tested and are accepted can be released
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hotfixes can be applied quickly, without disturbing the continuous integration
    workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This makes sense even when you are the only developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23f14c93-84d0-4a12-a092-183d8f12af55.png)'
  prefs: []
  type: TYPE_IMG
- en: On the dev (or on the feature) branch, unit and UI tests can be run. If all
    tests are successful, the dev branch can be merged into the master branch and
    made ready for release. If, however, something seems to be broken while the app
    is live, you can use feature branching on the master branch to apply a hotfix,
    without disturbing the development of new features.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is just a simplified example, and you may want to do things
    differently depending on your needs. To learn more about the Git workflow, check
    the website at [https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows)
    or [https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows](https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows).
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build server can run the unit tests and even UI tests for your app. For
    UI tests, think of tools such as Espresso (Android) or Xcode UI testing (iOS).
    If you are looking for tools that support both platforms you can check out Appium,
    for example, (available for Android and iOS).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to testing, there are different approaches to consider. One of
    these approaches is **Test-driven Development** (**TDD**). If the functionality
    and all the requirements are known, we can define our tests before developing
    our app. Of course, all tests will fail initially, but that is actually a good
    thing because it will set an outline of what needs to be done and create focus
    to get things right. During the implementation of the features, your tests are
    going to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Espresso is suitable for writing concise and reliable Android UI tests. A test
    typically contains clicks, text input, and checks. To learn more about Espresso
    or Appium, see [https://google.github.io/android-testing-support-library/docs/espresso/](https://google.github.io/android-testing-support-library/docs/espresso/)
    and [http://appium.io](http://appium.io).
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are often run for the feature branch, while integration and UI tests
    are often run for the development branch. After you pass all of your tests, your
    app can be deployed and released to an audience of beta or end users.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a continuous workflow for an Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A picture of the ad hoc distribution of an Android app could look as follows.
    For Continuous Integration, in the picture shown next, TeamCity is used to retrieve
    the app source code from a repository, created at Bitbucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5ac8f4a-96a9-4ff8-8eaa-6e88b0d31777.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we used **TeamCity** to instruct **Gradle** to build
    and sign the app and create a **Sonar** report to measure the quality of the code.
    Also, we ran unit tests and ran UI tests (using **Espresso**). Once configured,
    **TeamCity** will take care of all these steps. If they all succeed, then another
    step will upload the signed app (APK file) to **HockeyApp**, which, in turn, notifies
    users about a new version being available. If you prefer you can also use Jenkins
    as a build server, or use Fabric Beta instead of HockeyApp. We will discuss the
    highlights of CI/CD only. There are some interesting books available for both
    build servers. Have a look at [https://www.packtpub.com/](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Building variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not unlikely that you will need to deliver more than one version of your
    app. In fact, it could be a smart thing to deliver your app under multiple names,
    each with a different look and feel. It is great for targeting more than one audience.
    Another example is that of delivering a light and paid (or free and pro) version
    of an app. Although a flavor often is used to customize the look and feel, there
    is no reason why you could not use it for enabling or disabling features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to a particular flavor, you might need to create build types with
    different configurations. Think of an app that is communicating against a backend.
    You probably want to test your app with a different endpoint than the one you
    use for your app in production. This allows you to safely test your app without
    the need to worry that it will mess up your production data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e0cc7d9-b431-4e03-906a-049e842263a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **build flavor** term is reserved for customization, where the build type
    is for configuration purposes. The combination of a flavor and build type is called
    a **build variant**; well, at least it is like that for Android and Android Studio.
    If you have a light and full version of your app and you need to have at least
    one configuration to use as a test endpoint and one for production, then there
    will be four variants in total, for example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8bcc165-d993-495a-b33a-1262c7360748.png)'
  prefs: []
  type: TYPE_IMG
- en: As we will see later, it is not difficult to accomplish this using Gradle. We
    can use multiple Gradle tasks to build each variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we do the same for our iOS app? Yes, we can, but in a slightly different
    way. Xcode allows you to define multiple schemes, define a build target, which
    you can compare with a build flavor for Android and a build configuration, which
    indeed, has the same purpose as the build variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a0c3049-e3a2-4311-8d4c-93460788d928.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Xcode, you will have four different schemes (two targets x two build configurations):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bdd8440-9cbf-4fe6-87b9-b618ee1b8897.png)'
  prefs: []
  type: TYPE_IMG
- en: If we use a build server, we can use the Xcode command-line tools to determine
    which scheme we want to use for which build.
  prefs: []
  type: TYPE_NORMAL
- en: The Gradle way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Android, we can use Gradle to:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine which resources to use and for which build flavor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine which configuration parameters to use for each build type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the app for each variant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sign the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download or clone the sample project from [https://github.com/mikerworks/packt-lean-mobile-app-development](https://github.com/mikerworks/packt-lean-mobile-app-development).
  prefs: []
  type: TYPE_NORMAL
- en: Or, more specifically check out [https://github.com/mikerworks/packt-lean-android-build-variants](https://github.com/mikerworks/packt-lean-android-build-variants).
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the `build.gradle` file (inside the `app` folder) of the sample
    Android app, it has a couple of sections that define how to deal with different
    product flavors. Although it is sufficient to just define the flavors and keep
    the debug and release build types for your project, the sections in the example
    project might prove useful to examine.
  prefs: []
  type: TYPE_NORMAL
- en: The sample project has a blue and green version, with a test and a production
    endpoint. Each configuration has a different application ID and config fields.
  prefs: []
  type: TYPE_NORMAL
- en: productFlavors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `productFlavors` section, you can find the different flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: sourceSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `productFlavors` section, you can see which sources and resources each
    flavor refers to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `java.srcDirs` and `res.srcDirs` objects determine which folder is being
    referred to for a particular flavor (or flavors).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, resources such as text (`values.xml`) and colors (`colors.xml`)
    are defined under the `/src/main/res` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52765d2b-7043-4f4a-8641-55850d74852f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are, besides the `main` folder, two other folders: `blue`
    and `green`. Under the `blue/res` and `green/res` folders, you will find the files
    and values that override the default resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `main` folder has this content for the `color.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you can see that, for the `green` flavor, the same resource file
    exists but this time with a different value for `colorBackground` (a nice green
    one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The same applies to the `values.xml` resource file, containing the texts for
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: buildTypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `productFlavors` section, you can see the mapping between the signing
    configuration for the release of a particular flavor and the entry in the `signingConfigs`
    section, which we examine after the `buildTypes` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: signingConfigs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `productFlavors` section, you see that we can use different signing
    using a different key store for each flavor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of simplicity, you will see all properties, such as `storeFile`,
    `storePassword`, `keyAlias`, and `keyPassword` here, which all refer to the equally
    named properties of the key store. It is a good practice to put these values in
    a separate signing file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android Studio, it will look like this if you open the Build Variants panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8940826c-9181-429e-b228-782ef2102aea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, all you need to do is tell Gradle to build a particular variant, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Open a Terminal window to build each variant locally. Next, we will look at
    TeamCity and see how we can use it to build all variants automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Using TeamCity as build agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A build server, such as TeamCity or Jenkins, can be used to automate these processes.
    We will use TeamCity in our examples and you can download it for free at [https://www.jetbrains.com/teamcity/download/](https://www.jetbrains.com/teamcity/download/).
    If you prefer Jenkins, you can get it at [https://jenkins.io](https://jenkins.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download, install, and configure TeamCity on a server or, if just for testing
    purposes, on your development machine. After installing TeamCity, you can start
    the build server. On OS X, open a Terminal window, locate the `bin` folder of
    the `teamcity` folder (for example, `/Users/mike/Dev/teamcity/bin`), and type
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a browser and point it to [`http://localhost:8111`](http://localhost:8111).
    Wait until the setup of TeamCity has completed and then create a new project,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52d89b2f-dc4a-4765-8c89-bf682f786a42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we know how to use Gradle to build different variants, the picture
    shown next cannot be too challenging. We have a light and a full version. We want
    to have two built for each version: one that is consuming the data from the test
    endpoint and another one that is obtaining data from a production endpoint. This
    will result in four APK files in total:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7a91c9e-abf5-4a68-9599-697c5d5241c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we will create some build steps to create four APK files using Gradle, just
    like we did locally. First, we need to tell where TeamCity should get the repository
    from for this particular project. For this project we will use the same repository
    and branch for all flavors, but for more complex projects this may be different
    for flavors and it should be different for build types. This is because it makes
    sense to run your ad hoc tests on a development branch and to run your final tests
    on a production branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define VCS Root for your project and choose Git as the type of VCS. Give it
    a name and choose the following URL as Fetch URL: [https://github.com/mikerworks/packt-lean-android-build-variants.git](https://github.com/mikerworks/packt-lean-android-build-variants.git).'
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to enter credentials here (Anonymous for Authentication method)
    as this Bitbucket repository has public access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you are ready to create your first build step. Choose Command Line for
    Runner type, so you can enter the same thing for the build script content as you
    did on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/972a95fa-770b-48a0-b333-6c3745f9e6ea.png)'
  prefs: []
  type: TYPE_IMG
- en: For the Custom script field, enter`./gradlew assembleFlavorGreenTestRelease`.
  prefs: []
  type: TYPE_NORMAL
- en: You can define additional build steps in TeamCity, for example, to run unit
    tests, UI tests, SonarCube QA check, and basically anything else that you can
    automate from a command line.
  prefs: []
  type: TYPE_NORMAL
- en: Automated deploy and delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your app needs to be distributed once it is built, signed, and tested. There
    are multiple ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Self-hosted website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HockeyApp or Fabric beta
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play Store alpha/beta or iTunes beta/TestFlight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self hosted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can upload the signed APK and make it available on your own website. For
    Android, it will be sufficient just to host the APK (although you need to do some
    additional configuration for IIS). For iOS, you can distribute your IPA file using
    an **Over the Air** (**OTA**) manifest. If you choose this option, you still need
    to register UDIDs and create a corresponding ad hoc provision profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a high-level perspective, this approach looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5b7815b-e1d9-4c45-b4ba-700ee8d116da.png)'
  prefs: []
  type: TYPE_IMG
- en: You also have to notify your users about a new version being available on your
    website.
  prefs: []
  type: TYPE_NORMAL
- en: HockeyApp or Fabric beta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many SaaS solutions available to distribute and to notify your users
    of new ad hoc releases. One of them is HockeyApp. You can use a (**cURL**) script
    to upload your signed APK or IPA file to HockeyApp. HockeyApp can also notify
    your users of the new build, and each version can contain release notes, for example,
    by adding a build step running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using HockeyApp, the landscape will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d7f76bd-c4e6-47bd-868d-70659e513f80.png)'
  prefs: []
  type: TYPE_IMG
- en: HockeyApp is a paid service, and it diminishes the provisioning profile hassle
    for the distribution of your iOS app. Fabric Beta is another service that you
    can use for ad hoc distributions. Fabric beta is a freemium service and it works
    pretty much in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Fastlane, alpha/beta Play Store, and iTunes beta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use fastlane in combination with beta Play Store or iTunes beta/Testflight
    distribution, then you probably can save yourself some time and headaches.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fastlane** is a tool for delivering your app to a test or production environment.
    Because it is using iTunes beta for ad hoc distribution of your iOS app, it no
    longer requires you to obtain the UDIDs of your test users up front. The downside
    of this approach is that initially, although it is an ad hoc beta distribution,
    your app needs to be (pre-)approved by Apple, thus taking a little bit more time,
    before a test version becomes available for your test users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It changes the high-level picture to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fce1dfe7-8e0c-4e92-a375-91c53eaf4b62.png)'
  prefs: []
  type: TYPE_IMG
- en: The roadmap for fastlane looks like this. It will take care of each part of
    your distribution flow. It was originally developed for iOS app distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/c9056b75-6da3-4cd3-892b-d31bb2d7aa2e.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fastlane comes with various other interesting features that will enlighten
    your build automation life, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating (localized) screenshots and uploading them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending updated metadata to the App Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating and renewing push notification in profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fastlane is also available for Android. It probably is the easiest way to automate
    building and releasing your apps. You can find fastlane at [https://fastlane.tools](https://fastlane.tools).
  prefs: []
  type: TYPE_NORMAL
- en: It will take some time (and some pain) to correctly set up CI/CD but it is worth
    the investment!
  prefs: []
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often you are not just the developer, but also the operator. A **DevOps** culture
    probably is most commonly found at start-up companies; however, more and more
    established companies are adopting its philosophy. DevOps establishes a culture
    and environment where building, testing, and releasing your app will happen fast,
    often, and more reliably, which is exactly what we want. Basically, the idea is
    that the whole process will become the responsibility of the team, from development
    to operation (configuration, monitoring, and moderation). If something in production
    is broken, you create a hotfix, test it, and re-release it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Continuous Integration part of CI/CD is about the dev part (of DevOps)
    in particular. The delivery part is more about the Ops part. Together, these two
    cycles can correspond to the build-measure-feedback loop (from a higher perspective):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce01d54d-9379-4c3b-a5de-21de99a8d99e.png)'
  prefs: []
  type: TYPE_IMG
- en: Continuous Delivery and DevOps are often used together. They have common goals,
    such as delivering small and quick changes with focused value to the end customer.
    Some of the differences between CD and DevOps are that the latter also focuses
    on the organization change to support great collaboration between the many functions
    involved. It requires good collaboration and communication skills from each of
    the team members. As your organization and your team(s) start to grow, this will
    become increasingly important.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD and DevOps make split testing and gathering feedback more easy to do.
    This approach will contribute significantly to the adoption of the lean start-up
    methodology (seen from a technical perspective). It will result in better quality,
    higher customer satisfaction, and more (and earlier!) releases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen what CI and CD are, along with their benefits for you. Public or
    ad hoc distribution can be initiated by the build server. You can use a build
    server, such as TeamCity or Jenkins to build and test your app.
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc releases can be distributed using HockeyApp, Fabric Beta, or the beta
    programs of the Play Store or App Store. Fastlane can help you with these and
    other tasks. By now, you probably have learned a lot already.
  prefs: []
  type: TYPE_NORMAL
- en: CI and CD are important if you want to improve and maintain the quality of your
    code and if you want to optimize your workflow. It allows you to gather feedback
    since you are able to release early and often. CI/CD and a DevOps culture can
    help you with the optimization of the build-measure-feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn why building an unfair advantage is important
    if you want to succeed and if you want to survive as a company.
  prefs: []
  type: TYPE_NORMAL
