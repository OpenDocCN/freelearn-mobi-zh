<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Running and Running and Running...</h1></div></div></div><p>In this chapter we will be exploring randomly generated landscapes, how to create a lot of different enemies with very little code, parallax scrolling, and using particle effects for extra visual flair. We've covered a lot of the smaller housekeeping details several times, so for this project we will be focusing on the new, interesting code and not re-covering old ground.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Randomizing terrain</li><li class="listitem" style="list-style-type: disc">Endless scrolling parallax backgrounds</li><li class="listitem" style="list-style-type: disc">Using your own sensors</li><li class="listitem" style="list-style-type: disc">Animation made simple</li><li class="listitem" style="list-style-type: disc">Particle effects</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec92"/>The game is...</h1></div></div></div><p>This time around we will be designing a <a id="id2049" class="indexterm"/>side scrolling endless runner. The <a id="id2050" class="indexterm"/>endless runner game style has really taken off in the mobile gaming world, and it is a fun game style to implement using Cocos2d. Basic gameplay will be a simple two-touch control method: touches on the left half of the screen make the hero jump and touches on the right half of the screen will make the hero shoot. The game will scroll continuously, leaving no time for the player to stop and rest. As the game progresses, it will steadily increase the scrolling speed, so it gets harder the longer you play. For all of our graphics (except for the background images), we will be using the Planet-X graphics created by <a id="id2051" class="indexterm"/>
<a id="id2052" class="indexterm"/>James Macanufo at <a class="ulink" href="http://tintanker.com">http://tintanker.com</a>, used here with the creator's permission. You can find his original images at <a class="ulink" href="http://tintanker.com/makegameswithus">http://tintanker.com/makegameswithus</a>. If you enjoy the graphics, James deserves full credit for this fun and whimsical set.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec93"/>Design review</h1></div></div></div><p>When you are designing a side-scrolling endless runner, there are two primary design approaches. Some will use a physics engine like Box2D or Chipmunk to help control all of the object interactions. We will be taking the other <a id="id2053" class="indexterm"/>approach by building our own lightweight physics engine for the game. All of our ground will use square tiles, so we can easily identify the surfaces our hero can walk on safely. We will build sensors on the top of all walkable surfaces, as well as building <a id="id2054" class="indexterm"/>
<a id="id2055" class="indexterm"/>sensors underneath each of our walking characters (hero and enemies). The hero will be in a fixed x coordinate on the screen, and the world will scroll past the hero. We will have two types of enemies: flying and walking. Both will have similar behavior, but the walkers will have the sensors we mentioned to allow them to walk back and forth on their platforms. Enemies will not be allowed to walk off the platforms to their death. We will also implement a two level endless parallax background from scratch. Finally, we want some fun effects when enemies (or the hero) die. We will be using particle effects, built using Particle Designer. We will only measure the player's success in the game with one metric: distance travelled. That about covers the basics of the design, so let's take a peek at the finished game:</p><div><img src="img/9007_9_01.jpg" alt="Design review"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec94"/>Building the ground</h1></div></div></div><p>We will start by building the random ground tiles. For our game, we have three types of ground, with three ground images for each type, so we can build stacks with them. For organization, the image that has a gradient color (the bottom) <a id="id2056" class="indexterm"/>will be identified as <code class="literal">1</code>, the middle as <code class="literal">2</code>, and the top (with the grassy surface) as <code class="literal">3</code>. <a id="id2057" class="indexterm"/>
<a id="id2058" class="indexterm"/>Let's take a look at the code to build the ground, in two parts.</p><p>
<strong>Filename</strong>: <a id="id2059" class="indexterm"/>
<a id="id2060" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code> (<code class="literal">addGround…</code>, part 1)</p><div><pre class="programlisting">-(void) addGroundTileswithEnemies:(BOOL)haveEnemies {
    // Randomize nearly everything about the ground
    NSInteger platformWidth = (arc4random() % 5) + 2;
    NSInteger platformHeight = (arc4random() % 4) + 1;
    NSInteger platformType = (arc4random() % 3) + 1;

    switch (platformHeight) {
        case 1:
            [platformStack addObject:[NSNumber
                                      numberWithInt:3]];
            break;
        case 2:
            [platformStack addObject:[NSNumber
                                      numberWithInt:1]];
            [platformStack addObject:[NSNumber
                                      numberWithInt:3]];
            break;
        case 3:
            [platformStack addObject:[NSNumber
                                      numberWithInt:1]];
            [platformStack addObject:[NSNumber
                                      numberWithInt:2]];
            [platformStack addObject:[NSNumber
                                      numberWithInt:3]];
            break;
        case 4:
            [platformStack addObject:[NSNumber
                                      numberWithInt:1]];
            [platformStack addObject:[NSNumber
                                      numberWithInt:3]];
            [platformStack addObject:[NSNumber
                                      numberWithInt:2]];
            [platformStack addObject:[NSNumber
                                      numberWithInt:3]];
            break;
    }</pre></div><p>We start this method by randomizing the width, the height, and the type (graphic set) for the platform. The width and height are both expressed in terms of how many tiles we will use for this platform. You will notice that the width adds <code class="literal">2</code> to the result of the <code class="literal">arc4random()</code> call. <a id="id2061" class="indexterm"/>
<a id="id2062" class="indexterm"/>This is because we want the platform to be a minimum of 2 tiles wide. Anything smaller is too challenging to land on, once we add enemies into the mix. We then move into a big <a id="id2063" class="indexterm"/>
<a id="id2064" class="indexterm"/>
<code class="literal">switch</code> statement, passing it the <code class="literal">platformHeight</code> variable. We have designed "stacks" for the different elevations to be more playable. The tile type 3 is the only type of walkable tile, so we need to make sure there is a walkable tile on top. This predefined stack approach guarantees we will <a id="id2065" class="indexterm"/>have something that looks more pleasant and is playable. You will notice that the case 4 has two uses of tile type 3 (the walkable tile) in the stack. This will give that "stack" two separate platforms for the hero to walk on. We do this for variety, but also to make sure we don't have an impossible arrangement, if the terrain goes directly from an elevation 1 to an elevation 4. <a id="id2066" class="indexterm"/>The lower surface gives the hero something else to land on.</p><p>
<strong>Filename</strong>: <code class="literal">ERPlayfieldLayer.m</code> (<code class="literal">addGround…</code>, part 2)</p><div><pre class="programlisting">    for (int w = 0; w &lt;= platformWidth; w++) {
        // Set the new X position for the tile
        maxTileX = maxTileX + tileSize;
        
        for (int i = 0; i &lt; platformHeight; i++) {
            NSInteger currentTile = [[platformStack
                   objectAtIndex:i] integerValue];
            
            NSString *tileNm = [NSString stringWithFormat:@"w%i_%i.png", platformType, currentTile];
            ERTile *tile = [ERTile
                spriteWithSpriteFrameName:tileNm];

            // Determine where to position the tile
            [tile setAnchorPoint:ccp(0.5,0)];
            float newY = i * tileSize;
            
            // Identify if we need a walkable surface
            if (currentTile == 3) {
                [tile setIsTop:YES];
                
                // Do we want enemies to spawn here?
                if (haveEnemies) {
                    // Determine if we need an enemy here
                    if ((arc4random() % 13) &lt; 1) {
                        // chance of an enemy walker
                        // Add it slightly above the ground
                        [self addWalkingEnemyAtPosition:
                         ccp(maxTileX, newY + tileSize)];
                    }
                }
            } else {
                [tile setIsTop:NO];
            }
            
            // Set the position (will also create sensor)
            [tile setPosition:ccp(maxTileX, newY)];
            
            [grndArray addObject:tile];
            [runnersheet addChild:tile z:currentTile];
        }
    }
    [platformStack removeAllObjects];
}</pre></div><p>Now that we have a stack defined, we iterate through the number of tiles wide we need. The <code class="literal">maxTileX</code> variable is <a id="id2067" class="indexterm"/>
<a id="id2068" class="indexterm"/>populated with the <code class="literal">x</code> position we need for the current stack of tiles. Once that is updated for the current stack, we enter another loop, based on the <code class="literal">platformHeight</code> variable. We get the next tile from the <code class="literal">platformStack</code> array, and build the sprite name in the <code class="literal">tileNm</code> variable. This is a case where the consistent naming convention of the files really helps out. We then create a new <code class="literal">ERTile</code> object. <code class="literal">ERTile</code> is a subclass of the <a id="id2069" class="indexterm"/>
<a id="id2070" class="indexterm"/>
<code class="literal">CCSprite</code> class, which we will look at in just a few moments. We set the anchor point to center bottom so we can easily build the tiles f<a id="id2071" class="indexterm"/>rom the bottom of the screen, and we define the <code class="literal">y</code> value by multiplying times the <code class="literal">tileSize</code> variable we define in our <code class="literal">init</code> method (50, the size in points of the square tiles). We then check to see if the tile is type 3. Remember, tile 3 is a walkable surface. If it is a walkable surface, we set the tile's <code class="literal">isTop</code> value to <code class="literal">YES</code>. (We also try to generate an enemy on the walkable surface some percentage of the time.) Finally, we set the position of the tile, add it to the <a id="id2072" class="indexterm"/>
<a id="id2073" class="indexterm"/>
<code class="literal">grndArray</code> array, and add the tile as a child of the <code class="literal">runnersheet</code> (our <code class="literal">CCSpriteBatchNode</code> which houses all of our foreground images). The last thing we do here is to remove all objects from the <code class="literal">platformStack</code> array, so it will be ready for the next time we add ground.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec113"/>ERTile class</h2></div></div></div><p>We said that <code class="literal">ERTile</code> is a subclass of the <a id="id2074" class="indexterm"/>
<a id="id2075" class="indexterm"/>
<code class="literal">CCSprite</code> class, but for most purposes it acts like a normal sprite. Let's take a look at the <a id="id2076" class="indexterm"/>implementation file to see why we <a id="id2077" class="indexterm"/>need it.</p><p>
<strong>Filename</strong>: <a id="id2078" class="indexterm"/>
<a id="id2079" class="indexterm"/>
<code class="literal">ERTile.m</code>
</p><div><pre class="programlisting">-(void) defineSensors {
    topSensor = CGRectMake(self.boundingBox.origin.x,
                           self.boundingBox.origin.y +
                           self.boundingBox.size.height - 10,
                           self.boundingBox.size.width,
                           5);
}

-(void) setPosition:(CGPoint)position {
    // Override set position so we can keep the sensors
    // together with sprite
    [super setPosition:position];
    
    if (isTop) {
        [self defineSensors];
    }
}</pre></div><p>These two methods are the only methods included in the <code class="literal">ERTile</code> class. We define variables and properties for the <code class="literal">topSensor</code> and <code class="literal">isTop</code>, but that's it for this class. The main piece we need to understand is the sensor. The <code class="literal">topSensor</code> is a <code class="literal">CGRect</code> we define in relation to the bounding box of the tile. As you can see, this <a id="id2080" class="indexterm"/>
<a id="id2081" class="indexterm"/>
<code class="literal">topSensor</code> is the full width of the sprite and is <code class="literal">5</code> points high, a few points inside the top of the sprite. This is the level at which "ground" will be defined for this tile. To use this, we also override the <code class="literal">setPosition</code> method. When the <code class="literal">setPosition</code> method is called, it sends the same command to the <code class="literal">super</code> version of itself (that is, <code class="literal">CCSprite</code> class), and if the <code class="literal">isTop</code> value is <code class="literal">YES</code>, then it calls to the <a id="id2082" class="indexterm"/>
<a id="id2083" class="indexterm"/>
<code class="literal">defineSensors</code> method. We have to keep redefining it because the <code class="literal">CGRect</code> will otherwise stay exactly where you put it on screen, even if the sprite itself moves. By redefining it with every <a id="id2084" class="indexterm"/>
<a id="id2085" class="indexterm"/>
<code class="literal">setPosition</code> call, we guarantee it is exactly where we need it, relative to the tile. </p><p>There are other ways we could have accomplished this same effect, including invisible child sprites under the <code class="literal">ERTile</code> class. We have chosen this approach because a <code class="literal">CGRect</code> is a lot less resource intensive than defining another sprite for every tile (and character). For our purposes, this <code class="literal">CGRect</code> implementation is fast, reliable, and because we tie it into the overridden <a id="id2086" class="indexterm"/>
<a id="id2087" class="indexterm"/>
<code class="literal">setPosition</code> method, it is <a id="id2088" class="indexterm"/>invisible to any other methods that manipulate the sprite.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec114"/>Adding gap tiles</h2></div></div></div><p>We don't want end-to-end ground, since we need the ability for our hero to fall to his death. We build these gap tiles in much the same fashion as the <a id="id2089" class="indexterm"/>ground tiles, <a id="id2090" class="indexterm"/>except the gap tiles are only one tile high.</p><p>
<strong>Filename</strong>: <a id="id2091" class="indexterm"/>
<a id="id2092" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) addGapTiles {
    // Add spaces between tiles
    // Size of gap depends on current speed
    NSInteger gapRnd = arc4random() % 5;

    // Only create a gap some of the time
    if (gapRnd &gt; 1) {
        // Largest gap allowed is 5 tiles
        NSInteger gapSize = MIN(5, scrollSpeed);
        
        // Determine which gap/water image to use
        NSInteger gapType = (arc4random() % 2) + 1;

        for (int w = 0; w &lt; gapSize; w++) {
            // We make the water slightly narrower
            maxTileX = maxTileX + tileSize - 2;

            NSString *tileNm = [NSString
                stringWithFormat:@"gap%i.png", gapType];
            ERTile *tile = [ERTile
               spriteWithSpriteFrameName:tileNm];
            
            [tile setAnchorPoint:ccp(0.5,0)];

            // Put tile at bottom of screen
            [tile setPosition:ccp(maxTileX, 0)];
            
            // Gap tiles are not walkable
            [tile setIsTop:NO];
            
            [grndArray addObject:tile];
            [runnersheet addChild:tile z:-1];
        }
    }
    
    // 10 % chance of spawning a flying enemy
    if (arc4random() % 10 == 1) {
        float newY = (arc4random() % 40) + 250;
        [self addFlyingEnemyAtPosition:ccp(maxTileX, newY)];
    }
    // Always add more tiles after the gap
    [self addGroundTileswithEnemies:YES];
}</pre></div><p>The structure of this method is pretty similar to the ground tile method. We start by using a randomizer to determine if we need a gap or not. We have a three in five chance that we will build a gap (if the <code class="literal">gapRnd</code> value is greater than <code class="literal">1</code>). This lets us have some ground-to-ground passages for more variety. We control the width of the gaps a little differently. We take the <code class="literal">MIN</code> value of the <a id="id2093" class="indexterm"/>
<a id="id2094" class="indexterm"/>
<code class="literal">scrollSpeed</code> variable or <code class="literal">5</code>, so when the game is scrolling slower, the gaps will also be smaller. But as the game ramps up in speed, we don't want any tile gaps larger than 5. The loop in this method is virtually identical to the one in the ground method, except these tiles are never walkable. We also randomize the creation of flying enemies over the gaps. The chance is lower than with walking enemies, and we randomize their starting elevation between <code class="literal">y</code> values of <a id="id2095" class="indexterm"/>250 and 289. Finally, whenever we build a gap, we immediately call the method to build the ground tiles. This ensures that we don't have to worry about which method to call later on. We simply call the <code class="literal">addGapTiles</code> method, and it takes care of both of these methods.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec115"/>Scrolling the tiles</h2></div></div></div><p>In our game, there is a lot that needs to be updated, so we have <a id="id2096" class="indexterm"/>broken out our <code class="literal">update</code> method into individual methods for <a id="id2097" class="indexterm"/>each type of update. Let's take a look at how we update the tiles.</p><p>
<strong>Filename</strong>: <a id="id2098" class="indexterm"/>
<a id="id2099" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) updateTiles {
    //Update the ground position, if scrolling
    if (isScrolling) {
        for (CCSprite *aTile in grndArray) {
            [aTile setPosition:ccpAdd(aTile.position, 
                                      ccp(-scrollSpeed,0))];
        }
        // Update HUD
        distanceTravelled = distanceTravelled + 
                                   (scrollSpeed / 100);
        [hudLayer changeDistanceTo:distanceTravelled];
        
        // Speed up the scroll slowly
        scrollSpeed = scrollSpeed + 0.001;
    }

    // Reset the maxTileX value
    maxTileX = 0;
    
    // Check all tiles
    for (ERTile *aTile in grndArray) {
        // Check for tiles scrolled away
        if (aTile.position.x &lt; -100) {
            [grndToDelete addObject:aTile];
            [aTile removeFromParentAndCleanup:YES];
        }
        
        // Check for the rightmost tiles
        if (aTile.position.x &gt; maxTileX) {
            maxTileX = aTile.position.x;
        }
    }
    
    // Remove off-screen tiles
    [grndArray removeObjectsInArray:grndToDelete];
    [grndToDelete removeAllObjects];
    
    // Check if we need to add new tiles
    if (maxTileX &lt; (size.width * 1.1)) {
        // Add a gap first
        [self addGapTiles];
    }
}</pre></div><p>The first callout here is that we have a variable in our layer called <code class="literal">isScrolling</code> that controls whether or not the world is scrolling. It is a simple Boolean variable, used to start or stop the scrolling as we see fit. We also have a <a id="id2100" class="indexterm"/>
<a id="id2101" class="indexterm"/>
<code class="literal">scrollSpeed</code> variable, which controls the speed of the scroll. In our <code class="literal">init</code> method we start this at a value of <code class="literal">2.5f</code>. In this method, we go through every tile in the <a id="id2102" class="indexterm"/>
<a id="id2103" class="indexterm"/>
<code class="literal">grndArray</code> array, and add the negative of the <code class="literal">scrollSpeed</code> value <a id="id2104" class="indexterm"/>
<a id="id2105" class="indexterm"/>(to move everything left) to the current position of each tile. We then update our distance travelled, and call out to the <a id="id2106" class="indexterm"/>HUD to update the display. (Note: we will not be discussing the HUD layer here. It is structurally the same as how we built the HUD in <a class="link" href="ch08.html" title="Chapter 8. Shoot, Scroll, Shoot Again">Chapter 8</a>, <em>Shoot, Scroll, Shoot Again</em>, so flip back there for a refresher, if needed). We also increase the scroll speed a little bit each time this method is called, so the speed will slowly increase as the game progresses.</p><p>After we move everything, we need to do some tile maintenance. We look for any tiles whose <code class="literal">x</code> value is less than <code class="literal">-100</code>, and remove them. At the same time, we reset the <code class="literal">maxTileX</code> value to the <code class="literal">x</code> position of the rightmost tile we find. If that <a id="id2107" class="indexterm"/>
<a id="id2108" class="indexterm"/>
<code class="literal">maxTileX</code> value is less than <code class="literal">1.1</code> times the width of the screen, we call to the <a id="id2109" class="indexterm"/>
<a id="id2110" class="indexterm"/>
<code class="literal">addGapTiles</code> method to build some gaps and ground. That's all it takes to make a scrolling, randomly generated ground.</p><p>There is one slight issue, however. There will be visible seams between the tiles. Fortunately, this has a simple fix. In the cocos2d source files, there is a file called <code class="literal">ccConfig.h</code>. Open this file and find the line (line 85, in the 2.0 version) that looks like:</p><p>
<strong>Filename</strong>: <code class="literal">ccConfig.h</code>
</p><div><pre class="programlisting">#define CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL 0</pre></div><p>Change the value of <code class="literal">0</code> to <code class="literal">1</code>, and the seams disappear. How easy is that?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec95"/>Parallax background</h1></div></div></div><p>Before we move on to our hero, let's turn our attention to the other endless element of the game: the background. We want to have a two-layer parallax background that is endlessly scrolling. A <a id="id2111" class="indexterm"/>
<a id="id2112" class="indexterm"/>parallax background is simply one that has multiple layers that scroll at different rates, to simulate the way that distant terrain looks like it is moving slower than closer terrain. We simulate this by throttling the scrolling speed of each layer of the background to a relative speed. Let's look at our background class and see how it works.</p><p>
<strong>Filename</strong>: <a id="id2113" class="indexterm"/>
<a id="id2114" class="indexterm"/>
<code class="literal">ERBackground.h</code>
</p><div><pre class="programlisting">-(id) init {
    if(self = [super init]) {
        size = [[CCDirector sharedDirector] winSize];
        
        bg1 = [CCSprite spriteWithFile:@"bg_mtns.png"];
        [bg1 setAnchorPoint:ccp(0,0)];
        [bg1 setPosition:ccp(0, 0)];
        [self addChild:bg1];

        bg2 = [CCSprite spriteWithFile:@"bg_mtns.png"];
        [bg2 setAnchorPoint:ccp(0,0)];
        [bg2 setPosition:ccp(1001, 0)];
        [self addChild:bg2];
        
        [bg2 setFlipX:YES];
    }
    return self;
}</pre></div><p>The <a id="id2115" class="indexterm"/>
<a id="id2116" class="indexterm"/>
<code class="literal">ERBackground</code> class is a subclass of the <a id="id2117" class="indexterm"/>
<a id="id2118" class="indexterm"/>
<code class="literal">CCLayer</code> class. Here we simply add two sprites to the layer using the <code class="literal">bg_mtns.png</code> image. You will notice we aren't using a sprite sheet here. Since it is a single image, there would be minimal performance gains using a sprite sheet here. We position one at (<code class="literal">0,0</code>) and the other at (<code class="literal">1001,0</code>). The image itself is 1000 points wide, so this will put them one after the other. We flip the second sprite to add some variety to the landscape, even though we are using the same image twice.</p><p>
<strong>Filename</strong>: <a id="id2119" class="indexterm"/>
<a id="id2120" class="indexterm"/>
<code class="literal">ERBackground.m</code>
</p><div><pre class="programlisting">-(void) useDarkBG {
    // Tint for darker mountains
    [bg1 setColor:ccc3(150,150,150)];
    [bg2 setColor:ccc3(150,150,150)];
}</pre></div><p>We will be using the same image for both of the parallax layers, so we want to make one seem farther away. The <a id="id2121" class="indexterm"/>
<a id="id2122" class="indexterm"/>
<code class="literal">useDarkBG</code> method call will darken the image by about half when this method is called. Now we need to be able to move the background and make it endless.</p><p>
<strong>Filename</strong>: <a id="id2123" class="indexterm"/>
<a id="id2124" class="indexterm"/>
<code class="literal">ERBackground.m</code>
</p><div><pre class="programlisting">-(void) update:(ccTime)dt {
    // Move the mountains by their scroll speed
    [bg1 setPosition:ccpAdd(bg1.position,
                            ccp(-bgScrollSpeed,0))];
    [bg2 setPosition:ccpAdd(bg2.position,
                            ccp(-bgScrollSpeed,0))];
    
    // If bg1 is completely off-screen, move after bg2
    if (bg1.position.x &lt; (-1000 - initialOffset.x)) {
        [bg1 setPosition:ccpAdd(bg2.position,
                        ccp(1000 + initialOffset.x,0))];
    }
    
    // If bg2 is completely off-screen, move after bg1
    if (bg2.position.x &lt; (-1000 - initialOffset.x)) {
        [bg2 setPosition:ccpAdd(bg1.position,
                        ccp(1000 + initialOffset.x,0))];
    }
}</pre></div><p>When the <code class="literal">update</code> method is called, we move both images to the left by their designated <code class="literal">bgScrollSpeed</code> value. <a id="id2125" class="indexterm"/>
<a id="id2126" class="indexterm"/>Then each background is checked to see if it is off-screen by 1000 points. If it is, then that sprite is repositioned to the right <a id="id2127" class="indexterm"/>side of the other sprite. This means that every time one sprite is completely off-screen to the left, it is moved to the far right, so it will scroll through again. We obviously have a few parameters that need to be set from outside this class. Let's see how we set this up.</p><p>
<strong>Filename</strong>: <a id="id2128" class="indexterm"/>
<a id="id2129" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code> (inside <code class="literal">init</code>)</p><div><pre class="programlisting">        // Build the scrolling background layers
        background1 = [[ERBackground alloc] init];
        [background1 setAnchorPoint:ccp(0,0)];
        [background1 setPosition:ccp(0,0)];
        [background1 useDarkBG];
        [background1 setBgScrollSpeed:0.025];
        [self addChild:background1 z:-2];
        
        background2 = [[ERBackground alloc] init];
        [background2 setAnchorPoint:ccp(0,0)];
        [background2 setPosition:ccp(200,0)];
        [background2 setInitialOffset:ccp(200,0)];
        [background2 setBgScrollSpeed:0.1];
        [self addChild:background2 z:-3];</pre></div><p>Here you see that the <code class="literal">background1</code> object calls the <code class="literal">useDarkBG</code> method, and sets a <code class="literal">bgScrollSpeed</code> value of <code class="literal">0.025</code>, which is nice and slow. These are the mountains in the distance. The other layer, <code class="literal">background2</code>, sets its initial offset to be <code class="literal">200</code> to the right (and sets the corresponding position), so the mountains do not start exactly on top of each other. It also uses a faster scrolling rate of <code class="literal">0.1</code>. That is all it takes to establish the mountains. The one piece that is left to complete the parallax is how to call the <code class="literal">update</code> method. We do not set any schedules in the <a id="id2130" class="indexterm"/>
<a id="id2131" class="indexterm"/>
<code class="literal">ERBackground</code> class. Instead, we call this <code class="literal">update</code> method manually from the playfield's <code class="literal">update</code> method:</p><p>
<strong>Filename</strong>: <a id="id2132" class="indexterm"/>
<a id="id2133" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) update:(ccTime)dt {

    // Move the background layers
    [background1 update:dt];
    [background2 update:dt];</pre></div><p>On each iteration of the playfield's <code class="literal">update</code> method, it calls out the background layers, and they take care of themselves with nothing else needed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec96"/>Our hero</h1></div></div></div><p>Now we can turn our attention to our hero, the little spaceman. <a id="id2134" class="indexterm"/>Let's start by looking through the <a id="id2135" class="indexterm"/>
<a id="id2136" class="indexterm"/>
<code class="literal">ERHero</code> class.</p><p>
<strong>Filename</strong>: <code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">+(id)spriteWithSpriteFrameName:(NSString *)spriteFrameName {
   return [[[self alloc] initWithSpriteFrameName:spriteFrameName] autorelease];
}

-(id) initWithSpriteFrameName:(NSString *)spriteFrameName {
    if(self = [super initWithSpriteFrameName:spriteFrameName]) { 
        _state = kHeroFalling;
        
        // Let the hero take 5 hits before death
        heroHealth = 5;

    }
    return self;
}</pre></div><p>The <code class="literal">ERHero</code> class is a subclass of <code class="literal">CCSprite</code> class. Because we need a custom <code class="literal">init</code> method for the sprite, we have overridden the <a id="id2137" class="indexterm"/>
<a id="id2138" class="indexterm"/>
<code class="literal">spriteWithSpriteFrameName</code> class method and the corresponding <code class="literal">init</code> method. As the <code class="literal">_state</code> variable might lead you to guess, the hero <a id="id2139" class="indexterm"/>will be operating as a simple state machine. Let's see what states are valid:</p><p>
<strong>Filename</strong>: <a id="id2140" class="indexterm"/>
<a id="id2141" class="indexterm"/>
<code class="literal">ERDefinitions.m</code>
</p><div><pre class="programlisting">typedef enum {
    kHeroRunning = 1,
    kHeroJumping,
    kHeroInAir,
    kHeroFalling
} HeroState;</pre></div><p>Now we can look at how the states are changed for our hero.</p><p>
<strong>Filename</strong>: <a id="id2142" class="indexterm"/>
<a id="id2143" class="indexterm"/>
<code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) stateChangeTo:(HeroState)newState {
    // Make sure we are actually changing state
    if (newState == _state) {
        return;
    }
    // Stop old actions
    [self stopAllActions];
    // Reset the color if we were flashing
    if (isFlashing) {
        CCTintTo *normal = [CCTintTo actionWithDuration:
                            0.05 red:255 green:255 blue:255];
        CCCallBlock *done = [CCCallBlock actionWithBlock:^{
            isFlashing = NO;
        }];
        [self runAction:[CCSequence actions:normal,
                         done, nil]];
    }
    
    // Determine what to do now
    switch (newState) {
        case kHeroRunning:
            [self playRunAnim];
            break;
        case kHeroJumping:
            [self playJumpAnim];
            break;
        case kHeroFalling:
            [self playLandAnim];
            break;
        case kHeroInAir:
            // Leave the last frame
            break;
    }
    _state = newState;
    
    [self defineSensors];
}</pre></div><p>We start by checking to make sure we are not trying to reassign to the same state. If we are, we exit. We then stop all actions, because most of the actions are related to animations, so we want to stop the prior ones before running the new animation. The <code class="literal">isFlashing</code> <a id="id2144" class="indexterm"/>
<a id="id2145" class="indexterm"/>check relates to when the hero gets hit (he flashes red for a brief moment). We put this check in here to see if the hero was flashing when the state is changed. If he is flashing, then we force the hero back to normal color. We do this because the <a id="id2146" class="indexterm"/>
<a id="id2147" class="indexterm"/>
<code class="literal">stopAllActions</code> method will also stop all actions, including the "tint color" actions. The end result is that without this clause, the hero would get stuck with a red tint if his state changed when he got hit.</p><p>The core of the <a id="id2148" class="indexterm"/>
<a id="id2149" class="indexterm"/>
<code class="literal">stateChangeTo</code> method is the switch statement at the bottom. It evaluates the state and calls the appropriate animation method. Finally, it defines the sensors, to make sure we have current sensors in place.</p><p>
<strong>Filename</strong>: <code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) defineSensors {
    
    footSensor = CGRectMake(self.boundingBox.origin.x+20,
                              self.boundingBox.origin.y,
                              self.boundingBox.size.width-40,
                              1);
    fallSensor = CGRectMake(self.boundingBox.origin.x+20,
                              self.boundingBox.origin.y-3,
                              self.boundingBox.size.width-40,
                              2);
}

-(void) setPosition:(CGPoint)position {
    // Override set position so we can keep the sensors
    // together with sprite
    [super setPosition:position];
    
    [self defineSensors];
}</pre></div><p>Here we see the same type of <a id="id2150" class="indexterm"/>
<a id="id2151" class="indexterm"/>
<code class="literal">defineSensors</code> method we saw in the <code class="literal">ERTile</code> class. The difference for the hero is that he has two sensors: one on his feet, and one below his feet. The <a id="id2152" class="indexterm"/>
<a id="id2153" class="indexterm"/>
<code class="literal">footSensor</code> variable will be <a id="id2154" class="indexterm"/>used to identify state changes, and the <a id="id2155" class="indexterm"/>
<a id="id2156" class="indexterm"/>
<code class="literal">fallSensor</code> variable will be used to determine if the hero should be falling. We also use the same <a id="id2157" class="indexterm"/>
<a id="id2158" class="indexterm"/>
<code class="literal">setPosition</code> override method, for exactly the same reason: to keep the sensors in place during movement. Let's see how the game looks with the sensors visible:</p><div><img src="img/9007_9_02.jpg" alt="Our hero"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec116"/>Animation loading</h2></div></div></div><p>We have talked about playing animations, but we haven't actually <a id="id2159" class="indexterm"/>
<a id="id2160" class="indexterm"/>created any yet. We will be using a helper method to load our animations.</p><p>
<strong>Filename</strong>: <a id="id2161" class="indexterm"/>
<a id="id2162" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void)buildCacheAnimation:(NSString*) AnimName
          forFrameNameRoot:(NSString*) root
             withExtension:(NSString*) ext
                frameCount:(NSInteger) count
                 withDelay:(float)delay {
  // This method goes through all the steps to load an
  // animation to the CCSpriteFrameCache
  NSMutableArray *frames = [NSMutableArray array];
    
  // Load the frames
  for(int i = 1; i &lt;= count; i++) {
      CCSpriteFrame *newFrame = [[CCSpriteFrameCache
            sharedSpriteFrameCache] spriteFrameByName:
            [NSString stringWithFormat:@"%@%i%@",
            root, i, ext]];
      [frames addObject:newFrame];
  }
  // Build the animation
    CCAnimation *newAnim  =[CCAnimation
                        animationWithSpriteFrames:frames
                        delay:delay];
  // Store it in the cache
  [[CCAnimationCache sharedAnimationCache]
             addAnimation:newAnim name:AnimName];
}

-(CCAnimate*) getAnim:(NSString*)animNm {
    // Helper to avoid typing this long line repeaedly
    return [CCAnimate actionWithAnimation:
             [[CCAnimationCache sharedAnimationCache]
             animationByName:animNm]];
}</pre></div><p>Here we see our two helper methods. The first takes quite a few parameters to build the animation. We pass it the name we want the animation stored as, the root of the filename, the extensions of the filename, the number of frames for the animation, and the time delay between frames. This assumes that any animations loaded will have an incremental number in their filenames. It then goes through the process of loading each frame and adding it to the frames array. Finally, it builds the animation and stores it in the <code class="literal">CCAnimationCache</code> under the <a id="id2163" class="indexterm"/>
<a id="id2164" class="indexterm"/>
<code class="literal">AnimName</code> string specified. Once it is loaded, you can simply request the animation by name from the cache.</p><p>The code needed to load an animation from the cache is a fairly long line of code, so we have also built a helper method to assist with retrieving the frames, <code class="literal">getAnim</code>. <a id="id2165" class="indexterm"/>
<a id="id2166" class="indexterm"/>It returns a <code class="literal">CCAnimate</code> object<a id="id2167" class="indexterm"/>
<a id="id2168" class="indexterm"/> to the caller. If we were not using this helper method, we would have to repeat the same line of code found inside that method every time we wanted an animation. Combined, these two methods save us from <a id="id2169" class="indexterm"/>writing a lot of repetitive code. Now let's get back to our hero.</p><p>
<strong>Filename</strong>: <code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) loadAnimations {
    [pf buildCacheAnimation:@"HeroRun"
           forFrameNameRoot:@"hero_run"
              withExtension:@".png"
                 frameCount:4 withDelay:0.1];
    [pf buildCacheAnimation:@"HeroJump"
           forFrameNameRoot:@"hero_jump"
              withExtension:@".png"
                 frameCount:3 withDelay:0.1];
    [pf buildCacheAnimation:@"HeroLand"
           forFrameNameRoot:@"hero_land"
              withExtension:@".png"
                 frameCount:3 withDelay:0.1];
}</pre></div><p>This method is all we need to load the hero's animations. We call this method from the playfield after we have created the hero, because we need to reference the playfield in order to call the helper method (which we assign to the variable <code class="literal">pf</code>).</p><p>
<strong>Filename</strong>: <code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) playRunAnim {
    CCAnimate *idle = [pf getAnim:@"HeroRun"];
    CCRepeatForever *repeat = [CCRepeatForever
                         actionWithAction:idle];
    [self runAction:repeat];
}</pre></div><p>Here we see the fruits of our animation coding labor. When the state changes to <code class="literal">kHeroRunning</code>, this method is <a id="id2170" class="indexterm"/>
<a id="id2171" class="indexterm"/>called. We use our helper method to get the animation, and set it up to repeat forever. This will keep him running until the state changes.</p><p>
<strong>Filename</strong>: <a id="id2172" class="indexterm"/>
<a id="id2173" class="indexterm"/>
<code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) playLandAnim {
    CCAnimate *land = [pf getAnim:@"HeroLand"];
    [self runAction:land];
}</pre></div><p>The landing animation is similar, except we only play it once.</p><p>
<strong>Filename</strong>: <code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) playJumpAnim {
    CCAnimate *jump = [pf getAnim:@"HeroJump"];
    CCCallBlock *change = [CCCallBlock actionWithBlock:^{
        [self stateChangeTo:kHeroInAir];
    }];
    CCSequence *doIt = [CCSequence actions:jump, change, nil];
    
    [self runAction:doIt];
    
    // Play the sound effect
    [[SimpleAudioEngine sharedEngine]
                         playEffect:SND_HEROJUMP];
}</pre></div><p>The jumping animation is the most complex of the three. We play the animation once, and then state change the <a id="id2174" class="indexterm"/>
<a id="id2175" class="indexterm"/>
<code class="literal">kHeroInAir</code>, and play a jumping sound. The state <code class="literal">kHeroInAir</code> is used for the time the hero is airborne, but no special animation is playing. The sprite will remain as the last frame of the previous animation.</p><p>That covers everything in the hero class except for methods related to shooting and getting hit. We will come back to those when we discuss bullets and collisions later.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec117"/>Updating the hero</h2></div></div></div><p>As we saw earlier with the tile updates, we have also broken out the updates for the hero into a separate method in the playfield layer. <a id="id2176" class="indexterm"/>Let's take a look at that <a id="id2177" class="indexterm"/>method.</p><p>
<strong>Filename</strong>: <a id="id2178" class="indexterm"/>
<a id="id2179" class="indexterm"/>
<code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) updateHero:(ccTime)dt {
    CGPoint newPos = hero.position;
    
    BOOL isFalling = YES;
    
    // The hero is going up
    if (hero.state == kHeroJumping ||
                   hero.state == kHeroInAir) {
        jumpTimer = jumpTimer - dt;
        
        if (jumpTimer &lt;= 0) {
            // Jump ending, descend
            [hero stateChangeTo:kHeroFalling];
        } else {
            // Apply a force up for the hero
            newPos = ccpAdd(hero.position, ccp(0,3));
        }
    }
    
    // If hero is falling, apply our gravity
    if (hero.state == kHeroFalling) {
        newPos = ccpAdd(hero.position, ccp(0,-3));
    }
    
    // Check if the hero is touching the ground
    for (ERTile *aTile in grndArray) {
        if (CGRectIntersectsRect(hero.footSensor,
                                   aTile.topSensor)) {
            // push hero up 1 point if his feet hit the ground
            newPos = ccpAdd(hero.position, ccp(0,1));
            [hero stateChangeTo:kHeroRunning];
        }
        
        // See if the fall sensor detects anything below
        if (CGRectIntersectsRect(hero.fallSensor,
                                   aTile.topSensor)) {
            // Not falling
            isFalling = NO;
        }
    }
    // Check if hero should fall
    if (isFalling &amp;&amp; hero.state == kHeroRunning) {
        [hero stateChangeTo:kHeroFalling];
    }
    
    // Move the hero
    [hero setPosition:newPos];
    
    // Check if hero has fallen off screen
    if (hero.position.y &lt; -40) {
        [self gameOver];
    }
}</pre></div><p>In this method we parse through all the different states that we may need to trigger or react to. If the hero is jumping, we decrease the <a id="id2180" class="indexterm"/>
<a id="id2181" class="indexterm"/>
<code class="literal">jumpTimer</code> variable by the current delta value. The <code class="literal">jumpTimer</code> variable controls how long the hero can be in the air in a single jump. When the timer reaches zero, the hero's state changes to <code class="literal">kHeroIsFalling</code>. If the timer is still greater than zero, we increase the hero's <code class="literal">y</code> position by 3 points. (As you may recall, the hero is always at the same <code class="literal">x</code> <a id="id2182" class="indexterm"/>position, so we only have to concern ourselves with the y axis). If the hero is falling, then we apply our gravity by decreasing his <code class="literal">y</code> position by 3 points.</p><p>We then begin to make use of our sensors. We check to see if the hero's <code class="literal">footSensor</code> is touching any tile's <code class="literal">topSensor</code>. If it is, we push the hero up by 1 point, and change his state to <code class="literal">kHeroRunning</code>. We also check each tile to see if there is any contact between the hero's <code class="literal">fallSensor</code> and the tile's <code class="literal">topSensor</code>. If there is contact with any tile's sensor, then the <code class="literal">isFalling</code> local Boolean variable is set to <code class="literal">NO</code>. If there is no contact with any tile sensors, then the <a id="id2183" class="indexterm"/>
<a id="id2184" class="indexterm"/>
<code class="literal">isFalling</code> variable will still have the original <code class="literal">YES</code> we assigned to it, so we know the hero should be falling. We then check to see if the hero is currently running and if the <code class="literal">isFalling</code> variable is <code class="literal">YES</code>, then we change his state to <code class="literal">kHeroFalling</code>. After all of that, we actually set the new position to the hero. The last check is to see if the hero has fallen off the screen. If he has, we call the <code class="literal">gameOver</code> method.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec97"/>Touch controls</h1></div></div></div><p>Now that we have a hero to control, we need to look at the <a id="id2185" class="indexterm"/>control methods.</p><p>
<strong>Filename</strong>: <a id="id2186" class="indexterm"/>
<a id="id2187" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {
    if (preventTouches) {
        return YES;
    }
    
    if (isGameOver) {
        [[CCDirector sharedDirector] replaceScene:[ERMenuScene
                                               scene]];
        return YES;
    }
    
    CGPoint loc = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:loc];
    
    if (convLoc.x &lt; size.width/2) {
        // Jump if left side of screen
        if (hero.state == kHeroRunning) {
            // Jump from the ground
            [hero stateChangeTo:kHeroJumping];
            // Reset the jump timer
            jumpTimer = maxJumpTimer;
            // Allow hero to double-jump
            allowDoubleJump = YES;
        } else if (allowDoubleJump) {
            // Allow a second jump in the air
            [hero stateChangeTo:kHeroJumping];
            // Reset the jump timer
            jumpTimer = maxJumpTimer;
            // Prevent a third jump
            allowDoubleJump = NO;
        } else {
            return NO;
        }
    } else {
        // Shoot if right side of screen
        [hero shoot];
    }
    return YES;
}</pre></div><p>After checking whether touches should be prevented or whether game over conditions have been met, we compare the locations of the touch to the left or right half of the screen. If the touch is on the left and the hero is currently running, we change state to <code class="literal">kHeroJumping</code>. We set the <a id="id2188" class="indexterm"/>
<a id="id2189" class="indexterm"/>
<code class="literal">jumpTimer</code> variable to the value of the <code class="literal">maxJumpTimer</code> variable (defined in the <code class="literal">init</code> method as 0.85), and we also set the <code class="literal">allowDoubleJump</code> variable to <code class="literal">YES</code>. This state change will trigger the correct movement behavior (moving up) in the <a id="id2190" class="indexterm"/>
<a id="id2191" class="indexterm"/>
<code class="literal">updateHero</code> method we just saw. We set the <code class="literal">allowDoubleJump</code> variable to give the player a little extra help. As you can see, the <code class="literal">allowDoubleJump</code> variable <a id="id2192" class="indexterm"/>
<a id="id2193" class="indexterm"/>is only evaluated if the hero is not currently in the <code class="literal">kHeroRunning</code> state. Most of the code is the same as the first clause of the <code class="literal">if</code> statement, except we reset the <code class="literal">allowDoubleJump</code> to <code class="literal">NO</code>. Combined, this will allow the player to double-jump in mid-air, but it will prevent air-jumping a <a id="id2194" class="indexterm"/>third time. (If you allow unlimited jumps from mid-air, the hero can actually fly forever!)</p><p>The final <code class="literal">else</code> clause will catch any touches on the right-hand side of the screen, and send the message to the hero to shoot.</p><p>
<strong>Filename</strong>: <a id="id2195" class="indexterm"/>
<a id="id2196" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {
    if (isGameOver) {
        return;
    }
    
    CGPoint loc = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:loc];
    
    // Release the jump
    if (convLoc.x &lt; size.width/2) {
        // Jump if left side of screen
        [hero stateChangeTo:kHeroFalling];
    }
}</pre></div><p>We wrap up the touch handler by looking at the <code class="literal">ccTouchEnded</code> method. Here we must first check to make sure we are not in a game over condition. Without this check, if the hero died while a touch was still occurring, the game would crash as soon as the finger was lifted (since the hero sprite would be dead and gone).</p><p>Most of this is concerned with jumping, as you could probably assume. If the touch was on the left-hand side (jumping side), then we change the state to <code class="literal">kHeroFalling</code>, so gravity can take over.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec98"/>Shooting bullets</h1></div></div></div><p>Now we turn our attention to the bullets and allowing our <a id="id2197" class="indexterm"/>hero to shoot. Let's <a id="id2198" class="indexterm"/>look at the simple <code class="literal">ERBullet</code> class.</p><p>
<strong>Filename</strong>: <a id="id2199" class="indexterm"/>
<a id="id2200" class="indexterm"/>
<code class="literal">ERBullet.h</code>
</p><div><pre class="programlisting">@interface ERBullet : CCSprite {
    BOOL isShootingRight;
    BOOL isHeroBullet;
}

@property (nonatomic, assign) BOOL isShootingRight;
@property (nonatomic, assign) BOOL isHeroBullet;

@end
ERBullet.m:
@implementation ERBullet

@synthesize isShootingRight;
@synthesize isHeroBullet;

@end</pre></div><p>Our <code class="literal">ERBullet</code> <a id="id2201" class="indexterm"/>
<a id="id2202" class="indexterm"/>class is nothing more than a subclass of the <code class="literal">CCSprite</code> class with a couple of extra Boolean variables to track. The <a id="id2203" class="indexterm"/>
<a id="id2204" class="indexterm"/>
<code class="literal">isShootingRight</code> Boolean variable helps us keep track of direction of travel for the bullet. Since we are only designing the game to allow flat trajectories for the bullets, we really just need to know if it is going left or right. We also use the <a id="id2205" class="indexterm"/>
<a id="id2206" class="indexterm"/>
<code class="literal">isHeroBullet</code> variable so we can keep track of whose bullet it is, for collision detection purposes. We will not allow "friendly fire", so enemies won't kill other enemies in this game. Now we can look at what the hero does when instructed to shoot.</p><p>
<strong>Filename</strong>: <code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) shoot {
    // Create a bullet at hero's position
    ERBullet *bullet = [ERBullet
                   spriteWithSpriteFrameName:IMG_BULLET];
    [bullet setColor:ccBLUE];
    [bullet setIsShootingRight:YES];
    [bullet setIsHeroBullet:YES];
    [bullet setPosition:self.position];

    // Tell the playfield to add the bullet
    [pf addBullet:bullet];
    
    // Play the sound effect
    [[SimpleAudioEngine sharedEngine]
                   playEffect:SND_HEROSHOOT];
}</pre></div><p>We create a new bullet at the hero's position, give it a nice blue color, and set our two Boolean variables to <code class="literal">YES</code>. The hero is only travelling to the right, so that's the only direction his bullets will travel. We then call out to the playfield to the <code class="literal">addBullet</code> method. We wrap it up by playing a nice shooting sound. <a id="id2207" class="indexterm"/>Let's turn to that <code class="literal">addBullet</code> method next.</p><p>
<strong>Filename</strong>: <a id="id2208" class="indexterm"/>
<a id="id2209" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) addBullet:(ERBullet*) thisBullet {
    [runnersheet addChild:thisBullet z:3];
    
    [bulletArray addObject:thisBullet];
}</pre></div><p>Not much here, either. We add the bullet to the batch node, and we add the bullet to the <code class="literal">bulletArray</code> array. So why did we do this here, and not in the hero's <code class="literal">shoot</code> method? For one, we will be using this same method when adding enemy bullets. The other reason is that we don't want to have the <a id="id2210" class="indexterm"/>
<a id="id2211" class="indexterm"/>
<code class="literal">bulletArray</code> array accessible outside of the playfield layer itself, so it is much easier to use this method to insert the bullet into that array.</p><p>As you might imagine, there is also a separate update method for the bullets. Let's go there now.</p><p>
<strong>Filename</strong>: <a id="id2212" class="indexterm"/>
<a id="id2213" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) updateBullets {
    for (ERBullet *bullet in bulletArray) {
        if (bullet.isShootingRight) {
            // Move the bullet right
            bullet.position = ccpAdd(bullet.position,
                                      ccp(10,0));
            
            // Remove bullets that are off the screen
            if (bullet.position.x &gt; size.width) {
                [bulletsToDelete addObject:bullet];
                [bullet removeFromParentAndCleanup:YES];
            }
        } else {
            // Move the bullet left
            bullet.position = ccpAdd(bullet.position, 
                                      ccp(-10,0));
            
            // Remove bullets that are off the screen
            if (bullet.position.x &lt; 0) {
                [bulletsToDelete addObject:bullet];
                [bullet removeFromParentAndCleanup:YES];
            }
        }
    }
    
    // Remove deleted bullets from the array
    [bulletArray removeObjectsInArray:bulletsToDelete];
    [bulletsToDelete removeAllObjects];
}</pre></div><p>This method style should be familiar by now. We iterate through all the bullets in the <code class="literal">bulletArray</code> array, <a id="id2214" class="indexterm"/>
<a id="id2215" class="indexterm"/>and move each bullet either left or right, depending on the value of <code class="literal">isShootingRight</code> variable. <a id="id2216" class="indexterm"/>
<a id="id2217" class="indexterm"/>If the bullet goes off-screen, it is added to the <a id="id2218" class="indexterm"/>
<a id="id2219" class="indexterm"/>
<code class="literal">bulletsToDelete</code> array, which is then used after the loop to remove the bullets from the <code class="literal">bulletArray</code>. Of course, at this point the bullets won't interact with anything, but we need to have some <a id="id2220" class="indexterm"/>enemies to shoot at before we deal with collisions.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec99"/>Enemies everywhere</h1></div></div></div><p>We want to have enemies in our game. A lot of enemies. We need to have flying enemies as well as walking enemies. With the wonderful Planet-X graphics we are using, the designer created six types of creatures in six colors. We are <a id="id2221" class="indexterm"/>using all but one type of creature (the swimming creature didn't fit this game), so we have 12 flying enemy types and 18 walking enemy types. In our game there is no difference in the behavior of the creatures, but it does give more of a visual flair to the game to have this much variety. Because we will be randomly creating enemies throughout the game, we don't want to be reloading the animations into the cache every time a new creature is spawned, so we build all of the <a id="id2222" class="indexterm"/>enemy animations when the playfield is loaded.</p><p>
<strong>Filename</strong>: <a id="id2223" class="indexterm"/>
<a id="id2224" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) loadEnemyAnimations {    
    // Build all walking enemy animations
    for (int i = 1; i &lt;= 18; i++) {
        // Build the names for the image and animation
        NSString *root = [NSString stringWithFormat:
                          @"walk%i_", i];
        NSString *anim = [NSString stringWithFormat:
                          @"%@move", root];
        
        // Build the animation into the cache
        [self buildCacheAnimation:anim
                 forFrameNameRoot:root
                    withExtension:@".png"
                       frameCount:4 withDelay:0.1];
    }
    
    // Build all flying enemy animations
    for (int i = 1; i &lt;= 12; i++) {
        // Build the names for the image and animation
        NSString *root = [NSString stringWithFormat:
                          @"fly%i_", i];
        NSString *anim = [NSString stringWithFormat:
                          @"%@move", root];
        
        // Build the animation into the cache
        [self buildCacheAnimation:anim
                 forFrameNameRoot:root
                    withExtension:@".png"
                       frameCount:4 withDelay:0.1];
    }
 }</pre></div><p>Because we have kept our naming convention consistent (that is, <code class="literal">walk1_1.png</code>, <code class="literal">walk1_2.png</code>, and so on) we can easily construct our names in a loop. We first load the walking enemies in a loop, and we assemble two strings to help us. The <code class="literal">root</code> parameter is the first part of the file name before the incremental frame numbers. The <code class="literal">anim</code> variable will add the word "move" to the end of the <code class="literal">root</code> name, to load the animation under that name. So the fifth walker's animation will be named <code class="literal">walk5_move</code>. We then call the same helper method we used for the hero to load the animation frames for all of the walkers. The second half of the method repeats the same process, except it loads the flying creatures' animations.</p><p>Now we can start to look at the <a id="id2225" class="indexterm"/>
<a id="id2226" class="indexterm"/>
<code class="literal">EREnemy</code> class, <a id="id2227" class="indexterm"/>which will look very familiar.</p><p>
<strong>Filename</strong>: <code class="literal">EREnemy.m</code>
</p><div><pre class="programlisting">-(void) defineSensors {
    fallSensor = CGRectMake(self.boundingBox.origin.x+20,
                            self.boundingBox.origin.y-10,
                            self.boundingBox.size.width-40,
                            10);
}
-(void) setPosition:(CGPoint)position {
    // Override set position so we can keep the sensors
    // together with sprite
    [super setPosition:position];
    
    [self defineSensors];
}</pre></div><p>We define a <a id="id2228" class="indexterm"/>
<a id="id2229" class="indexterm"/>
<code class="literal">fallSensor</code> variable for the enemy, using the same structure as we did for the hero. We also override the <a id="id2230" class="indexterm"/>
<a id="id2231" class="indexterm"/>
<code class="literal">setPosition</code> method for this class to refresh the <code class="literal">fallSensor</code> every time it is repositioned.</p><p>
<strong>Filename</strong>: <code class="literal">EREnemy.m</code>
</p><div><pre class="programlisting">-(void) shoot {
    // Create a bullet at enemy's position
    ERBullet *bullet = [ERBullet
                          spriteWithSpriteFrameName:IMG_BULLET];
    [bullet setColor:ccRED];
    [bullet setIsShootingRight:self.isMovingRight];
    [bullet setPosition:self.position];
    [bullet setIsHeroBullet:NO];

    // Tell the playfield to add the bullet
    [pf addBullet:bullet];
    
    // Play the sound effect
    [[SimpleAudioEngine sharedEngine]
                              playEffect:SND_ENEMYSHOOT];
}</pre></div><p>The enemy's <a id="id2232" class="indexterm"/>
<a id="id2233" class="indexterm"/>
<code class="literal">shoot</code> method is very similar to the hero's <code class="literal">shoot</code> method. Obviously, the <code class="literal">isHeroBullet</code> Boolean variable <a id="id2234" class="indexterm"/>
<a id="id2235" class="indexterm"/>is set to <code class="literal">NO</code> here. Also, the <code class="literal">isShootingRight</code> variable sets <a id="id2236" class="indexterm"/>
<a id="id2237" class="indexterm"/>itself to one of the new variables that is contained in the <code class="literal">EREnemy</code> class.</p><p>
<strong>Filename</strong>: <code class="literal">EREnemy.h</code>
</p><div><pre class="programlisting">    BOOL isMovingRight;
    BOOL isFlying;
    ccTime shootTimer;</pre></div><p>These variables help us keep better track of the enemies. The <a id="id2238" class="indexterm"/>
<a id="id2239" class="indexterm"/>
<code class="literal">isFlying</code> and <a id="id2240" class="indexterm"/>
<a id="id2241" class="indexterm"/>
<code class="literal">isMovingRight</code> Boolean variables are self-explanatory. The <a id="id2242" class="indexterm"/>
<a id="id2243" class="indexterm"/>
<code class="literal">shootTimer</code> for the enemies is kept in this class, where the hero's is kept as part of the playfield layer itself. Now that we have seen all of the <code class="literal">EREnemy</code> class (except for getting hit), we can look at how we create the enemies in the game.</p><p>
<strong>Filename</strong>: <a id="id2244" class="indexterm"/>
<a id="id2245" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) addWalkingEnemyAtPosition:(CGPoint)pos {
    // Randomly select a walking enemy
    NSInteger enemyNo = (arc4random() % 18) + 1;
    
    // Build the name of the enemy
    NSString *enemyNm = [NSString stringWithFormat:@"walk%i",
                            enemyNo];
    
    // Build the initial sprite frame name
    NSString *enemyFrame = [NSString
                      stringWithFormat:@"%@_1.png", enemyNm];
    EREnemy *enemy = [EREnemy
                      spriteWithSpriteFrameName:enemyFrame];
    [enemy setPosition:ccpAdd(pos, 
                      ccp(0, enemy.contentSize.height/2))];
    [enemy setIsMovingRight:NO];
    [enemy setFlipX:NO];
    [enemy setIsFlying:NO];
    [enemy setPf:self];
    
    // Add this enemy to the layer and the array
    [runnersheet addChild:enemy z:5];
    [enemyArray addObject:enemy];
    
    // Set the enemy in motion
    NSString *moveAnim = [NSString
                    stringWithFormat:@"%@_move", enemyNm];
    CCAnimate *idle = [self getAnim:moveAnim];
    CCRepeatForever *repeat = [CCRepeatForever
                    actionWithAction:idle];
    [enemy runAction:repeat];
}</pre></div><p>As we did when we created the ground tiles, we randomize the selection of the <code class="literal">enemyNo</code>, and use that to build the correct initial frame name for the new <a id="id2246" class="indexterm"/>
<a id="id2247" class="indexterm"/>
<code class="literal">EREnemy</code> object. When we set the position, we add the requested position (<code class="literal">pos</code>) to half of the content size of the enemy itself. We do this because the enemy has a default center <code class="literal">anchorPoint</code>, and the position passed is the top of the tile we want the enemy to be standing on. So by adding half of the height, we position the enemy perfectly standing on the tile below. (We don't want to change the <code class="literal">anchorPoint</code>, because then <a id="id2248" class="indexterm"/>we would have to do this type of adjustment for all bullets fired by the enemies.) All enemies will start by facing to the left, and since these are walking enemies, they will have <code class="literal">isFlying</code> set to <code class="literal">NO</code>. After adding the enemy to the batch node and to the <code class="literal">enemyArray</code> array, we get the animation we loaded for this particular enemy, and set it to repeat forever. That's all we need to create the walking enemies.</p><p>
<strong>Filename</strong>: <a id="id2249" class="indexterm"/>
<a id="id2250" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) addFlyingEnemyAtPosition:(CGPoint)pos {
    // Randomly select a walking enemy
    NSInteger enemyNo = (arc4random() % 12) + 1;
    
    // Build the name of the enemy
    NSString *enemyNm = [NSString stringWithFormat:@"fly%i",
                      enemyNo];
    
    // Build the initial sprite frame name
    NSString *enemyFrame = [NSString
                      stringWithFormat:@"%@_1.png", enemyNm];
    EREnemy *enemy = [EREnemy
                      spriteWithSpriteFrameName:enemyFrame];
    [enemy setPosition:pos];
    [enemy setIsMovingRight:NO];
    [enemy setFlipX:NO];
    [enemy setIsFlying:YES];
    [enemy setPf:self];
    
    // Add this enemy to the layer and the array
    [runnersheet addChild:enemy z:5];
    [enemyArray addObject:enemy];
    
    // Set the enemy in motion
    NSString *moveAnim = [NSString
                      stringWithFormat:@"%@_move", enemyNm];
    CCAnimate *idle = [self getAnim:moveAnim];
    CCRepeatForever *repeat = [CCRepeatForever
                      actionWithAction:idle];
    [enemy runAction:repeat];
}</pre></div><p>As we look at how we add flying enemies, you will notice this is the same basic code structure as the walking enemy. The only real differences are that the names of the sprite frames begin with <code class="literal">fly</code> instead of <code class="literal">walk</code>, and we don't have to change the starting position for the flying enemies, because they will not interact with the ground at all. Now we can move to the enemy <code class="literal">update</code> method.</p><p>
<strong>Filename</strong>: <a id="id2251" class="indexterm"/>
<a id="id2252" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code>
</p><div><pre class="programlisting">-(void) updateEnemies:(ccTime)dt {
    // Only update the enemies while scrolling
    if (isScrolling == NO) {
        return;
    }
    
    // Loop through all enemies
    for (EREnemy *anEnemy in enemyArray) {
        BOOL noGround = YES;
        
        // Check movement direction
        if (anEnemy.isMovingRight) {
            // Moving against the scroll
            [anEnemy setPosition:ccpAdd(anEnemy.position,
                             ccp(-scrollSpeed + 2,0))];
        } else {
            // Moving with the scroll
            [anEnemy setPosition:ccpAdd(anEnemy.position,
                             ccp(-scrollSpeed - 2,0))];
        }
        
        // Updates for walking enemies only
        if (anEnemy.isFlying == NO) {
            // Check if the enemy is touching the ground
            for (ERTile *aTile in grndArray) {
                // See if the sensor detects anything below
                if (CGRectIntersectsRect(anEnemy.fallSensor,
                                aTile.topSensor)) {
                    // Ground is under foot
                    noGround = NO;
                }
            }
            
            // If there is no ground underfoot, turn around
            if (noGround) {
                if (anEnemy.isMovingRight) {
                    [anEnemy setIsMovingRight:NO];
                    [anEnemy setFlipX:NO];
                } else {
                    [anEnemy setIsMovingRight:YES];
                    [anEnemy setFlipX:YES];
                }
            }
        }
        
        // Enemy can shoot, with time delay
        if (anEnemy.shootTimer &lt;= 0) {
            [anEnemy shoot];
            anEnemy.shootTimer = 2.0;
        } else {
            anEnemy.shootTimer = anEnemy.shootTimer - dt;
        }

        // Check for enemies off screen
        if (anEnemy.position.x &lt; -50) {
            // If off-screen to the left, add to delete
            [enemiesToDelete addObject:anEnemy];
            [anEnemy removeFromParentAndCleanup:YES];
        }
    }
    
    // Remove deleted enemies from the array
    [enemyArray removeObjectsInArray:enemiesToDelete];
    [enemiesToDelete removeAllObjects];
}</pre></div><p>We begin the <a id="id2253" class="indexterm"/>
<a id="id2254" class="indexterm"/>
<code class="literal">updateEnemies</code> method by making sure the playfield is scrolling. If not we exit, because we don't want the enemies to move. Then we iterate through all the enemies in the <code class="literal">enemyArray</code> and move them left or right, according to how their <code class="literal">isMovingRight</code> Boolean variable is set. The middle section of the update is concerned only with walking enemies. For each walking enemy, we iterate through all tiles to see if their <code class="literal">fallSensor</code> is touching any tiles. This is exactly the same as what we did for the hero with the <a id="id2255" class="indexterm"/>
<a id="id2256" class="indexterm"/>
<code class="literal">isFalling</code> Boolean variable the <a id="id2257" class="indexterm"/>
<a id="id2258" class="indexterm"/>
<code class="literal">updateHero</code> method. If there is no ground, instead of making in the enemy fall, we flip the graphic to face the opposite direction, and change the <code class="literal">isMovingRight</code> Boolean to the opposite value. If an enemy reaches the edge of a ledge, this will make it turn around.</p><p>We then have a simple <a id="id2259" class="indexterm"/>
<a id="id2260" class="indexterm"/>
<code class="literal">shootTimer</code> loop for the enemies.  Each enemy will shoot every 2 seconds.  Because we have non-intelligent enemies (they move back and forth, but never pursue the player), it makes sense to have this form of blind shooting for the enemies.</p><p>Finally, we check to see if any enemies are off-screen to the left, and remove them in the usual fashion. Now our enemies can move and everybody can shoot, we need some collision detection.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec100"/>Collision handling</h1></div></div></div><p>We need to be able to check for three different types of collisions. We need to be able to have bullets hit the enemies. We need the hero to get hit. <a id="id2261" class="indexterm"/>We also need to <a id="id2262" class="indexterm"/>react when the hero runs into an enemy. Let's look at the method for this, which is in two parts.</p><p>
<strong>Filename</strong>: <a id="id2263" class="indexterm"/>
<a id="id2264" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code> (<code class="literal">checkCollisions</code>, part 1)</p><div><pre class="programlisting">-(void) checkCollisions {
    BOOL isHeroHit = NO;
    
    for (ERBullet *bullet in bulletArray) {
        // Enemy bullets
        if (bullet.isHeroBullet == NO) {
            if (CGRectIntersectsRect(hero.boundingBox,
                                bullet.boundingBox)) {
                // Hero got hit
                [bulletsToDelete addObject:bullet];
                [bullet removeFromParentAndCleanup:YES];
                isHeroHit = YES;
                break;
            }
        } else {
            // Hero bullets
            
            // Check all enemies to see if they got hit
            for (EREnemy *anEnemy in enemyArray) {
                if (CGRectIntersectsRect(anEnemy.boundingBox,
                                         bullet.boundingBox)) {
                    [bulletsToDelete addObject:bullet];
                    [bullet removeFromParentAndCleanup:YES];
                    [enemiesToDelete addObject:anEnemy];
                    [anEnemy gotShot];
                    break;
                }
            }
        } 
    }</pre></div><p>We start by iterating through all bullets in the array. If the bullet is an enemy bullet (<code class="literal">isHeroBullet == NO</code>), then we check the <code class="literal">boundingBox</code> of the bullet with the <code class="literal">boundingBox</code> of the hero. If they intersect, we add the bullet to the <code class="literal">bulletsToDelete</code> array, remove the bullet, and set the <a id="id2265" class="indexterm"/>
<a id="id2266" class="indexterm"/>
<code class="literal">isHeroHit</code> Boolean to <code class="literal">YES</code>. We use a Boolean variable for the hero hit here because we will be doing another hero collision check within this method. Since the hero's death causes the hero to be removed, the game would crash if the hero was shot and ran into an enemy at the same time.</p><p>If the bullet is a "hero bullet", we iterate through all enemies to determine if the bullet is intersecting with an enemy <code class="literal">boundingBox</code>. If it is, we add the <a id="id2267" class="indexterm"/>bullet to the <code class="literal">bulletsToDelete</code> array, remove the bullet, add the enemy to the <code class="literal">enemiesToDelete</code> array, and send the message to the enemy that it got shot.</p><p>
<strong>Filename</strong>: <a id="id2268" class="indexterm"/>
<a id="id2269" class="indexterm"/>
<code class="literal">ERPlayfieldLayer.m</code> (<code class="literal">checkCollisions</code>, part 2)</p><div><pre class="programlisting">    // Check for enemy and hero collisions
    for (EREnemy *anEnemy in enemyArray) {
        if (CGRectIntersectsRect(anEnemy.boundingBox,
                         hero.boundingBox)) {
            // Trigger the enemy's hit
            [enemiesToDelete addObject:anEnemy];
            [anEnemy gotShot];
            // Trigger the hero's hit
            isHeroHit = YES;
            break;
        }
    }
    
    // We process this here because there could be
    // multiple collisions with the hero
    if (isHeroHit) {
        [hero gotShot];
    }
    
    // Remove deleted bullets from the array
    [bulletArray removeObjectsInArray:bulletsToDelete];
    [bulletsToDelete removeAllObjects];
    
    // Remove deleted enemies from the array
    [enemyArray removeObjectsInArray:enemiesToDelete];
    [enemiesToDelete removeAllObjects];
}</pre></div><p>In the second half of this method, we start by iterating through all the enemies. For each enemy, we check to see if the enemy's <a id="id2270" class="indexterm"/>
<a id="id2271" class="indexterm"/>
<code class="literal">boundingBox</code> intersects with the hero's <code class="literal">boundingBox</code>. If they intersect, we register a collision for both <a id="id2272" class="indexterm"/>hero and enemy in the same manner as we did with the bullets.</p><p>After we have resolved the collisions, we check the <a id="id2273" class="indexterm"/>
<a id="id2274" class="indexterm"/>
<code class="literal">isHeroHit</code> variable to see if he got shot. If he got shot, we send the <a id="id2275" class="indexterm"/>
<a id="id2276" class="indexterm"/>
<code class="literal">gotShot</code> message to the hero. As the final bit of cleanup, we handle the <code class="literal">bulletsToDelete</code> and <a id="id2277" class="indexterm"/>
<a id="id2278" class="indexterm"/>
<code class="literal">enemiesToDelete</code> arrays the same as usual: we use them to remove the deleted objects from the <code class="literal">bulletArray</code> and <code class="literal">EnemyArray</code>, and then use the <a id="id2279" class="indexterm"/>
<a id="id2280" class="indexterm"/>
<code class="literal">removeAllObjects</code> method to empty the deletion arrays.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec118"/>Getting shot with particles</h2></div></div></div><p>The last unresolved bits of code that we need to look at are the <code class="literal">gotShot</code> routines for both the enemy and the hero. The enemies die after a single hit, so their <a id="id2281" class="indexterm"/>method is a simpler place to start.</p><p>
<strong>Filename</strong>: <a id="id2282" class="indexterm"/>
<a id="id2283" class="indexterm"/>
<code class="literal">EREnemy.m</code>
</p><div><pre class="programlisting">-(void) gotShot {
    CCParticleSystemQuad *emitter = [CCParticleSystemQuad
                      particleWithFile:@"enemydie.plist"];
    [emitter setPosition:self.position];
    [pf addChild:emitter z:50];

    [self removeFromParentAndCleanup:YES];
    
    // Play the sound effect
    [[SimpleAudioEngine sharedEngine]
                         playEffect:SND_ENEMYDEAD];
}</pre></div><p>When an enemy gets shot, the first thing we do is to create a particle system. Particles can be coded in one of two ways. The first would be to manually set all of the parameters regarding the particle system by hand, and test and retest until you achieve the desired effect. The alternate approach (one that is more widely used) is to use a commercially available tool, Particle Designer, available at <a class="ulink" href="http://particledesigner.71squared.com">http://particledesigner.71squared.com</a>. Particle Designer allows you to see the results of changing every parameter in real time, so you can experiment until you achieve the desired result. Once you have what you want, you can save it as a <a id="id2284" class="indexterm"/>
<a id="id2285" class="indexterm"/>
<code class="literal">.plist</code> file, and use it as we have done here. We created a <a id="id2286" class="indexterm"/>
<a id="id2287" class="indexterm"/>
<code class="literal">CCParticleSystemQuad</code> object using the plist file, set the position, and added it to the layer. That's all we needed to do for this one-shot particle. (If you want to know how much manual coding we are avoiding by using Particle Designer, open the <code class="literal">enemydie.plist</code> file in Xcode and see all the values stored in it.)</p><p>After we trigger the particle, we simply remove the enemy from its parent and play a nice death sound. Let's see the aftermath when an enemy is shot:</p><div><img src="img/9007_9_03.jpg" alt="Getting shot with particles"/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec119"/>Death of hero</h2></div></div></div><p>The hero getting hit adds a little complexity, because the <a id="id2288" class="indexterm"/>hero can take five hits before he dies. If he doesn't die, we want him to flash red briefly.</p><p>
<strong>Filename</strong>: <a id="id2289" class="indexterm"/>
<a id="id2290" class="indexterm"/>
<code class="literal">ERHero.m</code>
</p><div><pre class="programlisting">-(void) gotShot {
    // Subtract one from hero health
    heroHealth--;
    
    // Determine if the hero is dead
    if (heroHealth &lt;= 0) {
        // Spawn a death particle
        CCParticleSystemQuad *emitter = [CCParticleSystemQuad
                        particleWithFile:@"ExplodingRing.plist"];
        [emitter setPosition:self.position];
        [pf addChild:emitter z:50];
        
        // We don't clean up to avoid block failure
        [self removeFromParentAndCleanup:NO];
        
        // Play the sound effect for death
        [[SimpleAudioEngine sharedEngine]
                      playEffect:SND_HERODEATH];
        
        // Trigger game over
        [pf gameOver];
    } else if (isFlashing == NO) {
        // Flash the hero red briefly
        isFlashing = YES;
        CCTintTo *red = [CCTintTo actionWithDuration:0.05
                                   red:255 green:0 blue:0];
        CCTintTo *normal = [CCTintTo actionWithDuration:0.05
                                   red:255 green:255 blue:255];
        CCCallBlock *done = [CCCallBlock actionWithBlock:^{
            isFlashing = NO;
        }];
        [self runAction:[CCSequence actions: red, normal,
                             done, nil]];
        
        // Play the got hit sound effect
        [[SimpleAudioEngine sharedEngine]
                            playEffect:SND_HEROHIT];
    }
}</pre></div><p>We first reduce the hero's health by one. Then we check if the hero should be dead or not. If his health is zero, we spawn a new particle system centered on the hero, remove the hero, play a death sound, and then call the <a id="id2291" class="indexterm"/>
<a id="id2292" class="indexterm"/>
<code class="literal">gameOver</code> method. It should be noted that the <code class="literal">ExplodingRing.plist</code> file we use here is actually a particle that ships with Cocos2d, and is used as part of the Particle test.</p><p>If the hero is not dead, then we check the value of the hero's <a id="id2293" class="indexterm"/>
<a id="id2294" class="indexterm"/>
<code class="literal">isFlashing</code> variable. If he isn't currently flashing, we build a small action sequence that <a id="id2295" class="indexterm"/>will tint the hero red for a duration of 0.05, then tint it back to normal (all max values return the sprite color to its original color). Then we play a sound effect, and call it done.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec101"/>Summary</h1></div></div></div><p>We have put a lot of interesting pieces together in this game. We have dynamic terrain, randomized enemies, shooting, jumping, endless backgrounds, and (hopefully) some fun while building and playing it. You will notice that there are a few less interesting bits we have not covered in depth. Please, consult the code bundle to explore the other pieces of the game, like the "Dramatic Entrance" when the hero starts the game by being dropped off by a space ship. There is also some helpful debugging code we used for the sensors (commented out) in the bottom of the <code class="literal">ERPlayfieldLayer.m</code> file. By enabling that code, you can see the sensor boxes drawn while the game is playing.</p><p>It is our sincere hope that these projects have instructed, entertained, and perhaps even inspired you in your own pursuits. Each of the games, designed with a "bare bones" approach, gives plenty of room for exploration and expansion. If you create something wonderful as a result of having been inspired by these projects, please let us know! We look forward to hearing from you.</p></div></body></html>