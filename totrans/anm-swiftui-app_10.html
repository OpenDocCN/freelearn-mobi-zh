<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor138"/>10</h1>
<h1 id="_idParaDest-135"><a id="_idTextAnchor139"/>Creating an Ocean Scene</h1>
<p>In this chapter, we will be creating an ocean scene. To do that, we will be revisiting the <code>Shape</code> protocol and <code>path</code> function that we used in the previous project to create the waves, as well as a new SwiftUI property called <code>animatableData</code>, which will help to make our curvy lines animate in a fluid wave-like motion.</p>
<p>We will also add an image of a buoy to our scene and animate it in multiple different ways, including moving it along an anchor point, rotating it around the center of this point, and making it rise up and down along the <em class="italic">y</em>-axis – so the buoy looks like it’s bobbing in the water.</p>
<p>Finally, we will add some sound effects to the project to help it really come alive.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Adding the wave’s offset property</li>
<li>Creating a wave shape using the Shape protocol and Path function</li>
<li>Adding the wave’s <code>animatableData</code> property</li>
<li>Setting up the <code>ContentView</code> for animation</li>
<li>Duplicating and animating the wave shape in the <code>ContentView</code></li>
<li>Adding an animated floating buoy to the ocean scene</li>
<li>Adding sound effects</li>
</ul>
<h1 id="_idParaDest-136"><a id="_idTextAnchor140"/>Technical requirements</h1>
<p>You can download the resources and finished project from the <code>Chapter 10</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor141"/>Adding the wave’s offset property</h1>
<p>Okay, let’s start by creating<a id="_idIndexMarker550"/> a new SwiftUI project – I’ll be calling it <code>Making Waves</code>. </p>
<p>Then, let’s add a new file that will be in charge of making the waves for the ocean. Press <em class="italic">Command</em> + <em class="italic">N</em> to create a new file, then select the <code>WaveView</code>. </p>
<p>Inside this new file, we will make<a id="_idIndexMarker551"/> some minor modifications to the structure so that it conforms to the Shape protocol, as we did in the previous project. So, at the top of the <code>WaveView</code> struct, right after its name, remove the <code>View</code> protocol and replace it with the <code>Shape</code> protocol. Also, remove the <code>body</code> property as we don’t need that here. The file should look like this:</p>
<pre class="source-code">
struct WaveView: Shape {
}</pre>
<p>The reason why we removed the <code>body</code> property was that it was used to return a view; however, we will be returning a <code>path</code> variable that will hold the shape of the wave we want to animate.</p>
<p>The animation we want to create will be a wavy line that moves up and down in a wave-like motion, on the <em class="italic">y</em> axis. We will need a variable to control this animation movement, so let’s add a variable inside the <code>WaveView</code> struct to handle this:</p>
<pre class="source-code">
var yOffset: CGFloat = 0.0</pre>
<p>It’s called <code>yOffset</code> because that’s what the variable will do: it will offset the line only on the <em class="italic">y</em> axis. It gets an initial value of <code>0.0</code>. Its type is set to <code>CGFloat</code>.</p>
<p>We will need another special built-in Swift variable that will dynamically change the value of the <code>yOffset</code> variable and make things animate, called <code>animatableData</code>, but let’s first create the wave shape itself before adding that.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor142"/>Creating a wave shape using the Shape protocol and  Path function</h1>
<p>For the wave shape, it’s easy – we<a id="_idIndexMarker552"/> just need to make three straight lines and one curved line and join them together. Think of it as a rectangle, with the top line of the rectangle being the curvy wave part (skip to <em class="italic">Figure 10</em><em class="italic">.4</em> to see what I mean).</p>
<p>Before we start adding the wave code, let’s first modify the <code>Previews</code> struct so that we can see the results of each line of code we add. Modify the code so it looks like the following:</p>
<pre class="source-code">
struct WaveView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
        WaveView(yOffset: 0.7)
            .stroke(Color.blue, lineWidth: 3)
            .frame(height: 250)
        .padding()
            .previewDisplayName("Wave")
            
        }
    }
}</pre>
<p>We start off by giving the <code>yOffset</code> parameter in the <code>Previews</code> struct a value of <code>0.7</code>. This is a simple hardcoded value that allows us to display our wave shape in the previews on the right in Xcode. <code>yOffset</code> works by offsetting two control points in the Bezier curve – one control point will be offset in the up direction for the curvy line and the other control point will be offset in the down direction on the curvy line. The next line of code adds a stroke to the wave shape, so we can see it in the preview, and gives the wave a height of <code>250</code> points.</p>
<p>Now, with these changes in the previews, any code we add to the <code>WaveView</code> struct will immediately be visible in the <a id="_idIndexMarker553"/>previews. Let’s add the wave shape code now, small pieces of code at a time, so we can better understand how the wave shape is formed:</p>
<pre class="source-code">
func path(in rect: CGRect) -&gt; Path {
        var path = Path()
        path.move(to: .zero)
        path.addLine(to: CGPoint(x: rect.minX, 
          y: rect.maxY))
        return path
    }</pre>
<p>The first thing we do is create the <code>path</code> instance; this is the variable that we’re going to load up with all the lines that make the wave shape. </p>
<p>The next line calls the <code>move_to</code> method. This is the method that starts the drawing of the shape you’re making; in this project, that’s the wave shape. The <code>to</code> parameter is asking where on the screen you want to add the first point. For that parameter, we pass in the value of <code>.zero</code>, which is another way of setting the <em class="italic">x</em>- and <em class="italic">y</em>-axis values to 0. (We could simply write out the values as <code>X:</code> <code>0</code> and <code>Y:</code> <code>0</code>, but using <code>.zero</code> is easier.)</p>
<p>The next line of code calls the <code>addLine</code> function, which simply draws a straight line. Its parameters need an X and Y value to know where to put the next point to draw the line. For those X and Y values, we pass in two helper functions called <code>minX</code> and <code>maxY</code>, which automatically get different points of the screen for us.</p>
<p>The iPhone uses the X and Y coordinate system – X runs from left to right, and Y runs from top to bottom. The top-left corner of the iPhone screen would have the X and Y values of 0, 0. As you move to the right of the screen, the X value increases, and as you move down the screen, the Y value increases. So, by using the <code>minX</code> function in the <code>addLine</code> parameter, it will place a point at the far left of the screen (the minimum location on the X-coordinate plane). We could hardcode a value instead, such as 50 or 100, but by using the <code>minX</code> function, it tells Xcode to place the point over to the far left of the screen. Though this may seem vague, it is helpful when considering that Apple devices have different screen sizes. </p>
<p class="callout-heading">Note</p>
<p class="callout">The following are the Swift helper functions available for use to place points on the screen without hardcoding them: <code>minX</code>, <code>midX</code>, <code>maxX</code>, <code>minY</code>, <code>midY</code>, and <code>maxY</code>. The <code>midX</code> and <code>midY</code> functions, as you might imagine, add a point to the middle area of the screen, and <code>maxX</code> and <code>maxY</code>, when used together, add a point to the bottom-right area of the screen.</p>
<p>Now, the result of that <a id="_idIndexMarker554"/>code is visible in the <strong class="bold">Previews</strong> window, showing a vertical straight line:</p>
<div><div><img alt="Figure 10.1: The first line " src="img/B18674_10_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: The first line</p>
<p>The <code>move_to</code> and <code>addLine</code> functions have drawn a line down from the middle-left area of the screen to the bottom-left area of the screen. The length of the line is set by the <code>frame</code> modifier we used in the <code>Previews</code> struct. By adding a bigger value in the <code>frame</code> modifier’s parameter, you make the line bigger. </p>
<p>Now, with the first line of the wave shape done, let’s draw the second line – this will be a horizontal line that <a id="_idIndexMarker555"/>starts from the bottom of the first line and stretches to the right, across the screen. We can do this by adding the highlighted line to our existing code:</p>
<pre class="source-code">
func path(in rect: CGRect) -&gt; Path {
        var path = Path()
        path.move(to: .zero)
        path.addLine(to: CGPoint(x: rect.minX,
          y: rect.maxY))
        <strong class="bold">path.addLine(to: CGPoint(x: rect.maxX,</strong>
<strong class="bold">          y: rect.maxY))</strong>
        return path
    }</pre>
<p>This line of code calls the <code>addLine</code> function again, adding a point to the <code>maxX</code> and <code>maxY</code> locations. The result should now look like this:</p>
<div><div><img alt="Figure 10.2: The second line " src="img/B18674_10_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: The second line</p>
<p>With two lines and half of the wave shape done, let’s now add the third line, which is the last straight one. Add<a id="_idIndexMarker556"/> the following highlighted line to your existing code:</p>
<pre class="source-code">
func path(in rect: CGRect) -&gt; Path {
        var path = Path()
        path.move(to: .zero)
        path.addLine(to: CGPoint(x: rect.minX,
          y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.maxX,
          y: rect.maxY))
        <strong class="bold">path.addLine(to: CGPoint(x: rect.maxX,</strong>
<strong class="bold">          y: rect.minY))</strong>
        return path
    }</pre>
<p>This line of code adds<a id="_idIndexMarker557"/> a point to the <code>maxX</code> (far-right) and <code>minY</code> (top-left) parts of the screen, so the result will look like this:</p>
<div><div><img alt="Figure 10.3: The third line " src="img/B18674_10_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: The third line</p>
<p>Now that we have three straight lines, we just need to add the wavy line to the top to complete the wave shape. Let’s add that now:</p>
<pre class="source-code">
func path(in rect: CGRect) -&gt; Path {
        var path = Path()
        path.move(to: .zero)
        path.addLine(to: CGPoint(x: rect.minX,
          y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.maxX,
          y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.maxX,
          y: rect.minY))
<strong class="bold">        path.addCurve(to: CGPoint(x: rect.minX,</strong>
<strong class="bold">          y: rect.minY),</strong>
<strong class="bold">        control1: CGPoint(x: rect.maxX * 0.45, </strong>
<strong class="bold">          y: rect.minY - (rect.maxY * yOffset)),</strong>
<strong class="bold">        control2: CGPoint(x: rect.maxX * 0.45,</strong>
<strong class="bold">          y: (rect.maxY * yOffset)))</strong>
        return path
    }</pre>
<p>Here, we have<a id="_idIndexMarker558"/> used the <code>addCurve</code> function to create the Bezier curve. This has three parameters.</p>
<p>The first parameter, <code>to</code>, is for adding a point to the screen for drawing the curvy line. The previous line of code drew a line that ended at the top-right side of the rectangle, so from there, the <code>addCurve</code> function will draw to the <code>minX</code> and <code>minY</code> location, which is the top left of the rectangle, effectively closing off the shape.</p>
<p>The next two parameters are what are called <code>control1</code> and <code>control2</code> points, specifically. These parameters are here to accept values that will adjust the amount of curve in a line that pertains to the <em class="italic">y</em> axis – <code>control1</code> will adjust the right portion of the line and <code>control2</code> will adjust the left portion of the line.</p>
<p>To understand how these control points work, if we pass in a value of <code>0</code> to both parameters, then the line created will be straight, not a curvy one; that’s because a value of 0 does not alter those points up or down, thus the line remains straight. But by passing in floating-point values, the control points start to bend the line on the right and left sides by the given amount. The control points do not act on the right and left ends of the line; those are <a id="_idIndexMarker559"/>the connection points that close the wave shape. Instead, the control points are equally spaced and offset from the ends.</p>
<p>Looking at the values being used for the control points now, they have been computed to create a line that has a bend going upward on the right side and a bend going downward on the left side. The <code>x</code> values for <code>control1</code> and <code>control2</code> get their results by multiplying the <code>maxX</code> value by 0.45 (this is a hardcoded value and helps shape the bend in the line on the <em class="italic">x</em> axis). </p>
<p>On the other hand, the <code>y</code> values for <code>control1</code> and <code>control2</code> are computed a little differently. <code>control1</code> gets its value by subtracting the <code>minY</code> value by the result of multiplying <code>maxX</code> by the <code>yOffset</code> variable. <code>control2</code> gets its value by multiplying the <code>maxY</code> value by the <code>yOffset</code> value. </p>
<p>These computations may be a bit unclear at first, but when you complete the project and experiment with different parameter values, you will see how the math works to make the bend in the line move; the amount of movement is related directly to how big or small a value the <code>yOffset</code> variable has. </p>
<p>Let’s now have a look at the result of adding the control points:</p>
<div><div><img alt="Figure 10.4: The completed wave shape " src="img/B18674_10_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: The completed wave shape</p>
<p>Now, with all four lines completed, we have created the wave shape. Up next, we will make the shape come<a id="_idIndexMarker560"/> alive using a special Swift property called <code>animatableData</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">When working with the <code>path_in</code> function, as we are doing here, there is also another function that is used to close off the shape we are drawing out: <code>closeSubpath()</code>. This is helpful when closing the ends of a shape without needing to use the <code>addLine()</code> function and passing in X and Y points. We didn’t need to use it here because we drew the wave shape out and ended with the curvy line on top. If I drew the curvy line first and wanted to end with a straight line, then I could have used this function to save some code. </p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor143"/>Adding the wave’s animatableData property</h1>
<p>We now have a wave shape that <a id="_idIndexMarker561"/>we can duplicate as many times as needed to create a layered ocean scene. However, those waves are still static, meaning they won’t do anything unless we have a way of changing the value<a id="_idIndexMarker562"/> in the <code>yOffset</code> variable. To accomplish that, we need to add one more important variable to the file here: <code>animatableData</code>. </p>
<p>So, let’s add it right under the declaration of the <code>yOffset</code> variable:</p>
<pre class="source-code">
var animatableData: CGFloat {
        get {
            return yOffset
        }
        set {
            yOffset = newValue
        }
    }</pre>
<p>The <code>animatableData</code> property is an instance of a Swift class called <code>Animatable</code>, and is a built-in Swift property that has a getter and a setter attached to it. Properties with getters and setters do just that: they get a value and set a value. </p>
<p>Using the <code>animatableData</code> property provides a few benefits over animating with a simple <code>@State</code> property alone:</p>
<ul>
<li>It allows you to declaratively specify that a view can be animated, making it clear to other developers (and to the framework) that the view is intended to be animated</li>
<li>It allows the framework to automatically interpolate between the old and new values, rather than requiring you to manually calculate the intermediate values</li>
<li>It allows you to use the <code>animation()</code> method to specify how the animation should be performed, such as the duration, curve, and delay</li>
<li>It allows you to use more advanced animation techniques, such as <code>animation(_:)</code> and <code>transition(_:)</code>, to specify the animation between different states of the view</li>
</ul>
<p>In our project, we’re using the <code>animatableData</code> property to get and set the values of the wave’s control <a id="_idIndexMarker563"/>points. This getting and setting is happening constantly and thus making the value of the <code>yOffset</code> variable change constantly too. Since the <code>yOffset</code> variable is being used to create the curvy line<a id="_idIndexMarker564"/> inside the <code>path_in()</code> function, the result will be that the curvy line dynamically changes too. </p>
<p>With the <code>animatableData</code> property in place, and the wave shape completed, we can proceed to the <code>ContentView</code>, where we will add the animation to the shape.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor144"/>Setting up the ContentView for animation</h1>
<p>Here, in the <code>ContentView</code>, we are<a id="_idIndexMarker565"/> ready to use the wave shape and add the animation to it. Let’s start by creating a new struct at the bottom of the file, just above the <code>Previews</code> struct, and call it <code>WaveCreation</code>:</p>
<pre class="source-code">
struct WaveCreation: View {
    var body: some View { 
    }
}</pre>
<p>This struct is very similar to the <code>ContentView</code> struct – it conforms to the <code>View</code> protocol, which means it must implement the <code>body</code> property. The <code>body</code> property itself will return a view, and that will be the animated wave. By the end of the next section, we will have created six waves in total, spaced out neatly inside of a stack.</p>
<p>We will need several variables to get this working, some for the animation and some that allow us to alter the size of the wave curve. Add the following code above the <code>body</code> property, inside the <code>WaveCreation</code> struct:</p>
<pre class="source-code">
@Binding var animateOffset: Bool
    var curveOne: CGFloat
    var curveTwo: CGFloat
    var radius: CGFloat
    var shadowX: CGFloat
    var shadowY: CGFloat
    var duration: Double</pre>
<p>There are seven variables here:</p>
<ul>
<li>The first one is a <code>Binding</code> variable, which we will use in <code>ContentView</code> to start the animation<a id="_idIndexMarker566"/> when it is set to <code>true</code>.</li>
<li>The next two variables are called <code>curveOne</code> and <code>curveTwo</code>, which will be used to set the size of the wave’s two curves. Remember the wavy line shape has two curves on it, and they were created using those two control points, one for the left curve of the wavy line and the other for the right curve of the wavy line. The <code>curveOne</code> and <code>curveTwo</code> variables will allow us to alter the size of those curves on that wavy line; a bigger value will give us a bigger curve, and so a bigger wave.</li>
<li>Next is the <code>radius</code> variable, which allows us to set the radius on a shadow. I want to give each wave a shadow later and so this variable makes that customization easier.</li>
<li>The placement of these shadows is also important; we can control this placement with two <a id="_idIndexMarker567"/>variables, <code>shadowX</code> and <code>shadowY</code>.</li>
<li>Finally, the <code>duration</code> variable allows us to set the duration of the animation for each wave. </li>
</ul>
<p>With those variables in place, we only need a few lines of code to complete the <code>WaveCreation</code> struct. Those lines are as follows:</p>
<pre class="source-code">
var body: some View {
    WaveView(yOffset: animateOffset ? curveOne : curveTwo)
        <strong class="bold">.fill(Color(UIColor.blue))</strong>
<strong class="bold">        .shadow(color: .gray, radius: radius, x: shadowX,</strong>
<strong class="bold">          y: shadowY)</strong>
<strong class="bold">        .animation(Animation.easeInOut(duration:</strong>
<strong class="bold">          duration).repeatForever(autoreverses: true),</strong>
<strong class="bold">          value:animateOffset)</strong>
    }</pre>
<p>The first line of code calls the <code>WaveView</code> struct, and that requires a value for its <code>yOffset</code> parameter. We’re passing in one of two values: when the <code>animateOffset</code> variable is <code>true</code>, we’re going to use the <code>curveOne</code> variable, which means that one of the curves on the wavy line will be animated on the <em class="italic">y</em> axis. But when the <code>animateOffset</code> variable is <code>false</code>, we will then use the <code>curveTwo</code> variable, which will control the opposite side of the wavy line on the <em class="italic">y</em> axis.</p>
<p>The next line of code uses the <code>shadow</code> modifier to add a shadow to the wave. Looking at the parameters, the <code>color</code> parameter gets a gray color (which will look good against the blue waves), the <code>radius</code> parameter sets the size of the shadow, and the X and Y parameters allow us to adjust the shadow up, down, left, and right.</p>
<p>Then, the final line adds the animation – this is an <code>easeInOut</code> timing curve, which means the animation will start slowly, then build up, and when it finishes, it will ease itself out slowly. The duration of the animation will be set using the <code>duration</code> variable, with <code>repeatForever</code> and <code>autoreverses</code> set to <code>true</code>. Then, for the <code>value</code> parameter, that gets the <code>animateOffset</code> variable to start the animation.</p>
<p>Now, rather than just <a id="_idIndexMarker568"/>having one wave in our scene, we will call this structure inside the <code>ContentView</code> six times to make the ocean.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor145"/>Duplicating and animating the wave shape in the ContentView</h1>
<p>When creating our<a id="_idIndexMarker569"/> ocean, we’ll stack six waves in our scene and stagger the animation values so that they animate at different times. Working in the <code>ContentView</code> file <a id="_idIndexMarker570"/>now, we’ll start by adding a<a id="_idIndexMarker571"/> variable inside the <code>ContentView</code> struct that <a id="_idIndexMarker572"/>will toggle the <a id="_idIndexMarker573"/>animation on:</p>
<pre class="source-code">
@State private var animateOffset = false</pre>
<p>Next, let’s add a <code>ZStack</code> that will hold all the waves, and inside that, let’s set the background to a blue sky color:</p>
<pre class="source-code">
 ZStack {
            //MARK: - BACKGROUND
            Color.blue
                 .opacity(0.5)
                 .edgesIgnoringSafeArea(.all)
        }</pre>
<p>This code adds a <code>blue</code> color with an opacity of <code>0.5</code> (50%) for the background, and then we stretch that background out all the way around the edges of the screen using the <code>edgesIgnoreSafeArea</code> modifier.</p>
<p>We are now ready to add the first wave. So, add the following code directly underneath the <code>edgesIgnoring</code> modifier, inside the <code>ZStack</code>:</p>
<pre class="source-code">
//MARK: - WAVE 1
    WaveCreation(animateOffset: $animateOffset, curveOne:
      0.05, curveTwo: -0.05, radius: 50, shadowX: 0,
      shadowY: 50, duration: 5.0)
        .opacity(0.8)
        .offset(y: 575)</pre>
<p>Adding the wave is simple because we have done all of the work already – here, we just call the <code>WaveCreation</code> struct <a id="_idIndexMarker574"/>and fill some values into its parameters.</p>
<p>The first value is for the <code>animateOffset</code> parameter, a Boolean that will start the animation.</p>
<p>Then, the <code>curveOne</code> and <code>curveTwo</code> parameters require a value for both parts of the wavy line we made in <code>WaveView</code>. When you<a id="_idIndexMarker575"/> increase the value for one of the curve variables, you increase the height of the wave on one side. If you increase the size of both curve variables, you increase<a id="_idIndexMarker576"/> the height for both sides of the wave. Conversely, if you decrease the value for the curve variables by using <a id="_idIndexMarker577"/>negative numbers, then the wave gets smaller. </p>
<p>I’m using a small value here of <code>.05</code> and <code>-.05</code>. That’s because this is the first wave in the scene, and it will be further out to sea, so I want this wave to be a little calmer than the waves that are closer to the shore (and the user).</p>
<p>The next parameter is for the radius of the shadow. It’s set to <code>50</code>, which means it creates a shadow with a size of 50 points. The direction of the shadow will be controlled by the <code>shadowX</code> and <code>shadowY</code> properties – <code>shadowX</code> gets a value of <code>0</code> because I don’t want to move the shadow on the <em class="italic">x</em> axis left or right, but I do want to adjust it on the <em class="italic">y</em> axis, and a value of <code>50</code> points for the <code>shadowY</code> variable will bring the shadow upward by 50 points. </p>
<p>Then, we have the <code>duration</code> for the animation. We're setting it to <code>5</code> seconds to create the slower, calmer animation that we are aiming for with this first wave. </p>
<p>Finally, We're setting the opacity of this wave to <code>.8</code>, so it’s slightly less opaque than some of the other waves that we will be adding. Then, we offset this wave using a value of <code>575</code> on the <em class="italic">y</em> axis, putting it toward the bottom of the screen.</p>
<p>That completes our first wave. To see this animation, all we have to do is toggle the <code>animateOffset</code> variable<a id="_idIndexMarker578"/> inside the <code>onAppear</code> modifier. Add this code right at the end of the <code>ZStack</code>:</p>
<pre class="source-code">
  .onAppear() {
            animateOffset.toggle()
        }</pre>
<p>With that <a id="_idIndexMarker579"/>code in place, we can<a id="_idIndexMarker580"/> now run the app<a id="_idIndexMarker581"/> and see the result:</p>
<div><div><img alt="Figure 10.5: Our first wave " src="img/B18674_10_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Our first wave</p>
<p>The first wave has a smooth animation flowing back and forth, and we’re ready to build our next wave on top of it.</p>
<p>The code<a id="_idIndexMarker582"/> for the rest of the <a id="_idIndexMarker583"/>waves is nearly identical except for the specific values that we have set in each <a id="_idIndexMarker584"/>parameter. Here is the code for the<a id="_idIndexMarker585"/> next five waves:</p>
<pre class="source-code">
//MARK: - WAVE 2
    WaveCreation(animateOffset: $animateOffset, 
      curveOne: -0.07, curveTwo: 0.07, radius: 100,
      shadowX: 0, shadowY: 10, duration: 4.0)
.offset(y: 610)
//MARK: - WAVE 3
    WaveCreation(animateOffset: $animateOffset, curveOne: 0.1,       curveTwo: -0.1, radius: 30, shadowX: 0, shadowY: 0,       duration: 3.7)
.offset(y: 645)
//MARK: - WAVE 4
    WaveCreation(animateOffset: $animateOffset, 
      curveOne: 0.14, curveTwo: -0.1, radius: 70, 
      shadowX: 0, shadowY: 10, duration: 3.5)
.offset(y: 705)
//MARK: - WAVE 5
    WaveCreation(animateOffset: $animateOffset, 
      curveOne: -0.05, curveTwo: 0.08, radius: 60, 
      shadowX: 0, shadowY: 20, duration: 3.2)
        .opacity(0.8)
.offset(y: 740)
//MARK: - WAVE 6
    WaveCreation(animateOffset: $animateOffset, 
      curveOne: -0.05, curveTwo: 0.08, radius: 60, 
      shadowX: 0, shadowY: 20, duration: 3.4)
.offset(y: 800)</pre>
<p>As you can see, the values here are different from those of the first wave – for example, wave 2 has larger values for the curve variables, and the radius is bigger as well; however, the duration of this <a id="_idIndexMarker586"/>wave is slightly shorter, with a value of <code>4</code> seconds, making the animation a little faster. Waves 3, 4, 5, and 6 also have<a id="_idIndexMarker587"/> shorter durations, so we are increasing the speed of the animation for each wave as we move closer to the user’s point of view.</p>
<p>The shadows vary too, adding a <a id="_idIndexMarker588"/>nice white cresting look to the wave and helping to delineate the waves from each other. I’m using a gray<a id="_idIndexMarker589"/> color for the shadows as it’s not too pronounced; however, you can try white if you prefer a brighter-looking wave.</p>
<p>Now, go ahead and run the project in the simulator again and check out all the waves animating back and forth in our ocean scene:</p>
<div><div><img alt="Figure 10.6: All six waves together " src="img/B18674_10_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6: All six waves together</p>
<p>As with the first <a id="_idIndexMarker590"/>wave, the animation is smooth and rhythmic, and by piling up wave upon wave and offsetting<a id="_idIndexMarker591"/> each of them a little bit<a id="_idIndexMarker592"/> downward, we have created an ocean <a id="_idIndexMarker593"/>scene.</p>
<p>Next, we’re going to continue adding animations to the scene by adding a buoy that will bob up and down in the water, complete with a blinking light.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor146"/>Adding an animated floating buoy to the ocean scene</h1>
<p>When adding the buoy<a id="_idIndexMarker594"/> to our ocean scene, we will be giving it four different animations. It will do the following:</p>
<ul>
<li>Have a blinking light at the top of it</li>
<li>Tilt forward and backward</li>
<li>Move up and down</li>
<li>Rotate along its leading anchor</li>
</ul>
<p>All of these animations will combine to create a realistic-looking bobbing effect that simulates a floating object in an ocean reacting to the waves and current.</p>
<p>First, download the <code>buoy</code> image, which you can find in the <code>Chapter 10</code> folder in the GitHub repository, and add the image to the Assets catalog. Then, create a new SwiftUI View file, which we will call <code>BuoyView</code>. Inside the file, we will need six variables to get this buoy off the ground and into the water, so add the following code to the <code>BuoyView</code> struct:</p>
<pre class="source-code">
@Binding var tiltForwardBackward: Bool
    @Binding var upAndDown: Bool
    @Binding var leadingAnchorAnimate: Bool
    @State private var red = 1.0
    @State private var green = 1.0
    @State private var blue = 1.0</pre>
<p>Here, we are using three Boolean binding variables, which will oversee their respective animations: <code>tiltForwardBackward</code>, <code>upAndDown</code>, and <code>leadingAnchorAnimate</code>. Then, three <code>State</code> variables are used to make a blinking light animation.</p>
<p>We just added some binding variables to the <code>BuoyView</code> struct, which will introduce some errors in the project. The reason why these errors occur is that anytime we add binding variables to the struct we are working in, we will need to add them in the <code>Preview</code> struct as well; otherwise, the previews will complain. The Preview struct’s job is to display all the code that’s written within the file, so it works hand in hand with the <code>BuoyView</code> struct.</p>
<p>So, modify the Preview struct code to look like the following:</p>
<pre class="source-code">
struct BuoyView_Previews: PreviewProvider {
    static var previews: some View {
        BuoyView(tiltForwardBackward: .constant(true),
        upAndDown: .constant(true), leadingAnchorAnimate:
        .constant(true))
    }
}</pre>
<p>We are now, once again, error-free.</p>
<p>Let’s now come into the<a id="_idIndexMarker595"/> <code>body</code> property and add a <code>ZStack</code>, then add the buoy image inside of the <code>ZStack</code>:</p>
<pre class="source-code">
 ZStack {
           Image("buoy")
        }</pre>
<p>We should see the buoy in the previews now:</p>
<div><div><img alt="Figure 10.7: The buoy " src="img/B18674_10_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7: The buoy</p>
<p>We’re going to work on the blinking light first. In order to achieve this effect, we have to add a rectangle shape, place<a id="_idIndexMarker596"/> it on top of the buoy (inside the curved top), then give it some color, and finally toggle that color on and off to make it look like the light is blinking. </p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor147"/>Making the buoy light blink</h2>
<p>To start the process <a id="_idIndexMarker597"/>of creating the light, let’s overlay a rectangle on the buoy image. Add the following code to do that, right under the <code>Image</code> initializer:</p>
<pre class="source-code">
 ZStack {
           Image("buoy").overlay(Rectangle())
        }</pre>
<p>This is the <code>overlay</code> modifier, which allows us to add a new view over an existing view, to create layers of views.</p>
<p>If you look in your previews, you will see that the rectangle we just added is much too big for what we need. So, there needs to be a little more stylizing and resizing of it. But before we go any further, let’s set the color variables to some initial values in the <code>onAppear</code> modifier so we can see our work progressing in the previews. Add this code to the end of the <code>ZStack</code>:</p>
<pre class="source-code">
.onAppear() {
            red = 0.5
            green = 0.5
            blue = 0.5
        }</pre>
<p>I’m setting the <code>red</code>, <code>green</code>, and <code>blue</code> variables to a value of <code>0.5</code> (50%). This equal combination of 50% for these RGB colors produces a gray or neutral color, which will look good blinking against the blue sky background later. </p>
<p>Next, coming back to<a id="_idIndexMarker598"/> the <code>Image</code> initializer, let’s add that neutral gray color to the rectangle using another <code>overlay</code> modifier and passing in the color variables. Be careful to place the new code directly in front of the overlay’s closing brace, like this:</p>
<pre class="source-code">
 ZStack {
           Image("buoy").overlay(Rectangle()
               <strong class="bold"> .overlay(Color(red: red,green: green,blue:</strong>
<strong class="bold">                  blue)))</strong>
        }</pre>
<p>Now, we have a big gray rectangle, but we don’t see the buoy anymore because the rectangle is too big and needs to be resized. We are going to fix that. Add the following rectangle modifiers, which will size and position the rectangle, and place them directly inside the closing brace of the first <code>overlay</code> modifier:</p>
<pre class="source-code">
 Image("buoy").overlay(Rectangle()
     .overlay(Color(red: red,green: green,blue: blue))
     //adds a corner radius only to the bottom corners of
       the rectangle
                <strong class="bold">.frame(width: 12, height: 17)</strong>
<strong class="bold">                .position(x: 112.5, y: 19.5))</strong>
                 }</pre>
<p>The <code>frame</code> modifier sets the width <a id="_idIndexMarker599"/>and height of the rectangle to a small size of <code>12</code> by <code>17</code>. Then, the <code>position</code> modifier places the rectangle at the X and Y coordinates of <code>112.5</code> and <code>19.5</code>, which is at the top part of the buoy, the area that represents the light.  </p>
<p>You can see the rectangle in the following image:</p>
<div><div><img alt="Figure 10.8: The buoy with the rectangle overlay " src="img/B18674_10_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8: The buoy with the rectangle overlay</p>
<p>The rectangle looks good; however, a <a id="_idIndexMarker600"/>rectangle is, well, a rectangle. It has sharp corners on all four sides, whereas the top of the buoy has curved corners, as you can see in <em class="italic">Figure 10</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 10.9: A closer look at the rectangle overlay " src="img/B18674_10_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9: A closer look at the rectangle overlay</p>
<p>Using our current rectangle is a bit like fitting a square peg into a round hole. Luckily, SwiftUI does give us a modifier that rounds the corner radius of rectangles, but unluckily, there is still a problem with it: it rounds all four corners when all we want is for the top two corners to be rounded.</p>
<p>We could fix this by adding an extension to the corner radius modifier and altering its behavior so it will only act on two corners by writing numerous lines of code. However, a simpler way of achieving a two-corner radius modifier is by using the <code>padding</code> modifier in a unique way. </p>
<p>To do this, after the last <a id="_idIndexMarker601"/>variable in the <code>BuoyView</code> struct, add a constant to store the radius we want for rounding the two corners of our rectangle:</p>
<pre class="source-code">
    let cRadius = 8.0</pre>
<p>I’m calling this constant <code>cRadius</code>, for the corner radius, and setting it to a value of <code>8.0</code> points. The larger you make the corner radius value, the more rounded the rectangle becomes; for our purposes, an eight-point value adds just enough rounding to our rectangle’s two top corners to make it fit perfectly within the buoy light. </p>
<p>Add the following code, directly after the second <code>overlay</code> modifier, like this:</p>
<pre class="source-code">
Image("buoy").overlay(Rectangle()
    .overlay(Color(red: red,green: green,blue: blue))
    ///add a corner radius only to the bottom corners
<strong class="bold">        .padding(.bottom, cRadius)</strong>
<strong class="bold">        .cornerRadius(cRadius)</strong>
<strong class="bold">        .padding(.bottom, -cRadius)</strong>
    .frame(width: 12, height: 17)
    .position(x: 112.5, y: 19.5))</pre>
<p>Here’s what the code does. The <code>.padding(.bottom, cRadius)</code> line adds eight-point padding to the bottom of the rectangle. Then, we call the <code>cornerRadius</code> modifier, which will put a corner radius on all four corners of the rectangle. But since we have an eight-point <a id="_idIndexMarker602"/>padding on the bottom of the rectangle, we don’t see that corner radius placed on the bottom; we will only see the curved corners at the top of the rectangle, which is exactly what we want. </p>
<p>Finally, we call the <code>padding</code> modifier again, and again choose the <code>.bottom</code> option to place padding only on the bottom of the rectangle. This time, however, we set a value of <code>-8</code> points. When we make this option negative, it effectively extends the rectangle downward on the <em class="italic">y</em> axis – by 8 points – but preserves those two sharp corners that we want at the bottom. This is a pretty neat trick and saves us some time writing code in an extension for the <code>cornerRadius</code> modifier. This is the result we see in the previews now:</p>
<div><div><img alt="Figure 10.10: The rectangle overlay now fitting the curved tip of the buoy " src="img/B18674_10_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10: The rectangle overlay now fitting the curved tip of the buoy</p>
<p>The previews show that our gray rectangle now matches the curvature of the top portion of the light and has two sharp corners to match the bottom portion of the light.</p>
<p>To finish off the light and make it blink, we only have to add one line of code after the last line of code in the <code>ZStack</code>:</p>
<pre class="source-code">
    ///the animation for the blinking light
    .animation(Animation.easeOut(duration:
      1).repeatForever(autoreverses: true),value: red)</pre>
<p>With that code in place, if you run the previews here in the <code>BuoyView</code> file, you’ll see that now we have a <a id="_idIndexMarker603"/>blinking light that will blink on and off for a duration of 1 second, repeating forever, or until the app stops:</p>
<div><div><img alt="Figure 10.11: The completed buoy with a blinking light " src="img/B18674_10_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11: The completed buoy with a blinking light</p>
<p>Let’s add the animations that make the buoy move now. </p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor148"/>Making the buoy move</h2>
<p>The first animation<a id="_idIndexMarker604"/> that we will add to make the buoy move will be to rotate the buoy along its leading anchor point. To do this, add the following code right after the previous line of code in the <code>ZStack</code>:</p>
<pre class="source-code">
   ///the animation for the anchor point motion
    .rotationEffect(.degrees(leadingAnchorAnimate ? 7 :
      -3), anchor: .leading) 
    .animation(Animation.easeOut(duration:
      0.9).repeatForever(autoreverses: true),
      value: leadingAnchorAnimate)</pre>
<p>This code uses the <code>rotationEffect</code> modifier and will rotate the buoy by either <code>7</code> degrees when the <code>leadingAnchorAnimate</code> property becomes <code>true</code>, or <code>-3</code> when it's <code>false</code>. For the <code>anchor</code> parameter, we used the <code>leading</code> anchor option, which pivots the image around the leading edge, but you can use the <code>bottom</code> option as well for a slightly different rotation.</p>
<p>Then, we added the <code>animation</code> modifier, setting its <code>duration</code> to <code>0.9</code> seconds, with <code>repeatForever</code>, and <code>autoreverses</code> set to <code>true</code>.</p>
<p>We will also toggle the <code>leadingAnchorAnimate</code> property to <code>true</code> in the <code>onAppear</code> modifier shortly, but first, let’s add the other two animations to the buoy. </p>
<p>The next animation to add will make the buoy tilt forward and backward. Add the code for this right under the previous code:</p>
<pre class="source-code">
   ///the animation for the tilt forward and backward
     motion
    .rotationEffect(.degrees(tiltForwardBackward ? -20 :
      15))
    .animation(Animation.easeInOut(duration:
      1.0).delay(0.2).repeatForever(autoreverses:
      true),value: tiltForwardBackward)</pre>
<p>The is almost identical to the previous code, but the value of <code>.rotationEffect</code> is now set to <code>tiltForwardBackward</code>. The amount of rotation or tilt forward and back is going to be either <code>-20</code> degrees or <code>15</code> degrees, depending on the value inside of the <code>tiltForwardBackward</code> variable. Also, in the <code>animation</code> modifier, we’re adding a slight delay of <code>0.2</code>, as this will help to add to a real-looking bobbing motion.</p>
<p>Now, to add the final animation to the buoy, which will make the image move up and down, add this line of code directly after the previous code:</p>
<pre class="source-code">
.offset(y: upAndDown ? -10 : 10)</pre>
<p>A negative value will <a id="_idIndexMarker605"/>move an image up the <em class="italic">y</em> axis and a positive value will move the image down the <em class="italic">y</em> axis. So, this code will move the entire buoy image 10 points up or down depending on the <code>upAndDown</code> variable.</p>
<p>The last bit of code we need in the <code>BuoyView</code> file is code that toggles on these three animations in the <code>onAppear</code> modifier. So, add the following code:</p>
<pre class="source-code">
.onAppear() {
<strong class="bold">           leadingAnchorAnimate.toggle()</strong>
<strong class="bold">             tiltForwardBackward.toggle()</strong>
<strong class="bold">             upAndDown.toggle()</strong>
            red = 0.5
            green = 0.5
            blue = 0.5
        }</pre>
<p>That completes the <code>BuoyView</code> file, and now we can proceed to <code>ContentView</code> and add the buoy to the scene.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor149"/>Adding the buoy to the scene</h2>
<p>We want to place<a id="_idIndexMarker606"/> the buoy slightly in the distance of our ocean scene, so let’s add it right after wave 1. Add the following code after the closing brace of the first wave:</p>
<pre class="source-code">
  //MARK: - BUOY
      BuoyView(tiltForwardBackward: $tiltForwardBackward,
        upAndDown: $upAndDown, leadingAnchorAnimate:
        $leadingAnchorAnimnate)
      .offset(y: 205)</pre>
<p>Inside the <code>BuoyView</code> initializer, we pass in the three binding properties that initiate three separate animations. We add a dollar sign before those binding properties, which tells the compiler that there’s a two-way binding between the <code>BuoyView</code> struct and the <code>ContentView</code> struct. Next, using the <code>offset</code> modifier, we can place the buoy at the proper height in the ocean scene.</p>
<p>Now, go ahead and run the project in the simulator to see the animations:</p>
<div><div><img alt="Figure 10.12: The completed animation " src="img/B18674_10_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12: The completed animation</p>
<p>Though the code for the waves and buoy work independently, the two elements visually work together to create our ocean scene.</p>
<p>The final element <a id="_idIndexMarker607"/>that we can add next is some sound effects. How about the sound of some ocean waves and a buoy bell ringing in the background? That would really complete the project.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor150"/>Adding sound effects</h1>
<p>We already added<a id="_idIndexMarker608"/> sound in <a href="B18674_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, when building <a id="_idIndexMarker609"/>the record player project, and there’s nothing complicated about it.</p>
<p>First, start by creating a Swift file (just a Swift file, not a SwiftUI View one), and call it <code>PlaySound</code>. Next, drag the M4A sound effects file called <code>buoyBells</code> (which you can find on GitHub) and place it into the file navigator.</p>
<p>Inside the <code>PlaySound</code> file, the first thing we need to do is import the AVFoundation framework:</p>
<pre class="source-code">
import AVFoundation</pre>
<p>The AVFoundation framework gives us access to all the classes and methods needed to add audio to a project.</p>
<p>Next, create an <code>audioPlayer</code> object to play our sound file:</p>
<pre class="source-code">
var audioPlayer: AVAudioPlayer?</pre>
<p>This <code>audioPlayer</code> object is <a id="_idIndexMarker610"/>optional, which you can tell by the question mark at the end. It needs to be optional because the sound file may not exist for whatever reason – maybe the file gets <a id="_idIndexMarker611"/>corrupted, or the sound file has been downloaded from a server and the internet has timed out – and so this protects the project from crashing.</p>
<p>Finally, under the previous line of code, all we need to do is add a function to handle the audio needs of this project:</p>
<pre class="source-code">
func playSound(name: String, type: String) {
    if let path = Bundle.main.path(forResource: sound,
      ofType: type) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf:
              URL(fileURLWithPath: path))
            audioPlayer?.play()
        } catch {
            print("Could not find and play the sound file")
        }
    }
}</pre>
<p>The function is called <code>playSound</code>. It accepts two strings, one to hold the name of the file and another to hold the file’s extension type.</p>
<p>The first thing we do is try to access the sound file that’s in the app bundle by using the <code>path_forResource()</code> function. The app bundle is an internal hidden folder that is created for each app to hold all the necessary files to get <a id="_idIndexMarker612"/>the app up and running.</p>
<p>If the file exists with the specified name and type, then the code proceeds into the <code>do</code> block and tries to create the audio player with the path of the file’s location stored in the <code>path</code> constant. If, for whatever reason, the file cannot be found or it’s corrupt, then the code will fall into the <code>catch</code> block and print out an error.</p>
<p>And that’s really it for the <code>PlaySound</code> file. Let’s go back into <code>ContentView</code> and add the sound effects to the project. In the <code>onAppear</code> modifier, set the sound to start playing with the<a id="_idIndexMarker613"/> following code:</p>
<pre class="source-code">
.onAppear() {
            animateOffset.toggle()
            playSound(name: "buoyBells", type: "m4a")
        }</pre>
<p>We also need a way of stopping the sound too, when the app stops running on the device or the user closes the app. The way to make the sound stop is to call the <code>onDisappear</code> modifier, which we can use directly on the closing brace of the <code>onAppear</code> modifier, like this:</p>
<pre class="source-code">
       .onDisappear()
        {
            audioPlayer?.stop()
        }</pre>
<p>And with that, the project is complete!</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor151"/>Summary</h1>
<p>In this chapter, we created an ocean scene, with moving waves and a bobbing buoy with a flashing light, and added some sounds too.</p>
<p>More specially, you used the Shape protocol, the <code>path</code> function, the <code>animatableData</code> property, and curve variables to make the wave shape come alive. When working on the buoy, we looked at how to combine multiple types of animation to create unique effects, and how to turn different colors on and off to create a blinking effect.</p>
<p>The parameters in this project are highly customizable, so feel free to experiment further – maybe you want to create bigger waves or more of them, create the waves in landscape orientation, alter the shadow to create a horizon, or even replace the buoy with a boat!</p>
<p>Let’s keep going. In the next project, we will create a working elevator animation using timers and sound effects.</p>
</div>
<div><div></div>
</div>
</body></html>