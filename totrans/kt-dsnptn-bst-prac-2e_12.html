<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-210"><em class="italic"><a id="_idTextAnchor216"/>Chapter 9</em>: Idioms and Anti-Patterns</h1>&#13;
			<p>In the previous chapters, we discussed the different aspects of the Kotlin programming language, the benefits of functional programming, and concurrent design patterns.</p>&#13;
			<p>This chapter discusses the best and worst practices in Kotlin. You'll learn what idiomatic Kotlin code should look like and which patterns to avoid. This chapter contains a collection of best practices spanning those different topics.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Using the scope functions</li>&#13;
				<li>Type checks and casts</li>&#13;
				<li>An alternative to the try-with-resources statement</li>&#13;
				<li>Inline functions</li>&#13;
				<li>Implementing algebraic data types</li>&#13;
				<li>Reified generics</li>&#13;
				<li>Using constants efficiently</li>&#13;
				<li>Constructor overload</li>&#13;
				<li>Dealing with nulls</li>&#13;
				<li>Making asynchronicity explicit</li>&#13;
				<li>Validating input</li>&#13;
				<li>Preferring sealed classes over enums</li>&#13;
			</ul>&#13;
			<p>After completing this chapter, you should be able to write more readable and maintainable Kotlin code, as well as avoid some common pitfalls. </p>&#13;
			<h1 id="_idParaDest-211"><a id="_idTextAnchor217"/>Technical requirements</h1>&#13;
			<p>In addition to the requirements from the previous chapters, you will also need a <strong class="bold">Gradle</strong>-enabled <strong class="bold">Kotlin</strong> project to be able to add the required dependencies.</p>&#13;
			<p>You can find the source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09</a>.</p>&#13;
			<h1 id="_idParaDest-212"><a id="_idTextAnchor218"/>Using the scope functions</h1>&#13;
			<p>Kotlin has<a id="_idIndexMarker601"/> the concept of <strong class="bold">scoping functions</strong>, which are available on any object and can replace the need to write repetitive code. Among other benefits, these scoping functions help us simplify single-expression functions. They are considered higher-order functions since each scoping function receives a lambda expression as an argument. In this section, we'll discuss all the necessary functions and execute their code blocks using objects as their <em class="italic">scope</em>. In this section, we'll use the terms <em class="italic">scope</em> and <em class="italic">context object</em> interchangeably to describe the objects that those functions operate on. </p>&#13;
			<h2 id="_idParaDest-213"><a id="_idTextAnchor219"/>Let function</h2>&#13;
			<p>We can<a id="_idIndexMarker602"/> use <a id="_idIndexMarker603"/>the <code>let()</code> function to invoke a function on a nullable object, but only if the object is not null.</p>&#13;
			<p>Let's take, as an example, the following map of quotes (we discussed this in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>):</p>&#13;
			<pre>val clintEastwoodQuotes = mapOf(</pre>&#13;
			<pre>    "The Good, The Bad, The Ugly" to "Every gun makes its       own tune.",</pre>&#13;
			<pre>    "A Fistful Of Dollars" to "My mistake: four coffins."</pre>&#13;
			<pre>)</pre>&#13;
			<p>Now, let's fetch a quote from a movie that may not exist in the collection and print it, but only if it's not null:</p>&#13;
			<pre>val quote = clintEastwoodQuotes["Unforgiven"]</pre>&#13;
			<pre>if (quote != null) {</pre>&#13;
			<pre>    println(quote)</pre>&#13;
			<pre>} </pre>&#13;
			<p>The same code can we rewritten using the <code>let</code> scoping function:</p>&#13;
			<pre>clintEastwoodQuotes["Unforgiven"]?.let {</pre>&#13;
			<pre>    println(it)</pre>&#13;
			<pre>}</pre>&#13;
			<p>One common mistake is forgetting to use the safe navigation operator before <code>let</code>, because <code>let()</code> by itself also works on nulls:</p>&#13;
			<pre>clintEastwoodQuotes["Unforgiven"].let {</pre>&#13;
			<pre>    println(it)</pre>&#13;
			<pre>}</pre>&#13;
			<p>This code<a id="_idIndexMarker604"/> will print <code>null</code> to the console. Make sure that you don't forget <a id="_idIndexMarker605"/>the question mark (<code>?</code>) when you use <code>let()</code> for null checks.</p>&#13;
			<h2 id="_idParaDest-214"><a id="_idTextAnchor220"/>Apply function</h2>&#13;
			<p>We <a id="_idIndexMarker606"/>have <a id="_idIndexMarker607"/>discussed <code>apply()</code> in previous chapters. It returns the same object it operates on and sets the context to <code>this</code>. You can use <code>apply()</code> if you need to initialize a mutable object.</p>&#13;
			<p>Think of how many times you had to create a class that has an empty constructor, and then call a lot of setters, one after another. Let's look at the following class as an example. This may be a class that comes from a library, for example:</p>&#13;
			<pre>class JamesBond { </pre>&#13;
			<pre>    lateinit var name: String </pre>&#13;
			<pre>    lateinit var movie: String </pre>&#13;
			<pre>    lateinit var alsoStarring: String </pre>&#13;
			<pre>} </pre>&#13;
			<p>When we need to create a new instance of such a class, we could do so in a procedural manner: </p>&#13;
			<pre>val agent = JamesBond() </pre>&#13;
			<pre>agent.name = "Sean Connery" </pre>&#13;
			<pre>agent.movie = "Dr. No"</pre>&#13;
			<p>Alternatively, we can only set <code>name</code> and <code>movie</code>, and leave <code>alsoStarring</code> blank, using the <code>apply()</code> function:</p>&#13;
			<pre>val `007` = JamesBond().apply { </pre>&#13;
			<pre>    this.name = "Sean Connery" </pre>&#13;
			<pre>    this.movie = "Dr. No" </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>println(`007`.name)</pre>&#13;
			<p>Since the<a id="_idIndexMarker608"/> context<a id="_idIndexMarker609"/> of the block is set to <code>this</code>, we can simplify the preceding code even further:</p>&#13;
			<pre>val `007` = JamesBond().apply { </pre>&#13;
			<pre>    name = "Sean Connery" </pre>&#13;
			<pre>    movie = "Dr. No" </pre>&#13;
			<pre>}</pre>&#13;
			<p>Using the <code>apply()</code> function is especially good when you're working with Java classes that usually have a lot of setters and a default empty constructor.</p>&#13;
			<h2 id="_idParaDest-215"><a id="_idTextAnchor221"/>Also function</h2>&#13;
			<p>As we <a id="_idIndexMarker610"/>mentioned in<a id="_idIndexMarker611"/> the introduction to this section, single-expression functions are very nice and concise. Let's look at the following simple function, which multiplies two numbers:</p>&#13;
			<pre>fun multiply(a: Int, b: Int): Int = a * b</pre>&#13;
			<p>But often, you have a single-statement function that also needs to, for example, write to a log or have another side effect. To achieve this, we could rewrite our function in the following way:</p>&#13;
			<pre>fun multiply(a: Int, b: Int): Int { </pre>&#13;
			<pre>    val c = a * b </pre>&#13;
			<pre>    println(c) </pre>&#13;
			<pre>    return c </pre>&#13;
			<pre>}</pre>&#13;
			<p>We had to make our function much more verbose here and introduce another variable. Let's see how we can use the <code>also()</code> function instead:</p>&#13;
			<pre>fun multiply(a: Int, b: Int): Int = </pre>&#13;
			<pre>    (a * b)<strong class="bold">.also { println(it) }</strong></pre>&#13;
			<p>This function<a id="_idIndexMarker612"/> will assign the results of the expression to <code>it</code> and <a id="_idIndexMarker613"/>return the result of the expression. The <code>also()</code> function is also useful when you want to have a side effect on a chain of calls:</p>&#13;
			<pre>val l = (1..100).toList() </pre>&#13;
			<pre>l.filter{ it % 2 == 0 } </pre>&#13;
			<pre>    // Prints, but doesn't mutate the collection</pre>&#13;
			<pre>    .also { println(it) }     </pre>&#13;
			<pre>    .map { it * it }</pre>&#13;
			<p>Here, you can see that we can continue our chain of calls with a <code>map()</code> function, even though we used the <code>also()</code> function to print each element of a list.</p>&#13;
			<h2 id="_idParaDest-216"><a id="_idTextAnchor222"/>Run function</h2>&#13;
			<p>The <code>run()</code> function <a id="_idIndexMarker614"/>is very <a id="_idIndexMarker615"/>similar to the <code>let()</code> function, but it sets the context of the block to <code>this</code> instead of using <code>it</code>.</p>&#13;
			<p>Let's look at an example to understand this better:</p>&#13;
			<pre>val justAString = "string" </pre>&#13;
			<pre>val n = justAString.run {  </pre>&#13;
			<pre>    this.length </pre>&#13;
			<pre>}</pre>&#13;
			<p>In this example, <code>this</code> is set to reference the <code>justAString</code> variable.</p>&#13;
			<p>Usually, <code>this</code> could be omitted, so the code will look as follows:</p>&#13;
			<pre>val n = justAString.run {  </pre>&#13;
			<pre>    length </pre>&#13;
			<pre>}</pre>&#13;
			<p>The <code>run()</code> function is mostly useful when you plan to initialize an object, much like the <code>apply()</code> function we discussed earlier. However, instead of returning the object itself, like <code>apply()</code> does, you<a id="_idIndexMarker616"/> usually like to return the result of some<a id="_idIndexMarker617"/> computation:</p>&#13;
			<pre>val lowerCaseName = JamesBond().run {</pre>&#13;
			<pre>    name = "ROGER MOORE"</pre>&#13;
			<pre>    movie = "THE MAN WITH THE GOLDEN GUN"</pre>&#13;
			<pre>    name.toLowerCase() // &lt;= Not JamesBond type</pre>&#13;
			<pre>}</pre>&#13;
			<pre>println(lowerCaseName)</pre>&#13;
			<p>The preceding code prints the following output:</p>&#13;
			<pre>&gt; roger moore</pre>&#13;
			<p>Here, the object was initialized with <code>"ROGER MOORE"</code>. Note that here, we operated on the <code>JamesBond</code> object, but<a id="_idIndexMarker618"/> our return value was a <code>String</code>. </p>&#13;
			<h2 id="_idParaDest-217"><a id="_idTextAnchor223"/>With function</h2>&#13;
			<p>Unlike the<a id="_idIndexMarker619"/> other four scoping functions, <code>with()</code> is not an <a id="_idIndexMarker620"/>extension function. This means you cannot do the following:</p>&#13;
			<pre>"scope".with { ... }</pre>&#13;
			<p>Instead, <code>with()</code> receives the object you want to scope as an argument:</p>&#13;
			<pre>with("scope") { </pre>&#13;
			<pre>    println(this.length) // "this" set to the argument of                          // with() </pre>&#13;
			<pre>}</pre>&#13;
			<p>And as usual, we can omit <code>this</code>:</p>&#13;
			<pre>with("scope") { </pre>&#13;
			<pre>    length </pre>&#13;
			<pre>}</pre>&#13;
			<p>Just like <code>run()</code> and <code>let()</code>, you can return any result from <code>with()</code>.</p>&#13;
			<p>In this section, we learned how the various scope functions can help reduce the amount of boilerplate code by defining a code block to be executed on the object. In the next section, we'll see how Kotlin also allows us to write fewer instance checks than other languages.</p>&#13;
			<h1 id="_idParaDest-218"><a id="_idTextAnchor224"/>Type checks and casts</h1>&#13;
			<p>While writing <a id="_idIndexMarker621"/>your code, you may often be inclined to check what type your object is using, <code>is</code>, and cast it using <code>as</code>. As an example, let's imagine we're building a system for superheroes. Each superhero has their own set of methods:</p>&#13;
			<pre>interface Superhero </pre>&#13;
			<pre>class Batman : Superhero { </pre>&#13;
			<pre>    fun callRobin() { </pre>&#13;
			<pre>        println("To the Bat-pole, Robin!") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>class Superman : Superhero { </pre>&#13;
			<pre>    fun fly() { </pre>&#13;
			<pre>        println("Up, up and away!") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>} </pre>&#13;
			<p>There's also a <a id="_idIndexMarker622"/>function where a superhero tries to invoke their superpower:</p>&#13;
			<pre>fun doCoolStuff(s: Superhero) { </pre>&#13;
			<pre>    if (s is Superman) { </pre>&#13;
			<pre>        (s as Superman).fly() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    else if (s is Batman) { </pre>&#13;
			<pre>        (a as Batman).callRobin() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>But as you may know, Kotlin has smart casts, so implicit casting, in this case, is not needed. Let's rewrite this function using smart casts and see how they improve our code. All we need to do is remove the explicit casts from our code:</p>&#13;
			<pre>fun doCoolStuff(s: Superhero) { </pre>&#13;
			<pre>    if (s is Superman) { </pre>&#13;
			<pre>        s.fly() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    else if (s is Batman) { </pre>&#13;
			<pre>        s.callRobin() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Moreover, in most cases, using <code>when()</code> while smart casting produces cleaner code:</p>&#13;
			<pre>fun doCoolStuff(s : Superhero) { </pre>&#13;
			<pre>    when(s) { </pre>&#13;
			<pre>        is Superman -&gt; s.fly() </pre>&#13;
			<pre>        is Batman -&gt; s.callRobin() </pre>&#13;
			<pre>        else -&gt; println("Unknown superhero") </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>As a rule of thumb, you should avoid using casts and rely on smart casts most of the time:</p>&#13;
			<pre>// Superhero is clearly not a string </pre>&#13;
			<pre>val superheroAsString = (s as String)</pre>&#13;
			<p>But if you absolutely must, there's also a safe cast operator:</p>&#13;
			<pre>val superheroAsString = (s as? String)</pre>&#13;
			<p>The <strong class="bold">safe cast operator</strong> will <a id="_idIndexMarker623"/>return null if the object cannot be cast, instead of throwing an exception. </p>&#13;
			<h1 id="_idParaDest-219"><a id="_idTextAnchor225"/>An alternative to the try-with-resources statement</h1>&#13;
			<p><code>AutoCloseable</code> and the try-with-resources statement.</p>&#13;
			<p>This statement allows us to provide a set of resources that will be automatically closed once the code is done with them. So, there will be no more risk (or at least less risk) of forgetting to close a file.</p>&#13;
			<p>Before Java 7, this was a total mess, as shown in the following code:</p>&#13;
			<pre>BufferedReader br = null; // Nulls are bad, we know that </pre>&#13;
			<pre>try { </pre>&#13;
			<pre>    br = new BufferedReader(new FileReader</pre>&#13;
			<pre>      ("./src/main/kotlin/7_TryWithResource.kt "));</pre>&#13;
			<pre>    System.out.println(br.readLine());</pre>&#13;
			<pre>} </pre>&#13;
			<pre>finally { </pre>&#13;
			<pre>    if (br != null) { // Explicit check </pre>&#13;
			<pre>        br.close(); // Boilerplate </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>After <strong class="bold">Java 7</strong> was<a id="_idIndexMarker625"/> released, the preceding code could be written as follows:</p>&#13;
			<pre>try (BufferedReader br = new BufferedReader(new   FileReader("/some/path"))) { </pre>&#13;
			<pre>    System.out.println(br.readLine()); </pre>&#13;
			<pre>}</pre>&#13;
			<p>Kotlin doesn't support this syntax. Instead, the try-with-resource statement is replaced with the <code>use()</code> function:</p>&#13;
			<pre>val br = BufferedReader(FileReader("./src/main   /kotlin/7_TryWithResource.kt"))</pre>&#13;
			<pre> </pre>&#13;
			<pre>br.use {</pre>&#13;
			<pre>    println(it.readLines())</pre>&#13;
			<pre>}</pre>&#13;
			<p>An object must implement the <code>Closeable</code> interface for the <code>use()</code> function to be available. The <code>Closeable</code> object <a id="_idIndexMarker626"/>will be closed as soon as we exit the <code>use{}</code> block.</p>&#13;
			<h1 id="_idParaDest-220"><a id="_idTextAnchor226"/>Inline functions</h1>&#13;
			<p>You can<a id="_idIndexMarker627"/> think of <code>inline</code> functions as instructions for the compiler to copy and paste your code. Each time the compiler sees a call to a function marked with the <code>inline</code> keyword, it will replace the call with the concrete function body.</p>&#13;
			<p>It makes sense to use the <code>inline</code> function if it's a higher-order function that receives a lambda as one of its arguments. This is the most common use case where you would like to use <code>inline</code>.</p>&#13;
			<p>Let's look at such a higher-order function and see what pseudocode the compiler will output.</p>&#13;
			<p>First, here is the function definition:</p>&#13;
			<pre>inline fun logBeforeAfter(block: () -&gt; String) { </pre>&#13;
			<pre>    println("Before") </pre>&#13;
			<pre>    println(block()) </pre>&#13;
			<pre>    println("After") </pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we pass a lambda, or a <code>block</code>, to our function. This <code>block</code> simply returns the word <code>"Inlining"</code> as a <code>String</code>:</p>&#13;
			<pre>logBeforeAfter { </pre>&#13;
			<pre>    "Inlining" </pre>&#13;
			<pre>}</pre>&#13;
			<p>If you were to view the Java equivalent of the decompiled bytecode, you'd see that there's no call to our <code>makesSense</code> function at all. Instead, you'd see the following:</p>&#13;
			<pre>String var1 = "Before"; &lt;- Inline function call </pre>&#13;
			<pre>System.out.println(var1); </pre>&#13;
			<pre>var1 = "Inlining"; </pre>&#13;
			<pre>System.out.println(var1); </pre>&#13;
			<pre>var1 = "After"; </pre>&#13;
			<pre>System.out.println(var1); </pre>&#13;
			<p>Since the <code>inline</code> function is a copy/paste of your code, you shouldn't use it if you have more than a few lines of code. It would be more efficient to have it as a regular function. But if you have single-expression functions that receive a lambda, it makes sense to mark them with the <code>inline</code> keyword to optimize performance. In the end, it's a trade-off <a id="_idIndexMarker628"/>between the size of your application and its performance. </p>&#13;
			<h1 id="_idParaDest-221"><a id="_idTextAnchor227"/>Implementing Algebraic Data Types</h1>&#13;
			<p><strong class="bold">Algebraic Data Types</strong>, or <strong class="bold">ATDs</strong> for short, is <a id="_idIndexMarker629"/>a concept from functional programming and is very similar to the <strong class="bold">Composite design pattern</strong> we <a id="_idIndexMarker630"/>discussed in <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>.</p>&#13;
			<p>To understand how ADTs work and what their benefits are, let's discuss how we can implement a simple binary tree in Kotlin.</p>&#13;
			<p>First, let's declare an interface for our tree. Since a tree data structure can contain any type of data, we can parameterize it with a type (<code>T</code>):</p>&#13;
			<pre>sealed interface Tree&lt;out T&gt;</pre>&#13;
			<p>The type is marked with an <code>out</code> keyword, which means that this type is <em class="italic">covariant</em>. If you aren't familiar with this term, we'll cover it later, while implementing the interface.</p>&#13;
			<p>The opposite of a covariant is a <em class="italic">contravariant</em>. Contravariant types should be marked using the <code>in</code> keyword.</p>&#13;
			<p>We can also mark this interface with a <code>sealed</code> keyword. We saw this keyword applied to regular classes in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, while discussing the <code>sealed</code> interfaces are a relatively new feature and were introduced in <strong class="bold">Kotlin 1.5</strong>.</p>&#13;
			<p>The meaning is the same, though: only the owner of the interface can implement it. This means that all the implementations of the interface are known at compile time. </p>&#13;
			<p>Next, let's declare what an empty tree looks like:</p>&#13;
			<pre>object Empty : Tree&lt;Nothing&gt; {</pre>&#13;
			<pre>    override fun toString() = "Empty"</pre>&#13;
			<pre>}</pre>&#13;
			<p>Since all empty trees are the same, we declare it as an object. This is another use of the <code>Nothing</code> as the type of an empty tree. This is a special class in Kotlin's object hierarchy. </p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">There is some<a id="_idIndexMarker632"/> confusion between <code>Any</code>, which represents any class and is similar to <code>Object</code> in Java, and <code>Nothing</code>, which represents no class. We'll see why <code>Any</code> wouldn't work in this case later in this chapter.</p>&#13;
			<p>Next, let's define a non-empty node of a tree:</p>&#13;
			<pre>data class Node&lt;T&gt;(</pre>&#13;
			<pre>    val value: T,</pre>&#13;
			<pre>    val left: Tree&lt;T&gt; = Empty,</pre>&#13;
			<pre>    val right: Tree&lt;T&gt; = Empty</pre>&#13;
			<pre>) : Tree&lt;T&gt;</pre>&#13;
			<p><code>Node</code> also implements the <code>Tree</code> interface, but it is a data class and not an object since every node is different. The type of the value of a <code>Node</code> is <code>T</code>, which means it can contain any type of value, but all the nodes in the same tree will contain the same type of value. This is the real power of generics. </p>&#13;
			<p>A node also has two children, left and right, since it's a binary tree. By default, both of them are empty.</p>&#13;
			<p>We can specify the default values for the children of a node thanks to the fact that the type is covariant and <code>Empty</code> is of the <code>Nothing</code> type. <code>Nothing</code> is at the bottom of the class hierarchy, while <code>Any</code> is at the very top. </p>&#13;
			<p>When we declared the type of our <code>Tree</code> as <code>out T</code>, we meant that our <code>Tree</code> could contain values of type <code>T</code> or anything that inherits from that type.</p>&#13;
			<p>Since <code>Nothing</code> is at the bottom of a class hierarchy, it <em class="italic">inherits</em> from all types.</p>&#13;
			<p>Now that everything <a id="_idIndexMarker633"/>has been set, let's learn how to create a new instance of the tree we just defined:</p>&#13;
			<pre>val tree = Node(</pre>&#13;
			<pre>    1,</pre>&#13;
			<pre>    Empty,</pre>&#13;
			<pre>    Node(</pre>&#13;
			<pre>        2,</pre>&#13;
			<pre>        Node(3)</pre>&#13;
			<pre>    )</pre>&#13;
			<pre>)</pre>&#13;
			<pre>println(tree)</pre>&#13;
			<p>Here, we created a tree with <strong class="bold">1</strong> as the value of the root node and a right node with a value of <strong class="bold">2</strong>. The right node has a left child with a value of <strong class="bold">3</strong>. This is what our tree looks like:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B17816_09_01.jpg" alt="Figure 9.1 – Tree diagram&#13;&#10;" width="290" height="484"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 9.1 – Tree diagram</p>&#13;
			<p>The preceding code outputs the following:</p>&#13;
			<pre>&gt; Node(value=1, left=Empty, right=Node(value=2, left=Node(value=3, left=Empty, right=Empty), right=Empty))</pre>&#13;
			<p>However, printing <a id="_idIndexMarker634"/>the tree in such a form is not very interesting. So, let's implement a function that will summarize all the nodes of a tree if it's numeric:</p>&#13;
			<pre>fun Tree&lt;Int&gt;.sum(): Long = when (this) {</pre>&#13;
			<pre>    Empty -&gt; 0</pre>&#13;
			<pre>    is Node -&gt; value + left.sum() + right.sum()</pre>&#13;
			<pre>}</pre>&#13;
			<p>This is also <a id="_idIndexMarker635"/>called an <strong class="bold">operation</strong> on an ADT. This is an extension function that is declared only on trees that contain integers.</p>&#13;
			<p>For each node, we check whether it's <code>Empty</code> or <code>Node</code>. That's the beauty of <code>sealed</code> classes and interfaces. Since the compiler knows that the <code>Tree</code> interface has exactly two implementations, we don't need an <code>else</code> block in our <code>when</code> expression.</p>&#13;
			<p>If it's an <code>Empty</code> node, we use <code>0</code> as a neutral value. If it's not empty, then we sum its values with the left and right children. </p>&#13;
			<p>This function is also another example of a recursive algorithm, which we discussed in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>.</p>&#13;
			<p>Now, let's discuss another topic related to generics in Kotlin.</p>&#13;
			<h1 id="_idParaDest-222"><a id="_idTextAnchor228"/>Reified generics</h1>&#13;
			<p>Previously in<a id="_idIndexMarker636"/> this chapter, we mentioned <code>inline</code> functions. Since <code>inline</code> functions are copied, we can get rid of one of the major JVM limitations: <strong class="bold">type erasure</strong>. After all, inside the function, we know exactly what type we're getting.</p>&#13;
			<p>Let's look at the following example. We would like to create a generic function that will receive a <code>Number</code> (<code>Number</code> can either be <code>Int</code> or <code>Long</code>), but will only print it if it's of the same type as the function type.</p>&#13;
			<p>We'll start with a naïve implementation, simply trying the instance check on the type directly:</p>&#13;
			<pre>fun &lt;T&gt; printIfSameType(a: Number) { </pre>&#13;
			<pre>    if (<strong class="bold">a is T</strong>) { // &lt;== Error </pre>&#13;
			<pre>        println(a)    </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>However, this code won't compile and we'll get the following error: </p>&#13;
			<pre>&gt; Cannot check for instance of erased type: T</pre>&#13;
			<p>What we usually do in Java, in this case, is pass the class as an argument. We can try a similar approach in Kotlin. If you've worked with Android before, you'll recognize this pattern immediately, since it's used a lot in the standard library: </p>&#13;
			<pre>fun &lt;T : Number&gt; printIfSameType(clazz: KClass&lt;T&gt;, a: </pre>&#13;
			<pre>  Number) {</pre>&#13;
			<pre>    if (clazz.isInstance(a)) {</pre>&#13;
			<pre>        println("Yes")</pre>&#13;
			<pre>    } else {</pre>&#13;
			<pre>        println("No")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>We can check that the code works correctly by running the following lines:</p>&#13;
			<pre>printIfSameType(Int::class, 1) // Prints yes, as 1 is Int</pre>&#13;
			<pre>printIfSameType(Int::class, 2L) // Prints no, as 2 is Long</pre>&#13;
			<pre>printIfSameType(Long::class, 3L) // Prints yes, as 3 is Long</pre>&#13;
			<p>This code works but has a few downsides:</p>&#13;
			<ul>&#13;
				<li>We cannot use the <code>is</code> operator and must use the <code>isInstance()</code> function instead.</li>&#13;
				<li>We must pass the correct class; that is, <code>clazz: KClass&lt;T&gt;</code>.</li>&#13;
			</ul>&#13;
			<p>This code could <a id="_idIndexMarker637"/>be improved by using a <code>reified</code> type:</p>&#13;
			<pre>inline fun &lt;reified T : Number&gt; printIfSameReified(a:   Number) {</pre>&#13;
			<pre>    if (a is T) {</pre>&#13;
			<pre>        println("Yes")</pre>&#13;
			<pre>    } else {</pre>&#13;
			<pre>        println("No")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>This function works the same as the previous one but doesn't need a class as input to work. A function that uses a <code>reified</code> type must be declared as <code>inline</code>. This is due to type erasure on the JVM. </p>&#13;
			<p>We can test that our code still works as expected:</p>&#13;
			<pre>printIfSameReified&lt;Int&gt;(1) // Prints yes, as 1 is Int</pre>&#13;
			<pre>printIfSameReified&lt;Int&gt;(2L) // Prints no, as 2 is Long</pre>&#13;
			<pre>printIfSameReified&lt;Long&gt;(3L) // Prints yes, as 3 is Long</pre>&#13;
			<p>Notice that now, we specify the type that the function operates on, such as <code>Int</code> or <code>Long</code>, between <em class="italic">angular brackets</em>, instead of passing a class to it as an argument. We get the following benefits from using the <code>reified</code> functions:</p>&#13;
			<ul>&#13;
				<li>A clear method signature, without the need to pass a class as an argument.</li>&#13;
				<li>The ability to use the <code>is</code> construct inside the function.</li>&#13;
				<li>It's type-inference friendly, which means that if the <em class="italic">type</em> parameter can be inferred by the compiler, it can be completely omitted.</li>&#13;
			</ul>&#13;
			<p>Of course, the same rules for the regular <code>inline</code> functions apply here. This code would be replicated, so it shouldn't be too large.</p>&#13;
			<p>Now, let's<a id="_idIndexMarker638"/> consider another case for <code>reified</code> types – <strong class="bold">function overloading</strong>. We'll try<a id="_idIndexMarker639"/> to define two functions with the same name that differ only in terms of the types they operate on:</p>&#13;
			<pre>fun printList(list: List<strong class="bold">&lt;Int&gt;</strong>) { </pre>&#13;
			<pre>    println("This is a list of Ints") </pre>&#13;
			<pre>    println(list) </pre>&#13;
			<pre>} </pre>&#13;
			<pre> </pre>&#13;
			<pre>fun printList(list: List<strong class="bold">&lt;Long&gt;</strong>) { </pre>&#13;
			<pre>    println("This is a list of Longs") </pre>&#13;
			<pre>    println(list) </pre>&#13;
			<pre>}</pre>&#13;
			<p>This won't compile because there's a platform declaration clash. Both have the same signature in terms of JVM: <code>printList(list: List)</code>. This is because types are erased during compilation.</p>&#13;
			<p>But with <code>reified</code>, we can achieve this easily:</p>&#13;
			<pre>inline fun &lt;reified T : Any&gt; printList(list: List&lt;T&gt;) {</pre>&#13;
			<pre>    when {</pre>&#13;
			<pre>        1 is T -&gt; println("This is a list of Ints")</pre>&#13;
			<pre>        1L is T -&gt; println("This is a list of Longs")</pre>&#13;
			<pre>        else -&gt; println("This is a list of something else")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    println(list)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Since the entire function is <em class="italic">inlined</em>, we can check the actual type of the list and output the correct<a id="_idIndexMarker640"/> result.</p>&#13;
			<h1 id="_idParaDest-223"><a id="_idTextAnchor229"/>Using constants efficiently</h1>&#13;
			<p>Since everything<a id="_idIndexMarker641"/> in Java is an object (unless it's a primitive type), we're used to putting all the constants inside our objects as static members.</p>&#13;
			<p>And since Kotlin has <code>companion</code> objects, we usually try putting them there:</p>&#13;
			<pre>class Spock {</pre>&#13;
			<pre>    companion object {</pre>&#13;
			<pre>        val SENSE_OF_HUMOR = "None"</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>This will work, but you should remember that <code>companion object</code> is an object, after all.</p>&#13;
			<p>So, this will be translated into the following code, more or less:</p>&#13;
			<pre>public class Spock {</pre>&#13;
			<pre>    private static final String SENSE_OF_HUMOR = "None";</pre>&#13;
			<pre> </pre>&#13;
			<pre>    public String getSENSE_OF_HUMOR() {</pre>&#13;
			<pre>        return Spock.SENSE_OF_HUMOR;</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>In this example, the Kotlin compiler generates a getter for our constant, which adds another level of indirection.</p>&#13;
			<p>If we look at the code using the constant, we'll see the following:</p>&#13;
			<pre>String var0 = Spock.Companion.getSENSE_OF_HUMOR();</pre>&#13;
			<pre>System.out.println(var0);</pre>&#13;
			<p>We can invoke <a id="_idIndexMarker642"/>a method to get the constant value, which is not very efficient. </p>&#13;
			<p>Now, let's mark this value as constant and see how the code produced by the compiler changes:</p>&#13;
			<pre>class Spock { </pre>&#13;
			<pre>    companion object { </pre>&#13;
			<pre>        <strong class="bold">const </strong>val SENSE_OF_HUMOR = "None" </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>Here are the bytecode changes:</p>&#13;
			<pre>public class Spock { </pre>&#13;
			<pre>   public static final String SENSE_OF_HUMOR = "None"; </pre>&#13;
			<pre>   ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>And here is the call:</p>&#13;
			<pre>String var1 = "None"; </pre>&#13;
			<pre>System.out.println(var1);</pre>&#13;
			<p>Notice that there's no reference for our <code>Spock</code> class in the code anymore. The compiler has already <em class="italic">inlined</em> its value for us. After all, it's constant, so it will never change and can be safely <em class="italic">inlined</em>. </p>&#13;
			<p>If all you need is a constant, you can also set it up outside of any class:</p>&#13;
			<pre>const val SPOCK_SENSE_OF_HUMOR = "NONE"</pre>&#13;
			<p>And if you need namespacing, you can wrap it in an object:</p>&#13;
			<pre>object SensesOfHumor { </pre>&#13;
			<pre>    const val SPOCK = "None" </pre>&#13;
			<pre>}</pre>&#13;
			<p>Now that we've <a id="_idIndexMarker643"/>learned how to use constants more efficiently, let's learn how to work with constructors in an idiomatic manner.</p>&#13;
			<h1 id="_idParaDest-224"><a id="_idTextAnchor230"/>Constructor overload</h1>&#13;
			<p>In Java, we're <a id="_idIndexMarker644"/>used to having overloaded constructors. For example, let's look at the following Java class, which requires the <code>a</code> parameter and defaults the value of <code>b</code> to <code>1</code>:</p>&#13;
			<pre>class User { </pre>&#13;
			<pre>    private final String name; </pre>&#13;
			<pre>    private final boolean resetPassword; </pre>&#13;
			<pre>    public User(String name) { </pre>&#13;
			<pre>        this(name, true); </pre>&#13;
			<pre>    } </pre>&#13;
			<pre> </pre>&#13;
			<pre>    public User(String name, boolean resetPassword) { </pre>&#13;
			<pre>        this.name = name; </pre>&#13;
			<pre>        this.resetPassword = resetPassword; </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>We can simulate the same behavior in Kotlin by defining multiple constructors using the <code>constructor</code> keyword:</p>&#13;
			<pre>class User(val name: String, val resetPassword: Boolean) {</pre>&#13;
			<pre>    constructor(name: String) : this(name, true)</pre>&#13;
			<pre>}</pre>&#13;
			<p>The secondary constructor, as defined in the class body, will invoke the primary constructor, providing <code>1</code> as the default value for the second argument.</p>&#13;
			<p>However, it's usually better to have default parameter values and named arguments instead:</p>&#13;
			<pre>class User(val name: String, val resetPassword: Boolean =   true)</pre>&#13;
			<p>Note that all the<a id="_idIndexMarker645"/> secondary constructors must delegate to the primary constructor using the <code>this</code> keyword. The only exception is when you have a default primary constructor:</p>&#13;
			<pre>class User {</pre>&#13;
			<pre>    val resetPassword: Boolean</pre>&#13;
			<pre>    val name: String</pre>&#13;
			<pre> </pre>&#13;
			<pre>    constructor(name: String, resetPassword: Boolean = </pre>&#13;
			<pre>      true) {</pre>&#13;
			<pre>        this.name = name</pre>&#13;
			<pre>        this.resetPassword = resetPassword</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Next, let's discuss how to efficiently handle nulls in Kotlin code.</p>&#13;
			<h1 id="_idParaDest-225"><a id="_idTextAnchor231"/>Dealing with nulls</h1>&#13;
			<p><code>null</code> in Kotlin; for example: </p>&#13;
			<pre>// Will return "String" half of the time and null the other </pre>&#13;
			<pre>// half </pre>&#13;
			<pre>val stringOrNull: String? = if (Random.nextBoolean()) </pre>&#13;
			<pre>  "String" else null  </pre>&#13;
			<pre> </pre>&#13;
			<pre>// Java-way check </pre>&#13;
			<pre>if (stringOrNull != null) { </pre>&#13;
			<pre>    println(stringOrNull.length) </pre>&#13;
			<pre>}</pre>&#13;
			<p>We could rewrite this code using the <code>Elvis</code> operator (<code>?:</code>):</p>&#13;
			<pre>val alwaysLength = stringOrNull?.length <strong class="bold">?:</strong> 0 </pre>&#13;
			<p>If the length is not <code>null</code>, this operator will return its value. Otherwise, it will return the default value we supplied, which is <code>0</code> in this case.</p>&#13;
			<p>If you have a nested object, you can chain those checks. For example, let's have a <code>Response</code> object that contains a <code>Profile</code>, which, in turn, contains the first name and last name fields, which can be nullable:</p>&#13;
			<pre>data class Response(</pre>&#13;
			<pre>    val profile: UserProfile?</pre>&#13;
			<pre>)</pre>&#13;
			<pre> </pre>&#13;
			<pre>data class UserProfile(</pre>&#13;
			<pre>    val firstName: String?,</pre>&#13;
			<pre>    val lastName: String?</pre>&#13;
			<pre>)</pre>&#13;
			<p>This chaining will look like this:</p>&#13;
			<pre>val response: Response? = Response(UserProfile(null, null))</pre>&#13;
			<pre>println(response?.profile?.firstName?.length)</pre>&#13;
			<p>If any of the fields in the chain are null, our code won't crash. Instead, it will print <code>null</code>.</p>&#13;
			<p>Finally, you can use the <code>let()</code> block for null checks, as we briefly mentioned in the <em class="italic">Using the scope functions</em> section. The same code, but using the <code>let()</code> function instead, will <a id="_idIndexMarker647"/>look like this:</p>&#13;
			<pre>println(response?.let { </pre>&#13;
			<pre>    it.profile?.let { </pre>&#13;
			<pre>        it.firstName?.length </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>})</pre>&#13;
			<p>If you want to get rid of <code>it</code> everywhere, you can use another scoping function, <code>run()</code>:</p>&#13;
			<pre>println(response?.run { </pre>&#13;
			<pre>    profile?.run { </pre>&#13;
			<pre>        firstName?.length </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>})</pre>&#13;
			<p>Try to avoid using the unsafe <code>!!</code> null operator in production code:</p>&#13;
			<pre>println(json!!.User!!.firstName!!.length)</pre>&#13;
			<p>This will result in <code>KotlinNullPointerException</code>. However, during tests, the <code>!!</code> operator may prove useful, as it will help you spot null-safety issues faster. </p>&#13;
			<h1 id="_idParaDest-226"><a id="_idTextAnchor232"/>Making asynchronicity explicit</h1>&#13;
			<p>As you saw<a id="_idIndexMarker648"/> in the previous chapter, it is very easy to create an asynchronous function in Kotlin. Here is an example:</p>&#13;
			<pre>fun CoroutineScope.getResult() = async { </pre>&#13;
			<pre>   delay(100) </pre>&#13;
			<pre>   "OK" </pre>&#13;
			<pre>}</pre>&#13;
			<p>However, this asynchronicity may be an unexpected behavior for the user of the function, as they may expect a simple value. </p>&#13;
			<p><em class="italic">What do you think the following code prints?</em></p>&#13;
			<pre>println("${getResult()}")</pre>&#13;
			<p>For the user, the preceding code somewhat unexpectedly prints the following instead of <code>"OK"</code>:</p>&#13;
			<pre>&gt; Name: DeferredCoroutine{Active}@...</pre>&#13;
			<p>Of course, if you have read <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>, you will know that what's missing here is the <code>await()</code> function:</p>&#13;
			<pre>println("${getResult().await()}")</pre>&#13;
			<p>But it would have been a lot more obvious if we'd named our function accordingly, by adding an <code>async</code> suffix:</p>&#13;
			<pre>fun CoroutineScope.getResultAsync() = async { </pre>&#13;
			<pre>   delay(100) </pre>&#13;
			<pre>   "OK" </pre>&#13;
			<pre>}</pre>&#13;
			<p>Kotlin's convention is to distinguish asynchronous functions from regular ones by adding <code>Async</code> to the end of the function's name. If you're working with <strong class="bold">IntelliJ IDEA</strong>, it will even suggest you that rename it. </p>&#13;
			<p>Now, let's talk about some built-in functions for validating the user's input.</p>&#13;
			<h1 id="_idParaDest-227"><a id="_idTextAnchor233"/>Validating input</h1>&#13;
			<p>Input validation is <a id="_idIndexMarker649"/>a necessary but very tedious task. <em class="italic">How many times did you have to write code like the following?</em></p>&#13;
			<pre>fun setCapacity(cap: Int) { </pre>&#13;
			<pre>    if (cap &lt; 0) { </pre>&#13;
			<pre>        throw IllegalArgumentException() </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>    ... </pre>&#13;
			<pre>}</pre>&#13;
			<p>Instead, you can check arguments with the <code>require()</code> function:</p>&#13;
			<pre>fun setCapacity(cap: Int) { </pre>&#13;
			<pre>    require(cap &gt; 0) </pre>&#13;
			<pre>}</pre>&#13;
			<p>This makes the code a lot more fluent. You can use <code>require()</code> to check for nulls:</p>&#13;
			<pre>fun printNameLength(p: Profile) { </pre>&#13;
			<pre>    require(p.firstName != null) </pre>&#13;
			<pre>}</pre>&#13;
			<p>But there's also <code>requireNotNull()</code> for that:</p>&#13;
			<pre>fun printNameLength(p: Profile) { </pre>&#13;
			<pre>    requireNotNull(p.firstName) </pre>&#13;
			<pre>}</pre>&#13;
			<p>Use <code>check()</code> to validate the state of your object. This is useful when you are providing an object that the user may not have set up correctly:</p>&#13;
			<pre>class HttpClient { </pre>&#13;
			<pre>    var body: String? = null </pre>&#13;
			<pre>    var url: String = "" </pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun postRequest() { </pre>&#13;
			<pre>        check(body != null) { </pre>&#13;
			<pre>            "Body must be set in POST requests" </pre>&#13;
			<pre>        } </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>And again, there's a shortcut for this as well: <code>checkNotNull()</code>.</p>&#13;
			<p>The difference between the <code>require()</code> and <code>check()</code> functions is that <code>require()</code> throws <code>IllegalArgumentException</code>, implying that the input that was provided to the function was incorrect. On the other hand, <code>check()</code> throws <code>IllegalStateException</code>, which means that the state of the object is corrupted. </p>&#13;
			<p>Consider using <a id="_idIndexMarker650"/>functions such as <code>require()</code> and <code>check()</code> to improve the readability of your code.</p>&#13;
			<p>Finally, let's discuss how to efficiently represent different states in Kotlin.</p>&#13;
			<h1 id="_idParaDest-228"><a id="_idTextAnchor234"/>Preferring sealed classes over enums</h1>&#13;
			<p>Coming from<a id="_idIndexMarker651"/> Java, you may be tempted to overload your <code>enum</code> with functionality.</p>&#13;
			<p>For example, let's say you build an application that allows users to order a pizza and track its status. We can use the following code for this:</p>&#13;
			<pre>// Java-like code that uses enum to represent State</pre>&#13;
			<pre>enum class PizzaOrderStatus {</pre>&#13;
			<pre>    ORDER_RECEIVED, PIZZA_BEING_MADE, OUT_FOR_DELIVERY,      COMPLETED;</pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun nextStatus(): PizzaOrderStatus {</pre>&#13;
			<pre>        return when (this) {</pre>&#13;
			<pre>            ORDER_RECEIVED -&gt; PIZZA_BEING_MADE</pre>&#13;
			<pre>            PIZZA_BEING_MADE -&gt; OUT_FOR_DELIVERY</pre>&#13;
			<pre>            OUT_FOR_DELIVERY -&gt; COMPLETED</pre>&#13;
			<pre>            COMPLETED -&gt; COMPLETED</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Alternatively, you <a id="_idIndexMarker652"/>can use the <code>sealed</code> class:</p>&#13;
			<pre>sealed class PizzaOrderStatus(protected val orderId: Int) {</pre>&#13;
			<pre>    abstract fun nextStatus(): PizzaOrderStatus</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>class OrderReceived(orderId: Int) : </pre>&#13;
			<pre>  PizzaOrderStatus(orderId) {</pre>&#13;
			<pre>    override fun nextStatus() = PizzaBeingMade(orderId)</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>class PizzaBeingMade(orderId: Int) : </pre>&#13;
			<pre>  PizzaOrderStatus(orderId) {</pre>&#13;
			<pre>    override fun nextStatus() = OutForDelivery(orderId)</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>class OutForDelivery(orderId: Int) : </pre>&#13;
			<pre>  PizzaOrderStatus(orderId) {</pre>&#13;
			<pre>    override fun nextStatus() = Completed(orderId)</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>class Completed(orderId: Int) : PizzaOrderStatus(orderId) {</pre>&#13;
			<pre>    override fun nextStatus() = this</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we created a separate class for each object state, extending the <code>PizzaOrderStatus</code> sealed class.</p>&#13;
			<p>The benefit of this approach is that we can now store the state, along with its <code>status</code>, more easily. In <a id="_idIndexMarker653"/>our example, we can store the ID of the order:</p>&#13;
			<pre>var status: PizzaOrderStatus = OrderReceived(123) </pre>&#13;
			<pre> </pre>&#13;
			<pre>while (status !is Completed) { </pre>&#13;
			<pre>    status = when (status) { </pre>&#13;
			<pre>        is OrderReceived -&gt; status.nextStatus() </pre>&#13;
			<pre>        is PizzaBeingMade -&gt; status.nextStatus() </pre>&#13;
			<pre>        is OutForDelivery -&gt; status.nextStatus() </pre>&#13;
			<pre>        is Completed -&gt; status </pre>&#13;
			<pre>    } </pre>&#13;
			<pre>}</pre>&#13;
			<p>In general, <code>sealed</code> classes are good if you want to have data associated with a state, and you should prefer them over enums. </p>&#13;
			<h1 id="_idParaDest-229"><a id="_idTextAnchor235"/>Summary</h1>&#13;
			<p>In this chapter, we reviewed the best practices in Kotlin, as well as some of the caveats of the language. Now, you should be able to write more idiomatic code that is also performant and maintainable.</p>&#13;
			<p>You should make use of the scoping functions where necessary, but make sure not to overuse them as they may make the code confusing, especially for those newer to the language.</p>&#13;
			<p>Be sure to handle nulls and type casts correctly, with <code>let()</code>, the <code>Elvis</code> operator, and the smart casts that the language provides. Finally, generics and <code>sealed</code> classes and interfaces are powerful tools that help describe complex relationships and behaviors between different classes.</p>&#13;
			<p>In the next chapter, we'll put those skills to use by writing a real-life microservice Reactive design pattern.</p>&#13;
			<h1 id="_idParaDest-230"><a id="_idTextAnchor236"/>Questions</h1>&#13;
			<ol>&#13;
				<li>What is the alternative to Java's try-with-resources in Kotlin?</li>&#13;
				<li>What are the different options for handling nulls in Kotlin?</li>&#13;
				<li>Which problem can be solved by reified generics?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>