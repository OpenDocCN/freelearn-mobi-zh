<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer022">&#13;
			<h1 id="_idParaDest-210"><em class="italic"><a id="_idTextAnchor216"/>Chapter 9</em>: Idioms and Anti-Patterns</h1>&#13;
			<p>In the previous chapters, we discussed the different aspects of the Kotlin programming language, the benefits of functional programming, and concurrent design patterns.</p>&#13;
			<p>This chapter discusses the best and worst practices in Kotlin. You'll learn what idiomatic Kotlin code should look like and which patterns to avoid. This chapter contains a collection of best practices spanning those different topics.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Using the scope functions</li>&#13;
				<li>Type checks and casts</li>&#13;
				<li>An alternative to the try-with-resources statement</li>&#13;
				<li>Inline functions</li>&#13;
				<li>Implementing algebraic data types</li>&#13;
				<li>Reified generics</li>&#13;
				<li>Using constants efficiently</li>&#13;
				<li>Constructor overload</li>&#13;
				<li>Dealing with nulls</li>&#13;
				<li>Making asynchronicity explicit</li>&#13;
				<li>Validating input</li>&#13;
				<li>Preferring sealed classes over enums</li>&#13;
			</ul>&#13;
			<p>After completing this chapter, you should be able to write more readable and maintainable Kotlin code, as well as avoid some common pitfalls. </p>&#13;
			<h1 id="_idParaDest-211"><a id="_idTextAnchor217"/>Technical requirements</h1>&#13;
			<p>In addition to the requirements from the previous chapters, you will also need a <strong class="bold">Gradle</strong>-enabled <strong class="bold">Kotlin</strong> project to be able to add the required dependencies.</p>&#13;
			<p>You can find the source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter09</a>.</p>&#13;
			<h1 id="_idParaDest-212"><a id="_idTextAnchor218"/>Using the scope functions</h1>&#13;
			<p>Kotlin has<a id="_idIndexMarker601"/> the concept of <strong class="bold">scoping functions</strong>, which are available on any object and can replace the need to write repetitive code. Among other benefits, these scoping functions help us simplify single-expression functions. They are considered higher-order functions since each scoping function receives a lambda expression as an argument. In this section, we'll discuss all the necessary functions and execute their code blocks using objects as their <em class="italic">scope</em>. In this section, we'll use the terms <em class="italic">scope</em> and <em class="italic">context object</em> interchangeably to describe the objects that those functions operate on. </p>&#13;
			<h2 id="_idParaDest-213"><a id="_idTextAnchor219"/>Let function</h2>&#13;
			<p>We can<a id="_idIndexMarker602"/> use <a id="_idIndexMarker603"/>the <strong class="source-inline">let()</strong> function to invoke a function on a nullable object, but only if the object is not null.</p>&#13;
			<p>Let's take, as an example, the following map of quotes (we discussed this in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>):</p>&#13;
			<p class="source-code">val clintEastwoodQuotes = mapOf(</p>&#13;
			<p class="source-code">    "The Good, The Bad, The Ugly" to "Every gun makes its       own tune.",</p>&#13;
			<p class="source-code">    "A Fistful Of Dollars" to "My mistake: four coffins."</p>&#13;
			<p class="source-code">)</p>&#13;
			<p>Now, let's fetch a quote from a movie that may not exist in the collection and print it, but only if it's not null:</p>&#13;
			<p class="source-code">val quote = clintEastwoodQuotes["Unforgiven"]</p>&#13;
			<p class="source-code">if (quote != null) {</p>&#13;
			<p class="source-code">    println(quote)</p>&#13;
			<p class="source-code">} </p>&#13;
			<p>The same code can we rewritten using the <strong class="source-inline">let</strong> scoping function:</p>&#13;
			<p class="source-code">clintEastwoodQuotes["Unforgiven"]?.let {</p>&#13;
			<p class="source-code">    println(it)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>One common mistake is forgetting to use the safe navigation operator before <strong class="source-inline">let</strong>, because <strong class="source-inline">let()</strong> by itself also works on nulls:</p>&#13;
			<p class="source-code">clintEastwoodQuotes["Unforgiven"].let {</p>&#13;
			<p class="source-code">    println(it)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This code<a id="_idIndexMarker604"/> will print <strong class="source-inline">null</strong> to the console. Make sure that you don't forget <a id="_idIndexMarker605"/>the question mark (<strong class="source-inline">?</strong>) when you use <strong class="source-inline">let()</strong> for null checks.</p>&#13;
			<h2 id="_idParaDest-214"><a id="_idTextAnchor220"/>Apply function</h2>&#13;
			<p>We <a id="_idIndexMarker606"/>have <a id="_idIndexMarker607"/>discussed <strong class="source-inline">apply()</strong> in previous chapters. It returns the same object it operates on and sets the context to <strong class="source-inline">this</strong>. You can use <strong class="source-inline">apply()</strong> if you need to initialize a mutable object.</p>&#13;
			<p>Think of how many times you had to create a class that has an empty constructor, and then call a lot of setters, one after another. Let's look at the following class as an example. This may be a class that comes from a library, for example:</p>&#13;
			<p class="source-code">class JamesBond { </p>&#13;
			<p class="source-code">    lateinit var name: String </p>&#13;
			<p class="source-code">    lateinit var movie: String </p>&#13;
			<p class="source-code">    lateinit var alsoStarring: String </p>&#13;
			<p class="source-code">} </p>&#13;
			<p>When we need to create a new instance of such a class, we could do so in a procedural manner: </p>&#13;
			<p class="source-code">val agent = JamesBond() </p>&#13;
			<p class="source-code">agent.name = "Sean Connery" </p>&#13;
			<p class="source-code">agent.movie = "Dr. No"</p>&#13;
			<p>Alternatively, we can only set <strong class="source-inline">name</strong> and <strong class="source-inline">movie</strong>, and leave <strong class="source-inline">alsoStarring</strong> blank, using the <strong class="source-inline">apply()</strong> function:</p>&#13;
			<p class="source-code">val `007` = JamesBond().apply { </p>&#13;
			<p class="source-code">    this.name = "Sean Connery" </p>&#13;
			<p class="source-code">    this.movie = "Dr. No" </p>&#13;
			<p class="source-code">} </p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">println(`007`.name)</p>&#13;
			<p>Since the<a id="_idIndexMarker608"/> context<a id="_idIndexMarker609"/> of the block is set to <strong class="source-inline">this</strong>, we can simplify the preceding code even further:</p>&#13;
			<p class="source-code">val `007` = JamesBond().apply { </p>&#13;
			<p class="source-code">    name = "Sean Connery" </p>&#13;
			<p class="source-code">    movie = "Dr. No" </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Using the <strong class="source-inline">apply()</strong> function is especially good when you're working with Java classes that usually have a lot of setters and a default empty constructor.</p>&#13;
			<h2 id="_idParaDest-215"><a id="_idTextAnchor221"/>Also function</h2>&#13;
			<p>As we <a id="_idIndexMarker610"/>mentioned in<a id="_idIndexMarker611"/> the introduction to this section, single-expression functions are very nice and concise. Let's look at the following simple function, which multiplies two numbers:</p>&#13;
			<p class="source-code">fun multiply(a: Int, b: Int): Int = a * b</p>&#13;
			<p>But often, you have a single-statement function that also needs to, for example, write to a log or have another side effect. To achieve this, we could rewrite our function in the following way:</p>&#13;
			<p class="source-code">fun multiply(a: Int, b: Int): Int { </p>&#13;
			<p class="source-code">    val c = a * b </p>&#13;
			<p class="source-code">    println(c) </p>&#13;
			<p class="source-code">    return c </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We had to make our function much more verbose here and introduce another variable. Let's see how we can use the <strong class="source-inline">also()</strong> function instead:</p>&#13;
			<p class="source-code">fun multiply(a: Int, b: Int): Int = </p>&#13;
			<p class="source-code">    (a * b)<strong class="bold">.also { println(it) }</strong></p>&#13;
			<p>This function<a id="_idIndexMarker612"/> will assign the results of the expression to <strong class="source-inline">it</strong> and <a id="_idIndexMarker613"/>return the result of the expression. The <strong class="source-inline">also()</strong> function is also useful when you want to have a side effect on a chain of calls:</p>&#13;
			<p class="source-code">val l = (1..100).toList() </p>&#13;
			<p class="source-code">l.filter{ it % 2 == 0 } </p>&#13;
			<p class="source-code">    // Prints, but doesn't mutate the collection</p>&#13;
			<p class="source-code">    .also { println(it) }     </p>&#13;
			<p class="source-code">    .map { it * it }</p>&#13;
			<p>Here, you can see that we can continue our chain of calls with a <strong class="source-inline">map()</strong> function, even though we used the <strong class="source-inline">also()</strong> function to print each element of a list.</p>&#13;
			<h2 id="_idParaDest-216"><a id="_idTextAnchor222"/>Run function</h2>&#13;
			<p>The <strong class="source-inline">run()</strong> function <a id="_idIndexMarker614"/>is very <a id="_idIndexMarker615"/>similar to the <strong class="source-inline">let()</strong> function, but it sets the context of the block to <strong class="source-inline">this</strong> instead of using <strong class="source-inline">it</strong>.</p>&#13;
			<p>Let's look at an example to understand this better:</p>&#13;
			<p class="source-code">val justAString = "string" </p>&#13;
			<p class="source-code">val n = justAString.run {  </p>&#13;
			<p class="source-code">    this.length </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In this example, <strong class="source-inline">this</strong> is set to reference the <strong class="source-inline">justAString</strong> variable.</p>&#13;
			<p>Usually, <strong class="source-inline">this</strong> could be omitted, so the code will look as follows:</p>&#13;
			<p class="source-code">val n = justAString.run {  </p>&#13;
			<p class="source-code">    length </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The <strong class="source-inline">run()</strong> function is mostly useful when you plan to initialize an object, much like the <strong class="source-inline">apply()</strong> function we discussed earlier. However, instead of returning the object itself, like <strong class="source-inline">apply()</strong> does, you<a id="_idIndexMarker616"/> usually like to return the result of some<a id="_idIndexMarker617"/> computation:</p>&#13;
			<p class="source-code">val lowerCaseName = JamesBond().run {</p>&#13;
			<p class="source-code">    name = "ROGER MOORE"</p>&#13;
			<p class="source-code">    movie = "THE MAN WITH THE GOLDEN GUN"</p>&#13;
			<p class="source-code">    name.toLowerCase() // &lt;= Not JamesBond type</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">println(lowerCaseName)</p>&#13;
			<p>The preceding code prints the following output:</p>&#13;
			<p class="source-code">&gt; roger moore</p>&#13;
			<p>Here, the object was initialized with <strong class="source-inline">"ROGER MOORE"</strong>. Note that here, we operated on the <strong class="source-inline">JamesBond</strong> object, but<a id="_idIndexMarker618"/> our return value was a <strong class="source-inline">String</strong>. </p>&#13;
			<h2 id="_idParaDest-217"><a id="_idTextAnchor223"/>With function</h2>&#13;
			<p>Unlike the<a id="_idIndexMarker619"/> other four scoping functions, <strong class="source-inline">with()</strong> is not an <a id="_idIndexMarker620"/>extension function. This means you cannot do the following:</p>&#13;
			<p class="source-code">"scope".with { ... }</p>&#13;
			<p>Instead, <strong class="source-inline">with()</strong> receives the object you want to scope as an argument:</p>&#13;
			<p class="source-code">with("scope") { </p>&#13;
			<p class="source-code">    println(this.length) // "this" set to the argument of                          // with() </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>And as usual, we can omit <strong class="source-inline">this</strong>:</p>&#13;
			<p class="source-code">with("scope") { </p>&#13;
			<p class="source-code">    length </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Just like <strong class="source-inline">run()</strong> and <strong class="source-inline">let()</strong>, you can return any result from <strong class="source-inline">with()</strong>.</p>&#13;
			<p>In this section, we learned how the various scope functions can help reduce the amount of boilerplate code by defining a code block to be executed on the object. In the next section, we'll see how Kotlin also allows us to write fewer instance checks than other languages.</p>&#13;
			<h1 id="_idParaDest-218"><a id="_idTextAnchor224"/>Type checks and casts</h1>&#13;
			<p>While writing <a id="_idIndexMarker621"/>your code, you may often be inclined to check what type your object is using, <strong class="source-inline">is</strong>, and cast it using <strong class="source-inline">as</strong>. As an example, let's imagine we're building a system for superheroes. Each superhero has their own set of methods:</p>&#13;
			<p class="source-code">interface Superhero </p>&#13;
			<p class="source-code">class Batman : Superhero { </p>&#13;
			<p class="source-code">    fun callRobin() { </p>&#13;
			<p class="source-code">        println("To the Bat-pole, Robin!") </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">} </p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">class Superman : Superhero { </p>&#13;
			<p class="source-code">    fun fly() { </p>&#13;
			<p class="source-code">        println("Up, up and away!") </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">} </p>&#13;
			<p>There's also a <a id="_idIndexMarker622"/>function where a superhero tries to invoke their superpower:</p>&#13;
			<p class="source-code">fun doCoolStuff(s: Superhero) { </p>&#13;
			<p class="source-code">    if (s is Superman) { </p>&#13;
			<p class="source-code">        (s as Superman).fly() </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">    else if (s is Batman) { </p>&#13;
			<p class="source-code">        (a as Batman).callRobin() </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>But as you may know, Kotlin has smart casts, so implicit casting, in this case, is not needed. Let's rewrite this function using smart casts and see how they improve our code. All we need to do is remove the explicit casts from our code:</p>&#13;
			<p class="source-code">fun doCoolStuff(s: Superhero) { </p>&#13;
			<p class="source-code">    if (s is Superman) { </p>&#13;
			<p class="source-code">        s.fly() </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">    else if (s is Batman) { </p>&#13;
			<p class="source-code">        s.callRobin() </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Moreover, in most cases, using <strong class="source-inline">when()</strong> while smart casting produces cleaner code:</p>&#13;
			<p class="source-code">fun doCoolStuff(s : Superhero) { </p>&#13;
			<p class="source-code">    when(s) { </p>&#13;
			<p class="source-code">        is Superman -&gt; s.fly() </p>&#13;
			<p class="source-code">        is Batman -&gt; s.callRobin() </p>&#13;
			<p class="source-code">        else -&gt; println("Unknown superhero") </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>As a rule of thumb, you should avoid using casts and rely on smart casts most of the time:</p>&#13;
			<p class="source-code">// Superhero is clearly not a string </p>&#13;
			<p class="source-code">val superheroAsString = (s as String)</p>&#13;
			<p>But if you absolutely must, there's also a safe cast operator:</p>&#13;
			<p class="source-code">val superheroAsString = (s as? String)</p>&#13;
			<p>The <strong class="bold">safe cast operator</strong> will <a id="_idIndexMarker623"/>return null if the object cannot be cast, instead of throwing an exception. </p>&#13;
			<h1 id="_idParaDest-219"><a id="_idTextAnchor225"/>An alternative to the try-with-resources statement</h1>&#13;
			<p><strong class="bold">Java 7</strong> added <a id="_idIndexMarker624"/>the notion of <strong class="source-inline">AutoCloseable</strong> and the try-with-resources statement.</p>&#13;
			<p>This statement allows us to provide a set of resources that will be automatically closed once the code is done with them. So, there will be no more risk (or at least less risk) of forgetting to close a file.</p>&#13;
			<p>Before Java 7, this was a total mess, as shown in the following code:</p>&#13;
			<p class="source-code">BufferedReader br = null; // Nulls are bad, we know that </p>&#13;
			<p class="source-code">try { </p>&#13;
			<p class="source-code">    br = new BufferedReader(new FileReader</p>&#13;
			<p class="source-code">      ("./src/main/kotlin/7_TryWithResource.kt "));</p>&#13;
			<p class="source-code">    System.out.println(br.readLine());</p>&#13;
			<p class="source-code">} </p>&#13;
			<p class="source-code">finally { </p>&#13;
			<p class="source-code">    if (br != null) { // Explicit check </p>&#13;
			<p class="source-code">        br.close(); // Boilerplate </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>After <strong class="bold">Java 7</strong> was<a id="_idIndexMarker625"/> released, the preceding code could be written as follows:</p>&#13;
			<p class="source-code">try (BufferedReader br = new BufferedReader(new   FileReader("/some/path"))) { </p>&#13;
			<p class="source-code">    System.out.println(br.readLine()); </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Kotlin doesn't support this syntax. Instead, the try-with-resource statement is replaced with the <strong class="source-inline">use()</strong> function:</p>&#13;
			<p class="source-code">val br = BufferedReader(FileReader("./src/main   /kotlin/7_TryWithResource.kt"))</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">br.use {</p>&#13;
			<p class="source-code">    println(it.readLines())</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>An object must implement the <strong class="source-inline">Closeable</strong> interface for the <strong class="source-inline">use()</strong> function to be available. The <strong class="source-inline">Closeable</strong> object <a id="_idIndexMarker626"/>will be closed as soon as we exit the <strong class="source-inline">use{}</strong> block.</p>&#13;
			<h1 id="_idParaDest-220"><a id="_idTextAnchor226"/>Inline functions</h1>&#13;
			<p>You can<a id="_idIndexMarker627"/> think of <strong class="source-inline">inline</strong> functions as instructions for the compiler to copy and paste your code. Each time the compiler sees a call to a function marked with the <strong class="source-inline">inline</strong> keyword, it will replace the call with the concrete function body.</p>&#13;
			<p>It makes sense to use the <strong class="source-inline">inline</strong> function if it's a higher-order function that receives a lambda as one of its arguments. This is the most common use case where you would like to use <strong class="source-inline">inline</strong>.</p>&#13;
			<p>Let's look at such a higher-order function and see what pseudocode the compiler will output.</p>&#13;
			<p>First, here is the function definition:</p>&#13;
			<p class="source-code">inline fun logBeforeAfter(block: () -&gt; String) { </p>&#13;
			<p class="source-code">    println("Before") </p>&#13;
			<p class="source-code">    println(block()) </p>&#13;
			<p class="source-code">    println("After") </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we pass a lambda, or a <strong class="source-inline">block</strong>, to our function. This <strong class="source-inline">block</strong> simply returns the word <strong class="source-inline">"Inlining"</strong> as a <strong class="source-inline">String</strong>:</p>&#13;
			<p class="source-code">logBeforeAfter { </p>&#13;
			<p class="source-code">    "Inlining" </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If you were to view the Java equivalent of the decompiled bytecode, you'd see that there's no call to our <strong class="source-inline">makesSense</strong> function at all. Instead, you'd see the following:</p>&#13;
			<p class="source-code">String var1 = "Before"; &lt;- Inline function call </p>&#13;
			<p class="source-code">System.out.println(var1); </p>&#13;
			<p class="source-code">var1 = "Inlining"; </p>&#13;
			<p class="source-code">System.out.println(var1); </p>&#13;
			<p class="source-code">var1 = "After"; </p>&#13;
			<p class="source-code">System.out.println(var1); </p>&#13;
			<p>Since the <strong class="source-inline">inline</strong> function is a copy/paste of your code, you shouldn't use it if you have more than a few lines of code. It would be more efficient to have it as a regular function. But if you have single-expression functions that receive a lambda, it makes sense to mark them with the <strong class="source-inline">inline</strong> keyword to optimize performance. In the end, it's a trade-off <a id="_idIndexMarker628"/>between the size of your application and its performance. </p>&#13;
			<h1 id="_idParaDest-221"><a id="_idTextAnchor227"/>Implementing Algebraic Data Types</h1>&#13;
			<p><strong class="bold">Algebraic Data Types</strong>, or <strong class="bold">ATDs</strong> for short, is <a id="_idIndexMarker629"/>a concept from functional programming and is very similar to the <strong class="bold">Composite design pattern</strong> we <a id="_idIndexMarker630"/>discussed in <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>.</p>&#13;
			<p>To understand how ADTs work and what their benefits are, let's discuss how we can implement a simple binary tree in Kotlin.</p>&#13;
			<p>First, let's declare an interface for our tree. Since a tree data structure can contain any type of data, we can parameterize it with a type (<strong class="source-inline">T</strong>):</p>&#13;
			<p class="source-code">sealed interface Tree&lt;out T&gt;</p>&#13;
			<p>The type is marked with an <strong class="source-inline">out</strong> keyword, which means that this type is <em class="italic">covariant</em>. If you aren't familiar with this term, we'll cover it later, while implementing the interface.</p>&#13;
			<p>The opposite of a covariant is a <em class="italic">contravariant</em>. Contravariant types should be marked using the <strong class="source-inline">in</strong> keyword.</p>&#13;
			<p>We can also mark this interface with a <strong class="source-inline">sealed</strong> keyword. We saw this keyword applied to regular classes in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, while discussing the <strong class="bold">Visitor pattern</strong>. But <strong class="source-inline">sealed</strong> interfaces are a relatively new feature and were introduced in <strong class="bold">Kotlin 1.5</strong>.</p>&#13;
			<p>The meaning is the same, though: only the owner of the interface can implement it. This means that all the implementations of the interface are known at compile time. </p>&#13;
			<p>Next, let's declare what an empty tree looks like:</p>&#13;
			<p class="source-code">object Empty : Tree&lt;Nothing&gt; {</p>&#13;
			<p class="source-code">    override fun toString() = "Empty"</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Since all empty trees are the same, we declare it as an object. This is another use of the <strong class="bold">Singleton design pattern</strong>, which <a id="_idIndexMarker631"/>we discussed in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>. We can also use <strong class="source-inline">Nothing</strong> as the type of an empty tree. This is a special class in Kotlin's object hierarchy. </p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">There is some<a id="_idIndexMarker632"/> confusion between <strong class="source-inline">Any</strong>, which represents any class and is similar to <strong class="source-inline">Object</strong> in Java, and <strong class="source-inline">Nothing</strong>, which represents no class. We'll see why <strong class="source-inline">Any</strong> wouldn't work in this case later in this chapter.</p>&#13;
			<p>Next, let's define a non-empty node of a tree:</p>&#13;
			<p class="source-code">data class Node&lt;T&gt;(</p>&#13;
			<p class="source-code">    val value: T,</p>&#13;
			<p class="source-code">    val left: Tree&lt;T&gt; = Empty,</p>&#13;
			<p class="source-code">    val right: Tree&lt;T&gt; = Empty</p>&#13;
			<p class="source-code">) : Tree&lt;T&gt;</p>&#13;
			<p><strong class="source-inline">Node</strong> also implements the <strong class="source-inline">Tree</strong> interface, but it is a data class and not an object since every node is different. The type of the value of a <strong class="source-inline">Node</strong> is <strong class="source-inline">T</strong>, which means it can contain any type of value, but all the nodes in the same tree will contain the same type of value. This is the real power of generics. </p>&#13;
			<p>A node also has two children, left and right, since it's a binary tree. By default, both of them are empty.</p>&#13;
			<p>We can specify the default values for the children of a node thanks to the fact that the type is covariant and <strong class="source-inline">Empty</strong> is of the <strong class="source-inline">Nothing</strong> type. <strong class="source-inline">Nothing</strong> is at the bottom of the class hierarchy, while <strong class="source-inline">Any</strong> is at the very top. </p>&#13;
			<p>When we declared the type of our <strong class="source-inline">Tree</strong> as <strong class="source-inline">out T</strong>, we meant that our <strong class="source-inline">Tree</strong> could contain values of type <strong class="source-inline">T</strong> or anything that inherits from that type.</p>&#13;
			<p>Since <strong class="source-inline">Nothing</strong> is at the bottom of a class hierarchy, it <em class="italic">inherits</em> from all types.</p>&#13;
			<p>Now that everything <a id="_idIndexMarker633"/>has been set, let's learn how to create a new instance of the tree we just defined:</p>&#13;
			<p class="source-code">val tree = Node(</p>&#13;
			<p class="source-code">    1,</p>&#13;
			<p class="source-code">    Empty,</p>&#13;
			<p class="source-code">    Node(</p>&#13;
			<p class="source-code">        2,</p>&#13;
			<p class="source-code">        Node(3)</p>&#13;
			<p class="source-code">    )</p>&#13;
			<p class="source-code">)</p>&#13;
			<p class="source-code">println(tree)</p>&#13;
			<p>Here, we created a tree with <strong class="bold">1</strong> as the value of the root node and a right node with a value of <strong class="bold">2</strong>. The right node has a left child with a value of <strong class="bold">3</strong>. This is what our tree looks like:</p>&#13;
			<div>&#13;
				<div id="_idContainer021" class="IMG---Figure">&#13;
					<img src="Images/B17816_09_01.jpg" alt="Figure 9.1 – Tree diagram&#13;&#10;" width="290" height="484"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 9.1 – Tree diagram</p>&#13;
			<p>The preceding code outputs the following:</p>&#13;
			<p class="source-code">&gt; Node(value=1, left=Empty, right=Node(value=2, left=Node(value=3, left=Empty, right=Empty), right=Empty))</p>&#13;
			<p>However, printing <a id="_idIndexMarker634"/>the tree in such a form is not very interesting. So, let's implement a function that will summarize all the nodes of a tree if it's numeric:</p>&#13;
			<p class="source-code">fun Tree&lt;Int&gt;.sum(): Long = when (this) {</p>&#13;
			<p class="source-code">    Empty -&gt; 0</p>&#13;
			<p class="source-code">    is Node -&gt; value + left.sum() + right.sum()</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This is also <a id="_idIndexMarker635"/>called an <strong class="bold">operation</strong> on an ADT. This is an extension function that is declared only on trees that contain integers.</p>&#13;
			<p>For each node, we check whether it's <strong class="source-inline">Empty</strong> or <strong class="source-inline">Node</strong>. That's the beauty of <strong class="source-inline">sealed</strong> classes and interfaces. Since the compiler knows that the <strong class="source-inline">Tree</strong> interface has exactly two implementations, we don't need an <strong class="source-inline">else</strong> block in our <strong class="source-inline">when</strong> expression.</p>&#13;
			<p>If it's an <strong class="source-inline">Empty</strong> node, we use <strong class="source-inline">0</strong> as a neutral value. If it's not empty, then we sum its values with the left and right children. </p>&#13;
			<p>This function is also another example of a recursive algorithm, which we discussed in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>.</p>&#13;
			<p>Now, let's discuss another topic related to generics in Kotlin.</p>&#13;
			<h1 id="_idParaDest-222"><a id="_idTextAnchor228"/>Reified generics</h1>&#13;
			<p>Previously in<a id="_idIndexMarker636"/> this chapter, we mentioned <strong class="source-inline">inline</strong> functions. Since <strong class="source-inline">inline</strong> functions are copied, we can get rid of one of the major JVM limitations: <strong class="bold">type erasure</strong>. After all, inside the function, we know exactly what type we're getting.</p>&#13;
			<p>Let's look at the following example. We would like to create a generic function that will receive a <strong class="source-inline">Number</strong> (<strong class="source-inline">Number</strong> can either be <strong class="source-inline">Int</strong> or <strong class="source-inline">Long</strong>), but will only print it if it's of the same type as the function type.</p>&#13;
			<p>We'll start with a naïve implementation, simply trying the instance check on the type directly:</p>&#13;
			<p class="source-code">fun &lt;T&gt; printIfSameType(a: Number) { </p>&#13;
			<p class="source-code">    if (<strong class="bold">a is T</strong>) { // &lt;== Error </p>&#13;
			<p class="source-code">        println(a)    </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>However, this code won't compile and we'll get the following error: </p>&#13;
			<p class="source-code">&gt; Cannot check for instance of erased type: T</p>&#13;
			<p>What we usually do in Java, in this case, is pass the class as an argument. We can try a similar approach in Kotlin. If you've worked with Android before, you'll recognize this pattern immediately, since it's used a lot in the standard library: </p>&#13;
			<p class="source-code">fun &lt;T : Number&gt; printIfSameType(clazz: KClass&lt;T&gt;, a: </p>&#13;
			<p class="source-code">  Number) {</p>&#13;
			<p class="source-code">    if (clazz.isInstance(a)) {</p>&#13;
			<p class="source-code">        println("Yes")</p>&#13;
			<p class="source-code">    } else {</p>&#13;
			<p class="source-code">        println("No")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We can check that the code works correctly by running the following lines:</p>&#13;
			<p class="source-code">printIfSameType(Int::class, 1) // Prints yes, as 1 is Int</p>&#13;
			<p class="source-code">printIfSameType(Int::class, 2L) // Prints no, as 2 is Long</p>&#13;
			<p class="source-code">printIfSameType(Long::class, 3L) // Prints yes, as 3 is Long</p>&#13;
			<p>This code works but has a few downsides:</p>&#13;
			<ul>&#13;
				<li>We cannot use the <strong class="source-inline">is</strong> operator and must use the <strong class="source-inline">isInstance()</strong> function instead.</li>&#13;
				<li>We must pass the correct class; that is, <strong class="source-inline">clazz: KClass&lt;T&gt;</strong>.</li>&#13;
			</ul>&#13;
			<p>This code could <a id="_idIndexMarker637"/>be improved by using a <strong class="source-inline">reified</strong> type:</p>&#13;
			<p class="source-code">inline fun &lt;reified T : Number&gt; printIfSameReified(a:   Number) {</p>&#13;
			<p class="source-code">    if (a is T) {</p>&#13;
			<p class="source-code">        println("Yes")</p>&#13;
			<p class="source-code">    } else {</p>&#13;
			<p class="source-code">        println("No")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This function works the same as the previous one but doesn't need a class as input to work. A function that uses a <strong class="source-inline">reified</strong> type must be declared as <strong class="source-inline">inline</strong>. This is due to type erasure on the JVM. </p>&#13;
			<p>We can test that our code still works as expected:</p>&#13;
			<p class="source-code">printIfSameReified&lt;Int&gt;(1) // Prints yes, as 1 is Int</p>&#13;
			<p class="source-code">printIfSameReified&lt;Int&gt;(2L) // Prints no, as 2 is Long</p>&#13;
			<p class="source-code">printIfSameReified&lt;Long&gt;(3L) // Prints yes, as 3 is Long</p>&#13;
			<p>Notice that now, we specify the type that the function operates on, such as <strong class="source-inline">Int</strong> or <strong class="source-inline">Long</strong>, between <em class="italic">angular brackets</em>, instead of passing a class to it as an argument. We get the following benefits from using the <strong class="source-inline">reified</strong> functions:</p>&#13;
			<ul>&#13;
				<li>A clear method signature, without the need to pass a class as an argument.</li>&#13;
				<li>The ability to use the <strong class="source-inline">is</strong> construct inside the function.</li>&#13;
				<li>It's type-inference friendly, which means that if the <em class="italic">type</em> parameter can be inferred by the compiler, it can be completely omitted.</li>&#13;
			</ul>&#13;
			<p>Of course, the same rules for the regular <strong class="source-inline">inline</strong> functions apply here. This code would be replicated, so it shouldn't be too large.</p>&#13;
			<p>Now, let's<a id="_idIndexMarker638"/> consider another case for <strong class="source-inline">reified</strong> types – <strong class="bold">function overloading</strong>. We'll try<a id="_idIndexMarker639"/> to define two functions with the same name that differ only in terms of the types they operate on:</p>&#13;
			<p class="source-code">fun printList(list: List<strong class="bold">&lt;Int&gt;</strong>) { </p>&#13;
			<p class="source-code">    println("This is a list of Ints") </p>&#13;
			<p class="source-code">    println(list) </p>&#13;
			<p class="source-code">} </p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">fun printList(list: List<strong class="bold">&lt;Long&gt;</strong>) { </p>&#13;
			<p class="source-code">    println("This is a list of Longs") </p>&#13;
			<p class="source-code">    println(list) </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This won't compile because there's a platform declaration clash. Both have the same signature in terms of JVM: <strong class="source-inline">printList(list: List)</strong>. This is because types are erased during compilation.</p>&#13;
			<p>But with <strong class="source-inline">reified</strong>, we can achieve this easily:</p>&#13;
			<p class="source-code">inline fun &lt;reified T : Any&gt; printList(list: List&lt;T&gt;) {</p>&#13;
			<p class="source-code">    when {</p>&#13;
			<p class="source-code">        1 is T -&gt; println("This is a list of Ints")</p>&#13;
			<p class="source-code">        1L is T -&gt; println("This is a list of Longs")</p>&#13;
			<p class="source-code">        else -&gt; println("This is a list of something else")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    println(list)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Since the entire function is <em class="italic">inlined</em>, we can check the actual type of the list and output the correct<a id="_idIndexMarker640"/> result.</p>&#13;
			<h1 id="_idParaDest-223"><a id="_idTextAnchor229"/>Using constants efficiently</h1>&#13;
			<p>Since everything<a id="_idIndexMarker641"/> in Java is an object (unless it's a primitive type), we're used to putting all the constants inside our objects as static members.</p>&#13;
			<p>And since Kotlin has <strong class="source-inline">companion</strong> objects, we usually try putting them there:</p>&#13;
			<p class="source-code">class Spock {</p>&#13;
			<p class="source-code">    companion object {</p>&#13;
			<p class="source-code">        val SENSE_OF_HUMOR = "None"</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This will work, but you should remember that <strong class="source-inline">companion object</strong> is an object, after all.</p>&#13;
			<p>So, this will be translated into the following code, more or less:</p>&#13;
			<p class="source-code">public class Spock {</p>&#13;
			<p class="source-code">    private static final String SENSE_OF_HUMOR = "None";</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    public String getSENSE_OF_HUMOR() {</p>&#13;
			<p class="source-code">        return Spock.SENSE_OF_HUMOR;</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In this example, the Kotlin compiler generates a getter for our constant, which adds another level of indirection.</p>&#13;
			<p>If we look at the code using the constant, we'll see the following:</p>&#13;
			<p class="source-code">String var0 = Spock.Companion.getSENSE_OF_HUMOR();</p>&#13;
			<p class="source-code">System.out.println(var0);</p>&#13;
			<p>We can invoke <a id="_idIndexMarker642"/>a method to get the constant value, which is not very efficient. </p>&#13;
			<p>Now, let's mark this value as constant and see how the code produced by the compiler changes:</p>&#13;
			<p class="source-code">class Spock { </p>&#13;
			<p class="source-code">    companion object { </p>&#13;
			<p class="source-code">        <strong class="bold">const </strong>val SENSE_OF_HUMOR = "None" </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here are the bytecode changes:</p>&#13;
			<p class="source-code">public class Spock { </p>&#13;
			<p class="source-code">   public static final String SENSE_OF_HUMOR = "None"; </p>&#13;
			<p class="source-code">   ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>And here is the call:</p>&#13;
			<p class="source-code">String var1 = "None"; </p>&#13;
			<p class="source-code">System.out.println(var1);</p>&#13;
			<p>Notice that there's no reference for our <strong class="source-inline">Spock</strong> class in the code anymore. The compiler has already <em class="italic">inlined</em> its value for us. After all, it's constant, so it will never change and can be safely <em class="italic">inlined</em>. </p>&#13;
			<p>If all you need is a constant, you can also set it up outside of any class:</p>&#13;
			<p class="source-code">const val SPOCK_SENSE_OF_HUMOR = "NONE"</p>&#13;
			<p>And if you need namespacing, you can wrap it in an object:</p>&#13;
			<p class="source-code">object SensesOfHumor { </p>&#13;
			<p class="source-code">    const val SPOCK = "None" </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now that we've <a id="_idIndexMarker643"/>learned how to use constants more efficiently, let's learn how to work with constructors in an idiomatic manner.</p>&#13;
			<h1 id="_idParaDest-224"><a id="_idTextAnchor230"/>Constructor overload</h1>&#13;
			<p>In Java, we're <a id="_idIndexMarker644"/>used to having overloaded constructors. For example, let's look at the following Java class, which requires the <strong class="source-inline">a</strong> parameter and defaults the value of <strong class="source-inline">b</strong> to <strong class="source-inline">1</strong>:</p>&#13;
			<p class="source-code">class User { </p>&#13;
			<p class="source-code">    private final String name; </p>&#13;
			<p class="source-code">    private final boolean resetPassword; </p>&#13;
			<p class="source-code">    public User(String name) { </p>&#13;
			<p class="source-code">        this(name, true); </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    public User(String name, boolean resetPassword) { </p>&#13;
			<p class="source-code">        this.name = name; </p>&#13;
			<p class="source-code">        this.resetPassword = resetPassword; </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We can simulate the same behavior in Kotlin by defining multiple constructors using the <strong class="source-inline">constructor</strong> keyword:</p>&#13;
			<p class="source-code">class User(val name: String, val resetPassword: Boolean) {</p>&#13;
			<p class="source-code">    constructor(name: String) : this(name, true)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The secondary constructor, as defined in the class body, will invoke the primary constructor, providing <strong class="source-inline">1</strong> as the default value for the second argument.</p>&#13;
			<p>However, it's usually better to have default parameter values and named arguments instead:</p>&#13;
			<p class="source-code">class User(val name: String, val resetPassword: Boolean =   true)</p>&#13;
			<p>Note that all the<a id="_idIndexMarker645"/> secondary constructors must delegate to the primary constructor using the <strong class="source-inline">this</strong> keyword. The only exception is when you have a default primary constructor:</p>&#13;
			<p class="source-code">class User {</p>&#13;
			<p class="source-code">    val resetPassword: Boolean</p>&#13;
			<p class="source-code">    val name: String</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    constructor(name: String, resetPassword: Boolean = </p>&#13;
			<p class="source-code">      true) {</p>&#13;
			<p class="source-code">        this.name = name</p>&#13;
			<p class="source-code">        this.resetPassword = resetPassword</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Next, let's discuss how to efficiently handle nulls in Kotlin code.</p>&#13;
			<h1 id="_idParaDest-225"><a id="_idTextAnchor231"/>Dealing with nulls</h1>&#13;
			<p><strong class="bold">Nulls</strong> are unavoidable, especially if <a id="_idIndexMarker646"/>you work with Java libraries or get data from a database. We've already discussed that there are different ways to check whether a variable contains <strong class="source-inline">null</strong> in Kotlin; for example: </p>&#13;
			<p class="source-code">// Will return "String" half of the time and null the other </p>&#13;
			<p class="source-code">// half </p>&#13;
			<p class="source-code">val stringOrNull: String? = if (Random.nextBoolean()) </p>&#13;
			<p class="source-code">  "String" else null  </p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">// Java-way check </p>&#13;
			<p class="source-code">if (stringOrNull != null) { </p>&#13;
			<p class="source-code">    println(stringOrNull.length) </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We could rewrite this code using the <strong class="source-inline">Elvis</strong> operator (<strong class="source-inline">?:</strong>):</p>&#13;
			<p class="source-code">val alwaysLength = stringOrNull?.length <strong class="bold">?:</strong> 0 </p>&#13;
			<p>If the length is not <strong class="source-inline">null</strong>, this operator will return its value. Otherwise, it will return the default value we supplied, which is <strong class="source-inline">0</strong> in this case.</p>&#13;
			<p>If you have a nested object, you can chain those checks. For example, let's have a <strong class="source-inline">Response</strong> object that contains a <strong class="source-inline">Profile</strong>, which, in turn, contains the first name and last name fields, which can be nullable:</p>&#13;
			<p class="source-code">data class Response(</p>&#13;
			<p class="source-code">    val profile: UserProfile?</p>&#13;
			<p class="source-code">)</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">data class UserProfile(</p>&#13;
			<p class="source-code">    val firstName: String?,</p>&#13;
			<p class="source-code">    val lastName: String?</p>&#13;
			<p class="source-code">)</p>&#13;
			<p>This chaining will look like this:</p>&#13;
			<p class="source-code">val response: Response? = Response(UserProfile(null, null))</p>&#13;
			<p class="source-code">println(response?.profile?.firstName?.length)</p>&#13;
			<p>If any of the fields in the chain are null, our code won't crash. Instead, it will print <strong class="source-inline">null</strong>.</p>&#13;
			<p>Finally, you can use the <strong class="source-inline">let()</strong> block for null checks, as we briefly mentioned in the <em class="italic">Using the scope functions</em> section. The same code, but using the <strong class="source-inline">let()</strong> function instead, will <a id="_idIndexMarker647"/>look like this:</p>&#13;
			<p class="source-code">println(response?.let { </p>&#13;
			<p class="source-code">    it.profile?.let { </p>&#13;
			<p class="source-code">        it.firstName?.length </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">})</p>&#13;
			<p>If you want to get rid of <strong class="source-inline">it</strong> everywhere, you can use another scoping function, <strong class="source-inline">run()</strong>:</p>&#13;
			<p class="source-code">println(response?.run { </p>&#13;
			<p class="source-code">    profile?.run { </p>&#13;
			<p class="source-code">        firstName?.length </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">})</p>&#13;
			<p>Try to avoid using the unsafe <strong class="source-inline">!!</strong> null operator in production code:</p>&#13;
			<p class="source-code">println(json!!.User!!.firstName!!.length)</p>&#13;
			<p>This will result in <strong class="source-inline">KotlinNullPointerException</strong>. However, during tests, the <strong class="source-inline">!!</strong> operator may prove useful, as it will help you spot null-safety issues faster. </p>&#13;
			<h1 id="_idParaDest-226"><a id="_idTextAnchor232"/>Making asynchronicity explicit</h1>&#13;
			<p>As you saw<a id="_idIndexMarker648"/> in the previous chapter, it is very easy to create an asynchronous function in Kotlin. Here is an example:</p>&#13;
			<p class="source-code">fun CoroutineScope.getResult() = async { </p>&#13;
			<p class="source-code">   delay(100) </p>&#13;
			<p class="source-code">   "OK" </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>However, this asynchronicity may be an unexpected behavior for the user of the function, as they may expect a simple value. </p>&#13;
			<p><em class="italic">What do you think the following code prints?</em></p>&#13;
			<p class="source-code">println("${getResult()}")</p>&#13;
			<p>For the user, the preceding code somewhat unexpectedly prints the following instead of <strong class="source-inline">"OK"</strong>:</p>&#13;
			<p class="source-code">&gt; Name: DeferredCoroutine{Active}@...</p>&#13;
			<p>Of course, if you have read <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>, you will know that what's missing here is the <strong class="source-inline">await()</strong> function:</p>&#13;
			<p class="source-code">println("${getResult().await()}")</p>&#13;
			<p>But it would have been a lot more obvious if we'd named our function accordingly, by adding an <strong class="source-inline">async</strong> suffix:</p>&#13;
			<p class="source-code">fun CoroutineScope.getResultAsync() = async { </p>&#13;
			<p class="source-code">   delay(100) </p>&#13;
			<p class="source-code">   "OK" </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Kotlin's convention is to distinguish asynchronous functions from regular ones by adding <strong class="source-inline">Async</strong> to the end of the function's name. If you're working with <strong class="bold">IntelliJ IDEA</strong>, it will even suggest you that rename it. </p>&#13;
			<p>Now, let's talk about some built-in functions for validating the user's input.</p>&#13;
			<h1 id="_idParaDest-227"><a id="_idTextAnchor233"/>Validating input</h1>&#13;
			<p>Input validation is <a id="_idIndexMarker649"/>a necessary but very tedious task. <em class="italic">How many times did you have to write code like the following?</em></p>&#13;
			<p class="source-code">fun setCapacity(cap: Int) { </p>&#13;
			<p class="source-code">    if (cap &lt; 0) { </p>&#13;
			<p class="source-code">        throw IllegalArgumentException() </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">    ... </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Instead, you can check arguments with the <strong class="source-inline">require()</strong> function:</p>&#13;
			<p class="source-code">fun setCapacity(cap: Int) { </p>&#13;
			<p class="source-code">    require(cap &gt; 0) </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This makes the code a lot more fluent. You can use <strong class="source-inline">require()</strong> to check for nulls:</p>&#13;
			<p class="source-code">fun printNameLength(p: Profile) { </p>&#13;
			<p class="source-code">    require(p.firstName != null) </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>But there's also <strong class="source-inline">requireNotNull()</strong> for that:</p>&#13;
			<p class="source-code">fun printNameLength(p: Profile) { </p>&#13;
			<p class="source-code">    requireNotNull(p.firstName) </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Use <strong class="source-inline">check()</strong> to validate the state of your object. This is useful when you are providing an object that the user may not have set up correctly:</p>&#13;
			<p class="source-code">class HttpClient { </p>&#13;
			<p class="source-code">    var body: String? = null </p>&#13;
			<p class="source-code">    var url: String = "" </p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    fun postRequest() { </p>&#13;
			<p class="source-code">        check(body != null) { </p>&#13;
			<p class="source-code">            "Body must be set in POST requests" </p>&#13;
			<p class="source-code">        } </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>And again, there's a shortcut for this as well: <strong class="source-inline">checkNotNull()</strong>.</p>&#13;
			<p>The difference between the <strong class="source-inline">require()</strong> and <strong class="source-inline">check()</strong> functions is that <strong class="source-inline">require()</strong> throws <strong class="source-inline">IllegalArgumentException</strong>, implying that the input that was provided to the function was incorrect. On the other hand, <strong class="source-inline">check()</strong> throws <strong class="source-inline">IllegalStateException</strong>, which means that the state of the object is corrupted. </p>&#13;
			<p>Consider using <a id="_idIndexMarker650"/>functions such as <strong class="source-inline">require()</strong> and <strong class="source-inline">check()</strong> to improve the readability of your code.</p>&#13;
			<p>Finally, let's discuss how to efficiently represent different states in Kotlin.</p>&#13;
			<h1 id="_idParaDest-228"><a id="_idTextAnchor234"/>Preferring sealed classes over enums</h1>&#13;
			<p>Coming from<a id="_idIndexMarker651"/> Java, you may be tempted to overload your <strong class="source-inline">enum</strong> with functionality.</p>&#13;
			<p>For example, let's say you build an application that allows users to order a pizza and track its status. We can use the following code for this:</p>&#13;
			<p class="source-code">// Java-like code that uses enum to represent State</p>&#13;
			<p class="source-code">enum class PizzaOrderStatus {</p>&#13;
			<p class="source-code">    ORDER_RECEIVED, PIZZA_BEING_MADE, OUT_FOR_DELIVERY,      COMPLETED;</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    fun nextStatus(): PizzaOrderStatus {</p>&#13;
			<p class="source-code">        return when (this) {</p>&#13;
			<p class="source-code">            ORDER_RECEIVED -&gt; PIZZA_BEING_MADE</p>&#13;
			<p class="source-code">            PIZZA_BEING_MADE -&gt; OUT_FOR_DELIVERY</p>&#13;
			<p class="source-code">            OUT_FOR_DELIVERY -&gt; COMPLETED</p>&#13;
			<p class="source-code">            COMPLETED -&gt; COMPLETED</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Alternatively, you <a id="_idIndexMarker652"/>can use the <strong class="source-inline">sealed</strong> class:</p>&#13;
			<p class="source-code">sealed class PizzaOrderStatus(protected val orderId: Int) {</p>&#13;
			<p class="source-code">    abstract fun nextStatus(): PizzaOrderStatus</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">class OrderReceived(orderId: Int) : </p>&#13;
			<p class="source-code">  PizzaOrderStatus(orderId) {</p>&#13;
			<p class="source-code">    override fun nextStatus() = PizzaBeingMade(orderId)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">class PizzaBeingMade(orderId: Int) : </p>&#13;
			<p class="source-code">  PizzaOrderStatus(orderId) {</p>&#13;
			<p class="source-code">    override fun nextStatus() = OutForDelivery(orderId)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">class OutForDelivery(orderId: Int) : </p>&#13;
			<p class="source-code">  PizzaOrderStatus(orderId) {</p>&#13;
			<p class="source-code">    override fun nextStatus() = Completed(orderId)</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">class Completed(orderId: Int) : PizzaOrderStatus(orderId) {</p>&#13;
			<p class="source-code">    override fun nextStatus() = this</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we created a separate class for each object state, extending the <strong class="source-inline">PizzaOrderStatus</strong> sealed class.</p>&#13;
			<p>The benefit of this approach is that we can now store the state, along with its <strong class="source-inline">status</strong>, more easily. In <a id="_idIndexMarker653"/>our example, we can store the ID of the order:</p>&#13;
			<p class="source-code">var status: PizzaOrderStatus = OrderReceived(123) </p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">while (status !is Completed) { </p>&#13;
			<p class="source-code">    status = when (status) { </p>&#13;
			<p class="source-code">        is OrderReceived -&gt; status.nextStatus() </p>&#13;
			<p class="source-code">        is PizzaBeingMade -&gt; status.nextStatus() </p>&#13;
			<p class="source-code">        is OutForDelivery -&gt; status.nextStatus() </p>&#13;
			<p class="source-code">        is Completed -&gt; status </p>&#13;
			<p class="source-code">    } </p>&#13;
			<p class="source-code">}</p>&#13;
			<p>In general, <strong class="source-inline">sealed</strong> classes are good if you want to have data associated with a state, and you should prefer them over enums. </p>&#13;
			<h1 id="_idParaDest-229"><a id="_idTextAnchor235"/>Summary</h1>&#13;
			<p>In this chapter, we reviewed the best practices in Kotlin, as well as some of the caveats of the language. Now, you should be able to write more idiomatic code that is also performant and maintainable.</p>&#13;
			<p>You should make use of the scoping functions where necessary, but make sure not to overuse them as they may make the code confusing, especially for those newer to the language.</p>&#13;
			<p>Be sure to handle nulls and type casts correctly, with <strong class="source-inline">let()</strong>, the <strong class="source-inline">Elvis</strong> operator, and the smart casts that the language provides. Finally, generics and <strong class="source-inline">sealed</strong> classes and interfaces are powerful tools that help describe complex relationships and behaviors between different classes.</p>&#13;
			<p>In the next chapter, we'll put those skills to use by writing a real-life microservice Reactive design pattern.</p>&#13;
			<h1 id="_idParaDest-230"><a id="_idTextAnchor236"/>Questions</h1>&#13;
			<ol>&#13;
				<li>What is the alternative to Java's try-with-resources in Kotlin?</li>&#13;
				<li>What are the different options for handling nulls in Kotlin?</li>&#13;
				<li>Which problem can be solved by reified generics?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>