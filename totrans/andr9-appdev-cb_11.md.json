["```kt\n<uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" /> \n```", "```kt\nprivate GLSurfaceView mGLSurfaceView;\n```", "```kt\nclass GLRenderer implements GLSurfaceView.Renderer {\n    public void onSurfaceCreated(GL10 unused, EGLConfig config) {\n        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);\n    }\n    public void onDrawFrame(GL10 unused) {\n        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);\n    }\n    public void onSurfaceChanged(GL10 unused, int width, int height) {\n        GLES20.glViewport(0, 0, width, height);\n    }\n}\n```", "```kt\nclass CustomGLSurfaceView extends GLSurfaceView {\n\n    private final GLRenderer mGLRenderer;\n\n    public CustomGLSurfaceView(Context context){\n        super(context);\n        setEGLContextClientVersion(2);\n        mGLRenderer = new GLRenderer();\n        setRenderer(mGLRenderer);\n    }\n}\n```", "```kt\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mGLSurfaceView = new CustomGLSurfaceView(this);\n    setContentView(mGLSurfaceView);\n}\n```", "```kt\n<uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" /> \n```", "```kt\n<uses-feature android:glEsVersion=\"0x00030000\" android:required=\"true\" /> \n```", "```kt\n<uses-feature android:glEsVersion=\"0x00030001\" android:required=\"true\" /> \n```", "```kt\nclass CustomGLSurfaceView extends GLSurfaceView {\n\n    private final GLRenderer mGLRenderer;\n\n    public CustomGLSurfaceView(Context context){\n        super(context);\n        setEGLContextClientVersion(2);\n        mGLRenderer = new GLRenderer();\n        setRenderer(mGLRenderer);\n    }\n}\n```", "```kt\nclass GLRenderer implements GLSurfaceView.Renderer {\n    public void onSurfaceCreated(GL10 unused, EGLConfig config) {\n        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);\n    }\n    public void onDrawFrame(GL10 unused) {\n        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);\n    }\n    public void onSurfaceChanged(GL10 unused, int width, int height) {\n        GLES20.glViewport(0, 0, width, height);\n    }\n}\n```", "```kt\nprivate final String vertexShaderCode = \"attribute vec4 vPosition;\" +\n                \"void main() {\" +\n                \"  gl_Position = vPosition;\" +\n                \"}\";\n\nprivate final String fragmentShaderCode = \"precision mediump float;\" +\n                \"uniform vec4 vColor;\" +\n                \"void main() {\" +\n                \"  gl_FragColor = vColor;\" +\n                \"}\";\n\nfinal int COORDS_PER_VERTEX = 3;\nfloat triangleCoords[] = {\n        0.0f,  0.66f, 0.0f,\n        -0.5f, -0.33f, 0.0f,\n        0.5f, -0.33f, 0.0f\n};\n\nfloat color[] = { 0.63f, 0.76f, 0.22f, 1.0f };\n\nprivate final int mProgram;\nprivate FloatBuffer vertexBuffer;\nprivate int mPositionHandle;\nprivate int mColorHandle;\nprivate final int vertexCount = triangleCoords.length / COORDS_PER_VERTEX;\nprivate final int vertexStride = COORDS_PER_VERTEX * 4;\n```", "```kt\npublic int loadShader(int type, String shaderCode){\n     int shader = GLES20.glCreateShader(type);\n     GLES20.glShaderSource(shader, shaderCode);\n     GLES20.glCompileShader(shader);\n     return shader; \n} \n```", "```kt\npublic Triangle() {\n     int vertexShader = loadShader(\n             GLES20.GL_VERTEX_SHADER,\n             vertexShaderCode);\n     int fragmentShader = loadShader(\n             GLES20.GL_FRAGMENT_SHADER,\n             fragmentShaderCode);\n     mProgram = GLES20.glCreateProgram();\n     GLES20.glAttachShader(mProgram, vertexShader);\n     GLES20.glAttachShader(mProgram, fragmentShader);\n     GLES20.glLinkProgram(mProgram);\n\n     ByteBuffer bb = ByteBuffer.allocateDirect(\n             triangleCoords.length * 4);\n     bb.order(ByteOrder.nativeOrder());\n\n     vertexBuffer = bb.asFloatBuffer();\n     vertexBuffer.put(triangleCoords);\n     vertexBuffer.position(0); \n} \n```", "```kt\npublic void draw() {\n     GLES20.glUseProgram(mProgram);\n     mPositionHandle = GLES20.glGetAttribLocation(mProgram, \"vPosition\");\n     GLES20.glEnableVertexAttribArray(mPositionHandle);\n     GLES20.glVertexAttribPointer(mPositionHandle, \n             COORDS_PER_VERTEX,\n             GLES20.GL_FLOAT, false,\n             vertexStride, vertexBuffer);\n     mColorHandle = GLES20.glGetUniformLocation(mProgram, \"vColor\");\n     GLES20.glUniform4fv(mColorHandle, 1, color, 0);\n     GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);\n     GLES20.glDisableVertexAttribArray(mPositionHandle); \n} \n```", "```kt\nprivate Triangle mTriangle; \n```", "```kt\nmTriangle = new Triangle();\n```", "```kt\nmTriangle.draw(); \n```", "```kt\nprivate final String vertexShaderCode = \"attribute vec4 vPosition;\" +\n        \"void main() {\" +\n        \"  gl_Position = vPosition;\" +\n        \"}\";\n\nprivate final String fragmentShaderCode = \"precision mediump float;\" +\n        \"uniform vec4 vColor;\" +\n        \"void main() {\" +\n        \"  gl_FragColor = vColor;\" +\n        \"}\";\n```", "```kt\nprivate int mMVPMatrixHandle; \n```", "```kt\nprivate final String vertexShaderCode = \"attribute vec4 vPosition;\" +\n                \"uniform mat4 uMVPMatrix;\" +\n                \"void main() {\" +\n                \"  gl_Position = uMVPMatrix * vPosition;\" +\n                \"}\";\n```", "```kt\npublic void draw(float[] mvpMatrix) {\n```", "```kt\nmMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, \"uMVPMatrix\"); \nGLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);\n```", "```kt\nprivate final float[] mMVPMatrix = new float[16]; \nprivate final float[] mProjectionMatrix = new float[16]; \nprivate final float[] mViewMatrix = new float[16]; \n```", "```kt\npublic void onSurfaceChanged(GL10 unused, int width, int height) { \n    GLES20.glViewport(0, 0, width, height); \n    float ratio = (float) width / height; \n    Matrix.frustumM(mProjectionMatrix, 0, -ratio, ratio, -1, 1, 3, 7); \n} \n```", "```kt\npublic void onDrawFrame(GL10 unused) { \n    Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, \n         1.0f, 0.0f);    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, \n         mViewMatrix, 0); \n    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); \n    mTriangle.draw(mMVPMatrix); \n} \n```", "```kt\nMatrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);\n Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);\n```", "```kt\nprivate float[] mRotationMatrix = new float[16]; \n```", "```kt\nfloat[] tempMatrix = new float[16]; \nlong time = SystemClock.uptimeMillis() % 4000L; \nfloat angle = 0.090f * ((int) time); \nMatrix.setRotateM(mRotationMatrix, 0, angle, 0, 0, -1.0f); \nMatrix.multiplyMM(tempMatrix, 0, mMVPMatrix, 0, mRotationMatrix, 0); \nmTriangle.draw(tempMatrix); \n```", "```kt\nsetRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); \n```", "```kt\nprivate float mCenterX=0; \nprivate float mCenterY=0; \n```", "```kt\nprivate float[] mRotationMatrix = new float[16];\npublic volatile float mAngle;\npublic void setAngle(float angle) {\n    mAngle = angle;\n}\n```", "```kt\nfloat[] tempMatrix = new float[16];\nMatrix.setRotateM(mRotationMatrix, 0, mAngle, 0, 0, -1.0f);\nMatrix.multiplyMM(tempMatrix, 0, mMVPMatrix, 0, mRotationMatrix, 0);\nmTriangle.draw(tempMatrix);\n```", "```kt\nmCenterX=width/2; \nmCenterY=height/2; \n```", "```kt\nsetRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); \n```", "```kt\n@Override\npublic boolean onTouchEvent(MotionEvent e) {\n    float x = e.getX();\n    float y = e.getY();\n    switch (e.getAction()) {\n        case MotionEvent.ACTION_MOVE:\n            double angleRadians = Math.atan2(y-mCenterY,x-mCenterX);\n            mGLRenderer.setAngle((float)Math.toDegrees\n                    (-angleRadians));\n            requestRender();\n    }\n    return true;\n}\n```"]