<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Working with Closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Working with Closures</h1></div></div></div><p>Today, most major programming languages have functionalities similar to what closures offer. Some of these implementations are really hard to use (Objective-C blocks), while others are easy (Java lambda and C# delegates). I found that the functionality that closures provide is especially useful when developing frameworks. I have also used them extensively when communicating with remote services over a network connection. While blocks in Objective-C are incredibly useful (and I used them quite a bit), their syntax used to declare a block was absolutely horrible. Luckily, when Apple was developing the Swift language, they made the syntax of closures much easier to use and understand.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An introduction to closures</li><li class="listitem" style="list-style-type: disc">Defining a closure</li><li class="listitem" style="list-style-type: disc">Using a closure</li><li class="listitem" style="list-style-type: disc">Several useful examples of closures</li><li class="listitem" style="list-style-type: disc">How to avoid strong reference cycles with closures</li></ul></div><div class="section" title="An introduction to closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec76"/>An introduction to closures</h1></div></div></div><p>Closures<a class="indexterm" id="id487"/> are self-contained blocks of code that can be passed around and used throughout our application. We can think of an int type as a type that stores an integer and a string type as a type that stores a string. In this context, a closure can be thought of as a type that holds a block of code. What this means is that we can assign closures to a variable, pass them as arguments to functions, and also return functions from them.</p><p>Closures have the ability to capture and store references to any variable or constant from the context in which they were defined. This is known as closing over the variables or constants, and the best thing is, for the most part, Swift will handle the memory management for us. The only exception is when we create a strong reference cycle, and we will look at how to resolve this in the <span class="emphasis"><em>Creating strong reference cycles with closures</em></span> section of this chapter.</p><p>Closures in Swift are similar to blocks in Objective-C; however, closures in Swift are a lot easier to use and understand. Let's look at the syntax used to define a closure in Swift:</p><div class="informalexample"><pre class="programlisting">{
(parameters) -&gt; return-type in
  statements
}</pre></div><p>As we<a class="indexterm" id="id488"/> can see, the syntax used to create a closure looks very similar to the syntax we use to create functions in Swift, and actually, in Swift, global and nested functions are closures. The biggest difference in the format between closures and functions is the <code class="literal">in</code> keyword. The <code class="literal">in</code> keyword is used in place of curly brackets to separate the definition of the closure's parameter and return types from the body of the closure.</p><p>There are many uses for closures and we will go over a number of them later in this chapter, but first we need to understand the basics of closures. Let's start by looking at some very basic uses for closures so that we can get a better understanding of what they are, how to define them, and how to use them.</p></div></div>
<div class="section" title="Simple closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec77"/>Simple closures</h1></div></div></div><p>We will<a class="indexterm" id="id489"/> begin by creating a very simple closure that does not accept any arguments and does not return any value. All it does is print <code class="literal">Hello World</code> to the console. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">let clos1 = {
  () -&gt; Void in
  
  print("Hello World")
}</pre></div><p>In this example, we create a closure and assign it to the constant <code class="literal">clos1</code>. Since there are no parameters defined between the parentheses, this closure will not accept any parameters. Also, the return type is defined as <code class="literal">Void</code>; therefore, this closure will not return any value. The body of the closure contains one line that prints <code class="literal">Hello World</code> to the console.</p><p>There are many ways to use closures; in this example, all we want to do is execute it. We would execute this closure like this:</p><div class="informalexample"><pre class="programlisting">clos1()</pre></div><p>When we execute the closure, we will see that <code class="literal">Hello World</code> is printed to the console. At this point, closures may not seem that useful, but as we get further along in this chapter, we will see how useful and powerful they can be.</p><p>Let's look <a class="indexterm" id="id490"/>at another simple closure example. This closure will accept one string parameter named <code class="literal">name</code>, but will still not return a value. Within the body of the closure, we will print out a greeting to the name passed into the closure through the <code class="literal">name</code> parameter. Here is the code for this second closure:</p><div class="informalexample"><pre class="programlisting">let clos2 = {
  (name: String) -&gt; Void in
  
  print("Hello \(name)")
}</pre></div><p>The big difference between <code class="literal">clos2</code> defined in this example and the previous <code class="literal">clos1</code> closure is that we define a single string parameter between the parentheses in this closure. As we can see, we define parameters for closures just like we define parameters for functions.</p><p>We can execute this closure in the same way in which we executed <code class="literal">clos1</code>. The following code shows how this is done:</p><div class="informalexample"><pre class="programlisting">clos2("Jon")</pre></div><p>This example, when executed, will print the message <code class="literal">Hello Jon</code> to the console. Let's look at another way we can use the <code class="literal">clos2</code> closure.</p><p>Our original definition of closures stated, "Closures are self-contained blocks of code that can be passed around and used throughout our application code". What this tells us is that we can pass our closure from the context that they were created in other parts of our code. Let's look at how to pass our <code class="literal">clos2</code> closure into a function. We will define the function that accepts our <code class="literal">clos2</code> closure like this:</p><div class="informalexample"><pre class="programlisting">func testClosure(handler:(String)-&gt;Void) {
  handler("Dasher")
}</pre></div><p>We define the function just like we would any other function; however, in our parameter list, we define a parameter named <code class="literal">handler</code>, and the type defined for the handler parameter is <code class="literal">(String)-&gt;Void</code>. If we look closely, we can see that the <code class="literal">(String)-&gt;Void</code> definition of the <code class="literal">handler</code> parameter matches the parameter and return types that we defined for <code class="literal">clos2</code> closure. This means that we can pass the <code class="literal">clos2</code> closure into the function. Let's look at how to do this:</p><div class="informalexample"><pre class="programlisting">testClosure(clos2)</pre></div><p>We call the <code class="literal">testClosure()</code> function just like any other function and the closure that is being passed in looks like any other variable. Since the <code class="literal">clos2</code> closure executed in the <code class="literal">testClosure()</code> function, we will see the message, <code class="literal">Hello Dasher</code>, printed to the console when this code is executed.</p><p>As we will see a little later in this chapter, the ability to pass closures to functions is what makes closures so exciting and powerful.</p><p>As the final <a class="indexterm" id="id491"/>piece to the closure puzzle, let's look at how to return a value from a closure. The following example shows this:</p><div class="informalexample"><pre class="programlisting">let clos3 = {
  (name: String) -&gt; String in
  
  return "Hello \(name)"
}</pre></div><p>The definition of the <code class="literal">clos3</code> closure looks very similar to how we defined the <code class="literal">clos2</code> closure. The difference is that we changed the <code class="literal">Void</code> return type to a <code class="literal">String</code> type. Then, in the body of the closure, instead of printing the message to the console, we used the return statement to return the message. We can now execute the <code class="literal">clos3</code> closure just like the previous two closures or pass the closure to a function like we did with the <code class="literal">clos2</code> closure. The following example shows how to execute <code class="literal">clos3</code> closure:</p><div class="informalexample"><pre class="programlisting">var message = clos3("Buddy")</pre></div><p>After this line of code is executed, the message variable will contain the <code class="literal">Hello Buddy</code> string.</p><p>The previous three examples of closures demonstrate the format and how to define a typical closure. Those who are familiar with Objective-C can see that the format of closures in Swift is a lot cleaner and easier to use. The syntax for creating closures that we have shown so far in this chapter is pretty short; however, we can shorten it even more. In this next section, we will look at how to do this.</p></div>
<div class="section" title="Shorthand syntax for closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec78"/>Shorthand syntax for closures</h1></div></div></div><p>In <a class="indexterm" id="id492"/>this section, we will look at a couple of ways to <a class="indexterm" id="id493"/>shorten the definition of closures.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Using the shorthand syntax for closures is really a matter of personal preference. There are a lot of developers that like to make their code as small and compact as possible and they take great pride in doing so. However, at times, this can make code hard to read and understand by other developers.</p></div></div><p>The first shorthand syntax for closures that we are going to look at is one of the most popular and is the syntax we saw when we were using algorithms with arrays in <a class="link" href="ch03.html" title="Chapter 3. Using Collections and Cocoa Data Types">Chapter 3</a>, <span class="emphasis"><em>Using Collections and Cocoa Data Types</em></span>. This format is mainly used when we want to send a really small (usually one line) closure to a function, like we did with the algorithms for arrays. Before we look at this shorthand syntax, we need to write a function that will accept a closure as a parameter:</p><div class="informalexample"><pre class="programlisting">func testFunction(num: Int, handler:()-&gt;Void) {
  for var i=0; i &lt; num; i++ {     handler()
  }
}</pre></div><p>This<a class="indexterm" id="id494"/> function accepts two parameters—the first parameter is<a class="indexterm" id="id495"/> an integer named <code class="literal">num</code>, and the second parameter is a closure named <code class="literal">handler</code> that does not have any parameters and does not return any value. Within the function, we create a <code class="literal">for</code> loop that will use the <code class="literal">num</code> integer to define how many times it loops. Within the <code class="literal">for</code> loop, we call the <code class="literal">handler</code> closure that was passed into the function.</p><p>We can create a closure and pass it to the <code class="literal">testFunction()</code> like this:</p><div class="informalexample"><pre class="programlisting">let clos = {
    () -&gt; Void in
    print("Hello from standard syntax")
}
testFunction(5,handler: clos)</pre></div><p>This code is very easy to read and understand; however, it does take five lines of code. Now, let's look at how to shorten this code by writing the closure inline within the function call:</p><div class="informalexample"><pre class="programlisting">testFunction(5,handler: {print("Hello from Shorthand closure")})</pre></div><p>In this example, we created the closure inline within the function call using the same syntax that we used with the algorithms for arrays. The closure is placed in between two curly brackets (<code class="literal">{}</code>), which means the code to create our closure is <code class="literal">{print("Hello from Shorthand closure")}</code>. When this code is executed, it will print out the message, <code class="literal">Hello from Shorthand closure</code>, five times on the screen.</p><p>In <a class="link" href="ch03.html" title="Chapter 3. Using Collections and Cocoa Data Types">Chapter 3</a>, <span class="emphasis"><em>Using Collections and Cocoa Data Types</em></span>, we saw that we were able to pass parameters to the array algorithms using the <code class="literal">$0</code>, <code class="literal">$1</code>, <code class="literal">$2</code>, and so on parameters. Let's look at how to use parameters with this shorthand syntax. We will begin by creating a new function that will accept a closure with a single parameter. We will name this function <code class="literal">testFunction2</code>. The following example shows what the new <code class="literal">testFunction2</code> function does:</p><div class="informalexample"><pre class="programlisting">func testFunction2(num: Int, handler:(name: String)-&gt;Void) {
  for var i=0; i &lt; num; i++ {
    handler(name: "Me")
  }
}</pre></div><p>In <code class="literal">testFunction2</code>, we define our closure like this: <code class="literal">(name: String)-&gt;Void</code>. This definition means that the closure accepts one parameter and does not return any value. Now, let's see how to use the same shorthand syntax to call this function:</p><div class="informalexample"><pre class="programlisting">testFunction2(5,handler: {print("Hello from \($0)")}) </pre></div><p>The difference between this closure definition and the previous one is <code class="literal">$0</code>. The <code class="literal">$0</code> parameter is shorthand for the first parameter passed into the function. If we execute this code, it prints out the message, <code class="literal">Hello from Me</code>, five times.</p><p>Using the<a class="indexterm" id="id496"/> dollar sign (<code class="literal">$</code>) followed by a number <a class="indexterm" id="id497"/>with inline closures allows us to define the closure without having to put a parameter list in the definition. The number after the dollar sign defines the position of the parameter in the parameter list. Let's examine this format a bit more because we are not limited to only using the dollar sign (<code class="literal">$</code>) and number shorthand format with inline closures. This shorthand syntax can also be used to shorten the closure definition by allowing us to leave the parameter names off. The following example demonstrates this:</p><div class="informalexample"><pre class="programlisting">let clos5: (String, String) -&gt;Void = {
    print("\($0) \($1)")
}</pre></div><p>In this example, our closure has two string parameters defined; however, we do not give them names. The parameters are defined like this: <code class="literal">(String, String)</code>. We can then access the parameters within the body of the closure using <code class="literal">$0</code> and <code class="literal">$1</code>. Also, note that closure definition is after the colon (<code class="literal">:</code>), using the same syntax that we use to define a variable type, rather than inside the curly brackets. When we use anonymous arguments, this is how we would define the closure. It will not be valid to define the closure like this:</p><div class="informalexample"><pre class="programlisting">let clos5b = {
    (String, String) -&gt; Void in
    print("\($0) \($1)")
}</pre></div><p>In this example, we will receive the <code class="literal">Anonymous closure arguments cannot be used inside a closure that has explicit arguments</code> error.</p><p>We will use the <code class="literal">clos5</code> closure like this:</p><div class="informalexample"><pre class="programlisting">clos5("Hello","Kara")</pre></div><p>Since <code class="literal">Hello</code> is the first string in the parameter list, it is accessed with <code class="literal">$0</code>, and as <code class="literal">Kara</code> is the second string in the parameter list, it is accessed with <code class="literal">$1</code>. When we execute this code, we will see the message, <code class="literal">Hello Kara</code>, printed to the console.</p><p>This next example is used when the closure doesn't return any value. Rather than defining the return type as <code class="literal">Void</code>, we can use parentheses, as the following example shows:</p><div class="informalexample"><pre class="programlisting">let clos6: () -&gt; () = {
    print("Howdy")
}</pre></div><p>In this example, we define the closure as <code class="literal">() -&gt; ()</code>. This tells Swift that the closure does not accept any parameters and also does not return a value. We will execute this closure like this:</p><div class="informalexample"><pre class="programlisting">clos6()</pre></div><p>We have <a class="indexterm" id="id498"/>one more shorthand closure example to <a class="indexterm" id="id499"/>demonstrate before we begin showing some useful examples of closures. In this last example, we will demonstrate how we can return a value from the closure without the need to include the word, <code class="literal">return</code>.</p><p>If the entire closure body consists of only a single statement, then we can omit the <code class="literal">return</code> keyword, and the results of the statement will be returned. Let's take a look at an example of this:</p><div class="informalexample"><pre class="programlisting">let clos7 = {
    (first: Int, second: Int) -&gt; Int in
    first + second
}</pre></div><p>In this example, the closure accepts two parameters of the <code class="literal">Int</code> type and will return an <code class="literal">Int</code> type. The only statement within the body of the closure adds the first parameter to the second parameter. However, if you notice, we do not include the <code class="literal">return</code> keyword before the addition statement. Swift will see that this is a single statement closure and will automatically return the results, just as if we put the <code class="literal">return</code> keyword before the addition statement. We do need to make sure the result type of our statement matches the return type of the closure.</p><p>All of the examples that were shown in the previous two sections were designed to show how to define and use closures. On their own, these examples did not really show off the power of closures and they did not show how incredibly useful closures are. The remainder of this chapter is written to demonstrate the power and usefulness of closures in Swift.</p></div>
<div class="section" title="Using closures with Swift's array algorithms"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec79"/>Using closures with Swift's array algorithms</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Using Collections and Cocoa Data Types">Chapter 3</a>, <span class="emphasis"><em>Using Collections and Cocoa Data Types</em></span>, we looked at several built-in algorithms <a class="indexterm" id="id500"/>that we could use with Swift's arrays. In <a class="indexterm" id="id501"/>that chapter, we briefly saw how to add simple rules to each of these algorithms with very basic closures. Now that we have a better understanding of closures, let's see how we can expand on these algorithms using more advanced closures.</p><p>In this section, we will primarily be using the map algorithm for consistency purposes; however, we can use the basic ideas demonstrated with any of the algorithms. We will start by defining an array to use:</p><div class="informalexample"><pre class="programlisting">let guests = ["Jon", "Kim", "Kailey", "Kara"]</pre></div><p>This array contains a list of names and the array is named <code class="literal">guests</code>. This array will be used for all the examples in this section, except for the very last ones.</p><p>Now that <a class="indexterm" id="id502"/>we have our <code class="literal">guests</code> array, let's add a<a class="indexterm" id="id503"/> closure that will print a greeting to each of the names in the <code class="literal">guests</code> array:</p><div class="informalexample"><pre class="programlisting">guests.map({
    (name: String) -&gt; Void in
    print("Hello \(name)")
})</pre></div><p>Since the map algorithm applies the closure to each item of the array, this example will print out a greeting for each name within the <code class="literal">guests</code> array. After the first section in this chapter, we should have a pretty good understanding of how this closure works. Using the shorthand syntax that we saw in the last section, we could reduce the preceding example down to the following single line of code:</p><div class="informalexample"><pre class="programlisting">guests.map({print("Hello \($0)")})</pre></div><p>This is one of the few times, in my opinion, where the shorthand syntax may be easier to read than the standard syntax.</p><p>Now, let's say that rather than printing the greeting to the console, we wanted to return a new array that contained the greetings. For this, we would have returned a string type from our closure, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var messages = guests.map({
    (name:String) -&gt; String in
    return "Welcome \(name)"
})</pre></div><p>When this code is executed, the <code class="literal">messages</code> array will contain a greeting to each of the names in the <code class="literal">guests</code> array while the <code class="literal">guests</code> array will remain unchanged.</p><p>The preceding examples in this section showed how to add a closure to the map algorithm inline. This is good if we only had one closure that we wanted to use with the map algorithm, but what if we had more than one closure that we wanted to use, or if we wanted to use the closure multiple times or reuse them with different arrays. For this, we could assign the closure to a constant or variable and then pass in the closure, using its constant or variable name, as needed. Let's see how to do this. We will begin by defining two closures. One of the closures will print a greeting for each name in the <code class="literal">guests</code> array, and the other closure will print a goodbye message for each name in the <code class="literal">guests</code> array:</p><div class="informalexample"><pre class="programlisting">let greetGuest = {
  (name:String) -&gt; Void in
    print("Hello guest named \(name)")
}

let sayGoodbye = {
  (name:String) -&gt; Void in
    print("Goodbye \(name)")
}</pre></div><p>Now that <a class="indexterm" id="id504"/>we have two closures, we can use them with<a class="indexterm" id="id505"/> the map algorithm as needed. The following code shows how to use these closures interchangeably with the <code class="literal">guests</code> array:</p><div class="informalexample"><pre class="programlisting">guests.map(greetGuest)
guests.map(sayGoodbye)</pre></div><p>Whenever we use the <code class="literal">greetGuest</code> closure with the <code class="literal">guests</code> array, the greetings message is printed to the console, and whenever we use the <code class="literal">sayGoodbye</code> closure with the <code class="literal">guests</code> array, the goodbye message is printed to the console. If we had another array named <code class="literal">guests2</code>, we could use the same closures for that array, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">guests.map(greetGuest)
guests2.map(greetGuest)
guests.map(sayGoodbye)
guests2.map(sayGoodbye)</pre></div><p>All of the examples, in this section, so far have either printed a message to the console or returned a new array from the closure. We are not limited to such basic functionality in our closures. For example, we can filter the array within our closure, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">let greetGuest2 = {
  (name:String) -&gt; Void in
    if (name.hasPrefix("K")) {
      print("\(name) is on the guest list")
    } else {
    print("\(name) was not invited")
    }
}</pre></div><p>In this example, we print out a different message depending on whether the name starts with the letter K or not.</p><p>As we mentioned earlier in the chapter, closures have the ability to capture and store references to any variable or constant from the context in which they were defined. Let's look at an example of this. Let's say that we have a function that contains the highest temperature for the last seven days at a given location and this function accepts a closure as a parameter. This function will execute the closure on the array of temperature. The function can be written like this:</p><div class="informalexample"><pre class="programlisting">func temperatures(calculate:(Int)-&gt;Void) {
    var tempArray = [72,74,76,68,70,72,66]
    tempArray.map(calculate)

}</pre></div><p>This function <a class="indexterm" id="id506"/>accepts a closure defined as <code class="literal">(Int)-&gt;Void</code>. We <a class="indexterm" id="id507"/>then use the map algorithm to execute this closure for each item of the <code class="literal">tempArray</code> array. The key to using a closure correctly in this situation is to understand that the <code class="literal">temperatures</code> function does not know or care what goes on inside the <code class="literal">calculate</code> closure. Also, be aware that the closure is also unable to update or change the items within the function's context, which means that the closure cannot change any other variable within the temperature's function; however, it can update variables in the context that it was created in.</p><p>Let's look at the function that we will create the closure in. We will name this function <code class="literal">testFunction</code>. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">func testFunction() {
    var total = 0
    var count = 0
    let addTemps = {
      (num: Int) -&gt; Void in
      total += num
      count++
    }
    temperatures(addTemps)
    print("Total: \(total)")
    print("Count: \(count)")
    print("Average: \(total/count)")
}</pre></div><p>In this function, we begin by defining two variables named <code class="literal">total</code> and <code class="literal">count</code>, where both variables are of the integer type. We then create a closure named <code class="literal">addTemps</code> that will be used to add all of the temperatures from the <code class="literal">temperatures</code> function together. The <code class="literal">addTemps</code> closure will also count how many temperatures are there in the array. To do this, the <code class="literal">addTemps</code> closure calculates the sum of each item in the array and keeps the total in the <code class="literal">total</code> variable that was defined at the beginning of the function. The <code class="literal">addTemps</code> closure also keeps track of the number of items in the array by incrementing the <code class="literal">count</code> variable for each item. Notice that neither the <code class="literal">total</code> nor <code class="literal">count</code> variables are defined within the closure; however, we are able to use them within the closure because they were defined in the same context as the closure.</p><p>We then call the <code class="literal">temperatures</code> function and pass it the <code class="literal">addTemps</code> closure. Finally, we print the total, count, and average temperature to the console. When the <code class="literal">testFunction</code> is executed, we see the following output to the console:</p><div class="informalexample"><pre class="programlisting">Total: 498
Count: 7
Average: 71</pre></div><p>As we <a class="indexterm" id="id508"/>can see from the output, the <code class="literal">addTemps</code> closure is<a class="indexterm" id="id509"/> able to update and use items that are defined within the context that it was created in, even when the closure is used in a different context.</p><p>Now that we have looked at using closures with the array map algorithm, let's look at using closures by themselves. We will also look at the ways we can clean up our code to make it easier to read and use.</p></div>
<div class="section" title="Standalone closures and good style guidelines"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec80"/>Standalone closures and good style guidelines</h1></div></div></div><p>Closures <a class="indexterm" id="id510"/>give us the ability to truly separate the data portions of our code from the user interface and business logic portions. This gives us the ability to create reusable classes that focus solely on retrieving our data. This is especially good for developing classes and frameworks that are designed to retrieve data from external services, such as web services, databases, or files. This section will show how to develop a class that will execute a closure once our data is ready to return.</p><p>Let's begin by creating a class that will contain the data portion of our code. In this example, the class will be named <code class="literal">Guests</code> and it will contain an array of <code class="literal">guests</code> names. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">class Guests {
    var guestNames = ["Jon","Kim","Kailey","Kara","Buddy","Lily","Dash"]
   
    typealias UseArrayClosure = [String] -&gt; Void   
    func getGuest(handler:UseArrayClosure) {
        handler(guestNames)
    }

}</pre></div><p>The first line in the <code class="literal">Guests</code> class defines an array named <code class="literal">guestNames</code>. The <code class="literal">guestNames</code> array contains seven names. After we define the <code class="literal">guestNames</code> array, we then create a type alias. A type alias defines a named alias for an existing type. Just like a function, closures have types that consist of the parameter types and return types, which can be aliased. This allows us to define the closure once and then use the alias anywhere within our code. Using a type alias can reduce the amount of typing we have to do and also prevent errors. Therefore, it is recommended that we use them rather than trying to retype the closure definition multiple times in our code. It also allows us to change the definition in one location and it will then update throughout the code.</p><p>In this <a class="indexterm" id="id511"/>example, our type alias is named <code class="literal">UseArrayClosure</code> and is defined as a closure that accepts an array of strings as the only parameter and does not return a value. We can now use this type alias throughout our code as shorthand for the closure definition.</p><p>Finally, we define a <code class="literal">getGuest()</code> method that accepts a closure named <code class="literal">handler</code> as its only parameter. Within the <code class="literal">getGuests()</code> method, the only thing we do is execute the handler. Normally, in this method, we will have the logic to retrieve the data from our external data source; however, in this example, we have an array that is hardcoded with our list of guest names. Therefore, all we need to do is to execute the closure with the <code class="literal">guestsNames</code> array as the only parameter.</p><p>Now, let's say that we want to display this array of names in a <code class="literal">UITableView</code> view. A <code class="literal">UITableView</code> is an iOS view that is designed for displaying lists of information. In the view controller, we will need to create an array to hold the data to display in <code class="literal">UITableView</code> and a variable that will link to <code class="literal">UITableView</code> in our display. These will both be class variables defined in our view controller class, and they are defined like this:</p><div class="informalexample"><pre class="programlisting">@IBOutlet var tableView:UITableView?
var tableData: [String]?</pre></div><p>Now, let's create a function called <code class="literal">getData()</code> that will be used to retrieve the list of guests and update the table view:</p><div class="informalexample"><pre class="programlisting">func getData() {
  let dataClosure: Guests.UseArrayClosure = {
    self.tableData = $0
    if let tView = self.tableView {
      tView.reloadData()
    }
  }
       
  let guests = Guests()
  guests.getGuest(dataClosure)
}</pre></div><p>We begin the <code class="literal">getData()</code> function by defining a closure named <code class="literal">dataClosure</code>. This closure uses the <code class="literal">UseArrayClosure</code> type alias that we defined in the <code class="literal">Guests</code> class for the closure definition. Within the closure definition, we set the <code class="literal">tableData</code> array, which is defined within the view controller itself (not in the closure), equal to the string array that is passed into the closure. We then verify whether the <code class="literal">tableView</code> variable contains an instance of the <code class="literal">UITableView</code> class, and if so, we reload its data. Finally, we create an instance of the <code class="literal">Guests</code> class and call the <code class="literal">getGuest()</code> method passing it the <code class="literal">dataClosure</code> closure.</p><p>Keep in mind that the <code class="literal">guestNames</code> array, which defines the list of names, is defined in the <code class="literal">Guest</code> class, while the <code class="literal">tableView</code>, <code class="literal">UITableView</code>, and <code class="literal">tableData</code> arrays are defined in the view controller class.</p><p>When<a class="indexterm" id="id512"/> the <code class="literal">dataClosure</code> closure is passed to the <code class="literal">getGuests()</code> method, it will load the array of names, from the <code class="literal">Guests</code> class, into the <code class="literal">tableData</code> array. The <code class="literal">tableData</code> array is then used within the view controller class as the data elements for the <code class="literal">UITableView</code> array. The key items to note in this example are that we are able to load data from one context (the <code class="literal">Guests</code> class) into a variable that was defined within the same context as the closure (the view controller), and also have the ability to call methods on instances of classes (<code class="literal">tableView</code> and <code class="literal">UITableView</code>) defined within the same context as the closure.</p><p>We could have very easily created a method in the <code class="literal">Guest</code> class that returned the <code class="literal">guestNames</code> array. With a hardcoded array, such as the one we have in the <code class="literal">Guest</code> class, this method would have worked very well. However, if we were loading the data from a web service that takes a little time to load; this will not work as well because our UI will freeze while waiting for the data to load. By using a closure, as shown in this example, we can make the web service call asynchronously, and then when the data is returned, the closure will be executed and the UI updates automatically without our UI freezing.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>This book is primarily written to teach the Swift language and not specifically iOS development; therefore, we are not covering how the UI elements from the Cocoa Touch framework work in this example. If you want to see the full iOS example, download the code samples for this book.</p></div></div></div>
<div class="section" title="Changing functionality"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec81"/>Changing functionality</h1></div></div></div><p>Closures<a class="indexterm" id="id513"/> also give us the ability to change the functionality of classes on the fly. We saw in <a class="link" href="ch11.html" title="Chapter 11. Working with Generics">Chapter 11</a>, <span class="emphasis"><em>Working with Generics</em></span>, that generics give us the ability to write functions that are valid for multiple types. With closures, we are able to write functions and classes whose functionality can change, based on the closure that is passed into it as a parameter. In this section, we will show how to write a function whose functionality can be changed with a closure.</p><p>Let's begin by defining a class that will be used to demonstrate how to swap out functionality. We will name this class <code class="literal">TestClass</code>:</p><div class="informalexample"><pre class="programlisting">class TestClass {
  typealias getNumClosure = ((Int, Int) -&gt; Int)
  
  var numOne = 5
  var numTwo = 8
  
  var results = 0
  func getNum(handler: getNumClosure) -&gt; Int {
    results = handler(numOne,numTwo)
    return results

  }
}</pre></div><p>We begin<a class="indexterm" id="id514"/> this class by defining a type alias for our closure that is named <code class="literal">getNumClosure</code>. Any closure that is defined as a <code class="literal">getNumClosure</code> closure will take two integers and return an integer. Within this closure, we assume that it does something with the integers that we pass in to get the value to return, but it really doesn't have to. To be honest, this class doesn't really care what the closure does as long as it conforms to the <code class="literal">getNumClosure</code> type. Next, we define three integers that are named <code class="literal">numOne</code>, <code class="literal">NumTwo</code>, and <code class="literal">results</code>.</p><p>Finally, we define a method named <code class="literal">getNum()</code>. This method accepts a closure that confirms the <code class="literal">getNumClosure</code> type as its only parameter. Within the <code class="literal">getNum()</code> method, we execute the closure by passing in the <code class="literal">numOne</code> and <code class="literal">numTwo</code> class variables, and the integer that is returned is put into the <code class="literal">results</code> class variable.</p><p>Now, let's look at several closures that conform to the <code class="literal">getNumClosure</code> type that we can use with the <code class="literal">getNum()</code> method:</p><div class="informalexample"><pre class="programlisting">var max: TestClass.getNumClosure = {
  if $0 &gt; $1 {
    return $0
  } else {
    return $1
  }
}

var min: TestClass.getNumClosure = {
  if $0 &lt; $1 {
    return $0
  } else {
    return $1
  }
}

var multiply:  TestClass.getNumClosure = {
  return $0 * $1
}

var second: TestClass.getNumClosure = {
  return $1
}

var answer: TestClass.getNumClosure = {
  var tmp = $0 + $1
  return 42
}</pre></div><p>In this code, we<a class="indexterm" id="id515"/> define five closures that conform to the <code class="literal">getNumClosure</code> type:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">max</code>: This returns the maximum value of the two integers that are passed in</li><li class="listitem" style="list-style-type: disc"><code class="literal">min</code>: This returns the minimum value of the two integers that are passed in</li><li class="listitem" style="list-style-type: disc"><code class="literal">multiply</code>: This multiplies both the values that are passed in and returns the product</li><li class="listitem" style="list-style-type: disc"><code class="literal">second</code>: This returns the second parameter that was passed in</li><li class="listitem" style="list-style-type: disc"><code class="literal">answer</code>: This returns the answer to life, the universe, and everything</li></ul></div><p>In the <code class="literal">answer</code> closure, we have an extra line that looks like it does not have a purpose: <code class="literal">var tmp = $0 + $1</code>. We do this purposely because the following code is not valid:</p><div class="informalexample"><pre class="programlisting">var answer: TestClass.getNumClosure = {
    return 42
}</pre></div><p>This class gives us the <code class="literal">error: tuple types '(Int, Int)' and '()' have a different number of elements (2 vs. 0)</code> error. As we can see by the error, Swift does not think that our closure accepts any parameters unless we use <code class="literal">$0</code> and <code class="literal">$1</code> within the body of the closure. In the closure named <code class="literal">second</code>, Swifts assumes that there are two parameters because <code class="literal">$1</code> specifies the second parameter.</p><p>We can now pass each one of these closures to the <code class="literal">getNum</code> method of our <code class="literal">TestClass</code> to change the functionality of the function to suit our needs. The following code illustrates this:</p><div class="informalexample"><pre class="programlisting">var myClass = TestClass()

myClass.getNum(max)
myClass.getNum(min)
myClass.getNum(multiply)
myClass.getNum(second)
myClass.getNum(answer)</pre></div><p>When this code is run, we will receive the following results for each of the closures:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">max</code>: results = 8</li><li class="listitem" style="list-style-type: disc"><code class="literal">min</code>: results = 5</li><li class="listitem" style="list-style-type: disc"><code class="literal">multiply</code>: results = 40</li><li class="listitem" style="list-style-type: disc"><code class="literal">second</code>: results = 8</li><li class="listitem" style="list-style-type: disc"><code class="literal">answer</code>: results = 42</li></ul></div><p>The last example <a class="indexterm" id="id516"/>we are going to show you in this chapter is one that is used a lot in frameworks, especially the ones that have a functionality that is designed to be run asynchronously.</p></div>
<div class="section" title="Selecting a closure based on results"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec82"/>Selecting a closure based on results</h1></div></div></div><p>In the <a class="indexterm" id="id517"/>final example, we will pass two closures to a method, and then depending on some logic, one, or possibly both, of the closures will be executed. Generally, one of the closures is called if the method was successfully executed and the other closure is called if the method failed.</p><p>Let's start off by creating a class that will contain a method that will accept two closures and then execute one of the closures based on the defined logic. We will name this class <code class="literal">TestClass</code>. Here is the code for the <code class="literal">TestClass</code> class:</p><div class="informalexample"><pre class="programlisting">class TestClass {
  typealias ResultsClosure = ((String) -&gt; Void)

  func isGreater(numOne: Int, numTwo:Int, successHandler: ResultsClosure, failureHandler: ResultsClosure) {
    if numOne &gt; numTwo {
      successHandler("\(numOne) is greater than \(numTwo)")
    }
    else {
      failureHandler("\(numOne) is not greater than \(numTwo)")
    }

  }
}</pre></div><p>We begin this class by creating a type alias that defines the closure that we will use for both the successful and failure closures. We will name this type alias <code class="literal">ResultsClosure</code>. This example will also illustrate why using a type alias, rather than retyping the closure definition, saves us a lot of typing and also prevents us from making mistakes. In this example, if we did not use a type alias, we would need to retype the closure definition four times, and if we needed to change the closure definition, we would need to change it in four spots. With the type alias, we only need to type the closure definition once and then use the alias throughout the remaining code.</p><p>We then create a method named <code class="literal">isGreater</code> that takes two integers as the first two parameters and then two closures as the next two parameters. The first closure is named <code class="literal">successHandler</code>, and the second closure is named <code class="literal">failureHandler</code>. Within the <code class="literal">isGreater</code> method, we<a class="indexterm" id="id518"/> check whether the first integer parameter is greater than the second one. If the first integer is greater, the <code class="literal">successHandler</code> closure is executed; otherwise, the <code class="literal">failureHandler</code> closure is executed.</p><p>Now, let's create two of our closures. The code for these two closures is:</p><div class="informalexample"><pre class="programlisting">var success: TestClass. ResultsClosure = {
    print("Success: \($0)")
}

var failure: TestClass. ResultsClosure = {
    print("Failure: \($0)")
}</pre></div><p>Note that both closures are defined as the <code class="literal">TestClass.ResultsClosure</code> type. In each closure, we simply print a message to the console to let us know which closure was executed. Normally, we would put some functionality in the closure.</p><p>We will then call the method with both the closures like this:</p><div class="informalexample"><pre class="programlisting">var test = TestClass()
test.isGreater(8, numTwo: 6, successHandler:success, failureHandler:failure)</pre></div><p>Note that in the method call, we are sending both the success closure and the failure closure. In this example, we will see the message, <code class="literal">Success: 8 is greater than 6</code>. If we reversed the numbers, we would see the message, <code class="literal">Failure: 6 is not greater than 8</code>. This use case is really good when we call asynchronous methods, such as loading data from a web service. If the web service call was successful, the success closure is called; otherwise, the failure closure is called.</p><p>One big advantage of using closures like this is that the UI does not freeze while we wait for the web service call to complete. This also involves a concurrency piece, which we will be covering in <a class="link" href="ch14.html" title="Chapter 14. Concurrency and Parallelism in Swift">Chapter 14</a>, <span class="emphasis"><em>Concurrency and Parallelism in Swift</em></span>, later in this book. As an example, if we tried to retrieve data from a web service like this:</p><div class="informalexample"><pre class="programlisting">var data = myWebClass.myWebServiceCall(someParameter)</pre></div><p>Our UI would freeze while we wait for the response to come back, or we would have to make the call in a separate thread so that the UI would not hang. With closures, we pass the closures to the networking framework and rely on the framework to execute the appropriate closure when it is done. This does rely on the framework to implement concurrency<a class="indexterm" id="id519"/> correctly to make the calls asynchronously, but a decent framework should handle that for us.</p></div>
<div class="section" title="Creating strong reference cycles with closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec83"/>Creating strong reference cycles with closures</h1></div></div></div><p>Earlier in<a class="indexterm" id="id520"/> this chapter, we said, "the best thing is, for<a class="indexterm" id="id521"/> the most part, Swift will handle the memory management for us". The "for the most part" section of the quote means that if everything is written in a standard way, Swift will handle the memory management of the closures for us. However, just like classes, there are times where the memory management fails us. Memory management will work correctly for all of the examples that we have seen in this chapter so far. It is possible to create a strong reference cycle that would prevent Swift's memory management from working correctly. Let's look at what happens if we create a strong reference cycle with closures.</p><p>A strong reference cycle may happen if we assign a closure to a property of a class instance and within that closure, we capture the instance of the class. This capture occurs because we access a property of that particular instance using <code class="literal">self</code> like <code class="literal">self.someProperty</code> or we assign self to a variable or constant like <code class="literal">let c = self</code>. By capturing a property of the instance, we are actually capturing the instance itself, thereby creating a strong reference cycle where the memory manager will not know when to release the instance. As a result, the memory will not be freed correctly.</p><p>Let's begin by creating a class that has a closure and an instance of the string type as its two properties. We will also create a type alias for the closure type in this class and define a <code class="literal">deinit()</code> method that prints a message to the console. The <code class="literal">deinit()</code> method is called when the class gets released and the memory is freed. We will know when the class gets released when the message from the <code class="literal">deinit()</code> method is printed to the console. This class will be named <code class="literal">TestClassOne</code>. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">class TestClassOne {
  typealias nameClosure = (() -&gt; String)
   
  var name = "Jon"
   
  lazy var myClosure: nameClosure =  {
    return self.name
  }
   
  deinit {
    print("TestClassOne deinitialized")
  }
}</pre></div><p>Now, let's create a second class that will contain a method that accepts a closure that is of the <code class="literal">nameClosure</code> type that was defined in the <code class="literal">TestClassOne</code> class. This class will also have a <code class="literal">deinit()</code> method, so we can also see when it gets released. We will name this class <code class="literal">TestClassTwo</code>. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">class TestClassTwo {
   
  func closureExample(handler: TestClassOne.nameClosure) {
    print(handler())
  }
   
  deinit {
    print("TestClassTwo deinitialized")
  }
}</pre></div><p>Now, let's <a class="indexterm" id="id522"/>see this code in action by creating <a class="indexterm" id="id523"/>instances of each class and then trying to manually release the instance by setting them to <code class="literal">nil</code>:</p><div class="informalexample"><pre class="programlisting">var testClassOne: TestClassOne? = TestClassOne()
var testClassTwo: TestClassTwo? = TestClassTwo()

testClassTwo?.closureExample(testClassOne!.myClosure)
       
testClassOne = nil
print("testClassOne is gone")
       
testClassTwo = nil
print("testClassTwo is gone")</pre></div><p>What we do in this code is create two optionals that may contain an instance of our two test classes or nil. We need to create these variables as optionals because we will be setting them to <code class="literal">nil</code> later in the code so that we can see whether the instances are released properly.</p><p>We then call the <code class="literal">closureExample()</code> method of the <code class="literal">TestClassTwo</code> instance and pass it the <code class="literal">myClosure</code> property from the <code class="literal">TestClassOne</code> instance. We now try to release the <code class="literal">TestClassOne</code> and <code class="literal">TestClassTwo</code> instances by setting them to <code class="literal">nil</code>. Keep in mind that when an instance of a class is released, it attempts to call the <code class="literal">deinit()</code> method of the class if it exists. In our case, both classes have a <code class="literal">deinit()</code> method that prints a message to the console, so we know when the instances are actually released.</p><p>If we run this project, we will see the following messages printed to the console:</p><div class="informalexample"><pre class="programlisting">testClassOne is gone
TestClassTwo deinitialized
testClassTwo is gone</pre></div><p>As we can see, we do attempt to release the <code class="literal">TestClassOne</code> instances, but the <code class="literal">deinit()</code> method of the class is never called, indicating that it was not actually released; however, the <code class="literal">TestClassTwo</code> instance was properly released because the <code class="literal">deinit()</code> method of that class was called.</p><p>To see how this is supposed to work without the strong reference cycle, change the <code class="literal">myClosure</code> closure to return a string type that is defined within the closure itself, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">lazy var myClosure: nameClosure = {
  return "Just Me"
}</pre></div><p>Now, if we run the project, we should see the following output:</p><div class="informalexample"><pre class="programlisting">TestClassOne deinitialized
testClassOne is gone
TestClassTwo deinitialized
testClassTwo is gone</pre></div><p>This shows that the <code class="literal">deinit()</code> methods from both the <code class="literal">TestClassOne</code> and <code class="literal">TestClassTwo</code> instances were properly called, indicating that they were both released properly.</p><p>In the <a class="indexterm" id="id524"/>first example, we capture an instance<a class="indexterm" id="id525"/> of the <code class="literal">TestClassOne</code> class within the closure because we accessed a property of the <code class="literal">TestClassOne</code> class using <code class="literal">self.name</code>. This created a strong reference from the closure to the instance of the <code class="literal">TestClassOne</code> class, preventing memory management from releasing the instance.</p><p>Swift does provide a very easy and elegant way to resolve strong reference cycles in closures. We simply need to tell Swift not to create a strong reference by creating a capture list. A capture list defines the rules to use when capturing reference types within a closure. We can declare each reference to be a weak or unowned reference rather than a strong reference.</p><p>A <code class="literal">weak</code> keyword is used when there is the possibility that the reference will become nil during its lifetime; therefore, the type must be an optional. The <code class="literal">unowned</code> keyword is used when there is not a possibility of the reference becoming nil.</p><p>We define the capture list by pairing the <code class="literal">weak</code> or <code class="literal">unowned</code> keywords with a reference to a class instance. These pairings are written within square brackets (<code class="literal">[ ]</code>). Therefore, if we update the <code class="literal">myClosure</code> closure and define an <code class="literal">unowned</code> reference to <code class="literal">self</code>, we should eliminate the strong reference cycle. The following code shows what the new <code class="literal">myClosure</code> closure will look similar to:</p><div class="informalexample"><pre class="programlisting">lazy var myClosure: nameClosure =  {
  [unowned self] in
  return self.name
}</pre></div><p>Notice the new line—<code class="literal">[unowned self] in</code>. This line says that we do not want to create a strong reference to the instance of <code class="literal">self</code>. If we run the project now, we should see the following output:</p><div class="informalexample"><pre class="programlisting">TestClassOne deinitialized
testClassOne is gone
TestClassTwo deinitialized
testClassTwo is gone</pre></div><p>This<a class="indexterm" id="id526"/> shows <a class="indexterm" id="id527"/>that both the <code class="literal">TestClassOne</code> and <code class="literal">TestClassTwo</code> instances were properly released.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec84"/>Summary</h1></div></div></div><p>In this chapter, we saw that we can define a closure just like we can define an int or string type. We can assign closures to a variable, pass them as an argument to functions, and also return them from functions.</p><p>Closures capture a store references to any constants or variables from the context in which the closure was defined. We do have to be careful with this functionality to make sure that we do not create a strong reference cycle, which would lead to memory leaks in our applications.</p><p>Swift closures are very similar to blocks in Objective-C, but they have a much cleaner and eloquent syntax. This makes them a lot easier to use and understand.</p><p>Having a good understanding of closures is vital to mastering the Swift programming language and will make it easier to develop great applications that are easy to maintain for OS X and iOS. It is also essential for creating first class frameworks that can be used to create OS X and iOS applications.</p><p>The three use cases that we saw in this chapter are by no means the only three <span class="emphasis"><em>useful</em></span> uses for closures. I can promise you that the more you use closures in Swift, the more uses you will find for them. Closures are definitely one of the most powerful and useful features of the Swift language, and Apple did a great job by implementing them in the language.</p></div></body></html>