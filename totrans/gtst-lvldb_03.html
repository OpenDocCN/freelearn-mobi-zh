<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Basic Key-value Operations &#x2013; Creating and Deleting Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Basic Key-value Operations – Creating and Deleting Data</h1></div></div></div><p>The core of LevelDB and any key-value store is the ability to <code class="literal">Put</code>, <code class="literal">Get</code>, and <code class="literal">Delete</code> values by keys. These three operations are all we need to store and retrieve specific pieces of data, treating our database as a persistent dictionary.</p><p>This chapter is about how to use the <code class="literal">Put</code>, <code class="literal">Get</code>, and <code class="literal">Delete</code> operations at their simplest to store and retrieve data. We'll also cover when and how to combine operations into batches.</p><p>The code in this chapter is going to start being a little more idiomatic C++ than the trivial examples so far. The basic LevelDB interface is C++, not just C, and that introduces a couple of issues you need to understand for safe coding. The many other language bindings for LevelDB sit on top of this C++ API, although it is invisible in most of them. For the benefit of people who are pure Objective-C programmers, some C++ idioms will be explained in detail.</p><p>The sample code used for this and the next chapter is written as OS X console programs to have the simplest environment for testing. It's about the database concepts rather than the platforms. Duplicating projects in Xcode is awkward so we will just create new projects each time (which of course you can download in the accompanying code). The sample code uses a lot of <code class="literal">assert</code> statements around different actions. Normally, you would write more robust error-handling code.</p><p>The following screenshot shows the entire console output from running the <code class="literal">Sample03</code> code, including the strange characters drawn because of embedded nulls in one key.</p><p>Like most of our samples, the code creates a database from scratch, using the same logic to put it in a temporary directory as we did in <a class="link" href="ch01.html" title="Chapter 1. Downloading LevelDB and Building with OS X">Chapter 01</a>, <span class="emphasis"><em>Downloading LevelDB and Building with OS X</em></span>. Download the complete sample code to compile and try it for yourself or just refer back to this console output to see the results of the following code snippets:</p><div class="mediaobject"><img src="graphics/1015OS_03_01.jpg" alt="Basic Key-value Operations – Creating and Deleting Data"/><div class="caption"><p>Console output for Sample03 showing messages as data put and retrieved</p></div></div><div class="section" title="Understanding C++ idioms in LevelDbHelper.h"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec13"/>Understanding C++ idioms in LevelDbHelper.h</h1></div></div></div><p>A couple of C++ idioms for LevelDbHelper.h are about being able to write to <a id="id44" class="indexterm"/>standard I/O.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Never put an unscoped <a id="id45" class="indexterm"/>
<code class="literal">using</code> statement into a header file because that propagates to any source that <code class="literal">#includes</code> the header, causing obscure errors. However, it's perfectly acceptable  to simplify a function as seen in <code class="literal">testRead</code> (in the following code snippet) by <a id="id46" class="indexterm"/>putting the <code class="literal">using</code> statements inside. </p></div></div><p>A function such as <a id="id47" class="indexterm"/>
<code class="literal">operator&lt;&lt;</code> starting with <code class="literal">template</code> and using the template type in its declaration will automatically create code for different data types. This shows how to add an <code class="literal">operator&lt;&lt;</code> function so your own data types can be written to streams for output:</p><div class="informalexample"><pre class="programlisting">// little helper so any Slice can be written to a stream
template&lt;class streamT&gt;
streamT&amp; operator&lt;&lt;(
  streamT&amp; stream,
  const leveldb::Slice&amp; sliceValue)
{
  stream &lt;&lt; sliceValue.ToString();
  return stream;
}</pre></div><p>The LevelDB <code class="literal">Get</code> <a id="id48" class="indexterm"/>function fills in <a id="id49" class="indexterm"/>
<code class="literal">std::string</code> as its only way of returning values. Unlike a classical <code class="literal">const char*</code> C string, C++ <code class="literal">std::string</code> can contain binary data. It's basically a size and a pointer to bytes, which normally behaves like a string of characters but can also be used as an arbitrary <a id="id50" class="indexterm"/>container. You can see the <code class="literal">leveldb::Status</code> <a id="id51" class="indexterm"/>object returned by calling <code class="literal">Get</code> and how we <a id="id52" class="indexterm"/>check its <a id="id53" class="indexterm"/>
<code class="literal">ok()</code> function and human-readable error message via <code class="literal">ToString()</code>:</p><div class="informalexample"><pre class="programlisting">template&lt;class keyT&gt;
void testRead(keyT key)
{ // templated so we take a key of any datatype accepted by Get
  using std::cout; using std::endl;
  std::string value;
  leveldb::Status s = db-&gt;Get(
    leveldb::ReadOptions(), key, &amp;value);
  if (s.ok())
    cout &lt;&lt; key &lt;&lt; " =&gt; " &lt;&lt; value &lt;&lt; endl;
  else
    cout &lt;&lt; "failed: " &lt;&lt; s.ToString() &lt;&lt; " " &lt;&lt; key &lt;&lt; endl;
}</pre></div><p>Most of the LevelDB functions take an <code class="literal">options</code> object as their first parameter. Just for this test, you saw how to create a default <a id="id54" class="indexterm"/>just using <code class="literal">leveldb::ReadOptions()</code>. The variables <code class="literal">ropt</code> and <code class="literal">wopt</code> in <code class="literal">main03.cpp</code> are used for a single set of consistent options.</p></div></div>
<div class="section" title="Using Get and Put for strings"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec14"/>Using Get and Put for strings</h1></div></div></div><p>The <code class="literal">testString</code> <a id="id55" class="indexterm"/>function <a id="id56" class="indexterm"/>from <code class="literal">main03.cpp</code> stores and <a id="id57" class="indexterm"/>retrieves string values. We start by trying to read a non-existent key. Note that either a literal quoted string or a <a id="id58" class="indexterm"/>
<code class="literal">std::string</code> object can be passed as a key. The <code class="literal">Get</code> call in <code class="literal">testRead</code> fails with the message <span class="strong"><strong>NotFound</strong></span>, and you could test for that with <code class="literal">if (s.IsNotFound())</code>. See the <code class="literal">leveldb::Status</code> class declaration in <code class="literal">leveldb/status.h</code> <a id="id59" class="indexterm"/>for all these helpers.</p><p>After using the <code class="literal">Put</code> <a id="id60" class="indexterm"/>call to add a value for a given key, it can be read only by using the exact key again—see the <a id="id61" class="indexterm"/>following code—how a different case <a id="id62" class="indexterm"/>fails. Updating a value is simply done by using <code class="literal">Put</code> again with a different value but the same key:</p><div class="informalexample"><pre class="programlisting">testRead("Packt");  // should fail until we add this key
testRead( std::string("Packt") ); // should still fail
cout &lt;&lt; "putting Packt key in" &lt;&lt; endl;
assert( db-&gt;Put(wopt, "Packt", "Getting Started").ok() );
assert( db-&gt;Put(wopt, "Packt2", "with Leveldb").ok() );
testRead("Packt");  // succeeds now we have put that record
testRead("packt");  // fails, keys are case-sensitive
    
// change value for existing key
assert( db-&gt;Put(wopt "Packt", "Is Started").ok() );
testRead("Packt");  // succeeds now we have put that record</pre></div></div>
<div class="section" title="Understanding Slice &#x2013; the efficient LevelDB parameter object"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec15"/>Understanding Slice – the efficient LevelDB parameter object</h1></div></div></div><p>The <code class="literal">testRead</code> <a id="id63" class="indexterm"/>function was templated to allow it to take any data type for a key. In practice, that's any data type from which you can create a <code class="literal">leveldb::Slice</code> <a id="id64" class="indexterm"/>object. These objects are used as parameters in most of the LevelDB interfaces. A <code class="literal">Slice</code> <a id="id65" class="indexterm"/>object contains a length and a data pointer. It does not own its data so is very efficient to copy around but also dangerous to hang onto. If you keep a <code class="literal">Slice</code> object then make sure the data it was initialized with is also retained and the context is thread-safe. This is one reason why you should never share LevelDB objects across threads—they have internal storage referred to by <code class="literal">Slices</code>, and those buffers can be corrupted by operations on other threads.</p><p>See <code class="literal">slice.h</code> for the full class declaration. A <code class="literal">Slice</code> constructor can take a <code class="literal">const char*</code> parameter by itself as a C string, or take a <code class="literal">std::string</code> or <code class="literal">const char*</code> with <code class="literal">size_t</code> length to define a sized value. The <a id="id66" class="indexterm"/>
<code class="literal">Slice</code> methods <code class="literal">data()</code> and <code class="literal">size()</code> return that data pointer and size. The input keys and values for <code class="literal">Get</code> and <code class="literal">Put</code> are <code class="literal">const</code> references to <code class="literal">Slice</code> objects. This implies the unique C++ idiom of conversion by construction can create a temporary <code class="literal">Slice</code> object from any single value which can be used as a Slice constructor parameter, such as a <code class="literal">const char*</code> or <code class="literal">std:string&amp;</code>.</p></div>
<div class="section" title="Using Get and Put with binary values"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Using Get and Put with binary values</h1></div></div></div><p>Now that you understand <a id="id67" class="indexterm"/>how <code class="literal">Slice</code> objects are used, let's go back to the simple <code class="literal">Put</code> and <code class="literal">Get</code> operations. Binary values can be stored just the same as string <a id="id68" class="indexterm"/>values, remembering a <code class="literal">std::string</code> value can be regarded, such as <code class="literal">Slice</code> as containing just data bytes and a length. The difference is that a <code class="literal">std::string</code> retains ownership of its bytes and so is a safe container for binary data. In the following <code class="literal">testBin()</code> sample we create a <code class="literal">Slice</code> object with a pointer and length of an arbitrary binary <code class="literal">struct</code>, and do the opposite to get the binary <code class="literal">struct</code> back out of the <code class="literal">std::string</code> value returned from <code class="literal">Get</code>:</p><div class="informalexample"><pre class="programlisting">  struct binValues {
    int intVal;
    double realVal;
  };    
  binValues b = {-99, 3.14};
  Slice binSlice((const char*)&amp;b, sizeof(binValues) );
  assert( db-&gt;Put(WriteOptions(), "BinSample", binSlice).ok() );
  std::string binRead;
  assert( db-&gt;Get(ReadOptions(), "BinSample", &amp;binRead).ok() );
// treat the std::string as a container for arbitary binary data
  binValues* b2 = (binValues*)binRead.data();     
  cout &lt;&lt; "Read back binary structure " &lt;&lt; b2-&gt;intVal &lt;&lt; "  "
  &lt;&lt; b2-&gt;realVal &lt;&lt; " binary size=" &lt;&lt; binRead.size() &lt;&lt; endl;</pre></div></div>
<div class="section" title="Using Delete &#x2013; the final third of key-value operations"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Using Delete – the final third of key-value operations</h1></div></div></div><p>Earlier in this chapter, we saw how you can <a id="id69" class="indexterm"/>change the value for a given key just by using <code class="literal">Put</code> again with that same key. If you want to effectively rename a key, or get rid of it altogether, you use <code class="literal">Delete</code>. It will cope if the key doesn't exist, as seen in the second <code class="literal">Delete</code> of <code class="literal">Packt</code>:</p><div class="informalexample"><pre class="programlisting">WriteOptions syncWopt;
syncWopt.sync = true;
assert( db-&gt;Delete(syncWopt, "Packt").ok() );
testRead("Packt");  // should fail now we have deleted the key
testRead("Packt2"); // still here, delete only removed exact match
assert( db-&gt;Delete(syncWopt, "Packt").ok() );  // safe failure</pre></div><p>The <code class="literal">Delete</code> operation removes a key-value pair from storage. As mentioned previously, we must also use it as part of renaming to ensure an original key is no longer there. Unlike other database architectures, the log-based storage of LevelDB doesn't have an index table which can be updated. Thus, a <code class="literal">rename</code> implies <a id="id70" class="indexterm"/>both a new key being created and the entire associated value is rewritten:</p><div class="informalexample"><pre class="programlisting">std::string value;
if (db-&gt;Get(readOpt, fromKey, &amp;value).ok()) {
  if (db-&gt;Put(writeOpt, toKey, value).ok())
    db-&gt;Delete(writeOpt, fromKey);
}    </pre></div><p>This rename-by-copy starts by retrieving the value we're going to add back in, so we start with a <code class="literal">Get</code> with the old key.</p></div>
<div class="section" title="Wrapping operations in WriteBatch for increased safety"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Wrapping operations in WriteBatch for increased safety</h1></div></div></div><p>The previous example of <a id="id71" class="indexterm"/>renaming a key, like any other sequence of LevelDB operations, runs the risk of leaving the database in an inconsistent state if the program was terminated partway through. We can wrap any sequence of <code class="literal">Put</code> and <code class="literal">Delete</code> operations in a <a id="id72" class="indexterm"/>
<code class="literal">WriteBatch</code> object. Using sync will guarantee we wait for the disk I/O to complete and allow the batch to optimize its sequence of writes. A safer version of the rename is:</p><div class="informalexample"><pre class="programlisting">leveldb::WriteOptions syncW;
syncW.sync = true;  // sync writes slower but even safer
std::string value;
if (db-&gt;Get(readOpt, fromKey, &amp;value).ok()) {
  leveldb::WriteBatch wb;
  wb.Put(toKey, value);
  wb.Delete(fromKey);
  db-&gt;Write(syncW, &amp;wb);
}</pre></div><p>If you are familiar with other database concepts, <code class="literal">WriteBatch</code> is similar to performing a transaction and a commit. That implies the ability to abandon operations which is also a part of <code class="literal">WriteBatch</code>, using its <code class="literal">Clear</code> operation. Alternatively, you can just free a <code class="literal">WriteBatch</code> object and never apply <a id="id73" class="indexterm"/>it with <code class="literal">db-&gt;Write()</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Summary</h1></div></div></div><p>This was very much a chapter focused on C++, showing templated functions for different kinds of content and writing data to the console. The vital <code class="literal">Slice</code> class was discussed in detail, with its efficient but dangerous reference-only behavior and how it enables storing binary data. We covered the <code class="literal">Put</code>, <code class="literal">Get</code>, and <code class="literal">Delete</code> operations and the safe way to wrap a combination of data changes with <code class="literal">WriteBatch</code>. Next, we will learn to search keys.</p></div></body></html>