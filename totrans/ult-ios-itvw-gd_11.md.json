["```swift\nimport UIKitclass ViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var button: UIButton!\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        textField.addTarget(self, action: #selector\n            (textFieldDidChange(_:)), for: .editingChanged)\n        button.isEnabled = false\n    }\n    @objc private func textFieldDidChange(_ textField: UITextField) {\n        button.isEnabled = textField.text?.isEmpty == false\n    }\n}\n```", "```swift\nimport Combineimport UIKit\nclass ViewController: UIViewController {\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var button: UIButton!\n    private var subscriptions = Set<AnyCancellable>()\n    override func viewDidLoad() {\n        super.viewDidLoad()\ntextField.publisher(for: \\.text)\n         .map { $0?.isEmpty == false }\n         .assign(to: \\.isEnabled, on: button)\n      .store(in: &subscriptions)\n}\n}\n```", "```swift\nvar isTextEmpty: Bool = true {        didSet {\n            // Disable the button if the text is empty,\n               enable it otherwise\n            button.isEnabled = !isTextEmpty\n        }\n    }\n```", "```swift\n    private var cancellables = Set<AnyCancellable>()    private var buttonVisible = PassthroughSubject<Bool,\n        Never>()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        buttonVisible\n            .assign(to: \\.isEnabled, on: button)\n            .store(in: &cancellables)\n}\n```", "```swift\nstruct MyView: View {    @State var toggleIsOn = false\n    var body: some View {\n        Toggle(isOn: $toggleIsOn) {\n            Text(\"Toggle is on: \\(toggleIsOn.description)\")\n        }\n    }\n}\n```", "```swift\nstruct MyParentView: View {    @State var toggleIsOn = false\n    var body: some View {\n        VStack {\n            MyChildView(toggleIsOn: $toggleIsOn)\n            Text(\"Toggle is on: \\(toggleIsOn.description)\")\n        }\n    }\n}\nstruct MyChildView: View {\n    @Binding var toggleIsOn: Bool\n    var body: some View {\n        Toggle(isOn: $toggleIsOn) {\n            Text(\"Toggle is on: \\(toggleIsOn.description)\")\n        }\n    }\n}\n```", "```swift\nimport SwiftUIstruct ContactListView: View {\n    @ObservedObject var viewModel : ContactViewModel\n    var body: some View {\n        List(viewModel.contacts) { contact in Text(contact.name ?? \"\")\n        }\n    }\n}\n```", "```swift\nclass ContactViewModel: ObservableObject {    @Published var contacts = [Contact]()\n    private let dataLayer: ContactDataLayer\n    init(dataLayer: ContactDataLayer) {\n        self.dataLayer = dataLayer\n        loadContacts()\n    }\n    func loadContacts() {\n        contacts = dataLayer.loadContacts()\n    }\n}\n```", "```swift\nstruct ContentView: View {    @State var isModalPresented = false\n    var body: some View {\n        VStack {\n            Button(\"Present Modal\") {\n                isModalPresented = true\n            }\n        }\n        .sheet(isPresented: $isModalPresented) {\n            ModalView()\n        }\n    }\n}\n```", "```swift\nstruct Country {    let name: String\n}\nclass DataStore {\n    let countries = [\n        Country(name: \"USA\"),\n        Country(name: \"Canada\"),\n        Country(name: \"Mexico\")\n    ]\n}\nstruct CountryListView: View {\n    let dataStore = DataStore()\n    var body: some View {\n        NavigationView {\n            List(dataStore.countries, id: \\.name)\n                { country in\n                NavigationLink(destination:\n                    CountryDetailView(country: country)) {\n                    Text(country.name)\n                }\n            }\n            .navigationTitle(\"Countries\")\n        }\n    }\n}\n```", "```swift\nstruct CountryDetailView: View {    let country: Country\n    var body: some View {\n        Text(\"Selected country: \\(country.name)\")\n            .navigationTitle(\"Country Detail\")\n    }\n}\n```", "```swift\nstruct DetailView: View {    @Environment(\\.presentationMode) var presentationMode\n    var body: some View {\n        VStack {\n            Text(\"Detail View\")\n            Button(\"Dismiss\") {\n                presentationMode.wrappedValue.dismiss()\n            }\n        }\n        .navigationTitle(\"Detail View\")\n    }\n}\n```", "```swift\nif presentationMode.wrappedValue.isPresented {    Button(\"Dismiss\") {\n        presentationMode.wrappedValue.dismiss()\n    }\n}\n```", "```swift\nstruct ContentView: View {    @State var labelText = \"Hello, World!\"\n    var body: some View {\n        VStack {\n            Text(labelText)\n                .padding()\n            Button(\"Change Label Text\") {\n                labelText = \"New Label Text\"\n            }\n        }\n    }\n}\n```", "```swift\n.onChange(of: stateVariable) { newValue in    // Execute code here\n}\n```", "```swift\nstruct ContentView: View {    @StateObject var viewModel = ViewModel()\n    @State private var navigateToDetail = false\n    var body: some View {\n        NavigationView {\n            VStack {\n                if viewModel.isLoading {\n                    ProgressView(\"Loading...\")\n                } else {\n                    Button(\"View Detail\") {\n                        viewModel.loadDetail()\n                    }\n                }\n            }\n            .onChange(of: viewModel.detail) { detail in\n                if detail != nil {\n                    navigateToDetail = true\n                }\n            }\n            .sheet(isPresented: $navigateToDetail) {\n                DetailView(detail: viewModel.detail!)\n            }\n            .navigationBarTitle(\"Content\")\n        }\n    }\n}\n```", "```swift\nimport Combinelet numbersPublisher = PassthroughSubject<Int, Never>()\nlet lettersPublisher = PassthroughSubject<String, Never>()\nlet cancellable = Publishers\n    .combineLatest(numbersPublisher, lettersPublisher)\n    .map { (number, letter) -> String in\n        return \"Number: \\(number), Letter: \\(letter)\"\n    }\n    .filter { value in\n        return value.count > 10\n    }\n    .sink { value in\n        print(value)\n    }\nnumbersPublisher.send(1)\nlettersPublisher.send(\"A\")\nnumbersPublisher.send(2)\nlettersPublisher.send(\"B\")\n```", "```swift\nimport UIKitimport Combine\nclass ViewController: UIViewController {\n    @IBOutlet weak var notificationsButton: UIButton!\n    private var cancellables = Set<AnyCancellable>()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        let notificationsPublisher = NotificationsManager.\n            shared.getNotificationsPublisher()\n        notificationsPublisher\n            .map { count -> UIImage? in\n                if count > 0 {\n                    return UIImage(systemName: \"bell.\n                        fill\")?.withTintColor(.red)\n                } else {\n                    return UIImage(systemName: \"bell\")\n                }\n            }\n            .assign(to: \\.image, on: notificationsButton)\n            .store(in: &cancellables)\n}\n```", "```swift\nimport UIKitimport Combine\nstruct Article: Codable {\n    let title: String\n    let description: String\n    let url: URL\n}\nclass ArticlesViewModel {\n    private let url = URL(string: \"https://api.example.com/articles\")!\n    private let decoder = JSONDecoder()\n    @Published private(set) var articles: [Article] = []\n    init() {\n        fetchArticles()\n    }\n    private func fetchArticles() {\n        URLSession.shared.dataTaskPublisher(for: url)\n            .map { $0.data }\n            .decode(type: [Article].self, decoder: decoder)\n            .replaceError(with: [])\n            .receive(on: DispatchQueue.main)\n            .assign(to: &$articles)\n    }\n}\n```", "```swift\nclass ArticlesTableViewController: UITableViewController {    private let viewModel = ArticlesViewModel()\n    private var cancellables = Set<AnyCancellable>()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        viewModel.$articles\n            .receive(on: DispatchQueue.main)\n            .sink(receiveValue: { [weak self] _ in\n                self?.tableView.reloadData()\n            })\n            .store(in: &cancellables)\n    }\n    override func tableView(_ tableView: UITableView,\n        numberOfRowsInSection section: Int) -> Int {\n        return viewModel.articles.count\n    }\n    override func tableView(_ tableView: UITableView,\n        cellForRowAt indexPath: IndexPath) ->\n            UITableViewCell {\n        let cell = tableView.dequeueReusableCell\n            (withIdentifier: \"ArticleCell\", for: indexPath)\n        let article = viewModel.articles[indexPath.row]\n        cell.textLabel?.text = article.title\n        cell.detailTextLabel?.text = article.description\n        return cell\n    }\n}\n```", "```swift\nimport Combinelet numbers = [1, 2, 3, 4, 5]\nlet publisher = numbers.publisher\nlet pipeline = publisher\n    .map { $0 * 2 }\n    .print(\"Debug:\")\n    .filter { $0 % 3 == 0 }\nlet subscriber = Subscribers.Sink<Int, Never>(\n    receiveCompletion: { completion in\n        print(\"Completion: \\(completion)\")\n    },\n    receiveValue: { value in\n        print(\"Value: \\(value)\")\n    }\n)\n```", "```swift\nDebug: receive subscription: (Sequence)Debug: request unlimited\nDebug: receive value: (2)\nDebug: receive value: (6)\nDebug: receive value: (10)\nCompletion: finished\n```", "```swift\nlet pipeline = publisher    .map { $0 * 2 }\n    .handleEvents(\n        receiveSubscription: { subscription in\n            print(\"Subscription: \\(subscription)\")\n        },\n        receiveOutput: { output in\n            print(\"Output: \\(output)\")\n        },\n        receiveCompletion: { completion in\n            print(\"Completion: \\(completion)\")\n        },\n        receiveCancel: {\n            print(\"Cancelled\")\n        }\n    )\n    .filter { $0 % 3 == 0 }\n```", "```swift\nlet pipeline = publisher    .map { $0 * 2 }\n    .breakpoint(\n        receiveSubscription: { subscription in\n            return false\n        },\n        receiveOutput: { output in\n            print(\"Output: \\(output)\")\n            return output > 8\n        },\n        receiveCompletion: { completion in\n            return true\n        }\n    )\n    .filter { $0 % 3 == 0 }\n```", "```swift\nlet pipeline = publisher    .tryMap { value -> Int in\n        if value == 4 {\n            throw ExampleError.example\n        }\n        return value * 2\n    }\n    .breakpointOnError()\n    .filter { $0 % 3 == 0 }\n```"]