- en: '*Chapter 3*: Understanding Data Presentation on Android'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*: 在 Android 上理解数据展示'
- en: In this chapter, we will study the libraries available for presenting data on
    the `ViewModel` and `Lifecycle` libraries. We will then move on to analyze aspects
    of how the UI works and look at how the Jetpack Compose library revolutionized
    building UIs through its declarative approach. Finally, we will look at how we
    can navigate between different screens that are built in Compose by using the
    `Navigation` library with the `Compose` extension.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究可用于在 `ViewModel` 和 `Lifecycle` 库上展示数据的库。然后，我们将分析 UI 工作的一些方面，并查看 Jetpack
    Compose 库如何通过其声明式方法彻底改变了 UI 的构建。最后，我们将探讨如何使用带有 `Compose` 扩展的 `Navigation` 库在 Compose
    中构建的不同屏幕之间进行导航。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Analyzing lifecycle-aware components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析生命周期感知组件
- en: Using Jetpack Compose to build UIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jetpack Compose 构建用户界面
- en: By the end of the chapter, you will become familiar with how to present data
    on the UI using ViewModel and Compose.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉如何使用 ViewModel 和 Compose 在 UI 上展示数据。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Hardware and software requirements are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和软件要求如下：
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Arctic Fox 2020.3.1 补丁 3
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3lmMIOg](https://bit.ly/3lmMIOg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3lmMIOg](https://bit.ly/3lmMIOg)
- en: Analyzing lifecycle-aware components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析生命周期感知组件
- en: In this section, we will analyze the lifecycles of activities and fragments
    and the potential issues that are caused when working with them. We will also
    observe how the introduction of ViewModel and LiveData solves these problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析活动和片段的生命周期以及在使用它们时可能出现的潜在问题。我们还将观察 ViewModel 和 LiveData 的引入如何解决这些问题。
- en: When the Android operating system and its development framework were released,
    activities were the most commonly used components when developing an application,
    as they represent the entry point of the interaction between an application and
    a user. As technology in displays and resolutions improved, apps could then present
    more information and controls that the user could interact with. For developers,
    this meant that the code required to manage the logic for a single activity increased,
    especially when dealing with different layouts for landscape and portrait. The
    introduction of fragments was meant to solve some of these problems. Responsibilities
    for handling the logic in different parts of the screen could now be divided into
    different fragments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android 操作系统和其开发框架发布时，活动是开发应用程序时最常用的组件，因为它们代表了应用程序与用户之间交互的入口点。随着显示技术和分辨率的提高，应用程序可以展示更多用户可以与之交互的信息和控制。对于开发者来说，这意味着管理单个活动逻辑所需的代码量增加了，尤其是在处理横屏和竖屏的不同布局时。片段的引入旨在解决这些问题之一。处理屏幕不同部分的逻辑的责任现在可以分配到不同的片段中。
- en: The introduction of fragments, however, didn't solve all of the issues developers
    were dealing with, mainly because both activities and fragments have their own
    lifecycles. Dealing with lifecycles created the possibility of apps having context
    leaks, and the combination of lifecycles and inheritance made both activities
    and fragments hard to unit test.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，片段的引入并没有解决开发者所面临的所有问题，主要是因为活动和片段都有自己的生命周期。处理生命周期创造了应用程序出现上下文泄漏的可能性，而生命周期的组合和继承使得活动和片段都难以进行单元测试。
- en: 'The lifecycle of an activity is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的生命周期如下：
- en: '![Figure 3.1 – Activity lifecycle'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 活动生命周期'
- en: '](img/Figure_3.01_B18320.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B18320.jpg)'
- en: Figure 3.1 – Activity lifecycle
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 活动生命周期
- en: 'In *Figure 3.1*, we can see the six most well-known states of an activity:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.1* 中，我们可以看到活动最著名的六个状态：
- en: '*CREATED*: The activity enters this state when the `onCreate` method is called.
    This will be called when the system creates the activity.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建时间*: 当调用 `onCreate` 方法时，活动进入此状态。当系统创建活动时，将调用此方法。'
- en: '*STARTED*: The activity enters this state when the `onStart` method is called.
    This will be called when the activity is visible to the user.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启动*：当调用`onStart`方法时，活动进入此状态。这将在活动对用户可见时被调用。'
- en: '*RESUMED*: The activity enters this state when the `onResume` method is called.
    This will be called when the activity is in focus (the user can interact with
    it).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已恢复*：当调用`onResume`方法时，活动进入此状态。这将在活动获得焦点（用户可以与之交互）时被调用。'
- en: 'The next three states are called when the activity is no longer in focus. This
    can be caused either by the user closing the activity, putting it in the background,
    or another component gaining focus:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动不再获得焦点时，将调用以下三个状态。这可能是由于用户关闭活动、将其置于后台或另一个组件获得焦点引起的：
- en: '*PAUSED*: The activity enters this state when the `onPause` method is called.
    This will be called when the activity is visible but no longer in focus.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*暂停*：当调用`onPause`方法时，活动进入此状态。这将在活动可见但不再获得焦点时被调用。'
- en: '*STOPPED*: The activity enters this state when the `onStop` method is called.
    This will be called when the activity is no longer visible.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*停止*：当调用`onStop`方法时，活动进入此状态。这将在活动不再可见时被调用。'
- en: '*DESTROYED*: The activity enters this state when the `onDestroy` method is
    called. This will be called when the activity is destroyed by the operating system.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁*：当调用`onDestroy`方法时，活动进入此状态。这将在操作系统销毁活动时被调用。'
- en: 'When we use activities in our code, dealing with the lifecycle will look something
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中使用活动时，处理生命周期将看起来像这样：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see here that we need to extend the `Activity` class and, if we want
    to execute a particular operation in a particular state, we can override the method
    associated with the state and invoke the `super` call. This represents the main
    reason why activities are hard to unit test. The `super` calls would cause our
    test not only to invoke our code but also the parent class's code. Another reason
    activities are hard to test is because the system is the one instantiating the
    class, which means that we cannot use the constructor of the class for injection
    and must rely on setters to inject mock objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们需要扩展`Activity`类，如果我们想在特定状态下执行特定操作，我们可以覆盖与该状态相关的方法并调用`super`调用。这是活动难以进行单元测试的主要原因。`super`调用不仅会调用我们的代码，还会调用父类的代码。活动难以测试的另一个原因是系统是实例化类的，这意味着我们无法使用类的构造函数进行注入，而必须依赖于设置器来注入模拟对象。
- en: 'An important distinction should be made between the *DESTROYED* state and garbage
    collection. A *DESTROYED* activity doesn''t mean it will be garbage collected.
    A simple definition of what garbage collection means is that garbage collection
    is the process of deallocating memory that is no longer used. Each created object
    takes a certain amount of memory. When the garbage collector wants to free memory,
    it will look at objects that are no longer referenced by other objects. If we
    want to make sure that objects will be garbage collected, we will need to make
    sure that other objects that live longer than them will have no reference to the
    objects we want to be collected. In Android, we want `onDestroy` methods are called.
    This is because they tend to occupy a lot of memory and we will end up with crashes
    or bugs if we end up invoking methods after `onDestroy` is called. Leaks that
    prevent context objects from being collected are called **context leaks**. Let''s
    look at a simple example of this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在*销毁*状态和垃圾回收之间做出重要区分。一个*销毁*的活动并不意味着它将被垃圾回收。垃圾回收的简单定义是：垃圾回收是释放不再使用的内存的过程。每个创建的对象都会占用一定量的内存。当垃圾回收器想要释放内存时，它会查看那些不再被其他对象引用的对象。如果我们想确保对象将被垃圾回收，我们需要确保那些比它们存活时间长的其他对象不会引用我们想要回收的对象。在Android中，我们希望调用`onDestroy`方法。这是因为它们往往占用大量内存，如果我们调用`onDestroy`方法之后的任何方法，最终会导致崩溃或错误。防止上下文对象被回收的泄漏被称为**上下文泄漏**。让我们来看一个简单的例子：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we have a `MyManager` class in which we collect a list of `MyListener`
    that will be invoked when `performLogic` is called. Note that the `MyManager`
    class is defined using the `object` keyword. This will make the `MyManager` class
    static, which means the instance of the class will live as long as the application
    process lives. If we want an activity to listen to when the `performLogic` method
    is called, we will have something like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`MyManager`类，其中我们收集在调用`performLogic`时将被调用的`MyListener`列表。请注意，`MyManager`类是使用`object`关键字定义的。这将使`MyManager`类成为静态的，这意味着类的实例将与应用程序进程的生命周期一样长。如果我们想让活动在调用`performLogic`方法时进行监听，我们将有如下所示的内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `MyListener` is implemented in `MyActivity`, and when `onChange` is called,
    `myTextView` will be updated. The context leak occurs here when the activity is
    destroyed. As `MyActivity` is a `MyListener` and a reference to it is kept in
    `MyManager`, which lives longer, the garbage collector will not remove the `MyActivity`
    instance from memory. If `performLogic` is called after `MyActivity` is destroyed,
    we will get `NullPointerException`, because `myTextView` will be set to null;
    or, if multiple instances of `MyActivity` leak, it could potentially lead to consuming
    the entire application''s memory. A simple fix for this is to remove the reference
    to `MyActivity` when it is destroyed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyListener`在`MyActivity`中实现，当`onChange`被调用时，`myTextView`将被更新。当活动被销毁时，上下文泄露就发生在这里。由于`MyActivity`是一个`MyListener`，并且它的引用被保存在生命周期较长的`MyManager`中，垃圾收集器将不会从内存中移除`MyActivity`实例。如果在`MyActivity`被销毁后调用`performLogic`，我们将得到`NullPointerException`，因为`myTextView`将被设置为null；或者，如果多个`MyActivity`实例泄露，这可能会消耗整个应用程序的内存。对此的一个简单修复是在销毁时移除对`MyActivity`的引用：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we add a simple method to remove `MyListener` from the list and invoke
    it from the `onDestroy` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个简单的方法来从列表中移除`MyListener`并在`onDestroy`方法中调用它。
- en: Working with fragments will lead to the same type of problems as activities.
    Fragments have their own lifecycle and inherit from a parent `Fragment` class,
    which makes them vulnerable to context leaks and hard to unit test.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与片段一起工作会导致与活动相同类型的问题。片段有自己的生命周期，并从父`Fragment`类继承，这使得它们容易受到上下文泄露和难以单元测试的影响。
- en: 'The lifecycle of a fragment is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 片段的生命周期如下：
- en: '![Figure 3.2 – Fragment lifecycle'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – Fragment生命周期]'
- en: '](img/Figure_3.02_B18320.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.02_B18320.jpg]'
- en: Figure 3.2 – Fragment lifecycle
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.2 – Fragment生命周期
- en: In *Figure 3.2*, we can see that the fragment has similar lifecycle states to
    the activity. The `onAttach` and `onDetach` callbacks deal with when the fragment
    is attached to and detached from the activity. `onActivityCreated` is called when
    the activity completes its own `onCreate` call. The `onCreateView` and `onDestroyView`
    callbacks deal with inflating and destroying a fragment's views. One of the reasons
    these callbacks exist is because of the fragment back stack. This is a stack structure
    in which fragments are kept so that when the users press the *Back* button, the
    current fragment is popped out of the stack and the previous fragment is displayed.
    When fragments are replaced in the back stack, they aren't fully destroyed; just
    their views are destroyed to save memory. When they are popped back to be viewed
    by the user, they will not be re-created, and `onCreateView` will be called.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Figure 3.2*中，我们可以看到片段具有与活动相似的生命周期状态。`onAttach`和`onDetach`回调处理片段附加到和从活动中分离的情况。当活动完成其自己的`onCreate`调用时，会调用`onActivityCreated`。`onCreateView`和`onDestroyView`回调处理填充和销毁片段的视图。这些回调存在的一个原因是片段回退栈。这是一个栈结构，其中保存了片段，以便当用户按下*Back*按钮时，当前片段从栈中弹出，并显示上一个片段。当片段在回退栈中被替换时，它们不会被完全销毁；只是销毁它们的视图以节省内存。当它们被弹出以供用户查看时，它们将不会被重新创建，并且会调用`onCreateView`。
- en: 'In order to solve the problems caused by dealing with activity and fragment
    lifecycles, a set of libraries was created that are part of the `androidx.lifecycle`
    group. The `Lifecycle` class was introduced, which is responsible for keeping
    the current lifecycle state and handling transitions between lifecycle events.
    The events and states of the `Lifecycle` class would be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决处理活动和片段生命周期引起的问题，创建了一套库，这些库是`androidx.lifecycle`组的一部分。引入了`Lifecycle`类，它负责保持当前的生命周期状态和处理生命周期事件之间的转换。`Lifecycle`类的事件和状态如下：
- en: '![Figure 3.3 – Lifecycle states'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.3 – 生命周期状态]'
- en: '](img/Figure_3.03_B18320.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.03_B18320.jpg]'
- en: Figure 3.3 – Lifecycle states
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 生命周期状态
- en: In *Figure 3.3*, we can see that the `Lifecycle` class only has four states
    (*INITIALIZED*, *CREATED*, *STARTED*, and *DESTROYED*), and it will deal with
    six events (`ON_CREATE`, `ON_START`, `ON_RESUME`, `ON_PAUSE`, `ON_STOP`, and `ON_DESTROY`).
    If we wish for a certain class to be lifecycle-aware, it will need to implement
    the `LifecycleOwner` interface. Activities and fragments already implement this
    interface. We can see that for activities, the events match the existing callbacks,
    but for fragments, some changes are required to match these new events. The `onAttach`,
    `onDetach`, and `onActivityCreated` methods are deprecated, so they shouldn't
    be used with regard to the new `Lifecycle` library. The other change made for
    fragments is the introduction of a `viewLifecycleObserver` instance variable,
    which is used to handle the lifecycle between `onCreateView` and `onDestroyView`.
    This observer should be used when registering for lifecycle-aware components and
    you wish to update the UI.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.3* 中，我们可以看到 `Lifecycle` 类只有四个状态（*INITIALIZED*、*CREATED*、*STARTED* 和 *DESTROYED*），并且它将处理六个事件（`ON_CREATE`、`ON_START`、`ON_RESUME`、`ON_PAUSE`、`ON_STOP`
    和 `ON_DESTROY`）。如果我们希望某个类具有生命周期感知能力，它将需要实现 `LifecycleOwner` 接口。活动（activities）和片段（fragments）已经实现了这个接口。我们可以看到，对于活动，事件与现有的回调相匹配，但对于片段，需要一些更改以匹配这些新事件。`onAttach`、`onDetach`
    和 `onActivityCreated` 方法已被弃用，因此不应与新的 `Lifecycle` 库一起使用。对片段所做的另一个更改是引入了一个 `viewLifecycleObserver`
    实例变量，它用于处理 `onCreateView` 和 `onDestroyView` 之间的生命周期。当注册生命周期感知组件并希望更新 UI 时，应使用此观察者。
- en: In Android, when a configuration change (device rotation and language change,
    for example) occurs, then activities and fragments are re-created (the current
    instance is destroyed and a new instance will be created). This typically causes
    problems when these configuration changes occur while data is loaded or when we
    want to restore the previously loaded data. The `ViewModel` class is meant to
    solve this problem, along with the issue of testability of activities and fragments.
    A ViewModel will live until the activity or fragment it is connected to is destroyed
    and not re-created. The ViewModel comes with an `onCleared` method, which can
    be overwritten to clear any subscriptions to any pending operations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，当发生配置更改（例如设备旋转和语言更改）时，活动（activities）和片段（fragments）将被重新创建（当前实例将被销毁，并将创建一个新的实例）。这通常会在数据加载期间发生配置更改或当我们想要恢复之前加载的数据时引起问题。`ViewModel`
    类旨在解决这个问题，以及活动（activities）和片段（fragments）的可测试性问题。`ViewModel` 将一直存在，直到与之连接的活动或片段被销毁且不会被重新创建。`ViewModel`
    提供了一个 `onCleared` 方法，可以重写以清除对任何挂起操作的任何订阅。
- en: ViewModels are often paired with a class called `LiveData`. This is a lifecycle-aware
    component that observes and emits data. The combination of the two classes eliminates
    the risks of context leaks, as `LiveData` will only emit data when the observer
    is in a *STARTED* or *RESUMED* state. An additional benefit is that it will keep
    the last data held; so, in the case of a configuration change, the last data kept
    in `LiveData` will be re-emitted. This benefit allows activities and fragments
    to observe the changes and restore the UI to the way it was before they were re-created.
    In Jetpack Compose, `LiveData` isn't necessary due to Compose's own set of state
    handling classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 通常与一个名为 `LiveData` 的类配对。这是一个生命周期感知组件，用于观察和发射数据。这两个类的组合消除了上下文泄漏的风险，因为
    `LiveData` 只会在观察者在 *STARTED* 或 *RESUMED* 状态时发射数据。一个额外的优点是它会保留最后持有的数据；因此，在配置更改的情况下，`LiveData`
    中保留的最后数据将被重新发射。这个优点允许活动（activities）和片段（fragments）观察这些变化，并将 UI 恢复到它们被重新创建之前的状态。在
    Jetpack Compose 中，由于 Compose 自带的状态处理类，不需要 `LiveData`。'
- en: 'To use `ViewModel` and `LiveData`, you will need the following libraries to
    be added to `build.gradle`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ViewModel` 和 `LiveData`，您需要在 `build.gradle` 中添加以下库：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For integration with Jetpack Compose we will need the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 Jetpack Compose 集成，我们需要以下内容：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An example of a `ViewModel` and `LiveData` implementation will look something
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `ViewModel` 和 `LiveData` 实现的例子看起来可能像这样：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we extend the `ViewModel` class and define two `LiveData`
    instance variables. The `_myLiveData` variable is defined as `MutableLiveData`
    and is set to private. This is to prevent other objects from changing the values
    of `LiveData`. The `myLiveData` variable is public and can be used by `Lifecycle`
    owners to observe changes on `LiveData`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们扩展了 `ViewModel` 类并定义了两个 `LiveData` 实例变量。`_myLiveData` 变量定义为 `MutableLiveData`
    并设置为私有，这是为了防止其他对象更改 `LiveData` 的值。`myLiveData` 变量是公共的，可以被 `Lifecycle` 拥有者用来观察
    `LiveData` 的变化。
- en: 'To obtain the instance of a ViewModel in an activity or fragment, we can use
    the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要在活动或片段中获取 ViewModel 的实例，我们可以使用以下方法：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, the `viewModels` method will retrieve the instance of `MyViewModel`.
    The method provides the ability to pass along a `ViewModelProvider.Factory` object.
    This is useful in situations where we want to inject various objects in our ViewModel.
    This will look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`viewModels` 方法将检索 `MyViewModel` 的实例。此方法提供了传递 `ViewModelProvider.Factory`
    对象的能力。这在我们需要在 ViewModel 中注入各种对象的情况下很有用。这看起来可能像这样：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to observe the changes on `LiveData`, we would need to do something
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想观察 `LiveData` 的变化，我们需要做类似以下的事情：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we invoke the `observe` method, where we pass the
    activity as `LifecycleOwner` and pass a Lambda as `Observer`, which will be invoked
    when `LiveData` changes its value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们调用了 `observe` 方法，其中我们传递活动作为 `LifecycleOwner`，并传递一个 Lambda 作为 `Observer`，当
    `LiveData` 的值发生变化时，它将被调用。
- en: 'If we want to use `ViewModel` with `LiveData` in Jetpack Compose, we must do
    the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 Jetpack Compose 中使用 `ViewModel` 和 `LiveData`，我们必须做以下事情：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are using the `viewModel` method to obtain the `MyViewModel` instance.
    This method also offers the possibility of passing a `ViewModelProvider.Factory`
    instance, such as the previous `viewModel` method. The `observeAsState` extension
    method will observe changes on `LiveData` and convert them into a Compose `State`
    object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `viewModel` 方法来获取 `MyViewModel` 实例。此方法还提供了传递 `ViewModelProvider.Factory`
    实例的可能性，例如之前的 `viewModel` 方法。`observeAsState` 扩展方法将观察 `LiveData` 的变化并将它们转换为 Compose
    的 `State` 对象。
- en: In this section, we have discussed how lifecycles work in activities and fragments
    and the problems developers have when dealing with them. We have analyzed how
    the lifecycle-aware components (such as ViewModel and LiveData) solved these problems.
    The `ViewModel` class itself represents an implementation of the **Model-View
    ViewModel** (**MVVM**) pattern, which will be discussed in a future chapter. In
    the next section, we will look at an exercise in which we will use both ViewModel
    and LiveData and combine them with Kotlin flows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了活动（activities）和片段（fragments）的生命周期如何工作，以及开发者处理它们时遇到的问题。我们分析了生命周期感知组件（如
    ViewModel 和 LiveData）是如何解决这些问题的。`ViewModel` 类本身代表了对 **模型-视图-ViewModel**（**MVVM**）模式的实现，这将在未来的章节中讨论。在下一节中，我们将查看一个练习，我们将使用
    ViewModel 和 LiveData，并将它们与 Kotlin 流结合起来。
- en: Exercise 3.1 – Using ViewModel and LiveData
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.1 – 使用 ViewModel 和 LiveData
- en: 'Modify *Exercise 2.5* from [*Chapter 2*](B18320_02_ePub.xhtml#_idTextAnchor038),
    *Deep Diving into Data Sources*, so that the state of the UI is kept in a `LiveData`
    object inside `MainViewModel`, instead of using the Compose `State` object, and
    display `"Total request count: x"`, where `x` is the number of requests at the
    top of the list.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '修改 *第 2.5 章* 的 *练习 2.5*，即 [*第 2 章*](B18320_02_ePub.xhtml#_idTextAnchor038)，*深入数据源*，以便将
    UI 的状态保存在 `MainViewModel` 内部的 `LiveData` 对象中，而不是使用 Compose 的 `State` 对象，并显示 `"Total
    request count: x"`，其中 `x` 是列表顶部的请求数量。'
- en: 'To complete the exercise, you will need to build the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，你需要构建以下内容：
- en: Add the specified text in `strings.xml`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `strings.xml` 中添加指定的文本。
- en: 'Create a `MainTextFormatter` class that will have one method that will return
    the `"Total request count: x"` text.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '创建一个 `MainTextFormatter` 类，它将有一个返回 `"Total request count: x"` 文本的方法。'
- en: Add a dependency to `MainTextFormatter` in `MainViewModel`, and pass the formatted
    text as a value for the `UiState.count` object.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `MainViewModel` 中添加对 `MainTextFormatter` 的依赖，并将格式化后的文本作为值传递给 `UiState.count`
    对象。
- en: Remove `resultState` and replace it with a `LiveData` object.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `resultState` 并用 `LiveData` 对象替换它。
- en: Update the `@Composable` functions to use `LiveData`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 `@Composable` 函数以使用 `LiveData`。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'Add the `LiveData` extension library for Jetpack Compose to `app/build.gradle`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Jetpack Compose 的 `LiveData` 扩展库添加到 `app/build.gradle`：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `"Total request count"` text in `strings.xml`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `strings.xml` 中添加 `"Total request count"` 文本：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the `MainTextFormatter` class as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建 `MainTextFormatter` 类：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reason we created this class is to prevent possible context leaks by having
    a `Context` object inside the `MainViewModel` class. Here, we have a method that
    will take a count as a parameter and return the required text.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建这个类的原因是为了防止 `MainViewModel` 类内部可能出现的上下文泄漏，通过在 `MainViewModel` 类中包含一个 `Context`
    对象。在这里，我们有一个方法，它将计数作为参数并返回所需的文本。
- en: 'Inject `MainTextFormatter` in `MainViewModel` and use the formatted text as
    a value for the `UiState.count` object:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainViewModel` 中注入 `MainTextFormatter` 并使用格式化文本作为 `UiState.count` 对象的值：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, create the instance of the `MainTextFormatter` class in the `MyApplication`
    class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `MyApplication` 类中创建 `MainTextFormatter` 类的实例：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, update `MainViewModelFactory` to use `MainTextFormatter`, which was just
    created, and pass it into `MainViewModel`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `MainViewModelFactory` 以使用刚刚创建的 `MainTextFormatter`，并将其传递给 `MainViewModel`：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add `LiveData` to `MainViewModel`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `LiveData` 添加到 `MainViewModel`：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we have defined the two `LiveData` variables, one to update the value
    and the other to be observed, and in the `collect` method, we update the value
    of `LiveData`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了两个 `LiveData` 变量，一个用于更新值，另一个用于观察，并在 `collect` 方法中更新 `LiveData` 的值。
- en: 'In `MainActivity`, update the `@Composable` functions to use `LiveData`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，更新 `@Composable` 函数以使用 `LiveData`：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we call the `observeAsState` extension method on `LiveData` from `MainViewModel`,
    and then call the `UserList` method, which will redraw the UI for each new value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用来自 `MainViewModel` 的 `LiveData` 的 `observeAsState` 扩展方法，然后调用 `UserList`
    方法，这将针对每个新值重新绘制 UI。
- en: '![Figure 3.4 – Output of Exercise 3.1'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 练习 3.1 的输出'
- en: '](img/Figure_3.04_B18320.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B18320.jpg)'
- en: Figure 3.4 – Output of Exercise 3.1
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 练习 3.1 的输出
- en: 'If we run the application, we will see the same list of users, and at the top,
    we will see `"Total request count: x"` instead of just the `x` character that
    was there before, as shown in *Figure 3.4*. In this exercise, we used Jetpack
    Compose for rendering the UI. In the section that follows, we will analyze how
    Android handles UIs and go more in-depth into the Jetpack Compose framework.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们运行应用程序，我们将看到相同的用户列表，在顶部，我们将看到 `"Total request count: x"` 而不是之前仅有的 `x` 字符，如图
    3.4 所示。在这个练习中，我们使用了 Jetpack Compose 来渲染 UI。在接下来的部分中，我们将分析 Android 如何处理 UI，并更深入地探讨
    Jetpack Compose 框架。'
- en: Using Jetpack Compose to build UIs
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jetpack Compose 构建 UI
- en: 'In this section, we will analyze how to build UIs for Android applications
    using the `View` hierarchy and look at the implications this has for applications.
    We will then look at how Jetpack Compose simplifies and changes how UIs are built
    and how we can use Compose to create UIs. We will be looking at Jetpack Compose
    with the view of how we can integrate it with other libraries and how to build
    a simple UI. For more information on how to build more complex UIs, you can refer
    to the official documentation found here: [https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析如何使用 `View` 层次结构构建 Android 应用程序的 UI，并探讨这对应用程序的影响。然后，我们将探讨 Jetpack
    Compose 如何简化并改变 UI 的构建方式，以及我们如何使用 Compose 创建 UI。我们将从如何与其他库集成以及如何构建简单 UI 的角度来探讨
    Jetpack Compose。有关如何构建更复杂 UI 的更多信息，您可以参考以下官方文档：[https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose)。
- en: 'The way Android deals with UIs is through the `View` hierarchy. The subclasses
    of `View` deal with specific UI components that the user can interact with. The
    hierarchy looks similar to the following diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Android 处理 UI 的方式是通过 `View` 层次结构。`View` 的子类处理用户可以与之交互的特定 UI 组件。层次结构看起来类似于以下图表：
- en: '![Figure 3.5 – View hierarchy'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 视图层次结构'
- en: '](img/Figure_3.05_B18320.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B18320.jpg)'
- en: Figure 3.5 – View hierarchy
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 视图层次结构
- en: The `TextView` class deals with displaying text on the screen, `EditText` deals
    with handling text inputted by the user, and `Button` deals with rendering buttons
    on the screen. A specialized subclass of `View` is the `ViewGroup` class. This
    represents the base class for various layout classes that are responsible for
    how the views are grouped and arranged on the screen. Here, we find classes such
    as `LinearLayout` (which groups views one after the other either vertically or
    horizontally), `RelativeLayout` (which groups the views relative to the parent
    or to each other), or more recently, `ConstraintLayout`, which offers various
    ways to position views however we desire without creating many nested layouts
    (because it was bad for performance), which is why it became commonly used. When
    it comes to dealing with displaying lists of items of unknown lengths, objects
    such as `ListView` and `RecyclerView` are used. Both require creating adapters
    that will be responsible for pairing an object from a list with an associated
    `View` to render a row in the list in the UI.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextView` 类用于在屏幕上显示文本，`EditText` 用于处理用户输入的文本，`Button` 用于在屏幕上渲染按钮。`ViewGroup`
    类是一个专门的子类。它代表负责在屏幕上对视图进行分组和排列的各种布局类的基类。在这里，我们可以找到如 `LinearLayout`（按垂直或水平顺序依次分组视图）、`RelativeLayout`（相对于父视图或彼此分组视图）或更近期的
    `ConstraintLayout` 类，它提供了各种方式来定位视图，而无需创建许多嵌套布局（因为它对性能不利），这就是为什么它变得非常普遍。当处理未知长度的项目列表时，会使用如
    `ListView` 和 `RecyclerView` 这样的对象。两者都需要创建适配器，适配器将负责将列表中的对象与相关的 `View` 配对，以便在 UI
    中渲染列表中的行。'
- en: Using `ListViews` is prone to inefficiencies caused when scrolling where views
    are recreated for each new row, so in a long list of items, a lot of views would
    be created and then garbage collected. To solve this, developers had to implement
    a pattern called a `RecyclerView` addresses this issue so the adapter `RecyclerView`
    uses requires `ViewHolder`. This means that if a user views a list of 100 items
    and 10 are visible on the screen, for the 10 that are visible on the screen there
    would be 10 views to represent each row. When the user scrolls down, the 10 views
    that were created at the beginning would then display the items for the currently
    visible items. Developers can also create custom views by extending any of the
    existing `View` classes. This is useful when certain UI components have to be
    re-used in different activities, fragments, or other custom views.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ListViews` 容易因为滚动时为每一行重新创建视图而造成效率低下，因此在长列表中会创建大量视图，然后被垃圾回收。为了解决这个问题，开发者必须实现一个名为
    `RecyclerView` 的模式，该模式通过使用 `ViewHolder` 来解决此问题。这意味着如果用户查看包含 100 项的列表，并且屏幕上有 10
    项可见，那么在屏幕上可见的 10 项将会有 10 个视图来表示每一行。当用户向下滚动时，最初创建的 10 个视图将显示当前可见项的内容。开发者还可以通过扩展任何现有的
    `View` 类来创建自定义视图。这在某些 UI 组件需要在不同的活动、片段或其他自定义视图中重复使用时非常有用。
- en: 'To display these views to the user, we would need to use activities and fragments.
    For activities, this would require invoking the `setContentView` method in the
    `onCreate` method, and in fragments, we would need to return a `View` object in
    the `onCreateView` method. We have the possibility of creating the entire layout
    for an activity or fragment in Java or Kotlin, but this would lead to a lot of
    code being written. This, and the fact that we can have different layouts for
    different screen sizes or device rotation, led to using the `res/layout` folder,
    in which we can specify how a layout might look. An example of how this might
    look is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户显示这些视图，我们需要使用活动和片段。对于活动，这需要在 `onCreate` 方法中调用 `setContentView` 方法，而在片段中，我们需要在
    `onCreateView` 方法中返回一个 `View` 对象。我们可以在 Java 或 Kotlin 中创建活动或片段的整个布局，但这会导致编写大量代码。此外，我们可以为不同的屏幕尺寸或设备旋转使用不同的布局，这导致了使用
    `res/layout` 文件夹，在其中我们可以指定布局可能的外观。以下是一个示例：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding example, we define `ConstraintLayout`, which contains only
    `TextView` that displays a `"Hello World"` text. To obtain a reference to `TextView`
    to allow us to change the text because of an action or data being loaded, we would
    need to use the `findViewById` method from either the `Activity` class or the
    `View` class. This would look something like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了 `ConstraintLayout`，它只包含显示 `"Hello World"` 文本的 `TextView`。为了获取
    `TextView` 的引用，以便我们可以在动作或数据加载时更改文本，我们需要使用来自 `Activity` 类或 `View` 类的 `findViewById`
    方法。这看起来可能如下所示：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This approach would lead to possible crashes within an application. Developers
    would need to make sure that when a layout was set for `Activity` or `Fragment`
    and `findViewById` was used, then the view was added to the `layout` file. With
    the introduction of Kotlin, this was initially addressed through the Kotlin Synthetics
    framework, which generated extensions for the declared views in a layout. Kotlin
    Synthetics would generate an extension for a View's `android:id` XML tag, which
    would be accessible in the code. Later, this was replaced with `ViewBinding`.
    When `ViewBinding` is used in a project, a class is generated for each layout
    that will hold references to all the views in the layout, eliminating potential
    crashes related to `findViewById`. All these approaches with regard to creating
    your UI are defined as **imperative** because we need to specify the views that
    our interface uses and control how we update the views when data is changed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能会导致应用程序中的崩溃。开发者需要确保当为`Activity`或`Fragment`设置布局并使用`findViewById`时，视图被添加到布局文件中。随着Kotlin的引入，这最初是通过Kotlin
    Synthetics框架解决的，该框架为布局中声明的视图生成扩展。Kotlin Synthetics会为View的`android:id` XML标签生成一个扩展，这在代码中是可访问的。后来，这被`ViewBinding`所取代。当在项目中使用`ViewBinding`时，会为每个布局生成一个类，该类将持有布局中所有视图的引用，消除了与`findViewById`相关的潜在崩溃。所有这些关于创建UI的方法都被定义为**命令式**，因为我们需要指定界面使用的视图，并控制当数据更改时如何更新视图。
- en: 'An alternative approach to this is the `View` hierarchy and instead use `@Composable`
    functions, in which we specify what we want to display on the screen without thinking
    of how we need to display it, and we can also create the UI using Kotlin using
    less code than we would normally. In Compose, the `Hello World` example would
    look something like the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`View`层次结构，而不是使用`@Composable`函数，在`@Composable`函数中，我们指定我们想在屏幕上显示的内容，而不需要考虑如何显示它，我们还可以使用Kotlin以比通常更少的代码创建UI。在Compose中，`Hello
    World`示例可能如下所示：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we want to update the text because of a change in data, we will need to
    use `State` objects from the `Compose` library. Compose will observe these states
    and, when the values are changed, Compose will redraw the UI associated with that
    state. An example of this is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想因为数据的变化而更新文本，我们需要使用`Compose`库中的`State`对象。Compose会观察这些状态，当值发生变化时，Compose会重新绘制与该状态关联的UI。以下是一个例子：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, when the text is clicked, the `0` character is appended to
    the text and the UI is updated. This is because of the use of `mutableStateOf`.
    The `remember` method is needed because this state is kept inside a `@Composable`
    function, and it is used to keep the state intact while recomposition happens
    (the UI is redrawn). To make the text clickable, we needed to change from `Text`
    to `ClickableText`. The reason we are using two `@Composable` functions is that
    we want to keep the `@Composable` functions as re-usable as possible. This is
    called `HelloWorld`) components from the stateless components (`ShowText`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当文本被点击时，`0` 字符会被添加到文本中，并且UI会更新。这是因为使用了`mutableStateOf`。需要`remember`方法是因为这个状态被保存在一个`@Composable`函数内部，并且它用于在重新组合发生时（UI被重新绘制）保持状态完整。为了使文本可点击，我们需要将`Text`改为`ClickableText`。我们使用两个`@Composable`函数的原因是我们希望尽可能使`@Composable`函数可重用。这被称为`HelloWorld`组件从无状态组件（`ShowText`）。
- en: 'When it comes to rendering lists of items, Compose offers a simple way of rendering
    them in the form of `Column` (for when the length of the list is known and short),
    and `LazyColumn` (when the list of items is unknown and could potentially be long).
    An example of this is from *Exercise 3.1*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到渲染项目列表时，Compose提供了一个简单的方法以`Column`（当列表长度已知且较短时）和`LazyColumn`（当项目列表未知且可能很长时）的形式渲染它们。以下是一个来自*练习3.1*的例子：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we display a header at the top of the item list, and we use another column
    to set the padding for the row; then, we display the entire list of items with
    the use of the `items` function, and for each row, we set the padding and display
    a group with three texts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在项目列表的顶部显示一个标题，然后我们使用另一个列来设置行的填充；然后，我们使用`items`函数显示整个项目列表，并为每一行设置填充并显示一个包含三个文本的组。
- en: 'If we want to display input fields and buttons, then we can look at how we
    implemented the UI in *Exercise 2.1*, from [*Chapter 2*](B18320_02_ePub.xhtml#_idTextAnchor038),
    *Deep Diving into Data Sources*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要显示输入字段和按钮，我们可以查看我们在*练习2.1*中如何实现UI，见[*第2章*](B18320_02_ePub.xhtml#_idTextAnchor038)，*深入数据源*：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we used `OutlinedTextField` to render the equivalent of `TextInputLayout`.
    We could have used `TextField` if we wanted the equivalent of a simple `EditText`.
    For displaying a button, we can use the `Button` method, which uses `Text` for
    rendering the text on the button.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`OutlinedTextField`来渲染相当于`TextInputLayout`的效果。如果我们想要相当于简单的`EditText`，我们可以使用`TextField`。对于显示按钮，我们可以使用`Button`方法，该方法使用`Text`来渲染按钮上的文本。
- en: 'Compose also has integrations with other libraries, such as `ViewModel` and
    `LiveData`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Compose还与其他库集成，例如`ViewModel`和`LiveData`：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we can pass `ViewModel` as a parameter in our `Composable` function and
    use the `observeAsState` function to convert `LiveData` into a `State` object,
    which will then be observed by Compose to redraw the UI. Compose also supports
    integration with the `Hilt` library. When Hilt is added to a project, then there
    is no need to specify `Factory` for the ViewModel.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以将`ViewModel`作为参数传递到我们的`Composable`函数中，并使用`observeAsState`函数将`LiveData`转换为`State`对象，然后由Compose观察以重新绘制UI。Compose还支持与`Hilt`库的集成。当Hilt添加到项目中时，则无需为ViewModel指定`Factory`。
- en: 'Another important feature of Compose is how it deals with navigation between
    different screens. The Compose navigation is built upon the `androidx.navigation`
    library. This allows Compose to use the `NavHost` and `NavController` components
    to navigate between different screens. The screens are built using Compose, which
    means that an application using only Compose would ideally have only one activity.
    This eliminates any potential problems regarding activity and fragment lifecycles.
    To introduce navigation into a project, the following library is required:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Compose的另一个重要特性是它如何处理不同屏幕之间的导航。Compose导航建立在`androidx.navigation`库之上。这使得Compose可以使用`NavHost`和`NavController`组件在屏幕之间导航。屏幕是用Compose构建的，这意味着仅使用Compose的应用程序理想情况下只有一个活动。这消除了与活动和片段生命周期相关的任何潜在问题。要将导航引入项目，需要以下库：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we want to navigate from one screen to another, we will need to obtain `NavHostController`
    and pass it into a `@Composable` method that will represent the structure of the
    application:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要从一个屏幕导航到另一个屏幕，我们需要获取`NavHostController`并将其传递给一个表示应用程序结构的`@Composable`方法：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `AppNavigation` `@Composable` method will look something like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppNavigation` `@Composable`方法看起来可能如下所示：'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In `AppNavigation`, we invoke the `NavHost` `@Composable` function in which
    we will place the screens of the application along with a route to each of them.
    In this case, `Screen1` will have a simple route to navigate to and `Screen2`
    will require an argument when it is navigated to indicated through the `{param}`
    notation. For arguments, we will need to specify the type of the argument. In
    this case, it will be `String`, and `NavType.StringType` indicates this. If we
    wish to pass more complex arguments, then we will need to supply our own custom
    types and indicate how they should be serialized and deserialized. When we want
    to navigate from `Screen1` to `Screen2`, then we will need to do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppNavigation`中，我们调用`NavHost` `@Composable`函数，在其中我们将放置应用程序的屏幕以及每个屏幕的路径。在这种情况下，`Screen1`将有一个简单的路径用于导航，而`Screen2`在导航到时会需要一个参数，通过`{param}`表示法来指示。对于参数，我们需要指定参数的类型。在这种情况下，它将是`String`，`NavType.StringType`表示这一点。如果我们希望传递更复杂的参数，那么我们需要提供我们自己的自定义类型，并指示它们应该如何序列化和反序列化。当我们想要从`Screen1`导航到`Screen2`时，我们需要做以下操作：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When `Column` is clicked in `Screen1`, it will invoke `NavController` to navigate
    to `Screen2` and pass the `test` argument. `Screen2` will look like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Screen1`中点击`Column`时，它将调用`NavController`导航到`Screen2`并传递`test`参数。`Screen2`看起来如下所示：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Screen2` will use the text extracted from `it.arguments?.getString("param").orEmpty()`
    and it will display it on the UI.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Screen2`将使用从`it.arguments?.getString("param").orEmpty()`提取的文本，并在UI上显示它。'
- en: In this section, we have discussed how Android deals with UIs. We have looked
    over the imperative approach and then introduced the declarative approach for
    Uis. We have analyzed the Jetpack Compose library and the problems it attempts
    to solve, such as less code and no XML declarations for layouts. It follows the
    principles of libraries from other technologies (such as React and SwiftUI) and
    shows how UIs can be built from a functional programming point of view. In the
    next section, we will look at an exercise for how we can use Compose to navigate
    between two screens in an application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了 Android 如何处理 UI。我们回顾了命令式方法，然后介绍了 Uis 的声明式方法。我们分析了 Jetpack Compose
    库以及它试图解决的问题，例如更少的代码和不需要 XML 布局声明。它遵循来自其他技术（如 React 和 SwiftUI）的库的原则，并展示了从函数式编程的角度如何构建
    UI。在下一节中，我们将查看如何使用 Compose 在应用程序的两个屏幕之间导航的练习。
- en: Exercise 3.2 – Navigating using Jetpack Compose
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.2 – 使用 Jetpack Compose 导航
- en: Modify *Exercise 3.1* so that the current `@Composable` functions are moved
    into a new file named `UserListScreen`, then create a new file with new `@Composable`
    functions that will render a simple text called `UserScreen`. When a user from
    the list is clicked, the new screen is opened and it will display the name of
    the user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *练习 3.1*，将当前的 `@Composable` 函数移动到一个名为 `UserListScreen` 的新文件中，然后创建一个包含新 `@Composable`
    函数的新文件，这些函数将渲染一个简单的文本 `UserScreen`。当列表中的用户被点击时，新屏幕将被打开，并显示用户的姓名。
- en: 'To complete the exercise, you will need to build the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，你需要构建以下内容：
- en: Create an `AppNavigation` sealed class that will have two variables. The first
    variable, named `route`, will be `String` and the second variable, named `argumentName`,
    will be `String` and default to `empty`. Two subclasses of `AppNavigation` will
    be `Users` (which will set the route variable to `"users"`) and `User` (which
    will set the route to `"users/{name}"`, then `argumentName` to `name`, and a method
    to create the route for a specific name).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AppNavigation` 的密封类，它将有两个变量。第一个变量，名为 `route`，将是 `String` 类型，第二个变量，名为
    `argumentName`，也将是 `String` 类型，默认为 `empty`。`AppNavigation` 的两个子类将是 `Users`（将 `route`
    变量设置为 `"users"`) 和 `User`（将 `route` 设置为 `"users/{name}"`，然后 `argumentName` 设置为
    `name`，并有一个创建特定名称路由的方法）。
- en: In `MainActivity`, rename the screen `@Composable` function to `Users`, and
    using the `NavController` object, set up a click listener on the list row and
    navigate to the route from the `User` class in `AppNavigation`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，将屏幕 `@Composable` 函数重命名为 `Users`，并使用 `NavController` 对象在列表行上设置点击监听器，导航到
    `AppNavigation` 中的 `User` 类的路由。
- en: Create a new `@Composable` function named `User`, which will be responsible
    for showing a simple `Text` and will have the text displayed as a parameter.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `User` 的新 `@Composable` 函数，它将负责显示简单的 `Text`，并将文本作为参数显示。
- en: In `MainActivity`, create a `@Composable` function named `MainApplication`,
    which will use the `NavHost` `@Composable` function to link the navigation between
    the two screens.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，创建一个名为 `MainApplication` 的 `@Composable` 函数，它将使用 `NavHost`
    `@Composable` 函数在两个屏幕之间建立导航链接。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'Add the `navigation` library for Compose in `app/build.gradle`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/build.gradle` 中添加 Compose 的 `navigation` 库：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create the `AppNavigation` class, which will hold the information for the routes
    and arguments for each of our screens:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `AppNavigation` 类，它将保存每个屏幕的路由和参数信息：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As the navigation relies on URLs to identify the different screens, we can take
    advantage of sealed classes and objects in Kotlin to keep track of the required
    inputs for each screen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导航依赖于 URL 来识别不同的屏幕，我们可以利用 Kotlin 中的密封类和对象来跟踪每个屏幕所需的输入。
- en: 'Rename the screen `@Composable` function to `Users` in `MainActivity` and add
    `NavController` as a parameter:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MainActivity` 中的屏幕 `@Composable` 函数重命名为 `Users` 并添加 `NavController` 作为参数：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, pass the `NavController` parameter to `UserList` and implement the click
    listener for the user row:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `NavController` 参数传递给 `UserList` 并实现用户行的事件监听器：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the `User` `@Composable` function in `MainActivity`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中创建 `User` `@Composable` 函数：
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, create an `App` `@Composable` function that will use `NavHost` to set
    up the navigation between the two screens in `MainActivity`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个使用 `NavHost` 在 `MainActivity` 中设置两个屏幕之间导航的 `App` `@Composable` 函数：
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, invoke the `App` function when the `Activity` content is set in `MainActivity`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当在 `MainActivity` 中设置 `Activity` 内容时，调用 `App` 函数：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 3.6 – Output of Exercise 3.2'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 练习 3.2 的输出'
- en: '](img/Figure_3.06_B18320.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.06_B18320](img/Figure_3.06_B18320.jpg)'
- en: Figure 3.6 – Output of Exercise 3.2
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 练习 3.2 的输出
- en: If we run the application, we should see the same list of users as before, and
    if we click on a user, it will transition to a new screen that will display the
    selected user's name, as shown in *Figure 3.6*. If we press the *Back* button,
    we should see the initial list of users; that's because, by default, the `navigation`
    library handles back navigation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们应该看到之前相同的用户列表，如果我们点击一个用户，它将过渡到一个新的屏幕，该屏幕将显示所选用户的姓名，如图 *图 3.6* 所示。如果我们按下
    *返回* 按钮，我们应该看到初始的用户列表；这是因为默认情况下，`navigation` 库处理返回导航。
- en: In this exercise, we have analyzed how we can use Jetpack Compose to navigate
    between two screens in an application. In future chapters, we will revisit navigation
    when we must navigate between different screens in different modules.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们分析了如何使用 Jetpack Compose 在应用程序中在两个屏幕之间进行导航。在未来的章节中，当我们必须在不同的模块之间导航到不同的屏幕时，我们将重新审视导航。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have analyzed how data can be presented in Android and discussed
    the libraries we have available now. We have looked at Android lifecycles and
    the potential issues that applications could have regarding lifecycles and then
    looked at how libraries such as `ViewModel` and `LiveData` solve most of these
    problems. We then looked at how the UI works in Android and how we would need
    to deal with using XML to define layouts in which we would insert the views that
    the layouts needed to display, and how we would need to update the state of the
    views when the data changes. We then looked at how Jetpack Compose solves these
    issues in a declarative functional way. We built upon the exercises in the previous
    chapter to show how we can integrate multiple libraries in a single application
    and display data from the internet.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了如何在 Android 中展示数据，并讨论了我们现在可用的库。我们探讨了 Android 生命周期以及应用程序可能面临的与生命周期相关的问题，然后探讨了库如
    `ViewModel` 和 `LiveData` 如何解决这些问题的大部分。然后我们研究了 Android 中 UI 的工作方式以及我们需要如何处理使用 XML
    定义布局，在这些布局中我们会插入需要显示的视图，以及当数据发生变化时我们需要如何更新视图的状态。然后我们研究了 Jetpack Compose 如何以声明式函数式的方式解决这些问题。我们基于上一章的练习来展示如何在单个应用程序中集成多个库并显示来自互联网的数据。
- en: In the next chapter, we will deal with managing the dependencies inside an application
    and the libraries available for doing so.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理管理应用程序内部的依赖关系以及可用于此目的的库。
