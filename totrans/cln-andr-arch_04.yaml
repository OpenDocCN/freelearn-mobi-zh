- en: '*Chapter 3*: Understanding Data Presentation on Android'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will study the libraries available for presenting data on
    the `ViewModel` and `Lifecycle` libraries. We will then move on to analyze aspects
    of how the UI works and look at how the Jetpack Compose library revolutionized
    building UIs through its declarative approach. Finally, we will look at how we
    can navigate between different screens that are built in Compose by using the
    `Navigation` library with the `Compose` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing lifecycle-aware components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jetpack Compose to build UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will become familiar with how to present data
    on the UI using ViewModel and Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hardware and software requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3lmMIOg](https://bit.ly/3lmMIOg)'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing lifecycle-aware components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will analyze the lifecycles of activities and fragments
    and the potential issues that are caused when working with them. We will also
    observe how the introduction of ViewModel and LiveData solves these problems.
  prefs: []
  type: TYPE_NORMAL
- en: When the Android operating system and its development framework were released,
    activities were the most commonly used components when developing an application,
    as they represent the entry point of the interaction between an application and
    a user. As technology in displays and resolutions improved, apps could then present
    more information and controls that the user could interact with. For developers,
    this meant that the code required to manage the logic for a single activity increased,
    especially when dealing with different layouts for landscape and portrait. The
    introduction of fragments was meant to solve some of these problems. Responsibilities
    for handling the logic in different parts of the screen could now be divided into
    different fragments.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of fragments, however, didn't solve all of the issues developers
    were dealing with, mainly because both activities and fragments have their own
    lifecycles. Dealing with lifecycles created the possibility of apps having context
    leaks, and the combination of lifecycles and inheritance made both activities
    and fragments hard to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifecycle of an activity is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Activity lifecycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Activity lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3.1*, we can see the six most well-known states of an activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '*CREATED*: The activity enters this state when the `onCreate` method is called.
    This will be called when the system creates the activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*STARTED*: The activity enters this state when the `onStart` method is called.
    This will be called when the activity is visible to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RESUMED*: The activity enters this state when the `onResume` method is called.
    This will be called when the activity is in focus (the user can interact with
    it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next three states are called when the activity is no longer in focus. This
    can be caused either by the user closing the activity, putting it in the background,
    or another component gaining focus:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PAUSED*: The activity enters this state when the `onPause` method is called.
    This will be called when the activity is visible but no longer in focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*STOPPED*: The activity enters this state when the `onStop` method is called.
    This will be called when the activity is no longer visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DESTROYED*: The activity enters this state when the `onDestroy` method is
    called. This will be called when the activity is destroyed by the operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we use activities in our code, dealing with the lifecycle will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that we need to extend the `Activity` class and, if we want
    to execute a particular operation in a particular state, we can override the method
    associated with the state and invoke the `super` call. This represents the main
    reason why activities are hard to unit test. The `super` calls would cause our
    test not only to invoke our code but also the parent class's code. Another reason
    activities are hard to test is because the system is the one instantiating the
    class, which means that we cannot use the constructor of the class for injection
    and must rely on setters to inject mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important distinction should be made between the *DESTROYED* state and garbage
    collection. A *DESTROYED* activity doesn''t mean it will be garbage collected.
    A simple definition of what garbage collection means is that garbage collection
    is the process of deallocating memory that is no longer used. Each created object
    takes a certain amount of memory. When the garbage collector wants to free memory,
    it will look at objects that are no longer referenced by other objects. If we
    want to make sure that objects will be garbage collected, we will need to make
    sure that other objects that live longer than them will have no reference to the
    objects we want to be collected. In Android, we want `onDestroy` methods are called.
    This is because they tend to occupy a lot of memory and we will end up with crashes
    or bugs if we end up invoking methods after `onDestroy` is called. Leaks that
    prevent context objects from being collected are called **context leaks**. Let''s
    look at a simple example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a `MyManager` class in which we collect a list of `MyListener`
    that will be invoked when `performLogic` is called. Note that the `MyManager`
    class is defined using the `object` keyword. This will make the `MyManager` class
    static, which means the instance of the class will live as long as the application
    process lives. If we want an activity to listen to when the `performLogic` method
    is called, we will have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `MyListener` is implemented in `MyActivity`, and when `onChange` is called,
    `myTextView` will be updated. The context leak occurs here when the activity is
    destroyed. As `MyActivity` is a `MyListener` and a reference to it is kept in
    `MyManager`, which lives longer, the garbage collector will not remove the `MyActivity`
    instance from memory. If `performLogic` is called after `MyActivity` is destroyed,
    we will get `NullPointerException`, because `myTextView` will be set to null;
    or, if multiple instances of `MyActivity` leak, it could potentially lead to consuming
    the entire application''s memory. A simple fix for this is to remove the reference
    to `MyActivity` when it is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a simple method to remove `MyListener` from the list and invoke
    it from the `onDestroy` method.
  prefs: []
  type: TYPE_NORMAL
- en: Working with fragments will lead to the same type of problems as activities.
    Fragments have their own lifecycle and inherit from a parent `Fragment` class,
    which makes them vulnerable to context leaks and hard to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifecycle of a fragment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Fragment lifecycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Fragment lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3.2*, we can see that the fragment has similar lifecycle states to
    the activity. The `onAttach` and `onDetach` callbacks deal with when the fragment
    is attached to and detached from the activity. `onActivityCreated` is called when
    the activity completes its own `onCreate` call. The `onCreateView` and `onDestroyView`
    callbacks deal with inflating and destroying a fragment's views. One of the reasons
    these callbacks exist is because of the fragment back stack. This is a stack structure
    in which fragments are kept so that when the users press the *Back* button, the
    current fragment is popped out of the stack and the previous fragment is displayed.
    When fragments are replaced in the back stack, they aren't fully destroyed; just
    their views are destroyed to save memory. When they are popped back to be viewed
    by the user, they will not be re-created, and `onCreateView` will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve the problems caused by dealing with activity and fragment
    lifecycles, a set of libraries was created that are part of the `androidx.lifecycle`
    group. The `Lifecycle` class was introduced, which is responsible for keeping
    the current lifecycle state and handling transitions between lifecycle events.
    The events and states of the `Lifecycle` class would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Lifecycle states'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Lifecycle states
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3.3*, we can see that the `Lifecycle` class only has four states
    (*INITIALIZED*, *CREATED*, *STARTED*, and *DESTROYED*), and it will deal with
    six events (`ON_CREATE`, `ON_START`, `ON_RESUME`, `ON_PAUSE`, `ON_STOP`, and `ON_DESTROY`).
    If we wish for a certain class to be lifecycle-aware, it will need to implement
    the `LifecycleOwner` interface. Activities and fragments already implement this
    interface. We can see that for activities, the events match the existing callbacks,
    but for fragments, some changes are required to match these new events. The `onAttach`,
    `onDetach`, and `onActivityCreated` methods are deprecated, so they shouldn't
    be used with regard to the new `Lifecycle` library. The other change made for
    fragments is the introduction of a `viewLifecycleObserver` instance variable,
    which is used to handle the lifecycle between `onCreateView` and `onDestroyView`.
    This observer should be used when registering for lifecycle-aware components and
    you wish to update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In Android, when a configuration change (device rotation and language change,
    for example) occurs, then activities and fragments are re-created (the current
    instance is destroyed and a new instance will be created). This typically causes
    problems when these configuration changes occur while data is loaded or when we
    want to restore the previously loaded data. The `ViewModel` class is meant to
    solve this problem, along with the issue of testability of activities and fragments.
    A ViewModel will live until the activity or fragment it is connected to is destroyed
    and not re-created. The ViewModel comes with an `onCleared` method, which can
    be overwritten to clear any subscriptions to any pending operations.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModels are often paired with a class called `LiveData`. This is a lifecycle-aware
    component that observes and emits data. The combination of the two classes eliminates
    the risks of context leaks, as `LiveData` will only emit data when the observer
    is in a *STARTED* or *RESUMED* state. An additional benefit is that it will keep
    the last data held; so, in the case of a configuration change, the last data kept
    in `LiveData` will be re-emitted. This benefit allows activities and fragments
    to observe the changes and restore the UI to the way it was before they were re-created.
    In Jetpack Compose, `LiveData` isn't necessary due to Compose's own set of state
    handling classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `ViewModel` and `LiveData`, you will need the following libraries to
    be added to `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For integration with Jetpack Compose we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a `ViewModel` and `LiveData` implementation will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we extend the `ViewModel` class and define two `LiveData`
    instance variables. The `_myLiveData` variable is defined as `MutableLiveData`
    and is set to private. This is to prevent other objects from changing the values
    of `LiveData`. The `myLiveData` variable is public and can be used by `Lifecycle`
    owners to observe changes on `LiveData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the instance of a ViewModel in an activity or fragment, we can use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `viewModels` method will retrieve the instance of `MyViewModel`.
    The method provides the ability to pass along a `ViewModelProvider.Factory` object.
    This is useful in situations where we want to inject various objects in our ViewModel.
    This will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to observe the changes on `LiveData`, we would need to do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we invoke the `observe` method, where we pass the
    activity as `LifecycleOwner` and pass a Lambda as `Observer`, which will be invoked
    when `LiveData` changes its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use `ViewModel` with `LiveData` in Jetpack Compose, we must do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `viewModel` method to obtain the `MyViewModel` instance.
    This method also offers the possibility of passing a `ViewModelProvider.Factory`
    instance, such as the previous `viewModel` method. The `observeAsState` extension
    method will observe changes on `LiveData` and convert them into a Compose `State`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed how lifecycles work in activities and fragments
    and the problems developers have when dealing with them. We have analyzed how
    the lifecycle-aware components (such as ViewModel and LiveData) solved these problems.
    The `ViewModel` class itself represents an implementation of the **Model-View
    ViewModel** (**MVVM**) pattern, which will be discussed in a future chapter. In
    the next section, we will look at an exercise in which we will use both ViewModel
    and LiveData and combine them with Kotlin flows.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1 – Using ViewModel and LiveData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify *Exercise 2.5* from [*Chapter 2*](B18320_02_ePub.xhtml#_idTextAnchor038),
    *Deep Diving into Data Sources*, so that the state of the UI is kept in a `LiveData`
    object inside `MainViewModel`, instead of using the Compose `State` object, and
    display `"Total request count: x"`, where `x` is the number of requests at the
    top of the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the specified text in `strings.xml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a `MainTextFormatter` class that will have one method that will return
    the `"Total request count: x"` text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a dependency to `MainTextFormatter` in `MainViewModel`, and pass the formatted
    text as a value for the `UiState.count` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove `resultState` and replace it with a `LiveData` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `@Composable` functions to use `LiveData`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `LiveData` extension library for Jetpack Compose to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `"Total request count"` text in `strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `MainTextFormatter` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason we created this class is to prevent possible context leaks by having
    a `Context` object inside the `MainViewModel` class. Here, we have a method that
    will take a count as a parameter and return the required text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inject `MainTextFormatter` in `MainViewModel` and use the formatted text as
    a value for the `UiState.count` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the instance of the `MainTextFormatter` class in the `MyApplication`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update `MainViewModelFactory` to use `MainTextFormatter`, which was just
    created, and pass it into `MainViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add `LiveData` to `MainViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have defined the two `LiveData` variables, one to update the value
    and the other to be observed, and in the `collect` method, we update the value
    of `LiveData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity`, update the `@Composable` functions to use `LiveData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we call the `observeAsState` extension method on `LiveData` from `MainViewModel`,
    and then call the `UserList` method, which will redraw the UI for each new value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Output of Exercise 3.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Output of Exercise 3.1
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the application, we will see the same list of users, and at the top,
    we will see `"Total request count: x"` instead of just the `x` character that
    was there before, as shown in *Figure 3.4*. In this exercise, we used Jetpack
    Compose for rendering the UI. In the section that follows, we will analyze how
    Android handles UIs and go more in-depth into the Jetpack Compose framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jetpack Compose to build UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will analyze how to build UIs for Android applications
    using the `View` hierarchy and look at the implications this has for applications.
    We will then look at how Jetpack Compose simplifies and changes how UIs are built
    and how we can use Compose to create UIs. We will be looking at Jetpack Compose
    with the view of how we can integrate it with other libraries and how to build
    a simple UI. For more information on how to build more complex UIs, you can refer
    to the official documentation found here: [https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way Android deals with UIs is through the `View` hierarchy. The subclasses
    of `View` deal with specific UI components that the user can interact with. The
    hierarchy looks similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – View hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – View hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: The `TextView` class deals with displaying text on the screen, `EditText` deals
    with handling text inputted by the user, and `Button` deals with rendering buttons
    on the screen. A specialized subclass of `View` is the `ViewGroup` class. This
    represents the base class for various layout classes that are responsible for
    how the views are grouped and arranged on the screen. Here, we find classes such
    as `LinearLayout` (which groups views one after the other either vertically or
    horizontally), `RelativeLayout` (which groups the views relative to the parent
    or to each other), or more recently, `ConstraintLayout`, which offers various
    ways to position views however we desire without creating many nested layouts
    (because it was bad for performance), which is why it became commonly used. When
    it comes to dealing with displaying lists of items of unknown lengths, objects
    such as `ListView` and `RecyclerView` are used. Both require creating adapters
    that will be responsible for pairing an object from a list with an associated
    `View` to render a row in the list in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ListViews` is prone to inefficiencies caused when scrolling where views
    are recreated for each new row, so in a long list of items, a lot of views would
    be created and then garbage collected. To solve this, developers had to implement
    a pattern called a `RecyclerView` addresses this issue so the adapter `RecyclerView`
    uses requires `ViewHolder`. This means that if a user views a list of 100 items
    and 10 are visible on the screen, for the 10 that are visible on the screen there
    would be 10 views to represent each row. When the user scrolls down, the 10 views
    that were created at the beginning would then display the items for the currently
    visible items. Developers can also create custom views by extending any of the
    existing `View` classes. This is useful when certain UI components have to be
    re-used in different activities, fragments, or other custom views.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display these views to the user, we would need to use activities and fragments.
    For activities, this would require invoking the `setContentView` method in the
    `onCreate` method, and in fragments, we would need to return a `View` object in
    the `onCreateView` method. We have the possibility of creating the entire layout
    for an activity or fragment in Java or Kotlin, but this would lead to a lot of
    code being written. This, and the fact that we can have different layouts for
    different screen sizes or device rotation, led to using the `res/layout` folder,
    in which we can specify how a layout might look. An example of how this might
    look is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we define `ConstraintLayout`, which contains only
    `TextView` that displays a `"Hello World"` text. To obtain a reference to `TextView`
    to allow us to change the text because of an action or data being loaded, we would
    need to use the `findViewById` method from either the `Activity` class or the
    `View` class. This would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This approach would lead to possible crashes within an application. Developers
    would need to make sure that when a layout was set for `Activity` or `Fragment`
    and `findViewById` was used, then the view was added to the `layout` file. With
    the introduction of Kotlin, this was initially addressed through the Kotlin Synthetics
    framework, which generated extensions for the declared views in a layout. Kotlin
    Synthetics would generate an extension for a View's `android:id` XML tag, which
    would be accessible in the code. Later, this was replaced with `ViewBinding`.
    When `ViewBinding` is used in a project, a class is generated for each layout
    that will hold references to all the views in the layout, eliminating potential
    crashes related to `findViewById`. All these approaches with regard to creating
    your UI are defined as **imperative** because we need to specify the views that
    our interface uses and control how we update the views when data is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach to this is the `View` hierarchy and instead use `@Composable`
    functions, in which we specify what we want to display on the screen without thinking
    of how we need to display it, and we can also create the UI using Kotlin using
    less code than we would normally. In Compose, the `Hello World` example would
    look something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to update the text because of a change in data, we will need to
    use `State` objects from the `Compose` library. Compose will observe these states
    and, when the values are changed, Compose will redraw the UI associated with that
    state. An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when the text is clicked, the `0` character is appended to
    the text and the UI is updated. This is because of the use of `mutableStateOf`.
    The `remember` method is needed because this state is kept inside a `@Composable`
    function, and it is used to keep the state intact while recomposition happens
    (the UI is redrawn). To make the text clickable, we needed to change from `Text`
    to `ClickableText`. The reason we are using two `@Composable` functions is that
    we want to keep the `@Composable` functions as re-usable as possible. This is
    called `HelloWorld`) components from the stateless components (`ShowText`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to rendering lists of items, Compose offers a simple way of rendering
    them in the form of `Column` (for when the length of the list is known and short),
    and `LazyColumn` (when the list of items is unknown and could potentially be long).
    An example of this is from *Exercise 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we display a header at the top of the item list, and we use another column
    to set the padding for the row; then, we display the entire list of items with
    the use of the `items` function, and for each row, we set the padding and display
    a group with three texts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to display input fields and buttons, then we can look at how we
    implemented the UI in *Exercise 2.1*, from [*Chapter 2*](B18320_02_ePub.xhtml#_idTextAnchor038),
    *Deep Diving into Data Sources*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `OutlinedTextField` to render the equivalent of `TextInputLayout`.
    We could have used `TextField` if we wanted the equivalent of a simple `EditText`.
    For displaying a button, we can use the `Button` method, which uses `Text` for
    rendering the text on the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compose also has integrations with other libraries, such as `ViewModel` and
    `LiveData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can pass `ViewModel` as a parameter in our `Composable` function and
    use the `observeAsState` function to convert `LiveData` into a `State` object,
    which will then be observed by Compose to redraw the UI. Compose also supports
    integration with the `Hilt` library. When Hilt is added to a project, then there
    is no need to specify `Factory` for the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important feature of Compose is how it deals with navigation between
    different screens. The Compose navigation is built upon the `androidx.navigation`
    library. This allows Compose to use the `NavHost` and `NavController` components
    to navigate between different screens. The screens are built using Compose, which
    means that an application using only Compose would ideally have only one activity.
    This eliminates any potential problems regarding activity and fragment lifecycles.
    To introduce navigation into a project, the following library is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to navigate from one screen to another, we will need to obtain `NavHostController`
    and pass it into a `@Composable` method that will represent the structure of the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppNavigation` `@Composable` method will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In `AppNavigation`, we invoke the `NavHost` `@Composable` function in which
    we will place the screens of the application along with a route to each of them.
    In this case, `Screen1` will have a simple route to navigate to and `Screen2`
    will require an argument when it is navigated to indicated through the `{param}`
    notation. For arguments, we will need to specify the type of the argument. In
    this case, it will be `String`, and `NavType.StringType` indicates this. If we
    wish to pass more complex arguments, then we will need to supply our own custom
    types and indicate how they should be serialized and deserialized. When we want
    to navigate from `Screen1` to `Screen2`, then we will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When `Column` is clicked in `Screen1`, it will invoke `NavController` to navigate
    to `Screen2` and pass the `test` argument. `Screen2` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`Screen2` will use the text extracted from `it.arguments?.getString("param").orEmpty()`
    and it will display it on the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed how Android deals with UIs. We have looked
    over the imperative approach and then introduced the declarative approach for
    Uis. We have analyzed the Jetpack Compose library and the problems it attempts
    to solve, such as less code and no XML declarations for layouts. It follows the
    principles of libraries from other technologies (such as React and SwiftUI) and
    shows how UIs can be built from a functional programming point of view. In the
    next section, we will look at an exercise for how we can use Compose to navigate
    between two screens in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2 – Navigating using Jetpack Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *Exercise 3.1* so that the current `@Composable` functions are moved
    into a new file named `UserListScreen`, then create a new file with new `@Composable`
    functions that will render a simple text called `UserScreen`. When a user from
    the list is clicked, the new screen is opened and it will display the name of
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, you will need to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `AppNavigation` sealed class that will have two variables. The first
    variable, named `route`, will be `String` and the second variable, named `argumentName`,
    will be `String` and default to `empty`. Two subclasses of `AppNavigation` will
    be `Users` (which will set the route variable to `"users"`) and `User` (which
    will set the route to `"users/{name}"`, then `argumentName` to `name`, and a method
    to create the route for a specific name).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity`, rename the screen `@Composable` function to `Users`, and
    using the `NavController` object, set up a click listener on the list row and
    navigate to the route from the `User` class in `AppNavigation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `@Composable` function named `User`, which will be responsible
    for showing a simple `Text` and will have the text displayed as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity`, create a `@Composable` function named `MainApplication`,
    which will use the `NavHost` `@Composable` function to link the navigation between
    the two screens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `navigation` library for Compose in `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `AppNavigation` class, which will hold the information for the routes
    and arguments for each of our screens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the navigation relies on URLs to identify the different screens, we can take
    advantage of sealed classes and objects in Kotlin to keep track of the required
    inputs for each screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the screen `@Composable` function to `Users` in `MainActivity` and add
    `NavController` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, pass the `NavController` parameter to `UserList` and implement the click
    listener for the user row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `User` `@Composable` function in `MainActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create an `App` `@Composable` function that will use `NavHost` to set
    up the navigation between the two screens in `MainActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, invoke the `App` function when the `Activity` content is set in `MainActivity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.6 – Output of Exercise 3.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B18320.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Output of Exercise 3.2
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application, we should see the same list of users as before, and
    if we click on a user, it will transition to a new screen that will display the
    selected user's name, as shown in *Figure 3.6*. If we press the *Back* button,
    we should see the initial list of users; that's because, by default, the `navigation`
    library handles back navigation.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have analyzed how we can use Jetpack Compose to navigate
    between two screens in an application. In future chapters, we will revisit navigation
    when we must navigate between different screens in different modules.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have analyzed how data can be presented in Android and discussed
    the libraries we have available now. We have looked at Android lifecycles and
    the potential issues that applications could have regarding lifecycles and then
    looked at how libraries such as `ViewModel` and `LiveData` solve most of these
    problems. We then looked at how the UI works in Android and how we would need
    to deal with using XML to define layouts in which we would insert the views that
    the layouts needed to display, and how we would need to update the state of the
    views when the data changes. We then looked at how Jetpack Compose solves these
    issues in a declarative functional way. We built upon the exercises in the previous
    chapter to show how we can integrate multiple libraries in a single application
    and display data from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deal with managing the dependencies inside an application
    and the libraries available for doing so.
  prefs: []
  type: TYPE_NORMAL
