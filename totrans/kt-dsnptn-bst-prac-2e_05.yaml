- en: '*Chapter 4*: Getting Familiar with Behavioral Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses behavioral patterns in terms of Kotlin. **Behavioral
    patterns** deal with how objects interact with one another.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how an object can alter its behavior based on the situation, how
    objects can communicate without knowledge of one another, and how to iterate over
    complex structures easily. We'll also touch on the concept of functional programming
    in Kotlin, which will help us implement some of these patterns easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of Responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll be able to structure your code in a highly
    decoupled and flexible manner.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the requirements from the previous chapters, you will also need
    a **Gradle**-enabled **Kotlin** project to be able to add the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the **Strategy** design pattern is to allow an object to alter its
    behavior at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall the platformer game we were designing in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*, while discussing the **Facade** design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Canary Michael, who acts as a game designer in our small indie game development
    company, came up with a great idea. *What if we were to give our hero an arsenal
    of weapons to protect us from those horrible carnivorous snails?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Weapons all shoot projectiles (you don''t want to get too close to those dangerous
    snails) in the direction our hero is facing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All projectiles should have a pair of coordinates (*our game is 2D, remember?*)
    and a direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we were to shoot only one type of projectile, that would be simple, since
    we covered the Factory pattern in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do something like that here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But Michael wants our hero to have at least three different weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peashooter**: Shoots small peas that fly straight. Our hero starts with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pomegranate**: Explodes when hitting an enemy, much like a grenade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Banana**: Returns like a boomerang when it reaches the end of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Come on, Michael, give us some slack! Can''t you just stick with regular guns
    that all work the same?*'
  prefs: []
  type: TYPE_NORMAL
- en: Fruit arsenal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's discuss how we could solve this in the Java way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we would have created an interface that abstracts these changes. In
    our case, what changes is our hero''s weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all the other weapons would implement this interface. Since we don''t
    deal with aspects such as rendering or animating objects, no specific behavior
    will be implemented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All of the weapons in our game will implement the same interface, overriding
    its single method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our hero will hold a reference to a weapon, `Peashooter`, at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This reference will delegate the actual shooting process to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s left is the ability to equip another `weapon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And that's what the **Strategy** design pattern is all about. It makes our algorithms
    – in this case, the weapons in our game – interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: Citizen functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Kotlin, there's a more efficient way to implement the same functionality
    using fewer classes. That's thanks to the fact that functions in Kotlin are first-class
    citizens. *But what does that mean?*
  prefs: []
  type: TYPE_NORMAL
- en: 'For one, we can assign functions to the variables of our class, just like any
    other standard value. It makes sense that you can assign a primitive value to
    your variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also assign an object to a variable, as we have done many times already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*So, why shouldn''t you be able to assign a function to your variable?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, you can easily do that. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how that may help us simplify our design.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a namespace for all our weapons. We can use an object
    for that. This is not mandatory but it helps keep everything in check. Then, instead
    of classes, each of our weapons will become a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, instead of implementing an interface, we have multiple functions
    receiving the same parameters and returning the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting part is our hero. The `OurHero` class now contains two
    values, both of which are functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The interchangeable part is `currentWeapon`, while `shoot` is now an anonymous
    function that wraps it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test that our idea works, we can shoot the default weapon once, then switch
    to another weapon and shoot with it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this dramatically reduces the number of classes we have to write
    while keeping the same functionality. If your interchangeable algorithm doesn't
    have a state, you can replace it with a simple function. Otherwise, introduce
    an interface, and let each Strategy pattern implement it.
  prefs: []
  type: TYPE_NORMAL
- en: That's also the first time we used the function reference operator, `::`. This
    operator allows us to refer to a function as if it was a variable instead of invoking
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy** is a valuable pattern whenever your application needs to change
    its behavior at runtime. One example is a booking system for flights that allows
    for overbooking; that is, placing more passengers on a flight than there are seats.
    You may decide that you wish to enable overbooking up until one day before the
    flight and then disallow it. You can do this by switching strategies instead of
    adding complex checks to your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another pattern that should help us work with complex data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were discussing the **Composite** design pattern in the previous chapter,
    we noted that the design pattern felt a bit incomplete. Now is the time to reunite
    the twins separated at birth. Much like Arnold Schwarzenegger and Danny DeVito,
    they're very different but complement each other well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember from the previous chapter, a squad consists of troopers
    or other squads. Let''s create one now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a platoon that consists of four troopers in total.
  prefs: []
  type: TYPE_NORMAL
- en: It would be useful if we could print all the troopers in this platoon using
    a `for-each` loop, which we learned about back in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just try to write that code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this code doesn''t compile, the Kotlin compiler provides us with a
    useful hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Before we follow the compiler's guidance and implement the method, let's briefly
    discuss what problem we have at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Our platoon, which implements a Composite design pattern, is not a flat data
    structure. It can contain objects that contain other objects – squads can contain
    troopers as well as other squads. In this case, however, we want to abstract that
    complexity and work with it as if it was just a list of troopers. The Iterator
    pattern does just that – it *flattens* our complex data structure into a simple
    sequence of elements. The order of the elements and what elements to ignore is
    for the iterator to decide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our `Squad` object in a `for-each` loop, we will need to implement a
    special function called `iterator()`. And since it''s a special function, we''ll
    need to use the `operator` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'What our function returns is an anonymous object that implements the `Iterator<T>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we can see the use of generics in Kotlin. `Iterator<Trooper>` means
    that the objects that our `next()` method returns will always be of the `Trooper`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to iterate all the elements, we need to implement two methods –
    one to fetch the next element and one to let the loop know when to stop. Let''s
    do that by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a state for our iterator. It will remember that the last element
    is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to tell it when to stop. In simple cases, this would be equal
    to the size of the underlying data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be a bit more complex since we need to handle some edge cases. You
    can find the complete implementation in this book's GitHub repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to know which unit to return. For simple cases, we could just
    return the current element and increase the element count by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our case, this is a bit more complex since squads could contain other squads.
    Again, you can find the full implementation in this book's GitHub repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Sometimes, it also makes sense to receive an iterator as a parameter of a function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will iterate over anything that supplies an iterator. This is
    also an example of a generic function in Kotlin. Note `<T>`, which comes before
    the function's name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a regular developer that doesn't invent new data structures for a living,
    you may not implement iterators often. However, it's still important to know how
    they work behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will show how to design finite-state machines efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of the **State** design pattern as an opinionated Strategy pattern,
    which we discussed at the beginning of this chapter. But while the Strategy pattern
    is usually replaced from the outside by the client, the state may change internally
    based solely on the input it gets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this dialog a client wrote with the Strategy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: *Here''s a new thing to do, start doing it from now on.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: *OK, no problem.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: *What I like about you is that you never argue with me.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compare it with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: *Here''s some new input I got from you.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: *Oh, I don''t know. Maybe I''ll start doing something differently.
    Maybe not.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The client should also expect that the state may even reject some of its inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: *Here''s something for you to ponder, State.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: *I don''t know what it is! Don''t you see I''m busy? Go bother some
    Strategy with this!*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*So, why do clients still tolerate that state of ours?* Well, the state is
    good at keeping everything under control.'
  prefs: []
  type: TYPE_NORMAL
- en: Fifty shades of State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The carnivorous snails from our platformer game have had enough of this abuse.
    So, the player throws peas and bananas at them, only to get to another sorry castle.
    *Now, they shall act!*
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how the State design pattern can help us model a changing behavior
    of an actor – in our case, of the enemies in our platformer game. By default,
    the snail should stand still to conserve snail energy. But when the hero gets
    close, it should dash toward them aggressively.
  prefs: []
  type: TYPE_NORMAL
- en: If the hero manages to injure it, it should retreat to lick its wounds. Then,
    it will repeat attacking until either of them is dead.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll declare what can happen during a snail''s life:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Our snail implements this interface so that it is notified of anything that
    may happen to it and act accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can declare the `Mood` class, which we will mark with the `sealed`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '**Sealed classes** are abstract and cannot be instantiated. We''ll see the
    benefit of using them in a moment. But before that, let''s declare other states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: These are all the different states – sorry, moods – of our snail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the State design pattern, `Snail` is the context. It holds the
    state. So, we declare a member for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define what `Snail` should do when it sees our hero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this doesn't compile. This is where the `sealed` class comes into
    play. Much like with an `enum`, Kotlin knows that there's a finite number of classes
    that extend from it. So, it requires that our `when` is exhaustive and specifies
    all the different cases in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: If you're using IntelliJ as your IDE, it will even suggest that you `Add remaining
    branches` automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `else` to describe no state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'When the snail gets hit, we need to decide whether it''s dead or not. For that,
    we can use `when` without an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `is` keyword here, which is the same as `instanceof` in
    Java, but more concise.
  prefs: []
  type: TYPE_NORMAL
- en: State of the nation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous approach contains most of the logic for our context. You may sometimes
    see a different approach, which is valid as your context becomes bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this approach, `Snail` would become thin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we marked `mood` as `internal`. This lets other classes in the same
    package alter it. Instead of `Snail` implementing `WhatCanHappen`, our `Mood`
    will implement it instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the logic resides within our state objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Note that our state objects now receive a reference to their context in the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Use the first approach if the amount of code in your state is relatively small.
    Use the second approach for cases if the variants differ a lot. One example from
    the real world, where this pattern is widely used, is Kotlin's **Coroutines**
    mechanism. We'll discuss this in detail in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144),
    *Introducing Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another pattern that encapsulates actions.
  prefs: []
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern allows you to encapsulate actions inside an object to be
    executed sometime later. Furthermore, if we can execute one action later, we could
    also execute many, or even schedule exactly when to execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `Stormtrooper` management system from [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*. Here''s an example of implementing the `attack`
    and `move` functions from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: We could even use the **Bridge** design pattern from the previous chapter to
    provide the actual implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem we need to solve now is that our trooper can remember exactly one
    command. That''s it. If they start at `(0, 0)`, which is the top of the screen,
    we can tell them to `move(20, 0)`, which is 20 steps to the right, and then to
    `move(20, 20)`. In this case, they''ll move straight to `(20, 20)` and will probably
    get destroyed because there are rebels that we must try to avoid at all costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: If you've been following this book from the start or at least joined at [*Chapter
    3*](B17816_03_ePub.xhtml#_idTextAnchor080), *Understanding Structural Patterns*,
    you probably have an idea of what we need to do, since we have already discussed
    the concept of *functions as first-class citizens* in the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sketch a draft for this. We know that we want to hold a list of objects,
    but we don''t know what type they should be yet. So, we''ll use `Any` for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to iterate over the list and execute the orders we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Note that Kotlin provides us with the `isNotEmpty()` function on collections,
    as an alternative to the `!orders.isEmpty()` check, as well as a `removeFirst()`
    function, which allows us to use our collection as if it was a queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you''re not familiar with the Command design pattern, you can guess
    that if we want our code to compile, we can define an interface with a single
    method, `execute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can hold a list at the same time in a member property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Each type of order, be it a move order or an attack order, would implement this
    interface as needed. That's basically what the Java implementation of this pattern
    would suggest in most cases. *But isn't there a better way?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at `Command` again. The `execute()` method receives nothing, returns
    nothing, and does something. It''s the same as writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s no different from what we''ve seen previously. We could simplify this
    further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'And instead of having an interface for this called `Command`, we''ll have `typealias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: This makes our `Command` interface redundant and allows us to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this line stops compiling again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because `execute()` is just some name we invented. In Kotlin, functions
    use `invoke()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also omit `invoke()`, which will leaves us with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: That's nice, but currently, our function has no parameters at all. *What happens
    if our function receives arguments?*
  prefs: []
  type: TYPE_NORMAL
- en: 'One option would be to change the signature of our `Command` so that we receive
    two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '*But what if some commands receive no arguments, or only one, or more than
    two?* We also need to remember what to pass to `invoke()` at each step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A much better way is to have a **function generator**. This is a function that
    returns another function. If you have ever worked with the JavaScript language,
    then you''ll know that it''s a common practice to use closures to limit the scope
    and remember stuff. We''ll do the same here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'When called with proper arguments, `moveGenerator` will return a new function.
    This function can be invoked whenever we find it suitable and it will remember
    three things:'
  prefs: []
  type: TYPE_NORMAL
- en: What method to call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which arguments to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which object to use it on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, our `Trooper` may have a method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides us with a nice fluent syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '**Fluent syntax** means that we can chain methods on the same object easily
    without the need to repeat its name many times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Now, we may issue any number of commands to our `Trooper` without needing to
    know how they are executed internally.
  prefs: []
  type: TYPE_NORMAL
- en: A function that receives or returns another function is called a **higher-order
    function**. We'll explore such functions many more times in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Undoing commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While not directly related, one of the advantages of the Command design pattern
    is the ability to undo commands. *What if we wanted to support such a functionality?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Undoing is usually very tricky because it involves one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the previous state (this is impossible if there's more than one
    client as this requires a lot of memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing deltas (tricky to implement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining opposite operations (not always possible)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, the opposite of the *move from (0,0) to (0, 20)* command would
    be *move from wherever you''re now to (0,0)*. This can be achieved by storing
    a pair of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to change our `appendMove` function so that it also stores the
    reverse command every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Computing the opposite move is quite complex as we don't save the position of
    our soldier currently (it was something we should have implemented anyway). We'll
    also have to deal with some edge cases. But this should provide you with an idea
    of how such behavior can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: The **Command** design pattern is yet another example of functionality that
    is already embedded inside the language. In this case, this functions as a first-class
    citizen, which reduces the need to implement design patterns yourself. In the
    real world, this pattern is practical whenever you want to enqueue multiple actions
    or schedule an action to be executed later.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of Responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm a horrible software architect, and I don't particularly appreciate speaking
    with people. Hence, while sitting in *The Ivory Tower* (*that's the name of the
    cafe I often visit*), I wrote a small web application. If a developer has a question,
    they shouldn't approach me directly, oh no! They'll need to send me a proper request
    through this system and I shall only answer them if I deem their request worthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **filter chain** is a ubiquitous concept in web servers. Usually, when a
    request reaches you, it''s expected that the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: Its parameters have already been validated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user has already been authenticated, if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User roles and permissions are known and the user is authorized to perform an
    action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the code I initially wrote looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: It's a bit messy, but it works.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I noticed that some developers decided that they can send me two questions
    at once. We have to add some more logic to this function. But wait – I'm an architect,
    after all. *So, isn't there a better way to delegate this?*
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the **Chain of Responsibility** design pattern is to break a complex
    piece of logic into a collection of smaller steps, where each step, or link in
    the chain, decides whether to proceed to the next one or to return a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we won''t learn new Kotlin tricks but use those that we already
    know about. So, for example, we could start by implementing an interface such
    as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'We never discussed what my response to one of the developers looked like. That''s
    because I keep my chain of responsibility so long and complex that usually, they
    tend to solve the problems by themselves. I''ve never had to answer one of them,
    quite frankly. But let''s assume the response looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'We could do this *the Java way* and start implementing each piece of logic
    inside its own handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, here, we are implementing an interface with a single method,
    which we override with our desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other filters would look very similar to this one. We can compose them in any
    order we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'But I won''t even ask you the rhetorical question this time about better ways
    to do things. Of course, there''s a better way. We''re in the Kotlin world now.
    And we''ve seen how to use various functions in the previous section. So, let''s
    define a function for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t have a separate class and interface for something that simply receives
    a request and returns a response. Here''s an example of how we can implement authentication
    in our application by using a simple function as a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `authentication` is a function that receives a function and returns a
    function. This pattern allows us to easily compose those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Which method you choose to use is up to you. For example, using interfaces is
    more explicit and would suit you better if you're creating a library or framework
    that others may want to extend.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions is more concise and if you just want to split your code in a
    more manageable way, it may be the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: You've probably seen this approach many times in the real world. For example,
    many web server frameworks use it to handle cross-cutting concerns, such as authentication,
    authorization, logging, and even routing requests. Sometimes, these are called
    **filters** or **middleware**, but it's the same Chain of Responsibility design
    pattern in the end. We'll discuss it again in more detail in [*Chapter 10*](B17816_10_ePub.xhtml#_idTextAnchor237),
    *Concurrent Microservices with Ktor*, and [*Chapter 11*](B17816_11_ePub.xhtml#_idTextAnchor251),
    *Reactive Microservices with Vert.x*, where we'll see how it's implemented by
    some of the most popular Kotlin frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The next design pattern will be a bit different from all the others and also
    somewhat more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern may seem very simple or very hard, based on how much background
    you have in computer science. Some books that discuss classical software design
    patterns even decide to omit it altogether or put it somewhere at the end, for
    curious readers only.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind this is that the **Interpreter** design pattern deals with
    translating specific languages. *But why would we need that? Don't we have compilers
    to do that anyway?*
  prefs: []
  type: TYPE_NORMAL
- en: We need to go deeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All developers have to speak many languages or sub-languages. Even as regular
    developers, we use more than one language. Think of tools that build your projects,
    such as Maven or Gradle. You can consider their configuration files and build
    scripts as languages with specific grammar. If you put elements out of order,
    your project won't be built correctly. This is because such projects have interpreters
    to analyze configuration files and act upon them.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples are query languages, whether one of the SQL variations or one
    of the languages specific to NoSQL databases. If you're an Android developer,
    you may think of XML layouts as such languages too. Even HTML could be considered
    as a language that defines user interfaces. And there are others, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you've worked with one of the testing frameworks that defines a custom
    language for testing, such as **Cucumber** ([github.com/cucumber](http://github.com/cucumber)).
  prefs: []
  type: TYPE_NORMAL
- en: Each of these examples can be called a **domain-specific language** (**DSL**).
    A DSL is a language inside a language, built for a particular domain. We'll discuss
    how they work in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A language of your own
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll define a simple *DSL-for-SQL* language. We won''t define
    the format or grammar for it; instead, we''ll provide an example of what it should
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: The goal of our language is to improve readability and prevent some common SQL
    mistakes, such as typos (such as using *FORM* instead of `FROM`). We'll cover
    the compile-time validations and autocompletion along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start with the easiest part – implementing the `select` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: We could write this using single expression notation, but we are using the more
    verbose version for clarity here. This is a function that has two parameters.
    The first is a `String`, which is simple. The second is another function that
    receives nothing and returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting part is that we specify the receiver for our lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very smart trick, so be sure to follow along. Remember extension
    functions, which we discussed in [*Chapter 1*](B17816_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Kotlin*, and expanded on in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*. The preceding code can be translated into
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that although it may seem like this lambda receives nothing,
    it receives one argument: an object of the `SelectClause` type. The second trick
    lies in the usage of the `apply()` function, which we''ve already seen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be translated into the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the steps the preceding code will perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize `SelectClause`, which is a simple object that receives one argument
    in its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `from()` function with an instance of `SelectClause` as its only argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return an instance of `SelectClause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This code only makes sense if `from()` does something useful with `SelectClause`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our DSL example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: We've made the receiver explicit now, meaning that the `from()` function will
    call the `from()` method on the `SelectClause` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start guessing what this method looks like. It receives `String` as
    its first argument and another lambda as its second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: This example could be shortened, but then we'd need to use `apply()` within
    `apply()`, which may seem confusing at this point.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first time we've seen the `lateinit` keyword. Remember that the
    Kotlin compiler is very serious about null safety. If we omit `lateinit`, it will
    require us to initialize the variable with a default value. But since we'll only
    know this at a later time, we are asking the compiler to relax a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we don't make good on our promises and forget to initialize the
    variable, we'll get `UninitializedPropertyAccessException` when we access it for
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: This keyword is quite dangerous, so use it with caution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our preceding code; all we do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of `FromClause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store `FromClause` as a member of `SelectClause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass an instance of `FromClause` to the `where` lambda.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return an instance of `FromClause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hopefully, you''re starting to get the gist of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '*What does this mean?* After understanding the `from()` method, this should
    be much simpler. `FromClause` must have a method called `where()` that receives
    one argument of the `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have made good on our promise and shortened the method this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialized an instance of `WhereClause` with the string we received and
    returned it – simple as that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '`WhereClause` only prints the word `WHERE` and the conditions it received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '`FromClause` prints the word `FROM`, as well as the table name it received
    and everything `WhereClause` printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '`SelectClause` prints the word `SELECT`, the columns it got, and whatever `FromClause`
    printed.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking a break
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kotlin provides beautiful capabilities for creating readable and type-safe DSLs.
    But the Interpreter design pattern is one of the hardest in the toolbox. If you
    didn't get it from the get-go, take some time to debug the previous code. Understand
    what the `this` expression means at each step, as well as when we call the function
    of an object and when we call the method of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Call suffix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We left out one last notion of Kotlin's DSL until the end of this section so
    that we didn't confuse you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our DSL again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: Note that although the `select` function receives two arguments – a string and
    a lambda – the lambda is written outside of the round brackets, not inside them.
  prefs: []
  type: TYPE_NORMAL
- en: This is called **call suffix** and is a widespread practice in Kotlin. If our
    function receives another function as its last argument, we can pass it out of
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: This results in a much clearer syntax, especially for DSLs such as this one.
  prefs: []
  type: TYPE_NORMAL
- en: The Interpreter design pattern and Kotlin's abilities to produce DSLs with type-safe
    builders are compelling. But as they say, *with great power comes great responsibility*.
    So, consider if your case is complex enough to construct a language within a language,
    or whether using the Kotlin basic syntax will be enough.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go back to the game we were building to see how we can decouple object
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development team of our game has some real problems – and they're not related
    to code directly. As you may recall, our little indie company consists of only
    me, a canary named *Michael* that acts as a product manager, and two cat designers
    that sleep most of the day but produce some decent mockups from time to time.
    We have no **Quality** **Assurance** (**QA**) whatsoever. Maybe that's one of
    the reasons our game keeps crashing all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recently Michael has introduced me to a parrot named Kenny, who happens to
    be QA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '`Kenny` is a simple object that implements two interfaces: `QA`, to do QA work,
    and `Parrot`, because it''s a parrot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parrot QAs are very motivated. They''re ready to test the latest version of
    my game at any time. But they don''t like to be bothered when they are either
    sleeping or eating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'In case Kenny has any questions, I gave him my direct number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'Kenny is a hard-working parrot. But we had so many bugs that we also had to
    hire a second parrot QA, Brad. If Kenny is free, I give the job to him as he''s
    more acquainted with our project. But if he''s busy, I check if Brad is free and
    give the task to him:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'Brad, being more junior, usually checks with Kenny first. And Kenny also gave
    my number to him:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Then, Brad introduces me to George. George is an owl, so he sleeps at different
    times than Kenny and Brad. This means that he can check my code at night.
  prefs: []
  type: TYPE_NORMAL
- en: 'George checks everything with Kenny and with me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that George is an avid football fan. So, before calling him,
    we need to check if he''s watching a game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'Kenny, out of habit, checks in with George too, because George is a very knowledgeable
    owl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there''s Sandra. She''s a different kind of bird because she''s not part
    of QA but a copywriter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'I try not to bother her unless there''s a major release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'I have a few problems here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, my mind almost explodes trying to remember all those names. So might
    yours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, I need to remember how to interact with each person. I'm the one doing
    all the checks before calling them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, notice how George tries to confirm everything with Kenny, and Kenny with
    George. Luckily, up until now, George has always been watching a football game
    when Kenny calls him. And Kenny is asleep when George needs to confirm something
    with him. Otherwise, they would get stuck on the phone for eternity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, and what bothers me the most, is that Kenny plans to leave soon to open
    his own startup, ParrotPi. Imagine all the code we'll have to change now!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All I want to do is check if everything is alright with my code. Someone else
    should do all this talking!
  prefs: []
  type: TYPE_NORMAL
- en: The middleman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Mediator** design pattern is simply a control freak. It doesn't like it
    when one object speaks to the other directly. It gets mad sometimes when that
    happens. No – everybody should only speak through him. *What's the explanation
    for this?* It reduces coupling between objects. Instead of knowing some other
    objects, everybody should know only them, the mediator.
  prefs: []
  type: TYPE_NORMAL
- en: 'I decided that Michael should manage all those processes and act as the mediator
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'Only Michael will know all the other birds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the mediator encapsulates the complex interactions between different
    objects, exposing a very simple interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll only remember Michael and he''ll do the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll also change my phone number and make sure that everybody gets only Michael''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if somebody needs somebody else''s opinion, they''ll need to go through
    Michael first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's nothing new we can learn about Kotlin through this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator flavors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two *flavors* to the Mediator pattern. We'll call them *strict* and
    *loose*. We saw the strict version previously. We tell the mediator exactly what
    to do and expect an answer from it.
  prefs: []
  type: TYPE_NORMAL
- en: The loose version will expect us to notify the mediator of what happened, but
    not to expect an immediate answer. Instead, if they need to notify us in return,
    they should call us.
  prefs: []
  type: TYPE_NORMAL
- en: Mediator caveats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Michael suddenly becomes ever so important. Everybody knows only him and only
    he can manage their interactions. He may even become a *God Object*, all-knowing
    and almighty, which is an antipattern from [*Chapter 9*](B17816_09_ePub.xhtml#_idTextAnchor216),
    *Idioms and Anti-Patterns*. Even if he's that important, be sure to define what
    this mediator should, and – even more importantly – shouldn't do.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our example and discuss yet another behavioral pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Michael became a manager, it's been tough to catch him if I have a question.
    And when I do ask him something, he just throws something and runs to the next
    meeting.
  prefs: []
  type: TYPE_NORMAL
- en: Yesterday, I asked him what new weapon we should introduce in our game. He told
    me it should be a *Coconut Cannon*, clear as day. But today, when I presented
    him with this feature, he chirped at me angrily! Finally, he said he told me to
    implement a *Pineapple Launcher* instead. I'm lucky he's just a canary.
  prefs: []
  type: TYPE_NORMAL
- en: It would be great if I could record him so that when we have another meeting
    that goes awry because he's not paying full attention, I can simply replay everything
    he said.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sum up my problems first – Michael''s thoughts are his and his only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that since Michael is a canary, he can only hold `2` thoughts
    in his mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: 'If Michael thinks about more than `2` things at a time, he''ll forget the first
    thing he thought about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Even in the recording, what he says is quite hard to understand (because he
    doesn't return anything).
  prefs: []
  type: TYPE_NORMAL
- en: And even if I do record him, Michael can claim it's what he said, not what he
    meant.
  prefs: []
  type: TYPE_NORMAL
- en: The Memento design pattern solves this problem by saving the internal state
    of an object, which can't be altered from the outside (so that Michael cannot
    deny that he said it) and can only be used by the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, we can use an `inner` class to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see a new keyword, `inner`, for marking our class. If we omit this
    keyword, the class is called `Nested` and is similar to the static nested class
    from Java. Inner classes have access to the private fields of the outer class.
    For that reason, our `Memory` class can change the internal state of the `Manager`
    class easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can record what Michael says at this moment by creating an imprint
    of the current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can capture his thoughts in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add a means of going back to a previous line of thought:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that if we want to use special characters in function names,
    such as spaces, we can, but only if a function name is wrapped in *backticks*.
    Usually, that's not the best idea, but it has its uses, as we'll cover in [*Chapter
    10*](B17816_10_ePub.xhtml#_idTextAnchor237), *Concurrent Microservices with Ktor*.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s left is using `memento` to go back in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: The last invocation will return Michael's mind to thinking about Coconut Cannon,
    of all things.
  prefs: []
  type: TYPE_NORMAL
- en: Note how we use the `with` standard function to avoid repeating `michael.think()`
    on each line. This function is helpful if you need to refer to the same object
    often in the same block of code and would like to avoid repetition.
  prefs: []
  type: TYPE_NORMAL
- en: I don't expect you to see the Memento design pattern implemented very often
    in the real world. But it still may be useful in some types of applications that
    need to recover to some previous state.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we discussed the Iterator design pattern,
    which helps us work with complex data structures. Next, we'll look at another
    design pattern with a somewhat similar goal.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern is usually a close friend of the Composite design pattern,
    which we discussed in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080), *Understanding
    Structural Patterns*. It can either extract data from a complex tree-like structure
    or add behavior to each node of the tree, much like the Decorator design pattern
    does for a single object.
  prefs: []
  type: TYPE_NORMAL
- en: My plan, being a lazy software architect, worked out quite well. My request-answering
    system from the chain of responsibility worked quite well and I don't have plenty
    of time for coffee. But I'm afraid some developers begin to suspect that I'm a
    bit of a fraud.
  prefs: []
  type: TYPE_NORMAL
- en: To confuse them, I plan to produce weekly emails with links to all the latest
    buzzword articles. Of course, I don't plan to read them myself – I just want to
    collect them from some popular technology sites.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a crawler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the following data structure, which is very similar to what
    we had when we discussed the Iterator design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '`Page` is a container for other HTML elements, but not `HtmlElement` by itself.
    `Container` holds other containers, tables, links, and images. `Image` holds its
    link in the `src` attribute. `Link` has the `href` attribute instead.'
  prefs: []
  type: TYPE_NORMAL
- en: What we would like to do is extract all the URLs from the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a function that will receive the root of our object
    tree – a `Page` container, in this case – and return a list of all the available
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: Using `run` allows us to control what we return from the block's body. In this
    case, we will return the `links` objects we've gathered. Inside the `run` block,
    this refers to the object it operates on – in our case, `LinksCrawler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, the suggested way to implement the Visitor design pattern is to add
    a method for each class that will accept our new functionality. We''ll do the
    same, but not for all the classes. Instead, we''ll only define this method for
    container elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'Our feature will need to hold a collection internally and expose it for read
    purposes. In Java, we will only specify the getter for this member; no setter
    is required. In Kotlin, we can specify the value without a backing field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: We want our data structure to be immutable. That's the reason we're calling
    `toList()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: The functions that iterate over branches could be simplified even further if
    we use the Iterator design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'For containers, we simply pass their elements further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying the parent class as `sealed` helps the compiler further. We discussed
    sealed classes earlier in this chapter while covering the State design pattern.
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting logic is in the leaves of our tree-like structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Note that in some cases, we don't want to do anything. This is specified by
    an empty block in our `else` clause, `else -> {}`. This is yet another example
    of **smart casts** in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that after we checked that the element is a `Link`, we gained type-safe
    access to its `href` attribute. That's because the compiler is doing the casts
    for us. The same is true for the `Image` element.
  prefs: []
  type: TYPE_NORMAL
- en: Although we achieved our goals, the usability of this pattern can be debated.
    As you can see, it's one of the more verbose elements we have and introduces tight
    coupling between classes that are receiving additional behavior and the Visitor
    pattern itself.
  prefs: []
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some lazy people make art out of their laziness. Take me, for example. Here''s
    my daily schedule:'
  prefs: []
  type: TYPE_NORMAL
- en: '8:00 A.M. – 9:00 A.M.: Arrive at the office'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9:00 A.M. – 10:00 A.M.: Drink coffee'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '10:00 A.M. –1 2:00 P.M.: Attend some meetings or review code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '12:00 P.M. – 1:00 P.M.: Go out for lunch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '1:00 P.M. – 4:00 P.M.: Attend some meetings or review code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4:00 P.M.: Sneak back home'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some parts of my schedule never change, while some do. Specifically, I have
    two slots in my calendar that any number of meetings could occupy.
  prefs: []
  type: TYPE_NORMAL
- en: At first, I thought I could decorate my changing schedule with that setup and
    teardown logic, which happens before and after. But then there's lunch, which
    is holy for architects and happens in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java is pretty clear on what you should do. First, you create an abstract class.
    Then, you mark all the methods that you want to implement by yourself as `private`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'All the methods that are changing from day to day should be defined as `abstract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to be able to replace a function but also want to provide a default
    implementation, you should leave it `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `public` is the default visibility in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you have a method that executes your algorithm. It''s `final` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to have a schedule for Monday, we can simply implement the
    missing parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '*What does Kotlin add on top of that?* What it usually does – conciseness.
    As we saw previously, this can be achieved through functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three *moving parts* – two mandatory activities (the software architect
    must do something before and after lunch) and one optional (the boss may stop
    him before he sneaks off home):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have a function that accepts up to three other functions as its arguments.
    The first two are mandatory, while the third may not be supplied at all or assigned
    with `null` to explicitly state that we don''t want that function to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this function, we''ll have our algorithm. The invocations of `beforeLunch()`
    and `afterLunch()` should be clear; after all, those are the functions that are
    passed to us as arguments. The third one, `bossHook`, may be `null`, so we only
    execute it if it''s not. We can use the following construct for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '*But what about the other functions – the ones we want to always implement
    by ourselves?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin has a notion of **local functions**. These are functions that reside
    in other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: These are all valid ways to declare a local function. No matter how you define
    them, they're invoked in the same way. Local functions can only be accessed by
    the parent function they were declared in and are a great way to extract common
    logic without the need to expose it.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we're left with the code structure. Defining the algorithm's structure
    but letting others decide what to do at some points – that's what the Template
    method is all about.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost at the end of this chapter. There is just one more design pattern
    to discuss, but it's one of the most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably one of the highlights of this chapter, this design pattern provides
    us with a bridge to the following chapters, which are dedicated to functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, what is the* **Observer** *pattern all about?* You have one *publisher*,
    which may also be called a *subject*, that may have many *subscribers*, also known
    as *observers*. Each time something interesting happens with the publisher, all
    of its subscribers should be updated.'
  prefs: []
  type: TYPE_NORMAL
- en: This may look a lot like the **Mediator** design pattern, but there's a twist.
    Subscribers should be able to register or unregister themselves at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the classical implementation, all subscribers/observers need to implement
    a particular interface for the publisher to update them. But since Kotlin has
    higher-order functions, we can omit this part. The publisher will still have to
    provide a means for observers to be able to subscribe and unsubscribe.
  prefs: []
  type: TYPE_NORMAL
- en: This may have sounded a bit complex, so let's take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Animal choir example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, some animals have decided to have a choir of their own. The cat was elected
    as the conductor of the choir (it doesn't like to sing anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that these animals escaped from the Java world, so they don''t
    have a common interface. Instead, each has a different way of making a sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, the cat was elected not only because it was vocally challenged, but
    also because it was smart enough to follow this chapter until now. So, it knows
    that in the Kotlin world, it can accept functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we learned how to pass a new function as an argument, as well as
    a literal function. *But how do we pass a reference to a member function?*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this in the same way that we did in the Strategy design pattern;
    that is, by using the member reference operator (`::`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the cat needs to save all those subscribers somehow. Luckily, we can put
    them on a map. *What would be the key?* This should be the function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: If all those `()->Unit` instances are making you dizzy, be sure to use `typealias`
    to give them more semantic meaning, such as *subscriber*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the bat decides to leave the choir. After all, no one can hear its beautiful
    singing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'All `bat` needs to do is pass its subscriber function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the reason we used the map in the first place. Now, the cat can call
    all its choir members and tell them to sing – well, produce sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the rehearsal went well. But the cat is very tired after doing all those
    loops. It would rather delegate the job to choir members. That''s not a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: 'Our subscribers will have to change slightly to receive a new argument. Here''s
    an example for the `Turkey` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit of a problem. *What if the cat was to tell each animal what sound
    to make: high or low?* We''d have to change all the subscribers again, as well
    as the cat.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While designing your publisher, pass the single data classes with many properties,
    instead of sets of data classes or other types. That way, you won''t have to refactor
    your subscribers as much if new properties are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `enum` to describe the different types of pitches and a data class
    to encapsulate the pitch to be used, as well as how many times the message should
    be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that your messages are immutable. *Otherwise, you may experience
    strange behavior! What if you have sets of different messages you''re sending
    from the same publisher?* We could use smart casts to solve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: The Observer design pattern is enormously useful. Its power lies in its flexibility.
    The publisher doesn't need to know anything about the subscribers, except the
    signature of the function it invokes. In the real world, it is widely used both
    in reactive frameworks, which we'll discuss in [*Chapter 6*](B17816_06_ePub.xhtml#_idTextAnchor164),
    *Threads and Coroutines*, and [*Chapter 11*](B17816_11_ePub.xhtml#_idTextAnchor251),
    *Reactive Microservices with Vert.x*, and in Android, where all the UI events
    are implemented as subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a long chapter, but we've also learned a lot. We finished covering
    all the classical design patterns, including 11 behavioral ones. In Kotlin, functions
    can be passed to other functions, returned from functions, and assigned to variables.
    That's what the higher-order functions and functions as first-class citizens concepts
    are all about. If your class is all about behavior, it often makes sense to replace
    it with a function. This concept helped us implement the Strategy and Command
    design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that the Iterator design pattern is yet another `operator` in the
    language. Sealed classes make the `when` statements exhaustive and we used them
    to implement the State design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the Interpreter design pattern and learned that lambda with
    a receiver allows clearer syntax in your DSLs. Another keyword, `lateinit`, tells
    the compiler to relax a bit when it's performing its null safety checks. *Use
    it with care!*
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered how to reference an existing method with function references
    while talking about the Observer design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll move on from the object-oriented programming paradigm,
    with its well-known design patterns, to another paradigm – functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between the Mediator and Observer design patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a **Domain-Specific Language** (**DSL**)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using a sealed class or interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
