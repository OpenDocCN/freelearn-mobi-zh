# 第8章. SceneKit

所以，这就是全部！最后，我们从2D世界过渡到3D。使用SceneKit，我们可以轻松地制作3D游戏，特别是由于SceneKit的语法与SpriteKit非常相似。

当我们说3D游戏时，并不意味着你可以戴上3D眼镜来玩游戏。在2D游戏中，我们主要在x和y坐标上工作。在3D游戏中，我们处理所有三个轴*x*、*y*和*z*。

此外，在3D游戏中，我们有不同类型的灯光可以使用。SceneKit还内置了物理引擎，它将处理重力等力，并有助于碰撞检测。

我们还可以在SceneKit中使用SpriteKit来添加GUI和按钮，以便我们可以添加分数和交互性。所以，本章有很多内容要介绍。让我们开始吧。

本章涵盖的主题如下：

+   使用SCNScene创建场景

+   向场景添加对象

+   从外部3D应用程序导入场景

+   向场景添加物理效果

+   添加敌人

+   检查碰撞检测

+   添加SpriteKit叠加层

+   添加触摸交互

+   完成游戏循环

+   添加墙壁和地板的视差效果

+   添加粒子

# 使用SCNScene创建场景

首先，我们创建一个新的SceneKit项目。它与创建其他项目非常相似。但这次，请确保您从**游戏技术**下拉列表中选择SceneKit。不要忘记为语言字段选择**Swift**。选择**iPad**作为设备，然后点击**下一步**以在所选目录中创建项目，如下面的截图所示：

![使用SCNScene创建场景](img/B04014_08_01.jpg)

创建项目后，打开它。点击`GameViewController`类，删除`viewDidLoad`函数中的所有内容，删除`handleTap`函数，因为我们将创建一个单独的类，并添加触摸行为。

创建一个名为`GameSCNScene`的新类，并导入以下头文件。从`SCNScene`类继承，并添加一个名为`init`的函数，该函数接受一个名为`view`的参数，其类型为`SCNView`：

[PRE0]

此外，创建两个新的常量`scnView`和`_size`，分别对应类型`SCNView`和`CGSize`。另外，添加一个名为`scene`的变量，其类型为`SCNScene`。

由于我们正在制作SceneKit游戏，我们必须获取当前视图，其类型为`SCNView`，类似于我们在SpriteKit中获取视图的方式，我们在SpriteKit中将当前视图类型转换为`SKView`。

我们创建一个`_size`常量来获取当前视图的大小。然后我们创建一个新的变量`scene`，其类型为`SCNScene`。`SCNScene`是SceneKit中用于创建场景的类，类似于我们使用`SKScene`在SpriteKit中创建场景的方式。

### 小贴士

Swift会自动提示创建`required init`函数，所以我们不妨将其包含在类中。

现在，转到`GameViewController`类，创建一个名为`gameSCNScene`的全局变量，其类型为`GameSCNScene`，并在`viewDidLoad`函数中将其赋值，如下所示：

[PRE1]

太好了！现在我们可以在`GameSCNScene`类中添加对象。最好将所有代码移动到单个类中，这样我们可以保持`GameSceneController`类整洁。

在`GameSCNScene`类的`init`函数中，在`super.init`函数之后添加以下代码：

[PRE2]

在这里，我们首先将当前视图分配给`scnView`常量。接下来，我们将`_size`常量设置为当前视图的尺寸。

接下来，我们初始化场景变量。然后，将场景分配给`scnView`的场景。接下来，启用`allowCameraControls`和`showStatistics`。这将使我们能够控制相机并在场景中移动它，以便更好地查看场景。此外，启用统计信息后，我们将看到游戏的表现，以确保帧率（FPS）保持稳定。

`scnView`的`backgroundColor`属性使我们能够设置视图的颜色。我将其设置为黄色，以便在场景中更容易看到对象，如以下截图所示。设置好所有这些后，我们可以运行场景。

![使用SCNScene创建场景](img/B04014_08_02.jpg)

嗯，目前还不是那么令人印象深刻。需要注意的一点是，我们还没有添加相机或灯光，但我们仍然看到了黄色的场景。这是因为虽然我们还没有向场景中添加任何内容，但SceneKit自动为创建的场景提供了默认的灯光和相机。

# 添加场景中的对象

让我们接下来向场景添加几何形状。在SceneKit中，我们可以轻松创建一些基本几何形状，如球体、盒子、圆锥体、环面等。让我们首先创建一个球体并将其添加到场景中。

## 将球体添加到场景中

在类中创建一个名为`addGeometryNode`的函数，并在其中添加以下代码：

[PRE3]

对于创建几何形状，我们使用`SCNSphere`类创建球体形状。我们还可以调用`SCNBox`、`SCNCone`、`SCNTorus`等来分别创建盒子、圆锥体或环面形状。

在创建球体时，我们必须提供一个半径作为参数，这将确定球体的大小。尽管为了放置形状，我们必须将其附加到一个节点上，这样我们就可以放置并添加它到场景中。

因此，创建一个新的常量`sphereNode`，其类型为`SCNNode`，并将球体几何形状作为参数传递。为了定位节点，我们必须使用`SCNvector3Make`属性通过提供`x`、`y`和`z`的值在3D空间中放置我们的对象。

最后，要将节点添加到场景中，我们必须调用`scene.rootNode`将`sphereNode`添加到场景中，这与SpriteKit不同，在SpriteKit中我们只需使用`addChild`将对象添加到场景中。

球体添加后，让我们运行场景。别忘了在`init`函数中添加`self.addGeometryNode()`。

我们确实添加了一个球体，那么为什么我们会看到一个圆（如以下截图所示）呢？嗯，SceneKit使用的基灯光源只是使我们能够看到场景中的对象。如果我们想看到实际的球体，我们必须改进场景的光源。

![将球体添加到场景中](img/B04014_08_03.jpg)

## 添加光源

让我们创建一个名为 `addLightSourceNode` 的新函数，如下所示，以便我们可以向场景添加自定义灯光：

[PRE4]

我们可以向球体对象添加一些光源，以便看到一些深度。在这里，我们添加两种类型的光源。第一种是泛光灯。泛光灯从一个点开始，然后光线均匀地向所有方向散射。我们还添加了一个环境光源。环境光是被其他物体反射的光，例如月光。

### 注意

还有两种类型的灯光：方向光和聚光灯。聚光灯很容易理解，我们通常在需要将某个对象（如舞台上的歌手）吸引注意时使用它。如果你想使光线朝一个单一方向传播，例如阳光，则使用方向光。太阳离地球非常远，当我们看到光线时，光线几乎是平行的。

在创建光源时，我们创建一个名为 `lightNode` 的节点，其类型为 `SCNNode`。然后，我们将 `SCNLight` 分配给 `lightNode` 的灯光属性。我们将泛光灯类型分配给灯光的类型。我们将光源的位置分配为在所有三个 *x*、*y* 和 *z* 坐标上的 10。然后，我们将它添加到场景的根节点。

接下来，我们在场景中添加一个环境光。这个过程的前两个步骤与创建任何光源的步骤相同：

1.  对于灯光类型，我们必须将 `SCNLightTypeAmbient` 分配给环境类型的光源。由于我们不希望光源非常强烈，因为它会被反射，所以我们分配一个 `darkGrayColor` 给颜色。

1.  最后，我们将光源添加到场景中。

没有必要将环境光源添加到场景中，但它会使场景的阴影更柔和。你可以移除环境光源以查看差异。

在 `init` 函数中调用 `addLightSourceNode` 函数。现在，构建并运行场景，以查看具有适当照明的实际球体，如下面的截图所示：

![添加光源](img/B04014_08_04.jpg)

你可以在屏幕上放置一个手指并移动它来旋转相机，因为我们已经启用了相机控制。你可以使用两个手指平移相机，你可以双击以将相机重置到其原始位置和方向。

## 添加相机到场景

接下来，让我们向场景添加一个相机，因为默认相机非常靠近。在类中创建一个名为 `addCameraNode` 的新函数，并在其中添加以下代码：

[PRE5]

在这里，我们再次创建一个名为 `cameraNode` 的空节点。我们将 `SCNCamera` 分配给 `cameraNode` 的相机属性。接下来，我们将相机定位，使 `x` 和 `y` 值保持在零，并在 `z` 方向上将相机向后移动 15 个单位。然后，我们将相机添加到场景的根节点。在 `init` 函数的底部调用 `addCameraNode`。

在这个场景中，原点位于场景中心，与SpriteKit中场景的原点始终位于场景右下角不同。在这里，正*x*和*y*是从中心向右和向上的。正*z*方向朝向你。

![添加相机到场景](img/B04014_08_05.jpg)

我们没有将球体移回或缩小其大小，这纯粹是因为我们在场景中向后移动了相机。

让我们接下来创建一个地板，这样我们就可以更好地理解场景中的深度。同时，通过这种方式，我们将学习如何在场景中创建地板。

## 添加地板

在类中添加一个名为`addFloorNode`的新函数，并添加以下代码：

[PRE6]

为了创建地板，我们创建了一个名为`floorNode`的变量，其类型为`SCNNode`。然后我们将`SCNFloor`分配给`floorNode`的几何属性。对于位置，我们将`y`值设置为`-1`，因为我们希望球体出现在地板上方。最后，像往常一样，我们将`floorNode`分配给场景的根节点。

在下面的屏幕截图中，我已经旋转了相机以展示整个场景的动作。在这里，我们可以看到地板是灰色的，球体在地面上投射出它的反射，我们还可以看到球体顶部左边的明亮泛光灯。

![添加地板](img/B04014_08_06.jpg)

# 从外部3D应用程序导入场景

虽然我们可以通过代码添加对象、相机和灯光，但当场景中添加了很多对象时，这会变得非常繁琐和混乱。在SceneKit中，这个问题可以通过导入其他3D应用程序预先构建的场景来轻松解决。

所有3D应用程序，如3D StudioMax、Maya、Cheetah 3D和Blender，都有导出Collada（`.dae`）和Alembic（`.abc`）格式场景的能力。我们可以直接将这些场景导入SceneKit，其中包含灯光、相机和纹理化对象，无需设置场景。

在本节中，我们将导入一个Collada文件到场景中。在本章的资源文件夹中，你可以找到`monsterScene.DAE`文件。将此文件拖动到当前项目中。

![从外部3D应用程序导入场景](img/B04014_08_07.jpg)

除了DAE文件外，还需要将`monster.png`文件添加到项目中，否则你将只看到场景中未纹理化的怪物网格。

点击`monsterScene.DAE`文件。如果纹理化的怪物没有自动加载，请将`monster.png`文件从项目中拖动到预览窗口中的怪物网格。当鼠标悬停在怪物网格上并出现一个(**+**)符号时，释放鼠标按钮。现在你将能够正确地看到怪物被纹理化。

左侧的面板显示了场景中的实体。在实体下方显示场景图，右侧的视图是预览窗格。

实体显示场景中的所有对象，场景图显示了这些实体之间的关系。如果你有某些对象是其他对象的子对象，场景图将它们显示为树状结构。例如，如果你打开**CATRigHub001**旁边的三角形，你将看到其下的所有子对象。

你可以使用场景图来移动和旋转场景中的对象以微调你的场景。你还可以添加节点，这些节点可以通过代码访问。你可以看到我们已经在场景中有一个相机和一个聚光灯。你可以选择每个对象，并使用对象的轴点上的箭头将其移动。

你还可以通过在预览场景上点击并拖动左鼠标按钮来旋转场景以获得更好的视角。为了缩放，上下滚动鼠标滚轮。要平移，按住键盘上的*Alt*键，然后左键点击并拖动预览窗格。

### 注意

需要注意的是，在预览窗格中进行旋转、缩放和平移实际上并不会移动你的相机。相机仍然处于相同的位置和角度。要从前视图查看，再次从预览窗格的下拉列表中选择**Camera001**选项，视图将重置为相机视图。

在预览窗口的底部，我们可以选择通过相机或聚光灯查看视图，或者点击并拖动以旋转自由相机。如果你在场景中有多于一个相机，那么在下拉列表中你将看到**Camera002**、**Camera003**等等。

在预览面板中的视图选择下拉菜单下方，你还有一个播放按钮。如果你点击播放按钮，你可以在预览窗口中查看怪物的默认动画。

预览面板就是这样；它只是为了帮助你更好地理解场景中的对象。它绝不是3DSMax、Maya或Blender等常规3D软件的替代品。

你可以在场景图中创建相机、灯光和空节点，*但无法添加如盒子或球体这样的几何形状*。你可以添加一个空节点并将其定位在场景图中，然后在代码中添加几何形状并将其附加到该节点上。

现在我们已经了解了场景图，让我们看看我们如何在SceneKit中运行这个场景。

在`init`函数中，删除我们初始化场景的行，并添加以下行代替。同时删除我们之前添加的对象、灯光和相机。

[PRE7]

构建并运行游戏以查看以下截图：

![从外部3D应用程序导入场景](img/B04014_08_08.jpg)

你将看到怪物在跑动，以及我们最初分配给场景的黄色背景。在导出场景时，如果你导出了动画，一旦场景在SceneKit中加载，动画就会自动播放。

此外，你还会注意到我们已经删除了场景中的相机和灯光。那么，为什么默认的相机和灯光没有加载到场景中呢？

这里发生的情况是，在我导出文件时，我在场景中插入了一个相机，并添加了一个聚光灯。因此，当我们将文件导入场景时，SceneKit自动理解场景中已经存在一个相机，因此它将使用该相机作为其默认相机。同样，场景中已经添加了一个聚光灯，它被视为默认光源，并且相应地计算照明。

# 向场景添加对象和物理

现在我们来看看我们如何访问场景图中的每个对象，并为怪物添加重力。在本章的后面部分，我们将看到如何添加一个触摸界面，通过这个界面我们可以通过施加向上的力使英雄角色跳跃。

## 访问英雄对象并添加物理身体

因此，创建一个名为`addColladaObjects`的新函数，并在其中调用一个`addHero`函数。创建一个名为`heroNode`的全局变量，其类型为`SCNNode`。我们将使用此节点来访问场景中的英雄对象。在`addHero`函数中，添加以下代码：

[PRE8]

首先，我们在`init`函数中调用`addColladaObjects`函数，如高亮所示。然后我们创建`addHero`函数。在其中我们初始化`heroNode`。然后，为了实际移动怪物，我们需要访问`CatRibHub001`节点来移动怪物。我们通过`scene.rootNode.ChildWithName`属性来获取访问权限。对于我们希望通过代码访问的每个对象，我们都需要使用场景的`rootNode`的`ChildWithName`属性，并传入对象的名称。

如果递归设置为`true`，SceneKit将通过所有子节点来获取该对象。由于我们正在寻找的节点就在顶部，所以我们将其设置为`false`以节省处理时间。

我们创建了一个临时变量`monsterNode`。在下一步中，我们将`monsterNode`变量添加到`heroNode`中。然后我们将英雄节点的位置设置为原点。

为了使`heroNode`能够与场景中的其他物理身体交互，我们必须为`heroNode`的物理身体分配一个形状。我们可以使用怪物的网格，但形状可能计算不正确，而一个盒子比怪物的网格简单得多。为了创建一个盒子碰撞器，我们创建了一个新的盒子几何体，其宽度、高度和深度大致与怪物的尺寸相匹配。

然后，使用`heroNode.physicsBody.physicsShape`属性，我们为其分配了我们为其创建的`collisionBox`的形状。由于我们希望物体受到重力的影响，我们将物理身体类型设置为动态。稍后我们将看到其他身体类型。

由于我们希望物体对重力有高度的反应，我们将物体的质量值设置为`20`。在下一步中，我们将所有三个方向的`angularVelocityFactor`设置为`0`，因为我们希望当施加垂直力时，物体能够直接上下移动。如果我们不这样做，物体将会翻来覆去。

我们还将名称`hero`分配给怪物，以检查碰撞的对象是否是英雄。这在我们检查与其他物体的碰撞时将非常有用。

最后，我们将`heroNode`添加到场景中。

将`addColladaObjects`添加到`init`函数中，如果你还没有做的话，请注释或删除`self.addGeometryNode`、`self.addLightSourceNode`、`self.addCameraNode`和`self.addFloorNode`函数。然后，运行游戏以查看怪物缓缓下落。

我们将在怪物正下方创建一小块地面，这样它就不会掉下来。

## 添加地面

创建一个名为`addGround`的新函数，并添加以下内容：

[PRE9]

我们创建了一个名为`groundBox`的新常量，其类型为`SCNBox`，宽度为`10`，长度为`10`，高度为`2`。倒角是盒子边缘的圆角。由于我们不想对角落进行任何圆角处理，所以它被设置为`0`。

接下来，我们创建一个名为`groundNode`的`SCNNode`，并将`groundBox`分配给它。我们将其放置在原点稍下方。由于盒子的高度为`2`，我们将其放置在`-1.01`处，这样当怪物静止在地面上时，`heroNode`将是`(0, 0, 0)`。

接下来，我们分配一个静态类型的物理体。由于我们不想让英雄在掉到地面上时弹起，我们将恢复系数设置为`0`。最后，我们将地面添加到场景的根节点。

我们将这个物体设置为静态而不是动态的原因是，动态物体会受到重力和其他力的作用，而静态物体则不会。因此，在这个场景中，尽管重力向下作用，英雄会掉落，但`groundBox`不会，因为它是一个静态物体。

你会看到物理语法与SpriteKit非常相似，包括静态物体和动态物体、重力等。而且，与SpriteKit一样，当我们运行场景时，物理模拟会自动开启。

在`addColladaObjects`函数中添加`addGround`函数，并运行游戏以查看怪物受到重力影响并在接触地面后停止。

![添加地面](img/B04014_08_09.jpg)

# 添加敌人节点

要在SceneKit中检查碰撞，我们可以检查英雄和地面之间的碰撞。但让我们让它更有趣，并学习一种新的物体类型：运动学物体。

为了这个目的，我们将创建一个新的名为`enemy`的盒子，并使其移动并与英雄碰撞。创建一个新的全局`SCNNode`，命名为`enemyNode`，如下所示：

[PRE10]

此外，在类中创建一个新的函数`addEnemy`，并在其中添加以下内容：

[PRE11]

这里没有什么特别的地方！就像添加`groundNode`时，我们创建了一个所有边长为四单位的立方体。我们还为其材质添加了黄色。然后在函数中初始化`enemyNode`。我们将节点沿*x*、*y*和**z**轴定位。将身体类型设置为运动学而非静态或动态。然后我们将身体添加到场景中，并最终将`enemyNode`命名为`enemy`，这是我们检查碰撞时需要的。在我们忘记之前，在调用`addHero`函数之后，在`addColladaObjects`函数中调用`addEnemy`函数。

### 注意

运动学身体与其他身体类型的区别在于，就像静态一样，外部力不能作用于身体，但我们可以对运动学身体施加力来移动它。

在静态身体的情况下，我们看到了它不受重力影响，即使我们对其施加力，身体也不会移动。

在这里，我们不会应用任何力来移动敌人方块，而只是像我们在SpriteKit游戏中移动敌人一样移动对象。所以，这就像是制作同样的游戏，但是在3D而不是2D中，这样你就可以看到，尽管我们有第三维度，但游戏开发的原则同样适用于两者。

为了移动敌人，我们需要为敌人添加一个`update`函数。因此，让我们通过创建一个`updateEnemy`函数并将其添加到其中来将其添加到场景中：

[PRE12]

在`update`函数中，类似于我们在SpriteKit游戏中移动敌人的方式，我们将敌人节点的`Z`位置增加0.9。不同的是，我们是在移动*z*方向。

当敌人超过*z*方向的`-40`时，我们重置敌人的位置。为了给玩家创造额外的挑战，当敌人重置时，会随机选择`1`和`2`之间的一个数字。如果是`1`，则敌人放置得更靠近地面，否则它放置在离地面15个单位的位置。

之后，我们将为英雄添加一个跳跃机制。因此，当敌人靠近地面时，英雄必须跳过敌人盒子，但如果敌人以高度生成，英雄则不应该跳跃。如果他跳跃并击中敌人盒子，那么游戏就结束了。之后我们还将添加一个计分机制来记录分数。

为了更新敌人，我们实际上需要一个更新函数来添加`enemyUpdate`函数，以便敌人移动并且其位置重置。因此，在类中创建一个名为`update`的函数，并在其中调用`updateEnemy`函数，如下所示：

[PRE13]

## 更新场景中的对象

在SceneKit中，有一个在场景渲染后调用的更新函数。我们将使用此函数来调用我们游戏的`update`函数。在`GameViewController`类中，添加以下函数：

[PRE14]

要调用`rendererUpdateAtTime`函数，`GameViewController`类需要继承自`SCNSceneRendererDelegate`。因此，在创建类的地方，添加以下代码：

[PRE15]

接下来，在`viewDidLoad`函数中，将当前代理设置为self，如下所示：

[PRE16]

### 注意

代理是代码设计模式的一部分。使用代理，一个类可以让另一个类获得访问权限并执行其部分职责。在这里，`SceneRenderer`通过将代理设置为self来将`scnView`委托出去。

`rendererUpdateAtTime`函数是一个系统函数，在场景中所有对象渲染完毕后被调用。因此，一旦场景渲染完毕，场景中的对象就可以更新，否则可能会导致伪影。

现在，如果我们构建并运行游戏，我们会看到`enemyBox`被更新。

但存在问题，当盒子击中英雄时，英雄从他的祭坛上被撞飞。这是因为，首先，英雄是一个动态体，所以外部力会影响他。其次，尽管我们手动移动盒子而没有施加任何力，但我们仍在移动盒子，并且SceneKit计算了一些惯性力，所以一旦盒子击中英雄，能量就转移到英雄身上，它就像施加在英雄身上的外部力一样，使英雄开始移动。

由于我们使用`heroNode.physicsBody?.angularVelocityFactor = SCNVector3Zero`限制了英雄的旋转，当盒子击中他时，他不会旋转。如果我们注释或删除该行，英雄会因为盒子的撞击而旋转。

![更新场景中的对象](img/B04014_08_10.jpg)

当我们检查碰撞时，我们将修复这个问题。当发生碰撞时，我们将英雄和盒子的位置重置到它们的初始位置。因此，让我们接下来看看如何检查碰撞。

## 检查物体之间的接触

SceneKit的物理引擎具有内置的函数，当启用物理时检查物体之间的接触。当两个物体即将接触时，会触发接触。

对于检查接触，我们必须使用`physicsWorld`的`didBeginContact`函数；因此，将以下代码添加到类中。同时，我们必须继承自`SCNPhysicsContactDelegate`并将`GameSCNScene`类设置为接触代理。

### 注意

类似于在`GameViewController`中调用`RenderDelegate`，为了能够通过物理引擎在提供的`GameSCNScene`中接收“接触”事件并能够操作它们，`GameSCNScene`类继承自`SCNPhysicsContactDelegate`，并且场景的`contactDelegate`被设置为`self`。

因此，在类的顶部，继承自`SCNPhysicsContactDelegate`：

[PRE17]

并且，在`init`函数中，添加以下内容以设置当前类为接触代理：

[PRE18]

接下来，将`didBeginContact`函数添加到类中，如下所示：

[PRE19]

当两个物理对象发生碰撞时，节点存储在`contact`变量中。由于我们已经为我们的物理体对象命名，我们检查第一个物体是否是英雄的，而英雄碰撞的另一个物体是否是敌人的。如果是，我们将打印出`contact`并也将第一个物体的速度设置为零。

由于我们的游戏规模较小，我们可以推测身体**A**将是英雄，而身体**B**将是敌人。在更大型的游戏中，每秒发生许多碰撞，可能很难确定哪个是身体**A**，哪个是身体**B**。在这种情况下，我们将不得不检查两种情况，即身体**A**是否是敌人还是英雄，以及身体**B**的相反情况，然后做出必要的结论。

因此，现在我们已经添加了英雄和敌人，并且我们设置了碰撞。接下来，我们将看到如何在我们的3D场景上实现2D覆盖层，以便我们可以显示按钮和得分，并为我们的简单游戏添加游戏结束条件。

# 添加SpriteKit覆盖层

为了显示游戏得分和按钮，我们将添加一个2D SpriteKit层。为了添加覆盖层，创建一个名为`OverlaySKscene`的类。在这个类中，添加以下内容：

[PRE20]

为了导入SpriteKit，我们必须创建一个SpriteKit的子类。创建全局变量`GameSCNScene`、`SKLabelNodes`和`SpriteNodes`类型。在这里，我们创建了两个`LabelNodes`：一个用于显示得分，另一个用于显示“游戏结束”文本。我们还创建了两个`spriteNodes`：一个用于播放按钮，另一个用于跳跃按钮。

我们添加所需的`init`函数和默认的`init`函数。默认的`init`将接受场景的大小和`GameSCNScene`类的引用作为参数。

在`init`函数中，我们初始化超类。

## 添加标签和按钮

接下来，在`init`函数中，添加以下代码：

[PRE21]

在`init`函数中，首先，我们将传递给`_gameScene`属性的`gameScene`设置为`gameScene`。

接下来，我们初始化`scoreLabel`和`gameOverLabel`。我们设置`text`、`color`、`textsize`和`position`的值，并将其添加到场景中。在`gameOverLabel`中，我们将`hidden`设置为`true`，因为我们只想在游戏结束后显示文本。

然后，我们初始化我们在SpriteKit中制作的播放和跳跃按钮。我们将跳跃按钮精灵设置为隐藏，因为我们希望它在播放按钮被点击并开始游戏时才显示。跳跃和播放按钮的图像在章节的资源文件夹中提供。

# 添加触摸交互性

为了添加触摸交互性，我们将使用与我们在SpriteKit中一直使用的类似方式的`touchesBegan`函数。因此，我们获取触摸位置和触摸下精灵的名称。如果精灵名称是`jumpBtn`且`gameOver`布尔值为`false`，则我们在`gameScene`类中调用`heroJump`函数。如果`gameOver`为`true`并且如果播放按钮被点击，则我们在SceneKit类中调用`startGame`函数。

因此，添加以下函数以检测触摸：

[PRE22]

这就是SpriteKit类的全部内容。我们将在SceneKit类中添加`gameOver`布尔值、`heroJump`和`startGame`函数。代码在创建之前会显示一些错误，所以现在请忽略这些错误。

# 完成游戏循环

返回 SceneKit 类，并在类顶部导入 SpriteKit，如下所示：

[PRE23]

此外，创建一个名为 `skScene` 的全局变量，类型为 `OverlaySKScene`。在 SceneKit 类中添加一个名为 `addSpriteKitOverlay` 的新函数，并添加以下代码：

[PRE24]

在这里，我们初始化之前创建的 `skScene` 全局变量，并传入当前场景的大小和当前 SceneKit 类。接下来，我们将 `skScene` 类分配给 `scnView` 的 `overlaySKScene` 属性。最后，我们将 `skScene` 变量的 `scaleMode` 设置为 `SKSceneScaleMode.ResizeFill` 类型。

最后，在 `addColladaObjects` 函数中调用 `addSpriteKitOverlay` 函数，如下所示：

[PRE25]

## 使英雄跳跃

我们仍然需要向类中添加布尔值和函数，以便我们的游戏能够运行。因此，在类顶部创建一个名为 `gameOver` 的全局变量，并将其设置为 `true`。

接下来，创建一个名为 `heroJump` 的新函数，如下所示：

[PRE26]

在这里，我们对 `heroNode` 应用一个向上的力 `1400` 单位在 *y* 方向上。

接下来，创建 `gameStart` 函数，如下所示，并将其添加到类中：

[PRE27]

将 `gameOver` 布尔值设置为 `false`。我们将跳跃按钮和 `scoreLabel` 设置为可见，并隐藏播放按钮和 `gameOverlabel`。

为了跟踪和显示得分，我们需要一个得分变量，因此创建一个名为 `score` 的全局变量，类型为 `int`，并在类顶部将其初始化为 `0`。同样，在 `startGame` 函数中，将值设置为 `0`，以便每次函数被调用时值都会重置。此外，我们将 `scoreLabel` 文本设置为反映游戏开始时的当前得分。

对于游戏中的得分，每次敌人方块超出屏幕并重置时，我们将增加分数。如果方块击中英雄，则游戏结束。

因此，在 `enemyUpdate` 函数中，在我们检查敌人的 `Z` 位置是否小于 `-40` 后，添加以下突出显示的行以更新得分和 `scoreLabel` 文本：

[PRE28]

## 设置游戏结束条件

在 `didBeginContact` 函数中，在我们将玩家的速度重置为零后，添加以下代码：

[PRE29]

在这里，我们将 `gameOver` 设置为 `true` 并调用一个 `GameOver` 函数，我们将设置标签和按钮的可见性。因此，向 SceneKit 类添加一个名为 `GameOver` 的新函数，如下所示：

[PRE30]

在这里，一旦游戏结束，我们将隐藏 `jumpButton` 并显示 `playButton` 和 `gameOverLabel`。然后我们将敌人英雄的位置重置到初始状态。

接下来，我们必须确保 `enemyUpdate` 函数仅在 `gameOver` 为 `false` 时被调用。在 `update` 函数中，将 `enemyUpdate` 函数包含在一个 `if` 语句中，如下所示：

[PRE31]

最后，我们必须调整场景中的重力，否则英雄会被抛到空中，因为当前的重力非常低。在 `addColladaObjects` 函数中，在函数末尾添加以下行：

[PRE32]

现在我们的游戏循环已经准备好了。如果你按下播放按钮，游戏将开始，跳跃按钮将可见，并且当按下时英雄将跳跃。每次英雄成功避开敌人方块时，分数都会增加，如果英雄碰到敌人方块，游戏将结束。游戏结束后，播放按钮将可见，跳跃按钮将隐藏。再次轻触播放按钮将重置一切，游戏将再次开始。

## 修复跳跃

尽管如此，仍然有一个问题。你可以一直按跳跃按钮，英雄会一直向上跳。我们不想这样。我们希望英雄只有在落地时才能跳跃。为此，我们将添加一个小计数器，并在英雄在空中时禁用跳跃。

为了做到这一点，添加一个名为`jumpCounter`的新全局变量，其类型为`int`，并将其初始化为`0`。在类的`update`函数中添加以下内容：

[PRE33]

在这里，我们减少`jumpCounter`的值，一旦它小于零，我们就将其值设置为`0`。

接下来，在`heroJump`函数中，将我们对英雄施加跳跃力量的部分放在以下if条件中：

[PRE34]

现在，英雄只有在`jumpCounter`等于0时才会跳跃。如果它等于`0`，那么就会施加力量，并将计数器设置为`25`。

### 注意

这个数字是通过试错得出的，以确保怪物在空中时不会按下跳跃按钮。

在`update`函数中，我们减少这个值，直到那时不能施加力量。一旦`jumpCounter`再次设置为`0`，英雄就可以再次跳跃。

因此，最终，我们可以运行并测试游戏。确保在`addColladaObjects`函数中调用`addSpriteKitOverlay`函数。

![修复跳跃](img/B04014_08_11.jpg)

# 添加墙壁和地板视差

没有视差效果的游戏是什么？在SpriteKit中，我们使用精灵添加了视差，而在SceneKit中，我们将使用平面将其添加到场景中。除了添加视差之外，我们还将了解如何向平面添加漫反射、法线和高光贴图。我们还将学习这些术语的含义。

所以，像往常一样，我们创建一个新的函数，在其中我们将添加所有这些平面。按照以下方式添加四个全局`SCNNodes`：

[PRE35]

还要向场景添加一个名为`addWallandFloorParallax`的函数，如下所示：

[PRE36]

OMG！！这是一大堆代码。但别慌。我们将系统地通过它。只需看看代码中写着`准备墙壁几何形状`的地方。首先，我们将看看墙壁几何形状是如何设置的，然后一旦你理解了它，我们将看看如何设置地板几何形状。

我们创建了一个名为`wallGeometry`的新常量，并将其分配给`SCNPlane`。`SCNPlane`和`SCNFloor`之间的区别在于，在这里我们可以设置平面的尺寸。所以，非常简单，我们将平面的宽度和高度设置为`250`乘以`120`单位。

接下来，我们给平面分配一个材质。到目前为止，我们只看到了如何在SceneKit中给对象分配颜色。这里我们给平面分配了三种类型的贴图。第一种是漫反射。

### 注意

漫反射材质是你想要粘贴到平面上的图像或纹理。

文本纹理就像墙上的壁纸。想象一下未粉刷的墙面；现在你可以选择给墙面涂色或者贴上壁纸。在数字世界中添加油漆是通过应用颜色来完成的，就像我们在`enemyblock`上所做的那样，我们给它分配了一个黄色的漫反射颜色。要在数字世界中应用壁纸，我们使用纹理或图像。在这里，我们将`wall.png`图像应用到墙面平面几何上。

注意到，从宽度和高度的角度来看，墙面平面相当大。如果我们让它保持原样，`wall.png`图像将不得不拉伸以适应墙面的尺寸。所以，我们使用`wrapt`和`wraps`函数，使得墙面纹理在平面的*x*和*y*方向上重复，而不拉伸墙面纹理。所以这就是在接下来的两行中发生的事情。我们只是在两个方向上重复墙面纹理，直到它填满整个平面。

在下一步中，我们将`mipFiler`分配给`linear`。过滤器将决定需要添加多少细节到纹理中。如果相机足够远，它将生成一个低分辨率的纹理以减少CPU的负担。如果相机靠近，则将创建一个更高分辨率的图像，以便纹理的所有细节都可见。这纯粹是用于优化目的。线性过滤器模式是过滤器最基本的一种模式。还有其他模式，如双线性、三线性等，将提供更好的结果，但计算成本较高。对于我们的目的，线性过滤就足够了。你可以通过更改代码并在设备上运行游戏来看到差异。

对于最后的漫反射，我们根据纹理在平面上看起来有多大或有多小来缩小图像本身的纹理。在缩放时，我们将其缩放到与几何尺寸相同的比例。所以在这里的*x*和*y*平面上，我们将其缩小到几何宽度和高度的1/40倍。由于我们不在*z*方向上缩放，我们将其保持在`1`。

以下就是墙面的漫反射贴图图像：

![添加墙面和地板的视差效果](img/B04014_08_12.jpg)

现在，同样的五个步骤也重复用于法线贴图和镜面反射贴图。我们看到为了给平面添加壁纸，我们必须使用漫反射贴图。现在，如果这个壁纸有一些凹凸和孔洞怎么办？不是所有的墙面都这么光滑。所以，为了给壁纸添加这种粗糙感，我们使用所谓的法线贴图。以下就是法线贴图的图像：

![添加墙面和地板的视差效果](img/B04014_08_13.jpg)

这基本上计算了光线一旦击中正常表面后应该如何行为。根据光线的方向以及正常图中是否有凹坑或孔洞，照明将自动计算。所有这些操作都使用正常图来完成。正常图不过是一张图片。代码将从这张图片中获取信息以创建所需的效果。因此，我们分配一个名为 `wall_NRM.png` 的正常图，并将其作为内容。接下来的四个步骤与我们对漫反射图所做的步骤非常相似。

接下来，让我们看看高光图。这张图将决定纹理的哪些部分是闪亮的，哪些部分不是。想象一下，如果你的壁纸是由不锈钢制成的。为了产生这种效果，我们分配高光图，并使用 `wall_SPEC.png` 文件来添加它。接下来的四个步骤与之前相同，但现在我们分别对高光图进行操作。高光图的图像如下：

![添加墙壁和地板透视](img/B04014_08_14.jpg)

对于地板几何形状，也重复相同的步骤，只是这次我们翻转了宽度和高度值。

一旦地板和墙壁的几何形状准备就绪，我们将它们分配给墙壁和地板节点。

对于墙壁节点，我们将几何形状分配给节点。然后我们旋转节点，使墙壁垂直。我们在 *y* 方向上旋转节点 -90 度。然后我们将第一面墙放置在 `(15, 0, 0)`，然后将其添加到场景中。我们将第二面墙节点放置在 `(15, 0, 250)`，这将使其与第一个平面相邻。

对于地板节点，我们遵循类似的过程，但在这里我们必须旋转两次才能使其与地面水平。

在我们的墙壁和地板节点准备就绪后，我们可以更新平面的位置以创建透视效果。因此，在 `update` 函数中，添加以下代码：

[PRE37]

现在对你来说这应该非常熟悉了。就像我们在 SpriteKit 游戏中更新和重置背景精灵一样，我们现在将更新四个节点的位置，然后如果它们在 *z* 方向上超过 250 个单位，我们将重置所有节点的位置。

将 `addWallandFloorParallax` 函数添加到 `addColladaObjects` 函数中。

对于这个场景，我还使用场景图添加了一个环境光节点，否则场景看起来非常暗。转到 `monsterScene.DAE` 文件，在场景图中点击加号并添加一个新节点。然后，右键单击节点并选择 **addLight**。在右侧面板中，选择 **Attributes** 检查器，在 **Type** 下选择 **Ambient**。在 **Type** 下方选择 **Color** 并选择深蓝色或紫色。现在运行游戏，你应该会看到以下截图所示的结果：

![添加墙壁和地板透视](img/B04014_08_15.jpg)

# 添加粒子

作为锦上添花的部分，我们将包括一个雨粒子效果。要在 SceneKit 中创建粒子效果，请转到 **文件** | **新建**，在 **资源** 下选择 **SceneKit 粒子系统**。点击 **下一步**，在下一屏幕上，从 **粒子系统模板** 下拉列表中选择 **Rain**。点击 **下一步**，并为文件命名。我将其命名为 `rain`。因此，现在你将在项目中拥有 `rain.scnp` 和 `spark.png` 文件。

为了更好地定位粒子，前往场景图并创建一个名为 `particleNode` 的节点，并将节点平移和旋转，使其指向英雄。

在类中创建一个名为 `addRainParticle` 的新函数，并添加以下代码：

[PRE38]

我们创建了一个名为 `rain` 的新常量，并将其分配给 `SCNParticleSystem`，并在其中提供了我们创建的 `rain` 粒子系统。

创建了一个新的 `SCNNode` 被称为 `particleEmitterNode`，并将我们在场景图中创建的 `particleNode` 分配给它。然后我们将雨粒子系统分配给它。然后我们将 `particleEmitterNode` 添加到场景中。

我们使用粒子系统的 `warmupDuration` 并将其分配一个值为 `10` 的值。这样做是为了当游戏开始时，雨粒子效果被快速播放，看起来就像已经开始下雨了。

你可以选择 `rain.scnp` 文件并更改参数以更好地满足你的需求。构建并运行以查看我们完成的 SceneKit 游戏。在 `addColladaObjects` 函数的末尾调用 `addRainParticle` 函数。

![添加粒子](img/B04014_08_16.jpg)

### 小贴士

将音频添加到游戏中与我们将主旋律添加到 SpriteKit 游戏中的方式完全相同。所以，我将留给你大家去实验，找出如何将音频添加到场景中。

此外，我不想再次重复如何将资产导入到游戏中，因为我们已经看到如何做这件事超过四章了。但请确保在调用文件时提供正确的文件夹位置。如果不这样做，则资产将无法正确检索，导致构建错误。

# 概述

在本章中，我们看到了如何在 SceneKit 中制作 3D 游戏。从制作简单的几何形状到地板，我们创建了一个完整的游戏，包括完整的游戏循环。我们已将已在 3D 软件包中创建并带有动画的场景添加到 SceneKit 中。由于它已经是 3D 场景的一部分，因此我们无需添加相机或光源。

我们将 COLLADA 对象导入到场景中，并看到了如何通过代码访问对象。我们在场景中添加了敌人并应用了物理。我们使用 SceneKit 的物理引擎来计算碰撞，并也对英雄对象应用了力。

此外，你还看到了如何将 SpriteKit 集成到 SceneKit 中以在场景中显示分数和按钮。我们还使用了 SpriteKit 的 `touchBegan` 函数来检测屏幕上的触摸，并创建了播放和跳跃按钮。

场景中还添加了视差滚动效果，使用的是平面。此外，你还看到了不同类型的贴图，如漫反射贴图、法线贴图和镜面反射贴图，以及它们各自的功能。最后，我们还向场景中添加了一个雨粒子系统。

在下一章中，你将更深入地学习图形编程，并了解如何使用 Metal 图形库将对象实际显示在屏幕上。
