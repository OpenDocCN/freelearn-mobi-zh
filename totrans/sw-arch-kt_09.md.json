["```kt\n(CreatedEvent) -> Aggregate\n(UpdatedEvent, Aggregate) -> Aggregate\n```", "```kt\ndata class Contract(\n    val id: UUID,\n    val draftedAt: Instant,\n    val updatedAt: Instant? = null,\n    val version: Int,\n    val partyA: Party,\n    val partyB: Party,\n)\ndata class Party(\n    val householdName: String,\n    val serviceProvided: String,\n    val agreedAt: Instant? = null\n)\n```", "```kt\ninterface ContractEvent {\n    val contractId: UUID\n    val targetVersion: Int\n    val time: Instant\n}\n```", "```kt\nclass EventStore<KEY, AGGREGATE> {\n    private val aggregatesByKey = mutableMapOf<KEY, List<AGGREGATE>>()\n    fun append(id: KEY, payload: AGGREGATE) {\n        aggregatesByKey.merge(id, listOf(payload)) { t1, t2 -> t1 + t2 }\n    }\n    fun get(id: KEY): List<AGGREGATE>? = aggregatesByKey[id]\n}\n```", "```kt\ndata class ContractDraftedEvent(\n    override val contractId: UUID,\n    override val targetVersion: Int = 0,\n    override val time: Instant,\n    val draftedByHousehold: String,\n    val counterpartyHousehold: String,\n    val serviceProvided: String,\n    val serviceReceived: String,\n) : ContractEvent\n```", "```kt\nfun ContractDraftedEvent.play(): Contract = Contract(\n    id = contractId,\n    draftedAt = time,\n    version = targetVersion,\n    partyA = Party(\n        householdName = draftedByHousehold,\n        serviceProvided = serviceProvided\n    ),\n    partyB = Party(\n        householdName = counterpartyHousehold,\n        serviceProvided = serviceReceived\n    )\n)\n```", "```kt\ndata class ContractAmendedEvent(\n    override val contractId: UUID,\n    override val targetVersion: Int,\n    override val time: Instant,\n    val amendedByHousehold: String,\n    val serviceProvidedUpdate: String?,\n    val serviceReceivedUpdate: String?,\n) : ContractEvent\ndata class ContractAgreedEvent(\n    override val contractId: UUID,\n    override val targetVersion: Int,\n    override val time: Instant,\n    val agreedByHousehold: String,\n) : ContractEvent\n```", "```kt\nfun ContractAmendedEvent.play(current: Contract): Contract {\n    validate(current, amendedByHousehold)\n    return if (amendedByHousehold == current.partyA.householdName) {\n        current.copy(\n            version = targetVersion,\n            updatedAt = time,\n            partyA = current.partyA.copy(\n                serviceProvided = serviceProvidedUpdate ?: current.partyA.serviceProvided\n            ),\n            partyB = current.partyB.copy(\n                serviceProvided = serviceReceivedUpdate ?: current.partyB.serviceProvided\n            )\n        )\n    } else {\n        current.copy(\n            version = targetVersion,\n            updatedAt = time,\n            partyA = current.partyA.copy(\n                serviceProvided = serviceReceivedUpdate ?: current.partyA.serviceProvided\n            ),\n            partyB = current.partyB.copy(\n                serviceProvided = serviceProvidedUpdate ?: current.partyB.serviceProvided\n            )\n        )\n    }\n}\nfun ContractAgreedEvent.play(current: Contract): Contract {\n    validate(current, agreedByHousehold)\n    return if (agreedByHousehold == current.partyA.householdName) {\n        current.copy(\n            version = targetVersion,\n            updatedAt = time,\n            partyA = current.partyA.copy(agreedAt = time),\n        )\n    } else {\n        current.copy(\n            version = targetVersion,\n            updatedAt = time,\n            partyB = current.partyB.copy(agreedAt = time)\n        )\n    }\n}\n```", "```kt\nfun <T : ContractEvent> T.validate(current: Contract, expectedHouseholdName: String): T {\n    require(contractId == current.id) {\n        \"Aggregate ID mismatch - expected: $contractId, was ${current.id}\"\n    }\n    require(targetVersion == current.version + 1) {\n        \"Unexpected version - expected: ${targetVersion - 1}, was ${current.version}\"\n    }\n    require(\n        expectedHouseholdName == current.partyA.householdName ||\n            expectedHouseholdName == current.partyB.householdName\n    ) {\n        \"Unexpected household - expected: ${expectedHouseholdName}, was ${\n            listOf(current.partyA.householdName, current.partyB.householdName)\n        }\"\n    }\n    return this\n}\n```", "```kt\nfun List<ContractEvent>.play(): Contract? {\n    if (isEmpty()) return null\n    var current: Contract = (first() as ContractDraftedEvent).play()\n    var index = 1\n    while (index < size) {\n        val event = get(index++)\n        current = when (event) {\n            is ContractAmendedEvent -> event.play(current)\n            is ContractAgreedEvent -> event.play((current))\n            else -> throw IllegalArgumentException(\"Unsupported event\")\n        }\n    }\n    return current\n}\n```", "```kt\n    val contractId = UUID.randomUUID()\n    val eventStore = EventStore<UUID, ContractEvent>()\n    val createdEvent = ContractDraftedEvent(\n        contractId = contractId,\n        time = Instant.now(),\n        draftedByHousehold = \"HouseholdA\",\n        counterpartyHousehold = \"HouseholdB\",\n        serviceProvided = \"Cleaning\",\n        serviceReceived = \"Babysitting\"\n    )\n    val amendedEvent = ContractAmendedEvent(\n        contractId = contractId,\n        targetVersion = 1,\n        time = Instant.now(),\n        amendedByHousehold = \"HouseholdB\",\n        serviceReceivedUpdate = \"Dish washing\",\n        serviceProvidedUpdate = null\n    )\n    val agreedEventByHouseholdA = ContractAgreedEvent(\n        contractId = contractId,\n        targetVersion = 2,\n        time = Instant.now(),\n        agreedByHousehold = \"HouseholdA\"\n    )\n    val agreedEventByHouseholdB = ContractAgreedEvent(\n        contractId = contractId,\n        targetVersion = 3,\n        time = Instant.now(),\n        agreedByHousehold = \"HouseholdB\"\n    )\n    listOf(\n        createdEvent,\n        amendedEvent,\n        agreedEventByHouseholdA,\n        agreedEventByHouseholdB\n    ).forEach { eventStore.append(contractId, it) }\n    val aggregate = eventStore.get(contractId)?.play()\n    println(\"Aggregate is of version: ${aggregate?.version}\")\n```", "```kt\nAggregate is of version: 3\n```", "```kt\nval expire = If (event.time < System.currentMillis()) true else false\n```", "```kt\nval externalValueId = \"${event.id}-${event.value.id}\"\n```", "```kt\ndata class CurrentContractQuery(\n    val contractId: UUID\n)\ndata class DraftContractCommand(\n    val draftedByHousehold: String,\n    val counterpartyHousehold: String,\n    val serviceProvided: String,\n    val serviceReceived: String,\n)\ndata class AgreeContractCommand(\n    val contractId: UUID,\n    val agreedByHousehold: String,\n)\n```", "```kt\ndata class Failure<T>(\n    val request: T,\n    val message: String? = null,\n    val error: Throwable? = null\n)\n```", "```kt\nfun CurrentContractQuery.handle(\n    eventStore: EventStore<UUID, ContractEvent>\n): Contract? = eventStore.get(contractId)?.play()\n```", "```kt\nfun DraftContractCommand.handle(\n    eventStore: EventStore<UUID, ContractEvent>,\n    onSuccess: (ContractDraftedEvent) -> Unit,\n    onFailure: (Failure<DraftContractCommand>) -> Unit\n) {\n    if (draftedByHousehold == counterpartyHousehold) {\n        onFailure(Failure(this, \"Same household is not allowed: $draftedByHousehold\"))\n    } else {\n        ContractDraftedEvent(\n            contractId = UUID.randomUUID(),\n            time = Instant.now(),\n            draftedByHousehold = draftedByHousehold,\n            counterpartyHousehold = counterpartyHousehold,\n            serviceReceived = serviceReceived,\n            serviceProvided = serviceProvided\n        ).also{\n            eventStore.append(it.contractId, it)\n        }.also(onSuccess)\n    }\n}\n```", "```kt\nfun AgreeContractCommand.handle(\n    eventStore: EventStore<UUID, ContractEvent>,\n    onSuccess: (ContractAgreedEvent) -> Unit,\n    onFailure: (Failure<AgreeContractCommand>) -> Unit) {\n    validate(\n        eventStore = eventStore,\n        contractId = contractId,\n        householdName = agreedByHousehold,\n        onSuccess = { contract ->\n            ContractAgreedEvent(\n                contractId = contractId,\n                targetVersion = contract.version + 1,\n                time = Instant.now(),\n                agreedByHousehold\n            ).also { eventStore.append(contractId, it)\n            }.also(onSuccess)\n        },\n        onFailure = { onFailure(it)}\n    )\n}\n```", "```kt\nfun <T> T.validate(\n    eventStore: EventStore<UUID, ContractEvent>,\n    contractId: UUID,\n    householdName: String,\n    onSuccess: (Contract) -> Unit,\n    onFailure: (Failure<T>) -> Unit) {\n    val events = eventStore.get(contractId)\n    if (events == null) {\n        onFailure(Failure(this, \"Contract not found: $contractId\"))\n    } else {\n        val contract = events.play()\n        if (contract == null) {\n            onFailure(Failure(this, \"Failed to reconstruct Contract: $contractId\"))\n        } else if (contractId != contract.id) {\n            onFailure(Failure(this, \"Contract ID mismatched. Expected: $contractId, was: ${contract.id}\"))\n        } else if (householdName != contract.partyA.householdName\n            && householdName != contract.partyB.householdName) {\n            onFailure(Failure(this, \"Household not found in contract: $householdName\"))\n        } else {\n            onSuccess(contract)\n        }\n    }\n}\n```", "```kt\n    var contractId: UUID? = null\n    val eventStore = EventStore<UUID, ContractEvent>()\n    DraftContractCommand(\n        draftedByHousehold = \"HouseholdA\",\n        counterpartyHousehold = \"HouseholdB\",\n        serviceProvided = \"Cleaning\",\n        serviceReceived = \"Babysitting\"\n    ).handle(\n        eventStore = eventStore,\n        onSuccess = { contractId = it.contractId\n            println(\"Contract drafted: $contractId\") },\n        onFailure = { \"Failed to draft contract: $it\"}\n    )\n    AmendContractCommand(\n        contractId = contractId!!,\n        amendedByHousehold = \"HouseholdB\",\n        serviceReceivedUpdate = \"Dish washing\",\n        serviceProvidedUpdate = null\n    ).handle(eventStore = eventStore,\n        onSuccess = { println(\"Contract amended: $contractId\") },\n        onFailure = { println(\"Failed to amend contract: $contractId\")}\n    )\n```", "```kt\n    AgreeContractCommand(\n        contractId = contractId!!,\n        agreedByHousehold = \"HouseholdA\"\n    ).handle(eventStore = eventStore,\n        onSuccess = { println(\"Contract agreed: $contractId\") },\n        onFailure = { println(\"Failed to amend contract: $contractId\")}\n    )\n    AgreeContractCommand(\n        contractId = contractId!!,\n        agreedByHousehold = \"HouseholdB\"\n    ).handle(eventStore = eventStore,\n        onSuccess = { println(\"Contract agreed: $contractId\") },\n        onFailure = { println(\"Failed to amend contract: $contractId\")}\n    )\n```", "```kt\n    val aggregate = CurrentContractQuery(contractId!!).handle(eventStore)\n    println(\"Aggregate is of version: ${aggregate?.version}\")\n```", "```kt\nContract drafted: 3a25642c-fc9b-4024-b862-daf10fc645a6\nContract amended: 3a25642c-fc9b-4024-b862-daf10fc645a6\nContract agreed: 3a25642c-fc9b-4024-b862-daf10fc645a6\nContract agreed: 3a25642c-fc9b-4024-b862-daf10fc645a6\nAggregate is of version: 3\n```"]