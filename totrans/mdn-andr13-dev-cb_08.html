<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor382"/>8</h1>
<h1 id="_idParaDest-217"><a id="_idTextAnchor383"/>Getting Started with Paging</h1>
<p>In Android development, the Paging library helps developers load and display data pages from a larger dataset from local storage or over a network. This can be a common case if your application loads considerable amounts of data for people to read. For instance, a good example is Twitter; you might notice the data refreshes due to the many tweets that people send daily.</p>
<p>Hence, in <strong class="bold">Modern Android Development</strong> (<strong class="bold">MAD</strong>), Android developers might want to implement the Paging library in their applications to help them with such instances when loading data. In this chapter, you will learn how to utilize the Paging library in your projects.</p>
<p>In this chapter, we’ll cover the following recipes:</p>
<ul>
<li>Implementing the Jetpack Paging library</li>
<li>Managing present and loading states</li>
<li>Implementing your custom pagination in Jetpack Compose</li>
<li>Loading and displaying paged data</li>
<li>Understanding how to transform data streams</li>
<li>Migrating to Paging 3 and understanding the benefits</li>
<li>Writing tests for your Paging Source</li>
</ul>
<h1 id="_idParaDest-218"><a id="_idTextAnchor384"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight</a>. You will also need to get an API key for <a href="https://newsapi.org/">https://newsapi.org/</a>. <code>NewsApi</code> is a worldwide API for news.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor385"/>Implementing the Jetpack Paging library</h1>
<p>The Paging library<a id="_idIndexMarker498"/> comes with incredible features for developers. If your codebase is established and extensive, there are other custom ways that developers have created to help them load data efficiently. One notable advantage of Paging is its in-memory caching for your page’s data, which ensures your application uses the system resources efficiently while working with the already paged data.</p>
<p>In addition, it offers support for Kotlin coroutine flows and LiveData and has built-in deduplication, which ensures your application uses network bandwidth and resources efficiently, which can help save battery. Finally, the Paging library offers support for error handling, including when refreshing and retrying your data.<a id="_idTextAnchor386"/></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor387"/>Getting ready</h2>
<p>In this recipe, we will need to create a new project; if you need to reference a previous recipe for creating a new project, you can visit <a href="B18827_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Modern Android </em><em class="italic">Development Skills</em>.<a id="_idTextAnchor388"/></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor389"/>How to do it…</h2>
<p>Let’s go ahead and create a new empty Compose project and call it<code> PagingJetpackExample</code>. In our example project, we will use the free <code>NewsApi</code> to display the news to our users. To get started, check<a id="_idIndexMarker499"/> out this link at <a href="https://newsapi.org/docs/get-started">https://newsapi.org/docs/get-started</a>. Also, ensure you get your API for the project, as it is a requirement for this recipe. Follow these steps to get started:</p>
<ol>
<li>Let’s go ahead and add the following required dependencies. In addition, since we will be doing a network call, we need to add a library to handle this. As for the correct versioning, check out the <em class="italic">Technical requirements</em> section for the code and the correct version. We will provide <code>2.x.x</code> so you can check compatibility if you are upgrading or already have <code>Retrofit</code> in your project and Coil which is a fast, lightweight, and flexible image loading library. It is designed to simplify the process of loading images from various sources (such as network, local storage, or content providers) and displaying them in ImageView or other image-related UI components:<pre class="source-code">
//Retrofit</pre><pre class="source-code">
implementation 'com.squareup.retrofit2:retrofit:2.x.x'</pre><pre class="source-code">
implementation 'com.squareup.retrofit2:converter-gson:2.x.x'</pre><pre class="source-code">
//Coil you can also use Glide in this case</pre><pre class="source-code">
implementation 'com.google.accompanist:accompanist-coil:0.x.x'</pre><pre class="source-code">
//Paging 3.0</pre><pre class="source-code">
implementation 'Androidx.Paging:Paging-compose:1.x.x'</pre></li>
<li>After the project <a id="_idIndexMarker500"/>syncs and is ready, go ahead and remove the <code>Greeting</code> composable function that comes with the project. You should have just your theme, and your surface<a id="_idIndexMarker501"/> should be empty. In addition, for the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) portion of this recipe, you can get the entire code from the <em class="italic">Technical </em><em class="italic">requirements</em> section.</li>
<li>Also, when using an API, developers tend to forget to add the <code>Android.permission.INTERNET </code>permission on the manifest, so let’s do that now before we forget it:<pre class="source-code">
&lt;uses-permission Android:name="Android.permission.INTERNET"/&gt;</pre></li>
<li>Now, create a package and call it <code>data</code>; we will add our model and service files to this package. In addition, ensure you go through the News API <strong class="bold">Documentation</strong> section to understand how the API works:<pre class="source-code">
data class NewsArticle(</pre><pre class="source-code">
    val author: String,</pre><pre class="source-code">
    val content: String,val title: String ...)</pre></li>
<li>Let us now create our <code>NewsArticleResponse</code> data class, which we will implement in our <code>NewsApiService</code> interface. Our API call type is <code>@GET()</code>, which means exactly “to get.” A more detailed explanation of <code>GET</code> is provided in the <em class="italic">How it works</em> section. Our call seeks to return a call object containing the data in the form of the <code>NewsArticleResponse</code> data class:<pre class="source-code">
data class NewsArticleResponse(</pre><pre class="source-code">
    val articles: List&lt;NewsArticle&gt;,</pre><pre class="source-code">
    val status: String,</pre><pre class="source-code">
    val totalResults: Int</pre><pre class="source-code">
)</pre><pre class="source-code">
interface NewsApiService{</pre><pre class="source-code">
    @GET("everything?q=apple&amp;sortBy=popularity&amp;apiKey=        ${YOURAPIKEY}&amp;pageSize=20")</pre><pre class="source-code">
    suspend fun getNews(</pre><pre class="source-code">
        @Query("page") page: Int</pre><pre class="source-code">
    ): NewsArticleResponse</pre><pre class="source-code">
}</pre></li>
<li>Create another<a id="_idIndexMarker502"/> class called <code>NewsArticlePagingSource()</code>; our class will use <code>NewsApiService</code> as the input parameter. When exposing any large datasets through APIs, we need to provide a mechanism to paginate the list of resources. To implement it, we need to pass the type of the Paging key and the type of data to load, which in our case is <code>NewsArticle</code>:<pre class="source-code">
class NewsArticlePagingSource(</pre><pre class="source-code">
    private val newsApiService: NewsApiService,</pre><pre class="source-code">
): PagingSource&lt;Int, NewsArticle&gt;() {</pre><pre class="source-code">
. . .</pre><pre class="source-code">
}</pre></li>
<li>Finally, let us go ahead and override <code>getRefreshKey()</code> provided by the <code>PagingSource</code> and <code>load()</code> suspend functions. We will discuss the <code>load()</code> and <code>PagingSource</code> suspend functions<a id="_idIndexMarker503"/> in detail in the <em class="italic">Loading and displaying paged </em><em class="italic">data</em> recipe:<pre class="source-code">
class NewsArticlePagingSource(</pre><pre class="source-code">
    private val newsApiService: NewsApiService,</pre><pre class="source-code">
) : PagingSource&lt;Int, NewsArticle&gt;() {</pre><pre class="source-code">
    override fun getRefreshKey(state: PagingState&lt;Int,</pre><pre class="source-code">
    NewsArticle&gt;): Int? {</pre><pre class="source-code">
        return state.anchorPosition?.let {</pre><pre class="source-code">
        anchorPosition -&gt;</pre><pre class="source-code">
            state.closestPageToPosition(</pre><pre class="source-code">
                anchorPosition)?.prevKey?.plus(1)</pre><pre class="source-code">
                ?: state.closestPageToPosition(</pre><pre class="source-code">
                    anchorPosition)?.nextKey?.minus(1)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override suspend fun load(params:</pre><pre class="source-code">
    LoadParams&lt;Int&gt;): LoadResult&lt;Int, NewsArticle&gt; {</pre><pre class="source-code">
        return try {</pre><pre class="source-code">
            val page = params.key ?: 1</pre><pre class="source-code">
            val response = newsApiService.getNews(</pre><pre class="source-code">
                page = page)</pre><pre class="source-code">
            LoadResult.Page(</pre><pre class="source-code">
                data = response.articles,</pre><pre class="source-code">
                prevKey = if (page == 1) null else</pre><pre class="source-code">
                    page.minus(1),</pre><pre class="source-code">
                nextKey = if</pre><pre class="source-code">
                    (response.articles.isEmpty()) null</pre><pre class="source-code">
                        else page.plus(1),</pre><pre class="source-code">
            )</pre><pre class="source-code">
        } catch (e: Exception) {</pre><pre class="source-code">
            LoadResult.Error(e)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now, let’s create our repository; a repository<a id="_idIndexMarker504"/> is a class that isolates the data sources, such as a web service or a Room database, from the rest of the app. Since we do not have a Room database, we will work with the web service data:<pre class="source-code">
class NewsArticleRepository @Inject constructor(</pre><pre class="source-code">
    private val newsApiService: NewsApiService</pre><pre class="source-code">
) {</pre><pre class="source-code">
    fun getNewsArticle() = Pager(</pre><pre class="source-code">
        config = PagingConfig(</pre><pre class="source-code">
            pageSize = 20,</pre><pre class="source-code">
        ),</pre><pre class="source-code">
        PagingSourceFactory = {</pre><pre class="source-code">
            NewsArticlePagingSource(newsApiService)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    ).flow</pre><pre class="source-code">
}</pre></li>
<li>We will use Hilt<a id="_idIndexMarker505"/> for Dependency Injection in our project and build the required modules that will be supplied. For this section, you can reference the steps in<em class="italic"> </em><a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and Using Hilt</em>, on how to add Hilt to your project and also how to create the required modules. In addition, you can access the entire code through the <em class="italic">Technical requirements</em> section if you get stuck:<pre class="source-code">
@Module</pre><pre class="source-code">
@InstallIn(SingletonComponent::class)</pre><pre class="source-code">
class RetrofitModule{</pre><pre class="source-code">
    @Singleton</pre><pre class="source-code">
    @Provides</pre><pre class="source-code">
    fun provideRetrofitInstance(): NewsApiService =</pre><pre class="source-code">
    Retrofit.Builder()</pre><pre class="source-code">
        .baseUrl(BASE_URL)</pre><pre class="source-code">
        .addConverterFactory(</pre><pre class="source-code">
            GsonConverterFactory.create())</pre><pre class="source-code">
        .build()</pre><pre class="source-code">
        .create(NewsApiService::class.java)</pre><pre class="source-code">
}</pre></li>
<li>Finally, after we have implemented our <code>PagingSource</code>, we can go ahead and create a <code>Pager</code> which typically refers to a <code>ViewPager</code> in our ViewModel and specify our page size. This can range based on the project’s needs or preferences. Furthermore, when using Paging 3.0, we don’t need to individually handle or convert any data to survive the screen configuration changes because this is done for us automatically.</li>
</ol>
<p>We can simply cache our API result using <code>cachedIn(viewModelScope)</code>. In addition, to notify<a id="_idIndexMarker506"/> of any change to the <code>PagingData</code>, you can handle the loading state using a <code>CombinedLoadState</code> callback:</p>
<pre class="source-code">
@HiltViewModel
class NewsViewModel @Inject constructor(
    private val repository: NewsArticleRepository,
) : ViewModel() {
    fun getNewsArticle():
        Flow&lt;PagingData&lt;NewsArticle&gt;&gt; =
            repository.getNewsArticle().cachedIn(
                viewModelScope)
}</pre>
<ol>
<li value="11">Finally, when you run the application, you should see a display like <em class="italic">Figure 8</em><em class="italic">.1</em>, showing the author’s name, image, and content. We also wrap the content since this example is just for learning purposes; you can take it as a challenge to improve the UI and display more details:</li>
</ol>
<div><div><img alt="Figure 8.1 – The news article being loaded using the Paging 3 ﻿library" src="img/Figure_8.1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The news article being loaded using the Paging 3 <a id="_idTextAnchor390"/>library</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor391"/>How it works…</h2>
<p>In Android development, a retrofit request<a id="_idIndexMarker507"/> typically refers to a network request made using the Retrofit library, a popular HTTP client library for Android.</p>
<p>Here are some common types of Retrofit requests and their usage:</p>
<ul>
<li><code>GET</code>: This request is used to retrieve data<a id="_idIndexMarker508"/> from a server. It is the most common type of request used in Android apps and is often used to retrieve data to populate a UI element such as a list or a grid.</li>
<li><code>POST</code>: This request is used to submit<a id="_idIndexMarker509"/> data to a server. It is commonly used to create new resources on the server, such as a new user account or a new post.</li>
<li><code>PUT</code>: This request is used to update<a id="_idIndexMarker510"/> an existing resource on the server. It is commonly used to update a user’s account information or to modify an existing post.</li>
<li><code>DELETE</code>: This request is used to delete<a id="_idIndexMarker511"/> a resource on the server. It is commonly used to delete a user account or to remove a post.</li>
<li><code>PATCH</code>: This request partially<a id="_idIndexMarker512"/> updates an existing resource on the server. It is commonly used when only a small portion of the resource needs to be updated rather than updating the entire resource with a <code>PUT</code> request.</li>
</ul>
<p>When making Retrofit requests, developers typically define an interface that describes the endpoint and the request parameters. Retrofit then generates a client implementation for that interface, which can be used to make the actual network calls.</p>
<p>By using Retrofit, developers can abstract away many of the low-level details of network requests, making it easier and more efficient to communicate with a server from an Android app. For examples<a id="_idIndexMarker513"/> about Retrofit, check out the following link <a href="https://square.github.io/retrofit/">https://square.github.io/retrofit/</a>.</p>
<p>The Paging library<a id="_idIndexMarker514"/> ensures it adheres to the recommended Android architecture patterns. Furthermore, its components are the <code>Repository</code>, <code>ViewModel</code>, and <code>UI</code> layers. The following diagram shows how Paging components operate at each layer and how they work together in unison to load and display your paged data:</p>
<div><div><img alt="Figure 8.2 – The Paging library architecture" src="img/Figure_8.2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The Paging library architecture</p>
<p>The <code>Paging Source</code> component is the main component in the <code>Repository</code> layer, as seen in <em class="italic">Figure 8</em><em class="italic">.2</em>. The object usually declares a source for each piece of data and also handles how to retry data from that source. If you noticed, that is precisely what we did in our example:</p>
<pre class="source-code">
  class NewsArticleRepository @Inject constructor(
      private val newsApiService: NewsApiService
) { . . .</pre>
<p>We create our Retrofit <code>builder() </code>object that contains our base URL of the API, which we defined in the <code>Constant</code> class, <code>const val BASE_URL = "https://newsapi.org/v2/"</code>, and we use the <code>Gson</code> converter to convert our JSON API response. We then declare the <code>apiService</code> variable that we will use to connect the Retrofit <code>builder()</code> object with our interface<a id="_idIndexMarker515"/> and complete our retrofit module.</p>
<p class="callout-heading">Important note</p>
<p class="callout">It is recommended for anyone using the Paging Library to migrate to Paging 3 due to its improvements and because some functionalities are hard to handle <a id="_idTextAnchor392"/>using Paging 2.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor393"/>Managing present and loading states</h1>
<p>The Paging library offers<a id="_idIndexMarker516"/> the loading state information<a id="_idIndexMarker517"/> to users through its load state object, which can have different forms based on its current loading state. For example, if you have an active load, then the state will be <code>LoadState.Loading</code>.</p>
<p>If you have an error state, then the state will be a <code>LoadState.Error</code>; and finally, there might be no active load operation, and this state is called the <code>LoadState.NotLoading.</code> In this recipe, we will explore the different states and get to understand them; the example demonstrated<a id="_idIndexMarker518"/> here can also be found at the following link: <a href="https://developer.android.com/topic/libraries/architecture/paging/load-state">https://developer.android.com/topic/libraries/architecture/paging/load-state</a>. In this example, we assume your project uses legacy code, which utilizes XML fo<a id="_idTextAnchor394"/>r the view system.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor395"/>Getting ready</h2>
<p>To follow along with this recipe, you need to have completed the code in the previous recipe. You can also skip this if it is not require<a id="_idTextAnchor396"/>d in your project.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor397"/>How to do it…</h2>
<p>We will not create a new project in this recipe but rather a step-by-step look at how we can access the loading state with a listener or present the loading state with an adapter. Follow along with these steps to get started:</p>
<ol>
<li>When you want to access<a id="_idIndexMarker519"/> the state, pass this information<a id="_idIndexMarker520"/> to your UI. You can easily use the <code>loadedStateFlow</code> stream of the <code>addLoadStateListener</code> function provided by <code>PagingDataAdapter</code>:<pre class="source-code">
lifecycleScope.launch {</pre><pre class="source-code">
    thePagingAdapter.loadStateFlow.collectLatest {</pre><pre class="source-code">
        loadStates -&gt;</pre><pre class="source-code">
    progressBar.isVisible = loadStates.refresh is</pre><pre class="source-code">
        LoadState.Loading</pre><pre class="source-code">
    retry.isVisible = loadState.refresh !is</pre><pre class="source-code">
        LoadState.Loading</pre><pre class="source-code">
    errorMessage.isVisible = loadState.refresh is</pre><pre class="source-code">
        LoadState.Error</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
<li>For our example, we will not look into the <code>addLoadStateListener</code> function since this is used with an adapter class, and with the new Jetpack Compose, this is barely performed since there is more of a push to use the Jetpack Compose UI-based applications.</li>
<li>Filtering the load state steam might make sense based on your application’s specific event. This ensures that your app UI is updated at the correct time to avoid issues. Hence, using coroutines, we wait until our refresh load state is updated:<pre class="source-code">
lifecycleScope.launchWhenCreated{</pre><pre class="source-code">
    yourAdapter.loadStateFlow</pre><pre class="source-code">
        .distinctUntilChangedBy { it.refresh }</pre><pre class="source-code">
        .filter { it.refresh is LoadState.NotLoading }</pre><pre class="source-code">
        .collect { binding.list.scr<a id="_idTextAnchor398"/>ollToPosition(0) }</pre><pre class="source-code">
}</pre></li>
</ol>
<h2 id="_idParaDest-226"><a id="_idTextAnchor399"/>How it works…</h2>
<p>When getting updates<a id="_idIndexMarker521"/> from <code>loadStateFlow</code> and <code>addLoadStateListener()</code>, these are guaranteed to be<a id="_idIndexMarker522"/> synchronous, and they update the UI as needed. This simply means in the Paging 3 library for Android, <code>LoadState.Error</code> is a state that indicates an error has occurred while loading data from a <code>PagingSource</code>.</p>
<p>In Paging 3 library for Android, <code>LoadState.NotLoading</code> is a state that indicates that the <code>PagingDataAdapter</code> is not currently loading any data and that all available data has been loaded.</p>
<p>When a <code>PagingDataAdapter</code> is first created, it starts in the <code>LoadState.NotLoading</code> state. This means that no data has been loaded yet, and the adapter is waiting for the first load to occur.</p>
<p>After the first load, the adapter may transition to a different load state depending on the current state of the data loading process. However, once all available data has been loaded, the adapter will transition back to the <code>LoadState.NotLoading</code> state.</p>
<p><code>LoadState.NotLoading</code> can be used to inform the UI that the data-loading process is complete and that no further data will be loaded unless the user initiates a refresh or other action.</p>
<p>To handle this state, you can register a listener for changes to the <code>LoadState</code> in the <code>PagingDataAdapter</code> and update the UI accordingly. For example, you could display a message to the user indicating that<a id="_idIndexMarker523"/> all data has been loaded or disable<a id="_idIndexMarker524"/> any “load mo<a id="_idTextAnchor400"/>re” buttons or gestures.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor401"/>There’s more…</h2>
<p>You can learn more about the state and how to better handle Paging by following this link: <a href="https://developer.android.com/topic/libraries/architecture/paging/load-state">https://developer.android.com/topic/libraries/architecture/paging/load-state</a>.</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor402"/>Implementing your custom pagination in Jetpack Compose</h1>
<p>The Paging library<a id="_idIndexMarker525"/> has incredible features for developers, but sometimes<a id="_idIndexMarker526"/> you encounter challenges and are forced to create custom pagination. At the beginning of the chapter, we talked about complex code bases having or creating pagination.</p>
<p>In this recipe, we will look into how we can achieve this with a simple list example and how you can use this example to create custom pagin<a id="_idTextAnchor403"/>ation in your application.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor404"/>Getting ready</h2>
<p>In this recipe, we will need to create a new project and ca<a id="_idTextAnchor405"/>ll it <code>CustomPagingExample</code>.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor406"/>How to do it…</h2>
<p>In our example project, we will try to create a student profile card and use custom pagination to load the profiles in Jetpack Compose.</p>
<ol>
<li>For this recipe, let us go ahead and add the <code>lifecycle-ViewModel</code> dependency since we will need it:<pre class="source-code">
implementation "Androidx.lifecycle:lifecycle-viewmodel-compose:2.x.x"</pre></li>
<li>Let’s go ahead and create a new package and call it <code>data</code>. In our <code>data</code> package, we will add the items we will display on our card. For now, we will just display the student’s<code> name, school, </code><code>and major</code>:<pre class="source-code">
data class StudentProfile(</pre><pre class="source-code">
    val name: String,</pre><pre class="source-code">
    val school: String,</pre><pre class="source-code">
    val major: String</pre><pre class="source-code">
)</pre></li>
<li>Now that we have our <code>data</code> class, we will go ahead<a id="_idIndexMarker527"/> and build our repository, and since, in our example, we are not using<a id="_idIndexMarker528"/> an API, we will use our remote data source, and we can try to load, say, 50 to 100 profiles. Then, inside <code>data</code>, add another class and call it <code>StudentRepository</code>:<pre class="source-code">
class StudentRepository {</pre><pre class="source-code">
    private val ourDataSource = (1..100).map {</pre><pre class="source-code">
        StudentProfile(</pre><pre class="source-code">
            name = "Student $it",</pre><pre class="source-code">
            school = "MIT $it",</pre><pre class="source-code">
            major = "Computer Science $it"</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre><pre class="source-code">
    suspend fun getStudents(page: Int, pageSize: Int):</pre><pre class="source-code">
    Result&lt;List&lt;StudentProfile&gt;&gt; {</pre><pre class="source-code">
        delay(timeMillis = 2000L) //the delay added is</pre><pre class="source-code">
            just to mimic a network connection.</pre><pre class="source-code">
        val start = page * pageSize</pre><pre class="source-code">
        return if (start + pageSize &lt;=</pre><pre class="source-code">
        ourDataSource.size) {</pre><pre class="source-code">
            Result.success(</pre><pre class="source-code">
                ourDataSource.slice(start until start</pre><pre class="source-code">
                    + pageSize)</pre><pre class="source-code">
            )</pre><pre class="source-code">
        } else Result.success(emptyList())</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now that we have created our repository<a id="_idIndexMarker529"/> let us go ahead and create<a id="_idIndexMarker530"/> our custom pagination. We will do this by creating a new interface and calling it <code>StudentPaginator</code>:<pre class="source-code">
interface StudentPaginator&lt;Key, Student&gt; {</pre><pre class="source-code">
    suspend fun loadNextStudent()</pre><pre class="source-code">
    fun reset()</pre><pre class="source-code">
}</pre></li>
<li>Since <code>StudentPaginator</code> is an interface, we must create a class to implement the two functions we just created. Now, let us go ahead and create <code>StudentPaginatorImpl</code> and implement our interface:<pre class="source-code">
class StudentPaginatorImpl&lt;Key, Student&gt;(</pre><pre class="source-code">
) : StudentPaginator&lt;Key, Student&gt; {</pre><pre class="source-code">
    override suspend fun loadNextStudent() {</pre><pre class="source-code">
        TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override fun reset() {</pre><pre class="source-code">
        TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Next, you will need to work<a id="_idIndexMarker531"/> on what you need<a id="_idIndexMarker532"/> to handle in the <code>StudentPaginator</code> implementation class. For instance, in our constructor, we will need to create a key to listen to the <code>load</code>, <code>request</code>, <code>error</code>, <code>success</code>, and <code>next key</code>, and then finally, on the <code>reset()</code> function, be able to reset our pagination. You can view the complete code in the <em class="italic">Technical requirements</em> section. You might also notice it looks similar to the Paging Source in the first recipe of this chapter:<pre class="source-code">
class StudentPaginatorImpl&lt;Key, Student&gt;(</pre><pre class="source-code">
    private val key: Key,</pre><pre class="source-code">
    private inline val loadUpdated: (Boolean) -&gt; Unit,</pre><pre class="source-code">
    private inline val request: suspend (nextKey: Key)</pre><pre class="source-code">
    -&gt;</pre><pre class="source-code">
. . .</pre><pre class="source-code">
) : StudentPaginator&lt;Key, Student&gt; {</pre><pre class="source-code">
    private var currentKey = key</pre><pre class="source-code">
    private var stateRequesting = false</pre><pre class="source-code">
    override suspend fun loadNextStudent() {</pre><pre class="source-code">
        if (stateRequesting) {</pre><pre class="source-code">
            return</pre><pre class="source-code">
        }</pre><pre class="source-code">
        stateRequesting = true</pre><pre class="source-code">
     . . .</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override fun reset() {</pre><pre class="source-code">
        currentKey = key</pre><pre class="source-code">
    }</pre></li>
<li>Let’s go ahead and create<a id="_idIndexMarker533"/> a new package<a id="_idIndexMarker534"/> and call it <code>uistate</code>. Inside<code> uistate</code>, we will create a new data class and call it <code>UIState</code> to help us handle the UI state:<pre class="source-code">
data class UIState(</pre><pre class="source-code">
    val page: Int = 0,</pre><pre class="source-code">
    val loading: Boolean = false,</pre><pre class="source-code">
    val studentProfile: List&lt;StudentProfile&gt; =</pre><pre class="source-code">
        emptyList(),</pre><pre class="source-code">
    val error: String? = null,</pre><pre class="source-code">
    val end: Boolean = false,</pre><pre class="source-code">
)</pre></li>
<li>Now let’s go ahead and finalize our <code>ViewModel</code> <code>init</code> in Kotlin is the block that we use for our initialization. We also create <code>val ourPaginator</code> that we declare to the <code>StudentPaginatorImpl</code> class and handle the inputs with the data<a id="_idIndexMarker535"/> we need for<a id="_idIndexMarker536"/> our UI:<pre class="source-code">
class StudentViewModel() : ViewModel() {</pre><pre class="source-code">
    var state by mutableStateOf(UIState())</pre><pre class="source-code">
    private val studentRepository =</pre><pre class="source-code">
        StudentRepository()</pre><pre class="source-code">
    init {</pre><pre class="source-code">
        loadStudentProfile()</pre><pre class="source-code">
    }</pre><pre class="source-code">
    private val ourPaginator = StudentPaginatorImpl(</pre><pre class="source-code">
        key = state.page,</pre><pre class="source-code">
        loadUpdated = { state = state.copy(loading =</pre><pre class="source-code">
            it) },</pre><pre class="source-code">
        request = { studentRepository.getStudents(it,</pre><pre class="source-code">
            24) },</pre><pre class="source-code">
        nextKey = { state.page + 1 },</pre><pre class="source-code">
        error = { state = state.copy(error =</pre><pre class="source-code">
            it?.localizedMessage) },</pre><pre class="source-code">
        success = { student, newKey -&gt;</pre><pre class="source-code">
            state = state.copy(</pre><pre class="source-code">
                studentProfile = state.studentProfile</pre><pre class="source-code">
                    + student,</pre><pre class="source-code">
                page = newKey,</pre><pre class="source-code">
                end = student.isEmpty()</pre><pre class="source-code">
            )</pre><pre class="source-code">
        }</pre><pre class="source-code">
    )</pre><pre class="source-code">
    fun loadStudentProfile(){</pre><pre class="source-code">
        viewModelScope.launch {</pre><pre class="source-code">
            ourPaginator.loadNextStudent()</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, in our <code>MainActivity</code> class, we now load<a id="_idIndexMarker537"/> the student profile<a id="_idIndexMarker538"/> on our card and display it on the screen, as shown in <em class="italic">Figure 8</em><em class="italic">.3</em>. A tremendous additional exercise to try out is to use Dependency Injection on the sample project to enhance your Android skills. You can utilize <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and Using Hilt</em>, for adding Dependency Injection and also to try writing tests for the <code>ViewModel</code> class:</li>
</ol>
<div><div><img alt="Figure 8.3 – The data loaded on a lazy column" src="img/Figure_8.3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The data loaded on a lazy column</p>
<p>In <em class="italic">Figure 8</em><em class="italic">.4</em> you will see<a id="_idIndexMarker539"/> a progress loading<a id="_idIndexMarker540"/> symbol when you scroll down to <strong class="bold">Student 4</strong> and so on, which can be great when you have huge loads of data<a id="_idTextAnchor407"/>:</p>
<div><div><img alt="Figure 8.4 – Our data being loaded" src="img/Figure_8.4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Our data being loaded</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor408"/>How it works…</h2>
<p>You might experience issues<a id="_idIndexMarker541"/> once you get a list, and it might<a id="_idIndexMarker542"/> be tough to notify single items. However, you can easily make your pagination; in our project, we simulate a remote data source but remember that you can use any API for this example.</p>
<p>Our primary focus is the <code>StudentPaginatorImpl</code> class – you will notice we pass in a key, a <code>loadUpdated</code> value, and a request which is a suspend function that returns a result from our <code>Student</code> type; we also pass the <code>nextkey</code>, which tells us where we are. Then, in case of an error, we have the throwable error and a <code>suspend</code> value, <code>success</code>, which gives us the <code>success</code> result:</p>
<pre class="source-code">
class StudentPaginatorImpl&lt;Key, Student&gt;(
    private val key: Key,
    private inline val loadUpdated: (Boolean) -&gt; Unit,
    private inline val request: suspend (nextKey: Key) -&gt;
        Result&lt;List&lt;Student&gt;&gt;,
    private inline val nextKey: suspend (List&lt;Student&gt;) -&gt;
        Key,
    private inline val error: suspend (Throwable?) -&gt; Unit,
    private inline val success: suspend (items:
        List&lt;Student&gt;, newKey: Key) -&gt; Unit
) : StudentPaginator&lt;Key, Student&gt; {</pre>
<p>So when we override our function from the <code>loadNextStudent()</code> interface, we first check our current state request and return our initial value as <code>false</code>, but we update it after our status check. We also ensure that we reset the key by setting the <code>currentKey</code> to the <code>nextKey</code>.</p>
<pre class="source-code">
currentKey = nextKey(studentProfiles)
success(studentProfiles, currentKey)
loadUpdated(false)</pre>
<p>This makes it easy if you ever need to customize an item in your <code>LazyColumn</code>, ensuring you have great lists.</p>
<p>The <code>loadStudentProfile()</code> function has a <code>viewModelScope.launch {...}</code>. A ViewModel scope is defined for each ViewModel in our application. In addition, any coroutine launched in this scope is auto-canceled if the ViewModel is cleared.</p>
<p>You might be wondering<a id="_idIndexMarker543"/> what a ViewModel is. To help refresh<a id="_idIndexMarker544"/> your knowledge, you can look into <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the U<a id="_idTextAnchor409"/>I State in Jetpack Compose and </em><em class="italic">Using Hilt</em>.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor410"/>Loading and displaying paged data</h1>
<p>There are essential <a id="_idIndexMarker545"/>steps to consider<a id="_idIndexMarker546"/> when loading and displaying paged data. In addition, the Paging library provides tremendous advantages for loading and displaying large, paged datasets. A few steps you must have in mind is ensuring you first define a data source, your Paging Source set up streams if needed, and more.</p>
<p>In this recipe, we will look at <a id="_idTextAnchor411"/>how loading and displaying paged data works.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor412"/>How to do it…</h2>
<p>You need to have completed the <em class="italic">Implementing the Jetpack Paging library</em> recipe to be able to follow along with the explanation of this recipe:</p>
<ol>
<li>You might have noticed<a id="_idIndexMarker547"/> in our first recipe that we override <code>load()</code>, a method<a id="_idIndexMarker548"/> that we use to indicate how we retrieve the paged data from our corresponding data source:<pre class="source-code">
override suspend fun load(params: LoadParams&lt;Int&gt;): LoadResult&lt;Int, NewsArticle&gt; {</pre><pre class="source-code">
    return try {</pre><pre class="source-code">
        val page = params.key ?: 1</pre><pre class="source-code">
        val response = newsApiService.getNews(page =</pre><pre class="source-code">
            page)</pre><pre class="source-code">
        LoadResult.Page(</pre><pre class="source-code">
            data = response.articles,</pre><pre class="source-code">
            prevKey = if (page == 1) null else</pre><pre class="source-code">
                page.minus(1),</pre><pre class="source-code">
            nextKey = if (response.articles.isEmpty())</pre><pre class="source-code">
                null else page.plus(1),</pre><pre class="source-code">
        )</pre><pre class="source-code">
    } catch (e: Exception) {</pre><pre class="source-code">
        LoadResult.Error(e)</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>We start refreshing at page <code>1</code> if <code>val page = params.key ?: 1</code> is undefined when<a id="_idIndexMarker549"/> we override <code>getRefreshKey()</code>; we try to find the page key of the closest page to the anchor<a id="_idIndexMarker550"/> position from either our previous key or the next key. We also need to ensure we handle cases where we might have some <code>null</code> values:<pre class="source-code">
override fun getRefreshKey(state: PagingState&lt;Int, NewsArticle&gt;): Int? {</pre><pre class="source-code">
    return state.anchorPosition?.let { anchorPosition</pre><pre class="source-code">
        -&gt;</pre><pre class="source-code">
        state.closestPageToPosition(anchorPosition)?</pre><pre class="source-code">
            .prevKey?.plus(1)</pre><pre class="source-code">
            ?: state.closestPageToPosition(</pre><pre class="source-code">
          <a id="_idTextAnchor413"/>      anchorPosition)?.nextKey?.minus(1)</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
</ol>
<h2 id="_idParaDest-234"><a id="_idTextAnchor414"/>How it works…</h2>
<p>When using the Paging library, you can specify the position of the first item to be displayed on the screen using the <code>anchorPosition</code> parameter. In addition, <code>anchorPosition</code> is an optional parameter that you can pass to the <code>PagingItems</code> composable function, which is used to display paged data. The <code>anchorPosition</code> parameter is used to specify the position of the first item to be displayed on the screen when the composable is first rendered.</p>
<p>The <code>LoadParams</code> object carries the information about the load operation to be performed. In addition, it knows about the key to be loaded and the number of items to be displayed on the UI. Furthermore, to better understand how the <code>load()</code> function receives the key for each specific load<a id="_idIndexMarker551"/> and updates it, review the following<a id="_idIndexMarker552"/> diagram:</p>
<div><div><img alt="Figure 8.5 – How load() uses and updates the key" src="img/Figure_8.5.jpg"/>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor415"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – How load() uses and updates the key</p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor416"/>Understanding how to transform data streams</h1>
<p>When writing any code dealing<a id="_idIndexMarker553"/> with Paging, you need to understand how you can transform the data stream as you load it to your users. For instance, you may need to filter a list of items or even convert the items to a different type before you can feed the UI with the data.</p>
<p>Hence, ensuring you apply transformation directly to the stream data lets you keep your repository and UI logic separated cleanly. In this recipe, we will tr<a id="_idTextAnchor417"/>y to understand how we can transform data streams.</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor418"/>Getting ready</h2>
<p>To follow along, you must be familiar with the primary usage of the Paging library; hence make sure y<a id="_idTextAnchor419"/>ou have read the previous recipes in this chapter.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor420"/>How to do it…</h2>
<p>In this recipe, we will perform the following steps:</p>
<ol>
<li>Look into how we can apply the essential transformation.</li>
<li>Convert and filter the data.</li>
<li>Handle separators in the UI and convert the UI model.</li>
</ol>
<p>The recipe is helpful to you if you are already using Paging in your application.</p>
<ol>
<li value="4">First, we need to place the transformation<a id="_idIndexMarker554"/> inside a <code>map{PagingData -&gt;}</code>. A map in Kotlin applies the given lambda function to each element and returns a list of the lambda results:<pre class="source-code">
yourPager.flow</pre><pre class="source-code">
    .map { PagingData -&gt;</pre><pre class="source-code">
        // here is where the transformations are</pre><pre class="source-code">
           applied to the items in the paged data.</pre><pre class="source-code">
}</pre></li>
<li>Second, when we want to convert the data or filter, once we have access to our <code>PagingData</code> object, we can use <code>map()</code> again on each item separately in the paged list. A typical use case is when you want to map a database or network layer object onto an object that might be used in the UI layer specifically:<pre class="source-code">
yourPager.flow</pre><pre class="source-code">
    .map { PagingData -&gt;</pre><pre class="source-code">
        PagingData.map { sports -&gt; SportsModel(sports)</pre><pre class="source-code">
        }</pre><pre class="source-code">
}</pre></li>
<li>We will need to place the filter operation inside the map because the filter applies to the <code>PagingData</code> object. Then once the data is filtered out from our <code>PagingData</code>, the new instance is paged to the UI layer and displayed:<pre class="source-code">
yourPager.flow</pre><pre class="source-code">
    .map { PagingData -&gt;</pre><pre class="source-code">
        PagingData.filter { sports -&gt;</pre><pre class="source-code">
            !sports.displayInUi }</pre><pre class="source-code">
}</pre></li>
<li>Finally, when handling separators in the UI or converting the UI model, the most significant steps are ensuring that you do the following:<ol><li>Convert the UI models to accommodate your separator items.</li><li>Transform the data dynamically and add the separators between presenting and loading the data.</li><li><a id="_idTextAnchor421"/>Update the UI to handle the separator items better.</li></ol></li>
</ol>
<h2 id="_idParaDest-238"><a id="_idTextAnchor422"/>How it works…</h2>
<p>The <code>PagingData</code> is encapsulated in a reactive stream; what this means is that before loading the data and displaying it to the users, you can incrementally apply the transform to the data. Transforming data streams<a id="_idIndexMarker555"/> can be crucial when you have a complex application, and handling this situation in advance might help ensure your application scales better a<a id="_idTextAnchor423"/>nd help minimize the complexity of your data growth.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor424"/>See also</h2>
<p>It is fair to acknowledge that this recipe cannot cover all the information you need to know about transforming the data stream. That said, if you encounter an issue and want to learn more, you can always reference the following link to learn more about how you can handle separators in the UI and more: <a href="https://developer.android.com/topic/libraries/architecture/paging/v3-transform">https://developer.android.com/topic/libraries/architecture/paging/v3-transform</a>.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor425"/>Migrating to Paging 3 and understanding the benefits</h1>
<p>You might be using the old Paging<a id="_idIndexMarker556"/> version, in this<a id="_idIndexMarker557"/> case, Paging 2 or 1, and you might be required to migrate to utilize the benefits Paging 3 offers. Paging 3 offers enhanced functionality and ensures it addresses the most common challenges people experience using Paging 2.</p>
<p>In this recipe, we will look into how you<a id="_idTextAnchor426"/> can migrate to the latest recommended Paging library.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor427"/>Getting ready</h2>
<p>If your application is already<a id="_idIndexMarker558"/> using Paging 3, then you can skip this recipe; this step-by-step migration<a id="_idIndexMarker559"/> guide is intended for users c<a id="_idTextAnchor428"/>urrently using the older versions of the Paging library.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor429"/>How to do it…</h2>
<p>Migrating from old versions of the Paging library might seem complex due to the fact that each application is unique, and complexities might vary. In our example, however, we will touch on a low-level kind of migration since our example application does not need any migration.</p>
<p>To perform migration from old Paging libraries, follow these steps:</p>
<ol>
<li>The first step is to replace the refresh keys, and this is because we need to define how refreshing resumes from the middle of loading data. We will do this by first implementing <code>getRefreshKey()</code>, which maps the correct initial key using <code>PagingState.anchorPosition</code> as the recent index:<pre class="source-code">
override fun getRefreshKey(PagingState: PagingState): String? {</pre><pre class="source-code">
    return PagingState.anchorPosition?.let { position</pre><pre class="source-code">
        -&gt;</pre><pre class="source-code">
            PagingState.getClosestItemToPosition(</pre><pre class="source-code">
                position)?.id</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Next, we need to ensure we replace the positional data source:<pre class="source-code">
override fun getRefreshKey(PagingState: PagingState): Int? {</pre><pre class="source-code">
    return PagingState.anchorPosition</pre><pre class="source-code">
}</pre></li>
<li>If you are using the old Paging library, the paged data uses <code>DataSource.map()</code>, <code>mapByPage</code>, <code>Factory.map()</code>, and <code>Factory.mapByPage</code>. In Paging 3, however, all these are applied as operators to <code>PagingData</code>.</li>
<li>Finally, to ensure you migrate<a id="_idIndexMarker560"/> from <code>PageList</code>, which is in Paging 2, you will need<a id="_idIndexMarker561"/> to migrate to <code>PagingData</code>. The most notable change is that <code>PagedList.Config</code> is not <code>PagingConfig</code>. In addition, the <code>Pager()</code> exposes an observable <code>Flow&lt;PagingData&gt;</code> with its flow:<pre class="source-code">
val yourFlow = Pager(</pre><pre class="source-code">
    PagingConfig(pageSize = 24)</pre><pre class="source-code">
) {</pre><pre class="source-code">
    YourPagingSource(yo<a id="_idTextAnchor430"/>urBackend, yourQuery)</pre><pre class="source-code">
}.flow</pre><pre class="source-code">
    .cachedIn(viewModelScope)</pre></li>
</ol>
<h2 id="_idParaDest-243"><a id="_idTextAnchor431"/>How it works…</h2>
<p>To ensure your migration is complete and successful, you must make sure you migrate all the significant components from Paging 2. This includes the <code>DataSource</code> classes, <code>PagedList</code>, and <code>PagedListAdapter</code> if your application uses it. Furthermore, some Paging 3 components work well with other versions, which simply means it is backward compatible.</p>
<p>The most notable change to <code>PagingSource</code> in Paging 3 is that it combines all the loading functions into one, now called <code>load()</code> in <code>PagingSource</code>. This ensures there is no redundancy in the code because the loading logic is often identical to the old API. In addition, the loading function parameters in Paging 3 now use the <code>LoadParams</code> sealed class, which has subclasses for each load type.</p>
<p>In <code>PagedList</code>, which is used in Paging 2, when you migrate, you might use <code>PagingData</code> and <code>Pager</code>. When you start to use <code>PagingData</code> from Paging 3, you should ensure<a id="_idIndexMarker562"/> that the configurati<a id="_idTextAnchor432"/>on<a id="_idIndexMarker563"/> is moved from the old <code>PagedList.Config</code> to <code>PagingConfig</code>.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor433"/>Writing tests for your Paging Source</h1>
<p>Writing tests for your implementations<a id="_idIndexMarker564"/> is crucial. We will write unit tests for our <code>PagingSource</code> implementation<a id="_idIndexMarker565"/> in this recipe to test our logic. Some tests that might be worth writing are checking when news Paging load failure happens.</p>
<p>We can also test the success state and more. You can fo<a id="_idTextAnchor434"/>llow the pattern to write tests for your project or use case.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor435"/>Getting ready</h2>
<p>To follow this recipe step by step, you need to have followed the <em class="italic">Implementing the Jetpack Paging library<a id="_idTextAnchor436"/></em> recipe, and you need to use the <code>PagingJetpackExample</code> project.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor437"/>How to do it…</h2>
<p>Open <code>PagingJetpackExample</code> and follow along with this project to add unit tests:</p>
<ol>
<li>Add the following testing libraries to your <code>build.gradle</code> app:<pre class="source-code">
testImplementation 'org.assertj:assertj-core:3.x.x'</pre><pre class="source-code">
testImplementation "org.mockito:mockito-core:3.x.x"</pre><pre class="source-code">
testImplementation 'Androidx.arch.core:core-testing:2.x.x'</pre><pre class="source-code">
testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.x.x'</pre></li>
<li>After adding the dependencies, create a new package and call it <code>data</code> in your <code>test</code> package in the project structure. You can reference the <em class="italic">Understanding the Android project structure</em> recipe in <a href="B18827_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Modern Android Development Skills</em>, if you need help finding the folder.</li>
<li>Create a test class and call it <code>NewsArticlePagingSourceTest</code>.</li>
<li>Inside the class, let’s go<a id="_idIndexMarker566"/> ahead and add <code>Mock</code> to mock our <code>ApiService</code> interface<a id="_idIndexMarker567"/> and create a <code>lateinit var newsApiService</code> that we will initialize at our <code>@</code><code>Before</code> step:<pre class="source-code">
@Mock</pre><pre class="source-code">
private lateinit var newsApiService: NewsApiService</pre><pre class="source-code">
lateinit var newsPagingSource: NewsArticlePagingSource</pre></li>
<li>Now let’s go ahead and create our <code>@Before </code>so we can run our <code>CoroutineDispatchers</code>, which is used by all standard builders such as async, and launch to our <code>@Before</code> step too:<pre class="source-code">
@Before</pre><pre class="source-code">
fun setup() {</pre><pre class="source-code">
    Dispatchers.setMain(testDispatcher)</pre><pre class="source-code">
    newsPagingSource =</pre><pre class="source-code">
        NewsArticlePagingSource(newsApiService)</pre><pre class="source-code">
}</pre></li>
<li>The first test we will need to write is to check when a failure happens. Hence let’s go ahead and set up our test. A <code>403</code> response is a forbidden status code indicating the server understood your request but did not authorize it:<pre class="source-code">
@Test</pre><pre class="source-code">
fun `news article Paging Source load failure http error`() = runBlockingTest {</pre><pre class="source-code">
    //setup</pre><pre class="source-code">
    val error = HttpException(</pre><pre class="source-code">
        Response.error&lt;ResponseBody&gt;(</pre><pre class="source-code">
            403, "some content".toResponseBody(</pre><pre class="source-code">
                "plain/text".toMediaTypeOrNull())</pre><pre class="source-code">
        )</pre><pre class="source-code">
    ) . . .</pre></li>
<li>To continue<a id="_idIndexMarker568"/> our test, we will need<a id="_idIndexMarker569"/> to use <code>Mockito.doThrow(error)</code>:<pre class="source-code">
Mockito.doThrow(error)</pre><pre class="source-code">
    .`when`(newsApiService)</pre><pre class="source-code">
    .getNews(</pre><pre class="source-code">
        1</pre><pre class="source-code">
    ). . .</pre></li>
<li>Then, finally, we trigger <code>PagingSource.LoadResult.Error</code> and pass in the type, then assert:<pre class="source-code">
//assert</pre><pre class="source-code">
assertEquals(</pre><pre class="source-code">
    expectedResult, newsPagingSource.load(</pre><pre class="source-code">
        PagingSource.LoadParams.Refresh(</pre><pre class="source-code">
            key = null,</pre><pre class="source-code">
            loadSize = 1,</pre><pre class="source-code">
            placeholdersEnabled = false</pre><pre class="source-code">
        )</pre><pre class="source-code">
    )</pre><pre class="source-code">
)</pre></li>
<li>You can add two more additional tests and then add <code>tearDown</code> to clean up the coroutines:<pre class="source-code">
@A<a id="_idTextAnchor438"/>fter</pre><pre class="source-code">
fun tearDown() {</pre><pre class="source-code">
    testDispatcher.cleanupTestCoroutines()</pre><pre class="source-code">
}</pre></li>
</ol>
<h2 id="_idParaDest-247"><a id="_idTextAnchor439"/>How it works…</h2>
<p>We use <code>Mock</code> in unit tests, and the general idea is based on the notion that the objects under tests might have dependencies on other complex objects. Based on this, it is much easier to isolate the behavior of the object we want by mocking the object, which ensures it has the same behavior as our real object and makes testing <a id="_idTextAnchor440"/>easier:</p>
<pre class="source-code">
@Mock
private lateinit var newsApiService: NewsApiService</pre>
<p>Our <code>lateinit var newsPagingSource: NewsArticlePagingSource</code> is used for late<a id="_idIndexMarker570"/> initialization, and we initialize<a id="_idIndexMarker571"/> it on our <code>@</code><code>Before</code> function.</p>
</div>
</body></html>