<html><head></head><body>
<div id="_idContainer087">
<h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor382"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-217"><a id="_idTextAnchor383"/><span class="koboSpan" id="kobo.2.1">Getting Started with Paging</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In Android development, the Paging library helps developers load and display data pages from a larger dataset from local storage or over a network. </span><span class="koboSpan" id="kobo.3.2">This can be a common case if your application loads considerable amounts of data for people to read. </span><span class="koboSpan" id="kobo.3.3">For instance, a good example is Twitter; you might notice the data refreshes due to the many tweets that people </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">send daily.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Hence, in </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Modern Android Development</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">MAD</span></strong><span class="koboSpan" id="kobo.9.1">), Android developers might want to implement the Paging library in their applications to help them with such instances when loading data. </span><span class="koboSpan" id="kobo.9.2">In this chapter, you will learn how to utilize the Paging library in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">your projects.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Implementing the Jetpack </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Paging library</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Managing present and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">loading states</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Implementing your custom pagination in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Jetpack Compose</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Loading and displaying </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">paged data</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Understanding how to transform </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">data streams</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Migrating to Paging 3 and understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the benefits</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Writing tests for your </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Paging Source</span></span></li>
</ul>
<h1 id="_idParaDest-218"><a id="_idTextAnchor384"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">The complete source code for this chapter can be found at </span><a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight</span></a><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">You will also need to get an API key for </span><a href="https://newsapi.org/"><span class="koboSpan" id="kobo.31.1">https://newsapi.org/</span></a><span class="koboSpan" id="kobo.32.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">NewsApi</span></strong><span class="koboSpan" id="kobo.34.1"> is a worldwide API </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">for news.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor385"/><span class="koboSpan" id="kobo.36.1">Implementing the Jetpack Paging library</span></h1>
<p><span class="koboSpan" id="kobo.37.1">The Paging library</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.38.1"> comes with incredible features for developers. </span><span class="koboSpan" id="kobo.38.2">If your codebase is established and extensive, there are other custom ways that developers have created to help them load data efficiently. </span><span class="koboSpan" id="kobo.38.3">One notable advantage of Paging is its in-memory caching for your page’s data, which ensures your application uses the system resources efficiently while working with the already </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">paged data.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">In addition, it offers support for Kotlin coroutine flows and LiveData and has built-in deduplication, which ensures your application uses network bandwidth and resources efficiently, which can help save battery. </span><span class="koboSpan" id="kobo.40.2">Finally, the Paging library offers support for error handling, including when refreshing and retrying </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">your data.</span></span><a id="_idTextAnchor386"/></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor387"/><span class="koboSpan" id="kobo.42.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.43.1">In this recipe, we will need to create a new project; if you need to reference a previous recipe for creating a new project, you can visit </span><a href="B18827_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.45.1">, </span><em class="italic"><span class="koboSpan" id="kobo.46.1">Getting Started with Modern Android </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.47.1">Development Skills</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">.</span></span><a id="_idTextAnchor388"/></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor389"/><span class="koboSpan" id="kobo.49.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.50.1">Let’s go ahead and create a new empty Compose project and call it</span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1"> PagingJetpackExample</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">In our example project, we will use the free </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">NewsApi</span></strong><span class="koboSpan" id="kobo.54.1"> to display the news to our users. </span><span class="koboSpan" id="kobo.54.2">To get started, check</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.55.1"> out this link at </span><a href="https://newsapi.org/docs/get-started"><span class="koboSpan" id="kobo.56.1">https://newsapi.org/docs/get-started</span></a><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">Also, ensure you get your API for the project, as it is a requirement for this recipe. </span><span class="koboSpan" id="kobo.57.3">Follow these steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">get started:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.59.1">Let’s go ahead and add the following required dependencies. </span><span class="koboSpan" id="kobo.59.2">In addition, since we will be doing a network call, we need to add a library to handle this. </span><span class="koboSpan" id="kobo.59.3">As for the correct versioning, check out the </span><em class="italic"><span class="koboSpan" id="kobo.60.1">Technical requirements</span></em><span class="koboSpan" id="kobo.61.1"> section for the code and the correct version. </span><span class="koboSpan" id="kobo.61.2">We will provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">2.x.x</span></strong><span class="koboSpan" id="kobo.63.1"> so you can check compatibility if you are upgrading or already have </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">Retrofit</span></strong><span class="koboSpan" id="kobo.65.1"> in your project and Coil which is a fast, lightweight, and flexible image loading library. </span><span class="koboSpan" id="kobo.65.2">It is designed to simplify the process of loading images from various sources (such as network, local storage, or content providers) and displaying them in ImageView or other image-related </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">UI components:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.67.1">
//Retrofit</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.68.1">
implementation 'com.squareup.retrofit2:retrofit:2.x.x'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.69.1">
implementation 'com.squareup.retrofit2:converter-gson:2.x.x'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.70.1">
//Coil you can also use Glide in this case</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.71.1">
implementation 'com.google.accompanist:accompanist-coil:0.x.x'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.72.1">
//Paging 3.0</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.73.1">
implementation 'Androidx.Paging:Paging-compose:1.x.x'</span></pre></li>
<li><span class="koboSpan" id="kobo.74.1">After the project </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.75.1">syncs and is ready, go ahead and remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">Greeting</span></strong><span class="koboSpan" id="kobo.77.1"> composable function that comes with the project. </span><span class="koboSpan" id="kobo.77.2">You should have just your theme, and your surface</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.78.1"> should be empty. </span><span class="koboSpan" id="kobo.78.2">In addition, for the </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">user interface</span></strong><span class="koboSpan" id="kobo.80.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.81.1">UI</span></strong><span class="koboSpan" id="kobo.82.1">) portion of this recipe, you can get the entire code from the </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Technical </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.84.1">requirements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.86.1">Also, when using an API, developers tend to forget to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Android.permission.INTERNET </span></strong><span class="koboSpan" id="kobo.88.1">permission on the manifest, so let’s do that now before we </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">forget it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.90.1">
&lt;uses-permission Android:name="Android.permission.INTERNET"/&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.91.1">Now, create a package and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">data</span></strong><span class="koboSpan" id="kobo.93.1">; we will add our model and service files to this package. </span><span class="koboSpan" id="kobo.93.2">In addition, ensure you go through the News API </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Documentation</span></strong><span class="koboSpan" id="kobo.95.1"> section to understand how the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">API works:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.97.1">
data class NewsArticle(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.98.1">
    val author: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.99.1">
    val content: String,val title: String ...)</span></pre></li>
<li><span class="koboSpan" id="kobo.100.1">Let us now create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">NewsArticleResponse</span></strong><span class="koboSpan" id="kobo.102.1"> data class, which we will implement in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">NewsApiService</span></strong><span class="koboSpan" id="kobo.104.1"> interface. </span><span class="koboSpan" id="kobo.104.2">Our API call type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">@GET()</span></strong><span class="koboSpan" id="kobo.106.1">, which means exactly “to get.” </span><span class="koboSpan" id="kobo.106.2">A more detailed explanation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">GET</span></strong><span class="koboSpan" id="kobo.108.1"> is provided in the </span><em class="italic"><span class="koboSpan" id="kobo.109.1">How it works</span></em><span class="koboSpan" id="kobo.110.1"> section. </span><span class="koboSpan" id="kobo.110.2">Our call seeks to return a call object containing the data in the form of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">NewsArticleResponse</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.112.1">data class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.113.1">
data class NewsArticleResponse(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.114.1">
    val articles: List&lt;NewsArticle&gt;,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
    val status: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.116.1">
    val totalResults: Int</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.117.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.118.1">
interface NewsApiService{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.119.1">
    @GET("everything?q=apple&amp;sortBy=popularity&amp;apiKey=        ${YOURAPIKEY}&amp;pageSize=20")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.120.1">
    suspend fun getNews(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.121.1">
        @Query("page") page: Int</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.122.1">
    ): NewsArticleResponse</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.123.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.124.1">Create another</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.125.1"> class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">NewsArticlePagingSource()</span></strong><span class="koboSpan" id="kobo.127.1">; our class will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">NewsApiService</span></strong><span class="koboSpan" id="kobo.129.1"> as the input parameter. </span><span class="koboSpan" id="kobo.129.2">When exposing any large datasets through APIs, we need to provide a mechanism to paginate the list of resources. </span><span class="koboSpan" id="kobo.129.3">To implement it, we need to pass the type of the Paging key and the type of data to load, which in our case </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">NewsArticle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.133.1">
class NewsArticlePagingSource(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.134.1">
    private val newsApiService: NewsApiService,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.135.1">
): PagingSource&lt;Int, NewsArticle&gt;() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.136.1">
. </span><span class="koboSpan" id="kobo.136.2">. </span><span class="koboSpan" id="kobo.136.3">.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.137.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.138.1">Finally, let us go ahead and override </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">getRefreshKey()</span></strong><span class="koboSpan" id="kobo.140.1"> provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">PagingSource</span></strong><span class="koboSpan" id="kobo.142.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">load()</span></strong><span class="koboSpan" id="kobo.144.1"> suspend functions. </span><span class="koboSpan" id="kobo.144.2">We will discuss the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">load()</span></strong><span class="koboSpan" id="kobo.146.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">PagingSource</span></strong><span class="koboSpan" id="kobo.148.1"> suspend functions</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.149.1"> in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.150.1">Loading and displaying paged </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.151.1">data</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.152.1"> recipe:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.153.1">
class NewsArticlePagingSource(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
    private val newsApiService: NewsApiService,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.155.1">
) : PagingSource&lt;Int, NewsArticle&gt;() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
    override fun getRefreshKey(state: PagingState&lt;Int,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.157.1">
    NewsArticle&gt;): Int? </span><span class="koboSpan" id="kobo.157.2">{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.158.1">
        return state.anchorPosition?.let {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.159.1">
        anchorPosition -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.160.1">
            state.closestPageToPosition(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.161.1">
                anchorPosition)?.prevKey?.plus(1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.162.1">
                ?: state.closestPageToPosition(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.163.1">
                    anchorPosition)?.nextKey?.minus(1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.164.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.165.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.166.1">
    override suspend fun load(params:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.167.1">
    LoadParams&lt;Int&gt;): LoadResult&lt;Int, NewsArticle&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.168.1">
        return try {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.169.1">
            val page = params.key ?: 1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.170.1">
            val response = newsApiService.getNews(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.171.1">
                page = page)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.172.1">
            LoadResult.Page(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.173.1">
                data = response.articles,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.174.1">
                prevKey = if (page == 1) null else</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.175.1">
                    page.minus(1),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.176.1">
                nextKey = if</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.177.1">
                    (response.articles.isEmpty()) null</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.178.1">
                        else page.plus(1),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.179.1">
            )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.180.1">
        } catch (e: Exception) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.181.1">
            LoadResult.Error(e)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.182.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.183.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.184.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.185.1">Now, let’s create our repository; a repository</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.186.1"> is a class that isolates the data sources, such as a web service or a Room database, from the rest of the app. </span><span class="koboSpan" id="kobo.186.2">Since we do not have a Room database, we will work with the web </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">service data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.188.1">
class NewsArticleRepository @Inject constructor(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.189.1">
    private val newsApiService: NewsApiService</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.190.1">
) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.191.1">
    fun getNewsArticle() = Pager(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.192.1">
        config = PagingConfig(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.193.1">
            pageSize = 20,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.194.1">
        ),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.195.1">
        PagingSourceFactory = {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.196.1">
            NewsArticlePagingSource(newsApiService)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.197.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.198.1">
    ).flow</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.199.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.200.1">We will use Hilt</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.201.1"> for Dependency Injection in our project and build the required modules that will be supplied. </span><span class="koboSpan" id="kobo.201.2">For this section, you can reference the steps in</span><em class="italic"> </em><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.203.1">, </span><em class="italic"><span class="koboSpan" id="kobo.204.1">Handling the UI State in Jetpack Compose and Using Hilt</span></em><span class="koboSpan" id="kobo.205.1">, on how to add Hilt to your project and also how to create the required modules. </span><span class="koboSpan" id="kobo.205.2">In addition, you can access the entire code through the </span><em class="italic"><span class="koboSpan" id="kobo.206.1">Technical requirements</span></em><span class="koboSpan" id="kobo.207.1"> section if you </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">get stuck:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.209.1">
@Module</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.210.1">
@InstallIn(SingletonComponent::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.211.1">
class RetrofitModule{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.212.1">
    @Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
    @Provides</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.214.1">
    fun provideRetrofitInstance(): NewsApiService =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.215.1">
    Retrofit.Builder()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.216.1">
        .baseUrl(BASE_URL)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.217.1">
        .addConverterFactory(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.218.1">
            GsonConverterFactory.create())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.219.1">
        .build()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.220.1">
        .create(NewsApiService::class.java)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.222.1">Finally, after we have implemented our </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">PagingSource</span></strong><span class="koboSpan" id="kobo.224.1">, we can go ahead and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">Pager</span></strong><span class="koboSpan" id="kobo.226.1"> which typically refers to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">ViewPager</span></strong><span class="koboSpan" id="kobo.228.1"> in our ViewModel and specify our page size. </span><span class="koboSpan" id="kobo.228.2">This can range based on the project’s needs or preferences. </span><span class="koboSpan" id="kobo.228.3">Furthermore, when using Paging 3.0, we don’t need to individually handle or convert any data to survive the screen configuration changes because this is done for </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">us automatically.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.230.1">We can simply cache our API result using </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">cachedIn(viewModelScope)</span></strong><span class="koboSpan" id="kobo.232.1">. </span><span class="koboSpan" id="kobo.232.2">In addition, to notify</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.233.1"> of any change to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">PagingData</span></strong><span class="koboSpan" id="kobo.235.1">, you can handle the loading state using a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">CombinedLoadState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1"> callback:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
@HiltViewModel
class NewsViewModel @Inject constructor(
    private val repository: NewsArticleRepository,
) : ViewModel() {
    fun getNewsArticle():
        Flow&lt;PagingData&lt;NewsArticle&gt;&gt; =
            repository.getNewsArticle().cachedIn(
                viewModelScope)
}</span></pre>
<ol>
<li value="11"><span class="koboSpan" id="kobo.239.1">Finally, when you run the application, you should see a display like </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.240.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.241.1">.1</span></em><span class="koboSpan" id="kobo.242.1">, showing the author’s name, image, and content. </span><span class="koboSpan" id="kobo.242.2">We also wrap the content since this example is just for learning purposes; you can take it as a challenge to improve the UI and display </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">more details:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.244.1"><img alt="Figure 8.1 – The news article being loaded using the Paging 3 ﻿library" src="image/Figure_8.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.245.1">Figure 8.1 – The news article being loaded using the Paging 3 </span><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.246.1">library</span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor391"/><span class="koboSpan" id="kobo.247.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.248.1">In Android development, a retrofit request</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.249.1"> typically refers to a network request made using the Retrofit library, a popular HTTP client library </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">for Android.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">Here are some common types of Retrofit requests and </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">their usage:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">GET</span></strong><span class="koboSpan" id="kobo.254.1">: This request is used to retrieve data</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.255.1"> from a server. </span><span class="koboSpan" id="kobo.255.2">It is the most common type of request used in Android apps and is often used to retrieve data to populate a UI element such as a list or </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">a grid.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">POST</span></strong><span class="koboSpan" id="kobo.258.1">: This request is used to submit</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.259.1"> data to a server. </span><span class="koboSpan" id="kobo.259.2">It is commonly used to create new resources on the server, such as a new user account or a </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">new post.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">PUT</span></strong><span class="koboSpan" id="kobo.262.1">: This request is used to update</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.263.1"> an existing resource on the server. </span><span class="koboSpan" id="kobo.263.2">It is commonly used to update a user’s account information or to modify an </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">existing post.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">DELETE</span></strong><span class="koboSpan" id="kobo.266.1">: This request is used to delete</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.267.1"> a resource on the server. </span><span class="koboSpan" id="kobo.267.2">It is commonly used to delete a user account or to remove </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">a post.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">PATCH</span></strong><span class="koboSpan" id="kobo.270.1">: This request partially</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.271.1"> updates an existing resource on the server. </span><span class="koboSpan" id="kobo.271.2">It is commonly used when only a small portion of the resource needs to be updated rather than updating the entire resource with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">PUT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1"> request.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.274.1">When making Retrofit requests, developers typically define an interface that describes the endpoint and the request parameters. </span><span class="koboSpan" id="kobo.274.2">Retrofit then generates a client implementation for that interface, which can be used to make the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">network calls.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">By using Retrofit, developers can abstract away many of the low-level details of network requests, making it easier and more efficient to communicate with a server from an Android app. </span><span class="koboSpan" id="kobo.276.2">For examples</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.277.1"> about Retrofit, check out the following </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">link </span></span><a href="https://square.github.io/retrofit/"><span class="No-Break"><span class="koboSpan" id="kobo.279.1">https://square.github.io/retrofit/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.280.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">The Paging library</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.282.1"> ensures it adheres to the recommended Android architecture patterns. </span><span class="koboSpan" id="kobo.282.2">Furthermore, its components are the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">Repository</span></strong><span class="koboSpan" id="kobo.284.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">ViewModel</span></strong><span class="koboSpan" id="kobo.286.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">UI</span></strong><span class="koboSpan" id="kobo.288.1"> layers. </span><span class="koboSpan" id="kobo.288.2">The following diagram shows how Paging components operate at each layer and how they work together in unison to load and display your </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">paged data:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.290.1"><img alt="Figure 8.2 – The Paging library architecture" src="image/Figure_8.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.291.1">Figure 8.2 – The Paging library architecture</span></p>
<p><span class="koboSpan" id="kobo.292.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Paging Source</span></strong><span class="koboSpan" id="kobo.294.1"> component is the main component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Repository</span></strong><span class="koboSpan" id="kobo.296.1"> layer, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.297.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.298.1">.2</span></em><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">The object usually declares a source for each piece of data and also handles how to retry data from that source. </span><span class="koboSpan" id="kobo.299.3">If you noticed, that is precisely what we did in </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">our example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
  class NewsArticleRepository @Inject constructor(
      private val newsApiService: NewsApiService
) { . </span><span class="koboSpan" id="kobo.301.2">. </span><span class="koboSpan" id="kobo.301.3">.</span></pre>
<p><span class="koboSpan" id="kobo.302.1">We create our Retrofit </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">builder() </span></strong><span class="koboSpan" id="kobo.304.1">object that contains our base URL of the API, which we defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Constant</span></strong><span class="koboSpan" id="kobo.306.1"> class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">const val BASE_URL = "https://newsapi.org/v2/"</span></strong><span class="koboSpan" id="kobo.308.1">, and we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Gson</span></strong><span class="koboSpan" id="kobo.310.1"> converter to convert our JSON API response. </span><span class="koboSpan" id="kobo.310.2">We then declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">apiService</span></strong><span class="koboSpan" id="kobo.312.1"> variable that we will use to connect the Retrofit </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">builder()</span></strong><span class="koboSpan" id="kobo.314.1"> object with our interface</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.315.1"> and complete our </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">retrofit module.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.317.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.318.1">It is recommended for anyone using the Paging Library to migrate to Paging 3 due to its improvements and because some functionalities are hard to handle </span><a id="_idTextAnchor392"/><span class="koboSpan" id="kobo.319.1">using </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">Paging 2.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor393"/><span class="koboSpan" id="kobo.321.1">Managing present and loading states</span></h1>
<p><span class="koboSpan" id="kobo.322.1">The Paging library offers</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.323.1"> the loading state information</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.324.1"> to users through its load state object, which can have different forms based on its current loading state. </span><span class="koboSpan" id="kobo.324.2">For example, if you have an active load, then the state will </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">LoadState.Loading</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">If you have an error state, then the state will be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">LoadState.Error</span></strong><span class="koboSpan" id="kobo.330.1">; and finally, there might be no active load operation, and this state is called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">LoadState.NotLoading.</span></strong><span class="koboSpan" id="kobo.332.1"> In this recipe, we will explore the different states and get to understand them; the example demonstrated</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.333.1"> here can also be found at the following link: </span><a href="https://developer.android.com/topic/libraries/architecture/paging/load-state"><span class="koboSpan" id="kobo.334.1">https://developer.android.com/topic/libraries/architecture/paging/load-state</span></a><span class="koboSpan" id="kobo.335.1">. </span><span class="koboSpan" id="kobo.335.2">In this example, we assume your project uses legacy code, which utilizes XML fo</span><a id="_idTextAnchor394"/><span class="koboSpan" id="kobo.336.1">r the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">view system.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor395"/><span class="koboSpan" id="kobo.338.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.339.1">To follow along with this recipe, you need to have completed the code in the previous recipe. </span><span class="koboSpan" id="kobo.339.2">You can also skip this if it is not require</span><a id="_idTextAnchor396"/><span class="koboSpan" id="kobo.340.1">d in </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">your project.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor397"/><span class="koboSpan" id="kobo.342.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.343.1">We will not create a new project in this recipe but rather a step-by-step look at how we can access the loading state with a listener or present the loading state with an adapter. </span><span class="koboSpan" id="kobo.343.2">Follow along with these steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">get started:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.345.1">When you want to access</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.346.1"> the state, pass this information</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.347.1"> to your UI. </span><span class="koboSpan" id="kobo.347.2">You can easily use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">loadedStateFlow</span></strong><span class="koboSpan" id="kobo.349.1"> stream of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">addLoadStateListener</span></strong><span class="koboSpan" id="kobo.351.1"> function provided </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">PagingDataAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.355.1">
lifecycleScope.launch {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
    thePagingAdapter.loadStateFlow.collectLatest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.357.1">
        loadStates -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.358.1">
    progressBar.isVisible = loadStates.refresh is</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.359.1">
        LoadState.Loading</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
    retry.isVisible = loadState.refresh !is</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.361.1">
        LoadState.Loading</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.362.1">
    errorMessage.isVisible = loadState.refresh is</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
        LoadState.Error</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.364.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.365.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.366.1">For our example, we will not look into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">addLoadStateListener</span></strong><span class="koboSpan" id="kobo.368.1"> function since this is used with an adapter class, and with the new Jetpack Compose, this is barely performed since there is more of a push to use the Jetpack Compose </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">UI-based applications.</span></span></li>
<li><span class="koboSpan" id="kobo.370.1">Filtering the load state steam might make sense based on your application’s specific event. </span><span class="koboSpan" id="kobo.370.2">This ensures that your app UI is updated at the correct time to avoid issues. </span><span class="koboSpan" id="kobo.370.3">Hence, using coroutines, we wait until our refresh load state </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">is updated:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
lifecycleScope.launchWhenCreated{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
    yourAdapter.loadStateFlow</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.374.1">
        .distinctUntilChangedBy { it.refresh }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
        .filter { it.refresh is LoadState.NotLoading }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.376.1">
        .collect { binding.list.scr</span><a id="_idTextAnchor398"/><span class="koboSpan" id="kobo.377.1">ollToPosition(0) }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.378.1">
}</span></pre></li>
</ol>
<h2 id="_idParaDest-226"><a id="_idTextAnchor399"/><span class="koboSpan" id="kobo.379.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.380.1">When getting updates</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.381.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">loadStateFlow</span></strong><span class="koboSpan" id="kobo.383.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">addLoadStateListener()</span></strong><span class="koboSpan" id="kobo.385.1">, these are guaranteed to be</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.386.1"> synchronous, and they update the UI as needed. </span><span class="koboSpan" id="kobo.386.2">This simply means in the Paging 3 library for Android, </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">LoadState.Error</span></strong><span class="koboSpan" id="kobo.388.1"> is a state that indicates an error has occurred while loading data from </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">PagingSource</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">In Paging 3 library for Android, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">LoadState.NotLoading</span></strong><span class="koboSpan" id="kobo.394.1"> is a state that indicates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">PagingDataAdapter</span></strong><span class="koboSpan" id="kobo.396.1"> is not currently loading any data and that all available data has </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">been loaded.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">When a </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">PagingDataAdapter</span></strong><span class="koboSpan" id="kobo.400.1"> is first created, it starts in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">LoadState.NotLoading</span></strong><span class="koboSpan" id="kobo.402.1"> state. </span><span class="koboSpan" id="kobo.402.2">This means that no data has been loaded yet, and the adapter is waiting for the first load </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">to occur.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">After the first load, the adapter may transition to a different load state depending on the current state of the data loading process. </span><span class="koboSpan" id="kobo.404.2">However, once all available data has been loaded, the adapter will transition back to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">LoadState.NotLoading</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1"> state.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">LoadState.NotLoading</span></strong><span class="koboSpan" id="kobo.408.1"> can be used to inform the UI that the data-loading process is complete and that no further data will be loaded unless the user initiates a refresh or </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">other action.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">To handle this state, you can register a listener for changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">LoadState</span></strong><span class="koboSpan" id="kobo.412.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">PagingDataAdapter</span></strong><span class="koboSpan" id="kobo.414.1"> and update the UI accordingly. </span><span class="koboSpan" id="kobo.414.2">For example, you could display a message to the user indicating that</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.415.1"> all data has been loaded or disable</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.416.1"> any “load mo</span><a id="_idTextAnchor400"/><span class="koboSpan" id="kobo.417.1">re” buttons </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">or gestures.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor401"/><span class="koboSpan" id="kobo.419.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.420.1">You can learn more about the state and how to better handle Paging by following this </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">link: </span></span><a href="https://developer.android.com/topic/libraries/architecture/paging/load-state"><span class="No-Break"><span class="koboSpan" id="kobo.422.1">https://developer.android.com/topic/libraries/architecture/paging/load-state</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.423.1">.</span></span></p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor402"/><span class="koboSpan" id="kobo.424.1">Implementing your custom pagination in Jetpack Compose</span></h1>
<p><span class="koboSpan" id="kobo.425.1">The Paging library</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.426.1"> has incredible features for developers, but sometimes</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.427.1"> you encounter challenges and are forced to create custom pagination. </span><span class="koboSpan" id="kobo.427.2">At the beginning of the chapter, we talked about complex code bases having or </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">creating pagination.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">In this recipe, we will look into how we can achieve this with a simple list example and how you can use this example to create custom pagin</span><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.430.1">ation in </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">your application.</span></span></p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.432.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.433.1">In this recipe, we will need to create a new project and ca</span><a id="_idTextAnchor405"/><span class="koboSpan" id="kobo.434.1">ll </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">CustomPagingExample</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">.</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor406"/><span class="koboSpan" id="kobo.438.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.439.1">In our example project, we will try to create a student profile card and use custom pagination to load the profiles in </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">Jetpack Compose.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.441.1">For this recipe, let us go ahead and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">lifecycle-ViewModel</span></strong><span class="koboSpan" id="kobo.443.1"> dependency since we will </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">need it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.445.1">
implementation "Androidx.lifecycle:lifecycle-viewmodel-compose:2.x.x"</span></pre></li>
<li><span class="koboSpan" id="kobo.446.1">Let’s go ahead and create a new package and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">data</span></strong><span class="koboSpan" id="kobo.448.1">. </span><span class="koboSpan" id="kobo.448.2">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">data</span></strong><span class="koboSpan" id="kobo.450.1"> package, we will add the items we will display on our card. </span><span class="koboSpan" id="kobo.450.2">For now, we will just display the student’s</span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1"> name, school, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">and major</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.454.1">
data class StudentProfile(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.455.1">
    val name: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
    val school: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
    val major: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.459.1">Now that we have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">data</span></strong><span class="koboSpan" id="kobo.461.1"> class, we will go ahead</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.462.1"> and build our repository, and since, in our example, we are not using</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.463.1"> an API, we will use our remote data source, and we can try to load, say, 50 to 100 profiles. </span><span class="koboSpan" id="kobo.463.2">Then, inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">data</span></strong><span class="koboSpan" id="kobo.465.1">, add another class and call </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">StudentRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.469.1">
class StudentRepository {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
    private val ourDataSource = (1..100).map {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
        StudentProfile(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
            name = "Student $it",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
            school = "MIT $it",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
            major = "Computer Science $it"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.475.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.477.1">
    suspend fun getStudents(page: Int, pageSize: Int):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.478.1">
    Result&lt;List&lt;StudentProfile&gt;&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.479.1">
        delay(timeMillis = 2000L) //the delay added is</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.480.1">
            just to mimic a network connection.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.481.1">
        val start = page * pageSize</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.482.1">
        return if (start + pageSize &lt;=</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.483.1">
        ourDataSource.size) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
            Result.success(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.485.1">
                ourDataSource.slice(start until start</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.486.1">
                    + pageSize)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.487.1">
            )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.488.1">
        } else Result.success(emptyList())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.489.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.490.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.491.1">Now that we have created our repository</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.492.1"> let us go ahead and create</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.493.1"> our custom pagination. </span><span class="koboSpan" id="kobo.493.2">We will do this by creating a new interface and calling </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">StudentPaginator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.497.1">
interface StudentPaginator&lt;Key, Student&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.498.1">
    suspend fun loadNextStudent()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.499.1">
    fun reset()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.500.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.501.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">StudentPaginator</span></strong><span class="koboSpan" id="kobo.503.1"> is an interface, we must create a class to implement the two functions we just created. </span><span class="koboSpan" id="kobo.503.2">Now, let us go ahead and create </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">StudentPaginatorImpl</span></strong><span class="koboSpan" id="kobo.505.1"> and implement </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">our interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.507.1">
class StudentPaginatorImpl&lt;Key, Student&gt;(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.508.1">
) : StudentPaginator&lt;Key, Student&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.509.1">
    override suspend fun loadNextStudent() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.510.1">
        TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.511.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.512.1">
    override fun reset() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.513.1">
        TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.514.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.515.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.516.1">Next, you will need to work</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.517.1"> on what you need</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.518.1"> to handle in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">StudentPaginator</span></strong><span class="koboSpan" id="kobo.520.1"> implementation class. </span><span class="koboSpan" id="kobo.520.2">For instance, in our constructor, we will need to create a key to listen to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">load</span></strong><span class="koboSpan" id="kobo.522.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">request</span></strong><span class="koboSpan" id="kobo.524.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">error</span></strong><span class="koboSpan" id="kobo.526.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">success</span></strong><span class="koboSpan" id="kobo.528.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">next key</span></strong><span class="koboSpan" id="kobo.530.1">, and then finally, on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">reset()</span></strong><span class="koboSpan" id="kobo.532.1"> function, be able to reset our pagination. </span><span class="koboSpan" id="kobo.532.2">You can view the complete code in the </span><em class="italic"><span class="koboSpan" id="kobo.533.1">Technical requirements</span></em><span class="koboSpan" id="kobo.534.1"> section. </span><span class="koboSpan" id="kobo.534.2">You might also notice it looks similar to the Paging Source in the first recipe of </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">this chapter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.536.1">
class StudentPaginatorImpl&lt;Key, Student&gt;(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.537.1">
    private val key: Key,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.538.1">
    private inline val loadUpdated: (Boolean) -&gt; Unit,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.539.1">
    private inline val request: suspend (nextKey: Key)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.540.1">
    -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.541.1">
. </span><span class="koboSpan" id="kobo.541.2">. </span><span class="koboSpan" id="kobo.541.3">.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.542.1">
) : StudentPaginator&lt;Key, Student&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.543.1">
    private var currentKey = key</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.544.1">
    private var stateRequesting = false</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.545.1">
    override suspend fun loadNextStudent() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.546.1">
        if (stateRequesting) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
            return</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.549.1">
        stateRequesting = true</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.550.1">
     . </span><span class="koboSpan" id="kobo.550.2">. </span><span class="koboSpan" id="kobo.550.3">.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.551.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.552.1">
    override fun reset() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.553.1">
        currentKey = key</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.554.1">
    }</span></pre></li>
<li><span class="koboSpan" id="kobo.555.1">Let’s go ahead and create</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.556.1"> a new package</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.557.1"> and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">uistate</span></strong><span class="koboSpan" id="kobo.559.1">. </span><span class="koboSpan" id="kobo.559.2">Inside</span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1"> uistate</span></strong><span class="koboSpan" id="kobo.561.1">, we will create a new data class and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">UIState</span></strong><span class="koboSpan" id="kobo.563.1"> to help us handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">UI state:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.565.1">
data class UIState(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.566.1">
    val page: Int = 0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.567.1">
    val loading: Boolean = false,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.568.1">
    val studentProfile: List&lt;StudentProfile&gt; =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
        emptyList(),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.570.1">
    val error: String? </span><span class="koboSpan" id="kobo.570.2">= null,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.571.1">
    val end: Boolean = false,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.572.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.573.1">Now let’s go ahead and finalize our </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">ViewModel</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.575.1">init</span></strong><span class="koboSpan" id="kobo.576.1"> in Kotlin is the block that we use for our initialization. </span><span class="koboSpan" id="kobo.576.2">We also create </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">val ourPaginator</span></strong><span class="koboSpan" id="kobo.578.1"> that we declare to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">StudentPaginatorImpl</span></strong><span class="koboSpan" id="kobo.580.1"> class and handle the inputs with the data</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.581.1"> we need for</span><a id="_idIndexMarker536"/> <span class="No-Break"><span class="koboSpan" id="kobo.582.1">our UI:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.583.1">
class StudentViewModel() : ViewModel() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.584.1">
    var state by mutableStateOf(UIState())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.585.1">
    private val studentRepository =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.586.1">
        StudentRepository()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.587.1">
    init {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.588.1">
        loadStudentProfile()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.589.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.590.1">
    private val ourPaginator = StudentPaginatorImpl(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.591.1">
        key = state.page,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.592.1">
        loadUpdated = { state = state.copy(loading =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.593.1">
            it) },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.594.1">
        request = { studentRepository.getStudents(it,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.595.1">
            24) },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
        nextKey = { state.page + 1 },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
        error = { state = state.copy(error =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.598.1">
            it?.localizedMessage) },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
        success = { student, newKey -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
            state = state.copy(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
                studentProfile = state.studentProfile</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.602.1">
                    + student,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.603.1">
                page = newKey,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.604.1">
                end = student.isEmpty()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.605.1">
            )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.606.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.607.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.608.1">
    fun loadStudentProfile(){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.609.1">
        viewModelScope.launch {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.610.1">
            ourPaginator.loadNextStudent()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.611.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.612.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.613.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.614.1">Finally, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">MainActivity</span></strong><span class="koboSpan" id="kobo.616.1"> class, we now load</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.617.1"> the student profile</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.618.1"> on our card and display it on the screen, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.619.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.620.1">.3</span></em><span class="koboSpan" id="kobo.621.1">. </span><span class="koboSpan" id="kobo.621.2">A tremendous additional exercise to try out is to use Dependency Injection on the sample project to enhance your Android skills. </span><span class="koboSpan" id="kobo.621.3">You can utilize </span><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.622.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.623.1">, </span><em class="italic"><span class="koboSpan" id="kobo.624.1">Handling the UI State in Jetpack Compose and Using Hilt</span></em><span class="koboSpan" id="kobo.625.1">, for adding Dependency Injection and also to try writing tests for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">ViewModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1"> class:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.628.1"><img alt="Figure 8.3 – The data loaded on a lazy column" src="image/Figure_8.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.629.1">Figure 8.3 – The data loaded on a lazy column</span></p>
<p><span class="koboSpan" id="kobo.630.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.631.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.632.1">.4</span></em><span class="koboSpan" id="kobo.633.1"> you will see</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.634.1"> a progress loading</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.635.1"> symbol when you scroll down to </span><strong class="bold"><span class="koboSpan" id="kobo.636.1">Student 4</span></strong><span class="koboSpan" id="kobo.637.1"> and so on, which can be great when you have huge loads </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">of data</span><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.639.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.640.1"><img alt="Figure 8.4 – Our data being loaded" src="image/Figure_8.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.641.1">Figure 8.4 – Our data being loaded</span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor408"/><span class="koboSpan" id="kobo.642.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.643.1">You might experience issues</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.644.1"> once you get a list, and it might</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.645.1"> be tough to notify single items. </span><span class="koboSpan" id="kobo.645.2">However, you can easily make your pagination; in our project, we simulate a remote data source but remember that you can use any API for </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">Our primary focus is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">StudentPaginatorImpl</span></strong><span class="koboSpan" id="kobo.649.1"> class – you will notice we pass in a key, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">loadUpdated</span></strong><span class="koboSpan" id="kobo.651.1"> value, and a request which is a suspend function that returns a result from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">Student</span></strong><span class="koboSpan" id="kobo.653.1"> type; we also pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">nextkey</span></strong><span class="koboSpan" id="kobo.655.1">, which tells us where we are. </span><span class="koboSpan" id="kobo.655.2">Then, in case of an error, we have the throwable error and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">suspend</span></strong><span class="koboSpan" id="kobo.657.1"> value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">success</span></strong><span class="koboSpan" id="kobo.659.1">, which gives us the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">success</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1"> result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.662.1">
class StudentPaginatorImpl&lt;Key, Student&gt;(
    private val key: Key,
    private inline val loadUpdated: (Boolean) -&gt; Unit,
    private inline val request: suspend (nextKey: Key) -&gt;
        Result&lt;List&lt;Student&gt;&gt;,
    private inline val nextKey: suspend (List&lt;Student&gt;) -&gt;
        Key,
    private inline val error: suspend (Throwable?) -&gt; Unit,
    private inline val success: suspend (items:
        List&lt;Student&gt;, newKey: Key) -&gt; Unit
) : StudentPaginator&lt;Key, Student&gt; {</span></pre>
<p><span class="koboSpan" id="kobo.663.1">So when we override our function from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">loadNextStudent()</span></strong><span class="koboSpan" id="kobo.665.1"> interface, we first check our current state request and return our initial value as </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">false</span></strong><span class="koboSpan" id="kobo.667.1">, but we update it after our status check. </span><span class="koboSpan" id="kobo.667.2">We also ensure that we reset the key by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">currentKey</span></strong><span class="koboSpan" id="kobo.669.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">nextKey</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
currentKey = nextKey(studentProfiles)
success(studentProfiles, currentKey)
loadUpdated(false)</span></pre>
<p><span class="koboSpan" id="kobo.674.1">This makes it easy if you ever need to customize an item in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">LazyColumn</span></strong><span class="koboSpan" id="kobo.676.1">, ensuring you have </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">great lists.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">loadStudentProfile()</span></strong><span class="koboSpan" id="kobo.680.1"> function has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">viewModelScope.launch {...}</span></strong><span class="koboSpan" id="kobo.682.1">. </span><span class="koboSpan" id="kobo.682.2">A ViewModel scope is defined for each ViewModel in our application. </span><span class="koboSpan" id="kobo.682.3">In addition, any coroutine launched in this scope is auto-canceled if the ViewModel </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">is cleared.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">You might be wondering</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.685.1"> what a ViewModel is. </span><span class="koboSpan" id="kobo.685.2">To help refresh</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.686.1"> your knowledge, you can look into </span><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.687.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.688.1">, </span><em class="italic"><span class="koboSpan" id="kobo.689.1">Handling the U</span><a id="_idTextAnchor409"/><span class="koboSpan" id="kobo.690.1">I State in Jetpack Compose and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.691.1">Using Hilt</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">.</span></span></p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor410"/><span class="koboSpan" id="kobo.693.1">Loading and displaying paged data</span></h1>
<p><span class="koboSpan" id="kobo.694.1">There are essential </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.695.1">steps to consider</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.696.1"> when loading and displaying paged data. </span><span class="koboSpan" id="kobo.696.2">In addition, the Paging library provides tremendous advantages for loading and displaying large, paged datasets. </span><span class="koboSpan" id="kobo.696.3">A few steps you must have in mind is ensuring you first define a data source, your Paging Source set up streams if needed, </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">In this recipe, we will look at </span><a id="_idTextAnchor411"/><span class="koboSpan" id="kobo.699.1">how loading and displaying paged </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">data works.</span></span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor412"/><span class="koboSpan" id="kobo.701.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.702.1">You need to have completed the </span><em class="italic"><span class="koboSpan" id="kobo.703.1">Implementing the Jetpack Paging library</span></em><span class="koboSpan" id="kobo.704.1"> recipe to be able to follow along with the explanation of </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">this recipe:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.706.1">You might have noticed</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.707.1"> in our first recipe that we override </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">load()</span></strong><span class="koboSpan" id="kobo.709.1">, a method</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.710.1"> that we use to indicate how we retrieve the paged data from our corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">data source:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.712.1">
override suspend fun load(params: LoadParams&lt;Int&gt;): LoadResult&lt;Int, NewsArticle&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.713.1">
    return try {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.714.1">
        val page = params.key ?: 1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.715.1">
        val response = newsApiService.getNews(page =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.716.1">
            page)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.717.1">
        LoadResult.Page(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.718.1">
            data = response.articles,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.719.1">
            prevKey = if (page == 1) null else</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.720.1">
                page.minus(1),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.721.1">
            nextKey = if (response.articles.isEmpty())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.722.1">
                null else page.plus(1),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.723.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.724.1">
    } catch (e: Exception) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.725.1">
        LoadResult.Error(e)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.726.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.727.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.728.1">We start refreshing at page </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">1</span></strong><span class="koboSpan" id="kobo.730.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">val page = params.key ?: 1</span></strong><span class="koboSpan" id="kobo.732.1"> is undefined when</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.733.1"> we override </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">getRefreshKey()</span></strong><span class="koboSpan" id="kobo.735.1">; we try to find the page key of the closest page to the anchor</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.736.1"> position from either our previous key or the next key. </span><span class="koboSpan" id="kobo.736.2">We also need to ensure we handle cases where we might have some </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.738.1"> values:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.739.1">
override fun getRefreshKey(state: PagingState&lt;Int, NewsArticle&gt;): Int? </span><span class="koboSpan" id="kobo.739.2">{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.740.1">
    return state.anchorPosition?.let { anchorPosition</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.741.1">
        -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.742.1">
        state.closestPageToPosition(anchorPosition)?</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.743.1">
            .prevKey?.plus(1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.744.1">
            ?: state.closestPageToPosition(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.745.1">
          </span><a id="_idTextAnchor413"/><span class="koboSpan" id="kobo.746.1">      anchorPosition)?.nextKey?.minus(1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.747.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.748.1">
}</span></pre></li>
</ol>
<h2 id="_idParaDest-234"><a id="_idTextAnchor414"/><span class="koboSpan" id="kobo.749.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.750.1">When using the Paging library, you can specify the position of the first item to be displayed on the screen using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">anchorPosition</span></strong><span class="koboSpan" id="kobo.752.1"> parameter. </span><span class="koboSpan" id="kobo.752.2">In addition, </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">anchorPosition</span></strong><span class="koboSpan" id="kobo.754.1"> is an optional parameter that you can pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">PagingItems</span></strong><span class="koboSpan" id="kobo.756.1"> composable function, which is used to display paged data. </span><span class="koboSpan" id="kobo.756.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">anchorPosition</span></strong><span class="koboSpan" id="kobo.758.1"> parameter is used to specify the position of the first item to be displayed on the screen when the composable is </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">first rendered.</span></span></p>
<p><span class="koboSpan" id="kobo.760.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">LoadParams</span></strong><span class="koboSpan" id="kobo.762.1"> object carries the information about the load operation to be performed. </span><span class="koboSpan" id="kobo.762.2">In addition, it knows about the key to be loaded and the number of items to be displayed on the UI. </span><span class="koboSpan" id="kobo.762.3">Furthermore, to better understand how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">load()</span></strong><span class="koboSpan" id="kobo.764.1"> function receives the key for each specific load</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.765.1"> and updates it, review the </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">following</span></span><span class="No-Break"><a id="_idIndexMarker552"/></span><span class="No-Break"><span class="koboSpan" id="kobo.767.1"> diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.768.1"><img alt="Figure 8.5 – How load() uses and updates the key" src="image/Figure_8.5.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor415"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.769.1">Figure 8.5 – How load() uses and updates the key</span></p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor416"/><span class="koboSpan" id="kobo.770.1">Understanding how to transform data streams</span></h1>
<p><span class="koboSpan" id="kobo.771.1">When writing any code dealing</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.772.1"> with Paging, you need to understand how you can transform the data stream as you load it to your users. </span><span class="koboSpan" id="kobo.772.2">For instance, you may need to filter a list of items or even convert the items to a different type before you can feed the UI with </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">Hence, ensuring you apply transformation directly to the stream data lets you keep your repository and UI logic separated cleanly. </span><span class="koboSpan" id="kobo.774.2">In this recipe, we will tr</span><a id="_idTextAnchor417"/><span class="koboSpan" id="kobo.775.1">y to understand how we can transform </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">data streams.</span></span></p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor418"/><span class="koboSpan" id="kobo.777.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.778.1">To follow along, you must be familiar with the primary usage of the Paging library; hence make sure y</span><a id="_idTextAnchor419"/><span class="koboSpan" id="kobo.779.1">ou have read the previous recipes in </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">this chapter.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor420"/><span class="koboSpan" id="kobo.781.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.782.1">In this recipe, we will perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.784.1">Look into how we can apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">essential transformation.</span></span></li>
<li><span class="koboSpan" id="kobo.786.1">Convert and filter </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">the data.</span></span></li>
<li><span class="koboSpan" id="kobo.788.1">Handle separators in the UI and convert the </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">UI model.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.790.1">The recipe is helpful to you if you are already using Paging in </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">your application.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.792.1">First, we need to place the transformation</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.793.1"> inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">map{PagingData -&gt;}</span></strong><span class="koboSpan" id="kobo.795.1">. </span><span class="koboSpan" id="kobo.795.2">A map in Kotlin applies the given lambda function to each element and returns a list of the </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">lambda results:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.797.1">
yourPager.flow</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.798.1">
    .map { PagingData -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.799.1">
        // here is where the transformations are</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.800.1">
           applied to the items in the paged data.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.801.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.802.1">Second, when we want to convert the data or filter, once we have access to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">PagingData</span></strong><span class="koboSpan" id="kobo.804.1"> object, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">map()</span></strong><span class="koboSpan" id="kobo.806.1"> again on each item separately in the paged list. </span><span class="koboSpan" id="kobo.806.2">A typical use case is when you want to map a database or network layer object onto an object that might be used in the UI </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">layer specifically:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.808.1">
yourPager.flow</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.809.1">
    .map { PagingData -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.810.1">
        PagingData.map { sports -&gt; SportsModel(sports)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.811.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.812.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.813.1">We will need to place the filter operation inside the map because the filter applies to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">PagingData</span></strong><span class="koboSpan" id="kobo.815.1"> object. </span><span class="koboSpan" id="kobo.815.2">Then once the data is filtered out from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">PagingData</span></strong><span class="koboSpan" id="kobo.817.1">, the new instance is paged to the UI layer </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">and displayed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.819.1">
yourPager.flow</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.820.1">
    .map { PagingData -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.821.1">
        PagingData.filter { sports -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.822.1">
            !sports.displayInUi }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.823.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.824.1">Finally, when handling separators in the UI or converting the UI model, the most significant steps are ensuring that you do </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">the following:</span></span><ol><li><span class="koboSpan" id="kobo.826.1">Convert the UI models to accommodate your </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">separator items.</span></span></li><li><span class="koboSpan" id="kobo.828.1">Transform the data dynamically and add the separators between presenting and loading </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">the data.</span></span></li><li><a id="_idTextAnchor421"/><span class="koboSpan" id="kobo.830.1">Update the UI to handle the separator </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">items better.</span></span></li></ol></li>
</ol>
<h2 id="_idParaDest-238"><a id="_idTextAnchor422"/><span class="koboSpan" id="kobo.832.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.833.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">PagingData</span></strong><span class="koboSpan" id="kobo.835.1"> is encapsulated in a reactive stream; what this means is that before loading the data and displaying it to the users, you can incrementally apply the transform to the data. </span><span class="koboSpan" id="kobo.835.2">Transforming data streams</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.836.1"> can be crucial when you have a complex application, and handling this situation in advance might help ensure your application scales better a</span><a id="_idTextAnchor423"/><span class="koboSpan" id="kobo.837.1">nd help minimize the complexity of your </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">data growth.</span></span></p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor424"/><span class="koboSpan" id="kobo.839.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.840.1">It is fair to acknowledge that this recipe cannot cover all the information you need to know about transforming the data stream. </span><span class="koboSpan" id="kobo.840.2">That said, if you encounter an issue and want to learn more, you can always reference the following link to learn more about how you can handle separators in the UI and </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">more: </span></span><a href="https://developer.android.com/topic/libraries/architecture/paging/v3-transform"><span class="No-Break"><span class="koboSpan" id="kobo.842.1">https://developer.android.com/topic/libraries/architecture/paging/v3-transform</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.843.1">.</span></span></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor425"/><span class="koboSpan" id="kobo.844.1">Migrating to Paging 3 and understanding the benefits</span></h1>
<p><span class="koboSpan" id="kobo.845.1">You might be using the old Paging</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.846.1"> version, in this</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.847.1"> case, Paging 2 or 1, and you might be required to migrate to utilize the benefits Paging 3 offers. </span><span class="koboSpan" id="kobo.847.2">Paging 3 offers enhanced functionality and ensures it addresses the most common challenges people experience using </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">Paging 2.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">In this recipe, we will look into how you</span><a id="_idTextAnchor426"/><span class="koboSpan" id="kobo.850.1"> can migrate to the latest recommended </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">Paging library.</span></span></p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor427"/><span class="koboSpan" id="kobo.852.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.853.1">If your application is already</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.854.1"> using Paging 3, then you can skip this recipe; this step-by-step migration</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.855.1"> guide is intended for users c</span><a id="_idTextAnchor428"/><span class="koboSpan" id="kobo.856.1">urrently using the older versions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">Paging library.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor429"/><span class="koboSpan" id="kobo.858.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.859.1">Migrating from old versions of the Paging library might seem complex due to the fact that each application is unique, and complexities might vary. </span><span class="koboSpan" id="kobo.859.2">In our example, however, we will touch on a low-level kind of migration since our example application does not need </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">any migration.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">To perform migration from old Paging libraries, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.863.1">The first step is to replace the refresh keys, and this is because we need to define how refreshing resumes from the middle of loading data. </span><span class="koboSpan" id="kobo.863.2">We will do this by first implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">getRefreshKey()</span></strong><span class="koboSpan" id="kobo.865.1">, which maps the correct initial key using </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">PagingState.anchorPosition</span></strong><span class="koboSpan" id="kobo.867.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">recent index:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.869.1">
override fun getRefreshKey(PagingState: PagingState): String? </span><span class="koboSpan" id="kobo.869.2">{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.870.1">
    return PagingState.anchorPosition?.let { position</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.871.1">
        -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.872.1">
            PagingState.getClosestItemToPosition(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.873.1">
                position)?.id</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.874.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.875.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.876.1">Next, we need to ensure we replace the positional </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">data source:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.878.1">
override fun getRefreshKey(PagingState: PagingState): Int? </span><span class="koboSpan" id="kobo.878.2">{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.879.1">
    return PagingState.anchorPosition</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.880.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.881.1">If you are using the old Paging library, the paged data uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">DataSource.map()</span></strong><span class="koboSpan" id="kobo.883.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">mapByPage</span></strong><span class="koboSpan" id="kobo.885.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">Factory.map()</span></strong><span class="koboSpan" id="kobo.887.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">Factory.mapByPage</span></strong><span class="koboSpan" id="kobo.889.1">. </span><span class="koboSpan" id="kobo.889.2">In Paging 3, however, all these are applied as operators </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">PagingData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.893.1">Finally, to ensure you migrate</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.894.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">PageList</span></strong><span class="koboSpan" id="kobo.896.1">, which is in Paging 2, you will need</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.897.1"> to migrate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">PagingData</span></strong><span class="koboSpan" id="kobo.899.1">. </span><span class="koboSpan" id="kobo.899.2">The most notable change is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">PagedList.Config</span></strong><span class="koboSpan" id="kobo.901.1"> is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">PagingConfig</span></strong><span class="koboSpan" id="kobo.903.1">. </span><span class="koboSpan" id="kobo.903.2">In addition, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">Pager()</span></strong><span class="koboSpan" id="kobo.905.1"> exposes an observable </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">Flow&lt;PagingData&gt;</span></strong><span class="koboSpan" id="kobo.907.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">its flow:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.909.1">
val yourFlow = Pager(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.910.1">
    PagingConfig(pageSize = 24)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.911.1">
) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.912.1">
    YourPagingSource(yo</span><a id="_idTextAnchor430"/><span class="koboSpan" id="kobo.913.1">urBackend, yourQuery)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.914.1">
}.flow</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.915.1">
    .cachedIn(viewModelScope)</span></pre></li>
</ol>
<h2 id="_idParaDest-243"><a id="_idTextAnchor431"/><span class="koboSpan" id="kobo.916.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.917.1">To ensure your migration is complete and successful, you must make sure you migrate all the significant components from Paging 2. </span><span class="koboSpan" id="kobo.917.2">This includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">DataSource</span></strong><span class="koboSpan" id="kobo.919.1"> classes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">PagedList</span></strong><span class="koboSpan" id="kobo.921.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">PagedListAdapter</span></strong><span class="koboSpan" id="kobo.923.1"> if your application uses it. </span><span class="koboSpan" id="kobo.923.2">Furthermore, some Paging 3 components work well with other versions, which simply means it is </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">backward compatible.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">The most notable change to </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">PagingSource</span></strong><span class="koboSpan" id="kobo.927.1"> in Paging 3 is that it combines all the loading functions into one, now called </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">load()</span></strong><span class="koboSpan" id="kobo.929.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">PagingSource</span></strong><span class="koboSpan" id="kobo.931.1">. </span><span class="koboSpan" id="kobo.931.2">This ensures there is no redundancy in the code because the loading logic is often identical to the old API. </span><span class="koboSpan" id="kobo.931.3">In addition, the loading function parameters in Paging 3 now use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">LoadParams</span></strong><span class="koboSpan" id="kobo.933.1"> sealed class, which has subclasses for each </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">load type.</span></span></p>
<p><span class="koboSpan" id="kobo.935.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">PagedList</span></strong><span class="koboSpan" id="kobo.937.1">, which is used in Paging 2, when you migrate, you might use </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">PagingData</span></strong><span class="koboSpan" id="kobo.939.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">Pager</span></strong><span class="koboSpan" id="kobo.941.1">. </span><span class="koboSpan" id="kobo.941.2">When you start to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">PagingData</span></strong><span class="koboSpan" id="kobo.943.1"> from Paging 3, you should ensure</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.944.1"> that the configurati</span><a id="_idTextAnchor432"/><span class="koboSpan" id="kobo.945.1">on</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.946.1"> is moved from the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">PagedList.Config</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.948.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">PagingConfig</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">.</span></span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor433"/><span class="koboSpan" id="kobo.951.1">Writing tests for your Paging Source</span></h1>
<p><span class="koboSpan" id="kobo.952.1">Writing tests for your implementations</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.953.1"> is crucial. </span><span class="koboSpan" id="kobo.953.2">We will write unit tests for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">PagingSource</span></strong><span class="koboSpan" id="kobo.955.1"> implementation</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.956.1"> in this recipe to test our logic. </span><span class="koboSpan" id="kobo.956.2">Some tests that might be worth writing are checking when news Paging load </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">failure happens.</span></span></p>
<p><span class="koboSpan" id="kobo.958.1">We can also test the success state and more. </span><span class="koboSpan" id="kobo.958.2">You can fo</span><a id="_idTextAnchor434"/><span class="koboSpan" id="kobo.959.1">llow the pattern to write tests for your project or </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">use case.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor435"/><span class="koboSpan" id="kobo.961.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.962.1">To follow this recipe step by step, you need to have followed the </span><em class="italic"><span class="koboSpan" id="kobo.963.1">Implementing the Jetpack Paging library</span><a id="_idTextAnchor436"/></em><span class="koboSpan" id="kobo.964.1"> recipe, and you need to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">PagingJetpackExample</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.966.1"> project.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor437"/><span class="koboSpan" id="kobo.967.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.968.1">Open </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">PagingJetpackExample</span></strong><span class="koboSpan" id="kobo.970.1"> and follow along with this project to add </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">unit tests:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.972.1">Add the following testing libraries to your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.974.1"> app:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.975.1">
testImplementation 'org.assertj:assertj-core:3.x.x'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.976.1">
testImplementation "org.mockito:mockito-core:3.x.x"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.977.1">
testImplementation 'Androidx.arch.core:core-testing:2.x.x'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.978.1">
testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.x.x'</span></pre></li>
<li><span class="koboSpan" id="kobo.979.1">After adding the dependencies, create a new package and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">data</span></strong><span class="koboSpan" id="kobo.981.1"> in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">test</span></strong><span class="koboSpan" id="kobo.983.1"> package in the project structure. </span><span class="koboSpan" id="kobo.983.2">You can reference the </span><em class="italic"><span class="koboSpan" id="kobo.984.1">Understanding the Android project structure</span></em><span class="koboSpan" id="kobo.985.1"> recipe in </span><a href="B18827_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.986.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.987.1">, </span><em class="italic"><span class="koboSpan" id="kobo.988.1">Getting Started with Modern Android Development Skills</span></em><span class="koboSpan" id="kobo.989.1">, if you need help finding </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">the folder.</span></span></li>
<li><span class="koboSpan" id="kobo.991.1">Create a test class and call </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">NewsArticlePagingSourceTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.995.1">Inside the class, let’s go</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.996.1"> ahead and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">Mock</span></strong><span class="koboSpan" id="kobo.998.1"> to mock our </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">ApiService</span></strong><span class="koboSpan" id="kobo.1000.1"> interface</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.1001.1"> and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">lateinit var newsApiService</span></strong><span class="koboSpan" id="kobo.1003.1"> that we will initialize at our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">Before</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1"> step:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1007.1">
@Mock</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1008.1">
private lateinit var newsApiService: NewsApiService</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
lateinit var newsPagingSource: NewsArticlePagingSource</span></pre></li>
<li><span class="koboSpan" id="kobo.1010.1">Now let’s go ahead and create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">@Before </span></strong><span class="koboSpan" id="kobo.1012.1">so we can run our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">CoroutineDispatchers</span></strong><span class="koboSpan" id="kobo.1014.1">, which is used by all standard builders such as async, and launch to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">@Before</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1016.1">step too:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1017.1">
@Before</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
fun setup() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1019.1">
    Dispatchers.setMain(testDispatcher)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1020.1">
    newsPagingSource =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
        NewsArticlePagingSource(newsApiService)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.1023.1">The first test we will need to write is to check when a failure happens. </span><span class="koboSpan" id="kobo.1023.2">Hence let’s go ahead and set up our test. </span><span class="koboSpan" id="kobo.1023.3">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">403</span></strong><span class="koboSpan" id="kobo.1025.1"> response is a forbidden status code indicating the server understood your request but did not </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">authorize it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1027.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
fun `news article Paging Source load failure http error`() = runBlockingTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1029.1">
    //setup</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1030.1">
    val error = HttpException(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1031.1">
        Response.error&lt;ResponseBody&gt;(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
            403, "some content".toResponseBody(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1033.1">
                "plain/text".toMediaTypeOrNull())</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1034.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
    ) . </span><span class="koboSpan" id="kobo.1035.2">. </span><span class="koboSpan" id="kobo.1035.3">.</span></pre></li>
<li><span class="koboSpan" id="kobo.1036.1">To continue</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.1037.1"> our test, we will need</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.1038.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">Mockito.doThrow(error)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1042.1">
Mockito.doThrow(error)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1043.1">
    .`when`(newsApiService)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1044.1">
    .getNews(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
        1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1046.1">
    ). </span><span class="koboSpan" id="kobo.1046.2">. </span><span class="koboSpan" id="kobo.1046.3">.</span></pre></li>
<li><span class="koboSpan" id="kobo.1047.1">Then, finally, we trigger </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">PagingSource.LoadResult.Error</span></strong><span class="koboSpan" id="kobo.1049.1"> and pass in the type, </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">then assert:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
//assert</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
assertEquals(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
    expectedResult, newsPagingSource.load(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1054.1">
        PagingSource.LoadParams.Refresh(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1055.1">
            key = null,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1056.1">
            loadSize = 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1057.1">
            placeholdersEnabled = false</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1058.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1059.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1060.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.1061.1">You can add two more additional tests and then add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">tearDown</span></strong><span class="koboSpan" id="kobo.1063.1"> to clean up </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">the coroutines:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
@A</span><a id="_idTextAnchor438"/><span class="koboSpan" id="kobo.1066.1">fter</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
fun tearDown() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1068.1">
    testDispatcher.cleanupTestCoroutines()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1069.1">
}</span></pre></li>
</ol>
<h2 id="_idParaDest-247"><a id="_idTextAnchor439"/><span class="koboSpan" id="kobo.1070.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.1071.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">Mock</span></strong><span class="koboSpan" id="kobo.1073.1"> in unit tests, and the general idea is based on the notion that the objects under tests might have dependencies on other complex objects. </span><span class="koboSpan" id="kobo.1073.2">Based on this, it is much easier to isolate the behavior of the object we want by mocking the object, which ensures it has the same behavior as our real object and makes </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">testing </span><a id="_idTextAnchor440"/><span class="koboSpan" id="kobo.1075.1">easier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
@Mock
private lateinit var newsApiService: NewsApiService</span></pre>
<p><span class="koboSpan" id="kobo.1077.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">lateinit var newsPagingSource: NewsArticlePagingSource</span></strong><span class="koboSpan" id="kobo.1079.1"> is used for late</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.1080.1"> initialization, and we initialize</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.1081.1"> it on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">Before</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1"> function.</span></span></p>
</div>
</body></html>