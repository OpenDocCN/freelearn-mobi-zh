<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Getting Started with Material Design</h1></div></div></div><p>Announced at the 2014 Google I/O conference and making its first appearance in Android Lollipop, Material Design is the new design language from Google.</p><p>This is particularly big news for Android, as Material Design's whole purpose is to provide a more consistent user experience; and as an open platform Android is particularly vulnerable to inconsistencies. Open your Android device's app drawer and spend some time flicking through your apps, and chances are you'll encounter at least a few apps that will look and feel <em>very</em> different from one another.</p><p>Material Design sets out to change all this by providing the tools and guidelines that you need to deliver a more unified user experience.</p><p>By adhering to Material Design principles, you can create apps that look good, run smoothly, and feel like a seamless extension of the Android platform. And who wouldn't want that?</p><p>However, Material Design is more than just a bunch of technical specifications about how much shading you should apply to a button and how opaque your UI's primary text should be. So, before we get into <em>how</em> to create a UI that perfectly compliments Google's new design direction, let's get a better understanding of what Material Design is by looking at the theory behind it.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>The Material Design ethos</h1></div></div></div><p>Material Design is based on the idea of translating the physical properties of real-world materials into the virtual screen, and it takes much of its inspiration from paper, ink, and print techniques.</p><p>Material Design encourages designers and developers to create on-screen objects that seem to possess the same qualities as real-world objects. This means using techniques such as shadows, light, and elevation to create a sense of depth and edges.</p><p>The way Material Design objects move also mimics how objects move in the physical world; for example, two real-world objects cannot occupy the same space simultaneously or pass through one another, so your on-screen objects shouldn't either.</p><p>To help you create this illusion, Material Design introduces the concept of a simulated 3D space where all UI objects possess <em>X</em>, <em>Y</em>, and <em>Z</em> coordinates. The <em>Z</em> coordinate is particularly important, as the positive <em>Z</em> axis extends outward toward the user, creating that sense of depth that's so very crucial to Material Design.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>In Material Design, every object occupies a position on the <em>Z</em> axis, and iteach object has a standard 1dp thickness.</p></div></div><p>Everything happens within Material Design's simulated 3D environment; objects appear, disappear, and transform into new objects without ever breaking the illusion of a continuous 3D environment.</p><p>When objects move through the Material Design space, they mimic how paper can be shuffled and bound together. For example, you can bind two sheets of material together along a common edge or <em>seam</em>, so they move together. By contrast, when two sheets of material overlap but occupy different positions along the <em>Z</em> axis, they're <em>not</em> bound together, and so can move independent of one another.</p><p>These design principles may give your user interface a distinct look and feel, but Material Design isn't just about how your UI looks. You can use Material Design elements such as depth and shadow to give your users visual clues about your interface's hierarchy, subtly guiding them toward the UI elements that they need to interact with next. If used correctly, Material Design can help to ensure that your users instinctively know how to navigate and interact with your app's user interface.</p><p>One of the most effective ways of getting to grips with Material Design is to look at some examples of Material Design that are done well, so you know what you're aiming for.</p><p>Since Material Design is Google's design language, what better place to look for pointers than Google's own apps?</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Case study – Hangouts</h2></div></div></div><p>The Hangouts app has undergone a major overhaul to bring it into line with Material Design.</p><p>One of the most notable UI changes is the <strong>Create New Message</strong> button, which now appears as a floating action button, also known as a FAB. As the most important action, this FAB is prominently and conveniently located in the bottom-right part of the main Hangouts screen, so it's always within easy reach when the user needs to create a new message.</p><p>
</p><div><img src="img/B05061_4_1.jpg" alt="Case study – Hangouts"/></div><p>
</p><p>The Hangouts app uses two Material Design staples—elevation and shadows—to create the sense that the FAB is floating above all the other UI elements. This naturally draws the user's attention toward the screen's most important task; in this instance, the most important task is creating a new message.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Case study – Google Calendar</h2></div></div></div><p>Material Design encourages the use of bold colors and large images. You'll find both of these in the updated Google Calendar app.</p><p>
</p><div><img src="img/B05061_4_2.jpg" alt="Case study – Google Calendar"/></div><p>
</p><p>Google Calendar is a great example of a UI where colors and images not only make the app fun to look at, but also serve a purpose by helping the user pick up important information about their schedule at a glance. For example, a quick glance at the previous calendar image is all that's needed to see I have running club coming up on Monday night, thanks to the large, colorful picture of the running shoes.</p><p>Calendar is also a great example of Material Design animations. Spend some time moving around the Calendar app, and you'll encounter different animated flourishes, such as the on-screen elements moving on and off the screen, assembling into new views.</p><p>These short animations make navigating through the Google Calendar app a more fluid, natural, and generally much more enjoyable experience.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Case study – Google Maps</h2></div></div></div><p>Google Maps uses Material Design's concept of <strong>bottom sheets</strong> to create an immersive experience, where the user selects a location and then explores all the information related to this location without leaving the Maps environment.</p><p>Open the Google Maps app and select a location (whether it's a huge tourist attraction, a famous landmark, or simply your local pub), and you'll notice a bottom sheet peeking up from the bottom of your screen. In its default state, this bottom sheet displays a few facts about your chosen location, but when you drag the sheet upward, it expands to fill the entire screen. This expanded sheet contains much more information, including opening times, contact details, photos, and user reviews of your chosen location:</p><p>
</p><div><img src="img/B05061_4_3.jpg" alt="Case study – Google Maps"/></div><p>
</p><p>Bottom sheets use shadows and elevation to create the impression that some components are positioned higher than others. In our Google Maps screenshot, the photo component is styled, so it appears to be lower than the rest of the bottom sheet.</p><p>Once you've read everything the bottom sheet has to offer, you can dismiss it by dragging the sheet off the screen. The bottom sheet will fold away, revealing the main Google Maps screen, leaving you with the impression that this main screen was hiding behind the bottom sheet the entire time.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Getting started with Material Design</h1></div></div></div><p>Now that we've explored the major concepts behind Material Design and seen a few examples of Material Design done well, it's time to look at how you can apply some of the core Material Design principles to your own Android apps.</p><p>The next few sections will show you how to give your app a Material Design makeover using visual techniques such as shadows and elevation. You will also learn how to make some more fundamental changes to the way your app functions, by adding things such as FABs, cards, and <code class="literal">RecyclerView</code>. Let's start by making sure your app <em>looks</em> the part.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Applying the Material theme to your app</h2></div></div></div><p>Applying the Material theme is the quickest and easiest way to get a consistent Material Design look across your entire app.</p><p>Android provides light and dark variations for you to choose from:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Theme.Material</code>: This is the dark version of the Material theme. This is considered the default Material theme.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Theme.Material.Light</code>: This is the light variation of the Material theme.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Theme.Material.Light.DarkActionBar</code>: This is the light version of the theme but with a dark action bar.</li></ul></div><p>To apply the Material theme to your app, you need to create a new style that inherits from the version of the theme that you want to use (<code class="literal">Theme.Material</code>, <code class="literal">Theme.Material.Light</code>, or <code class="literal">Theme.Material.Light.DarkActionBar</code>). Open your project's <code class="literal">res/valus/styles.xml</code>  file, and create a new style that inherits from the theme of your choice:</p><pre class="programlisting">&lt;resources&gt; &#13;
  &lt;style name="AppTheme" parent="android:Theme.Material"&gt; &#13;
 &#13;
//Inherits from the standard Theme.Material// &#13;
 &#13;
  &lt;/style&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>To give your app its own identity while maintaining the look and feel of Material Design, you may want to add your own customizations to your inherited Material Design style. One of the most common customizations is changing the theme's base colors; for example, you may want to change the color of the action bar to match your app's <em>primary color</em>.</p><p>Material Design uses two kinds of colors: primary and accent. As the name suggests, the primary color is the main color that's used throughout your app—in Google Hangouts the primary color is green.</p><p>The accent color is a brighter shade that you use to draw attention to your app's most important elements, such as the floating action button or title. By using a consistent primary color with the occasional splash of bolder accent color, you can create a user interface that's colorful and vibrant but doesn't distract the user from your application's content.</p><p>When it's time to customize the colors used in your inherited Material Design theme, there are several available attributes you can use:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">colorPrimary</code>: This sets the color of the action bar's background. This is your app's primary color.</li><li class="listitem" style="list-style-type: disc"><code class="literal">colorAccent</code>: This is your app's accent color. This should compliment your app's primary color, and is a good way of drawing the user's attention toward important UI elements.</li><li class="listitem" style="list-style-type: disc"><code class="literal">colorControlNormal</code>: This sets the color of your app's framework controls when they're in their default, non-activated state.</li><li class="listitem" style="list-style-type: disc"><code class="literal">colorControlActivated</code>: This sets the color of your framework controls when they're in their activated state. This attribute overrides <code class="literal">colorAccent</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:textColorPrimary</code>: This sets the color of the text on your controls. On devices running a pre-Lollipop version of Android, this attribute sets the color of the overflow menu and the action bar title.</li></ul></div><p>The following attributes only work on devices running Android 5.0 or higher:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">colorPrimaryDark</code>: This is a dark variant of your app's primary color. This attribute sets the color of your navigation bar (via <code class="literal">navigationBarColor</code>) and status bar (via <code class="literal">statusBarColor</code>).</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">colorControlHighlight</code>: This is the color applied to your app's framework control highlights, such as ripple animations. You can use this attribute to provide visual feedback that compliments your app's color scheme. Just don't get carried away—too much visual feedback and you're running the risk of overwhelming the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">colorSwitchThumbNormal</code>: The user interacts with a toggle switch by dragging the switch's <code class="literal">Thumb</code> section back and forth. This attribute sets the color of the <code class="literal">Thumb</code> element when it's in the <em>off</em> position.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:colorButtonNormal</code>: This sets the color of a button when it's in its default, non-pressed state.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:colorEdgeEffect</code>: This sets the color of your app's overscroll effect, which occurs when the user tries to scroll beyond your content's boundaries.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:navigationBarColor</code>: This sets the color of the navigation bar, which is the bar that appears at the bottom of your device and contains the <em>
<strong>Back</strong>,</em> <em>
<strong>Home</strong>,</em> and <em>
<strong>Recent</strong>
</em> softkeys.</li></ul></div><p>To create your own variation of the Material theme, add any of the preceding attributes to the style we created earlier:</p><pre class="programlisting">&lt;resources&gt; &#13;
 &#13;
  &lt;style name="AppTheme" parent="android:Theme.Material"&gt; &#13;
 &#13;
    &lt;item name="android:colorPrimary"&gt;@color/blue&lt;/item&gt; &#13;
 &#13;
//Specifies that the theme's primary color should be blue// &#13;
 &#13;
    &lt;item name="colorPrimaryDark"&gt;@color/darkblue&lt;/item&gt; &#13;
 &#13;
//Specifies that the navigation bar and status bar should be dark blue// &#13;
 &#13;
    &lt;item name="colorAccent"&gt;@color/white&lt;/item&gt; &#13;
 &#13;
//Specifies that the app's accent color should be white// &#13;
 &#13;
&lt;item name="colorSwitchThumbNormal"&gt;@color/white&lt;/item&gt; &#13;
 &#13;
//All the switches should have a white thumb element// &#13;
 &#13;
  &lt;/style&gt; &#13;
 &#13;
&lt;/resources&gt; &#13;
</pre><p>Now, you know how to customize the colors in your Material-inspired theme, but what colors should you use? Once again, Material Design has the answers.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec23"/>Choosing your color scheme</h3></div></div></div><p>Choosing your color scheme is one of the most important UI decisions you need to make, as the colors you pick will affect every single part of your user interface.</p><p>To help you make this crucial design decision, the Android team released a complete palette of primary and accent colors that are designed to compliment one another. You can find the complete Material Design palette at <a class="ulink" href="https://www.google.com/design/spec/style/color.html">
https://www.google.com/design/spec/style/color.html#
</a>.</p><p>When choosing your app's color scheme, you should select three hues from the primary palette (that's any color marked 500) and one accent color from the secondary palette (that's any color <em>except</em> the 500 colors).</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p><strong>Need some help selecting your palette?</strong></p><p>Struggling to choose from the massive selection of colors and shades on offer? You may want to check out one of the many websites that can generate a complete Material Design palette for you. Simply select two colors, and the website generates a complete palette of primary and accent colors based on your selection. There's plenty of palette generators available online, but one of the simplest and easiest to use is Material Palette at <a class="ulink" href="http://www.materialpalette.com/">
http://www.materialpalette.com/
</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec24"/>Backwards compatibility</h3></div></div></div><p>The Material theme is only available in Android 5.0 (API level 21) and upwards, so in its default state you cannot use the Material theme or any other custom theme derived from it on devices running earlier versions of Android.</p><p>However, you can make the Material theme available to users running API 7 and higher using the <strong>AppCompat library</strong>.</p><p>To add this library to your project, make sure you've downloaded the latest version of <strong>Android Support Library</strong> (if you're using Eclipse) or <strong>Android Support Repository</strong> (if you're using Android Studio). AppCompat relies on the v4 support library so make sure you've also added this library to your project.</p><p>Android Studio users need to add AppCompat as a dependency in their module-level <code class="literal">build.gradle</code> file:</p><pre class="programlisting">dependencies { &#13;
    ... &#13;
    compile 'com.android.support:appcompat-v7:23.1.0' &#13;
} &#13;
</pre><p>Eclipse users will need to locate the AppCompat library in their Android SDK directory, copy the library into their project's <code class="literal">libs</code> directory, right-click on the JAR file and select <strong>Build Path</strong>, followed by <strong>Add to Build Path</strong>.</p><p>To use AppCompat, make sure all your project's activities extend <code class="literal">AppCompatActivity</code>:</p><pre class="programlisting">import android.support.v7.app.AppCompatActivity; &#13;
 &#13;
public class MainActivity extends AppCompatActivity { &#13;
</pre><p>Your theme must also inherit from <code class="literal">Theme.AppCompat</code>:</p><pre class="programlisting">&lt;style name="AppTheme" parent="Theme.AppCompat"&gt; &#13;
</pre><p>After this, you're free to customize the Material theme as normal.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Creating a sense of depth</h2></div></div></div><p>Material Design combines three visual techniques to create a sense of depth:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Lights</strong>: In Material Design's simulated 3D environment, virtual lights illuminate the on-screen objects and allow them to cast shadows. Lighting takes the form of either key lights (which cast directional shadows) or ambient lighting (which create soft shadows from all angles).</li><li class="listitem" style="list-style-type: disc"><strong>Shadows</strong>: These give your users important visual clues about each object's depth. When an object moves, shadows continue to supply important information including the direction the object is moving toward, and whether the distance between this object and other on-screen objects is increasing or decreasing. The shape an object casts is defined by the object's background and <em>not</em> its content, so a circular button will cast a circular shadow, regardless of the shape of the button's icon.</li><li class="listitem" style="list-style-type: disc"><strong>Elevation</strong>: Each UI element has its own elevation, which is the object's elevation along the <em>Z</em> axis. Elevation can help you communicate the importance of each screen's different UI elements, naturally drawing the user's eye toward the most important on-screen elements.</li></ul></div><p>You can create shadows by specifying an object's elevation. When you add an elevation, the framework automatically casts a shadow across the items behind the object. An object's elevation determines the appearance of its shadow; a view with a higher <em>Z</em> value will cast a larger, softer shadow.</p><p>To set a view's elevation, use the <code class="literal">android:elevation</code> attribute:</p><pre class="programlisting">&lt;TextView &#13;
  android:layout_width="wrap_content" &#13;
  android:layout_height="wrap_content" &#13;
  android:elevation="20dp" &#13;
  android:text="Hello down there!" /&gt; &#13;
</pre><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>Just keep in mind that all material elements have a thickness of 1dp, so elevation is the distance from the top of one surface to the top of another.</p></div></div><p>If you want to set a view's elevation programmatically, use the <code class="literal">View.setElevation</code> and <code class="literal">View.getElevation</code> methods.</p><p>Every object has a default <em>resting</em> elevation that should be consistent across your app. For example, if you position a floating action button at 10dp on one screen, it should be positioned at 10dp on <em>every</em> screen.</p><p>Objects can also have a responsive elevation, which is where they temporarily change their elevation in response to a user action. For example, if the user selects a picture in a gallery app, this picture may temporarily increase its elevation to indicate its selected status.</p><p>Responsive elevations should also be consistent across your app, so if the picture in a gallery app changes elevation by 5dp, all other images that have responsive elevations must display the exact same 5dp behavior.</p><p>If an object changes elevation, it should return to its resting elevation as soon as possible—typically as soon as the input event is completed or cancelled.</p><p>When adding components with responsive elevations, check that there's no possibility of one component encountering another component while it is changing elevation. Remember that in Material Design, objects cannot pass through one another! If the space is tight, then one solution is to use animations to temporarily move objects out of the way; for example, you could animate one object a few pixels to the right in order to clear the way for an object that's changing its elevation.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec25"/>Creating a Material Design structure</h3></div></div></div><p>At this point, you've selected your color palette, created a customized version of the Material theme, and know how to add elevation to your user interface.</p><p>The next step is to look at some of the new structural elements you can add to your app, so it doesn't <em>just</em> look like a Material app, it acts like a Material app, too.</p><p>Let's start with one of the most familiar Material Design features: floating action buttons.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Floating action buttons</h2></div></div></div><p>A FAB is a circular sheet of material that appears to float above the user interface (hence the name). If you have a persistent action that needs to be readily available to the user, you should consider displaying it as a FAB.</p><p>Floating icon buttons represent a single promoted action, and use the familiar system icons.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>You can find all the system icons at 
<a class="ulink" href="https://www.google.com/design/icons/">https://www.google.com/design/icons/</a>
.</p></div></div><p>Adding a FAB to your project via XML is fairly straightforward, as it uses many attributes you're already familiar with, such as <code class="literal">android:id</code> and <code class="literal">layout_width</code>. However, in our FAB example, we're going to use a new element called <code class="literal">CoordinatorLayout</code>. This attribute lets you control the way your UI elements interact, and is particularly useful for telling FABs how they should react when the user scrolls the screen; should they move or remain anchored in the same place?</p><p>In this example, we're placing our FAB inside <code class="literal">CoordinatorLayout</code> and telling it to remain anchored to the bottom of the toolbar:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;android.support.design.widget.CoordinatorLayout &#13;
......... &#13;
......... &#13;
.......... &#13;
 &#13;
&lt;android.support.design.widget.FloatingActionButton &#13;
  android:id="@+id/myfab" &#13;
  android:layout_width="wrap_content" &#13;
  android:layout_height="wrap_content" &#13;
  app:layout_anchor="@id/actionbar" &#13;
 &#13;
//The FAB should stay anchored to the action bar//  &#13;
 &#13;
  app:layout_anchorGravity="bottom|right|end" &#13;
  android:layout_margin="@dimen/fab_margin" &#13;
  app:elevation="20dp" &#13;
 &#13;
//Set the button's elevation so it appears to hover above the rest of the UI, and casts a shadow across the items behind it//   &#13;
 &#13;
  android:src="img/ic_dialog_email" /&gt; &#13;
 &#13;
//This references the icon that the FAB should display. In this example, I'm using the create new email icon//  &#13;
 &#13;
&lt;/android.support.design.widget.CoordinatorLayout&gt; &#13;
</pre><p>You may notice that we haven't specified the FAB's background color; that's because the FAB defaults to your theme's <code class="literal">colorAccent</code> property unless you specify otherwise.</p><p>You can add a click event in the usual way. So, to make things interesting, I'll throw in another new element from Material Design: the <strong>Snackbar</strong>.</p><p>Snackbars are similar to Toasts, but the key difference is that users can interact with them. The user dismisses a Snackbar by swiping it off the screen. Snackbars appear at the bottom of the screen. So, they are perfect for displaying a message that relates to our FAB, which also happens to be positioned towards the bottom of the screen:</p><pre class="programlisting">fab.setOnClickListener(new View.OnClickListener() { &#13;
    @Override public void onClick(View v) { &#13;
        Snackbar.make(content, "The FAB has been clicked!",          Snackbar.LENGTH_SHORT).show(); &#13;
 &#13;
//Create a snackbar and display the message "The FAB has been clicked!"// &#13;
 &#13;
    } &#13;
}); &#13;
</pre><p>When creating FABs there are a few guidelines you should keep in mind:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Be positive</strong>: Only use FABs for positive actions such as <strong>Create</strong>, <strong>Like</strong>, <strong>Share</strong>, or <strong>Navigate, </strong>and never for destructive actions such as <strong>Archive</strong> or <strong>Trash</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Use consistent spacing</strong>: On mobile devices, you should place your FABs 16dp or more from the edge. On tablet-sized devices, floating action buttons should be a minimum of 24dp away from the edge.</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Avoid customized FABs</strong>: Always use the standard circular icon, and don't be tempted to give your action button extra dimensions. If you do want to put your own spin on a FAB, you can always animate the icon inside the button.</li><li class="listitem" style="list-style-type: disc"><strong>Don't include overflow actions</strong>: Overflow menus belong in toolbars, not in FABs.</li></ul></div><div><div><h3 class="title"><a id="tip33"/>Tip</h3><p>
<strong>Impress with FAB animations</strong></p><p>As a prominent UI element, FABs are the perfect opportunity to surprise and delight your users with animated flourishes. For example, you could design your <code class="literal">Create new email</code> FAB, so it transforms into a new e-mail when tapped. Experiment with different animations and transitions, but don't get carried away! Animations should be subtle, finishing touches and never get in the user's way or run the risk of distracting them from your app's actual content.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Bottom sheets</h2></div></div></div><p>A bottom sheet is a sheet of material that slides up from the bottom of the screen in response to user action, for example the sheet that appears when you select a point of interest in Google Maps.</p><p>A bottom sheet's initial height is relative to the height of the list items it contains, but a bottom sheet's initial height shouldn't be more than its 16:9 ratio.</p><p>Bottom sheets initially only cover a portion of the screen, but they do expand to fill the entire screen when the user swipes upward. When a bottom sheet is expanded to its full height, the user can scroll through its content; again, the Google Maps app is a perfect example of this functionality.</p><p>Bottom sheets are best suited to displaying three or more actions that don't require a description. If you want to display fewer than three actions, or you want to include detailed descriptions, then you should consider using a dialogue or menu instead.</p><p>There are two types of bottom sheets:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Persistent bottom sheets:<p>These are persistent structural elements that appear throughout your application. They display in-app content that supplements the main view. Persistent bottom sheets remain visible even when they're not actively in use, and they rest at the same elevation as the rest of your app. Persistent bottom sheets are useful for drawing the user's attention toward important content by presenting it in a unique way.</p></li><li class="listitem" style="list-style-type: disc">Modal bottom sheets:<p>This is a temporary sheet of material that rests at a higher elevation than the rest of your content.</p><p>You can use modal bottom sheets to present actions in a list or grid format as an alternative to menus and simple dialogues. It's impossible for the user to overlook a modal sheet; when an active modal bottom sheet slides onto the screen, the rest of the screen dims. Users have to dismiss the modal sheet before they can interact with the underlying content. Modal bottom sheets are handy if you need to present the user with a list of actions, and there's no suitable place in your user interface where you can insert a menu button.</p></li></ul></div><p>However, on larger screens where space is less restricted, components such as dialogues and menus may be more appropriate than modal bottom sheets. This is because bottom sheets, as the name suggests, always appear at the bottom of the screen. For a user interacting with your app on a larger device, such as a tablet held in portrait mode, a modal sheet may appear at a significant distance from where the user triggered the sheet. This might not sound like a big deal, but little annoyances like this can really add up, chipping away at the user's overall experience of your app.</p><p>
</p><div><img src="img/B05061_4_4.jpg" alt="Bottom sheets"/></div><p>
</p><p>The preceding screenshot shows an example of a modal bottom sheet in its default state before it's expanded.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>CardView</h2></div></div></div><p>Cards give you a convenient and consistent way of displaying related content, particularly content that comprises of multiple data types. For example, you could create a card that contains images, links, text, or video about a specific subject.</p><p>Cards are also handy when you want to display data alongside interactive features, such as <strong>+1</strong>, comments, and user reviews. Just be wary of overloading your cards with too much information.</p><p>Cards have a constant width and a variable height that can expand temporarily depending on the available space.</p><p>Each card is made up of blocks of content. A typical card consists of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>A header or primary title</em>. This should indicate what the card is all about.</li><li class="listitem" style="list-style-type: disc"><em>Rich media</em> such as images or video. Including rich media helps the user get valuable information from your card at a glance; for example, if you're designing a weather app, featuring a picture on every card means your users get an idea of what the weather is going to be like just by glancing at that card.</li></ul></div><p>
</p><div><img src="img/B05061_4_5.jpg" alt="CardView"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Supporting text</em>. Text that provides important information about the card.</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>A primary action</em>. This is the most important action the user can perform within the context of this card. Think of this as the card's equivalent of a FAB. </li><li class="listitem" style="list-style-type: disc"><em>Optional supplemental actions</em>. These can be icons, text, or even UI controls that give the user the ability to change the card's content. In our weather example, you may include a slider that allows the user to scroll through the weather forecast for each hour.</li></ul></div><p>When you're designing your card's content hierarchy, you should place the most important content at the top, whereas supplemental icons usually belong at the very bottom of the card.</p><p>You add a card to your layout using <code class="literal">CardView</code>. The following code shows you how to add an empty card to your layout via XML:</p><pre class="programlisting">&lt;android.support.v7.widget.CardView &#13;
 &#13;
      &#13;
     android:layout_width="match_parent" &#13;
     android:layout_height="wrap_content"&gt; &#13;
 &#13;
&lt;/android.support.v7.widget.CardView&gt; &#13;
</pre><p>You add content to <code class="literal">Cardview</code> in exactly the same way you add content to a regular layout. The following example demonstrates how to create a <code class="literal">LinearLayout</code> that contains a <code class="literal">Contacts</code> card. This <code class="literal">Contacts CardView</code> displays each person's name and avatar:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
 &#13;
&lt;LinearLayout   &#13;
   &#13;
   &#13;
  android:layout_width="match_parent" &#13;
 &#13;
  android:layout_height="match_parent" &#13;
  android:padding="20dp"  &gt; &#13;
 &#13;
  &lt;android.support.v7.widget.CardView &#13;
      android:layout_width="match_parent" &#13;
      android:layout_height="wrap_content" &#13;
      android:id="@+id/contacts" &gt; &#13;
 &#13;
   &lt;LinearLayout  &#13;
     &#13;
    android:orientation="vertical" &#13;
    android:layout_width="match_parent" &#13;
    android:layout_height="match_parent"&gt; &#13;
 &#13;
&lt;TextView &#13;
     android:id="@+id/contactName" &#13;
     android:layout_width="wrap_content" &#13;
     android:layout_height="wrap_content" &#13;
     android:text="@string/contactName" /&gt; &#13;
 &#13;
 &lt;ImageView &#13;
     android:layout_width="wrap_content" &#13;
     android:layout_height="wrap_content" &#13;
     android:id="@+id/contactphoto" &#13;
     android:src="img/avatar" /&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
 &#13;
  &lt;/android.support.v7.widget.CardView&gt; &#13;
 &#13;
&lt;/LinearLayout&gt; &#13;
</pre><p>You can use <code class="literal">CardViews</code> on devices that are running Android 2.1 (API level 7) and higher by adding the <code class="literal">v7 cardview</code> library to your project. If you're using Eclipse, you'll need to add this library to your project's <code class="literal">libs</code> directory, then select <strong>Build Path</strong>, followed by <strong>Add to Build Path</strong>. Android Studio users need to add this library as a dependency in their module-level <code class="literal">build.gradle</code> file:</p><pre class="programlisting">dependencies { &#13;
     compile &#13;
     'com.android.support:cardview-v7:21.0.+' &#13;
} &#13;
</pre><p>Adding a standard <code class="literal">CardView</code> to your layout is pretty straightforward, but if you want to customize Android's standard <code class="literal">CardView</code>, you can make the following changes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Change a card's corner radius using <code class="literal">cardView:cardCornerRadius</code>, for example, <code class="literal">card_view:cardCornerRadius="10dp"</code>. Alternatively, you can set the corner radius via your application code using the <code class="literal">cardView.setRadius</code> method.</li><li class="listitem" style="list-style-type: disc">Change a card's background color using <code class="literal">card_view:cardBackgroundColor</code>.</li><li class="listitem" style="list-style-type: disc">Give your card an elevation and create a shadow using <code class="literal">card_view:cardElevation</code>.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Lists and RecyclerView</h2></div></div></div><p>Lists give you a way of presenting related data types in a consistent, easy-to-read format.</p><p>A list consists of continuous columns and rows that serve as containers for tiles. You should prioritize your most important content within each tile; imagine you're designing an e-mail app where each e-mail is represented by a tile. Typically, each tile would display the sender's name and the subject heading in a larger font, as this is the most important information, and then you'd provide a preview of the e-mail's text in a smaller font.</p><p>A typical list tile contains the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Text</strong>: In a single list, each tile contains a single line of text. In a two-line list, each tile contains a maximum of two lines of text. If you need to display more than two lines of text, consider using a card instead. The amount of text can vary between tiles within the same list.</li><li class="listitem" style="list-style-type: disc"><strong>Primary actions</strong>: These are consistent throughout every tile in the list. In our e-mail example, the primary action might be <em>open e-mail</em>, and this primary action would appear on every tile within the list.</li><li class="listitem" style="list-style-type: disc"><strong>Optional supplemental actions</strong>: These usually take the form of icons or secondary text and should be placed on the right side of each tile.</li></ul></div><p>You create a list using the <code class="literal">RecylerView</code>, which is a container for displaying large data sets. <code class="literal">RecylerViews</code> offers improved performance over <code class="literal">ListViews</code>, as it recycles views directly. When item views are no longer visible to the user, <code class="literal">RecylerView</code> automatically replaces their contents with a different element from the data set, resulting in smoother scrolling.</p><p>
<code class="literal">RecylerView</code> also offers default animations for common operations, such as removing items from the list, and it provides layout managers to help you position the items within those lists.</p><p>
<code class="literal">RecyclerView</code> provides three built-in layout managers for you to choose from:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LinearLayoutManager</code> displays items in a horizontal or vertical scrolling list</li><li class="listitem" style="list-style-type: disc"><code class="literal">GridLayoutManager</code> displays items in a grid</li><li class="listitem" style="list-style-type: disc"><code class="literal">StaggeredGridLayoutManager</code> displays items in a staggered grid</li></ul></div><p>To use <code class="literal">RecylerView</code> in your project, you need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">RecyclerView </code>support library to your project's Gradle build file (<code class="literal">com.android.support:recyclerview-v7:23.1.0</code>).</li><li class="listitem">Define your data source.</li><li class="listitem">Add <code class="literal">RecylerView</code> to your layout file, like you'd add a regular view:<pre class="programlisting">        &lt;android.support.v7.widget.RecyclerView&#13;
        android:id="@+id/recylerview"&#13;
        android:layout_width="match_parent"&#13;
        android:layout_height="match_parent"&#13;
        android:scrollbars="vertical" /&gt; &#13;
</pre></li><li class="listitem">Specify the layout manager you want to use:<pre class="programlisting">        mLayoutManager = new LinearLayoutManager(this);&#13;
        mRecyclerView.setLayoutManager(mLayoutManager); &#13;
</pre></li><li class="listitem">Create an adapter. To use <code class="literal">RecylerView</code>, you need to create an adapter that extends the <code class="literal">RecylerView.Adapter</code> class:<pre class="programlisting">        public class MyRecyclerAdapter extends&#13;
        RecyclerView.Adapter&lt;MyRecyclerAdapter.ViewHolder&gt; { &#13;
</pre></li><li class="listitem">Create <code class="literal">ViewHolder</code>. The <code class="literal">RecyclerView</code> adapter relies on the <code class="literal">ViewHolder</code> object that stores references to all your views, so you don't need to use multiple <code class="literal">thefindViewById()</code> methods.<pre class="programlisting">        public class ViewHolder extends&#13;
        RecyclerView.ViewHolder { &#13;
</pre></li><li class="listitem">Assign the adapter to your <code class="literal">RecylerView</code>, via the <code class="literal">setAdapter</code> method.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Animations and transitions</h2></div></div></div><p>Two more key features of Material Design are new animations and transitions. When used correctly, these visual effects don't just look nice, they also serve two major purposes.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec26"/>Reinforcing the Material Design illusion</h3></div></div></div><p>A crucial aspect of Material Design is the sense that on-screen elements possess the same characteristics as physical objects, and animation is a powerful tool that can help you really drive this point home.</p><p>In the real world, the way objects move varies depending on their physical characteristics. By varying your animations, you can create the sense that different on-screen objects possess different physical characteristics. For example, you can suggest that an object is heavier than others by making it move more slowly. And if the user sees an object moving quickly and accelerating rapidly, they'll assume that the object is lighter.</p><p>Another fundamental aspect of Material Design is the illusion that all on-screen objects appear, disappear, and transform inside a continuous 3D space. One of the most powerful ways of making your app feel like a real, 3D environment is to create a visual continuity between your app's activities.</p><p>Traditionally, Android apps were designed as a sequence of screens, where each activity was a separate screen. Material Design seeks to blur these boundaries by using transitionsto ease the user from one activity to the next.</p><p>For example, when a new activity starts, the previous activity's elements might fade away, while elements from the new activity animate their way on screen. And if these two activities share common elements, you could animate these elements so that they appear to rearrange themselves into a new layout, which is actually an entirely new activity. In this way, you can create a more fluid and immersive user experience where users feel as though they're moving around inside your app's environment rather than switching from one screen to the next.</p><div><div><h3 class="title"><a id="tip34"/>Tip</h3><p>
<strong>Entrances and exits</strong></p><p>Put some thought into the way your objects enter and exit the screen, as these are ideal opportunities to strengthen the illusion of Material Design's continuous 3D environment. If an object enters the screen at a considerable pace, then the user will assume that this object has been traveling for some distance off screen, picking up speed along the way. If an object slows down as it exits the screen, the user will assume this object will come to a halt just off screen.</p><p>You should also look for opportunities to use these assumptions to your advantage. For example, if you have an object that you know will be making a reappearance, you could animate it so that it exits the screen at a crawl, and then edges its way back on screen when the time is right, giving the user the impression that this object has been hovering just off screen the entire time.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Providing the user with a visual feedback</h2></div></div></div><p>Whenever the user interacts with a UI element, your app should provide them with some form of visual confirmation that it's successfully registered their interaction.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>The most common user interaction is a touch event, so this is the type of event I'll be focusing on throughout this section. Just be aware that your app may need to handle other forms of user input, such as the user typing on a virtual keyboard or speaking commands into their device's microphone.</p></div></div><p>In Material Design, a touch ripple is the main mechanism that you'll use to provide the user with this visual confirmation.</p><p>A touch ripple effect is a particularly useful animation, as you can use it to communicate additional information about the touch event, such as the duration of the event, the amount of pressure applied, and where the touch event occurred (the touch ripple moves outward from the point of input).</p><p>You may also want to animate material so that it responds to user inputs, such as animating a photo so that it appears to lift slightly in response to the user long-pressing it.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec27"/>Animations – a word of warning</h3></div></div></div><p>Animations have the potential to be one of the most powerful or destructive tools at your disposal.</p><p>Our eyes are experts at detecting and tracking movement, but if multiple elements are moving at once, or moving in random patterns, then the user won't be able to keep up! Bad animation is far worse than no animation at all.</p><p>You should also avoid using time-consuming animations that serve no purpose other than to look pretty. Ideally, you should aim to catch your users off-guard with subtle, unexpected uses of animation that enhance their experience in some way, rather than simply using animation for the sake of it.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>The finishing touches</h2></div></div></div><p>Now that you've created a user interface with a Material Design look and feel and added some structural elements, such as floating action buttons and cards, it's time to put the finishing touches to your Material Design application.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec28"/>Designing your product icon</h3></div></div></div><p>Your product icon should communicate your app's identity while also indicating your app's purpose and core functionality.</p><div><div><h3 class="title"><a id="tip36"/>Tip</h3><p>
<strong>Building your brand</strong></p><p>If you're creating multiple apps, each product icon should be distinct, but you should also use each icon as an opportunity to create and reinforce a wider brand that spans all your Android offerings. Aim for some consistency across related product icons.</p></div></div><p>Product icons should reflect the same Material Design principles that we've explored throughout this chapter, so once again, you should take the physical qualities of paper and ink as your main inspiration. Your product icon should appear to be cut, folded, and illuminated exactly like other Material Design objects, but the real challenge is communicating all this information while also creating a product icon that's clean and simple.</p><p>Two particularly effective examples of Material Design icons are the Google Calendar and Gmail product icons. Both of these icons use simple shapes to create a sense of shadow, depth, and edges, while clearly communicating the app's main purpose and function.</p><p>Here is the Gmail icon:</p><p>
</p><div><img src="img/B05061_4_6.jpg" alt="Designing your product icon"/></div><p>
</p><p>And here's the Google Calendar icon:</p><p>
</p><div><img src="img/B05061_4_7.jpg" alt="Designing your product icon"/></div><p>
</p><p>To make designing your product icon easier, Material Design introduces the concept of <strong>product icon anatomy</strong>. These are standardized shapes that you can incorporate into your design to help promote a consistent look and feel across product icons. You can view these standardized shapes at 
<a class="ulink" href="https://www.google.com/design/spec/style/icons.html#icons-product-icons">https://www.google.com/design/spec/style/icons.html#icons-product-icons</a>
.</p><p>Each product icon should contain the same structural elements. These elements are always viewed straight from above, and each component is positioned at the top of the previous component:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Finish</strong>: This is a soft tint that you should use to highlight the top edge of all your product icon elements. You shouldn't apply this tint to your icon's left, right, or bottom elements.</li><li class="listitem" style="list-style-type: disc"><strong>Material background</strong>: This is a sheet of material that serves as your icon's background.</li><li class="listitem" style="list-style-type: disc"><strong>Material foreground</strong>: This is an element that's raised above the material background, and casts a shadow across that background.</li><li class="listitem" style="list-style-type: disc"><strong>Shadows</strong>: This is a soft shadow that appears around all the edges of a raised material element. This shadow should be slightly heavier along the product icon's right and bottom lines.</li></ul></div><div><div><h3 class="title"><a id="note37"/>Note</h3><p>
<strong>Creating the perfect product icon</strong></p><p>Although layering paper elements is effective for creating a sense of depth, be careful not to overcomplicate your app by adding lots of layers. You should aim for a product icon that has all the shadows, depth, and edges you'd expect from a physical object, but it should <em>still</em> deliver a simple and streamlined look.</p></div></div><p>You should supply your icon at 48dp with edges of 1dp.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec4"/>System icons</h4></div></div></div><p>In the previous section, we took an in-depth look at product icons, which are unique to your application, but what about system icons?</p><p>The good news is that the Android team has already given all the system icons a Material Design makeover. You should use these standard system icons unless you have a very, <em>very</em> good reason not to.</p><p>You can grab the entire pack from 
<a class="ulink" href="https://www.google.com/design/spec/style/icons.html#icons-system-icons">https://www.google.com/design/spec/style/icons.html#icons-system-icons</a>
.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec29"/>Typography and writing</h3></div></div></div><p>In this section, we'll look at everything you need to know about creating text that complies with Material Design principles, from general writing advice through to specific guidelines about how opaque your text should be.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec5"/>Typefaces</h4></div></div></div><p>As an Android developer, there are two main typefaces you need to know about:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Roboto</strong>: Since Android 4.0, Roboto has been the standard typeface for Android</li><li class="listitem" style="list-style-type: disc"><strong>Noto</strong>: Since the release of Android 2.2, Noto has been the standard typeface for all languages that are not covered by Roboto</li></ul></div><p>Material Design uses both of these typefaces.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec6"/>Text opacity</h4></div></div></div><p>You can give the user visual clues about how important each piece of text is using varying degrees of opacity.</p><p>The opacity levels you should use will vary depending on the color of your text and the color of your app's background. When you're adding light text to a dark background, you should use the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Primary text</strong>: 100% opacity</li><li class="listitem" style="list-style-type: disc"><strong>Secondary text</strong>: 70% opacity</li><li class="listitem" style="list-style-type: disc"><strong>Hint text, disabled text, and icons</strong>: 30% opacity</li></ul></div><p>When you're adding dark text to a light background, you should use the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Primary text</strong>: 87% opacity</li><li class="listitem" style="list-style-type: disc"><strong>Secondary text</strong>: 54% opacity</li><li class="listitem" style="list-style-type: disc"><strong>Hint text, disabled text, and icons</strong>: 38% opacity</li></ul></div><p>When adding text to your UI, check that the color of your background doesn't make your text difficult to read. Also, be aware that too much contrast can make your text equally tricky to read; ideally, your text should maintain a contrast ratio of 7:1.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec7"/>Writing guidelines</h4></div></div></div><p>Now that you know how your text should look on the screen, it's time to turn our attention to what your text is actually <em>saying</em>.</p><p>To make sure your user interface is as user-friendly as possible, you should create text that's as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Clear</strong>: Your users will appreciate simple, direct language that doesn't require repeat reading. Choose your words carefully, and look for the simplest way of conveying your message; for example, it's better to say <em>move onto question 2</em> rather than <em>navigate to question 2</em>.</li><li class="listitem" style="list-style-type: disc"><strong>Accessible</strong>: When writing your text, bear in mind that some people may be using your app in their second language. Even if you translate your app into other languages, culturally-specific phrases and slang may not survive the translation process. Your aim should be to write text that's accessible to <em>everyone</em>. On a related note, when you create string resources, it's generally a good idea to include detailed descriptions and perhaps even additional comments, so if your app does wind up getting translated, you stand a much greater chance of it being translated accurately.</li><li class="listitem" style="list-style-type: disc"><strong>Necessary</strong>: The whole idea of text is to help the user navigate and get value from your app, so whenever you're tempted to add text to your UI, ask yourself—<em>does the user really need to know this?</em> For example, if you create a screen that consists of a form and a <strong>Submit</strong> button, your users will probably know what's expected of them, without you having to add a <strong>Please complete the form and then press the Submit button</strong> disclaimer.</li><li class="listitem" style="list-style-type: disc"><strong>Concise</strong>: The text you do decide to include should be short, sweet, and to the point. In the interests of keeping text to a minimum, use contractions wherever possible (so that's <em>can't</em> instead of <em>can not</em>).</li><li class="listitem" style="list-style-type: disc"><strong>Lacks punctuation</strong>: Punctuation adds visual clutter, so you should omit punctuation wherever possible. In particular you should avoid exclamation marks. Every time you're tempted to add an exclamation point, ask yourself—<em>do I really want to shout this at the user?</em></li><li class="listitem" style="list-style-type: disc"><strong>In the present tense</strong>: Most UI events happen in the here and now, so you should write in the present tense unless you have a <em>really</em> good reason not to.</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Use active verbs</strong>: Make your writing more engaging by opting for active verbs over passive ones. The only exception is if the passive version is much shorter and simpler than the active version.</li><li class="listitem" style="list-style-type: disc"><strong>Write in the right tone:</strong> The <em>right</em> tone is friendly, respectful, and focused firmly on the user. You should address the user directly as <em>you</em>, and avoid the temptation of lumping yourself and the user together as <em>we</em>.</li></ul></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we looked at the core principles of Material Design, including creating a UI that has that distinctive Material Design look and feel, and we covered how to incorporate some of the new structural features into our application.</p><p>Over the course of the past few chapters, we've mainly focused on the technical aspects of creating a great user interface. In the next few chapters, we'll shift focus and look at how to capture the initial spark of inspiration via sketches, wireframes, and prototypes.</p></div></body></html>