- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control Flow
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was a teen, every month while I was learning BASIC programming on my
    Commodore Vic-20, I would read several of the early computer magazines, such as
    *Byte Magazine*. I remember one particular review for a game called *Zork*. While
    Zork was not a game that was available for my Vic-20, the concept of the game
    fascinated me because I was really into sci-fi and fantasy. I remember thinking
    how cool it would be to write a game like that, so I decided to figure out how
    to do it. One of the biggest concepts that I had to grasp at that time was how
    to control the flow of the application depending on the user's actions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What conditional statements are and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What loops are and how to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What control transfer statements are and how to use them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What have we learned so far?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have been laying the foundation for writing applications
    with Swift. While it is possible to write a very basic application with what we
    have learned so far, it would be difficult to write a useful application using
    only what we've covered in the first five chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Starting with this chapter, we will begin to move away from the foundations
    of the Swift language and begin to learn the building blocks of application development
    with Swift. In this chapter, we will go over control flow statements. To become
    a master of the Swift programming language, it is important that you fully understand
    and comprehend the concepts that are discussed in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Before we cover control flow and functions, let's take a look at how curly brackets
    and parentheses are used in Swift.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Curly brackets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, unlike other C-like languages, curly brackets are required for conditional
    statements and loops. In other C-like languages, if there is only one statement
    to execute for a conditional statement or a loop, curly brackets around that line
    are optional. This has led to numerous errors and bugs, such as Apple''s `goto
    fail` bug. When Apple was designing Swift, they decided to introduce the use of
    curly brackets, even when there was only one line of code to execute. Let''s take
    a look at some code that illustrates this requirement. This first example is not
    valid in Swift because it is missing the curly brackets; however, it will be valid
    in most other languages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Swift, you are required to have curly brackets as illustrated in the following
    example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parentheses
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike other C-like languages, the parentheses around conditional expressions
    in Swift are optional. In the preceding example, we put parentheses around the
    conditional expression, but they are not required. The following example will
    be valid in Swift, but not valid in most C-like languages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Control flow
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control flow, also known as the flow of control, refers to the order in which
    statements, instructions, and functions are executed within an application. Swift
    supports most of the familiar control flow statements that are used in C-like
    languages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: These include loops (such as `while`), conditional statements (including `if`,
    `switch`, and `guard`), and the transfer of control statements (including `break`
    and `continue`). It is worth noting that Swift does not include the traditional
    C `for` loop and, rather than the traditional `do-while` loop, Swift has the `repeat-while`
    loop.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the standard C control flow statements, Swift has also included
    statements such as the `for-in` loop and enhanced some of the existing statements,
    such as the `switch` statement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by looking at conditional statements in Swift.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A conditional statement checks a condition and executes a block of code only
    if the condition is `true`. Swift provides both the `if` and `if...else` conditional
    statements. Let's take a look at how to use these conditional statements to execute
    blocks of code if a specified condition is `true`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if` statement will check a conditional statement and, if it is `true`,
    it will execute the block of code. This statement takes the following format:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s take a look at how to use the `if` statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we begin by setting the `teamOneScore` and `teamTwoScore`
    constants. We then use the `if` statement to check whether the value of `teamOneScore`
    is greater than the value of `teamTwoScore`. If the value is greater, we print
    `Team One Won` to the console. When this code is run, we will indeed see that
    `Team One Won` is printed to the console, but if the value of `teamTwoScore` is
    greater than the value of `teamOneScore`, nothing will be printed. This is not
    the best way to write an application, as we want the user to know which team has
    actually won. The `if...else` statement can help us with this problem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Conditional code execution with the if...else statement
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if...else` statement checks a conditional statement and, if it is `true`,
    it executes a block of code. If the conditional statement is not `true`, it executes
    a separate block of code; this statement takes the following format:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s now modify the preceding example to use the `if...else` statement to
    tell the user which team has won:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This new version will print out `Team One Won` if the value of `teamOneScore`
    is greater than the value of `teamTwoScore`; otherwise, it will print out the
    message, `Team Two Won`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: This fixes one problem with our code, but what do you think the code will do
    if the value of `teamOneScore` is equal to the value of `teamTwoScore`? In the
    real world, we would see a tie, but in the preceding code, we would print out
    `Team Two Won`, which would not be fair to team one. In cases like this, we can
    use multiple `else if` statements and an `else` statement at the end to act as
    the default path if no conditional statements are met.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'This is illustrated in the following code sample:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, if the value of `teamOneScore` is greater than the value
    of `teamTwoScore`, we print `Team One Won` to the console. We then have an `else
    if` statement, which means that the conditional statement is only checked if the
    first `if` statement returns `false`. Finally, if both of the `if` statements
    return `false`, the code in the `else` block is called and `We have a tie` is
    printed to the console.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: This is a good time to point out that it is not good practice to have numerous
    `else if` statements stacked up, as demonstrated in the previous example. It is
    better to use the `switch` statement, which we will explore later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The guard statement
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Swift, and most modern languages, our conditional statements tend to focus
    on testing whether a condition is `true`. As an example, the following code tests
    whether the `x` variable is greater than `10` and, if so, then we perform some
    kind of function. If the condition is `false`, we handle the following error condition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This type of code embeds our functional code within our checks and tucks the
    error conditions away at the end of our functions, but what if that is not what
    we really want? Sometimes (actually a lot of times), it might be better to take
    care of our error conditions at the beginning of the function. In our simple example,
    we can easily check whether `x` is less than or equal to `10` and, if so, then
    we perform the error condition. Not all conditional statements are that easy to
    rewrite, especially items such as optional binding.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, we have the `guard` statement. This statement focuses on performing
    a function if a condition is `false`; this allows us to trap errors and perform
    the error conditions early in our functions. We can rewrite our previous example
    using the `guard` statement, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this new example, we check to see whether the `x` variable is greater than
    `10`, and if not, we perform the error condition. If the variable is greater than
    `10`, the application continues to the functional part of our code. You will notice
    that we have a `return` statement embedded within the guard condition. The code
    within the `guard` statement must contain a transfer of control statement; this
    is what prevents the rest of the code from executing. If we forget the transfer
    of control statement, Swift will show a compile-time error. We will look at transfer
    of control statements a little later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some more examples of the `guard` statement. The following
    example shows how we can use the `guard` statement to verify that an optional
    contains a valid value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Functions have not been covered yet but they will be covered in *Chapter 7*,
    *Functions*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create a function named `guardFunction()` that accepts an
    optional that contains a string or `nil` value. We then use the `guard` statement
    with optional binding to verify that the string optional is not `nil`. If it does
    contain nil, then the code within the `guard` statement is executed and the `return`
    statement is used to exit the function. The great thing about using the `guard`
    statement with optional binding is that the new variable is within the scope of
    the rest of the function, rather than just within the scope of the optional binding
    statement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: A conditional statement checks the condition once and, if the condition is met,
    it executes the block of code. However, what if we wanted to continuously execute
    the block of code until a condition is met? For this, we use loop statements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` statement takes a value, compares it to several possible matches,
    and executes the appropriate block of code based on the first successful match.
    The `switch` statement is an alternative to using multiple `else if` statements
    when there could be several possible matches. The `switch` statement takes the
    following format:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unlike most other languages, in Swift, the `switch` statement does not fall
    through to the next `case` statement; therefore, we do not need to use a `break`
    statement to prevent this fall-through. This is another safety feature that has
    been built into Swift, as one of the most common programming mistakes regarding
    the `switch` statement made by beginner programmers is to forget the `break` statement
    at the end of the `case` statement. Let''s take a look at how to use the `switch`
    statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, the `switch` statement took the value of the `speed`
    variable and compared it to the two `case` statements. If the value of `speed`
    matches either case, the code prints the speed. If it does not find a match, it
    prints the `Unknown speed` message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `switch` statement must have a match for all the possible values. This
    means that, unless we are matching against an enumeration that has a defined number
    of values, each `switch` statement must have a `default` case. Let''s take a look
    at a case where we do not have a `default` case:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we put the preceding code into a Playground and attempt to compile the code,
    we will receive a `Switch must be exhaustive` error. This is a compile-time error,
    and therefore, we will not be notified until we attempt to compile the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to include multiple items in a single case. To do this, we need
    to separate the items with a comma. Let''s take a look at how we use the `switch`
    statement to tell us whether a character is a vowel or a consonant:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see in the preceding example that each case has multiple items. Commas
    separate these items and the `switch` statement attempts to match the `char` variable
    to each item listed in the `case` statements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to check the value of a `switch` statement to see whether
    it is included in a range. To do this, we use one of the range operators in the
    `case` statement, as shown in the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, the `switch` statement took the `grade` variable,
    compared it with the ranges in each `case` statement, and printed out the appropriate
    grade.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, any `case` statement can contain an optional `where` clause, which
    provides an additional condition that needs validating. Let''s say that, in our
    preceding example, we have students who are receiving special assistance in class
    and we wanted to define a grade of `D` for them as a range from 55 to 69\. The
    following example shows how we can do this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One thing to bear in mind with the `where` expression is that Swift will attempt
    to match the value, starting with the first `case` statement and working its way
    down, checking each `case` statement in order. This means that, if we put the
    `case` statement with the `where` expression after the grade `F` `case` statement,
    then the `case` statement with the `where` expression will never be reached. This
    is illustrated in the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you are using the `where` clause, a good rule of thumb is to always put the
    `case` statements with the `where` clause before any similar `case` statements
    withou the `where` clause.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`sSwitch` statements are also extremely useful for evaluating enumerations.
    Since an enumeration has a finite number of values, if we provide a `case` statement
    for all the values in the enumeration, we would not need to provide a `default`
    case. The following example demonstrates how we can use a `switch` statement to
    evaluate an enumeration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we began by defining an enumeration named `Product` with two
    values, each with associated values. We then created an `order` variable of `Product`
    type and used the `switch` statement to evaluate it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a `switch` statement with enumerations, we must have a `case` statement
    for all possible values or a default statement. Let''s take a look at some additional
    code that illustrates this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this sample code, we have a `case` statement that handles each planet in
    the `Planets` enumeration. We can also add a `default` statement to handle any
    additional planets if they are added in later. However, it is recommended that
    if a `switch` statement uses a `default` case with an enumeration, then we should
    use the `@unknown` attribute, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will always throw a warning to remind us that if we add a new planet to
    the `Planet` enumeration, then we need to handle that new planet in this part
    of the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 5*, *Using Swift Collections*, we briefly covered the Diff algorithm.
    At that time we mentioned that we couldn''t see the power of this algorithm until
    we understood the `switch` statement. Now that we understand the `switch` statement,
    let''s see what we can do with this algorithm:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we start by creating two arrays of strings that each
    contain a list of cities. We then run the `difference(from:)` method, which we
    covered in the previous chapter. The `difference(from:)` method returns a collection
    containing instances of the `Change` enumeration. The `Change` enumeration is
    defined like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This enumeration contains two possible values. The `insert` value tells us
    if we need to insert a value because the array is missing an element from the
    other array. The `remove` value tells us we need to remove an element because
    the array has an element that is not in the other array. In our code, we are handling
    both the `insert` and `remove` values, which means that after the code is executed,
    the `cities2` array will have the same elements and in the same order as the `cities1`
    array. This isn''t too exciting but let''s say that we want to `remove` any elements
    from the `cities2` array that do not appear in the `cities1` array. We could change
    our code to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When this code is executed, the `cities2` array would contain the three elements
    of `London`, `Paris`, and `Boston`. If we just handled the insert conditions then
    the `cities2` array would contain any elements that were part of either array.
    sSwitch on tuples
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `switch` statement with tuples; let''s take a look at how
    to do this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this code, we created a tuple named `myDog` that contained the name of my
    dog and her age. We then used the `switch` statement to match the name (the first
    element of the tuple) and a `let` statement to retrieve the age. In this example,
    the message, `Maple is my dog and is 4`, will be printed to the screen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the underscore (wildcard) and range operators with tuples in
    the `case` statement, as shown in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the underscore will match any name, while the range operators
    will look for the age of the dog. In this example, since Maple is four years old,
    the message `Your dog is middle aged` will be printed on the screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Match on wildcard
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Swift, we can also combine the underscore (wildcard) with the `where` statement.
    This is illustrated in the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we create an integer variable named `myNumber` and use the
    `switch` statement to determine whether the value of the variable is a multiple
    of 2 or 3\. Notice the `case` statement is proceeded by an underscore followed
    by the `where` statement. The underscore will match all the values of the variable,
    and then the `where` statement is called to see if the item we are switching on
    matches the rule defined within it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loop statements enable us to continuously execute a block of code until a condition
    is met. They also enable us to iterate over elements of a collection. Let's look
    at how we would use the `for-in` loop to iterate over the elements of a collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The for-in loop
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Swift does not offer the standard C-based `for` loop, it does have the
    `for-in` loop. The standard C-based `for` loop was removed from the Swift language
    in Swift 3 because it was rarely used. You can read the full proposal to remove
    this loop on the Swift evolution site at [https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md).
    The `for-in` statement is used to execute a block of code for each item in a range,
    collection, or sequence.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Using the for-in loop
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for-in` loop iterates over a collection of items or a range of numbers,
    and executes a block of code for each item in the collection or range. The format
    for the `for-in` statement is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we can see in the preceding code, the `for-in` loop has twos:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`variable`: This variable will change each time the loop executes and will
    hold the current item from the collection or range'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collection/range`: This is the collection or range to iterate through'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to use the `for-in` loop to iterate through a range
    of numbers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, we iterated over a range of numbers from 1 to 5 and
    printed each of the numbers to the console. This loop used the closed range operator
    (`...`) to give the loop a range to iterate through. Swift also provides the half-open
    range operator (`..>`) and the one-sided range operators that we saw in the previous
    chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how to iterate over an array with the `for-in` loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, we iterated through the `countries` array and printed
    each element of the array to the console. As you can see, iterating through an
    array with the `for-in` loop is safer, cleaner, and a lot easier than using the
    standard C-based `for` loop. Using the `for-in` loop prevents us from making common
    mistakes, such as using the less than or equal to (`<=`) operator rather than
    the less than (`<`) operator in our conditional statement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to iterate over a dictionary with the `for-in` loop:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we used the `for-in` loop to iterate through each
    key-value pair of the dictionary. In this example, each item in the dictionary
    is returned as a (`key`,`value`) tuple. We can decompose (`key`,`value`) tuple
    members as named constants within the body of the loop. One thing to note is that
    since a dictionary does not guarantee the order that items are stored in, the
    order that they are iterated through may not be the same as the order in which
    they were inserted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at another type of loop, the `while` loop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `while` loop executes a block of code until a condition is met. Swift provides
    two forms of the `while` loop; these are the `while` and `repeat-while` loops.
    In Swift 2.0, Apple replaced the `do-while` loop with the `repeat-while` loop.
    The `repeat-while` loop functions in the same way as the `do-while` loop did.
    Swift uses the `do` statement for error handling. A `while` loop is used when
    you want to run a loop zero or more times, while a `repeat-while` loop is used
    when you want to run the loop one or more times.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We use `while` loops when the number of iterations to be performed is not known
    and is usually dependent on some business logic. This could be something like
    looping through a collection until a certain value is found or a condition is
    met.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Using the while loop
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop starts by evaluating a conditional statement and then repeatedly
    executes a block of code while the conditional statement is `true`. The format
    for the `while` statement is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s take a look at how to use a `while` loop. In the following example,
    the `while` loop will continue to execute the block of code while the randomly-generated
    number is less than 7\. In this example, we are using the `Int.random()` function
    to generate a random number between 0 and 9:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we began by initializing the `ran` variable to `0`.
    The `while` loop then checks this variable and, if the value is less than 7, a
    new random number between 0 and 19 is generated. The `while` loop will continue
    to loop while the randomly-generated number is less than 7\. Once the randomly-generated
    number is equal to or greater than 7, the loop will exit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `while` loop checked the conditional statement
    prior to generating a new random number. But what if we don't want to check the
    conditional statement prior to generating a random number? We could generate a
    random number when we first initialize the variable, but that means we need to
    duplicate the code that generates the random numbers, and duplicating code is
    never an ideal solution. It is preferable to use the `repeat-while` loop instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Using the repeat-while loop
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between the `while` and `repat-while` loops is that the `while`
    loop checks the conditional statement prior to executing the block of code for
    the first time; therefore, all the variables in the conditional statements need
    to be initialized prior to executing the `while` loop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The `repeat-while` loop will run through the loop block prior to checking the
    conditional statement for the first time. This means that we can initialize the
    variables in the conditional block of code. The use of the `repeat-while` loop
    is preferred when the conditional statement is dependent on the code in the loop
    block. The `repeat-while` loop takes the following format:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s look at this specific example by creating a `repeat-while` loop where
    we initialize the variable that we are checking within the loop block:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, we defined the `ran` variable as an integer; however,
    we did not initialize it until we entered the loop block and generated a random
    number. If this is attempted with the `while` loop (leaving the `ran` variable
    uninitialized), we will receive the `variable used before b`eing initializedexception.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we mentioned that the `switch` statement is preferred over using multiple
    `else if` blocks. Let's see how we can use the `switch` statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Using case and where statements with conditional statements and loops
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw with `switch` statements, the `case` and `where` statements within
    a `switch` statement can be very powerful. Using `case` and `where` statements
    within our conditional statements can also make our code much smaller and easier
    to read. Conditional statements and loops, such as `if`, `for`, and `while`, can
    also make use of the `where` and `case` keywords. Let's take a look at some examples,
    starting off with using the `where` statement to filter the results in a `for-in`
    loop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with the where statement
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we take an array of integers and print out only multiples
    of 3\. However, before we look at how to filter the results with the `where` statement,
    let''s take a look at how to do this without the `where` statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, we use a `for-in` loop to cycle through the numbers 1 to 30\.
    Within the `for-in` loop, we use an `if` conditional statement to filter out multiples
    of 3\. In this simple example, the code is relatively easy to read, but let''s
    examine how we can use the `where` statement to use fewer lines of code and make
    them easier to read:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We still have the same `for-in` loop as in the previous example. However, we
    have now put the `where` statement at the end; therefore, we only loop through
    numbers that are multiples of 3\. Using the `where` statement shortens our example
    by two lines and makes it easier to read, because the `where` clause is on the
    same line as the `for-in` loop, rather than being embedded in the loop itself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how we could filter with the `for-case` statement.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with the for-case statement
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this next example, we will use the `for-case` statement to filter through
    an array of tuples and print out only the results that match our criteria. The
    `for-case` example is very similar to using the `where` statement where it is
    designed to eliminate the need for an `if` statement within a loop to filter the
    results. In this example, we will use the `for-case` statement to filter through
    a list of World Series winners and print out the year(s) that a particular team
    won the World Series:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we created an array of tuples named `worldSeriesWinners`, where
    each tuple in the array contained the name of the team and the year that they
    won the World Series. We then use the `for-case` statement to filter through the
    array and only print out the years that the Red Sox won the World Series. The
    filtering is done within the `case` statement, where `("Red Sox", year)` states
    that we want all the results that have the `Red Sox` string in the first item
    of the tuple, and the value of the second item in the `year` constant. The `for-in`
    loop then loops through the results of the `case` statement, printing out the
    value of the `year` constant.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for-case-in` statement also makes it very easy to filter out the `nil`
    values in an array of optionals; let''s look at an example of this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this example, we created an array of optionals named `myNumbers` that could
    contain either an integer value or `nil`. As we saw in *Chapter 4*, *Optional
    Types*, an optional is internally defined as an enumeration, as shown in the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If an optional is set to `nil`, it will have a value of `none`, but if it is
    not `nil`, it will have a value of `some`, with an associated type of the actual
    value. In our example, when we filter for `.some(num)`, we are looking for any
    optional that has a non-nil value. As a shorthand for `.some()`, we could use
    the question mark (`?`) symbol, as we will see in the following example. This
    example also combines the `for-case-in` statement with a `where` statement to
    perform additional filtering:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This example is the same as the previous example, except that we have put the
    additional filtering in the `where` statement. In the previous example, we looped
    through all of the non-nil values; however, in this example, we have looped through
    the non-nil values that are greater than 3\. Let''s examine how we can do this
    same filtering without the `case` or `where` statements:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using the `for-case-in` and `where` statements can greatly reduce the number
    of lines that are needed. It also makes our code much easier to read because all
    the filtering statements are on the same line.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at one more filtering example. This time, we will look at
    the `if-case` statement.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Using the if-case statement
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `if-case` statement is very similar to using the `switch` statement.
    Most of the time, the `switch` statement is preferred when we have over two cases
    that we are trying to match, but there are instances where the `if-case` statement
    is needed. One of those times is when we are only looking for one or two possible
    matches, and we do not want to handle all the possible matches; let''s take a
    look at an example of this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this example, we created an enumeration named `Identifier` that contains
    three possible values: `Name`, `Number`, and `NoIdentifier`. We then created an
    instance of the `Identifier` enumeration named `playerIdentifier`, with a value
    of `Number` and an associated value of `2`. We then used the `if-case` statement
    to see if the `playerIdentifier` had a value for `Number` and if so, we printed
    a message to the console.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `for-case` statement, we can perform additional filtering with
    the `where` statement. The following example uses the same `Identifier` enumeration
    that we used in the previous example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we have used the `if-case` statement to see whether the `playerIdentifier`
    had a value of `Number`, but we also added the `where` statement to see if the
    associated value was equal to `2`. If so, we identified the player as either `XanderBogarts`
    or `Derek` `Jeter`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in our examples, using the `case` and `where` statements with our
    conditional statements can reduce the number of lines that are needed to perform
    certain types of filtering. It can also make our code easier to read. Now let's
    take a look at control transfer statements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Control transfer statements
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control transfer statements are used to transfer control to another part of
    the code. Swift offers six control transfer statements; these are `continue`,
    `break`, `fallthrough`, `guard`, `throws`, and `return`. We will look at the `return`
    statement in *Chapter 7*, *Functions*,and will discuss the `throws` statement
    in *Chapter 12*, *Availability and Error Handling*. The remaining control transfer
    statements will be discussed in this section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `continue` statement tells a loop to stop executing the code block and
    to go to the next iteration of the loop. The following example shows how we can
    use this statement to print out only the odd numbers in a range:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding example, we looped through a range from 1 to 10\. For each
    iteration of the `for-in` loop, we used the remainder (`%`) operator to see whether
    the number was odd or even. If the number is even, the `continue` statement tells
    the loop to immediately go to the next iteration of the loop. If the number is
    odd, we print that the number is odd and then move on. The output of the preceding
    code is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now let's take a look at the `break` statement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The break statement
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `break` statement immediately ends the execution of a code block within
    the control flow. The following example demonstrates how to break out of a `for-in`
    loop when we encounter the first even number:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding example, we loop through the range from 1 to 10\. For each
    iteration of the `for-in` loop, we use the remainder (`%`) operator to see whether
    the number is odd or even. If the number is even, we use the `break` statement
    to immediately exit the loop. If the number is odd, we print out that the number
    is odd, and then go to the next iteration of the loop. The preceding code has
    the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们遍历从1到10的范围。对于`for-in`循环的每次迭代，我们使用取余（`%`）运算符来判断数字是奇数还是偶数。如果数字是偶数，我们使用`break`语句立即退出循环。如果数字是奇数，我们打印出该数字是奇数，然后进入循环的下一个迭代。前面的代码有以下输出：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The fallthrough statement
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跌落语句
- en: In Swift, the `switch` statement does not fall through like other languages;
    however, we can use the `fallthrough` statement to force them to fall through.
    The `fallthrough` statement can be very dangerous because, once a match is found,
    the next case defaults to `true` and that code block is executed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，`switch`语句不像其他语言那样会跌落；然而，我们可以使用`fallthrough`语句来强制它们跌落。`fallthrough`语句可能非常危险，因为一旦找到匹配项，下一个情况将默认为`true`，并且执行那个代码块。
- en: 'This is illustrated in the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下示例中得到了说明：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When this code is run, the following results are printed to the console:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，以下结果将打印到控制台：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I recommend that you be very careful about using the `fallthrough` statement.
    Apple purposely disabled falling through on the `case` statement to avoid the
    common errors that programmers make. By using the `fallthrough` statement, you
    could introduce these errors back into your code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在使用`fallthrough`语句时要非常小心。苹果公司故意禁用了`case`语句的跌落，以避免程序员常见的错误。通过使用`fallthrough`语句，您可能会将这些错误重新引入到您的代码中。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered control flow and functions in Swift. It is essential
    that you understand the concepts in this chapter before moving ahead. Every application
    that we write, beyond the simple Hello World applications, will rely very heavily
    on control flow statements and functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Swift中的控制流和函数。在继续前进之前，理解本章中的概念是至关重要的。我们编写的每个应用程序，除了简单的Hello World应用程序之外，都将非常依赖控制流语句和函数。
- en: Control flow statements are used to make decisions within our application, and
    functions, which we will be discussing in the next chapter, are used to group
    our code into sections that are reusable and organized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流语句用于在我们应用程序中做出决策，并且函数，我们将在下一章讨论，用于将我们的代码分组到可重用和有组织的部分。
