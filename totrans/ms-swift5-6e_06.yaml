- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Control Flow
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程
- en: When I was a teen, every month while I was learning BASIC programming on my
    Commodore Vic-20, I would read several of the early computer magazines, such as
    *Byte Magazine*. I remember one particular review for a game called *Zork*. While
    Zork was not a game that was available for my Vic-20, the concept of the game
    fascinated me because I was really into sci-fi and fantasy. I remember thinking
    how cool it would be to write a game like that, so I decided to figure out how
    to do it. One of the biggest concepts that I had to grasp at that time was how
    to control the flow of the application depending on the user's actions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我还是个青少年时，每个月在我用 Commodore Vic-20 学习 BASIC 编程的时候，我都会阅读几本早期的计算机杂志，比如 *Byte Magazine*。我记得有一篇关于一款名为
    *Zork* 的游戏的评论。虽然 Zork 并不是为我的 Vic-20 可用的游戏，但这个游戏的概念深深吸引了我，因为我真的很喜欢科幻和奇幻。我记得在想，写一个那样的游戏会多么酷，所以我决定找出如何做到这一点。当时我必须掌握的最大概念之一就是如何根据用户的操作来控制应用程序的流程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What conditional statements are and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句是什么以及如何使用它们
- en: What loops are and how to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环是什么以及如何使用它们
- en: What control transfer statements are and how to use them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制转移语句是什么以及如何使用它们
- en: What have we learned so far?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们到目前为止学到了什么？
- en: Up to this point, we have been laying the foundation for writing applications
    with Swift. While it is possible to write a very basic application with what we
    have learned so far, it would be difficult to write a useful application using
    only what we've covered in the first five chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在为使用 Swift 编写应用程序打下基础。虽然我们可以用我们目前学到的东西编写一个非常基础的程序，但仅使用我们前五章所涵盖的内容来编写一个有用的应用程序将会很困难。
- en: Starting with this chapter, we will begin to move away from the foundations
    of the Swift language and begin to learn the building blocks of application development
    with Swift. In this chapter, we will go over control flow statements. To become
    a master of the Swift programming language, it is important that you fully understand
    and comprehend the concepts that are discussed in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将开始从 Swift 语言的根基中走出来，开始学习使用 Swift 进行应用程序开发的构建块。在本章中，我们将讨论控制流程语句。要成为
    Swift 编程语言的专家，理解本章中讨论的概念至关重要。
- en: Before we cover control flow and functions, let's take a look at how curly brackets
    and parentheses are used in Swift.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论控制流程和函数之前，让我们看看在 Swift 中括号和括号是如何使用的。
- en: Curly brackets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号
- en: 'In Swift, unlike other C-like languages, curly brackets are required for conditional
    statements and loops. In other C-like languages, if there is only one statement
    to execute for a conditional statement or a loop, curly brackets around that line
    are optional. This has led to numerous errors and bugs, such as Apple''s `goto
    fail` bug. When Apple was designing Swift, they decided to introduce the use of
    curly brackets, even when there was only one line of code to execute. Let''s take
    a look at some code that illustrates this requirement. This first example is not
    valid in Swift because it is missing the curly brackets; however, it will be valid
    in most other languages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，与其它 C 类语言不同，条件语句和循环需要使用括号。在其它 C 类语言中，如果条件语句或循环只有一个要执行的语句，那么围绕该行的括号是可选的。这导致了无数的错误和漏洞，比如苹果的
    `goto fail` 漏洞。当苹果设计 Swift 时，他们决定引入括号的使用，即使只有一行代码要执行也是如此。让我们看看一些说明这一要求的代码示例。第一个示例在
    Swift 中是无效的，因为它缺少括号；然而，它将在大多数其它语言中是有效的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Swift, you are required to have curly brackets as illustrated in the following
    example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你需要像以下示例中那样使用括号：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parentheses
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号
- en: 'Unlike other C-like languages, the parentheses around conditional expressions
    in Swift are optional. In the preceding example, we put parentheses around the
    conditional expression, but they are not required. The following example will
    be valid in Swift, but not valid in most C-like languages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其它 C 类语言不同，Swift 中条件表达式的括号是可选的。在上面的示例中，我们围绕条件表达式使用了括号，但它们不是必需的。以下示例在 Swift
    中是有效的，但在大多数 C 类语言中则不是：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Control flow
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程
- en: Control flow, also known as the flow of control, refers to the order in which
    statements, instructions, and functions are executed within an application. Swift
    supports most of the familiar control flow statements that are used in C-like
    languages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流，也称为控制流程，指的是在应用程序中语句、指令和函数执行的顺序。Swift 支持大多数在 C 类语言中使用的熟悉控制流语句。
- en: These include loops (such as `while`), conditional statements (including `if`,
    `switch`, and `guard`), and the transfer of control statements (including `break`
    and `continue`). It is worth noting that Swift does not include the traditional
    C `for` loop and, rather than the traditional `do-while` loop, Swift has the `repeat-while`
    loop.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括循环（如 `while`）、条件语句（包括 `if`、`switch` 和 `guard`）以及控制转移语句（包括 `break` 和 `continue`）。值得注意的是，Swift
    不包括传统的 C `for` 循环，而不是传统的 `do-while` 循环，Swift 有 `repeat-while` 循环。
- en: In addition to the standard C control flow statements, Swift has also included
    statements such as the `for-in` loop and enhanced some of the existing statements,
    such as the `switch` statement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的 C 控制流语句外，Swift 还包括 `for-in` 循环等语句，并增强了一些现有语句，例如 `switch` 语句。
- en: Let's begin by looking at conditional statements in Swift.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 Swift 中的条件语句开始。
- en: Conditional statements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: A conditional statement checks a condition and executes a block of code only
    if the condition is `true`. Swift provides both the `if` and `if...else` conditional
    statements. Let's take a look at how to use these conditional statements to execute
    blocks of code if a specified condition is `true`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句检查一个条件，并且只有当条件为 `true` 时才执行代码块。Swift 提供了 `if` 和 `if...else` 条件语句。让我们看看如何使用这些条件语句在指定的条件为
    `true` 时执行代码块。
- en: The if statement
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: 'The `if` statement will check a conditional statement and, if it is `true`,
    it will execute the block of code. This statement takes the following format:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句会检查一个条件语句，如果它是 `true`，它将执行代码块。这个语句采用以下格式：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s take a look at how to use the `if` statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `if` 语句：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we begin by setting the `teamOneScore` and `teamTwoScore`
    constants. We then use the `if` statement to check whether the value of `teamOneScore`
    is greater than the value of `teamTwoScore`. If the value is greater, we print
    `Team One Won` to the console. When this code is run, we will indeed see that
    `Team One Won` is printed to the console, but if the value of `teamTwoScore` is
    greater than the value of `teamOneScore`, nothing will be printed. This is not
    the best way to write an application, as we want the user to know which team has
    actually won. The `if...else` statement can help us with this problem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先设置了 `teamOneScore` 和 `teamTwoScore` 常量。然后我们使用 `if` 语句来检查 `teamOneScore`
    的值是否大于 `teamTwoScore` 的值。如果值更大，我们将 `Team One Won` 打印到控制台。当运行此代码时，我们确实会看到 `Team
    One Won` 被打印到控制台，但如果 `teamTwoScore` 的值大于 `teamOneScore` 的值，则不会打印任何内容。这不是编写应用程序的最佳方式，因为我们希望用户知道哪个队伍实际上赢得了比赛。`if...else`
    语句可以帮助我们解决这个问题。
- en: Conditional code execution with the if...else statement
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `if...else` 语句进行条件代码执行
- en: 'The `if...else` statement checks a conditional statement and, if it is `true`,
    it executes a block of code. If the conditional statement is not `true`, it executes
    a separate block of code; this statement takes the following format:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else` 语句检查一个条件语句，如果它是 `true`，它将执行一个代码块。如果条件语句不是 `true`，它将执行一个单独的代码块；这个语句采用以下格式：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s now modify the preceding example to use the `if...else` statement to
    tell the user which team has won:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们修改前面的例子，使用 `if...else` 语句来告诉用户哪个队伍赢得了比赛：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This new version will print out `Team One Won` if the value of `teamOneScore`
    is greater than the value of `teamTwoScore`; otherwise, it will print out the
    message, `Team Two Won`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本将打印出 `Team One Won`（队伍一获胜），如果 `teamOneScore` 的值大于 `teamTwoScore` 的值；否则，它将打印出消息，`Team
    Two Won`（队伍二获胜）。
- en: This fixes one problem with our code, but what do you think the code will do
    if the value of `teamOneScore` is equal to the value of `teamTwoScore`? In the
    real world, we would see a tie, but in the preceding code, we would print out
    `Team Two Won`, which would not be fair to team one. In cases like this, we can
    use multiple `else if` statements and an `else` statement at the end to act as
    the default path if no conditional statements are met.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们代码中的一个问题，但如果你认为`teamOneScore`的值等于`teamTwoScore`的值时，代码会做什么呢？在现实世界中，我们会看到一场平局，但在前面的代码中，我们会打印出`Team
    Two Won`，这对第一队来说是不公平的。在这种情况下，我们可以使用多个`else if`语句和一个最后的`else`语句来作为没有满足任何条件时的默认路径。
- en: 'This is illustrated in the following code sample:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码示例中得到了说明：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, if the value of `teamOneScore` is greater than the value
    of `teamTwoScore`, we print `Team One Won` to the console. We then have an `else
    if` statement, which means that the conditional statement is only checked if the
    first `if` statement returns `false`. Finally, if both of the `if` statements
    return `false`, the code in the `else` block is called and `We have a tie` is
    printed to the console.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果`teamOneScore`的值大于`teamTwoScore`的值，我们将`Team One Won`打印到控制台。然后我们有一个`else
    if`语句，这意味着只有当第一个`if`语句返回`false`时，才会检查条件语句。最后，如果两个`if`语句都返回`false`，则调用`else`块中的代码，并将`We
    have a tie`打印到控制台。
- en: This is a good time to point out that it is not good practice to have numerous
    `else if` statements stacked up, as demonstrated in the previous example. It is
    better to use the `switch` statement, which we will explore later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是指出这一点的好时机，即像前一个例子中那样堆叠多个`else if`语句并不是一个好的实践。更好的做法是使用`switch`语句，我们将在本章后面探讨这一点。
- en: The guard statement
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守卫语句
- en: 'In Swift, and most modern languages, our conditional statements tend to focus
    on testing whether a condition is `true`. As an example, the following code tests
    whether the `x` variable is greater than `10` and, if so, then we perform some
    kind of function. If the condition is `false`, we handle the following error condition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift以及大多数现代语言中，我们的条件语句往往侧重于测试一个条件是否为`true`。例如，以下代码测试`x`变量是否大于`10`，如果是，则执行某种功能。如果条件为`false`，我们处理以下错误条件：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This type of code embeds our functional code within our checks and tucks the
    error conditions away at the end of our functions, but what if that is not what
    we really want? Sometimes (actually a lot of times), it might be better to take
    care of our error conditions at the beginning of the function. In our simple example,
    we can easily check whether `x` is less than or equal to `10` and, if so, then
    we perform the error condition. Not all conditional statements are that easy to
    rewrite, especially items such as optional binding.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代码将我们的功能代码嵌入到我们的检查中，并将错误条件藏在函数的末尾，但如果我们真的不希望这样呢？有时（实际上很多次），在函数的开始处处理错误条件可能更好。在我们的简单例子中，我们可以轻松检查`x`是否小于或等于`10`，如果是，则执行错误条件。并不是所有的条件语句都那么容易重写，特别是像可选绑定这样的项目。
- en: 'In Swift, we have the `guard` statement. This statement focuses on performing
    a function if a condition is `false`; this allows us to trap errors and perform
    the error conditions early in our functions. We can rewrite our previous example
    using the `guard` statement, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，我们有`guard`语句。这个语句专注于在条件为`false`时执行一个功能；这允许我们在函数的早期捕获错误并执行错误条件。我们可以使用`guard`语句重写先前的例子，如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this new example, we check to see whether the `x` variable is greater than
    `10`, and if not, we perform the error condition. If the variable is greater than
    `10`, the application continues to the functional part of our code. You will notice
    that we have a `return` statement embedded within the guard condition. The code
    within the `guard` statement must contain a transfer of control statement; this
    is what prevents the rest of the code from executing. If we forget the transfer
    of control statement, Swift will show a compile-time error. We will look at transfer
    of control statements a little later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新例子中，我们检查`x`变量是否大于`10`，如果不是，我们执行错误条件。如果变量大于`10`，应用程序将继续执行我们代码的功能部分。你会注意到我们在守卫条件中嵌入了一个`return`语句。守卫语句中的代码必须包含一个控制转移语句；这就是防止其余代码执行的原因。如果我们忘记了控制转移语句，Swift会在编译时显示错误。我们将在本章稍后讨论控制转移语句。
- en: 'Let''s take a look at some more examples of the `guard` statement. The following
    example shows how we can use the `guard` statement to verify that an optional
    contains a valid value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`guard`语句的一些更多示例。以下示例展示了我们如何使用`guard`语句来验证一个可选值是否包含有效值：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Functions have not been covered yet but they will be covered in *Chapter 7*,
    *Functions*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数尚未介绍，但将在*第7章*，*函数*中介绍。
- en: In this example, we create a function named `guardFunction()` that accepts an
    optional that contains a string or `nil` value. We then use the `guard` statement
    with optional binding to verify that the string optional is not `nil`. If it does
    contain nil, then the code within the `guard` statement is executed and the `return`
    statement is used to exit the function. The great thing about using the `guard`
    statement with optional binding is that the new variable is within the scope of
    the rest of the function, rather than just within the scope of the optional binding
    statement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`guardFunction()`的函数，它接受一个包含字符串或`nil`值的可选值。然后我们使用带有可选绑定的`guard`语句来验证字符串可选值不是`nil`。如果它包含`nil`，则执行`guard`语句内的代码，并使用`return`语句退出函数。使用带有可选绑定的`guard`语句的好处是，新变量在函数的其余部分的作用域内，而不仅仅是可选绑定语句的作用域内。
- en: A conditional statement checks the condition once and, if the condition is met,
    it executes the block of code. However, what if we wanted to continuously execute
    the block of code until a condition is met? For this, we use loop statements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句会检查一次条件，如果条件满足，则执行代码块。然而，如果我们想连续执行代码块直到满足条件呢？为此，我们使用循环语句。
- en: The switch statement
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: 'The `switch` statement takes a value, compares it to several possible matches,
    and executes the appropriate block of code based on the first successful match.
    The `switch` statement is an alternative to using multiple `else if` statements
    when there could be several possible matches. The `switch` statement takes the
    following format:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句获取一个值，将其与几个可能的匹配项进行比较，并根据第一个成功的匹配执行相应的代码块。`switch`语句是当存在多个可能的匹配项时，使用多个`else
    if`语句的替代方案。`switch`语句的格式如下：'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unlike most other languages, in Swift, the `switch` statement does not fall
    through to the next `case` statement; therefore, we do not need to use a `break`
    statement to prevent this fall-through. This is another safety feature that has
    been built into Swift, as one of the most common programming mistakes regarding
    the `switch` statement made by beginner programmers is to forget the `break` statement
    at the end of the `case` statement. Let''s take a look at how to use the `switch`
    statement:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他语言不同，在Swift中，`switch`语句不会自动跳转到下一个`case`语句；因此，我们不需要使用`break`语句来防止这种情况。这是Swift中内置的另一个安全特性，因为初学者在处理`switch`语句时最常见的编程错误之一就是忘记在`case`语句的末尾添加`break`语句。让我们看看如何使用`switch`语句：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, the `switch` statement took the value of the `speed`
    variable and compared it to the two `case` statements. If the value of `speed`
    matches either case, the code prints the speed. If it does not find a match, it
    prints the `Unknown speed` message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`switch`语句获取了`speed`变量的值，并将其与两个`case`语句进行比较。如果`speed`的值与任一`case`匹配，则代码会打印速度。如果没有找到匹配项，它会打印`Unknown
    speed`消息。
- en: 'Every `switch` statement must have a match for all the possible values. This
    means that, unless we are matching against an enumeration that has a defined number
    of values, each `switch` statement must have a `default` case. Let''s take a look
    at a case where we do not have a `default` case:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`switch`语句都必须匹配所有可能的值。这意味着，除非我们正在匹配一个具有定义数量的值的枚举，否则每个`switch`语句都必须有一个`default`情况。让我们看看没有`default`情况的例子：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we put the preceding code into a Playground and attempt to compile the code,
    we will receive a `Switch must be exhaustive` error. This is a compile-time error,
    and therefore, we will not be notified until we attempt to compile the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码放入Playground并尝试编译，我们将收到一个`Switch must be exhaustive`错误。这是一个编译时错误，因此，我们只有在尝试编译代码时才会收到通知。
- en: 'It is possible to include multiple items in a single case. To do this, we need
    to separate the items with a comma. Let''s take a look at how we use the `switch`
    statement to tell us whether a character is a vowel or a consonant:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个`case`中可以包含多个项目。为了做到这一点，我们需要用逗号分隔这些项目。让我们看看我们是如何使用`switch`语句来判断一个字符是元音还是辅音的：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see in the preceding example that each case has multiple items. Commas
    separate these items and the `switch` statement attempts to match the `char` variable
    to each item listed in the `case` statements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到每个 `case` 都有多个项。逗号分隔这些项，`switch` 语句尝试将 `char` 变量与 `case` 语句中列出的每个项进行匹配。
- en: 'It is also possible to check the value of a `switch` statement to see whether
    it is included in a range. To do this, we use one of the range operators in the
    `case` statement, as shown in the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能检查 `switch` 语句的值，看它是否包含在某个范围内。为此，我们在 `case` 语句中使用范围运算符之一，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, the `switch` statement took the `grade` variable,
    compared it with the ranges in each `case` statement, and printed out the appropriate
    grade.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`switch` 语句取了 `grade` 变量，将其与每个 `case` 语句中的范围进行比较，并打印出适当的等级。
- en: 'In Swift, any `case` statement can contain an optional `where` clause, which
    provides an additional condition that needs validating. Let''s say that, in our
    preceding example, we have students who are receiving special assistance in class
    and we wanted to define a grade of `D` for them as a range from 55 to 69\. The
    following example shows how we can do this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，任何 `case` 语句都可以包含一个可选的 `where` 子句，它提供了一个需要验证的额外条件。假设在我们前面的例子中，我们有在课堂上接受特殊帮助的学生，我们想要为他们定义一个从
    55 到 69 的 `D` 等级。以下示例展示了我们如何做到这一点：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One thing to bear in mind with the `where` expression is that Swift will attempt
    to match the value, starting with the first `case` statement and working its way
    down, checking each `case` statement in order. This means that, if we put the
    `case` statement with the `where` expression after the grade `F` `case` statement,
    then the `case` statement with the `where` expression will never be reached. This
    is illustrated in the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `where` 表达式时，需要注意的一点是 Swift 将尝试匹配值，从第一个 `case` 语句开始，逐个检查每个 `case` 语句。这意味着，如果我们把带有
    `where` 表达式的 `case` 语句放在 `F` 等级 `case` 语句之后，那么带有 `where` 表达式的 `case` 语句将永远不会被触及。这在下述示例中得到了说明：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you are using the `where` clause, a good rule of thumb is to always put the
    `case` statements with the `where` clause before any similar `case` statements
    withou the `where` clause.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `where` 子句，一个很好的经验法则是始终将带有 `where` 子句的 `case` 语句放在任何不带 `where` 子句的类似 `case`
    语句之前。
- en: '`sSwitch` statements are also extremely useful for evaluating enumerations.
    Since an enumeration has a finite number of values, if we provide a `case` statement
    for all the values in the enumeration, we would not need to provide a `default`
    case. The following example demonstrates how we can use a `switch` statement to
    evaluate an enumeration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句在评估枚举时也非常有用。由于枚举具有有限数量的值，如果我们为枚举中的所有值提供 `case` 语句，我们就不需要提供 `default`
    语句。以下示例演示了我们可以如何使用 `switch` 语句来评估枚举：'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we began by defining an enumeration named `Product` with two
    values, each with associated values. We then created an `order` variable of `Product`
    type and used the `switch` statement to evaluate it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了一个名为 `Product` 的枚举，包含两个值，每个值都有关联的值。然后我们创建了一个 `order` 变量，其类型为 `Product`，并使用
    `switch` 语句对其进行评估。
- en: 'When using a `switch` statement with enumerations, we must have a `case` statement
    for all possible values or a default statement. Let''s take a look at some additional
    code that illustrates this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用枚举的 `switch` 语句时，我们必须为所有可能的值提供一个 `case` 语句或一个 `default` 语句。让我们看看一些额外的代码，以说明这一点：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this sample code, we have a `case` statement that handles each planet in
    the `Planets` enumeration. We can also add a `default` statement to handle any
    additional planets if they are added in later. However, it is recommended that
    if a `switch` statement uses a `default` case with an enumeration, then we should
    use the `@unknown` attribute, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例代码中，我们有一个处理 `Planets` 枚举中每个行星的 `case` 语句。我们还可以添加一个 `default` 语句来处理将来可能添加的任何额外行星。然而，建议如果
    `switch` 语句使用带有枚举的 `default` 语句，则应使用 `@unknown` 属性，如下所示：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will always throw a warning to remind us that if we add a new planet to
    the `Planet` enumeration, then we need to handle that new planet in this part
    of the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将始终抛出一个警告，提醒我们如果我们在 `Planet` 枚举中添加一个新的行星，那么我们需要在这个代码部分处理这个新行星。
- en: 'In *Chapter 5*, *Using Swift Collections*, we briefly covered the Diff algorithm.
    At that time we mentioned that we couldn''t see the power of this algorithm until
    we understood the `switch` statement. Now that we understand the `switch` statement,
    let''s see what we can do with this algorithm:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第5章*，*使用 Swift 集合* 中，我们简要介绍了 Diff 算法。当时我们提到，直到我们理解了 `switch` 语句，我们才看不到这个算法的强大之处。现在我们理解了
    `switch` 语句，让我们看看我们可以用这个算法做什么：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we start by creating two arrays of strings that each
    contain a list of cities. We then run the `difference(from:)` method, which we
    covered in the previous chapter. The `difference(from:)` method returns a collection
    containing instances of the `Change` enumeration. The `Change` enumeration is
    defined like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了两个包含城市列表的字符串数组。然后我们运行了 `difference(from:)` 方法，我们在上一章中介绍了这个方法。`difference(from:)`
    方法返回一个包含 `Change` 枚举实例的集合。`Change` 枚举的定义如下：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This enumeration contains two possible values. The `insert` value tells us
    if we need to insert a value because the array is missing an element from the
    other array. The `remove` value tells us we need to remove an element because
    the array has an element that is not in the other array. In our code, we are handling
    both the `insert` and `remove` values, which means that after the code is executed,
    the `cities2` array will have the same elements and in the same order as the `cities1`
    array. This isn''t too exciting but let''s say that we want to `remove` any elements
    from the `cities2` array that do not appear in the `cities1` array. We could change
    our code to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举包含两个可能的值。`insert` 值告诉我们是否需要插入一个值，因为数组缺少来自另一个数组的一个元素。`remove` 值告诉我们需要删除一个元素，因为数组有一个不在另一个数组中的元素。在我们的代码中，我们处理了
    `insert` 和 `remove` 两个值，这意味着代码执行后，`cities2` 数组将具有与 `cities1` 数组相同的元素和相同的顺序。这并不太令人兴奋，但让我们假设我们想要从
    `cities2` 数组中删除任何不在 `cities1` 数组中出现的元素。我们可以将我们的代码更改为以下内容：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When this code is executed, the `cities2` array would contain the three elements
    of `London`, `Paris`, and `Boston`. If we just handled the insert conditions then
    the `cities2` array would contain any elements that were part of either array.
    sSwitch on tuples
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码执行时，`cities2` 数组将包含三个元素：`London`、`Paris` 和 `Boston`。如果我们只处理插入条件，那么 `cities2`
    数组将包含任何属于任一数组的元素。切换元组
- en: 'We can also use the `switch` statement with tuples; let''s take a look at how
    to do this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `case` 语句中使用下划线（通配符）和范围运算符与元组结合；让我们看看如何做到这一点：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this code, we created a tuple named `myDog` that contained the name of my
    dog and her age. We then used the `switch` statement to match the name (the first
    element of the tuple) and a `let` statement to retrieve the age. In this example,
    the message, `Maple is my dog and is 4`, will be printed to the screen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个名为 `myDog` 的元组，其中包含了我狗的名字和她的年龄。然后我们使用 `switch` 语句来匹配名字（元组的第一个元素）和
    `let` 语句来检索年龄。在这个例子中，信息“Maple是我的狗，她4岁”将被打印到屏幕上。
- en: 'We can also use the underscore (wildcard) and range operators with tuples in
    the `case` statement, as shown in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `case` 语句中使用下划线（通配符）和范围运算符与元组结合，如下面的示例所示：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the underscore will match any name, while the range operators
    will look for the age of the dog. In this example, since Maple is four years old,
    the message `Your dog is middle aged` will be printed on the screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，下划线将匹配任何名字，而范围运算符将查找狗的年龄。在这个例子中，由于Maple四岁了，屏幕上会打印出信息“你的狗处于中年”。
- en: Match on wildcard
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配通配符
- en: 'In Swift, we can also combine the underscore (wildcard) with the `where` statement.
    This is illustrated in the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们还可以将下划线（通配符）与 `where` 语句结合使用。以下示例说明了这一点：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we create an integer variable named `myNumber` and use the
    `switch` statement to determine whether the value of the variable is a multiple
    of 2 or 3\. Notice the `case` statement is proceeded by an underscore followed
    by the `where` statement. The underscore will match all the values of the variable,
    and then the `where` statement is called to see if the item we are switching on
    matches the rule defined within it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `myNumber` 的整数变量，并使用 `switch` 语句来确定变量的值是否是2或3的倍数。注意，`case`
    语句前面有一个下划线，后面跟着 `where` 语句。下划线将匹配变量的所有值，然后调用 `where` 语句来查看我们正在切换的项是否匹配其中定义的规则。
- en: Loops
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Loop statements enable us to continuously execute a block of code until a condition
    is met. They also enable us to iterate over elements of a collection. Let's look
    at how we would use the `for-in` loop to iterate over the elements of a collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句使我们能够连续执行一段代码，直到满足某个条件。它们还使我们能够遍历集合中的元素。让我们看看我们如何使用`for-in`循环来遍历集合的元素。
- en: The for-in loop
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for-in循环
- en: While Swift does not offer the standard C-based `for` loop, it does have the
    `for-in` loop. The standard C-based `for` loop was removed from the Swift language
    in Swift 3 because it was rarely used. You can read the full proposal to remove
    this loop on the Swift evolution site at [https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md).
    The `for-in` statement is used to execute a block of code for each item in a range,
    collection, or sequence.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Swift没有提供基于C的标准`for`循环，但它确实有`for-in`循环。在Swift 3中，基于C的标准`for`循环被从Swift语言中移除，因为它很少使用。你可以在Swift进化网站上阅读移除此循环的完整提案：[https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md)。`for-in`语句用于对范围、集合或序列中的每个项执行代码块。
- en: Using the for-in loop
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用for-in循环
- en: 'The `for-in` loop iterates over a collection of items or a range of numbers,
    and executes a block of code for each item in the collection or range. The format
    for the `for-in` statement is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环遍历一个项的集合或数字的范围，并对集合或范围内的每个项执行一段代码。`for-in`语句的格式如下：'
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we can see in the preceding code, the `for-in` loop has twos:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`for-in`循环有两个：
- en: '`variable`: This variable will change each time the loop executes and will
    hold the current item from the collection or range'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variable`：这个变量会在每次循环执行时改变，并将持有集合或范围中的当前项'
- en: '`collection/range`: This is the collection or range to iterate through'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection/range`：这是要遍历的集合或范围'
- en: 'Let''s take a look at how to use the `for-in` loop to iterate through a range
    of numbers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`for-in`循环遍历一个数字的范围：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, we iterated over a range of numbers from 1 to 5 and
    printed each of the numbers to the console. This loop used the closed range operator
    (`...`) to give the loop a range to iterate through. Swift also provides the half-open
    range operator (`..>`) and the one-sided range operators that we saw in the previous
    chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们遍历了从1到5的数字范围，并将每个数字打印到控制台。这个循环使用了闭包范围运算符（`...`）来为循环提供一个遍历的范围。Swift还提供了半开范围运算符（`..>`）和我们在上一章中看到的单侧范围运算符。
- en: 'Now, let''s take a look at how to iterate over an array with the `for-in` loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`for-in`循环遍历一个数组：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, we iterated through the `countries` array and printed
    each element of the array to the console. As you can see, iterating through an
    array with the `for-in` loop is safer, cleaner, and a lot easier than using the
    standard C-based `for` loop. Using the `for-in` loop prevents us from making common
    mistakes, such as using the less than or equal to (`<=`) operator rather than
    the less than (`<`) operator in our conditional statement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们遍历了`countries`数组，并将数组中的每个元素打印到控制台。正如你所看到的，使用`for-in`循环遍历数组比使用基于C的标准`for`循环更安全、更简洁，也更简单。使用`for-in`循环可以防止我们犯一些常见的错误，例如在条件语句中使用小于等于（`<=`）运算符而不是小于（`<`）运算符。
- en: 'Let''s take a look at how to iterate over a dictionary with the `for-in` loop:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`for-in`循环遍历一个字典：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we used the `for-in` loop to iterate through each
    key-value pair of the dictionary. In this example, each item in the dictionary
    is returned as a (`key`,`value`) tuple. We can decompose (`key`,`value`) tuple
    members as named constants within the body of the loop. One thing to note is that
    since a dictionary does not guarantee the order that items are stored in, the
    order that they are iterated through may not be the same as the order in which
    they were inserted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`for-in`循环遍历字典中的每个键值对。在这个例子中，字典中的每个项都作为（`key`,`value`）元组返回。我们可以在循环体中将（`key`,`value`）元组的成员分解为命名的常量。需要注意的是，由于字典不保证存储项的顺序，遍历的顺序可能与插入的顺序不同。
- en: Now, let's take a look at another type of loop, the `while` loop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种类型的循环，即`while`循环。
- en: The while loop
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当循环
- en: The `while` loop executes a block of code until a condition is met. Swift provides
    two forms of the `while` loop; these are the `while` and `repeat-while` loops.
    In Swift 2.0, Apple replaced the `do-while` loop with the `repeat-while` loop.
    The `repeat-while` loop functions in the same way as the `do-while` loop did.
    Swift uses the `do` statement for error handling. A `while` loop is used when
    you want to run a loop zero or more times, while a `repeat-while` loop is used
    when you want to run the loop one or more times.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环执行一个代码块，直到满足某个条件。Swift提供了两种形式的`while`循环；这些是`while`循环和`repeat-while`循环。在Swift
    2.0中，Apple用`repeat-while`循环替换了`do-while`循环。`repeat-while`循环的功能与`do-while`循环相同。Swift使用`do`语句进行错误处理。当你想运行零次或多次循环时，使用`while`循环；当你想运行一次或多次循环时，使用`repeat-while`循环。'
- en: We use `while` loops when the number of iterations to be performed is not known
    and is usually dependent on some business logic. This could be something like
    looping through a collection until a certain value is found or a condition is
    met.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`while`循环当要执行的迭代次数未知且通常依赖于某些业务逻辑时。这可能是像遍历一个集合直到找到一个特定的值或满足某个条件。
- en: Using the while loop
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用while循环
- en: 'The `while` loop starts by evaluating a conditional statement and then repeatedly
    executes a block of code while the conditional statement is `true`. The format
    for the `while` statement is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环首先评估一个条件语句，然后当条件语句为`true`时，反复执行一个代码块。`while`语句的格式如下：'
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s take a look at how to use a `while` loop. In the following example,
    the `while` loop will continue to execute the block of code while the randomly-generated
    number is less than 7\. In this example, we are using the `Int.random()` function
    to generate a random number between 0 and 9:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`while`循环。在下面的例子中，`while`循环将在生成的随机数小于7时继续执行代码块。在这个例子中，我们使用`Int.random()`函数生成一个介于0到9之间的随机数：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we began by initializing the `ran` variable to `0`.
    The `while` loop then checks this variable and, if the value is less than 7, a
    new random number between 0 and 19 is generated. The `while` loop will continue
    to loop while the randomly-generated number is less than 7\. Once the randomly-generated
    number is equal to or greater than 7, the loop will exit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先将`ran`变量初始化为`0`。然后`while`循环检查这个变量，如果值小于7，就生成一个新的介于0到19之间的随机数。`while`循环将继续循环，直到生成的随机数等于或大于7。一旦生成的随机数等于或大于7，循环将退出。
- en: In the preceding example, the `while` loop checked the conditional statement
    prior to generating a new random number. But what if we don't want to check the
    conditional statement prior to generating a random number? We could generate a
    random number when we first initialize the variable, but that means we need to
    duplicate the code that generates the random numbers, and duplicating code is
    never an ideal solution. It is preferable to use the `repeat-while` loop instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`while`循环在生成新的随机数之前检查了条件语句。但如果我们不想在生成随机数之前检查条件语句呢？我们可以在初始化变量时生成一个随机数，但这意味着我们需要复制生成随机数的代码，而复制代码永远不是一种理想解决方案。使用`repeat-while`循环更为可取。
- en: Using the repeat-while loop
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用repeat-while循环
- en: The difference between the `while` and `repat-while` loops is that the `while`
    loop checks the conditional statement prior to executing the block of code for
    the first time; therefore, all the variables in the conditional statements need
    to be initialized prior to executing the `while` loop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环和`repeat-while`循环的区别在于，`while`循环在第一次执行代码块之前会检查条件语句；因此，所有在条件语句中的变量都需要在执行`while`循环之前初始化。'
- en: 'The `repeat-while` loop will run through the loop block prior to checking the
    conditional statement for the first time. This means that we can initialize the
    variables in the conditional block of code. The use of the `repeat-while` loop
    is preferred when the conditional statement is dependent on the code in the loop
    block. The `repeat-while` loop takes the following format:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat-while`循环会在第一次检查条件语句之前运行循环块。这意味着我们可以在代码的条件块中初始化变量。当条件语句依赖于循环块中的代码时，`repeat-while`循环的使用更为合适。`repeat-while`循环的格式如下：'
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s look at this specific example by creating a `repeat-while` loop where
    we initialize the variable that we are checking within the loop block:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个`repeat-while`循环来查看这个具体的例子，在这个循环中，我们在循环块内初始化我们要检查的变量：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, we defined the `ran` variable as an integer; however,
    we did not initialize it until we entered the loop block and generated a random
    number. If this is attempted with the `while` loop (leaving the `ran` variable
    uninitialized), we will receive the `variable used before b`eing initializedexception.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`ran`变量定义为整数；然而，我们直到进入循环块并生成随机数之前都没有初始化它。如果我们尝试使用`while`循环（未初始化`ran`变量），我们将收到`variable
    used before being initialized`异常。
- en: Earlier, we mentioned that the `switch` statement is preferred over using multiple
    `else if` blocks. Let's see how we can use the `switch` statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到`switch`语句比使用多个`else if`块更受欢迎。让我们看看我们如何使用`switch`语句。
- en: Using case and where statements with conditional statements and loops
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在条件语句和循环中使用`case`和`where`语句
- en: As we saw with `switch` statements, the `case` and `where` statements within
    a `switch` statement can be very powerful. Using `case` and `where` statements
    within our conditional statements can also make our code much smaller and easier
    to read. Conditional statements and loops, such as `if`, `for`, and `while`, can
    also make use of the `where` and `case` keywords. Let's take a look at some examples,
    starting off with using the `where` statement to filter the results in a `for-in`
    loop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`switch`语句中看到的那样，`switch`语句内的`case`和`where`语句可以非常强大。在我们的条件语句中使用`case`和`where`语句也可以使我们的代码更加简洁且易于阅读。条件语句和循环，如`if`、`for`和`while`，也可以使用`where`和`case`关键字。让我们看看一些例子，从使用`where`语句在`for-in`循环中过滤结果开始。
- en: Filtering with the where statement
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`where`语句进行过滤
- en: 'In this example, we take an array of integers and print out only multiples
    of 3\. However, before we look at how to filter the results with the `where` statement,
    let''s take a look at how to do this without the `where` statement:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们取一个整数数组，并仅打印出3的倍数。然而，在我们查看如何使用`where`语句过滤结果之前，让我们看看如何在不使用`where`语句的情况下完成此操作：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, we use a `for-in` loop to cycle through the numbers 1 to 30\.
    Within the `for-in` loop, we use an `if` conditional statement to filter out multiples
    of 3\. In this simple example, the code is relatively easy to read, but let''s
    examine how we can use the `where` statement to use fewer lines of code and make
    them easier to read:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`for-in`循环遍历数字1到30。在`for-in`循环内，我们使用`if`条件语句过滤出3的倍数。在这个简单的例子中，代码相对容易阅读，但让我们看看如何使用`where`语句来减少代码行数并使其更容易阅读：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We still have the same `for-in` loop as in the previous example. However, we
    have now put the `where` statement at the end; therefore, we only loop through
    numbers that are multiples of 3\. Using the `where` statement shortens our example
    by two lines and makes it easier to read, because the `where` clause is on the
    same line as the `for-in` loop, rather than being embedded in the loop itself.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有与上一个例子相同的`for-in`循环。然而，我们现在将`where`语句放在了末尾；因此，我们只遍历3的倍数。使用`where`语句将我们的例子缩短了两行，并使其更容易阅读，因为`where`子句与`for-in`循环在同一行，而不是嵌入在循环本身中。
- en: Now, let's look at how we could filter with the `for-case` statement.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`for-case`语句进行过滤。
- en: Filtering with the for-case statement
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for-case`语句进行过滤
- en: 'In this next example, we will use the `for-case` statement to filter through
    an array of tuples and print out only the results that match our criteria. The
    `for-case` example is very similar to using the `where` statement where it is
    designed to eliminate the need for an `if` statement within a loop to filter the
    results. In this example, we will use the `for-case` statement to filter through
    a list of World Series winners and print out the year(s) that a particular team
    won the World Series:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的例子中，我们将使用`for-case`语句过滤一个元组数组，并仅打印出符合我们标准的结果。`for-case`示例与使用`where`语句非常相似，它旨在消除在循环中过滤结果时需要`if`语句的需求。在这个例子中，我们将使用`for-case`语句过滤一系列世界系列冠军，并打印出特定球队赢得世界系列的时间：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we created an array of tuples named `worldSeriesWinners`, where
    each tuple in the array contained the name of the team and the year that they
    won the World Series. We then use the `for-case` statement to filter through the
    array and only print out the years that the Red Sox won the World Series. The
    filtering is done within the `case` statement, where `("Red Sox", year)` states
    that we want all the results that have the `Red Sox` string in the first item
    of the tuple, and the value of the second item in the `year` constant. The `for-in`
    loop then loops through the results of the `case` statement, printing out the
    value of the `year` constant.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`worldSeriesWinners`的元组数组，数组中的每个元组包含球队名称和赢得世界大赛的年份。然后我们使用`for-case`子句遍历数组，并仅打印出红袜队赢得世界大赛的年份。过滤是在`case`子句中完成的，其中`("Red
    Sox", year)`表示我们想要所有第一个元素包含`Red Sox`字符串的结果，以及`year`常量的第二个元素。然后`for-in`循环遍历`case`子句的结果，打印出`year`常量的值。
- en: 'The `for-case-in` statement also makes it very easy to filter out the `nil`
    values in an array of optionals; let''s look at an example of this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-case-in`子句也使得在可选数组中过滤掉`nil`值变得非常容易；让我们看看这个例子：'
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this example, we created an array of optionals named `myNumbers` that could
    contain either an integer value or `nil`. As we saw in *Chapter 4*, *Optional
    Types*, an optional is internally defined as an enumeration, as shown in the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`myNumbers`的可选数组，它可以包含整数或`nil`。正如我们在*第4章*，*可选类型*中看到的，可选在内部定义为枚举，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If an optional is set to `nil`, it will have a value of `none`, but if it is
    not `nil`, it will have a value of `some`, with an associated type of the actual
    value. In our example, when we filter for `.some(num)`, we are looking for any
    optional that has a non-nil value. As a shorthand for `.some()`, we could use
    the question mark (`?`) symbol, as we will see in the following example. This
    example also combines the `for-case-in` statement with a `where` statement to
    perform additional filtering:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可选设置为`nil`，它将具有`none`的值，但如果它不是`nil`，它将具有`some`的值，并关联实际值的类型。在我们的例子中，当我们过滤`.some(num)`时，我们正在寻找任何具有非空值的可选。作为`.some()`的简写，我们可以使用问号（`?`）符号，如下面的例子所示。此示例还结合了`for-case-in`子句和`where`子句以执行额外的过滤：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This example is the same as the previous example, except that we have put the
    additional filtering in the `where` statement. In the previous example, we looped
    through all of the non-nil values; however, in this example, we have looped through
    the non-nil values that are greater than 3\. Let''s examine how we can do this
    same filtering without the `case` or `where` statements:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子相同，只是我们在`where`子句中添加了额外的过滤。在上一个例子中，我们遍历了所有非空值；然而，在这个例子中，我们遍历了大于3的非空值。让我们看看我们如何在不使用`case`或`where`子句的情况下进行相同的过滤：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using the `for-case-in` and `where` statements can greatly reduce the number
    of lines that are needed. It also makes our code much easier to read because all
    the filtering statements are on the same line.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for-case-in`和`where`子句可以大大减少所需的行数。它还使我们的代码更容易阅读，因为所有过滤子句都在同一行。
- en: Let's take a look at one more filtering example. This time, we will look at
    the `if-case` statement.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看另一个过滤示例。这次，我们将查看`if-case`子句。
- en: Using the if-case statement
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`if-case`子句
- en: 'Using the `if-case` statement is very similar to using the `switch` statement.
    Most of the time, the `switch` statement is preferred when we have over two cases
    that we are trying to match, but there are instances where the `if-case` statement
    is needed. One of those times is when we are only looking for one or two possible
    matches, and we do not want to handle all the possible matches; let''s take a
    look at an example of this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if-case`子句与使用`switch`子句非常相似。大多数时候，当我们有超过两个要匹配的情况时，我们更喜欢使用`switch`子句，但有时需要使用`if-case`子句。其中一种情况是我们只寻找一两个可能的匹配项，并且不想处理所有可能的匹配项；让我们看看这个例子：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this example, we created an enumeration named `Identifier` that contains
    three possible values: `Name`, `Number`, and `NoIdentifier`. We then created an
    instance of the `Identifier` enumeration named `playerIdentifier`, with a value
    of `Number` and an associated value of `2`. We then used the `if-case` statement
    to see if the `playerIdentifier` had a value for `Number` and if so, we printed
    a message to the console.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`Identifier`的枚举，其中包含三个可能的值：`Name`、`Number`和`NoIdentifier`。然后我们创建了一个名为`playerIdentifier`的`Identifier`枚举实例，其值为`Number`，关联值为`2`。然后我们使用`if-case`语句来查看`playerIdentifier`是否有`Number`的值，如果有，我们将在控制台打印一条消息。
- en: 'Just like the `for-case` statement, we can perform additional filtering with
    the `where` statement. The following example uses the same `Identifier` enumeration
    that we used in the previous example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`for-case`语句一样，我们可以使用`where`语句进行额外的过滤。以下示例使用了我们在上一个例子中使用的相同的`Identifier`枚举：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we have used the `if-case` statement to see whether the `playerIdentifier`
    had a value of `Number`, but we also added the `where` statement to see if the
    associated value was equal to `2`. If so, we identified the player as either `XanderBogarts`
    or `Derek` `Jeter`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`if-case`语句来查看`playerIdentifier`是否有`Number`的值，但我们还添加了`where`语句来查看关联值是否等于`2`。如果是这样，我们将玩家识别为`XanderBogarts`或`Derek
    Jeter`。
- en: As we saw in our examples, using the `case` and `where` statements with our
    conditional statements can reduce the number of lines that are needed to perform
    certain types of filtering. It can also make our code easier to read. Now let's
    take a look at control transfer statements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中看到的那样，使用`case`和`where`语句与我们的条件语句可以减少执行某些类型过滤所需的行数。它还可以使我们的代码更容易阅读。现在让我们来看看控制转移语句。
- en: Control transfer statements
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制转移语句
- en: Control transfer statements are used to transfer control to another part of
    the code. Swift offers six control transfer statements; these are `continue`,
    `break`, `fallthrough`, `guard`, `throws`, and `return`. We will look at the `return`
    statement in *Chapter 7*, *Functions*,and will discuss the `throws` statement
    in *Chapter 12*, *Availability and Error Handling*. The remaining control transfer
    statements will be discussed in this section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 控制转移语句用于将控制权转移到代码的另一个部分。Swift提供了六个控制转移语句；这些是`continue`、`break`、`fallthrough`、`guard`、`throws`和`return`。我们将在*第7章*，*函数*中查看`return`语句，并在*第12章*，*可用性和错误处理*中讨论`throws`语句。剩余的控制转移语句将在本节中讨论。
- en: The continue statement
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`continue`语句'
- en: 'The `continue` statement tells a loop to stop executing the code block and
    to go to the next iteration of the loop. The following example shows how we can
    use this statement to print out only the odd numbers in a range:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句告诉循环停止执行代码块并转到循环的下一个迭代。以下示例展示了我们如何使用此语句来打印出范围内的奇数：'
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding example, we looped through a range from 1 to 10\. For each
    iteration of the `for-in` loop, we used the remainder (`%`) operator to see whether
    the number was odd or even. If the number is even, the `continue` statement tells
    the loop to immediately go to the next iteration of the loop. If the number is
    odd, we print that the number is odd and then move on. The output of the preceding
    code is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们遍历了从1到10的范围。对于`for-in`循环的每次迭代，我们使用余数（`%`）运算符来查看数字是奇数还是偶数。如果数字是偶数，`continue`语句告诉循环立即转到循环的下一个迭代。如果数字是奇数，我们打印出该数字是奇数，然后继续。前面代码的输出如下：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now let's take a look at the `break` statement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`break`语句。
- en: The break statement
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`break`语句'
- en: 'The `break` statement immediately ends the execution of a code block within
    the control flow. The following example demonstrates how to break out of a `for-in`
    loop when we encounter the first even number:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句立即结束控制流中的代码块执行。以下示例演示了当我们遇到第一个偶数时如何从`for-in`循环中退出：'
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding example, we loop through the range from 1 to 10\. For each
    iteration of the `for-in` loop, we use the remainder (`%`) operator to see whether
    the number is odd or even. If the number is even, we use the `break` statement
    to immediately exit the loop. If the number is odd, we print out that the number
    is odd, and then go to the next iteration of the loop. The preceding code has
    the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们遍历从1到10的范围。对于`for-in`循环的每次迭代，我们使用取余（`%`）运算符来判断数字是奇数还是偶数。如果数字是偶数，我们使用`break`语句立即退出循环。如果数字是奇数，我们打印出该数字是奇数，然后进入循环的下一个迭代。前面的代码有以下输出：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The fallthrough statement
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跌落语句
- en: In Swift, the `switch` statement does not fall through like other languages;
    however, we can use the `fallthrough` statement to force them to fall through.
    The `fallthrough` statement can be very dangerous because, once a match is found,
    the next case defaults to `true` and that code block is executed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，`switch`语句不像其他语言那样会跌落；然而，我们可以使用`fallthrough`语句来强制它们跌落。`fallthrough`语句可能非常危险，因为一旦找到匹配项，下一个情况将默认为`true`，并且执行那个代码块。
- en: 'This is illustrated in the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下示例中得到了说明：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When this code is run, the following results are printed to the console:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，以下结果将打印到控制台：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I recommend that you be very careful about using the `fallthrough` statement.
    Apple purposely disabled falling through on the `case` statement to avoid the
    common errors that programmers make. By using the `fallthrough` statement, you
    could introduce these errors back into your code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在使用`fallthrough`语句时要非常小心。苹果公司故意禁用了`case`语句的跌落，以避免程序员常见的错误。通过使用`fallthrough`语句，您可能会将这些错误重新引入到您的代码中。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered control flow and functions in Swift. It is essential
    that you understand the concepts in this chapter before moving ahead. Every application
    that we write, beyond the simple Hello World applications, will rely very heavily
    on control flow statements and functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Swift中的控制流和函数。在继续前进之前，理解本章中的概念是至关重要的。我们编写的每个应用程序，除了简单的Hello World应用程序之外，都将非常依赖控制流语句和函数。
- en: Control flow statements are used to make decisions within our application, and
    functions, which we will be discussing in the next chapter, are used to group
    our code into sections that are reusable and organized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流语句用于在我们应用程序中做出决策，并且函数，我们将在下一章讨论，用于将我们的代码分组到可重用和有组织的部分。
