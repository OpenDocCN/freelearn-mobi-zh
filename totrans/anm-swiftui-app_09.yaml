- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating Strokes around Shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will take three images, create outlines around them, and
    then animate strokes along those outlines. A stroke is a line that follows the
    outline (or contours) of a shape, which we can give any color and thickness and
    animate to move around the image.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you’ll learn how to convert bitmap images into vector images using
    the Inkscape software, and then take those vectors and convert them into Swift
    code using Sketch and Kite. We will then insert this code back into Xcode so that
    we can start animating our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the objectives for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting images into Swift code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating images with the `stroke` modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 9` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remove Background software, which is a free online tool you can access
    here: [https://www.remove.bg/upload](https://www.remove.bg/upload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inkscape, which is free and you can install here: [https://inkscape.org/release/inkscape-1.2.1/](https://inkscape.org/release/inkscape-1.2.1/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sketch, which you can install here: [https://www.sketch.com/switch-to-sketch/](https://www.sketch.com/switch-to-sketch/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kite, which you can install here: [https://kiteapp.co](https://kiteapp.co)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting images into Swift code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create the three outlines that we need, we first have to convert
    images into vectors and then convert those vectors into Swift code. Why do we
    have to convert an image into Swift code?
  prefs: []
  type: TYPE_NORMAL
- en: Well, in order to place an animating stroke around an image, we need a path
    for the animation to follow. When the image has been translated into code, it
    will then be easy to use Swift to follow the image outline.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s a problem: bitmaps. A **bitmap**, also called a **raster image**,
    is a graphic that is created from different colored pixels, which together form
    an image. Bitmaps can be very simple, just made up of two colors (those would
    be black and white), or they can have many thousands or millions of colors that
    produce photograph-quality images. Some examples of bitmap formats that you will
    see use the file extensions PNG, JPEG, and TIFF. With a bitmap image, there is
    no defined outline for any code to follow, and thus it cannot have an animating
    stroke around it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector images**, on the other hand, are images created from code that have
    sharply defined edges and never get blurry like a bitmap when you zoom in on them.
    Since they are created with code, we can animate strokes around those images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to animate a stroke around a bitmap image, there are three main
    steps that you need to undertake:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the background of the image you want to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectorizing the image into an SVG file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating the SVG file into Swift code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s go through those steps now.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the image backgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many images have a white or colored background, and in many cases, the background
    is not needed. It’s easier to convert images into vectors if they are against
    a transparent background.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, the images that we will be using are an image of the word “WE,”
    an image of a heart, and an image of the SwiftUI logo. We will combine them in
    Swift so that they say, “We Love SwiftUI,” like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The images we will use in our project ](img/B18674_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The images we will use in our project'
  prefs: []
  type: TYPE_NORMAL
- en: You can download these from the GitHub repository, where you will notice that
    the backgrounds have already been removed. However, if you are going to use your
    own images, you will need to do this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already explored how to remove backgrounds in [*Chapter 6*](B18674_06.xhtml#_idTextAnchor082)
    when we animated the girl on the swing. You can refer back to that chapter; however,
    to recap, you can use an online tool called Remove Background: [https://www.remove.bg/upload](https://www.remove.bg/upload).
    You just have to click **Upload Image** and choose the one you want to use. And
    that’s it – in about 20 seconds, the website’s algorithms will find the background
    and remove it, leaving only your subject. Then, all you have to do is download
    the new image file and you’re good to go.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use Mac’s Preview app to remove the background, or you
    can use paid software such as Affinity Designer. How you decide to remove the
    background is up to you; experiment and try to see what works best for the image
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Also, although it’s not strictly necessary, it’s a good idea to crop your image,
    as we only want to work with the image and not any surrounding space. You can
    do this in pretty much any graphics editing program, including the Preview app.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can proceed to the next step, which is vectorizing the image.
  prefs: []
  type: TYPE_NORMAL
- en: Vectorizing the images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second step will be to create vectors from the bitmap image. To do this,
    we will need software with the proper algorithms to detect pixels, remove them,
    and replace them with code that will draw the shapes instead. The resulting code
    file will be a `.svg`) file. One of the best software options on the market is
    called Vector Magic. This software is easy to use and automates the vectorization
    process with a click of a button to start the process, but the downside is it
    costs around $300.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use Inkscape, which is free software that does a really
    good job of tracing out a bitmap image and converting all its parts into vectors.
    This is what we will use, and you can download the latest version (at the time
    of writing) from the following link: [https://inkscape.org/release/inkscape-1.2.1/](https://inkscape.org/release/inkscape-1.2.1/).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Even though Inkscape can work with color images, it’s usually better to have
    your images in black and white; the algorithms work better with these two colors.
    If you have color images, though, that’s not a problem – you can still convert
    them into black and white by using a graphics program such as Affinity Designer.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the images we are using for this project, two of them are in
    color, but that’s okay because they have a limited number of colors and are simple
    shapes. If you have more complicated shapes, for instance, such as a portrait
    photograph with many colors in it, then it’s better to convert them into black
    and white first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have Inkscape installed, you can get started. Grab one of your images
    (in my case, I am choosing the “WE” image), right-click on it, and open it in
    Inkscape. You will see this pop-up window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Importing an image into Inkscape ](img/B18674_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Importing an image into Inkscape'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set **Image Import Type** to **Embed**, **Image DPI** to **Default import resolution**,
    and **Image Rendering Mode** to **None (auto)**. Then, click **OK**. You will
    then see this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The Inkscape editor with our image ](img/B18674_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The Inkscape editor with our image'
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing with the conversion, I want to show you how a bitmap looks
    close up. On your Mac trackpad, pinch and zoom in very close to the image; you
    will see pixelization and blurriness appear. This is one way you can tell whether
    the image is a bitmap and not a vector. (Of course, the file extension will also
    let you know whether it’s a bitmap or vector as well!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select your image on the Inkscape canvas (you will know it’s been selected
    if you see black arrows around it), then go to the **Path** menu at the top of
    the screen, and choose **Trace Bitmap**. This will open up the **Preview** option
    on the right-hand side of Inkscape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Inkscape Preview ](img/B18674_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Inkscape Preview'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Preview** window, Inkscape shows us what the **Trace Bitmap** function
    will be able to trace, and what the image will look like as a vector graphic.
    Since the preview looks nearly identical to the “WE” image on the canvas, there
    will be a complete outline around the image.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t see the vector lines and points just yet in the preview, but you will
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using a black and white image, Inscape has selected the **Single
    scan** option from the top of the **Preview** window (which you can see in *Figure
    9**.5*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: The Inkscape scan option ](img/B18674_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: The Inkscape scan option'
  prefs: []
  type: TYPE_NORMAL
- en: The **Single scan** option is used for black and white images, but if we use
    a multicolored image, then we need to select the **Multicolor** option. The **Multicolor**
    option will scan your image, looking at the many colors it contains, and do its
    best to trace an outline around each of those colors. This is why I said earlier
    that it’s usually better to have a black-and-white image, as there are fewer colors
    to scan and thus less chance of not getting a good trace.
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in *Figure 9**.5*, you can also adjust the **Threshold** and
    **Details** sliders to get the best possible image in the previews. These sliders
    are useful if Inkscape is having difficulty getting a good scan. By moving the
    sliders, you can fine-tune the parts of the image that Inkscape can see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the **Details** sliders:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Speckles** slider will ignore the small spots in the vector – when set
    to maximum, it will ignore more speckles, and when set to minimum, it will ignore
    fewer speckles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Smooth corners** slider will smooth out any sharp corners that are in
    the trace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Optimize** slider will try to optimize paths by joining adjacent Bezier
    curve segments together; this means that the **Optimize** slider will try its
    best to remove as many vector nodes as it can. When you have fewer nodes in a
    vector image, there tends to be better tracing and fewer jagged edges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see the **Threshold** slider later when creating a stroke around the
    heart.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to see in the preview is an image that is as close to the one in
    the center canvas as possible. When we do see this, it means that Inkscape can
    trace all around the shape on the canvas correctly and capture all the vector
    lines. If you don’t see an image that’s close to the original, then try and adjust
    some of the sliders I just mentioned to fine-tune the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished adjusting the image so it looks close to the original,
    click **Update Preview**, and then **Apply**. Inkscape places its newly created
    vectors directly over the original image. To see the result, click on the “WE”
    image in the editor and drag the new vectors to the side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Creating the vectors ](img/B18674_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Creating the vectors'
  prefs: []
  type: TYPE_NORMAL
- en: You can now delete the original image, as it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at what Inkscape has done for us – it has traced the original
    image and created a new image that is now made of vector paths. To see the difference,
    pinch and zoom on your Mac trackpad on the new vector image as you did with the
    bitmap image. Do you see the difference? There is no pixelation or blurriness
    at all, as the image is created with code rather than pixels; the image can be
    blown up to any size and it will still remain sharp and crisp along its edges
    and curves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Vector resolution ](img/B18674_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Vector resolution'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remember that I mentioned that you will be able to see the vectors that
    Inkscape has created? Well, they are there, it’s just that we need to select the
    right editing tool to see them. Select the image in the center of the canvas,
    go to the left toolbar, and select the **Node Editing** tool. When you click on
    that tool, you will be able to see all the vector lines that Inkscape created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: The vectors ](img/B18674_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: The vectors'
  prefs: []
  type: TYPE_NORMAL
- en: Each of those small squares is a point (or node) that links lines, curves, and
    corners to make this new shape – and these points can now be edited by clicking
    on them and dragging them to any location to reshape the vector image.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new vectors created, we can export them. To do this, open **File**
    at the top menu and choose **Export**. Then, you can choose the export options
    at the bottom right of the software. Choose the file type that you want to export
    to – we want a **Plain SVG (*.svg)** file. Then, click on the **Export** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: Exporting to an SVG file ](img/B18674_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Exporting to an SVG file'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have an SVG file stored on our computer, ready to be translated into
    Swift code. Do the same process for any of the other images that you want to use
    in this project – whether you are using your own images or following along with
    the book’s project images – and then you can proceed to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Translating the SVG file into Swift code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s continue. We have an SVG file ready for the next step. An **SVG** file
    is a file written in XML, and **XML** is a markup language used for storing and
    transferring digital information. The XML code in an SVG file creates all of the
    shapes, colors, and text that comprise the image. We will be turning that XML
    code into Swift code shortly, but first, we need to edit the images’ dimensions
    and we can do that in Sketch.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first, open the SVG “WE” image in Sketch. Then, in the **Utilities** area
    on the right, we can size the image however we like; in my case, I have set the
    width to **250**. To set this, make sure that the little lock icon in between
    the width and height fields is selected so that it’s locked – this will keep the
    correct proportions for the image – and hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Sizing the image ](img/B18674_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Sizing the image'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all we need to do in Sketch. Now, minimize your Sketch document (but
    don’t close it!).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a program that can turn XML code into Swift code. One option is
    Paint Code – although it is a great program, it costs around $200 per year for
    a subscription. Instead, we will use Kite – although this is currently $99 to
    buy outright with no subscription, you can always use the free trial to follow
    along with this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open up Kite. Then, click on **File** | **Import** | **From Sketch…**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: Importing from Sketch into Kite ](img/B18674_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Importing from Sketch into Kite'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then see a pop-up window asking how you would like to import the layers.
    Leave the default settings as they are, but make sure that **Import text layers
    as** is set to **Image Layers** and that **Import images at** is set to a scale
    of **1x**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Import From Sketch settings ](img/B18674_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Import From Sketch settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click on **Import**. You now have your image in Kite and are ready to
    turn it into Swift code, and that process is as simple as clicking one button,
    the **Code** button, at the top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Converting the file into Swift code ](img/B18674_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Converting the file into Swift code'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Swift code that is generated shows up in the bottom console, which you
    can resize like the Xcode console by dragging it upwards. Here is what the code
    console looks like for the “WE” image, containing all the Swift code that makes
    up its length, thickness, colors, position, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: The generated Swift code in Kite ](img/B18674_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: The generated Swift code in Kite'
  prefs: []
  type: TYPE_NORMAL
- en: That looks like a lot of code just to create an image with two letters, doesn’t
    it? Well, yes, but there are a lot of things the code is doing – it’s mapping
    out all the paths needed to create the lines and curves that form the shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now get this code into Xcode. First, create a new Xcode project if you
    haven’t done so already – I’ve called it **Animating Strokes**. Then, all we have
    to do is copy a small segment of it from Kite. You should copy the code starting
    from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And continue all the way down the file until you reach these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, we just want to copy all the code that starts with `pathPath`; everything
    else we don’t need.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we enter Xcode, let’s summarize what we have done so far. We have
    taken a bitmap image, removed its background and cropped it, opened it with Inkscape
    and turned it into a vector image, and then finally imported that vector into
    Kite, where we turned it into Swift code. This process will get faster with more
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now proceed to Xcode and start making all this code work.
  prefs: []
  type: TYPE_NORMAL
- en: Animating images with the stroke modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will be working in Xcode and refactoring the “WE”
    code somewhat in order to make it work in our project. We will use the Shape protocol
    that lets us draw a 2D shape using its `path()` function, and then use the `stroke`
    modifier to add a moving line around the path of our shapes. We will also get
    started on animating our heart and SwiftUI logo images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stroke animation on the “WE” image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start animating the “WE” image, we need to create a file inside the project.
    Press *Command + N*, choose a `WeView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a struct at the bottom of the file; this will be the struct that
    conforms to the shape protocol, allowing us to create 2D shapes by using the `path`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can paste in the code that we copied from the Kite program and place
    it right into that `path` function. This code is quite repetitive and long, as
    it is drawing a shape and must repeat itself for every line, curve, and corner.
    So, for the sake of brevity and to not take up too much space, I will just provide
    the beginning and end of the code (however, you can find the complete code in
    the GitHub repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you paste the code into Xcode, you will get some errors – don’t worry about
    these, as the code needs to be reworked a little bit anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing these issues is also a good excuse for me to show you how to refactor
    code in SwiftUI. Refactoring is a helpful feature that allows us to rename code
    or remove and replace different parts of code throughout multiple files in your
    project without having to search through all your files looking for each instance
    that needs refactoring and manually changing it.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we want to change is the name of the `pathPath` constant, which is
    the first line of code inside the `path` function that was pasted in. This constant
    seems to have been named twice because it was exported from Inkscape. However,
    it should simply be named `path`.
  prefs: []
  type: TYPE_NORMAL
- en: So, to refactor this, just *Command + click* on the `pathPath` variable and
    select `pathPath` in the file, and all you have to do is just type in the new
    name, `path`, and hit *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: That’s our first revision of the code that we copied over. The next revision
    is to change the class that’s being assigned to the `path` constant. Currently,
    the `path` constant is assigned as a `CGMutablePath()` instance, which is a core
    graphics class used for drawing shapes and lines. Working in SwiftUI though, nearly
    everything is built with structs, so we need to use the `Path()` struct instead.
    Also, change the `let` keyword to the `var` keyword, because we need the `path`
    variable to be mutable, meaning its value can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those modifications done, the first line of the code in your path function
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add one more line of code to this `path` function. At the very end
    of the function, we need to return the `path` variable, and to do so, we use the
    `return` keyword, followed by the variable the function must return; so, add this
    line at the bottom of the `path` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the changes we made to the start and end of the `path` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you press *Command + B*, the code should be error-free.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see what all of that Kite code is actually doing.
  prefs: []
  type: TYPE_NORMAL
- en: The `path()` function will return a shape according to the points, lines, and
    curves that are drawn inside it. The first line of code inside the `path()` function
    is creating a path instance; this will draw the shape, and you can think of this
    variable as the pencil moving along the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code is the `move()` function. This is what sets the starting
    location for the `path` variable to move to. The locations are based on the Cartesian
    coordinate system and an X and Y location are used to position the `path` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the third line of code, the `path` variable calls the `addCurve()` function,
    and this does what it says – it adds a Bezier curve to the path using the specified
    points. Continuing down our code, we see that the `path` variable also calls the
    `addLine()` function, and this will add a line to the path using the specified
    points. The code continues to call these two functions, `addCurve()` and `addLine()`,
    quite a bit until the `path` variable needs to finish off a particular path in
    the drawing and close off the ends of that finished line before moving on to the
    next line in the drawing.
  prefs: []
  type: TYPE_NORMAL
- en: The finished line is closed off using the `closeSubpath()` function and directly
    proceeded by the `moveTo()` function to start a new line in the drawing. So, as
    you can see, there are several lines drawn in this code to make up the finished
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, at the end of all this code, the `path()` function returns the
    `pat`h variable, which now contains a finished shape inside of it, ready to be
    displayed on the iPhone screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, continuing to work in the same file, we need to come into the `WEView`
    struct and add the code to display this shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting at the top of the struct, add the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside the `body` property, add a `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ZStack`, let’s add a `Group`, and then the following code to display
    the shape in the preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside `Group`, we call the `WeTextShape` struct and add the `stroke` modifier
    directly to it. This modifier will create a new shape that has a stroke on it,
    which is styled according to the `StrokeStyle` function. The `StrokeStyle` function
    adds a `lineWidth` property of `0.5`, and sets both `lineCap` (the ends of the
    stroke) and `lineJoin` to `round`; this joins the ends of the stroke with a semi-circular
    arc. Finally, the color of the stroke shape is set to `gray`.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the shape – we won’t add any animation to it, as we just want
    it to be a stationary shape. Instead, we will add this shape again, directly over
    the first one, and that’s the one we will animate in color. Let’s add that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing inside the `Group` view, and directly under the last line of code,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And that’s the code that will add a second shape, identical to the first one,
    directly over it.
  prefs: []
  type: TYPE_NORMAL
- en: As we did for the non-moving shape, we called the `WeTextView` struct to create
    the shape. Then, we used the `trim` modifier to trim the shape by a fractional
    amount based on the values that get passed into its parameters. By passing in
    the `startStroke` variable as the location of the start of the stroke animation
    and the `endStroke` variable to tell the `trim` modifier where to stop, a stroked
    line will be drawn along the shape’s path from start to end. The length of that
    stroke line will depend on the values inside the `startStroke` and `endStroke`
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the first shape, we also used the `strokeStyle` modifier to style
    the stroke with a `width` property of `5`, and `lineCap` and `lineJoin` set to
    `round`. This time, we set the color to `red` so that the moving stroke will stand
    out as it travels along the gray shape underneath it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, finally, we’re using the `offset` modifier to center the shape inside
    the preview in the middle from left to right, and toward the top of the iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the code for the outline and animating the stroke are complete. What’s
    needed next is to use the `onAppear` modifier to start the animation and set up
    some timers so that the stroke can proceed at a certain speed. Add the final bit
    of code right after the closing brace of the `ZStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code might look a little busy to grasp at first, but let’s break it down
    for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The `onAppear()` method is called on the `ZStack` container; this method is
    triggered when the view appears on the screen. Inside the method, a timer is scheduled
    using the `Timer.scheduledTimer` method, which is set to repeat every `0.23` seconds.
    This is the amount of time it takes for the animation to draw each stroke segment.
    A stroke segment is how we draw out the shape, in segments, one at a time. You
    can experiment with this timer’s interval value – a larger number will draw the
    stroke segments slower, and a smaller number will draw the segments faster, creating
    a smooth animating line around the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want the animation to repeat, so we set the `repeats` parameter to
    `true`. Within the timer’s event handler, the code first checks whether the `endStroke`
    variable is greater than or equal to `1`. If this is true, the code then checks
    whether the `strokeReset` variable is `true`. If both of these conditions are
    met, another timer is scheduled using the `Timer.scheduledTimer` method. This
    timer is set to run only once, after `0.6` seconds, and within this timer’s event
    handler, the values of `endStroke` and `startStroke` are reset to `0`, so the
    stroke animation can once again start at the beginning, and the `strokeReset`
    variable is toggled. After the inner timer is scheduled, the `strokeReset` variable
    is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `withAnimation` function is different from the animation modifier we have
    used in past projects. Remember in [*Chapter 2*](B18674_02.xhtml#_idTextAnchor034),
    when we talked about the two types of animations, *implicit* and *explicit*? The
    `withAnimation` function is an explicit type of animation and is used to animate
    changes to the view’s state. It is considered an explicit animation because it
    requires you to specify the animation that you want to use, as opposed to an implicit
    animation, which would automatically animate changes without the need for additional
    code.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the body of the `withAnimation` function, we set the `endStroke` variable
    to increase its value by `0.12` after every iteration of the animation. We also
    set `startStroke` to a value that is calculated by subtracting `0.4` from `endStroke`
    – this computation creates the length and speed of an animating stroke that I
    think looks pretty good for the “We” shape.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, this animation is complete. So, to summarize the code in the
    `WeView` struct, it creates a view that animates a shape, this shape is outlined
    twice, once with a gray color and a small stroke, and then again, with a red color
    and a bigger stroke. The animation is controlled by the `startStroke` and `endStroke`
    variables, which are incremented over time. The animation will be repeated once
    the `endStroke` variable reaches `1`, and there is a `0.6`-second delay before
    the animation starts again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished with the code, if you click on the `endStroke` in
    the `withAnimation` function, you can leave more of the stroke line on the shape
    or less of it, depending on the look you want to go for.
  prefs: []
  type: TYPE_NORMAL
- en: Play around with the values and experiment. You can create a flashing stroke
    by increasing the speed, or you can have a very slow-moving stroke. You can stroke
    the entire shape with a short line, or you can go with a very long line along
    the whole shape.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our first animation, the “WE” image stroke. Even though that
    seems like a long process, the whole thing actually only takes a few minutes once
    you get familiar with the different programs and techniques used. We are going
    to move on to the heart image now and repeat the same process. After all, practice
    makes perfect!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stroke animation on the heart image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, we have animated our first image, so we are going to follow the same process
    again for two more images. The next image will be a heart – for this one, we will
    animate a stroke around it as we did with the letters, but also we will add the
    heart image back into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along with the book’s project, you can find the heart image
    in the GitHub repository, where the background has already been removed. However,
    if you are using your own images, you will need to do this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: After you have prepared your image, now open it with Inkscape so that you can
    vectorize it. With the image selected in the editor, go to the **Path** menu at
    the top and choose **Trace Bitmap**; this will trace the image and prepare it
    for vectorization, as before.
  prefs: []
  type: TYPE_NORMAL
- en: With the image selected on the canvas, if you look at the **Previews** pane
    at the right, the image has been converted into black and white. That’s because,
    by default, Inkscape selects the **Single Scan** option, the option for black-and-white
    images. And even though this is a color image, because it’s such a simple shape
    with not many variations of red in it, we don’t need the **Multicolor** option;
    so, **Single scan** will work fine here.
  prefs: []
  type: TYPE_NORMAL
- en: This is also a good opportunity to use the **Smooth Corners** option as well
    because this shape has (for the most part) smooth corners, and this selection
    will preserve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it should look like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: The heart image in Inkscape ](img/B18674_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: The heart image in Inkscape'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, do you notice that the heart image shown in **Preview** has two white
    areas inside it? That’s the Inkscape algorithm trying to capture the shiny parts
    of the red heart image on the canvas. We only want to trace the outside perimeter
    of the heart, which is the area that will be outlined later in the code – we don’t
    want those white areas. To remove those white areas in the preview, slide the
    **Threshold** slider to the right, just enough so the heart fills up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Setting the options in Inkscape for the heart image ](img/B18674_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Setting the options in Inkscape for the heart image'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the heart shape is ready to be vectorized, click the **Apply** button
    to complete the process, and a new vectorized black heart is placed directly over
    the red heart image on the canvas. Drag the black heart off to the side, in order
    to see the red heart under it, then delete the red heart.
  prefs: []
  type: TYPE_NORMAL
- en: Next, position the black heart back over the white canvas and export it like
    the “WE” image, making sure to choose the **Plain SVG (*.svg)** file type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving away from Inkscape and into the Sketch program, open the new vector
    image we just exported from Inkscape into Sketch by right-clicking on the image
    and selecting **Open with Sketch**. We will resize the image again to a width
    of **250** (again, making sure to click on the lock icon to fix the proportions):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: Setting the size for the heart image in Sketch ](img/B18674_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Setting the size for the heart image in Sketch'
  prefs: []
  type: TYPE_NORMAL
- en: Next minimize the Sketch window, as we only need it running in the background
    so that Kite can access it, and open the Kite program. In Kite, click on **File**,
    then **Import**, and then **From Sketch**. You will see the same window as shown
    in *Figure 9**.12*, and you can keep the default settings. Then, click **Import**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has been imported, select the image on the canvas, and then
    click the **Code** button at the top to generate the Swift code we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: Generating the heart’s Swift code in Kite ](img/B18674_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Generating the heart’s Swift code in Kite'
  prefs: []
  type: TYPE_NORMAL
- en: Like we did with the “WE” image code, we just want to copy the code that starts
    with the `pathtPath` name. In the example here, the code we need starts at the
    `let pathPath = CGMutablePath()` line and ends with `pathPath.move(to)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to Xcode – create a new SwiftUI View file, which I will name `HeartView`.
    Inside the file, we will create a struct to put the code in, call it `HeartShape`,
    and make it conform to the `shape` protocol, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember when making the “WE” shape, we used the shape protocol? As before,
    it requires us to use the `path()` method, which I have added here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can paste the Kite-generated Swift code inside this method (again,
    I will only include the first few lines and the last few lines so as not to take
    up too much space here; as before, the complete code file and project are available
    in the GitHub repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s refactor the code as we did before. *Command + click* on the `pathPath`
    instance and choose `path`. Also, change the mutability of the `path` constant
    to a variable by replacing `let` with `var`, and change `CGMutablePath()` to `Path()`.
    These changes should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last change to make is at the bottom of the `HeartShape` struct; after
    the very last line of code, we need to return the path we created, so add the
    following line of code to the end of the `path` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code should now build cleanly, and we can move on to animating the outline
    around the heart. This is similar code to that in the `WEView` file. At the top
    of the struct, let’s add the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `strokeReset` variable will keep track of the animation, `startStroke` will
    hold a value that sets the `length` property of the stroke at the beginning, and
    `endStroke` will hold a value that sets the `length` property of the stroke at
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving into the `body` property of the struct, let’s add the views needed to
    display and animate our heart outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code here is almost identical to the code in the `WEView` file – what’s
    different is the color of the stroke. Here, it is white and we are offsetting
    the heart to be lower on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and you’ll see that there is a smoothly animating stroke going
    around the heart shape.
  prefs: []
  type: TYPE_NORMAL
- en: Again, all the values are for you to explore and experiment with to create the
    look you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s do something a bit different for this shape – let’s add the actual
    heart bitmap image right inside the animating heart shape. To do this, add the
    following code at the bottom of the `Group` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code again and you’ll see that it performs as before, only now we’ve
    positioned the heart bitmap image inside the stationary stroke, so the animated
    stroke is tracing the heart image for an interesting look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: The stroke around the heart image ](img/B18674_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: The stroke around the heart image'
  prefs: []
  type: TYPE_NORMAL
- en: We have completed two shapes now, the “WE” letters and the heart. Let’s continue
    and add the final image to the project, the SwiftUI logo.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stroke animation on the SwiftUI logo image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have reached the final image, I would like to challenge you by letting
    you take this one on by yourself. Use the steps we have outlined in the previous
    two shapes – including removing backgrounds, vectorizing your image, and converting
    the image into Swift Code – and copy the code into a new SwiftUI View file called
    `SwiftUILogoView`.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, give it a try, and come back here when you’re ready…
  prefs: []
  type: TYPE_NORMAL
- en: How did you do?
  prefs: []
  type: TYPE_NORMAL
- en: After you vectorize a few shapes and gather the code, the process will become
    very familiar and much quicker. If you have used images other than the ones I
    supplied for this project, that’s perfectly fine; just know that the SwiftUI code
    for those images will be different from the code I will show here for the SwiftUI
    logo, but the animating code will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the SwiftUI code that I got back from Kite for the SwiftUI logo image
    (and as before, the full code file is available in the GitHub repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I have previously explained how this code creates a shape object in the *Creating
    a stroke animation on the “WE” image* section; if you would like a refresher on
    understanding how this works, go back to that section for the details on this
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move to the top of the file, inside the `SwiftUILogo` struct, and
    start adding the animation code. I will add the complete code for this final shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This animating code is the same code that we have been adding all along, and
    if you would like an explanation of how it works, go back to the “WE” shape code
    for all the details. The minor differences here are that the line is blue, and
    we are offsetting it lower on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Give this a run and check out the stroke around the logo.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the project is to combine all three of the shape structs onto
    the screen together. Let’s do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the animated strokes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is very little code needed for this, as we are just calling the three
    shape structs in one place. All you need to do is add the following code to the
    `ContentView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done here is called all three structs inside `ContentView`, used
    a `VStack` to line up the views vertically, and then added a black background
    at the end. When you run the code, you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: The finished project ](img/B18674_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: The finished project'
  prefs: []
  type: TYPE_NORMAL
- en: Now, all three views are animated as being outlined with different colors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nice job finishing this project! To create the finished animation, we learned
    how to turn bitmap images into vector files, and then how to turn those vector
    files into code that we can work with using SwiftUI. Also, we learned how to create
    and animate a moving outline around almost any shape using the `stroke` modifier
    and timers, and used animation in this project.
  prefs: []
  type: TYPE_NORMAL
- en: Using this project, you can play around with the values. You can make the stroke
    thicker or thinner, make it move faster or slower, and make it any color of the
    rainbow.
  prefs: []
  type: TYPE_NORMAL
- en: There are many applications for animating strokes in your apps, too. It can
    be used for logos, text, and brands, so that they stand out and get noticed; it
    can be used in game apps to bring the users’ attention to different areas of the
    screen or can be used anywhere you want to make an app come alive. The uses are
    only limited by your imagination.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to animate lines in a different way to
    create waves, and then put them together to make an ocean with an animating buoy,
    complete with sound effects.
  prefs: []
  type: TYPE_NORMAL
