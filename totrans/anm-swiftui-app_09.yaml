- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Animating Strokes around Shapes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在形状周围动画线条
- en: In this project, we will take three images, create outlines around them, and
    then animate strokes along those outlines. A stroke is a line that follows the
    outline (or contours) of a shape, which we can give any color and thickness and
    animate to move around the image.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将取三张图像，围绕它们创建轮廓，然后沿着这些轮廓动画线条。线条是跟随形状轮廓（或轮廓线）的线条，我们可以给它任何颜色和粗细，并动画化使其在图像周围移动。
- en: To do this, you’ll learn how to convert bitmap images into vector images using
    the Inkscape software, and then take those vectors and convert them into Swift
    code using Sketch and Kite. We will then insert this code back into Xcode so that
    we can start animating our project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您将学习如何使用Inkscape软件将位图图像转换为矢量图像，然后使用Sketch和Kite将这些矢量转换为Swift代码。然后我们将此代码插入Xcode中，以便我们可以开始动画化我们的项目。
- en: 'The following are the objectives for this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个项目的目标：
- en: Converting images into Swift code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像转换为Swift代码
- en: Animating images with the `stroke` modifier
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stroke`修饰符动画化图像
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the resources and finished project from the `Chapter 9` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub上的`第9章`文件夹下载资源和完成的项目：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: 'You will also need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要以下内容：
- en: 'The Remove Background software, which is a free online tool you can access
    here: [https://www.remove.bg/upload](https://www.remove.bg/upload)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The Remove Background软件，这是一个免费的在线工具，您可以通过以下链接访问：[https://www.remove.bg/upload](https://www.remove.bg/upload)
- en: 'Inkscape, which is free and you can install here: [https://inkscape.org/release/inkscape-1.2.1/](https://inkscape.org/release/inkscape-1.2.1/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Inkscape，它是免费的，您可以通过以下链接安装：[https://inkscape.org/release/inkscape-1.2.1/](https://inkscape.org/release/inkscape-1.2.1/)
- en: 'Sketch, which you can install here: [https://www.sketch.com/switch-to-sketch/](https://www.sketch.com/switch-to-sketch/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在此处安装Sketch：[https://www.sketch.com/switch-to-sketch/](https://www.sketch.com/switch-to-sketch/)
- en: 'Kite, which you can install here: [https://kiteapp.co](https://kiteapp.co)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在此处安装Kite：[https://kiteapp.co](https://kiteapp.co)
- en: Converting images into Swift code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像转换为Swift代码
- en: In order to create the three outlines that we need, we first have to convert
    images into vectors and then convert those vectors into Swift code. Why do we
    have to convert an image into Swift code?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们需要的三个轮廓，我们首先必须将图像转换为矢量，然后将这些矢量转换为Swift代码。为什么我们必须将图像转换为Swift代码？
- en: Well, in order to place an animating stroke around an image, we need a path
    for the animation to follow. When the image has been translated into code, it
    will then be easy to use Swift to follow the image outline.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，为了在图像周围放置动画线条，我们需要一个动画路径。当图像被转换为代码后，使用Swift跟随图像轮廓将变得容易。
- en: 'However, there’s a problem: bitmaps. A **bitmap**, also called a **raster image**,
    is a graphic that is created from different colored pixels, which together form
    an image. Bitmaps can be very simple, just made up of two colors (those would
    be black and white), or they can have many thousands or millions of colors that
    produce photograph-quality images. Some examples of bitmap formats that you will
    see use the file extensions PNG, JPEG, and TIFF. With a bitmap image, there is
    no defined outline for any code to follow, and thus it cannot have an animating
    stroke around it.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题：位图。**位图**，也称为**栅格图像**，是由不同颜色的像素组成的图形，这些像素组合在一起形成图像。位图可以非常简单，仅由两种颜色组成（那些将是黑色和白色），或者它们可以有数千或数百万种颜色，产生高质量的图像。您将看到的位图格式示例使用文件扩展名PNG、JPEG和TIFF。位图图像没有定义的轮廓供任何代码跟随，因此它不能在其周围有动画线条。
- en: '**Vector images**, on the other hand, are images created from code that have
    sharply defined edges and never get blurry like a bitmap when you zoom in on them.
    Since they are created with code, we can animate strokes around those images.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**矢量图像**，另一方面，是由代码创建的图像，具有锐利的边缘，并且在放大时永远不会像位图那样模糊。由于它们是用代码创建的，因此我们可以围绕这些图像动画线条。'
- en: 'If you want to animate a stroke around a bitmap image, there are three main
    steps that you need to undertake:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想围绕位图图像动画线条，您需要执行以下三个主要步骤：
- en: Removing the background of the image you want to use
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除您想要使用的图像的背景
- en: Vectorizing the image into an SVG file
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像矢量化为SVG文件
- en: Translating the SVG file into Swift code
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SVG文件转换为Swift代码
- en: So, let’s go through those steps now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Removing the image backgrounds
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many images have a white or colored background, and in many cases, the background
    is not needed. It’s easier to convert images into vectors if they are against
    a transparent background.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, the images that we will be using are an image of the word “WE,”
    an image of a heart, and an image of the SwiftUI logo. We will combine them in
    Swift so that they say, “We Love SwiftUI,” like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The images we will use in our project ](img/B18674_09_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The images we will use in our project'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: You can download these from the GitHub repository, where you will notice that
    the backgrounds have already been removed. However, if you are going to use your
    own images, you will need to do this yourself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We already explored how to remove backgrounds in [*Chapter 6*](B18674_06.xhtml#_idTextAnchor082)
    when we animated the girl on the swing. You can refer back to that chapter; however,
    to recap, you can use an online tool called Remove Background: [https://www.remove.bg/upload](https://www.remove.bg/upload).
    You just have to click **Upload Image** and choose the one you want to use. And
    that’s it – in about 20 seconds, the website’s algorithms will find the background
    and remove it, leaving only your subject. Then, all you have to do is download
    the new image file and you’re good to go.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use Mac’s Preview app to remove the background, or you
    can use paid software such as Affinity Designer. How you decide to remove the
    background is up to you; experiment and try to see what works best for the image
    you are using.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Also, although it’s not strictly necessary, it’s a good idea to crop your image,
    as we only want to work with the image and not any surrounding space. You can
    do this in pretty much any graphics editing program, including the Preview app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Now you can proceed to the next step, which is vectorizing the image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Vectorizing the images
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second step will be to create vectors from the bitmap image. To do this,
    we will need software with the proper algorithms to detect pixels, remove them,
    and replace them with code that will draw the shapes instead. The resulting code
    file will be a `.svg`) file. One of the best software options on the market is
    called Vector Magic. This software is easy to use and automates the vectorization
    process with a click of a button to start the process, but the downside is it
    costs around $300.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use Inkscape, which is free software that does a really
    good job of tracing out a bitmap image and converting all its parts into vectors.
    This is what we will use, and you can download the latest version (at the time
    of writing) from the following link: [https://inkscape.org/release/inkscape-1.2.1/](https://inkscape.org/release/inkscape-1.2.1/).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Even though Inkscape can work with color images, it’s usually better to have
    your images in black and white; the algorithms work better with these two colors.
    If you have color images, though, that’s not a problem – you can still convert
    them into black and white by using a graphics program such as Affinity Designer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Inkscape可以处理彩色图像，但通常最好将您的图像设置为黑白；这两种颜色算法效果更好。如果您有彩色图像，那也不是问题——您仍然可以使用像Affinity
    Designer这样的图形程序将它们转换为黑白。
- en: If you look at the images we are using for this project, two of them are in
    color, but that’s okay because they have a limited number of colors and are simple
    shapes. If you have more complicated shapes, for instance, such as a portrait
    photograph with many colors in it, then it’s better to convert them into black
    and white first.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们用于此项目的图像，其中有两个是彩色的，但这没关系，因为它们的颜色有限且形状简单。如果您有更复杂的形状，例如，包含许多颜色的肖像照片，那么最好先将它们转换为黑白。
- en: 'Once you have Inkscape installed, you can get started. Grab one of your images
    (in my case, I am choosing the “WE” image), right-click on it, and open it in
    Inkscape. You will see this pop-up window:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Inkscape，您就可以开始使用。选择您的一张图像（以我的情况为例，我选择了“WE”图像），右键单击它，并在Inkscape中打开。您将看到以下弹出窗口：
- en: '![Figure 9.2: Importing an image into Inkscape ](img/B18674_09_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：将图像导入Inkscape](img/B18674_09_02.jpg)'
- en: 'Figure 9.2: Importing an image into Inkscape'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：将图像导入Inkscape
- en: 'Set **Image Import Type** to **Embed**, **Image DPI** to **Default import resolution**,
    and **Image Rendering Mode** to **None (auto)**. Then, click **OK**. You will
    then see this screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将**图像导入类型**设置为**嵌入**，**图像DPI**设置为**默认导入分辨率**，**图像渲染模式**设置为**无（自动）**。然后，点击**确定**。您将看到以下屏幕：
- en: '![Figure 9.3: The Inkscape editor with our image ](img/B18674_09_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：带有我们图像的Inkscape编辑器](img/B18674_09_03.jpg)'
- en: 'Figure 9.3: The Inkscape editor with our image'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：带有我们图像的Inkscape编辑器
- en: Before continuing with the conversion, I want to show you how a bitmap looks
    close up. On your Mac trackpad, pinch and zoom in very close to the image; you
    will see pixelization and blurriness appear. This is one way you can tell whether
    the image is a bitmap and not a vector. (Of course, the file extension will also
    let you know whether it’s a bitmap or vector as well!)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续转换之前，我想向您展示位图近距离的样子。在您的Mac触摸板上，捏合并放大图像，您将看到像素化和模糊出现。这是您判断图像是位图而不是矢量的方法之一。（当然，文件扩展名也会让您知道它是位图还是矢量！）
- en: 'Next, select your image on the Inkscape canvas (you will know it’s been selected
    if you see black arrows around it), then go to the **Path** menu at the top of
    the screen, and choose **Trace Bitmap**. This will open up the **Preview** option
    on the right-hand side of Inkscape:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Inkscape画布上选择您的图像（如果您看到它周围有黑色箭头，则表示已选择），然后转到屏幕顶部的**路径**菜单，并选择**追踪位图**。这将打开Inkscape右侧的**预览**选项：
- en: '![Figure 9.4: Inkscape Preview ](img/B18674_09_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：Inkscape预览](img/B18674_09_04.jpg)'
- en: 'Figure 9.4: Inkscape Preview'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：Inkscape预览
- en: In the **Preview** window, Inkscape shows us what the **Trace Bitmap** function
    will be able to trace, and what the image will look like as a vector graphic.
    Since the preview looks nearly identical to the “WE” image on the canvas, there
    will be a complete outline around the image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在**预览**窗口中，Inkscape向我们展示了**追踪位图**功能将能够追踪的内容，以及图像作为矢量图形将看起来像什么。由于预览看起来几乎与画布上的“WE”图像相同，因此图像周围将有一个完整的轮廓。
- en: You can’t see the vector lines and points just yet in the preview, but you will
    shortly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览中，您目前还看不到矢量线条和点，但很快就会看到。
- en: Since we are using a black and white image, Inscape has selected the **Single
    scan** option from the top of the **Preview** window (which you can see in *Figure
    9**.5*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是黑白图像，Inscape已经从**预览**窗口的顶部选择了**单次扫描**选项（您可以在*图9.5*中看到）。
- en: '![Figure 9.5: The Inkscape scan option ](img/B18674_09_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：Inkscape扫描选项](img/B18674_09_05.jpg)'
- en: 'Figure 9.5: The Inkscape scan option'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：Inkscape扫描选项
- en: The **Single scan** option is used for black and white images, but if we use
    a multicolored image, then we need to select the **Multicolor** option. The **Multicolor**
    option will scan your image, looking at the many colors it contains, and do its
    best to trace an outline around each of those colors. This is why I said earlier
    that it’s usually better to have a black-and-white image, as there are fewer colors
    to scan and thus less chance of not getting a good trace.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**单扫描**选项用于黑白图像，但如果我们使用彩色图像，则需要选择**多色**选项。**多色**选项将扫描您的图像，查看其中包含的多种颜色，并尽可能为每种颜色绘制轮廓。这就是我之前说通常最好使用黑白图像的原因，因为扫描的颜色较少，因此无法获得良好轮廓的机会也较少。'
- en: As highlighted in *Figure 9**.5*, you can also adjust the **Threshold** and
    **Details** sliders to get the best possible image in the previews. These sliders
    are useful if Inkscape is having difficulty getting a good scan. By moving the
    sliders, you can fine-tune the parts of the image that Inkscape can see.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 9.5*所示，您还可以调整**阈值**和**细节**滑块以在预览中获得最佳图像。如果 Inkscape 难以获得良好的扫描，这些滑块非常有用。通过移动滑块，您可以微调
    Inkscape 可以看到的图像部分。
- en: 'Let’s look at the **Details** sliders:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看**细节**滑块：
- en: The **Speckles** slider will ignore the small spots in the vector – when set
    to maximum, it will ignore more speckles, and when set to minimum, it will ignore
    fewer speckles.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**斑纹**滑块将忽略向量中的小点——当设置为最大时，它将忽略更多的斑纹，而当设置为最小时，它将忽略较少的斑纹。'
- en: The **Smooth corners** slider will smooth out any sharp corners that are in
    the trace.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平滑角落**滑块将平滑掉追踪中的任何尖锐角落。'
- en: The **Optimize** slider will try to optimize paths by joining adjacent Bezier
    curve segments together; this means that the **Optimize** slider will try its
    best to remove as many vector nodes as it can. When you have fewer nodes in a
    vector image, there tends to be better tracing and fewer jagged edges.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化**滑块将尝试通过连接相邻的贝塞尔曲线段来优化路径；这意味着**优化**滑块将尽力移除尽可能多的向量节点。当向量图像中的节点较少时，往往会有更好的追踪和较少的锯齿边缘。'
- en: We will see the **Threshold** slider later when creating a stroke around the
    heart.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建围绕心脏的描边时看到**阈值**滑块。
- en: What we want to see in the preview is an image that is as close to the one in
    the center canvas as possible. When we do see this, it means that Inkscape can
    trace all around the shape on the canvas correctly and capture all the vector
    lines. If you don’t see an image that’s close to the original, then try and adjust
    some of the sliders I just mentioned to fine-tune the output.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在预览中看到尽可能接近中心画布中图像的图像。当我们看到这种情况时，这意味着 Inkscape 可以正确追踪画布上的形状并捕获所有向量线条。如果您没有看到接近原始图像的图像，那么请尝试调整我刚才提到的某些滑块以微调输出。
- en: 'Once you have finished adjusting the image so it looks close to the original,
    click **Update Preview**, and then **Apply**. Inkscape places its newly created
    vectors directly over the original image. To see the result, click on the “WE”
    image in the editor and drag the new vectors to the side:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您调整完图像，使其看起来接近原始图像，请点击**更新预览**，然后**应用**。Inkscape 将其新创建的向量直接放置在原始图像上方。要查看结果，请在编辑器中点击“WE”图像，并将新向量拖到一边：
- en: '![Figure 9.6: Creating the vectors ](img/B18674_09_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6：创建向量](img/B18674_09_06.jpg)'
- en: 'Figure 9.6: Creating the vectors'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：创建向量
- en: You can now delete the original image, as it is no longer needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以删除原始图像，因为它不再需要了。
- en: 'Let’s have a look at what Inkscape has done for us – it has traced the original
    image and created a new image that is now made of vector paths. To see the difference,
    pinch and zoom on your Mac trackpad on the new vector image as you did with the
    bitmap image. Do you see the difference? There is no pixelation or blurriness
    at all, as the image is created with code rather than pixels; the image can be
    blown up to any size and it will still remain sharp and crisp along its edges
    and curves:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Inkscape 为我们做了什么——它追踪了原始图像，并创建了一个由向量路径组成的新图像。为了查看差异，请在 Mac 触控板上用您查看位图图像的方式缩放和捏合新的向量图像。您看到差异了吗？图像完全没有像素化或模糊，因为图像是用代码而不是像素创建的；图像可以放大到任何大小，并且它的边缘和曲线仍然保持清晰：
- en: '![Figure 9.7: Vector resolution ](img/B18674_09_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7：向量分辨率](img/B18674_09_07.jpg)'
- en: 'Figure 9.7: Vector resolution'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：向量分辨率
- en: 'Now, remember that I mentioned that you will be able to see the vectors that
    Inkscape has created? Well, they are there, it’s just that we need to select the
    right editing tool to see them. Select the image in the center of the canvas,
    go to the left toolbar, and select the **Node Editing** tool. When you click on
    that tool, you will be able to see all the vector lines that Inkscape created:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记得我提到过您将能够看到 Inkscape 创建的矢量吗？好吧，它们确实在那里，只是我们需要选择正确的编辑工具来查看它们。选择画布中央的图像，转到左侧工具栏，并选择**节点编辑**工具。当您点击该工具时，您将能够看到
    Inkscape 创建的所有矢量线条：
- en: '![Figure 9.8: The vectors ](img/B18674_09_08.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8：矢量](img/B18674_09_08.jpg)'
- en: 'Figure 9.8: The vectors'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：矢量
- en: Each of those small squares is a point (or node) that links lines, curves, and
    corners to make this new shape – and these points can now be edited by clicking
    on them and dragging them to any location to reshape the vector image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小正方形中的每一个都是一个点（或节点），它将线条、曲线和角落连接起来，形成这个新形状——并且现在可以通过点击它们并将它们拖动到任何位置来编辑这些点，以重塑矢量图像。
- en: 'With the new vectors created, we can export them. To do this, open **File**
    at the top menu and choose **Export**. Then, you can choose the export options
    at the bottom right of the software. Choose the file type that you want to export
    to – we want a **Plain SVG (*.svg)** file. Then, click on the **Export** button:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了新的矢量后，我们可以将其导出。为此，在顶部菜单中打开**文件**，然后选择**导出**。然后，您可以在软件的右下角选择导出选项。选择您想要导出的文件类型——我们想要一个**纯
    SVG (*.svg**) 文件。然后，点击**导出**按钮：
- en: '![Figure 9.9: Exporting to an SVG file ](img/B18674_09_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9：导出为 SVG 文件](img/B18674_09_09.jpg)'
- en: 'Figure 9.9: Exporting to an SVG file'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：导出为 SVG 文件
- en: Now, we have an SVG file stored on our computer, ready to be translated into
    Swift code. Do the same process for any of the other images that you want to use
    in this project – whether you are using your own images or following along with
    the book’s project images – and then you can proceed to the next step.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在电脑上存储了一个 SVG 文件，准备将其转换为 Swift 代码。对于您想要在这个项目中使用的任何其他图像，执行相同的过程——无论您是使用自己的图像还是跟随书中的项目图像——然后您可以继续下一步。
- en: Translating the SVG file into Swift code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 SVG 文件转换为 Swift 代码
- en: Let’s continue. We have an SVG file ready for the next step. An **SVG** file
    is a file written in XML, and **XML** is a markup language used for storing and
    transferring digital information. The XML code in an SVG file creates all of the
    shapes, colors, and text that comprise the image. We will be turning that XML
    code into Swift code shortly, but first, we need to edit the images’ dimensions
    and we can do that in Sketch.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续。我们有一个准备进行下一步的 SVG 文件。**SVG** 文件是一种以 XML 编写的文件，**XML** 是一种用于存储和传输数字信息的标记语言。SVG
    文件中的 XML 代码创建了构成图像的所有形状、颜色和文本。我们将很快将那个 XML 代码转换为 Swift 代码，但首先，我们需要编辑图像的尺寸，我们可以在
    Sketch 中完成这项操作。
- en: 'So, first, open the SVG “WE” image in Sketch. Then, in the **Utilities** area
    on the right, we can size the image however we like; in my case, I have set the
    width to **250**. To set this, make sure that the little lock icon in between
    the width and height fields is selected so that it’s locked – this will keep the
    correct proportions for the image – and hit *Enter*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，在 Sketch 中打开 SVG “WE” 图像。然后，在右侧的**实用工具**区域，我们可以按自己的喜好调整图像大小；在我的情况下，我将宽度设置为**250**。要设置此值，请确保在宽度和高度字段之间的那个小锁形图标被选中，以便锁定——这将保持图像的正确比例——然后按*Enter*：
- en: '![Figure 9.10: Sizing the image ](img/B18674_09_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10：调整图像大小](img/B18674_09_10.jpg)'
- en: 'Figure 9.10: Sizing the image'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：调整图像大小
- en: And that’s all we need to do in Sketch. Now, minimize your Sketch document (but
    don’t close it!).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sketch 中，我们所需做的就这些了。现在，最小化您的 Sketch 文档（但不要关闭它！）。
- en: Next, we need a program that can turn XML code into Swift code. One option is
    Paint Code – although it is a great program, it costs around $200 per year for
    a subscription. Instead, we will use Kite – although this is currently $99 to
    buy outright with no subscription, you can always use the free trial to follow
    along with this project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个可以将 XML 代码转换为 Swift 代码的程序。一个选项是 Paint Code——尽管这是一个很棒的程序，但每年订阅费用约为
    200 美元。相反，我们将使用 Kite——尽管目前一次性购买价格为 99 美元，无需订阅，您始终可以使用免费试用版来跟随这个项目。
- en: 'So, open up Kite. Then, click on **File** | **Import** | **From Sketch…**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开 Kite。然后，点击**文件** | **导入** | **从 Sketch…**：
- en: '![Figure 9.11: Importing from Sketch into Kite ](img/B18674_09_11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11：从 Sketch 导入到 Kite](img/B18674_09_11.jpg)'
- en: 'Figure 9.11: Importing from Sketch into Kite'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11：从 Sketch 导入到 Kite
- en: 'You will then see a pop-up window asking how you would like to import the layers.
    Leave the default settings as they are, but make sure that **Import text layers
    as** is set to **Image Layers** and that **Import images at** is set to a scale
    of **1x**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个弹出窗口询问你如何导入图层。保留默认设置不变，但请确保 **导入文本图层为** 设置为 **图像图层**，并且 **导入图像的缩放** 设置为
    **1x**：
- en: '![Figure 9.12: Import From Sketch settings ](img/B18674_09_12.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12：从 Sketch 导入设置](img/B18674_09_12.jpg)'
- en: 'Figure 9.12: Import From Sketch settings'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12：从 Sketch 导入设置
- en: 'Then, click on **Import**. You now have your image in Kite and are ready to
    turn it into Swift code, and that process is as simple as clicking one button,
    the **Code** button, at the top of the screen:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击 **导入**。现在你的图像已经在 Kite 中，并且准备好将其转换为 Swift 代码，这个过程就像点击屏幕顶部的 **代码** 按钮一样简单：
- en: '![Figure 9.13: Converting the file into Swift code ](img/B18674_09_13.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13：将文件转换为 Swift 代码](img/B18674_09_13.jpg)'
- en: 'Figure 9.13: Converting the file into Swift code'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13：将文件转换为 Swift 代码
- en: 'The Swift code that is generated shows up in the bottom console, which you
    can resize like the Xcode console by dragging it upwards. Here is what the code
    console looks like for the “WE” image, containing all the Swift code that makes
    up its length, thickness, colors, position, and more:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 Swift 代码显示在底部的控制台中，你可以通过向上拖动来调整它的大小，就像调整 Xcode 控制台一样。以下是“WE”图像的代码控制台外观，其中包含构成其长度、粗细、颜色、位置等所有
    Swift 代码：
- en: '![Figure 9.14: The generated Swift code in Kite ](img/B18674_09_14.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14：Kite 生成的 Swift 代码](img/B18674_09_14.jpg)'
- en: 'Figure 9.14: The generated Swift code in Kite'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：Kite 生成的 Swift 代码
- en: That looks like a lot of code just to create an image with two letters, doesn’t
    it? Well, yes, but there are a lot of things the code is doing – it’s mapping
    out all the paths needed to create the lines and curves that form the shape.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是创建一个由两个字母组成的图像需要很多代码，不是吗？嗯，是的，但代码做了很多事——它绘制出创建线条和曲线形状所需的所有路径。
- en: 'Let’s now get this code into Xcode. First, create a new Xcode project if you
    haven’t done so already – I’ve called it **Animating Strokes**. Then, all we have
    to do is copy a small segment of it from Kite. You should copy the code starting
    from here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这段代码放入 Xcode 中。首先，如果你还没有创建一个新的 Xcode 项目，请创建一个——我将其命名为 **Animating Strokes**。然后，我们只需要从
    Kite 中复制一小段代码。你应该从这里开始复制代码：
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And continue all the way down the file until you reach these two lines:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后继续向下浏览文件，直到你到达这两行：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, we just want to copy all the code that starts with `pathPath`; everything
    else we don’t need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只想复制以 `pathPath` 开头的所有代码；其他我们不需要。
- en: Now, before we enter Xcode, let’s summarize what we have done so far. We have
    taken a bitmap image, removed its background and cropped it, opened it with Inkscape
    and turned it into a vector image, and then finally imported that vector into
    Kite, where we turned it into Swift code. This process will get faster with more
    practice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们进入 Xcode 之前，让我们总结一下到目前为止我们所做的工作。我们取了一个位图图像，移除了它的背景并裁剪了它，用 Inkscape 打开它并将其转换为矢量图像，然后最后将这个矢量图像导入到
    Kite 中，在那里我们将其转换为 Swift 代码。随着练习的增多，这个过程会变得更快。
- en: Let’s now proceed to Xcode and start making all this code work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入 Xcode 并开始让所有这些代码工作。
- en: Animating images with the stroke modifier
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用笔画修改器动画图像
- en: In the following sections, we will be working in Xcode and refactoring the “WE”
    code somewhat in order to make it work in our project. We will use the Shape protocol
    that lets us draw a 2D shape using its `path()` function, and then use the `stroke`
    modifier to add a moving line around the path of our shapes. We will also get
    started on animating our heart and SwiftUI logo images.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将在 Xcode 中工作，并对“WE”代码进行一些重构，以便使其在我们的项目中工作。我们将使用允许我们使用其 `path()` 函数绘制
    2D 形状的 Shape 协议，然后使用 `stroke` 修改器在形状的路径周围添加移动的线条。我们还将开始动画我们的心形和 SwiftUI 标志图像。
- en: Creating a stroke animation on the “WE” image
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在“WE”图像上创建笔画动画
- en: To start animating the “WE” image, we need to create a file inside the project.
    Press *Command + N*, choose a `WeView`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始动画“WE”图像，我们需要在项目中创建一个文件。按 *Command + N*，选择一个 `WeView`。
- en: 'Then, create a struct at the bottom of the file; this will be the struct that
    conforms to the shape protocol, allowing us to create 2D shapes by using the `path`
    function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在文件底部创建一个结构体；这将是一个符合形状协议的结构体，允许我们通过使用 `path` 函数创建 2D 形状：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can paste in the code that we copied from the Kite program and place
    it right into that `path` function. This code is quite repetitive and long, as
    it is drawing a shape and must repeat itself for every line, curve, and corner.
    So, for the sake of brevity and to not take up too much space, I will just provide
    the beginning and end of the code (however, you can find the complete code in
    the GitHub repo):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们从Kite程序中复制的代码粘贴到`path`函数中。这段代码相当重复且冗长，因为它在绘制形状时必须对每一行、曲线和角落重复。因此，为了简洁并节省空间，我只会提供代码的开始和结束部分（然而，你可以在GitHub仓库中找到完整的代码）：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you paste the code into Xcode, you will get some errors – don’t worry about
    these, as the code needs to be reworked a little bit anyway.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将代码粘贴到Xcode中时，你将得到一些错误——不要担心这些错误，因为代码需要稍作修改。
- en: Fixing these issues is also a good excuse for me to show you how to refactor
    code in SwiftUI. Refactoring is a helpful feature that allows us to rename code
    or remove and replace different parts of code throughout multiple files in your
    project without having to search through all your files looking for each instance
    that needs refactoring and manually changing it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题也是我向您展示如何在SwiftUI中重构代码的好借口。重构是一个有用的功能，它允许我们在项目的多个文件中重命名代码或删除和替换代码的不同部分，而无需搜索所有文件以查找需要重构的每个实例并手动更改它。
- en: One thing we want to change is the name of the `pathPath` constant, which is
    the first line of code inside the `path` function that was pasted in. This constant
    seems to have been named twice because it was exported from Inkscape. However,
    it should simply be named `path`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要更改的一件事是`pathPath`常量的名称，这是粘贴到`path`函数中的第一行代码。这个常量似乎被命名了两次，因为它是从Inkscape导出的。然而，它应该简单地命名为`path`。
- en: So, to refactor this, just *Command + click* on the `pathPath` variable and
    select `pathPath` in the file, and all you have to do is just type in the new
    name, `path`, and hit *Enter*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了重构这段代码，只需*Command + click*点击`pathPath`变量，并在文件中选择`pathPath`，然后你只需输入新的名称`path`并按*Enter*键。
- en: That’s our first revision of the code that we copied over. The next revision
    is to change the class that’s being assigned to the `path` constant. Currently,
    the `path` constant is assigned as a `CGMutablePath()` instance, which is a core
    graphics class used for drawing shapes and lines. Working in SwiftUI though, nearly
    everything is built with structs, so we need to use the `Path()` struct instead.
    Also, change the `let` keyword to the `var` keyword, because we need the `path`
    variable to be mutable, meaning its value can be changed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对复制的代码所做的第一次修订。下一次修订是更改分配给`path`常量的类。目前，`path`常量被分配为一个`CGMutablePath()`实例，这是一个用于绘制形状和线条的核心图形类。但在SwiftUI中工作，几乎所有内容都是用结构体构建的，因此我们需要使用`Path()`结构体。此外，将`let`关键字更改为`var`关键字，因为我们需要`path`变量是可变的，这意味着其值可以被更改。
- en: 'With those modifications done, the first line of the code in your path function
    should look like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些修改后，你的`path`函数中的第一行代码应该如下所示：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s add one more line of code to this `path` function. At the very end
    of the function, we need to return the `path` variable, and to do so, we use the
    `return` keyword, followed by the variable the function must return; so, add this
    line at the bottom of the `path` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向这个`path`函数添加一行代码。在函数的末尾，我们需要返回`path`变量，为此，我们使用`return`关键字，后面跟着函数必须返回的变量；因此，在`path`函数的底部添加此行：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following are the changes we made to the start and end of the `path` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们对`path`函数开始和结束部分所做的更改：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you press *Command + B*, the code should be error-free.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下*Command + B*时，代码应该是无错误的。
- en: Now let’s see what all of that Kite code is actually doing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看所有这些Kite代码实际上在做什么。
- en: The `path()` function will return a shape according to the points, lines, and
    curves that are drawn inside it. The first line of code inside the `path()` function
    is creating a path instance; this will draw the shape, and you can think of this
    variable as the pencil moving along the canvas.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`path()`函数将根据在内部绘制的点、线和曲线返回一个形状。`path()`函数内的第一行代码是创建一个路径实例；这将绘制形状，你可以将这个变量想象成在画布上移动的铅笔。'
- en: The second line of code is the `move()` function. This is what sets the starting
    location for the `path` variable to move to. The locations are based on the Cartesian
    coordinate system and an X and Y location are used to position the `path` variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二行是`move()`函数。这是设置`path`变量移动到起始位置的方法。位置基于笛卡尔坐标系，使用X和Y位置来定位`path`变量。
- en: In the third line of code, the `path` variable calls the `addCurve()` function,
    and this does what it says – it adds a Bezier curve to the path using the specified
    points. Continuing down our code, we see that the `path` variable also calls the
    `addLine()` function, and this will add a line to the path using the specified
    points. The code continues to call these two functions, `addCurve()` and `addLine()`,
    quite a bit until the `path` variable needs to finish off a particular path in
    the drawing and close off the ends of that finished line before moving on to the
    next line in the drawing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行代码中，`path`变量调用`addCurve()`函数，它做了它所说的——使用指定的点在路径上添加一个贝塞尔曲线。继续向下查看我们的代码，我们看到`path`变量还调用了`addLine()`函数，这将使用指定的点在路径上添加一条线。代码继续调用这两个函数，`addCurve()`和`addLine()`，直到`path`变量需要完成绘图中的特定路径并在移动到绘图中的下一行之前关闭完成线的末端。
- en: The finished line is closed off using the `closeSubpath()` function and directly
    proceeded by the `moveTo()` function to start a new line in the drawing. So, as
    you can see, there are several lines drawn in this code to make up the finished
    shape.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`closeSubpath()`函数关闭完成线条，然后直接使用`moveTo()`函数开始绘制新的一行。所以，正如你所看到的，在这段代码中有几行用来组成完成形状。
- en: And finally, at the end of all this code, the `path()` function returns the
    `pat`h variable, which now contains a finished shape inside of it, ready to be
    displayed on the iPhone screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有这些代码的末尾，`path()`函数返回包含完成形状的`path`变量，现在它可以在iPhone屏幕上显示。
- en: Next, continuing to work in the same file, we need to come into the `WEView`
    struct and add the code to display this shape.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，继续在同一文件中工作，我们需要进入`WEView`结构体并添加代码以显示此形状。
- en: 'Starting at the top of the struct, add the following variables:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构体的顶部开始，添加以下变量：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, inside the `body` property, add a `ZStack`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`body`属性内部，添加一个`ZStack`：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the `ZStack`, let’s add a `Group`, and then the following code to display
    the shape in the preview:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ZStack`内部，让我们添加一个`Group`，然后添加以下代码以在预览中显示形状：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside `Group`, we call the `WeTextShape` struct and add the `stroke` modifier
    directly to it. This modifier will create a new shape that has a stroke on it,
    which is styled according to the `StrokeStyle` function. The `StrokeStyle` function
    adds a `lineWidth` property of `0.5`, and sets both `lineCap` (the ends of the
    stroke) and `lineJoin` to `round`; this joins the ends of the stroke with a semi-circular
    arc. Finally, the color of the stroke shape is set to `gray`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Group`内部，我们调用`WeTextShape`结构体，并直接对其添加`stroke`修饰符。这个修饰符将创建一个新的形状，其上有一个带有样式的描边，该样式根据`StrokeStyle`函数进行设置。`StrokeStyle`函数添加了一个`lineWidth`属性值为`0.5`，并将`lineCap`（描边的末端）和`lineJoin`都设置为`round`；这通过半圆形弧线连接描边的末端。最后，描边形状的颜色被设置为`gray`。
- en: This completes the shape – we won’t add any animation to it, as we just want
    it to be a stationary shape. Instead, we will add this shape again, directly over
    the first one, and that’s the one we will animate in color. Let’s add that now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了形状的创建——我们不会为它添加任何动画，因为我们只想让它保持静止。相反，我们将在第一个形状的正上方再次添加这个形状，这是我们将在颜色上动画化的形状。现在让我们添加它。
- en: 'Continuing inside the `Group` view, and directly under the last line of code,
    add the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Group`视图内部继续，并在最后一行代码下方直接添加以下内容：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And that’s the code that will add a second shape, identical to the first one,
    directly over it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将在第一个形状正上方添加第二个形状，与第一个形状完全相同的代码。
- en: As we did for the non-moving shape, we called the `WeTextView` struct to create
    the shape. Then, we used the `trim` modifier to trim the shape by a fractional
    amount based on the values that get passed into its parameters. By passing in
    the `startStroke` variable as the location of the start of the stroke animation
    and the `endStroke` variable to tell the `trim` modifier where to stop, a stroked
    line will be drawn along the shape’s path from start to end. The length of that
    stroke line will depend on the values inside the `startStroke` and `endStroke`
    variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对非移动形状所做的那样，我们调用了 `WeTextView` 结构体来创建形状。然后，我们使用 `trim` 修饰符根据传递给其参数的值以分数形式修剪形状。通过传递
    `startStroke` 变量作为笔触动画的起始位置，以及 `endStroke` 变量来告诉 `trim` 修饰符在哪里停止，将在形状路径上从起点到终点绘制一条笔触线。这条笔触线的长度将取决于
    `startStroke` 和 `endStroke` 变量内部的值。
- en: As we did with the first shape, we also used the `strokeStyle` modifier to style
    the stroke with a `width` property of `5`, and `lineCap` and `lineJoin` set to
    `round`. This time, we set the color to `red` so that the moving stroke will stand
    out as it travels along the gray shape underneath it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对第一个形状所做的那样，我们也使用了 `strokeStyle` 修饰符来使用 `width` 属性为 `5` 的 `width` 属性和将 `lineCap`
    和 `lineJoin` 设置为 `round` 来样式化笔触。这次，我们将颜色设置为 `red`，以便移动的笔触在沿着其下方的灰色形状移动时更加突出。
- en: Then, finally, we’re using the `offset` modifier to center the shape inside
    the preview in the middle from left to right, and toward the top of the iPhone.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后，我们使用 `offset` 修饰符将形状在预览中从左到右居中，并朝向iPhone的顶部。
- en: 'Now, the code for the outline and animating the stroke are complete. What’s
    needed next is to use the `onAppear` modifier to start the animation and set up
    some timers so that the stroke can proceed at a certain speed. Add the final bit
    of code right after the closing brace of the `ZStack`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，轮廓和笔触动画的代码已经完成。接下来需要使用 `onAppear` 修饰符来启动动画并设置一些计时器，以便笔触可以以一定的速度进行。在 `ZStack`
    的闭合花括号后添加最后一段代码：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code might look a little busy to grasp at first, but let’s break it down
    for clarity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码一开始可能看起来有些复杂，但让我们来分解它以便理解。
- en: The `onAppear()` method is called on the `ZStack` container; this method is
    triggered when the view appears on the screen. Inside the method, a timer is scheduled
    using the `Timer.scheduledTimer` method, which is set to repeat every `0.23` seconds.
    This is the amount of time it takes for the animation to draw each stroke segment.
    A stroke segment is how we draw out the shape, in segments, one at a time. You
    can experiment with this timer’s interval value – a larger number will draw the
    stroke segments slower, and a smaller number will draw the segments faster, creating
    a smooth animating line around the shape.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ZStack` 容器上调用 `onAppear()` 方法；这个方法在视图出现在屏幕上时被触发。在方法内部，使用 `Timer.scheduledTimer`
    方法安排了一个计时器，设置为每 `0.23` 秒重复一次。这是动画绘制每个笔触段所需的时间。笔触段是我们一次绘制形状的方式，一次绘制一个段。你可以尝试调整这个计时器的间隔值——较大的数字将使笔触段绘制得更慢，而较小的数字将使段绘制得更快，从而在形状周围创建一条平滑的动画线。
- en: Next, we want the animation to repeat, so we set the `repeats` parameter to
    `true`. Within the timer’s event handler, the code first checks whether the `endStroke`
    variable is greater than or equal to `1`. If this is true, the code then checks
    whether the `strokeReset` variable is `true`. If both of these conditions are
    met, another timer is scheduled using the `Timer.scheduledTimer` method. This
    timer is set to run only once, after `0.6` seconds, and within this timer’s event
    handler, the values of `endStroke` and `startStroke` are reset to `0`, so the
    stroke animation can once again start at the beginning, and the `strokeReset`
    variable is toggled. After the inner timer is scheduled, the `strokeReset` variable
    is set to `false`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望动画能够重复，因此将 `repeats` 参数设置为 `true`。在计时器的处理程序中，代码首先检查 `endStroke` 变量是否大于或等于
    `1`。如果是这样，代码接着检查 `strokeReset` 变量是否为 `true`。如果这两个条件都满足，就使用 `Timer.scheduledTimer`
    方法安排另一个计时器。这个计时器设置为在 `0.6` 秒后只运行一次，在这个计时器的处理程序中，将 `endStroke` 和 `startStroke`
    的值重置为 `0`，这样笔触动画就可以再次从开始处开始，并且 `strokeReset` 变量被切换。在安排内部计时器后，将 `strokeReset` 变量设置为
    `false`。
- en: The `withAnimation` function is different from the animation modifier we have
    used in past projects. Remember in [*Chapter 2*](B18674_02.xhtml#_idTextAnchor034),
    when we talked about the two types of animations, *implicit* and *explicit*? The
    `withAnimation` function is an explicit type of animation and is used to animate
    changes to the view’s state. It is considered an explicit animation because it
    requires you to specify the animation that you want to use, as opposed to an implicit
    animation, which would automatically animate changes without the need for additional
    code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`withAnimation`函数与我们过去项目中使用的动画修饰符不同。记得在[*第二章*](B18674_02.xhtml#_idTextAnchor034)，当我们讨论两种类型的动画，*隐式*和*显式*时？`withAnimation`函数是一种显式类型的动画，用于动画化视图状态的变化。它被认为是一种显式动画，因为它要求你指定你想要使用的动画，而不是隐式动画，后者会自动动画化变化，无需额外的代码。'
- en: So, in the body of the `withAnimation` function, we set the `endStroke` variable
    to increase its value by `0.12` after every iteration of the animation. We also
    set `startStroke` to a value that is calculated by subtracting `0.4` from `endStroke`
    – this computation creates the length and speed of an animating stroke that I
    think looks pretty good for the “We” shape.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`withAnimation`函数的主体中，我们在动画的每次迭代后都将`endStroke`变量的值增加`0.12`。我们还设置了`startStroke`的值，该值是通过从`endStroke`中减去`0.4`计算得出的——这种计算方式创建了一个动画笔画的长度和速度，我认为对于“我们”形状来说看起来相当不错。
- en: And with that, this animation is complete. So, to summarize the code in the
    `WeView` struct, it creates a view that animates a shape, this shape is outlined
    twice, once with a gray color and a small stroke, and then again, with a red color
    and a bigger stroke. The animation is controlled by the `startStroke` and `endStroke`
    variables, which are incremented over time. The animation will be repeated once
    the `endStroke` variable reaches `1`, and there is a `0.6`-second delay before
    the animation starts again.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，这个动画就完成了。所以，为了总结`WeView`结构体中的代码，它创建了一个动画形状的视图，这个形状被勾勒了两次，一次是灰色和细笔画，然后再次，是红色和大笔画。动画由`startStroke`和`endStroke`变量控制，这些变量随时间增加。一旦`endStroke`变量达到`1`，动画就会重复一次，并且在动画再次开始之前有一个`0.6`秒的延迟。
- en: Now that we have finished with the code, if you click on the `endStroke` in
    the `withAnimation` function, you can leave more of the stroke line on the shape
    or less of it, depending on the look you want to go for.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了代码，如果你点击`withAnimation`函数中的`endStroke`，你可以根据你想要的视觉效果在形状上留下更多的笔画线或者更少。
- en: Play around with the values and experiment. You can create a flashing stroke
    by increasing the speed, or you can have a very slow-moving stroke. You can stroke
    the entire shape with a short line, or you can go with a very long line along
    the whole shape.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整数值并进行实验。你可以通过增加速度来创建闪烁的笔画，或者你可以有一个非常缓慢移动的笔画。你可以用短线条勾勒整个形状，或者你可以沿着整个形状使用非常长的线条。
- en: That completes our first animation, the “WE” image stroke. Even though that
    seems like a long process, the whole thing actually only takes a few minutes once
    you get familiar with the different programs and techniques used. We are going
    to move on to the heart image now and repeat the same process. After all, practice
    makes perfect!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第一个动画，“WE”图像的笔画。尽管这个过程看起来很复杂，但一旦你熟悉了不同的程序和技术，整个过程实际上只需要几分钟。我们现在将转向心形图像，并重复同样的过程。毕竟，熟能生巧！
- en: Creating a stroke animation on the heart image
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在心形图像上创建笔画动画
- en: Okay, we have animated our first image, so we are going to follow the same process
    again for two more images. The next image will be a heart – for this one, we will
    animate a stroke around it as we did with the letters, but also we will add the
    heart image back into the scene.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经动画化了我们的第一张图像，所以我们将对另外两张图像重复同样的过程。下一张图像将是一个心形——对于这个，我们将像处理字母一样在它周围动画化一个笔画，但也会将心形图像重新添加到场景中。
- en: If you are following along with the book’s project, you can find the heart image
    in the GitHub repository, where the background has already been removed. However,
    if you are using your own images, you will need to do this yourself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随书中的项目，你可以在GitHub仓库中找到心形图像，其中背景已经被移除。然而，如果你使用自己的图像，你需要自己完成这项工作。
- en: After you have prepared your image, now open it with Inkscape so that you can
    vectorize it. With the image selected in the editor, go to the **Path** menu at
    the top and choose **Trace Bitmap**; this will trace the image and prepare it
    for vectorization, as before.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在你准备好了你的图像后，现在用Inkscape打开它，以便你可以将其矢量化。在编辑器中选择图像后，转到顶部的**路径**菜单并选择**追踪位图**；这将追踪图像并为其矢量化做准备，就像之前一样。
- en: With the image selected on the canvas, if you look at the **Previews** pane
    at the right, the image has been converted into black and white. That’s because,
    by default, Inkscape selects the **Single Scan** option, the option for black-and-white
    images. And even though this is a color image, because it’s such a simple shape
    with not many variations of red in it, we don’t need the **Multicolor** option;
    so, **Single scan** will work fine here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上选择图像后，如果你查看右侧的**预览**面板，图像已被转换为黑白。这是因为默认情况下，Inkscape选择**单扫描**选项，黑白图像的选项。尽管这是一个彩色图像，但由于它是一个形状简单且红色变化不多的图像，我们不需要**多彩色**选项；所以，**单扫描**在这里就足够了。
- en: This is also a good opportunity to use the **Smooth Corners** option as well
    because this shape has (for the most part) smooth corners, and this selection
    will preserve them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的机会来使用**平滑角落**选项，因为这个形状（大部分）有平滑的角落，这个选择将保留它们。
- en: 'This is what it should look like so far:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是到目前为止应该看起来的样子：
- en: '![Figure 9.15: The heart image in Inkscape ](img/B18674_09_15.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15：Inkscape中的心形图像](img/B18674_09_15.jpg)'
- en: 'Figure 9.15: The heart image in Inkscape'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：Inkscape中的心形图像
- en: 'Also, do you notice that the heart image shown in **Preview** has two white
    areas inside it? That’s the Inkscape algorithm trying to capture the shiny parts
    of the red heart image on the canvas. We only want to trace the outside perimeter
    of the heart, which is the area that will be outlined later in the code – we don’t
    want those white areas. To remove those white areas in the preview, slide the
    **Threshold** slider to the right, just enough so the heart fills up like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你注意到在**预览**中显示的心形图像内部有两个白色区域吗？那是Inkscape算法试图捕捉画布上红色心形图像的闪亮部分。我们只想追踪心形的轮廓，这是稍后在代码中将要勾勒的区域——我们不想那些白色区域。为了在预览中移除这些白色区域，将**阈值**滑块向右滑动，直到心形填充得像这样：
- en: '![Figure 9.16: Setting the options in Inkscape for the heart image ](img/B18674_09_16.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16：在Inkscape中设置心形图像的选项](img/B18674_09_16.jpg)'
- en: 'Figure 9.16: Setting the options in Inkscape for the heart image'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：在Inkscape中设置心形图像的选项
- en: Now that the heart shape is ready to be vectorized, click the **Apply** button
    to complete the process, and a new vectorized black heart is placed directly over
    the red heart image on the canvas. Drag the black heart off to the side, in order
    to see the red heart under it, then delete the red heart.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在心形形状已经准备好进行矢量化，点击**应用**按钮以完成过程，一个新的矢量化黑色心形将直接放在画布上的红色心形图像上方。将黑色心形拖到一边，以便可以看到下面的红色心形，然后删除红色心形。
- en: Next, position the black heart back over the white canvas and export it like
    the “WE” image, making sure to choose the **Plain SVG (*.svg)** file type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将黑色心形放回到白色画布上，并像“WE”图像一样导出它，确保选择**纯SVG (*.svg**)文件类型。
- en: 'Moving away from Inkscape and into the Sketch program, open the new vector
    image we just exported from Inkscape into Sketch by right-clicking on the image
    and selecting **Open with Sketch**. We will resize the image again to a width
    of **250** (again, making sure to click on the lock icon to fix the proportions):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 离开Inkscape并进入Sketch程序，通过右键单击图像并选择**用Sketch打开**来将我们从Inkscape导出的新矢量图像打开到Sketch中。我们将再次将图像调整到宽度为**250**（再次确保点击锁定图标以固定比例）：
- en: '![Figure 9.17: Setting the size for the heart image in Sketch ](img/B18674_09_17.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17：在Sketch中设置心形图像的大小](img/B18674_09_17.jpg)'
- en: 'Figure 9.17: Setting the size for the heart image in Sketch'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：在Sketch中设置心形图像的大小
- en: Next minimize the Sketch window, as we only need it running in the background
    so that Kite can access it, and open the Kite program. In Kite, click on **File**,
    then **Import**, and then **From Sketch**. You will see the same window as shown
    in *Figure 9**.12*, and you can keep the default settings. Then, click **Import**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来最小化Sketch窗口，因为我们只需要它在后台运行，以便Kite可以访问它，然后打开Kite程序。在Kite中，点击**文件**，然后**导入**，接着**从Sketch导入**。你会看到与*图9.12*中显示的相同窗口，你可以保持默认设置。然后，点击**导入**。
- en: 'Once the image has been imported, select the image on the canvas, and then
    click the **Code** button at the top to generate the Swift code we need:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: Generating the heart’s Swift code in Kite ](img/B18674_09_18.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Generating the heart’s Swift code in Kite'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Like we did with the “WE” image code, we just want to copy the code that starts
    with the `pathtPath` name. In the example here, the code we need starts at the
    `let pathPath = CGMutablePath()` line and ends with `pathPath.move(to)`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to Xcode – create a new SwiftUI View file, which I will name `HeartView`.
    Inside the file, we will create a struct to put the code in, call it `HeartShape`,
    and make it conform to the `shape` protocol, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember when making the “WE” shape, we used the shape protocol? As before,
    it requires us to use the `path()` method, which I have added here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can paste the Kite-generated Swift code inside this method (again,
    I will only include the first few lines and the last few lines so as not to take
    up too much space here; as before, the complete code file and project are available
    in the GitHub repo):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let’s refactor the code as we did before. *Command + click* on the `pathPath`
    instance and choose `path`. Also, change the mutability of the `path` constant
    to a variable by replacing `let` with `var`, and change `CGMutablePath()` to `Path()`.
    These changes should look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last change to make is at the bottom of the `HeartShape` struct; after
    the very last line of code, we need to return the path we created, so add the
    following line of code to the end of the `path` function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code should now build cleanly, and we can move on to animating the outline
    around the heart. This is similar code to that in the `WEView` file. At the top
    of the struct, let’s add the following variables:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `strokeReset` variable will keep track of the animation, `startStroke` will
    hold a value that sets the `length` property of the stroke at the beginning, and
    `endStroke` will hold a value that sets the `length` property of the stroke at
    the end.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving into the `body` property of the struct, let’s add the views needed to
    display and animate our heart outline:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code here is almost identical to the code in the `WEView` file – what’s
    different is the color of the stroke. Here, it is white and we are offsetting
    the heart to be lower on the screen.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and you’ll see that there is a smoothly animating stroke going
    around the heart shape.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Again, all the values are for you to explore and experiment with to create the
    look you want.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s do something a bit different for this shape – let’s add the actual
    heart bitmap image right inside the animating heart shape. To do this, add the
    following code at the bottom of the `Group` view:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code again and you’ll see that it performs as before, only now we’ve
    positioned the heart bitmap image inside the stationary stroke, so the animated
    stroke is tracing the heart image for an interesting look:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: The stroke around the heart image ](img/B18674_09_19.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: The stroke around the heart image'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We have completed two shapes now, the “WE” letters and the heart. Let’s continue
    and add the final image to the project, the SwiftUI logo.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stroke animation on the SwiftUI logo image
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have reached the final image, I would like to challenge you by letting
    you take this one on by yourself. Use the steps we have outlined in the previous
    two shapes – including removing backgrounds, vectorizing your image, and converting
    the image into Swift Code – and copy the code into a new SwiftUI View file called
    `SwiftUILogoView`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Okay, give it a try, and come back here when you’re ready…
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: How did you do?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: After you vectorize a few shapes and gather the code, the process will become
    very familiar and much quicker. If you have used images other than the ones I
    supplied for this project, that’s perfectly fine; just know that the SwiftUI code
    for those images will be different from the code I will show here for the SwiftUI
    logo, but the animating code will be the same.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the SwiftUI code that I got back from Kite for the SwiftUI logo image
    (and as before, the full code file is available in the GitHub repo):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I have previously explained how this code creates a shape object in the *Creating
    a stroke animation on the “WE” image* section; if you would like a refresher on
    understanding how this works, go back to that section for the details on this
    code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move to the top of the file, inside the `SwiftUILogo` struct, and
    start adding the animation code. I will add the complete code for this final shape:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This animating code is the same code that we have been adding all along, and
    if you would like an explanation of how it works, go back to the “WE” shape code
    for all the details. The minor differences here are that the line is blue, and
    we are offsetting it lower on the screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Give this a run and check out the stroke around the logo.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the project is to combine all three of the shape structs onto
    the screen together. Let’s do that next.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Combining the animated strokes
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is very little code needed for this, as we are just calling the three
    shape structs in one place. All you need to do is add the following code to the
    `ContentView` struct:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What we have done here is called all three structs inside `ContentView`, used
    a `VStack` to line up the views vertically, and then added a black background
    at the end. When you run the code, you will see the following result:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: The finished project ](img/B18674_09_20.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: The finished project'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Now, all three views are animated as being outlined with different colors.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nice job finishing this project! To create the finished animation, we learned
    how to turn bitmap images into vector files, and then how to turn those vector
    files into code that we can work with using SwiftUI. Also, we learned how to create
    and animate a moving outline around almost any shape using the `stroke` modifier
    and timers, and used animation in this project.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，完成了这个项目！为了创建最终的动画，我们学习了如何将位图图像转换为矢量文件，然后如何将这些矢量文件转换为我们可以使用SwiftUI进行工作的代码。此外，我们还学习了如何使用`stroke`修改器和计时器创建和动画化几乎任何形状的移动轮廓，并在本项目中使用了动画。
- en: Using this project, you can play around with the values. You can make the stroke
    thicker or thinner, make it move faster or slower, and make it any color of the
    rainbow.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个项目，你可以玩转这些值。你可以使笔触更粗或更细，让它移动得更快或更慢，还可以让它呈现出彩虹的任何颜色。
- en: There are many applications for animating strokes in your apps, too. It can
    be used for logos, text, and brands, so that they stand out and get noticed; it
    can be used in game apps to bring the users’ attention to different areas of the
    screen or can be used anywhere you want to make an app come alive. The uses are
    only limited by your imagination.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中动画化笔触也有很多应用。它可以用于标志、文本和品牌，使它们脱颖而出并引起注意；它可以在游戏应用中使用，将用户的注意力吸引到屏幕的不同区域，或者在任何你想让应用生动起来的地方使用。这些用途仅限于你的想象力。
- en: In the next chapter, we will learn how to animate lines in a different way to
    create waves, and then put them together to make an ocean with an animating buoy,
    complete with sound effects.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何以不同的方式动画化线条来创建波浪，然后将它们组合起来，通过一个动画浮标制作一个海洋，并配备音效。
