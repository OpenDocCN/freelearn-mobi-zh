- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating Strokes around Shapes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will take three images, create outlines around them, and
    then animate strokes along those outlines. A stroke is a line that follows the
    outline (or contours) of a shape, which we can give any color and thickness and
    animate to move around the image.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you’ll learn how to convert bitmap images into vector images using
    the Inkscape software, and then take those vectors and convert them into Swift
    code using Sketch and Kite. We will then insert this code back into Xcode so that
    we can start animating our project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the objectives for this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Converting images into Swift code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating images with the `stroke` modifier
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 9` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remove Background software, which is a free online tool you can access
    here: [https://www.remove.bg/upload](https://www.remove.bg/upload)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inkscape, which is free and you can install here: [https://inkscape.org/release/inkscape-1.2.1/](https://inkscape.org/release/inkscape-1.2.1/)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sketch, which you can install here: [https://www.sketch.com/switch-to-sketch/](https://www.sketch.com/switch-to-sketch/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kite, which you can install here: [https://kiteapp.co](https://kiteapp.co)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting images into Swift code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create the three outlines that we need, we first have to convert
    images into vectors and then convert those vectors into Swift code. Why do we
    have to convert an image into Swift code?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Well, in order to place an animating stroke around an image, we need a path
    for the animation to follow. When the image has been translated into code, it
    will then be easy to use Swift to follow the image outline.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s a problem: bitmaps. A **bitmap**, also called a **raster image**,
    is a graphic that is created from different colored pixels, which together form
    an image. Bitmaps can be very simple, just made up of two colors (those would
    be black and white), or they can have many thousands or millions of colors that
    produce photograph-quality images. Some examples of bitmap formats that you will
    see use the file extensions PNG, JPEG, and TIFF. With a bitmap image, there is
    no defined outline for any code to follow, and thus it cannot have an animating
    stroke around it.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector images**, on the other hand, are images created from code that have
    sharply defined edges and never get blurry like a bitmap when you zoom in on them.
    Since they are created with code, we can animate strokes around those images.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to animate a stroke around a bitmap image, there are three main
    steps that you need to undertake:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Removing the background of the image you want to use
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectorizing the image into an SVG file
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating the SVG file into Swift code
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s go through those steps now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Removing the image backgrounds
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many images have a white or colored background, and in many cases, the background
    is not needed. It’s easier to convert images into vectors if they are against
    a transparent background.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, the images that we will be using are an image of the word “WE,”
    an image of a heart, and an image of the SwiftUI logo. We will combine them in
    Swift so that they say, “We Love SwiftUI,” like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The images we will use in our project ](img/B18674_09_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The images we will use in our project'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: You can download these from the GitHub repository, where you will notice that
    the backgrounds have already been removed. However, if you are going to use your
    own images, you will need to do this yourself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We already explored how to remove backgrounds in [*Chapter 6*](B18674_06.xhtml#_idTextAnchor082)
    when we animated the girl on the swing. You can refer back to that chapter; however,
    to recap, you can use an online tool called Remove Background: [https://www.remove.bg/upload](https://www.remove.bg/upload).
    You just have to click **Upload Image** and choose the one you want to use. And
    that’s it – in about 20 seconds, the website’s algorithms will find the background
    and remove it, leaving only your subject. Then, all you have to do is download
    the new image file and you’re good to go.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use Mac’s Preview app to remove the background, or you
    can use paid software such as Affinity Designer. How you decide to remove the
    background is up to you; experiment and try to see what works best for the image
    you are using.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Also, although it’s not strictly necessary, it’s a good idea to crop your image,
    as we only want to work with the image and not any surrounding space. You can
    do this in pretty much any graphics editing program, including the Preview app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Now you can proceed to the next step, which is vectorizing the image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Vectorizing the images
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second step will be to create vectors from the bitmap image. To do this,
    we will need software with the proper algorithms to detect pixels, remove them,
    and replace them with code that will draw the shapes instead. The resulting code
    file will be a `.svg`) file. One of the best software options on the market is
    called Vector Magic. This software is easy to use and automates the vectorization
    process with a click of a button to start the process, but the downside is it
    costs around $300.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use Inkscape, which is free software that does a really
    good job of tracing out a bitmap image and converting all its parts into vectors.
    This is what we will use, and you can download the latest version (at the time
    of writing) from the following link: [https://inkscape.org/release/inkscape-1.2.1/](https://inkscape.org/release/inkscape-1.2.1/).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Even though Inkscape can work with color images, it’s usually better to have
    your images in black and white; the algorithms work better with these two colors.
    If you have color images, though, that’s not a problem – you can still convert
    them into black and white by using a graphics program such as Affinity Designer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the images we are using for this project, two of them are in
    color, but that’s okay because they have a limited number of colors and are simple
    shapes. If you have more complicated shapes, for instance, such as a portrait
    photograph with many colors in it, then it’s better to convert them into black
    and white first.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have Inkscape installed, you can get started. Grab one of your images
    (in my case, I am choosing the “WE” image), right-click on it, and open it in
    Inkscape. You will see this pop-up window:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Importing an image into Inkscape ](img/B18674_09_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Importing an image into Inkscape'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Set **Image Import Type** to **Embed**, **Image DPI** to **Default import resolution**,
    and **Image Rendering Mode** to **None (auto)**. Then, click **OK**. You will
    then see this screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The Inkscape editor with our image ](img/B18674_09_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The Inkscape editor with our image'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing with the conversion, I want to show you how a bitmap looks
    close up. On your Mac trackpad, pinch and zoom in very close to the image; you
    will see pixelization and blurriness appear. This is one way you can tell whether
    the image is a bitmap and not a vector. (Of course, the file extension will also
    let you know whether it’s a bitmap or vector as well!)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select your image on the Inkscape canvas (you will know it’s been selected
    if you see black arrows around it), then go to the **Path** menu at the top of
    the screen, and choose **Trace Bitmap**. This will open up the **Preview** option
    on the right-hand side of Inkscape:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Inkscape Preview ](img/B18674_09_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Inkscape Preview'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: In the **Preview** window, Inkscape shows us what the **Trace Bitmap** function
    will be able to trace, and what the image will look like as a vector graphic.
    Since the preview looks nearly identical to the “WE” image on the canvas, there
    will be a complete outline around the image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: You can’t see the vector lines and points just yet in the preview, but you will
    shortly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using a black and white image, Inscape has selected the **Single
    scan** option from the top of the **Preview** window (which you can see in *Figure
    9**.5*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: The Inkscape scan option ](img/B18674_09_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: The Inkscape scan option'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The **Single scan** option is used for black and white images, but if we use
    a multicolored image, then we need to select the **Multicolor** option. The **Multicolor**
    option will scan your image, looking at the many colors it contains, and do its
    best to trace an outline around each of those colors. This is why I said earlier
    that it’s usually better to have a black-and-white image, as there are fewer colors
    to scan and thus less chance of not getting a good trace.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in *Figure 9**.5*, you can also adjust the **Threshold** and
    **Details** sliders to get the best possible image in the previews. These sliders
    are useful if Inkscape is having difficulty getting a good scan. By moving the
    sliders, you can fine-tune the parts of the image that Inkscape can see.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the **Details** sliders:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The **Speckles** slider will ignore the small spots in the vector – when set
    to maximum, it will ignore more speckles, and when set to minimum, it will ignore
    fewer speckles.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Smooth corners** slider will smooth out any sharp corners that are in
    the trace.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Optimize** slider will try to optimize paths by joining adjacent Bezier
    curve segments together; this means that the **Optimize** slider will try its
    best to remove as many vector nodes as it can. When you have fewer nodes in a
    vector image, there tends to be better tracing and fewer jagged edges.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see the **Threshold** slider later when creating a stroke around the
    heart.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: What we want to see in the preview is an image that is as close to the one in
    the center canvas as possible. When we do see this, it means that Inkscape can
    trace all around the shape on the canvas correctly and capture all the vector
    lines. If you don’t see an image that’s close to the original, then try and adjust
    some of the sliders I just mentioned to fine-tune the output.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished adjusting the image so it looks close to the original,
    click **Update Preview**, and then **Apply**. Inkscape places its newly created
    vectors directly over the original image. To see the result, click on the “WE”
    image in the editor and drag the new vectors to the side:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Creating the vectors ](img/B18674_09_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Creating the vectors'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: You can now delete the original image, as it is no longer needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at what Inkscape has done for us – it has traced the original
    image and created a new image that is now made of vector paths. To see the difference,
    pinch and zoom on your Mac trackpad on the new vector image as you did with the
    bitmap image. Do you see the difference? There is no pixelation or blurriness
    at all, as the image is created with code rather than pixels; the image can be
    blown up to any size and it will still remain sharp and crisp along its edges
    and curves:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Vector resolution ](img/B18674_09_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Vector resolution'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remember that I mentioned that you will be able to see the vectors that
    Inkscape has created? Well, they are there, it’s just that we need to select the
    right editing tool to see them. Select the image in the center of the canvas,
    go to the left toolbar, and select the **Node Editing** tool. When you click on
    that tool, you will be able to see all the vector lines that Inkscape created:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: The vectors ](img/B18674_09_08.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: The vectors'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Each of those small squares is a point (or node) that links lines, curves, and
    corners to make this new shape – and these points can now be edited by clicking
    on them and dragging them to any location to reshape the vector image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new vectors created, we can export them. To do this, open **File**
    at the top menu and choose **Export**. Then, you can choose the export options
    at the bottom right of the software. Choose the file type that you want to export
    to – we want a **Plain SVG (*.svg)** file. Then, click on the **Export** button:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: Exporting to an SVG file ](img/B18674_09_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Exporting to an SVG file'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have an SVG file stored on our computer, ready to be translated into
    Swift code. Do the same process for any of the other images that you want to use
    in this project – whether you are using your own images or following along with
    the book’s project images – and then you can proceed to the next step.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Translating the SVG file into Swift code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s continue. We have an SVG file ready for the next step. An **SVG** file
    is a file written in XML, and **XML** is a markup language used for storing and
    transferring digital information. The XML code in an SVG file creates all of the
    shapes, colors, and text that comprise the image. We will be turning that XML
    code into Swift code shortly, but first, we need to edit the images’ dimensions
    and we can do that in Sketch.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first, open the SVG “WE” image in Sketch. Then, in the **Utilities** area
    on the right, we can size the image however we like; in my case, I have set the
    width to **250**. To set this, make sure that the little lock icon in between
    the width and height fields is selected so that it’s locked – this will keep the
    correct proportions for the image – and hit *Enter*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Sizing the image ](img/B18674_09_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Sizing the image'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all we need to do in Sketch. Now, minimize your Sketch document (but
    don’t close it!).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a program that can turn XML code into Swift code. One option is
    Paint Code – although it is a great program, it costs around $200 per year for
    a subscription. Instead, we will use Kite – although this is currently $99 to
    buy outright with no subscription, you can always use the free trial to follow
    along with this project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open up Kite. Then, click on **File** | **Import** | **From Sketch…**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: Importing from Sketch into Kite ](img/B18674_09_11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Importing from Sketch into Kite'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then see a pop-up window asking how you would like to import the layers.
    Leave the default settings as they are, but make sure that **Import text layers
    as** is set to **Image Layers** and that **Import images at** is set to a scale
    of **1x**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Import From Sketch settings ](img/B18674_09_12.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Import From Sketch settings'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click on **Import**. You now have your image in Kite and are ready to
    turn it into Swift code, and that process is as simple as clicking one button,
    the **Code** button, at the top of the screen:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Converting the file into Swift code ](img/B18674_09_13.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Converting the file into Swift code'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The Swift code that is generated shows up in the bottom console, which you
    can resize like the Xcode console by dragging it upwards. Here is what the code
    console looks like for the “WE” image, containing all the Swift code that makes
    up its length, thickness, colors, position, and more:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: The generated Swift code in Kite ](img/B18674_09_14.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: The generated Swift code in Kite'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: That looks like a lot of code just to create an image with two letters, doesn’t
    it? Well, yes, but there are a lot of things the code is doing – it’s mapping
    out all the paths needed to create the lines and curves that form the shape.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now get this code into Xcode. First, create a new Xcode project if you
    haven’t done so already – I’ve called it **Animating Strokes**. Then, all we have
    to do is copy a small segment of it from Kite. You should copy the code starting
    from here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And continue all the way down the file until you reach these two lines:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, we just want to copy all the code that starts with `pathPath`; everything
    else we don’t need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we enter Xcode, let’s summarize what we have done so far. We have
    taken a bitmap image, removed its background and cropped it, opened it with Inkscape
    and turned it into a vector image, and then finally imported that vector into
    Kite, where we turned it into Swift code. This process will get faster with more
    practice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now proceed to Xcode and start making all this code work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Animating images with the stroke modifier
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will be working in Xcode and refactoring the “WE”
    code somewhat in order to make it work in our project. We will use the Shape protocol
    that lets us draw a 2D shape using its `path()` function, and then use the `stroke`
    modifier to add a moving line around the path of our shapes. We will also get
    started on animating our heart and SwiftUI logo images.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stroke animation on the “WE” image
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start animating the “WE” image, we need to create a file inside the project.
    Press *Command + N*, choose a `WeView`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a struct at the bottom of the file; this will be the struct that
    conforms to the shape protocol, allowing us to create 2D shapes by using the `path`
    function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can paste in the code that we copied from the Kite program and place
    it right into that `path` function. This code is quite repetitive and long, as
    it is drawing a shape and must repeat itself for every line, curve, and corner.
    So, for the sake of brevity and to not take up too much space, I will just provide
    the beginning and end of the code (however, you can find the complete code in
    the GitHub repo):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you paste the code into Xcode, you will get some errors – don’t worry about
    these, as the code needs to be reworked a little bit anyway.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Fixing these issues is also a good excuse for me to show you how to refactor
    code in SwiftUI. Refactoring is a helpful feature that allows us to rename code
    or remove and replace different parts of code throughout multiple files in your
    project without having to search through all your files looking for each instance
    that needs refactoring and manually changing it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: One thing we want to change is the name of the `pathPath` constant, which is
    the first line of code inside the `path` function that was pasted in. This constant
    seems to have been named twice because it was exported from Inkscape. However,
    it should simply be named `path`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: So, to refactor this, just *Command + click* on the `pathPath` variable and
    select `pathPath` in the file, and all you have to do is just type in the new
    name, `path`, and hit *Enter*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: That’s our first revision of the code that we copied over. The next revision
    is to change the class that’s being assigned to the `path` constant. Currently,
    the `path` constant is assigned as a `CGMutablePath()` instance, which is a core
    graphics class used for drawing shapes and lines. Working in SwiftUI though, nearly
    everything is built with structs, so we need to use the `Path()` struct instead.
    Also, change the `let` keyword to the `var` keyword, because we need the `path`
    variable to be mutable, meaning its value can be changed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'With those modifications done, the first line of the code in your path function
    should look like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s add one more line of code to this `path` function. At the very end
    of the function, we need to return the `path` variable, and to do so, we use the
    `return` keyword, followed by the variable the function must return; so, add this
    line at the bottom of the `path` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following are the changes we made to the start and end of the `path` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you press *Command + B*, the code should be error-free.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see what all of that Kite code is actually doing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The `path()` function will return a shape according to the points, lines, and
    curves that are drawn inside it. The first line of code inside the `path()` function
    is creating a path instance; this will draw the shape, and you can think of this
    variable as the pencil moving along the canvas.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code is the `move()` function. This is what sets the starting
    location for the `path` variable to move to. The locations are based on the Cartesian
    coordinate system and an X and Y location are used to position the `path` variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二行是`move()`函数。这是设置`path`变量移动到起始位置的方法。位置基于笛卡尔坐标系，使用X和Y位置来定位`path`变量。
- en: In the third line of code, the `path` variable calls the `addCurve()` function,
    and this does what it says – it adds a Bezier curve to the path using the specified
    points. Continuing down our code, we see that the `path` variable also calls the
    `addLine()` function, and this will add a line to the path using the specified
    points. The code continues to call these two functions, `addCurve()` and `addLine()`,
    quite a bit until the `path` variable needs to finish off a particular path in
    the drawing and close off the ends of that finished line before moving on to the
    next line in the drawing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行代码中，`path`变量调用`addCurve()`函数，它做了它所说的——使用指定的点在路径上添加一个贝塞尔曲线。继续向下查看我们的代码，我们看到`path`变量还调用了`addLine()`函数，这将使用指定的点在路径上添加一条线。代码继续调用这两个函数，`addCurve()`和`addLine()`，直到`path`变量需要完成绘图中的特定路径并在移动到绘图中的下一行之前关闭完成线的末端。
- en: The finished line is closed off using the `closeSubpath()` function and directly
    proceeded by the `moveTo()` function to start a new line in the drawing. So, as
    you can see, there are several lines drawn in this code to make up the finished
    shape.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`closeSubpath()`函数关闭完成线条，然后直接使用`moveTo()`函数开始绘制新的一行。所以，正如你所看到的，在这段代码中有几行用来组成完成形状。
- en: And finally, at the end of all this code, the `path()` function returns the
    `pat`h variable, which now contains a finished shape inside of it, ready to be
    displayed on the iPhone screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有这些代码的末尾，`path()`函数返回包含完成形状的`path`变量，现在它可以在iPhone屏幕上显示。
- en: Next, continuing to work in the same file, we need to come into the `WEView`
    struct and add the code to display this shape.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，继续在同一文件中工作，我们需要进入`WEView`结构体并添加代码以显示此形状。
- en: 'Starting at the top of the struct, add the following variables:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构体的顶部开始，添加以下变量：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, inside the `body` property, add a `ZStack`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`body`属性内部，添加一个`ZStack`：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the `ZStack`, let’s add a `Group`, and then the following code to display
    the shape in the preview:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ZStack`内部，让我们添加一个`Group`，然后添加以下代码以在预览中显示形状：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside `Group`, we call the `WeTextShape` struct and add the `stroke` modifier
    directly to it. This modifier will create a new shape that has a stroke on it,
    which is styled according to the `StrokeStyle` function. The `StrokeStyle` function
    adds a `lineWidth` property of `0.5`, and sets both `lineCap` (the ends of the
    stroke) and `lineJoin` to `round`; this joins the ends of the stroke with a semi-circular
    arc. Finally, the color of the stroke shape is set to `gray`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Group`内部，我们调用`WeTextShape`结构体，并直接对其添加`stroke`修饰符。这个修饰符将创建一个新的形状，其上有一个带有样式的描边，该样式根据`StrokeStyle`函数进行设置。`StrokeStyle`函数添加了一个`lineWidth`属性值为`0.5`，并将`lineCap`（描边的末端）和`lineJoin`都设置为`round`；这通过半圆形弧线连接描边的末端。最后，描边形状的颜色被设置为`gray`。
- en: This completes the shape – we won’t add any animation to it, as we just want
    it to be a stationary shape. Instead, we will add this shape again, directly over
    the first one, and that’s the one we will animate in color. Let’s add that now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了形状的创建——我们不会为它添加任何动画，因为我们只想让它保持静止。相反，我们将在第一个形状的正上方再次添加这个形状，这是我们将在颜色上动画化的形状。现在让我们添加它。
- en: 'Continuing inside the `Group` view, and directly under the last line of code,
    add the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Group`视图内部继续，并在最后一行代码下方直接添加以下内容：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And that’s the code that will add a second shape, identical to the first one,
    directly over it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将在第一个形状正上方添加第二个形状，与第一个形状完全相同的代码。
- en: As we did for the non-moving shape, we called the `WeTextView` struct to create
    the shape. Then, we used the `trim` modifier to trim the shape by a fractional
    amount based on the values that get passed into its parameters. By passing in
    the `startStroke` variable as the location of the start of the stroke animation
    and the `endStroke` variable to tell the `trim` modifier where to stop, a stroked
    line will be drawn along the shape’s path from start to end. The length of that
    stroke line will depend on the values inside the `startStroke` and `endStroke`
    variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the first shape, we also used the `strokeStyle` modifier to style
    the stroke with a `width` property of `5`, and `lineCap` and `lineJoin` set to
    `round`. This time, we set the color to `red` so that the moving stroke will stand
    out as it travels along the gray shape underneath it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Then, finally, we’re using the `offset` modifier to center the shape inside
    the preview in the middle from left to right, and toward the top of the iPhone.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the code for the outline and animating the stroke are complete. What’s
    needed next is to use the `onAppear` modifier to start the animation and set up
    some timers so that the stroke can proceed at a certain speed. Add the final bit
    of code right after the closing brace of the `ZStack`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code might look a little busy to grasp at first, but let’s break it down
    for clarity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The `onAppear()` method is called on the `ZStack` container; this method is
    triggered when the view appears on the screen. Inside the method, a timer is scheduled
    using the `Timer.scheduledTimer` method, which is set to repeat every `0.23` seconds.
    This is the amount of time it takes for the animation to draw each stroke segment.
    A stroke segment is how we draw out the shape, in segments, one at a time. You
    can experiment with this timer’s interval value – a larger number will draw the
    stroke segments slower, and a smaller number will draw the segments faster, creating
    a smooth animating line around the shape.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want the animation to repeat, so we set the `repeats` parameter to
    `true`. Within the timer’s event handler, the code first checks whether the `endStroke`
    variable is greater than or equal to `1`. If this is true, the code then checks
    whether the `strokeReset` variable is `true`. If both of these conditions are
    met, another timer is scheduled using the `Timer.scheduledTimer` method. This
    timer is set to run only once, after `0.6` seconds, and within this timer’s event
    handler, the values of `endStroke` and `startStroke` are reset to `0`, so the
    stroke animation can once again start at the beginning, and the `strokeReset`
    variable is toggled. After the inner timer is scheduled, the `strokeReset` variable
    is set to `false`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The `withAnimation` function is different from the animation modifier we have
    used in past projects. Remember in [*Chapter 2*](B18674_02.xhtml#_idTextAnchor034),
    when we talked about the two types of animations, *implicit* and *explicit*? The
    `withAnimation` function is an explicit type of animation and is used to animate
    changes to the view’s state. It is considered an explicit animation because it
    requires you to specify the animation that you want to use, as opposed to an implicit
    animation, which would automatically animate changes without the need for additional
    code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`withAnimation`函数与我们过去项目中使用的动画修饰符不同。记得在[*第二章*](B18674_02.xhtml#_idTextAnchor034)，当我们讨论两种类型的动画，*隐式*和*显式*时？`withAnimation`函数是一种显式类型的动画，用于动画化视图状态的变化。它被认为是一种显式动画，因为它要求你指定你想要使用的动画，而不是隐式动画，后者会自动动画化变化，无需额外的代码。'
- en: So, in the body of the `withAnimation` function, we set the `endStroke` variable
    to increase its value by `0.12` after every iteration of the animation. We also
    set `startStroke` to a value that is calculated by subtracting `0.4` from `endStroke`
    – this computation creates the length and speed of an animating stroke that I
    think looks pretty good for the “We” shape.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`withAnimation`函数的主体中，我们在动画的每次迭代后都将`endStroke`变量的值增加`0.12`。我们还设置了`startStroke`的值，该值是通过从`endStroke`中减去`0.4`计算得出的——这种计算方式创建了一个动画笔画的长度和速度，我认为对于“我们”形状来说看起来相当不错。
- en: And with that, this animation is complete. So, to summarize the code in the
    `WeView` struct, it creates a view that animates a shape, this shape is outlined
    twice, once with a gray color and a small stroke, and then again, with a red color
    and a bigger stroke. The animation is controlled by the `startStroke` and `endStroke`
    variables, which are incremented over time. The animation will be repeated once
    the `endStroke` variable reaches `1`, and there is a `0.6`-second delay before
    the animation starts again.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，这个动画就完成了。所以，为了总结`WeView`结构体中的代码，它创建了一个动画形状的视图，这个形状被勾勒了两次，一次是灰色和细笔画，然后再次，是红色和大笔画。动画由`startStroke`和`endStroke`变量控制，这些变量随时间增加。一旦`endStroke`变量达到`1`，动画就会重复一次，并且在动画再次开始之前有一个`0.6`秒的延迟。
- en: Now that we have finished with the code, if you click on the `endStroke` in
    the `withAnimation` function, you can leave more of the stroke line on the shape
    or less of it, depending on the look you want to go for.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了代码，如果你点击`withAnimation`函数中的`endStroke`，你可以根据你想要的视觉效果在形状上留下更多的笔画线或者更少。
- en: Play around with the values and experiment. You can create a flashing stroke
    by increasing the speed, or you can have a very slow-moving stroke. You can stroke
    the entire shape with a short line, or you can go with a very long line along
    the whole shape.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整数值并进行实验。你可以通过增加速度来创建闪烁的笔画，或者你可以有一个非常缓慢移动的笔画。你可以用短线条勾勒整个形状，或者你可以沿着整个形状使用非常长的线条。
- en: That completes our first animation, the “WE” image stroke. Even though that
    seems like a long process, the whole thing actually only takes a few minutes once
    you get familiar with the different programs and techniques used. We are going
    to move on to the heart image now and repeat the same process. After all, practice
    makes perfect!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第一个动画，“WE”图像的笔画。尽管这个过程看起来很复杂，但一旦你熟悉了不同的程序和技术，整个过程实际上只需要几分钟。我们现在将转向心形图像，并重复同样的过程。毕竟，熟能生巧！
- en: Creating a stroke animation on the heart image
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在心形图像上创建笔画动画
- en: Okay, we have animated our first image, so we are going to follow the same process
    again for two more images. The next image will be a heart – for this one, we will
    animate a stroke around it as we did with the letters, but also we will add the
    heart image back into the scene.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经动画化了我们的第一张图像，所以我们将对另外两张图像重复同样的过程。下一张图像将是一个心形——对于这个，我们将像处理字母一样在它周围动画化一个笔画，但也会将心形图像重新添加到场景中。
- en: If you are following along with the book’s project, you can find the heart image
    in the GitHub repository, where the background has already been removed. However,
    if you are using your own images, you will need to do this yourself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随书中的项目，你可以在GitHub仓库中找到心形图像，其中背景已经被移除。然而，如果你使用自己的图像，你需要自己完成这项工作。
- en: After you have prepared your image, now open it with Inkscape so that you can
    vectorize it. With the image selected in the editor, go to the **Path** menu at
    the top and choose **Trace Bitmap**; this will trace the image and prepare it
    for vectorization, as before.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: With the image selected on the canvas, if you look at the **Previews** pane
    at the right, the image has been converted into black and white. That’s because,
    by default, Inkscape selects the **Single Scan** option, the option for black-and-white
    images. And even though this is a color image, because it’s such a simple shape
    with not many variations of red in it, we don’t need the **Multicolor** option;
    so, **Single scan** will work fine here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: This is also a good opportunity to use the **Smooth Corners** option as well
    because this shape has (for the most part) smooth corners, and this selection
    will preserve them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it should look like so far:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: The heart image in Inkscape ](img/B18674_09_15.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: The heart image in Inkscape'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, do you notice that the heart image shown in **Preview** has two white
    areas inside it? That’s the Inkscape algorithm trying to capture the shiny parts
    of the red heart image on the canvas. We only want to trace the outside perimeter
    of the heart, which is the area that will be outlined later in the code – we don’t
    want those white areas. To remove those white areas in the preview, slide the
    **Threshold** slider to the right, just enough so the heart fills up like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Setting the options in Inkscape for the heart image ](img/B18674_09_16.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Setting the options in Inkscape for the heart image'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Now that the heart shape is ready to be vectorized, click the **Apply** button
    to complete the process, and a new vectorized black heart is placed directly over
    the red heart image on the canvas. Drag the black heart off to the side, in order
    to see the red heart under it, then delete the red heart.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Next, position the black heart back over the white canvas and export it like
    the “WE” image, making sure to choose the **Plain SVG (*.svg)** file type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving away from Inkscape and into the Sketch program, open the new vector
    image we just exported from Inkscape into Sketch by right-clicking on the image
    and selecting **Open with Sketch**. We will resize the image again to a width
    of **250** (again, making sure to click on the lock icon to fix the proportions):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: Setting the size for the heart image in Sketch ](img/B18674_09_17.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Setting the size for the heart image in Sketch'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Next minimize the Sketch window, as we only need it running in the background
    so that Kite can access it, and open the Kite program. In Kite, click on **File**,
    then **Import**, and then **From Sketch**. You will see the same window as shown
    in *Figure 9**.12*, and you can keep the default settings. Then, click **Import**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has been imported, select the image on the canvas, and then
    click the **Code** button at the top to generate the Swift code we need:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: Generating the heart’s Swift code in Kite ](img/B18674_09_18.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Generating the heart’s Swift code in Kite'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Like we did with the “WE” image code, we just want to copy the code that starts
    with the `pathtPath` name. In the example here, the code we need starts at the
    `let pathPath = CGMutablePath()` line and ends with `pathPath.move(to)`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to Xcode – create a new SwiftUI View file, which I will name `HeartView`.
    Inside the file, we will create a struct to put the code in, call it `HeartShape`,
    and make it conform to the `shape` protocol, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember when making the “WE” shape, we used the shape protocol? As before,
    it requires us to use the `path()` method, which I have added here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can paste the Kite-generated Swift code inside this method (again,
    I will only include the first few lines and the last few lines so as not to take
    up too much space here; as before, the complete code file and project are available
    in the GitHub repo):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let’s refactor the code as we did before. *Command + click* on the `pathPath`
    instance and choose `path`. Also, change the mutability of the `path` constant
    to a variable by replacing `let` with `var`, and change `CGMutablePath()` to `Path()`.
    These changes should look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last change to make is at the bottom of the `HeartShape` struct; after
    the very last line of code, we need to return the path we created, so add the
    following line of code to the end of the `path` function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code should now build cleanly, and we can move on to animating the outline
    around the heart. This is similar code to that in the `WEView` file. At the top
    of the struct, let’s add the following variables:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `strokeReset` variable will keep track of the animation, `startStroke` will
    hold a value that sets the `length` property of the stroke at the beginning, and
    `endStroke` will hold a value that sets the `length` property of the stroke at
    the end.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving into the `body` property of the struct, let’s add the views needed to
    display and animate our heart outline:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code here is almost identical to the code in the `WEView` file – what’s
    different is the color of the stroke. Here, it is white and we are offsetting
    the heart to be lower on the screen.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and you’ll see that there is a smoothly animating stroke going
    around the heart shape.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Again, all the values are for you to explore and experiment with to create the
    look you want.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s do something a bit different for this shape – let’s add the actual
    heart bitmap image right inside the animating heart shape. To do this, add the
    following code at the bottom of the `Group` view:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code again and you’ll see that it performs as before, only now we’ve
    positioned the heart bitmap image inside the stationary stroke, so the animated
    stroke is tracing the heart image for an interesting look:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: The stroke around the heart image ](img/B18674_09_19.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: The stroke around the heart image'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We have completed two shapes now, the “WE” letters and the heart. Let’s continue
    and add the final image to the project, the SwiftUI logo.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stroke animation on the SwiftUI logo image
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have reached the final image, I would like to challenge you by letting
    you take this one on by yourself. Use the steps we have outlined in the previous
    two shapes – including removing backgrounds, vectorizing your image, and converting
    the image into Swift Code – and copy the code into a new SwiftUI View file called
    `SwiftUILogoView`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Okay, give it a try, and come back here when you’re ready…
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: How did you do?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: After you vectorize a few shapes and gather the code, the process will become
    very familiar and much quicker. If you have used images other than the ones I
    supplied for this project, that’s perfectly fine; just know that the SwiftUI code
    for those images will be different from the code I will show here for the SwiftUI
    logo, but the animating code will be the same.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the SwiftUI code that I got back from Kite for the SwiftUI logo image
    (and as before, the full code file is available in the GitHub repo):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I have previously explained how this code creates a shape object in the *Creating
    a stroke animation on the “WE” image* section; if you would like a refresher on
    understanding how this works, go back to that section for the details on this
    code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move to the top of the file, inside the `SwiftUILogo` struct, and
    start adding the animation code. I will add the complete code for this final shape:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This animating code is the same code that we have been adding all along, and
    if you would like an explanation of how it works, go back to the “WE” shape code
    for all the details. The minor differences here are that the line is blue, and
    we are offsetting it lower on the screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Give this a run and check out the stroke around the logo.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the project is to combine all three of the shape structs onto
    the screen together. Let’s do that next.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Combining the animated strokes
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is very little code needed for this, as we are just calling the three
    shape structs in one place. All you need to do is add the following code to the
    `ContentView` struct:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What we have done here is called all three structs inside `ContentView`, used
    a `VStack` to line up the views vertically, and then added a black background
    at the end. When you run the code, you will see the following result:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: The finished project ](img/B18674_09_20.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: The finished project'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Now, all three views are animated as being outlined with different colors.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nice job finishing this project! To create the finished animation, we learned
    how to turn bitmap images into vector files, and then how to turn those vector
    files into code that we can work with using SwiftUI. Also, we learned how to create
    and animate a moving outline around almost any shape using the `stroke` modifier
    and timers, and used animation in this project.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Using this project, you can play around with the values. You can make the stroke
    thicker or thinner, make it move faster or slower, and make it any color of the
    rainbow.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: There are many applications for animating strokes in your apps, too. It can
    be used for logos, text, and brands, so that they stand out and get noticed; it
    can be used in game apps to bring the users’ attention to different areas of the
    screen or can be used anywhere you want to make an app come alive. The uses are
    only limited by your imagination.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to animate lines in a different way to
    create waves, and then put them together to make an ocean with an animating buoy,
    complete with sound effects.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
