- en: Chapter 6. Notifications and the Action Bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vertically scrolling `RecyclerView`, which we have been dealing with in
    the previous chapters, is a great device for negotiating long, simple lists where
    there is either not much data in each item or where each item only displays a
    small part of the whole. There are, of course, times when we will want to display
    a full screen of information and still have this as a part of a list. This is
    where the `ViewPager` comes in as it allows us to chain together full-page, mini
    Activities called **Fragments** in such a way that we can navigate through them
    with simple, intuitive horizontal swipe gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Along with making use of the variety of views and widgets available to us, there
    are often times when we would wish to inform our user of some event even when
    they are not focused on our app. Smartphones generally provide some form of notification
    area, and Android is no exception with its **notification bar** at the top of
    the screen. Issuing notifications to the user is a very simple process, and Android
    has added two new features in Lollipop so that it is now possible to add display
    notifications on the lock screen and produce floating, heads-up notifications.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate these features, we will build a small weather forecast app (using
    fake data) that will issue warnings in the form of notifications to the user when
    the weather is severe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a screen slide with `ViewPager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Fragments instead of Activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `ViewPager` and `PagerAdapter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add tabs to the action bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue notifications to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage a back stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design icons for the notification bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce heads-up notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create expanded notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure lock screen notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set notification priority and visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a ViewPager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ViewPager` and its variants are extended from the `ViewGroup` class and
    can be thought of as a kind of layout manager that takes care of placing and navigation
    through the pages. `ViewPagers` work in conjunction with `PagerAdapters`, which
    populate each page with the appropriate data.
  prefs: []
  type: TYPE_NORMAL
- en: The code behind the pages of our `ViewPager` is contained within a new class,
    the `Fragment`. Fragments are very similar in structure and purpose to Activities,
    but can be contained and combined within Activities and, to all intents and purposes,
    can be thought of as sub-Activities.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we need to consider the layout and appearance of our app before we
    begin programming. Here, we will need layouts for the `ViewPager` and `Fragment`.
    The steps in the following section show how to set up our layout and resource
    files for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once created, this project will require two layout files and, to take advantage
    of some Material Design features, we will edit the styles resource. The following
    steps explain how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Weather Forecast` and start it with the **Blank Activity** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `build.gradle (Module: app)` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have not downloaded the project files, locate five suitable images of
    approximately 400 x 400 px with the following names and place them in the project
    `drawable` directory:![Creating the layout](img/B04321_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `res/values-v21/styles.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following color items inside the `<style>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `activity_main.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace its contents with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new layout file called `fragment_layout.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ViewGroup` hierarchy to match the one shown here:![Creating the layout](img/B04321_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using images from the `drawable` folder and text as placeholders, recreate the
    layout (with the inner two layouts highlighted), as shown here, selecting margins
    and other visual attributes as you see fit:![Creating the layout](img/B04321_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `CardView` element should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To achieve the correct text coloring, set `android:textAppearance` to apply
    the `textColors` we set in the `styles.xml` file with `textColorPrimary` being
    applied to views and with `textAppearance` set to `"?android:attr/textAppearanceLarge"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added a **support library (v4)** to our gradle script along with `CardView`
    support, which we will use later. Support libraries provide features that are
    unavailable in the standard SDK and backward-compatibility for many others.
  prefs: []
  type: TYPE_NORMAL
- en: That's all the layout and resource work we need to do. By applying custom colors
    in the style file, we allow the system to decide which colors to apply to which
    screen components as always; here, however, it applies our own personal scheme.
    These colors are displayed throughout the app; not only this method is a good
    way to ensure that our apps are distinctive but it also gives them a consistent
    feel for very little effort on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with large layout files, the process can be tidied up somewhat
    with the use of `<include layout="@layout/some_layout"/>` where `some_layout`
    will be inserted in place of the include tag on inflation.
  prefs: []
  type: TYPE_NORMAL
- en: With the layout, theme and style set up, we can now continue with writing some
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a ViewPager and FragmentPagerAdapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As briefly mentioned already, a `ViewPager` is a layout manager for horizontally
    scrolling screens. The work of filling these pages is undertaken by a `PagerAdapter`,
    or more specifically in this case `FragmentPagerAdapter`, which fulfills the same
    function but with Fragments rather than Activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Including a small dataset, we will require a total of four classes to implement
    our `ViewPager`. Here is how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainActivity` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend the class like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this class field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following three lines to the `onCreate()` method to initiate our `ViewPager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new class called `FragmentAdapter.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new class called `WeatherFragment.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fill out the class like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a last class called `WeatherData.java` and complete it like following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now run and test the app on a handset or emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may be wondering why instructions on which libraries to import were included
    in this section as you probably have Auto Import configured in the settings. This
    feature works perfectly in almost all situations and is a great time-saver. If
    you have not already enabled it, it can be found at `File | Settings... | IDE
    Settings | Editor | Auto Import`. It is only useful when a support library contains
    imports that have the same name as the standard libraries. Had we not imported
    these libraries first, we would have encountered something similar to the following
    screenshot when we tried to enter the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a ViewPager and FragmentPagerAdapter](img/B04321_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When this occurs, it is still perfectly possible to import the correct libraries
    by simply selecting the v4 version from the list the editor offers.
  prefs: []
  type: TYPE_NORMAL
- en: The `MainActivity` code is remarkably short as most of the work is done elsewhere.
    `ViewPagers` requires an ID, which is the XML-defined `ViewPager` as set in our
    `activity_main.xml` file. The `PagerAdapter` is implemented in the next class;
    here, all we do is to connect the two.
  prefs: []
  type: TYPE_NORMAL
- en: The `FragmentAdapter` class is also quite straightforward. All we need to do
    is pass the index of the selected page to our `Fragment` class, which we do with
    the Bundle object. The fragment then takes care of laying out the views with the
    appropriate data. It is important to point out that we did not use a `PagerAdapter`
    directly, but rather one of its variants, the `FragmentPagerAdapter`, which is
    designed to work with fragments There is also the `FragmentSatePagerAdapter`,
    which does an identical job, but is better suited to longer lists. The reason
    for this is the way the framework handles those pages that are not directly visible
    to the user. For short lists, such as ours, the best performance can be obtained
    with `FragmentPagerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Fragment` class we created is also very simple to understand as it does
    little more than inflating our `fragment_layout`, associating and setting our
    views in a way that is, by now, very familiar to us. Fragments are very similar
    to Activities as they each have their own life cycle, which can be intercepted
    at various points with callback methods, such as `onCreate()` and `onPause()`
    in the same way as we do with Activities. Here, we chose to use the `onCreateView()`
    method as it provides access to the instances we need to inflate the fragment
    along with the page index stored in a Bundle by the adapter and is also called
    when the view is created.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewPagers` provides a lot of functionality with very little effort. Once
    connected to an adapter, we can create a screen slide without worrying about implementing
    touch listeners and having to pay much attention to which page has been selected
    at any given time.'
  prefs: []
  type: TYPE_NORMAL
- en: As it stands, our app does very little, and we need to provide more functionality,
    which we will do by firstly adding tabs to the action bar so that we can associate
    each page with an actual date, and secondly by programming a notification builder
    to issue weather alerts via the system notification area. We will begin by adding
    tabs with dates.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tabs and dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A weather forecasting app is of no use if the user does not know when to expect
    the weather predicted. We could easily add another view to our fragment layout,
    but we will attach our pages to the tabs on the action bar, and access calendar
    and date format classes to populate them.
  prefs: []
  type: TYPE_NORMAL
- en: To intercept changes between the pages, we will need an `OnPageChangeListener`,
    which is called whenever the page changes, and to redefine the class declaration
    so that it implements an `ActionBar.TabListener`. We will use Java's own `Calendar`
    and `SimpleDateFormat` objects to calculate and format our dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything we need to do to add tabs to our action bar can be done from within
    our `MainActivity` class by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainActivity.java` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the declaration like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the error this generates, follow the editor's recommendation, and implement
    the three methods suggested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `onTabSelected()` method to match the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the following class field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines to the `onCreate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within `onCreate()`, include the following listener to detect page changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now run the project on a device or AVD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tabbed action bar is a familiar sight on many Android applications and the
    `ActionBar.TabListener` is an interface that is called whenever a tab is selected,
    added, or removed. Here, we use its selection to inform our `ViewPager` of the
    change. The `ViewPager` layout also provides a good opportunity to see how the
    colors we defined earlier are applied to the various components of the UI, such
    as the colored hint that appears when the user attempts to scroll beyond either
    end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding tabs and dates](img/B04321_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Calendar` and `SimpleDateFormat` classes are not hard to follow. The date
    formatting follows **Unicode Technical Standards** (**UTS**) #35, the details
    of which can be found at [http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns](http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns).
    Here, we applied a stand-alone day-of-week format with `"cccc"`. We could have
    been more creative and used something like `"c LLL d"` to have something like
    **Tue Mar 15** or even taken advantage of the system''s built-in formatting by
    changing the `dayFormat` assignation to `dayFormat = (SimpleDateFormat) new SimpleDateFormat().getDateInstance();`,
    as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding tabs and dates](img/B04321_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final part of the puzzle is put into place with the `ViewPager.OnPageChangeListener`,
    which we use to inform the action bar when a new page is selected with a swipe
    rather than a tab.
  prefs: []
  type: TYPE_NORMAL
- en: With both forms of navigation in place and connected, we can now move on and
    program our app to issue notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Programming notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android 5 provides a more flexible notification framework than the previous
    versions. In addition to being able to issue standard notifications to the notification
    bar, we can now expand notifications to include more detail than before, and are
    able to notify the user when they are using a full-screen app, or even when their
    screen is locked, with **heads-up notifications** that float above the screen
    for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: When using notifications, it is important to be sensitive to our user's needs
    and not issue too many notifications or give them too great a level of importance.
    It is for this reason that notifications can be assigned **priority and visibility**
    settings. With that said, it is now time to proceed with adding notifications
    to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a standard notification and icon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming the notification we wish to deliver is neither important nor personal,
    and all we wish to do is to inform the user of some event and offer them the opportunity
    to open our app, we need to issue a standard notification so that a small icon
    appears on the notification bar and, when the drawer is opened, a small card appears
    with some brief text and an icon. This, if clicked on, will open our app. Notifications
    require a particular type of icon for display on the bar. We will begin with this
    and then continue to implement a notification. Complete the following steps to
    set this up on our weather app:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not downloaded the project files, you will need a small icon of
    a single color against a transparent background (like the one you see here) called
    `small_icon.png`, and stored in the `drawable` directory:![Adding a standard notification
    and icon](img/B04321_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the MainActivity Java file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this class field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onCreate()` method, add the following clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `postAlert()` method and complete it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application can now be tested on an emulator or device, and opening the
    notification drawer should produce the following result:![Adding a standard notification
    and icon](img/B04321_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are quite a few things going on here. Firstly, there was the **notification
    icon**. This is required by the builder and has to be of a specific format. Apart
    from being small, the icon needs to be a simple design on a transparent background.
    The color of the image is immaterial as only the alpha channel is considered by
    the system. For this reason, colors with intermediate alpha levels are strongly
    discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting to the rest of the code, it would be amiss not to point out
    that there is an alternative to using the small icon on the notification pop-down,
    which, although suitable for the minimal space on the bar, does not always look
    great in the circular icon to the left of the larger view. Add the following setting
    to our builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the app now produces an icon like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a standard notification and icon](img/B04321_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We used `NotificationCompat` to construct our builder. `NotificationCompat`
    is a helper class provided by the support libraries we imported earlier. The `Builder`
    itself has three required parameters: `ContentTitle`, `ContentText`, and `SmallIcon`.
    There are many others, which we will get to, but only these three are mandatory.
    I have also set `AutoCancel` to true as this is extremely helpful because it automatically
    closes the notification once it has been selected from the drawer. The purpose
    of setting `Builder.Ticker` would have become apparent when the app was run.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of their available position, notifications can be viewed and triggered
    when other apps have the focus. This can lead to confusing results for the user
    when they press the back key. We want the navigation keys to behave as if the
    app had been launched in the usual way. This is the function of the **TaskStackBuilder**,
    which takes an **Intent** in this case to launch our MainActivity, and places
    it onto the recent activities back stack and the PendingIntent makes it available
    outside our app.
  prefs: []
  type: TYPE_NORMAL
- en: The actual notification is called with the `NotificationManager.notify()` call.
    The use of an ID was not strictly necessary here as our app only issues one notification
    at a time. However, not only is it a useful way to keep track of multiple notifications,
    but can also be used, as we did here, to ensure that a notification is issued
    only once.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding a notification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NotificationCompat` class provides us with three built-in styles. Here,
    we will use `BigPictureStyle`. Before we start, you will need an image to use
    as the "big picture". Find a suitable image of around 640 x 480 px, place it in
    your `drawable` folder, and name it `snow_scene` or change the reference in the
    following code. Once your image is in place, follow these short steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainActivity.java` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `onCreate()` method, just before our Intent is
    declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! Run the app on your handset or emulator and open the notification
    drawer.![Expanding a notification](img/B04321_06_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `NotificationCompat.Style` objects are very handy to add details to our
    notifications, and simple to understand and use. Along with `BigPictureStyle`,
    there is `BigTextStyle` for headline type notifications and `InboxStyle` for lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with two other new notification features: heads-up notifications
    and lock screen notifications. Neither of these requires any additional coding
    as such, but they are triggered by adjusting certain privacy and priority settings
    of the existing notifications. The next and final section of this chapter demonstrates
    how this is done.'
  prefs: []
  type: TYPE_NORMAL
- en: Issuing heads-up and lock screen notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heads-up and lock screen notifications are created in the same way as the standard
    notifications. The difference depends on the `VISIBILTY` and `PRIORITY` properties
    of our `NotificationCompat.Builder` class. The following are the steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainActivity` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give our builder instance the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the app is run, it will now display heads-up and lock screen notifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The screen can be locked on an emulator by pressing *F7*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, the `setPriority()` method is how we decide whether a notification is
    important enough to consider using a heads-up message that may intrude on some
    other task they are performing more than the standard version. Priority must be
    set to `PRIORITY_HIGH` or `PRIORITY_MAX` and the notification must be set to trigger
    a vibration for notifications to appear in this manner. The other priorities are
    `MIN`, `LOW`, and `DEFAULT`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you do not wish for your notification to set off a vibration, but still
    appear in a heads-up fashion, you can use the following line instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Although there are more intricate ways to configure a vibration, the constructor
    used here will suit most purposes. The array of longs represents alternating times
    in milliseconds, representing pulses of vibration and silence alternatively so
    that, in the example here, the device would buzz three times for 100 ms with pauses
    of 50 ms in between.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other notifications, the user can choose, via settings, whether or not
    the device displays lock screen messages. As developers, however, we can decide
    how much, if any, information is displayed on the user's lock screen.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the visibility of a notification to `PUBLIC` will cause both content
    title and content text to be displayed, setting it to `PRIVATE` will display only
    the title, and `SECRET` will display nothing at all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored an alternative to the vertically scrolling `RecyclerView`
    with the `ViewPager`. We used Fragments instead of Activities, and saw some of
    the things we can do with the Action Bar. We learnt how to issue notifications
    of all kinds and how to manage the back stack so as to provide consistent navigation
    back through our app for the user. In most cases, notifications are sent when
    our app is not even actively running; to do this, we will need to use Services,
    which are a kind of background Activity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how to include Google Maps into
    our apps and make them location-aware. This involves having to register our app
    for an API key and employing a `LocationListener` to keep our app updated with
    current location data; as this can be resource hungry, we will also see how to
    optimize this process.
  prefs: []
  type: TYPE_NORMAL
