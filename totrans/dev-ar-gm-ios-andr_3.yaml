- en: Chapter 3. Understanding Vuforia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will go over the components Vuforia provides with the SDK,
    and how to construct an AR scene. The addition of the SDK to a project will be
    covered, and how to include and activate the trackable data to be recognized in
    the app. We will create a very simple project from scratch similar to the example
    project provided by Vuforia to see how all the components fit together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Unity project with Vuforia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the previous chapter, we know how to create a project easily from Unity.
    Do not forget to exclude any spaces in the project name. This will create an empty
    project that we can build our AR app on.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Unity projects are created preset to the PC and Mac stand-alone
    platform. We need to change that to iOS. The current platform is always visible
    on the window title bar on the top.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows platform switching.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Unity project with Vuforia](img/0032_3_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After switching the platform, it is time to add the Vuforia SDK to our project.
    To do that, click on the **Asset** menu in the menu bar, then inside **Import
    package ...**, click on **custom package**. This is exactly the same way we imported
    the sample project from Vuforia to our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now find where Vuforia SDK was installed and choose the Vuforia Unity package
    to be imported into the project. The following screenshot shows the importing
    of a Vuforia package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Unity project with Vuforia](img/0032_3_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that the entire Vuforia library has been added to the project, we can start
    looking at the components that comes with it. All that makes a Vuforia project
    is within the **Qualcomm Augmented Reality** folder inside the project. This folder
    will contain all the scripts that control the behavior of the AR experience. Not
    only scripts, but some shaders and textures as well. They are mainly used for
    the video background rendering of the AR app.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we don't have to deal directly with most of those scripts, as Vuforia
    bundles the necessary components in Unity prefabs ready to be dropped into the
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Vuforia prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **prefab** is essentially a type of asset that is created in Unity to be a
    reusable game object stored in Project view. Prefabs can be inserted as many times
    as we want into the scene and with any object transformation applied to it. When
    added to the scene, they are basically an instance of the original prefab and
    linked to it. When a change is applied to the original prefab, all its instances
    will copy it, as they are essentially clones of it.
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs are an indispensable tool for Unity. It makes the creation of standard
    scene components a much easier task. Imagine we are making a game with many enemy
    non-player characters. It will take a lot of time to manually construct every
    one of them, but if we create a single enemy prefab and then clone it multiple
    times, it will make constructing the scene much easier. Also if we want to edit
    the entire enemy NPCs, we only have to edit the prefab and the change will propagate.
  prefs: []
  type: TYPE_NORMAL
- en: Unity prefabs also make it easier to share components between projects if they
    are to be exported into Unity packages. This is essentially what Qualcomm did
    with Vuforia components. All the components that make the AR scene are stored
    as prefabs that are ready to be dropped into the scene; we only needs its parameters
    adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Vuforia prefabs can be found inside the **Prefabs** folder inside the **Qualcomm
    Augmented Reality** folder. The following screenshot shows the **Qualcomm Augmented
    Reality Prefabs** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia prefabs](img/0032_3_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inside the **Prefabs** folder, we will find all the components explained before
    such as the **ImageTarget** prefab and the **FrameMarker** prefab. We will also
    find the **ARCamera** prefab, which is the common thing among any type of AR app.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when Unity creates a new scene, it adds a camera to the scene such
    as the one in the **Hierarchy** panel. In our case, we will use Vuforia's special
    **ARCamera** prefab in our scene. So we need to first delete the **Main Camera**
    object from the **Hierarchy** panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply select the **Main Camera** from the scene **Hierarchy** and right click
    on it, then click on **Delete**. Now drag-and-drop the **ARCamera** prefab to
    the scene. Anywhere on the scene is fine. Now to focus on its position, select
    the **ARCamera** from the **Hierarchy** panel and hold the *F* keyboard key till
    the focus is on it. When holding the *F* key, make sure the mouse pointer is over
    the scene panel, or the focus will not work. The following screenshot shows **ARCamera**
    prefab added to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia prefabs](img/0032_3_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the rest of the components is just as easy. Now that we have an **ARCamera**
    prefab added to the scene, we just need to add the **ImageTarget** prefab to the
    scene as well. Drag and drop the **ImageTarget** prefab anywhere on the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'This prefab is the platform that we will add the 3D content to. It will also
    hold the image target that the app will track to orient `ARCamera` the way we
    saw in the sample app. The following screenshot shows **ImageTarget** prefab added
    to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia prefabs](img/0032_3_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Depending on where the `ImageTarget` prefab was dropped in the scene, its position
    in the game world displayed in the transform section will differ. **Transform**
    is basically the position of the game object in the game world. Transform holds
    three different vectors for three different data about the position of the object.
    That data is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Position**: This is the position of the object in the three axes, x, y, and
    z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotation**: This is the rotation of the object in the three axes , x, y,
    and z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale**: This is the size scale of the object compared to its original size
    in the game world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Objects can be anywhere in the world, but it is recommended to keep the world''s
    floor at *y=0*. By keeping the floor to `0`, it simplifies a lot of other aspects
    of code when it comes to changing the transformation of object through scripts.
    So now change all the `ImageTarget`''s position to be (*x=0*, *y=0*, *z=0*). This
    will position the object in the origin of the world and simplifies the position
    aspect of subsequent game objects. The following screenshot shows the image target
    inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia prefabs](img/0032_3_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As it is noticeable from the inspector, there are a lot of settings for Image
    Target that might seem intimidating at first. One of those components is named
    **Image Target Behaviour (Script)**, which is highlighted in the image above;
    this is responsible for attaching the image target data to the image target object.
    Right now, it has no target defined in the app because we haven't added any yet,
    hence the white representation of the image target.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to add the image target''s data into the app.
    We do that by importing the dataset''s Unity package that is available with the
    book content by the name `exampleDataset.unitypackage`. Import the package in
    the same way we imported all the other Unity packages. The following screenshot
    shows **exampleDataset.unityPackage**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia prefabs](img/0032_3_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What this package essentially contains is the data of the target image that
    Vuforia's tracking algorithm can effectively look for from the camera's feed.
    It also carries a texture representation of the target image to be viewed inside
    Unity's editor while developing the app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the project contains the tracking data, a new selection will appear
    inside the `ImageTarget` prefab for the **Image Target Behaviour**. We will be
    able to select any of the images imported from the target package and the `ImageTarget`
    prefab will instantly adopt it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to select the dataset that contains the images. From the dropdown
    menu, we can select the only dataset available, named **exampleDataset**. From
    the dropdown menu below, we can choose the specific target image. Choose the target
    image stones. Notice immediately the **ImageTarget** representation in the game
    world carries now the target image. The following screenshot shows the dataset
    selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia prefabs](img/0032_3_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Datasets are essentially a collection of image targets that Vuforia will track
    simultaneously for any of the images inside it. Inside the dataset that we imported,
    we have images images from the Vuforia sample project. The app will track all
    three images at any given time till it finds any of the images to render the 3D
    material on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: The app can have multiple datasets with as many as 100 images in each one of
    them. That is a substantial number of images that Vuforia can track. We also have
    the ability to activate and deactivate any of the datasets from the editor or
    from script.
  prefs: []
  type: TYPE_NORMAL
- en: When we added the dataset to the `ImageTarget`, it represented the image target
    in the world right away, but that doesn't necessarily mean that `ARCamera` will
    be tracking that dataset. For that, we need to first activate the dataset and
    tell the `ARCamera` to start tracking that dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **ARCamera** object from the **Hierarchy** panel. In the inspector,
    we can find the **Script** component **Data Set Load Behaviour (Script)**. Inside
    the component, there will be one checkbox with the label **Load Data Set exampleDataset**.
    If we click on the checkbox, another one will appear with the label **Activate**.
    Click on that as well. Now the dataset is loaded and activated. The following
    screenshot shows the activated dataset in **ARCamera**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuforia prefabs](img/0032_3_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a particular reason why we need to both load and activate the datasets
    as separate options. The datasets will be loaded but not necessarily tracked at
    the start of the scene if added to the `ARCamera` component. From script, we can
    then enable and disable tracking for any of them without the need for loading
    overhead. The process is very fast that way.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that Vuforia both knows what trackables to track and is actively
    tracking them. We added the `ImageTarget` prefab and set it to the **Stones**
    image target. If we are to press play and present the camera with the stones image
    target, nothing will happen beyond a console log declaring it has detected the
    image target. We might even notice the `ARCamera` frantically moving around the
    game world in relation to the image target in the editor. That is simply because
    we do not have any 3D content attached to the target image just yet.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and attaching 3D objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity is capable of importing 3D models from many well-established formats.
    Models can be created from any of the 3D modeling applications such as 3D max,
    Maya, and Blender. As long as the model is exported in a Unity-supported format,
    it is easily imported into the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formats supported by Unity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Maya (`.mb` and `.ma`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D Studio Max (`.max`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cheetah 3D (`.jas`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cinema 4D (`.c4d`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blender (`.blend`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modo (`.lxo`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autodesk (`.fbx`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COLLADA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carrara
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightwave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XSI 5.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SketchUp Pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wings 3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D studio (`.3ds`, does not work on Mac OSX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wavefront (`.obj`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing Interchange Files (`.dxf`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is quite extensive. It is quite safe to assume that Unity will support
    most known 3D model formats. Notice though that Unity uses the 3D modeling application
    to convert the model format to FBX, which then can be imported by Unity. This
    process is mostly automatic and produces smooth results and streamlines the workflow
    considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to add our own 3D model to the project. Firstly, we need to create
    a folder for models in our project. We will use it to include all models in our
    project. In the **Assets** root folder, create a folder and name it `Models`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing assets is easily done from the **Assets** menu at the top. Click
    on **Import New Asset** from the menu, and point at the chapter''s assets folder
    and choose `frog.fbx` file. Unity will start importing the asset right away. The
    following screenshot shows Unity imported **Frog** asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have the 3D model in our project, it is that easy to add models to Unity
    projects. That is good news because for a game engine, adding models is one of
    the top chores done in projects. Are you wondering why the 3D model is a frog?
    It is because it's generally good for developers to have a sense of humor; it
    helps.
  prefs: []
  type: TYPE_NORMAL
- en: When importing the 3D model, it created two folders and one file for us. The
    folders contain materials for the 3D model and settings for the FBX import. The
    file is actually a Unity prefab of the model with the materials attached ready
    to be dropped to the scene. Unity creates the prefab automatically for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can drag the **Frog** prefab and drop it in our scene. The frog 3D model
    will appear in our game world. The following screenshot shows the frog model added
    to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just as when we added the `ImageTarget` prefab, the frog's position in the scene
    is almost certainly not right. We need to position it on top of the `ImageTarget`
    and for it to face the right way, but first we need to approximate its position
    in relation to the `ImageTarget` better. Remember when we added the `ImageTarget`;
    we positioned it at the game world's origin at `(0,0,0)` position. We will do
    the same for the frog as a first step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the frog from the **Hierarchy**, and from the inspector panel in **Transform**
    position, set x, y and z to zero. The following screenshot shows the frog position
    at the origin point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing to notice wrong with the frog is that it is sunk in the `ImageTarget`.
    The other problem is that it is too small for the `ImageTarget`.
  prefs: []
  type: TYPE_NORMAL
- en: First we will try to position the frog above the `ImageTarget`. At the top left
    of Unity, make sure that you have the directional cross button selected. This
    allows us to change the position of the selected object. Notice the green, blue,
    and red axes coming out of the frog. They are the relative position of the object
    in the game world. Green is for the y axis, red for the x axis, and blue for the
    z axis. We will want to move the object in the y axis to get it above the `ImageTarget`.
    To do that, simply drag the green axis and move the mouse up; the object will
    move up with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Position the frog anywhere above the `ImageTarget`. It doesn''t have to be
    perfect for now. The following screenshot shows the frog positioned higher in
    the y axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now for the second problem, its size; we will need to scale it up considerably
    to fit the `ImageTarget`.
  prefs: []
  type: TYPE_NORMAL
- en: While the frog is selected from the scene, click on the **Scale** button from
    the top left menu. It is the last icon on the right of a square with arrows coming
    out of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scaling button allows us to scale the object in the scene on any axis or
    all axes. Since we need the object to scale in every direction equally to avoid
    the frog being stretched in one direction more than the other, we need to click
    on the square at the origin of the three axes now represented on the object, and
    then drag the mouse over it. The following screenshot shows the scaled up the
    frog object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scaling up to `10` in the inspector should be sufficient, but since there are
    no constraints, we can make it as big or as small as we want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to make the frog face the right way, opposite to where it's facing
    right now. To do that we need to activate the Rotation button in the top left
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Rotation button is activated, the axes over the object will look quite
    different. For a start they are spherical in nature, and there are more than just
    the (x, y, and z) axes.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation functions in a similar manner, despite the different look to the other
    transformation tools. By dragging on the (x, y, and z) axes, we can rotate the
    object around any of the three axes. The remaining white axes are diagonal rotations
    for easy access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the green y axis to rotate the object to face the right way. Notice the
    rotation data in the inspector changing around the y axis. We need it to be around
    `180` or `-180` degrees. Note that we can just input that number in the rotation
    section of the inspector to reach the same result. The following screenshot shows
    the rotated frog object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the frog is rotated to face the right way in relation to the trackable,
    we only need to position it higher up to be right on top of the trackable. We
    can achieve that in the same way we positioned the frog before. Only this time
    with more care and we must rotate the editor camera several times to make sure
    the frog is positioned from all angles correctly. The following screenshot shows
    correctly the positioned frog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now the frog is positioned perfectly fine on top of the image target, all is
    good. You would notice, though, that the frog seems to have dull colors. That
    is mainly due to the lack of any light sources in the scene; this is what we are
    going to add next.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the top menu, choose **GameObject**. From the menu click on **Directional
    Light** from the **Create Other** menu. This adds an object called Directional
    Light to your scene. The following screenshot shows Directional Light added to
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing and attaching 3D objects](img/0032_3_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Directional Light is a type of scene light that is quite easy to add and cheap
    on device resources. It essentially acts like a sun, lighting up any object in
    the direction you point it at. All we need to do is adjust the object's rotation.
    Its position in the game world doesn't mean much, because its light is only based
    on its direction, not its position.
  prefs: []
  type: TYPE_NORMAL
- en: Now the frog is where we want it to be, and looking good. We might be tempted
    to press the **Play Button** now and test the AR experience. If we do that and
    present the camera with the trackable, the frog will appear correctly. But once
    the trackable is lost to the camera, we will find that the frog remains on the
    screen regardless. This happens because we did not parent the frog with the image
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Parenting in Unity objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a good reason Unity's **Hierarchy** panel is named that way. That is
    because it represents the object's hierarchy in the scene. If we are to click
    on the arrow next to the frog object in the **Hierarchy** panel, it will reveal
    a number of objects below it. These objects are essentially children of the object
    frog.
  prefs: []
  type: TYPE_NORMAL
- en: The parent object frog contains many children under it in **Hierarchy** that
    essentially means that the children's transformation will follow that of the parent.
    When we moved the frog object around, we didn't have to individually move the
    children as we did so; they automatically moved with the parent object. That is
    fortunate because it would have consumed a lot of time to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Parenting in Unity happens for a number of reasons. Whether it's script access,
    transformation, or simple grouping, Unity parenting is a very important feature.
  prefs: []
  type: TYPE_NORMAL
- en: For image targets to work correctly, we must parent them over any 3D content
    they will display. This is a must for Vuforia to be able to control when and how
    the 3D content is shown to match that of the image target.
  prefs: []
  type: TYPE_NORMAL
- en: 'To parent it, we simply need to drag the frog object and drop it over the `ImageTarget`
    object in the **Hierarchy** panel. The following screenshot shows the parented
    frog object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parenting in Unity objects](img/0032_3_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With that our AR project should be functional and displays the frog correctly
    once we click on the **Play Button** to test it. We can deploy it on the device
    if we follow the settings explained in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Through this chapter, we have learned how to build a Vuforia project from scratch
    in Unity, how to import and present our 3D objects, and how to add and set up
    Vuforia components to correctly display it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our new Unity project that we added Vuforia SDK
    to. We were introduced to the meaning of the term prefab and then explored the
    different prefabs that are packaged inside Vuforia SDK. We saw how to build up
    an AR scene using Vuforia prefabs, especially the `ARCamera` prefab and `ImageTarget`
    prefab. We then understood the method in which we add targets to the project and
    how to activate those datasets in our project. We also saw how easy it is to add
    a 3D model to a Unity project and position it in our scene however we like and
    add appropriate lightening.
  prefs: []
  type: TYPE_NORMAL
- en: Next chapter, we will see how to create our own target datasets in the target
    manager, and understand how to obtain the best targeting results from the images
    we choose.
  prefs: []
  type: TYPE_NORMAL
