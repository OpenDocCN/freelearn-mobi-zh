["```swift\n@interface MXMoleHill : CCNode {\n\n  NSInteger moleHillID;\n  CCSprite *moleHillTop;\n  CCSprite *moleHillBottom;\n  NSInteger moleHillBaseZ;\n  MXMole *hillMole;\n  BOOL isOccupied;\n}\n\n@property (nonatomic, assign) NSInteger moleHillID;\n@property (nonatomic, retain) CCSprite *moleHillTop;\n@property (nonatomic, retain) CCSprite *moleHillBottom;\n@property (nonatomic, assign) NSInteger moleHillBaseZ;\n@property (nonatomic, retain) MXMole *hillMole;\n@property (nonatomic, assign) BOOL isOccupied;\n\n@end\n```", "```swift\n#import <Foundation/Foundation.h>\n#import \"cocos2d.h\"\n#import \"MXDefinitions.h\"\n#import \"SimpleAudioEngine.h\"\n\n// Forward declaration, since we don't want to import it here\n@class MXMoleHill;\n\n@interface MXMole : CCNode <CCTargetedTouchDelegate> {\n  CCSprite *moleSprite;  // The sprite for the mole\n    MXMoleHill *parentHill;  // The hill for this mole\n  float moleGroundY;  // Where \"ground\" is\n    MoleState _moleState; // Current state of the mole\n    BOOL isSpecial; // Is this a \"special\" mole?\n}\n\n@property (nonatomic, retain) MXMoleHill *parentHill;\n@property (nonatomic, retain) CCSprite *moleSprite;\n@property (nonatomic, assign) float moleGroundY;\n@property (nonatomic, assign) MoleState moleState;\n@property (nonatomic, assign) BOOL isSpecial;\n\n-(void) destroyTouchDelegate;\n\n@end\n```", "```swift\ntypedef enum {\n    kMoleDead = 0,\n    kMoleHidden,\n    kMoleMoving,\n    kMoleHit,\n    kMoleAlive\n} MoleState;\n\n#define SND_MOLE_NORMAL @\"penguin_call.caf\"\n#define SND_MOLE_SPECIAL @\"penguin_call_echo.caf\"\n#define SND_BUTTON @\"button.caf\"\n```", "```swift\n-(void) drawHills {\n    NSInteger hillCounter = 0;\n    NSInteger newHillZ = 6;\n\n    // We want to draw a grid of 12 hills\n    for (NSInteger row = 1; row <= 4; row++) {\n        // Each row reduces the Z order\n        newHillZ--;\n        for (NSInteger col = 1; col <= 3; col++) {\n            hillCounter++;\n\n            // Build a new MXMoleHill\n            MXMoleHill *newHill = [[MXMoleHill alloc] init];\n            [newHill setPosition:[self\n                hillPositionForRow:row andColumn:col]];\n            [newHill setMoleHillBaseZ:newHillZ];\n            [newHill setMoleHillTop:[CCSprite\n                spriteWithSpriteFrameName:@\"pileTop.png\"]];\n            [newHill setMoleHillBottom:[CCSprite\n                spriteWithSpriteFrameName:@\"pileBottom.png\"]];\n            [newHill setMoleHillID:hillCounter];\n\n            // We position the two moleHill sprites so \n            // the \"seam\" is at the edge.  We use the\n            // size of the top to position both, \n            // because the bottom image\n            // has some overlap to add texture\n            [[newHill moleHillTop] setPosition:\n                ccp(newHill.position.x, newHill.position.y +\n                [newHill moleHillTop].contentSize.height\n                    / 2)];\n            [[newHill moleHillBottom] setPosition:\n                ccp(newHill.position.x, newHill.position.y - \n                [newHill moleHillTop].contentSize.height\n                    / 2)];\n\n            //Add the sprites to the batch node\n            [molesheet addChild:[newHill moleHillTop]\n                              z:(2 + (newHillZ * 5))];\n            [molesheet addChild:[newHill moleHillBottom]\n                              z:(5 + (newHillZ * 5))];\n\n            //Set up a mole in the hill\n            MXMole *newMole = [[MXMole alloc] init];\n            [newHill setHillMole:newMole]; \n            [[newHill hillMole] setParentHill:newHill]; \n            [newMole release];\n\n            // This flatlines the values for the new mole\n            [self resetMole:newHill];\n\n            [moleHillsInPlay addObject:newHill];\n            [newHill release];\n        }\n    }\n}\n```", "```swift\n-(CGPoint) hillPositionForRow:(NSInteger)row\n                    andColumn:(NSInteger)col {\n    float rowPos = row * 82;\n    float colPos = 54 + ((col - 1) * 104);\n    return ccp(colPos,rowPos); \n}\n```", "```swift\n-(void) drawGround {\n    // Randomly select a ground image\n    NSString *groundName;\n    NSInteger groundPick = CCRANDOM_0_1() * 2;\n\n    switch (groundPick) {\n        case 1:\n            groundName = @\"ground1.png\";\n            break;\n        default: // Case 2 also falls through here\n            groundName = @\"ground2.png\";\n            break;\n    }\n\n    // Build the strips of ground from the selected image\n    for (int i = 0; i < 5; i++) {\n        CCSprite *groundStrip1 = [CCSprite\n                spriteWithSpriteFrameName:groundName];\n        [groundStrip1 setAnchorPoint:ccp(0.5,0)];\n        [groundStrip1 setPosition:ccp(size.width/2,i*82)];\n        [molesheet addChild:groundStrip1 z:4+((5-i) * 5)];\n    }\n\n    // Build a skybox\n    skybox = [CCSprite\n              spriteWithSpriteFrameName:@\"skybox1.png\"];\n    [skybox setPosition:ccp(size.width/2,5*82)];\n    [skybox setAnchorPoint:ccp(0.5,0)];\n    [molesheet addChild:skybox z:1];\n}\n```", "```swift\n-(void) spawnMole:(id)sender {\n  // Spawn a new mole from a random, unoccupied hill\n  NSInteger newMoleHill;\n  BOOL isApprovedHole = FALSE;\n  NSInteger rand;\n  if (molesInPlay == [moleHillsInPlay count] ||\n        molesInPlay == maxMoles) {\n    // Holes full, cannot spawn a new mole\n  } else {\n    // Loop until we pick a hill that isn't occupied\n    do {\n      rand = CCRANDOM_0_1() * maxHills;\n\n      if (rand > maxHills) { rand = maxHills; }\n\n            MXMoleHill *testHill = [moleHillsInPlay\n                                    objectAtIndex:rand];\n\n            // Look for an unoccupied hill\n      if ([testHill isOccupied] == NO) {\n        newMoleHill = rand;\n        isApprovedHole = YES;\n        [testHill setIsOccupied:YES];\n      }\n    } while (isApprovedHole == NO);\n\n    // Mark that we have a new mole in play\n    molesInPlay++;\n\n    // Grab a handle on the mole Hill \n    MXMoleHill *thisHill = [moleHillsInPlay\n                        objectAtIndex:newMoleHill];\n\n    NSInteger hillZ = [thisHill moleHillBaseZ];\n\n    // Set up the mole for this hill\n    CCSprite *newMoleSprite = [CCSprite\n             spriteWithSpriteFrameName:@\"penguin_forward.png\"];\n\n    [[thisHill hillMole] setMoleSprite:newMoleSprite];\t\t\n    [[thisHill hillMole] setMoleState:kMoleAlive];\n\n    // We keep track of where the ground level is\n    [[thisHill hillMole] setMoleGroundY:\n                                thisHill.position.y];\n\n    // Set the position of the mole based on the hill\n    float newMolePosX = thisHill.position.x;\n    float newMolePosY = thisHill.position.y - \n        (newMoleSprite.contentSize.height/2);\n\n    [newMoleSprite setPosition:ccp(newMolePosX,\n                                       newMolePosY)];\n\n    // See if we need this to be a \"special\" mole\n    NSInteger moleRandomizer = CCRANDOM_0_1() * 100;\n\n    // If we randomized under 5, make this special\n    if (moleRandomizer < 5) {\n            [[thisHill hillMole] setIsSpecial:YES];\n    }\n\n    //Trigger the new mole to raise\n    [molesheet addChild:newMoleSprite\n                          z:(3 + (hillZ * 5))];\n    [self raiseMole:thisHill];\n  }\n}\n```", "```swift\n-(void) buildAnimations {\n    // Load the Animation to the CCSpriteFrameCache\n    NSMutableArray *frameArray = [NSMutableArray array];\n\n    // Load the frames\n    [frameArray addObject:[[CCSpriteFrameCache\n            sharedSpriteFrameCache]\n            spriteFrameByName:@\"penguin_forward.png\"]];\n    [frameArray addObject:[[CCSpriteFrameCache\n            sharedSpriteFrameCache]\n            spriteFrameByName:@\"penguin_left.png\"]];\n    [frameArray addObject:[[CCSpriteFrameCache\n            sharedSpriteFrameCache]\n            spriteFrameByName:@\"penguin_forward.png\"]];\n    [frameArray addObject:[[CCSpriteFrameCache\n            sharedSpriteFrameCache]\n            spriteFrameByName:@\"penguin_right.png\"]];\n    [frameArray addObject:[[CCSpriteFrameCache\n            sharedSpriteFrameCache]\n            spriteFrameByName:@\"penguin_forward.png\"]];\n    [frameArray addObject:[[CCSpriteFrameCache\n            sharedSpriteFrameCache]\n            spriteFrameByName:@\"penguin_forward.png\"]];\n\n    // Build the animation\n    CCAnimation *newAnim = [CCAnimation\n            animationWithSpriteFrames:frameArray delay:0.4];\n\n    // Store it in the cache\n    [[CCAnimationCache sharedAnimationCache]\n            addAnimation:newAnim name:@\"penguinAnim\"];\n}\n```", "```swift\n[[CCAnimationCache sharedAnimationCache]\n                  animationByName:@\"penguinAnim\"]]\n```", "```swift\n-(void) raiseMole:(MXMoleHill*)aHill {\n  // Grab the mole sprite\n  CCSprite *aMole = [[aHill hillMole] moleSprite];\n\n    float moleHeight = aMole.contentSize.height;\n\n  // Define the hole wobble/jiggle\n  CCMoveBy *wobbleHillLeft = [CCMoveBy\n            actionWithDuration:.1 position:ccp(-3,0)];\n  CCMoveBy *wobbleHillRight =[CCMoveBy\n            actionWithDuration:.1 position:ccp(3,0)];\n  // Run the actions for the hill\n  [[aHill moleHillBottom] runAction:\n            [CCSequence actions:wobbleHillLeft,\n             wobbleHillRight, wobbleHillLeft,\n             wobbleHillRight, nil]];\n\n  // Define some mole actions.\n    // We will only use some of them on each mole\n  CCMoveBy *moveUp = [CCMoveBy\n            actionWithDuration:moleRaiseTime\n            position:ccp(0,moleHeight*.8)];\n  CCMoveBy *moveUpHalf = [CCMoveBy\n            actionWithDuration:moleRaiseTime\n            position:ccp(0,moleHeight*.4)];\n  CCDelayTime *moleDelay = [CCDelayTime\n            actionWithDuration:moleDelayTime];\n  CCMoveBy *moveDown = [CCMoveBy\n            actionWithDuration:moleDownTime\n            position:ccp(0,-moleHeight*.8)];\n  CCCallFuncND *delMole = [CCCallFuncND\n            actionWithTarget:self\n            selector:@selector(deleteMole:data:)\n            data:(MXMoleHill*)aHill];\n    CCAnimate *anim = [CCAnimate\n            actionWithAnimation:[[CCAnimationCache\n            sharedAnimationCache]\n            animationByName:@\"penguinAnim\"]];\n    CCRotateBy *rot1 = [CCRotateBy\n            actionWithDuration:moleDelayTime/3 angle:-20];\n    CCRotateBy *rot2 = [CCRotateBy\n            actionWithDuration:moleDelayTime/3 angle:40];\n    CCRotateBy *rot3 = [CCRotateBy\n            actionWithDuration:moleDelayTime/3 angle:-20];\n\n    // We have 6 behaviors to choose from. Randomize.\n    NSInteger behaviorPick = CCRANDOM_0_1() * 6;\n\n    // If this is a special mole, let's control him better\n    if ([aHill hillMole].isSpecial) {\n\n        // Build some more actions for specials\n        CCTintTo *tintR = [CCTintTo actionWithDuration:0.2\n                        red:255.0 green:0.2 blue:0.2];\n        CCTintTo *tintB = [CCTintTo actionWithDuration:0.2\n                        red:0.2 green:0.2 blue:255.0];\n        CCTintTo *tintG = [CCTintTo actionWithDuration:0.2\n                        red:0.2 green:255.0 blue:0.2];\n\n        // Set a color flashing behavior\n        [aMole runAction:[CCRepeatForever\n                actionWithAction:[CCSequence actions:\n                tintR, tintB, tintG, nil]]];\n        // Move up and down and rotate/wobble\n        [aMole runAction:[CCSequence actions:moveUp, rot1,\n                rot2, rot3, rot1, rot2, rot3, moveDown,\n                delMole, nil]];\n    } else {\n        switch (behaviorPick) {\n            case 1:\n                // Move up and down and rotate/wobble\n                [aMole runAction:[CCSequence actions:\n                    moveUp, rot1, rot2, rot3, moveDown,\n                    delMole, nil]];\n                break;\n            case 2:\n                // Move up and then down without pausing\n                [aMole runAction:[CCSequence actions:\n                    moveUp, moveDown, delMole, nil]];\n                break;\n            case 3:\n                // Move up halfway and then down\n                [aMole runAction:[CCSequence actions:\n                    moveUpHalf, moleDelay, moveDown,\n                    delMole, nil]];\n                break;\n            case 4:\n                // Move up halfway and then down, no pause\n                [aMole runAction:[CCSequence actions:\n                    moveUpHalf, moveDown, delMole, nil]];\n                break;\n            case 5:\n                // Move up halfway, look around, then down\n                [aMole runAction:[CCSequence actions:\n                    moveUpHalf, anim, moveDown, delMole,\n                    nil]];\n                break;\n            default:\n                // Play the look around animation\n                [aMole runAction:anim];\n                // Move up and down\n                [aMole runAction:[CCSequence actions:\n                    moveUp, moleDelay, moveDown, delMole,\n                    nil]];\n                break;\n        }\n    }\n}\n```", "```swift\n-(void)deleteMole:(id)sender data:(MXMoleHill*)moleHill {\n  molesInPlay--;\n  [self resetMole:moleHill];\n}\n```", "```swift\n-(void) resetMole:(MXMoleHill*)moleHill {\n  // Reset all mole-related values.\n  // This allows us to keep reusing moles in the hills\n  [[moleHill hillMole] stopAllActions];\n  [[[moleHill hillMole] moleSprite]\n                        removeFromParentAndCleanup:NO];\n  [[moleHill hillMole] setMoleGroundY:0.0f];\t  \n  [[moleHill hillMole] setMoleState:kMoleDead];\n  [[moleHill hillMole] setIsSpecial:NO];\n  [moleHill setIsOccupied:NO];\n}\n```", "```swift\n#import \"MXMole.h\"\n\n@implementation MXMole\n\n@synthesize parentHill;\n@synthesize moleSprite;\n@synthesize moleGroundY;\n@synthesize moleState = _moleState;\n@synthesize isSpecial;\n\n-(id) init {\n    if(self = [super init]) {\n            self.moleState = kMoleDead;\n            [[[CCDirector sharedDirector] touchDispatcher]\n                    addTargetedDelegate:self priority:0\n                    swallowsTouches:NO];\n    }\n  return self;  \n}\n\n- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {\n    CGPoint location = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:location];\n\n    if (self.moleState == kMoleDead) {\n        return NO;\n    } else if (self.moleSprite.position.y +\n               (self.moleSprite.contentSize.height/2)\n               <= moleGroundY) {\n    self.moleState = kMoleHidden;\n    return NO;\n  } else  {\n        // Verify touch was on this mole and above ground\n        if (CGRectContainsPoint(self.moleSprite.boundingBox,\n                                convLoc) &&\n            convLoc.y >= moleGroundY)\n        {\n            // Set the mole's state\n            self.moleState = kMoleHit;\n\n            // Play the \"hit\" sound\n            if (isSpecial) {\n                [[SimpleAudioEngine sharedEngine]\n                        playEffect:SND_MOLE_SPECIAL];\n            } else {\n                [[SimpleAudioEngine sharedEngine]\n                        playEffect:SND_MOLE_NORMAL];\n            }\n        }\n        return YES;\n    }\n}\n\n-(void) destroyTouchDelegate {\n    [[[CCDirector sharedDirector] touchDispatcher]\n                        removeDelegate:self];\n}\n\n@end\n```", "```swift\n-(void)update:(ccTime)dt {\n\n  for (MXMoleHill *aHill in moleHillsInPlay) {\n\n    if (aHill.hillMole.moleState == kMoleHit) {\n            [[aHill hillMole] setMoleState:kMoleMoving];\n      [self scoreMole:[aHill hillMole]];\n    }\n  }\n\n    if (molesInPlay < maxMoles && spawnRest > 10) {\n        [self spawnMole:self];\n        spawnRest = 0;\n    } else {\n        spawnRest++;\n    }\n\n    // Update the timer value & display\n    // Protection against overfilling the timer\n\n    // Update the timer visual\n\n    // Game Over / Time's Up\n}\n```", "```swift\n-(void) scoreMole:(MXMole*)aMole {\n  // Make sure we don't have a dead mole\n  if (aMole.moleState == kMoleDead) {\n    return;\n  }\n\n  // Get the hill\n  MXMoleHill *aHill = [aMole parentHill];\n\n    // Add the score\n    if (aMole.isSpecial) {\n        // Specials score more points\n        playerScore = playerScore + 5;\n        // You get 5 extra seconds, too\n        [self addTimeToTimer:5];\n    } else {\n        // Normal mole.  Add 1 point.\n        playerScore++;\n    }\n\n    // Update the score display\n    [self updateScore];\n\n    // Set up the mole's move to the score\n    CCMoveTo *moveMole = [CCMoveTo actionWithDuration:0.2f\n            position:[self scorePosition]];\n    CCScaleTo *shrinkMole = [CCScaleTo\n            actionWithDuration:0.2f scale:0.5f];\n    CCSpawn *shrinkAndScore = [CCSpawn\n            actionOne:shrinkMole two:moveMole];\n    CCCallFuncND *delMole = [CCCallFuncND\n            actionWithTarget:self\n            selector:@selector(deleteMole:data:)\n            data:(MXMoleHill*)aHill];\n\n    [aHill.hillMole.moleSprite stopAllActions];\n    [aHill.hillMole.moleSprite runAction:[CCSequence\n            actions: shrinkAndScore, delMole,  nil]];\n}\n```"]