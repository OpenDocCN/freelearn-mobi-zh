<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Creating User Interfaces</h1></div></div></div><p>Now that we created our first project and have become familiar with the code editor and its functionalities, we will begin our application by creating our user interface. Is there more than one way to create a user interface using Android Studio? How can you add components to your user interface? Have you ever wondered how to make your applications support different screen sizes and resolutions?</p><p>This chapter focuses on the creation of the user interfaces using layouts. Layouts can be created using a graphical view or a text-based view. You will learn how to use both of them to create your layout. We will also code a <code class="literal">Hello World</code> application using simple components. Since there are over 18,000 Android device types, you will learn about fragmentation on different screen types and we will discuss how to prepare our application for this issue. We will end this chapter with basic notions of handling events in our application.</p><p>These are the topics we'll be covering in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Existing layout editors</li><li class="listitem" style="list-style-type: disc">Creating a new layout</li><li class="listitem" style="list-style-type: disc">Adding components</li><li class="listitem" style="list-style-type: disc">Supporting different screens</li><li class="listitem" style="list-style-type: disc">Changing the UI theme</li><li class="listitem" style="list-style-type: disc">Handling events</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>The graphical editor</h1></div></div></div><p>Open the<a class="indexterm" id="id142"/> main layout located at <code class="literal">/src/main/res/layout/activity_main.xml</code> in our project. The graphical editor will be opened by default. The center panel of the graphical editor is the <strong>Preview</strong>, where you can examine what your layout looks like. From the <strong>Preview</strong> you can see that initially this main layout contains just a text view with a <strong>Hello World!</strong> message. To switch between the graphical and text editors, click on the <strong>Design</strong> and <strong>Text</strong> tabs at the bottom of the screen, as shown in the screenshot:</p><div><img alt="The graphical editor" src="img/B05459_05_01.jpg"/></div><p>The <strong>Toolbar</strong> options<a class="indexterm" id="id143"/> contains some options that can be used to change the layout style and preview. The <strong>Toolbar</strong> options, which are shown in the following screenshot, are explained throughout the chapter:</p><div><img alt="The graphical editor" src="img/B05459_05_02.jpg"/></div><p>The<strong> Component Tree</strong> panel displays the components placed in the layout as a hierarchy. There are two components in our layout: a <strong>RelativeLayout</strong> as the root element, and a <strong>TextView</strong> which is the one displaying the <strong>Hello World!</strong> message. When you select one element on the <strong>Component Tree</strong> panel, the element is highlighted in <strong>Preview</strong>, and its properties are listed in the <strong>Properties</strong> inspector panel. It shows the properties of the selected component <a class="indexterm" id="id144"/>from the layout and allows us to change them. <strong>Palette</strong> lists the<a class="indexterm" id="id145"/> existing <strong>user interface</strong> (<strong>UI</strong>) components to place in our layout. It organizes the components in different categories. Let's look at the options available in <strong>Components Palette</strong>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Layouts</strong>: A layout is a container object used to distribute the components on the screen. The root element of UI is a layout object, but layouts can also contain more layouts, creating a hierarchy of components structured in layouts. The recommendation is to keep this layout hierarchy as simple as possible. Our main layout has <strong>RelativeLayout</strong> as a root element.</li><li class="listitem" style="list-style-type: disc"><strong>Widgets</strong>: This category contains options for text views, buttons, checkboxes, switches, image views, progress bars, seek bars, rating bars, spinners, and web views. They are the most commonly used components, and they are used in most layouts. Our main layout contains <strong>TextView</strong> inside the root relative layout.</li><li class="listitem" style="list-style-type: disc"><strong>Text Fields</strong>: These are editable fields that contain different categories of input under which users can type text. The difference between the various options is the type of text users can type.</li><li class="listitem" style="list-style-type: disc"><strong>Containers</strong>: This category groups components that share a common behavior. Radio groups, list views, grid views, scroll views, and tab hosts are some of them.</li><li class="listitem" style="list-style-type: disc"><strong>Date &amp; Time</strong>: This category holds components related to date and time in the form of calendars or clocks.</li><li class="listitem" style="list-style-type: disc"><strong>Expert</strong>: The components in this category are not as common as the components in the <strong>Widgets</strong> category, but it is worth taking a look at them.</li><li class="listitem" style="list-style-type: disc"><strong>Custom</strong>: This category holds components that allow us to include our custom components, which are usually other layouts from our project.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>The text-based editor</h1></div></div></div><p>Change the <a class="indexterm" id="id146"/>graphical editor to the text editor by clicking on the <strong>Text</strong> tab:</p><div><img alt="The text-based editor" src="img/B05459_05_03.jpg"/></div><p>The <strong>Toolbar</strong> panel is the same as that on the graphical editor. The <strong>Preview</strong> window displays the layout, but it cannot be changed. To do that, you should use the <strong>Design</strong> tab instead. The <a class="indexterm" id="id147"/>components are added to the layout using their XML declarations. The properties are also configured using XML declarations. Like the graphical editor, the text editor contains two XML elements: a relative layout as the root element and the text view element inside the root layout.</p><p>The XML tag names define the type of component that we are declaring. For the relative layout, we use the <code class="literal">RelativeLayout</code> tag, and for the text view, we use the <code class="literal">TextView</code> tag. We can add properties to the elements by including attributes in the XML tags. For example, the text view in our main layout has three properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_width</code>, with the <code class="literal">wrap_content</code> value: This property sets the element width inside its parent element. The <code class="literal">wrap_content</code> value means that the element's width will be determined by the width of its content. The other default value that you can set for this property is <code class="literal">match_parent</code>, which means that the element will have the same width as its parent element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_height</code>, the <code class="literal">wrap_content</code> value: This property sets the element height inside its parent element. The values behave the same way as the width.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:text</code>, with the <code class="literal">Hello World!</code> value: This property sets the text to be displayed in the text view.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Creating a new layout</h1></div></div></div><p>When we <a class="indexterm" id="id148"/>created our main activity, the associated layout was also created. This is a way of creating a layout when creating an activity.</p><p>To add an independent layout without creating a new activity, right-click on the <code class="literal">layout</code> folder (<code class="literal">res/layout/</code>) and navigate to <strong>New</strong> | <strong>Layout resource file</strong>. You can also create a layout file using the same right-click menu by navigating to the <strong>New</strong> | <strong>XML</strong> | <strong>Layout XML file</strong>. You can also navigate to these two options using the top <strong>File</strong> menu. The following dialog from the next screenshot will be displayed to configure the new layout component:</p><div><img alt="Creating a new layout" src="img/B05459_05_04.jpg"/></div><p>Type the <strong>Layout File Name</strong> and the <strong>Root Tag</strong>. The root element of our main layout was a relative layout, but you can select a different root tag. There are five types of layout:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>FrameLayout</strong>: This<a class="indexterm" id="id149"/> layout displays usually only one child in an arranged area of the screen. If more than one child is added, then the views are displayed in a stack.</li><li class="listitem" style="list-style-type: disc"><strong>LinearLayout</strong>: This layout displays its children by aligning them, one after other, in one<a class="indexterm" id="id150"/> direction. There are two types of linear layouts: vertical and horizontal, which are identified by the <code class="literal">android:orientation</code> property of the layout.</li><li class="listitem" style="list-style-type: disc"><strong>TableLayout</strong>: This<a class="indexterm" id="id151"/> layout displays its children by distributing them in rows and columns. Along with the table layout, you need to use the <strong>TableRow</strong> element to create the distribution in rows and columns.</li><li class="listitem" style="list-style-type: disc"><strong>GridLayout</strong>: This <a class="indexterm" id="id152"/>layout displays its children in a rectangular grid. Children can fill more than one cell using properties such as <code class="literal">rowSpec</code> and <code class="literal">columnSpec</code>.</li><li class="listitem" style="list-style-type: disc"><strong>RelativeLayout</strong>: This layout displays its children by the relative positions between them. You<a class="indexterm" id="id153"/> have to use the position properties in the children's views to determine their position. At least one child view needs to have a position property relative to the parent view, so that child view, and the ones relative to it, can be positioned inside the parent layout. Some of these properties are <code class="literal">android:layout_below</code>, <code class="literal">android:layout_toLeftOf</code>, or <code class="literal">android:layout_alignBottom</code>.</li></ul></div><p>Once the<a class="indexterm" id="id154"/> layout is created, the associated activity can be changed to a different activity using the editor. If the layout has no activity, any existing one can be linked to it from the editor. To accomplish this, search for the <strong>Associate with Activity</strong> option in the toolbar of the layout editor, click on it, and select the <strong>Associate with other Activity</strong> option, as shown in the following screenshot:</p><div><img alt="Creating a new layout" src="img/B05459_05_05.jpg"/></div><p>A dialog box that lists all the activities of your project will open, and you can select one of them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Adding components</h1></div></div></div><p>Our main <a class="indexterm" id="id155"/>layout is a relative layout and contains a text view saying <strong>Hello World!</strong>. Now let's add a new component. The easiest way to do this is using the graphical editor, so open the <strong>Design</strong> tab. Select a component and drag it into the layout preview; for example, navigate to the <strong>Person Name</strong> component in <strong>Text Fields</strong> and place it below the text view.</p><p>Since our root layout is a relative layout, as you drag the element in the layout, some line guides are displayed. The properties related to the position are also shown in the top part of the <strong>Preview</strong> as you try to drag and drop the element in the layout. These lines and suggested properties, which are shown in the following screenshot, can help you properly align the element in your screen. They also help you to set the element position relative to the rest of the elements that are already in the layout.</p><div><img alt="Adding components" src="img/B05459_05_06.jpg"/></div><p>The<a class="indexterm" id="id156"/> properties suggested in the <strong>Preview</strong> panel from the previous screenshot align the text field to the left of the parent element (<strong>alignParentLeft</strong>), set the text field position below the <strong>Hello World!</strong> text view (<strong>below=textView</strong>), and add a margin to the text view of 38 dp (<strong>margin=38 dp</strong>).</p><p>In the <strong>Component Tree</strong> view, there is now a new <code class="literal">editText</code> object. Keep the text field selected to examine its properties loaded in the <strong>Properties</strong> inspector. Let's change some of them and observe the differences in the layout preview and in <strong>Component Tree</strong>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>layout:width</strong>: This option will adapt the width of the field to its content. Its current value is <code class="literal">wrap_content</code>. Change it to <code class="literal">match_parent</code> to adapt it to the parent layout width (the root relative layout).</li><li class="listitem" style="list-style-type: disc"><strong>hint</strong>: Type <code class="literal">Enter your name</code> as the hint of the field. The hint is a text shown when the field is empty to indicate the information that should be typed. As the field has a default value, <code class="literal">Name</code>, the hint is not visible.</li><li class="listitem" style="list-style-type: disc"><strong>id</strong>: This has <code class="literal">@+id/editText</code> as the current ID. The ID will be used from the code to get access to this object and is the ID displayed in the component tree. This ID can also be used by other elements in the layout to determine their relative position to it. Change it to <code class="literal">@+id/editText_name</code> to distinguish it easily from other text fields. Check whether the component ID has also changed in the <strong>Component Tree</strong> window, as shown in the following screenshot:<div><img alt="Adding components" src="img/B05459_05_07.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><strong>text</strong>: This deletes the value of this field. The hint should now be visible.</li></ul></div><p>If we<a class="indexterm" id="id157"/> switch to the text editor, we can see the XML definition of the text field with the properties we edited:</p><div><pre class="programlisting">&lt;EditText
    <strong>android:layout_width="match_parent"</strong>
    android:layout_height="wrap_content"
    android:inputType="textPersonName"
    android:ems="10"
    <strong>android:id="@+id/editText_name"</strong>
    android:layout_marginTop="38dp"
	android:layout_below="@+id/textView"
	android:layout_alignParentLeft="true"
    <strong>android:hint="Enter your name"</strong>
/&gt;</pre></div><p>There is a recommended order for the properties of the XML definitions. Having a specific order helps to understand the code when reading it and makes it easier to modify the elements. Select the <code class="literal">EditText</code> code definition and execute the <strong>Reformat Code</strong> action in the <strong>Code</strong> menu. The properties order has now changed, placing the <code class="literal">android:id</code> at the first position:</p><div><pre class="programlisting">&lt;EditText
    android:id="@+id/editText_name"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentLeft="true"
    android:layout_below="@+id/textView"
    android:layout_marginTop="38dp"
	android:ems="10"
	android:hint="Enter your name"
    android:inputType="textPersonName" 
/&gt;</pre></div><p>You can<a class="indexterm" id="id158"/> check the position properties (<code class="literal">android:layout_marginTop</code>, <code class="literal">android:layout_below</code>, and <code class="literal">android:layout_alignParentLeft</code>) that match the properties displayed in the graphical editor while you were dragging the edit text in the layout. Note that the <code class="literal">android:layout_below</code> property uses the ID of the text view to identify it.</p><p>From the text editor, the existing components and their properties can also be changed. Modify the text view ID (the <code class="literal">android:id</code> property) from <code class="literal">@+id/textView</code> to <code class="literal">@+id/textView_greeting</code>. Having a descriptive ID is important since it will be used by our code. Descriptive variable names allow the code to be self-documenting. You will need to change all the references to the text view ID to the new ID.</p><p>Let's add another component using the text editor this time. Press the <strong>Open Tag</strong> key and start typing <code class="literal">Button</code>. A list of suggestions will appear to help you with the code completion. Let the list of suggestions appear and select a <code class="literal">Button</code> object. Inside the <code class="literal">Button</code> tag, add the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:id</code>, with <a class="indexterm" id="id159"/>the <code class="literal">@+id/button_accept</code> value: This creates the ID property.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_width</code>, with the <code class="literal">wrap_content</code> value: This lets the width adapt to<a class="indexterm" id="id160"/> the button content.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_height</code>, with the <code class="literal">wrap_content</code> value: This lets the height <a class="indexterm" id="id161"/>adapt to the button content.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_below</code>, with the <code class="literal">@id/editText_name</code> value: This places the button<a class="indexterm" id="id162"/> below the name text field. We reference the name text field by its ID (<code class="literal">@id/editText_name</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:layout_centerHorizontal</code>, with the value <code class="literal">true</code>: This centers the<a class="indexterm" id="id163"/> button horizontally in the parent layout.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:text</code>, with the <code class="literal">Accept</code> value: This sets the text of the button. The recommended<a class="indexterm" id="id164"/> way to add a text to a component is by adding it to the <code class="literal">strings.xml</code> file. The component should be configured with the string identifier, instead of the string directly. For simplicity, we are adding the string directly to the button.</li></ul></div><p>The <a class="indexterm" id="id165"/>final XML definition for the button is the following:</p><div><pre class="programlisting">&lt;Button
  android:id="@+id/button_accept"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_below="@+id/editText_name"
  android:layout_centerHorizontal="true"
  android:text="Accept"
/&gt;</pre></div><p>The button is displayed in <strong>Preview</strong>. The next screenshot shows that if we switch to the graphical editor, the button is displayed in it and also in <strong>Component Tree</strong>:</p><div><img alt="Adding components" src="img/B05459_05_08.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec19"/>Component's properties</h2></div></div></div><p>The <a class="indexterm" id="id166"/>properties that we added or modified in our main layout can also be modified by code, and not only using the layout editor. For example, if you have a <code class="literal">Button</code> object in your code, you can change its text using the <code class="literal">setText</code> method:</p><div><pre class="programlisting">myButton.setText("Accept");</pre></div><p>Some of the<a class="indexterm" id="id167"/> properties available for a <code class="literal">View</code> object are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android:alpha</code>: This <a class="indexterm" id="id168"/>XML property sets the alpha value of the view, between <code class="literal">0</code> and <code class="literal">1</code>, which represents the opacity of the view. You can also use the <code class="literal">setAlpha</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:background</code>: This XML property sets the background of the view. You can <a class="indexterm" id="id169"/>also use the <code class="literal">setBackground</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:clickable</code>: This XML property sets whether the view is clickable or not, receiving<a class="indexterm" id="id170"/> the click events or not. You can also use the <code class="literal">setClicklable</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:elevation</code>: This XML property sets the elevation value of the view, its z <a class="indexterm" id="id171"/>depth value. You can also use the <code class="literal">setElevation</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:fadeScrollbars</code>: This XML property sets whether the scroll bars fade out when<a class="indexterm" id="id172"/> they are not in use. You can also use the <code class="literal">setScrollbarFadingEnabled</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:focusable</code>: This XML property sets whether the view can take the focus or not. You<a class="indexterm" id="id173"/> can also use the setFocusable method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:foreground</code>: This XML property sets the foreground of the view. You can <a class="indexterm" id="id174"/>also use the <code class="literal">setForeground</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:foregroundTint</code>: This XML property sets the tint color for the foreground <a class="indexterm" id="id175"/>of the view. You can also use the <code class="literal">setForegroundTintList</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:id</code>: This <a class="indexterm" id="id176"/>XML property sets the identifier of the view. You can also use the <code class="literal">setId</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:minHeight</code>: This <a class="indexterm" id="id177"/>XML property sets the minimum height that the view should have. You can also use the <code class="literal">setMinimumHeight</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:minWidth</code>: This XML property sets the minimum width that the view should <a class="indexterm" id="id178"/>have. You can also use the <code class="literal">setWidth</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:padding</code>: This XML property sets the padding for the four edges of the <a class="indexterm" id="id179"/>view. You can also use the <code class="literal">setPadding</code> method from code. Similar to this property are: <code class="literal">android:paddingBottom</code>, <code class="literal">android:paddingEnd</code>, <code class="literal">android:paddingLeft</code>, <code class="literal">android:paddingRight</code>, <code class="literal">android:paddingStart</code>, and <code class="literal">android:paddingTop</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:scrollIndicators</code>: This XML property sets whether the scroll indicators<a class="indexterm" id="id180"/> are shown for the view. You can also use the <code class="literal">setScrollIndicators</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:textAlignment</code>: This XML property sets the alignment of the text in the <a class="indexterm" id="id181"/>view. You can also use the <code class="literal">setTextAlignment</code> method from code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">android:visibility</code>: This XML property sets whether the view is visible or not. You can<a class="indexterm" id="id182"/> also use the <code class="literal">setVisibility</code> method from code.</li></ul></div><p>In <a class="indexterm" id="id183"/>addition to the properties of a <code class="literal">View</code> object, <code class="literal">View</code> subclasses can provide some more specific properties. For example, the <code class="literal">TextView</code> objects also have these properties: <code class="literal">android:editable</code>, <code class="literal">android:fontFamily</code>, <code class="literal">android:hint</code>, <code class="literal">android:text</code>, or <code class="literal">android:textColor</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Supporting multiple screens</h1></div></div></div><p>When <a class="indexterm" id="id184"/>creating Android applications, we have to take into account the existence of multiple screen sizes and screen resolutions. It is important to check how our layouts are displayed in different screen configurations. To accomplish this, Android Studio provides a functionality to change the virtual device that renders the layout preview when we are in the <strong>Design</strong> mode.</p><p>We can find this functionality in the toolbar and click on it to open the list of available device definitions, as shown in the following screenshot:</p><div><img alt="Supporting multiple screens" src="img/B05459_05_09.jpg"/></div><p>Try some<a class="indexterm" id="id185"/> of them. The difference between a tablet device and a device like those from the Nexus line is very notable. We should adapt the views to all the screen configurations our application supports to ensure that they are displayed optimally. Note that there are device definitions for Android Wear (<strong>square</strong>, <strong>round</strong>, and <strong>round chin</strong> designs) and for Android TV.</p><p>The device definitions indicate the screen size, resolution, and screen density. Android screen densities include ldpi, mdpi, tvdpi, hdpi, xhdpi, and even xxhdpi. Let's see what their values are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>ldpi</strong> : This is<a class="indexterm" id="id186"/> <strong>low-density dots per inch</strong>, and its value is about 120 dpi</li><li class="listitem" style="list-style-type: disc"><strong>mdpi</strong>: This<a class="indexterm" id="id187"/> is <strong>medium-density dots per inch</strong>, and its values is about 160 dpi</li><li class="listitem" style="list-style-type: disc"><strong>tvdpi</strong>: This<a class="indexterm" id="id188"/> is <strong>medium-density dots per inch</strong>, and its value is about 213 dpi</li><li class="listitem" style="list-style-type: disc"><strong>hdpi</strong>: This<a class="indexterm" id="id189"/> is <strong>high-density dots per inch</strong>, and its value is about 240 dpi</li><li class="listitem" style="list-style-type: disc"><strong>xhdpi</strong>: This<a class="indexterm" id="id190"/> is <strong>extra-high-density dots per inch</strong>, and its value is about 320 dpi</li><li class="listitem" style="list-style-type: disc"><strong>xxhdpi</strong>: This <a class="indexterm" id="id191"/>is <strong>extra-extra-high-density dots per inch</strong>, and its value is about 480 dpi</li><li class="listitem" style="list-style-type: disc"><strong>xxxhdpi</strong>: This <a class="indexterm" id="id192"/>is <strong>extra-extra-extra-high-density dots per inch</strong>, and its value is about 640 dpi</li></ul></div><p>The last <a class="indexterm" id="id193"/>dashboards published by Google show that most devices have high-density screens (42.3 percent), followed by xhdpi (24.8 percent) and xxhdpi (15.0 percent). Therefore, we can cover 82.1 percent of all the devices by testing our application using these three screen densities. If you want to cover a bigger percentage of devices, test your application using mdpi screens (12.9 percent) as well so the coverage will be 95.0 percent of all devices. The official Android dashboards are available<a class="indexterm" id="id194"/> at <a class="ulink" href="http://developer.android.com/about/dashboards">http://developer.android.com/about/dashboards</a>.</p><p>Another issue to keep in mind is <a class="indexterm" id="id195"/>the <strong>device orientation</strong>. Do we want to support the landscape mode in our application? If the answer is yes, then we have to test our layouts in landscape orientation. On the toolbar, click on the <strong>layout state</strong> option to change the mode either from portrait to landscape or from landscape to portrait.</p><p>If our application supports landscape mode and the layout does not get displayed as expected in this orientation, we might want to create a variation of the layout. Click on the first icon of the toolbar, that is, the <strong>Configuration to render this layout with inside the IDE</strong> option, and select the <strong>Create Landscape Variation</strong> option, as shown in the next screenshot:</p><div><img alt="Supporting multiple screens" src="img/B05459_05_10.jpg"/></div><p>A new layout will be opened in the editor. This layout has been created in the <code class="literal">resources</code> folder, under the <code class="literal">layout-land</code> directory, and it uses the same name as the portrait layout - <code class="literal">/src/main/res/layout-land/activity_main.xml</code>. The Android system will decide which <a class="indexterm" id="id196"/>version of the layout needs to be used depending on the current device orientation. Now, we can edit the new layout variation so that it perfectly conforms to landscape mode.</p><p>Similarly, we can create a variation of the layout for extra-large screens. Select the <strong>Create layout-xlarge Variation</strong> option. The new layout will be created in the <code class="literal">layout-xlarge</code> folder using the same name as the original layout at <code class="literal">/src/main/res/layout-xlarge/activity_main.xml</code>. Android divides into actual screen sizes of small, normal, large, and extra large:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Small</strong>: Screens<a class="indexterm" id="id197"/> classified in this category are at least 426 dp x 320 dp.</li><li class="listitem" style="list-style-type: disc"><strong>Normal</strong>: Screens<a class="indexterm" id="id198"/> classified in this category are at least 470 dp x 320 dp.</li><li class="listitem" style="list-style-type: disc"><strong>Large</strong>: Screens <a class="indexterm" id="id199"/>classified in this category are at least 640 dp x 480 dp.</li><li class="listitem" style="list-style-type: disc"><strong>Extra large</strong>: Screens <a class="indexterm" id="id200"/>classified in this category are at least 960 dp x 720 dp.</li></ul></div><p>A <a class="indexterm" id="id201"/>
<strong>density-independent pixel</strong> (<strong>dp</strong>) is equivalent to one physical pixel on a 160 dpi screen. The latest dashboards published by Google show that most devices have a normal screen size (85.1 percent), followed by large screen <a class="indexterm" id="id202"/>size (8.2 percent). The official Android dashboards are available at <a class="ulink" href="http://developer.android.com/about/dashboards">http://developer.android.com/about/dashboards</a>.</p><p>To display multiple device configurations at the same time, click on the <strong>Configuration to render this layout with inside the IDE</strong> option in the toolbar and select the <strong>Preview All Screen Sizes</strong> option, or click on the <strong>Preview Representative Sample</strong> option to open only the most important screen sizes, as shown in the following screenshot. We can also delete any of the samples by right-clicking on them and selecting the <strong>Delete</strong> option from the menu. Another useful action of this menu is the <strong>Save screenshot</strong> option. It allows us to take a screenshot of the layout preview:</p><div><img alt="Supporting multiple screens" src="img/B05459_05_11.jpg"/></div><p>If we <a class="indexterm" id="id203"/>create different layout variations, we can preview all of them by selecting the <strong>Preview Layout Versions</strong> option. If we want to preview what the layout looks like for different Android versions, we can use the<strong> Preview Android Versions</strong> option.</p><p>Now that we have <a class="indexterm" id="id204"/>seen how to add different components and optimize our layout for different screens, let's start working with themes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Changing the UI theme</h1></div></div></div><p>Layouts and <a class="indexterm" id="id205"/>widgets are created using the default UI theme of our project. We can change the appearance of the elements of the UI by creating styles. Styles can be grouped to create a theme, and a theme can be applied to an activity or to the whole <a class="indexterm" id="id206"/>application. Some themes are provided by default, such as<a class="indexterm" id="id207"/> the <strong>Material Design</strong> or <strong>Holo</strong> style. Styles and themes are created as resources under the <code class="literal">/src/res/values</code> folder.</p><p>To continue<a class="indexterm" id="id208"/> our example, we are going to change the default colors of the theme that we are using in our app. Using the graphical editor, you can see that the selected theme for our layout is shown as <strong>AppTheme</strong> in the toolbar. This theme was created for our project and can be found in the <code class="literal">styles</code> file at <code class="literal">/src/res/values/styles.xml</code>.</p><p>Open the <code class="literal">styles</code> file. Android Studio suggests we use the <strong>Theme Editor</strong>. You can click on the message link or you can navigate to <strong>Tools </strong>| <strong>Android </strong>| <strong>Theme Editor</strong> to open it. You can see the <strong>Theme Editor</strong> in the next screenshot:</p><div><img alt="Changing the UI theme" src="img/B05459_05_12.jpg"/></div><p>The left panel shows what different UI components look like. For example, you can view the appearance of the app bar, different types of buttons, text views, or the appearance of the status bar. The right panel of the <strong>Theme Editor</strong> contains the settings of the theme. You can change the values from the right panel and see how the components change in the left panel of <strong>Theme Editor</strong>.</p><p>In the right-hand configuration panel, you can change the <strong>Theme</strong> to modify, you can change the <strong>Theme parent</strong> of the selected theme, and you can change the theme colors. You will note that <strong>AppTheme</strong> is by default an extension of another theme, <code class="literal">Theme.AppCompat.Light.DarkActionBar</code>.</p><p>Let's try to<a class="indexterm" id="id209"/> change the main color of our app. Follow the next steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Look for the <strong>colorPrimary</strong> property on the right panel of the <strong>Theme Editor</strong>.</li><li class="listitem">Click on the color square of the <strong>colorPrimary</strong> property. The color selector of the following screenshot will be opened:<div><img alt="Changing the UI theme" src="img/B05459_05_13.jpg"/></div></li><li class="listitem">Select a different color and click on the <strong>OK</strong> button. Note that the theme has changed and now the app bar has the new color in <strong>Theme Editor</strong>.</li><li class="listitem">Open your main layout file. The preview of the layout has also changed its color. This theme primary color will be applied to all our layouts due to the fact that we configured it in the theme and not just in the layout.</li></ol></div><p>The specification<a class="indexterm" id="id210"/> of the colors is saved in the <code class="literal">colors</code> file at <code class="literal">/src/res/values/colors.xml</code>. This is the current content of the <code class="literal">colors</code> file:</p><div><pre class="programlisting">&lt;resources&gt;
    &lt;color name="colorPrimary"&gt;#009688&lt;/color&gt;
    &lt;color name="colorPrimaryDark"&gt;#303F9F&lt;/color&gt;
    &lt;color name="colorAccent"&gt;#FF4081&lt;/color&gt;
&lt;/resources&gt;</pre></div><p>You can also change the colors from this file. Modify the <code class="literal">colorPrimaryDark</code>, save the file, and note that in the <strong>Theme Editor</strong>, the status bar color has changed to the new color. Switch to your main layout file and observe that the preview of your layout has also changed to show the new color in the status bar.</p><p>To change the<a class="indexterm" id="id211"/> layout theme completely, click on the theme option from the toolbar in the graphical editor. The theme selector dialog is now opened, displaying a list of the available themes, as shown in the following screenshot:</p><div><img alt="Changing the UI theme" src="img/B05459_05_14.jpg"/></div><p>The themes created in our own project are listed in the <strong>Project Themes</strong> section. The <strong>Manifest Themes</strong> section shows the theme configured in the application manifest file (<code class="literal">/src/main/AndroidManifest.xml</code>). The <strong>All</strong> section lists all the available themes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Handling events</h1></div></div></div><p>The user interface<a class="indexterm" id="id212"/> would be useless if the rest of the application could not interact with it. Events in Android are generated when the user interacts with our application. All the UI widgets are children of the <code class="literal">View</code> class, and they share some events handled by the following listeners:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OnClickListener</code>: This <a class="indexterm" id="id213"/>captures the event when the user clicks on the view element. To configure this listener in a view, use the <code class="literal">setOnClickListener</code> method. The <code class="literal">OnClickListener</code> interface declares the following method to receive the click event:<div><pre class="programlisting">public abstract void <strong>onClick</strong>(View v)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnCreateContextMenu</code>: This captures the event when the user performs a long click<a class="indexterm" id="id214"/> on the view element and we want to open a context menu. To configure this listener in a view, use the <code class="literal">setOnCreateContextMenu</code> method. The <code class="literal">OnCreateContextMenu</code> interface declares the following method to receive the long-click event:<div><pre class="programlisting">public abstract void <strong>onCreateContextMenu</strong>(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnDragListener</code>: This captures the event when the user drags and drops the event element. To <a class="indexterm" id="id215"/>configure this listener in a view, use the <code class="literal">setOnDragListener</code> method. The <code class="literal">OnDragListener</code> interface declares the following method to receive the drag event:<div><pre class="programlisting">public abstract boolean <strong>onDrag</strong>(View v, DragEvent event)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnFocusChangedListener</code>: This captures the event when the user navigates from an <a class="indexterm" id="id216"/>element to another in the same view. To configure this listener in a view, use the <code class="literal">setOnFocusChangedListener</code> method. The <code class="literal">OnFocusChangedListener</code> interface declares the following method to receive the change of focus event:<div><pre class="programlisting">public abstract void <strong>onFocusChange</strong>(View v, boolean hasFocus)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnHoverListener</code>: This captures the event when the user is moving over an element. To<a class="indexterm" id="id217"/> configure this listener in a view, use the <code class="literal">setOnHoverListener</code> method. The <code class="literal">OnHoverListener</code> interface declares the following method to receive the hover event:<div><pre class="programlisting">public abstract boolean <strong>onHover</strong>(View v, MotionEvent event)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnKeyListener</code>: This captures the event when the user presses any key while the view<a class="indexterm" id="id218"/> element has the focus. To configure this listener in a view, use the <code class="literal">setOnKeyListener</code> method. The <code class="literal">OnKeyListener</code> interface declares the following method to receive the key event:<div><pre class="programlisting">public abstract boolean <strong>onKey</strong>(View v, int keyCode, KeyEvent event)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnLayoutChangeListener</code>: This captures the event when the layout of a view<a class="indexterm" id="id219"/> changes its bounds due to layout processing. To configure this listener in a view, use the <code class="literal">setOnLayoutChangeListener</code> method. The <code class="literal">OnLayoutChangeListener</code> interface declares the following method to receive the layout change event:<div><pre class="programlisting">public abstract void <strong>onLayoutChange</strong>(View v,
int left, int top, int right, int bottom,
int oldLeft, int oldTop, int oldRight, int oldBottom)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnLongClickListener</code>: This captures the event when the user touches the view element<a class="indexterm" id="id220"/> and holds it. To configure this listener in a view, use the <code class="literal">setOnLongClickListener</code> method. The <code class="literal">OnLongClickListener</code> interface declares the following method to receive the long click<a class="indexterm" id="id221"/> event:<div><pre class="programlisting">public abstract boolean <strong>onLongClick</strong>(View v)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnScrollChangeListener</code>: This captures the event when the scroll position of a view<a class="indexterm" id="id222"/> changes. To configure this listener in a view, use the <code class="literal">setOnScrollChangeListener</code> method. The <code class="literal">OnScrollChangeListener</code> interface declares the following method to receive the scroll change event:<div><pre class="programlisting">public abstract void <strong>onScrollChange</strong>(View v, 
int scrollX, int scrollY, 
int oldScrollX, int oldScrollY)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">OnTouchListener</code>: This captures the event when the user touches the view element. To<a class="indexterm" id="id223"/> configure this listener in a view, use the <code class="literal">setOnTouchListener</code> method. The <code class="literal">OnTouchListener</code> interface declares the following method to receive the touch event:<div><pre class="programlisting">public abstract boolean <strong>onTouch</strong>(View v, MotionEvent event)</pre></div></li></ul></div><p>In addition to these standard events and listeners, some UI widgets have some more specific events and listeners. Checkboxes can register a listener to capture when its state changes (<code class="literal">OnCheckedChangeListener</code>), and spinners can register a listener to capture when an item is clicked (<code class="literal">OnItemClickListener</code>).</p><p>The most common event to capture is when the user clicks on the view elements. There is an easy way to handle it—using the view properties. Select the <strong>Accept</strong> button in our layout and look for the <code class="literal">onClick</code> property. This property indicates the name of the method that will be executed when the user presses the button. This method has to be created in the activity associated with the current layout, our main activity (<code class="literal">MainActivity.java</code>) in this case. Type <code class="literal">onAcceptClick</code> as the value of this property.</p><p>Open the main activity to create the method definition. When a view is clicked, the event callback method when has to be public with a <code class="literal">void</code> return type. It receives the view that has been clicked on as parameter. This method will be executed every time the user clicks on the button:</p><div><pre class="programlisting">public void onAcceptClick(View v) {
  // Action when the button is pressed
}</pre></div><p>From the main <a class="indexterm" id="id224"/>activity, we can interact with all the components of the interface, so when the user presses the <strong>Accept</strong> button, our code can read the text from the name field and change the greeting to include the name in it.</p><p>To get the reference to a <code class="literal">view</code> object, use the <code class="literal">findViewById</code> method inherited from the <code class="literal">Activity</code> class. This method receives the ID of the component and returns the <code class="literal">View</code> object corresponding to that ID. The returned view object has to be cast to its specific class in order to use its methods, such as the <code class="literal">getText</code> method of the <code class="literal">EditText</code> class, to get the name typed by the user:</p><div><pre class="programlisting">public void onAcceptClick(View v) {
  TextView tvGreeting =
    (TextView) findViewById(R.id.textView_greeting);
  EditText etName = (EditText) findViewById(R.id.editText_name);

  if(0 &lt; etName.getText().length()) {
    tvGreeting.setText("Hello " + et_name.getText());
  }
}</pre></div><p>In the first two lines of the method, the references to the elements of the layout are retrieved: the text view that contains the greeting and the text field where the user can type a name. The components are found by their IDs, the same ID that we indicated in the properties of the element in the layout file. All the IDs of resources are included in the <code class="literal">R</code> class. The <code class="literal">R</code> class is autogenerated in the build phase and therefore we must not edit it. If this class is not autogenerated, then probably some file of our resources contain an error.</p><p>The next line is a<a class="indexterm" id="id225"/> conditional statement used to check whether the user typed a name. If they typed a name, the text will be replaced by a new greeting that contains that name. In the coming chapters, you will learn how to execute our application in an emulator, and we will be able to test this code.</p><p>If the event we want to handle is not the user's click, then we have to create and add the listener by code to the <code class="literal">onCreate</code> method of the activity. There are two ways to do this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing the listener interface in the activity and then adding the unimplemented methods. The methods required by the interface are the methods used to receive the events.</li><li class="listitem" style="list-style-type: disc">Creating a private anonymous implementation of the listener in the activity file. The methods that receive the events are implemented in this object.</li></ul></div><p>Finally, the listener implementation has to be assigned to the view element using the setter methods, such as <code class="literal">setOnClickListener</code>, <code class="literal">setOnCreateContextMenu</code>, <code class="literal">setOnDragListener</code>, <code class="literal">setOnFocusChange</code>, <code class="literal">setOnKeyListener</code>, and so forth. The listener assignment is usually included in the <code class="literal">onCreate</code> method of the activity. If the listener is implemented in the same activity, then the parameter indicated to the setter method is the own activity using the <code class="literal">this</code> keyword, as shown in the following code:</p><div><pre class="programlisting">Button bAccept = (Button) findViewById(R.id.button_accept);
bAccept.setOnClickListener(this);</pre></div><p>The activity<a class="indexterm" id="id226"/> should then implement the listener and the <code class="literal">onClick</code> method required by the listener interface:</p><div><pre class="programlisting">public class MainActivity extends Activity 
<strong>implements View.OnClickListener</strong> {
  @Override
  public void <strong>onClick</strong>(View view) {
    // Action when the button is pressed
  }</pre></div><p>If we implement it using a private anonymous class, the code would be the following:</p><div><pre class="programlisting">bAccept.setOnClickListener(<strong>new View.OnClickListener()</strong> {
    @Override
    public void <strong>onClick</strong>(View v) {
        // Action when the button is pressed
    }
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we saw how to create and edit the user interface layouts using both the graphical and the text-based editors. We finished our first small application, and we upgraded it with some basic components. You should now be able to create a simple layout and test it with different styles, screen sizes, and screen resolutions. You also learned about the different available UI themes. Finally, you learned about events and learned how to handle them using listeners.</p><p>In the next chapter, you will learn about some useful tools available in the Android Studio. We will use the SDK Manager frequently to install different packages. You will also learn about the AVD Manager for different virtual devices to test your applications on. We will generate Javadoc documentation for our project using the Javadoc utility, and you will learn about the version control systems available in Android Studio.</p></div></body></html>