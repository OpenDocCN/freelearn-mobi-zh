- en: Designing Material Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing and creating the layout for a screen, there are many different
    schools of thought about how it should be done. Modern layouts are often complex
    systems that change their shape dynamically as the user interacts with them. In
    the past, layouts tended to be quite rigid structures with only specialized areas
    such as windows or slit panels that could be adjusted by the user. However, a
    mobile application must make better use of their available space, since they're
    typically used on physically smaller devices. The direct interaction of a touch
    interface also changes how the user expects an application to behave; you need
    to not only react to the users gestures, but also be mindful of where their hand
    and fingers are likely to be on the screen as they might be obscuring some part
    of the screen, as they drag to scroll through your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to see how a layout can change and adjust is with a jumbo collapsing
    toolbar. When the screen opens, the toolbar is full sized and takes up enough
    space to contain various additional widgets and information. As the screen is
    scrolled, the action button vanishes, and the toolbar collapses in size. Then,
    the toolbar pins itself to the top of the screen and remains visible as just the
    title and possibly some action buttons, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02822db6-d361-47d1-9253-4b2e52ddd52a.png)'
  prefs: []
  type: TYPE_IMG
- en: This collapsing behavior is something you see commonly in material applications--various
    parts of the user interface being shown or hidden as the user scrolls or changes
    what they are doing. These layouts often coordinate the moving, resizing, showing,
    and hiding of many different widgets at the same time, and there's a special class
    for that--the `CoordinatorLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a look at the `CoordinatorLayout` and some other
    specialist Android layout classes in order to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create layouts that change based on user actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create layouts on flexible grids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to take actions using gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlight some widgets above others using elevation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at material structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Material layouts have a selection of patterns that applications should follow
    for every screen they build. This sort of template is often called the **scaffolding**,
    and for mobile, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f0a7b7a-4c05-4b04-9dc4-bcc3e84a7eb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What is important about the scaffolding is that while it defines the basic
    layout of virtually every screen, it doesn''t define how you should achieve this
    design, and even on Android, you''ll find that there are several different ways
    of creating a screen with the preceding layout structure. Several elements are
    also optional: the Bottom Bar and floating action button are often left out because
    they aren''t useful to a screen. The App Bar appears on most screens, but can
    be much larger and can also be folded away to provide the user with more reading
    space in the content area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also important to understand that by default, the platform theming will
    put the App Bar (presented by the `ActionBar` class) into an `Activity` for you;
    it''s also common to create your own App Bar using the `Toolbar` class and the
    `NoActionBar` theme on the `Activity`. In fact, in [Chapter 2](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml),
    *Designing Form Screens*, when you created the `CaptureClaimActivity`, the Android
    Studio template did exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CaptureClaimActivity` class, near the top of the `onCreate` method,
    you''ll be able to find the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code allows your application to take complete control of the `Toolbar`,
    from what it looks like, to what widgets it contains. Setting it as the `SupportActionBar`
    tells the `AppCompatActivity` to delegate any calls to `Activity.setTitle` and
    similar methods to the `Toolbar`, but in no other way changes how the `Toolbar`
    interacts with the layout system. This is still firmly under your control now.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CoordinatorLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android has a small family of layouts designed to work together to achieve
    the dynamic movement effects when the user scrolls. At the core of this group
    is the `CoordinatorLayout` class, which allows complex behaviors to be attached
    to any number of floating sibling widgets that can depend on and react to each
    other''s position and size. To illustrate how a `CoordinatorLayout` actually works,
    take a look at this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea7ef32e-740a-40e3-8cf6-e0885b1d0d5c.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though the `FloatingActionButton` appears to be floating above the other
    widgets, it's a direct child of the `CoordinatorLayout`. It remains in place because
    it is anchored to the bottom of the toolbar. If the toolbar changes its size or
    position, the `CoordinatorLayout` will move the `FloatingActionButton` so that
    it appears to be attached to the bottom of the toolbar. These movements are all
    done together as part of the layout process, resulting in every frame being pixel
    perfect and everything appearing to move and resize together.
  prefs: []
  type: TYPE_NORMAL
- en: '`CoordinatorLayout` defines two major ways to manipulate its child widgets--anchors
    and behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anchors** are by far the simpler of these two; they simply attach one widget
    to another widget. The anchors respond to the `layout_gravity` attribute and a
    special `layout_anchorGravity` attribute to determine exactly where the anchored
    widget should appear relatively to the widget it''s attached to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behaviors** are more complex; they are entire classes that can be used to
    manipulate the widget in any way based on other widgets (known as its **dependencies**).
    Several classes define their own behavior classes that should be used when they
    are declared within a `CoordinatorLayout`. For example, `FloatingActionButton`
    declares a `FloatingActionButton.Behavior` class that will hide the button if
    its anchor-point approaches too close to the end of the screen, and make it reappear
    when there is enough space again. This showing and hiding behavior is even accompanied
    by an animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinating the Overview Screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Overview screen you built in [Chapter 7](22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml),
    *Creating Overview Screens*, is a perfect candidate for a `CoordinatorLayout`.
    To start with, the allowance overview bar can be made to collapse, and unfold
    as the user scrolls. This allows more space for the claim items on the screen
    as they are scrolling, and by expanding the overview again when they scroll upward,
    the user doesn't have to scroll all the way to the top to get the overview back.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior won''t just use the `CoordinatorLayout`, but will also need the
    help of the `AppBarLayout` and `CollapsingToolbarLayout` classes as you''ll need
    to take control of the Material Design scaffolding to make it work. Follow these
    steps to move the allowance overview into the header bar and make it collapse:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the `AndroidManifest` file from the manifests folder in the project
    tree (use the Android perspective).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `OverviewActivity` entry and add a theme attribute that will tell
    the system not to provide a system `ActionBar`, because you''ll be adding your
    own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `activity_overview` layout file and change to the text mode. Remove
    the `FrameLayout` and all of its contents; you'll need to completely rewrite this
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `CoordinatorLayout` root element with all the standard namespaces
    and context. Note that this time you''ll tell the system that this widget will
    fit to the root window, and not act as *contents*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `AppBarLayout` element within the `CoordinatorLayout`; again,
    you''ll tell the system that the `AppBarLayout` fits to the system window and
    is not to be treated as normal *content* widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the code-assistance for the `layout_height` to create a new dimension resource
    named `app_bar_height`, and assign it a value of `180dp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `AppBarLayout`, you need to declare the `CollapsingToolbarLayout`.
    This will handle the collapsing and expanding of the toolbar and other widgets
    as the user scrolls. You use the `layout_scrollFlags` to tell it how to collapse
    and expand, but it''s important to note that it''s actually the `AppBarLayout`
    that takes care of these, so any children of `AppBarLayout` can use these flags.
    In this particular case, we''ll be telling it to collapse when the user scrolls
    down the list of items, but not to exit (vanish) completely, and to reenter as
    soon as the user starts to scroll up the list again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `CollapsingToolbarLayout` declares its `contentScrim`
    as `?attr/colorPrimary`. The attributes `?` syntax is a type of lookup that is
    used with theming. It tells the resource-system to look up that attribute in the
    theme, rather than directly referencing the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `CollapsingToolbarLayout`, you''ll need to declare a `Toolbar` widget.
    This widget will take the place of the system `ActionBar`. We use the `layout_collapseMode`
    to tell the `CollapsingToolbarLayout` to *pin* the `Toolbar` to the top of the
    screen once it has been collapsed (rather than having it vanish completely):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `Toolbar` widget, you can declare the `AllowanceOverviewFragment`;
    it will use the `parallax` collapse mode and will disappear as the use scrolls
    down the list of claim items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That concludes your new `AppBarLayout` structure; now you need to add the `RecyclerView`
    in after the `AppBarLayout` and tell the `CoordinatorLayout` that it is scrolling
    content using the `layout_behaviour` attribute. This will tell the `CoordinatorLayout`
    that when the `RecyclerView` is scrolled, the `AppBarLayout` should react to the
    scrolling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RecyclerView` declared that its behavior references a string resource
    by the name `appbar_scrolling_view_behavior`, but you haven''t declared any such
    resource in your `strings.xml` file, so why doesn''t the code assistant complain?
    This is a string resource declared by the `CoordinatorLayout` support library,
    and it gets merged into your application resources during the build. Its contents
    is the full class-name for the scrolling view `Behaviour` implementation (that
    is: ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final element in your `CoordinatorLayout` should be the `NewClaimItemFloatingActionButtonFragment`,
    which will automatically gain special behavior within the `CoordinatorLayout`
    because of how the `FloatingActionButton` class is written:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FloatingActionButton` class declares a default `Behaviour` class that
    the `CoordinatorLayout` looks for when any child is added to it. This defines
    how the `FloatingActionButton` is positioned on the screen, when it should disappear,
    reappear, and even move relative to panels that may appear at the bottom of the
    screen (such as snackbars). The declaration is made using a publicly accessible
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to how your application has been structured, the `OverviewActivity` class
    doesn''t need to be modified for this new layout to work. It will still automatically
    populate the `RecyclerView` with the `ClaimItem` objects, and the fragments will
    communicate through the database. It is, however, useful to make the new `Toolbar`
    widget act as the `ActionBar` for the `OverviewActivity`; you can do this by changing
    the `onCreate` method to call `setSupportActionBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Swiping to delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you have a way for your users to create claim items, the users have no
    way to delete the claim items that they have created. A common pattern in lists
    on mobile apps is to allow the user to swipe right to dismiss or delete items.
    `RecyclerView` provides some excellent and easy-to-use structures to enable this
    sort of behavior; however, it's always important to ensure that users don't delete
    items by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, most user interfaces used confirmation dialogs when executing destructive
    actions. However, these "are you sure" dialogs are a horrible distraction for
    most users, because such messages violate a key principle--the application assumes
    that the user probably doesn't want to perform an action that they just took.
    In reality, the user probably did mean to delete the item, but the application
    interrupts them to ask whether they're sure about their choice. A much better
    behavior is to assume that the user does want to take the action, but then to
    give them a way to undo their action if they have made a mistake. Material Design
    has a design pattern and widget dedicated specifically to this sort of task--the
    `Snackbar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Material Design language, the `Snackbar` is a small bar that can appear
    at the bottom of the screen, providing the user with information and possible
    actions that they can take based on the information given. The most commonly seen
    use is when something is deleted, and the user is given the chance to undo the
    delete. Undo actions might appear to be challenging, but they''re actually very
    simple to carry out if correctly wrapped in a `Command` class. Follow these steps
    to add a swipe-to-delete action and an undo option to the travel claims application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `DataBoundViewHolder` class in the ui package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your new classes will need a simple way to access the items from the `DataBoundViewHolder`,
    but the `ViewDataBinding` doesn''t offer a `getVariable` method, so you''ll need
    to keep it in a class field and provide a getter method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to modify the `setItem` method to capture this field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Open the `OverviewActivity` source file in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of the `OverviewActivity` class, you''ll need to declare a new
    `ActionCommand` class that will encapsulate both the delete action and the undo
    operation. Unlike most other `ActionCommand` classes, this one is not reusable
    and takes no arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `DeleteClaimItemCommand` class will need a reference to the `ClaimDatabase`,
    and will also have a `ClaimItem` field that it will delete and optionally restore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onBackground` implementation deletes the `ClaimItem` object from the database,
    but the `DeleteClaimItemCommand` keeps a reference to the in-memory implementation
    if the user decides to restore it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code does not delete the `Attachments` related to the `ClaimItem`, which
    will cause the application to leak attachment files and database rows. In practice,
    you would also want to ensure that the attachments are cleaned up as well by copying
    the behavior used for `ClaimItem`, but that is beyond the scope of this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onForeground` implementation will need to display a `Snackbar` notification
    telling the user that the item was deleted; for that, you''ll need a localizable
    message. The `Context` class offers a convenience `getString` method that will
    generate a formatted string from the application resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the code assistance to create a new string resource named `msg_claim_item_deleted`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These strings follow the formatting rules defined in `java.util.Formatter` or
    `String.format`, allowing you to create relatively complex formatting rules. By
    providing different `strings.xml` files for different languages and formats like
    this, you can very easily localize most strings in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onForeground` method, you''ll need to grab a reference to the `CoordinatorLayout`
    as a base for the `Snackbar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `Snackbar` object, specifying its undo action text, and use
    the `DeleteClaimItemCommand` as the action handler (`OnClickListener`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the code assistance on the `R.string.undo` reference to create a new string
    resource for the text of the `undo` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user clicks on the undo action, the `DeleteClaimItemCommands` and `onClick`
    methods will be invoked. It can then use its cached reference to the deleted `ClaimItem`
    to restore it in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As another inner-class to the `OverviewActivity`, you''ll need a class to provide
    the action definition and handling for the *swipe-to-delete* behavior. This new
    class will extend the `SimpleCallback` class of the `ItemTouchHelper` class, which
    provides the handling for the movement gesture recognition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SimpleCallback` constructor takes two sets of "flags" in the form of `int`
    values. These are simply a number of numbers that you can binary "or" (using the
    `|` operator) together. These define the different gestures to allow and manage.
    The first of these are the flags for different types of "move" gestures that can
    be used to reorder the items in a `RecyclerView` (leaving this as zero indicates
    that no move gestures should be recognized). The second flag''s argument is for
    "swipe" gestures, which are what we''re interested in here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SimpleCallback` class requires that you declare handler methods for moving
    and swiping, even though the class will not deal with movement gestures. You''ll
    need to declare `onMove`, but the class can just return `false` as its implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can define the implementation of the `onSwipe` method, which will
    create a `DeleteClaimItemCommand` and execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to attach the `SwipeToDeleteCallback` to the `RecyclerView`, you need
    to wrap it using the `ItemTouchHelper` class, and attach that to your `RecyclerView`
    instance at the bottom of the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Elevating widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An excellent way of highlighting one widget over the others on the screen is
    to make it appear over the others on the screen, not two-dimensionally, but floating
    above them as though in three-dimensions. This is already a clear pattern if you
    look at the `FloatingActionButton` classes; they don't just overlap other widgets,
    but they have a shadow and appear to float in space (hence the class name `FloatingActionButton`).
  prefs: []
  type: TYPE_NORMAL
- en: One of the great features in the Android widget library is that the `View` class
    defines the notion of elevation, which makes it usable by every widget in the
    toolkit. The elevation of a widget doesn't affect its two-dimensional position
    or size, but does cause it to produce a shadow that will be correctly shaded as
    though the widget is floating in three-dimensions. This can be used to create
    an amazing effect when you need to draw attention to a message, or when the user
    is repositioning a widget on the screen (for example, reorganizing a list of reminders).
    Given that most of a Material Design user interface is flat, adding a three-dimensional
    elevation instantly makes a widget stand out for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Much like the borders and shadow of a `CardView` widget, when you use elevation,
    you need to ensure that the shadow is not clipped by the parent widget or the
    padding attributes. Use the `clipChildren` and `clipToPadding` attributes to control
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add an elevation effect to the swipe-to-delete behavior
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `OverviewActivity` and find the `SwipeToDeleteCallback` inner class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class will need to be able to reset the elevation if the user "drops" an
    item after picking it up to delete it. For this, the `SwipeToDeleteCallback` class
    will need a field with the default card elevation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time a child of the `RecyclerView` is drawn after being picked up, the
    `ItemTouchHelper` allows you to override the drawing behavior. In your case, you
    want to adjust the elevation of the card relative to how far right the user has
    dragged it. In order to work on older versions of Android, this code uses the
    `ViewCompat` class to change the elevation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the card is released by the user, we need to clear the elevation value
    by setting it back to its default; the `ItemTouchHelper` will invoke the `clearView`
    callback when the user drops an item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve implemented this behavior, the user will receive secondary visual
    feedback on the swipe to delete gesture, as the card they drag will appear to
    rise above the others as they pull it to the right. It''ll also do the reverse
    and appear to descend back to its normal elevation if they drag it to the left
    again. This elevation feedback can be even more useful on interfaces where the
    user can change the position of the cards in a list (for example, in a to-do list).
    Note that as the card''s elevation increases, it casts a shadow on the cards both
    below and above it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ba8e1ad-4842-451f-b1f0-df6616b8cf26.png)'
  prefs: []
  type: TYPE_IMG
- en: Building layouts using grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building screens, it's common to want specific widgets to appear the same
    size and shape as other widgets. This is often achieved using flexible grid models
    for the layout. By dividing the screen into a number of cells, and having each
    widget occupy one or more cells, you can create very complex layouts that will
    stretch to any screen size. However, this traditional model is completely outdated
    when faced with `ConstraintLayout`, which is capable of maintaining complex relationships
    between widgets without the need for a grid.
  prefs: []
  type: TYPE_NORMAL
- en: In most situations, `ConstraintLayout` should be more than capable of managing
    any complex layout you choose to design, and will be much more flexible than a
    grid/table layout manager. Unlike a grid-based layout engine, `ConstraintLayout`
    is much more flexible when dealing with widgets that are sized based on a font
    or images that can be various sizes, depending on the physical screen size and
    pixel-density. While `GridLayout` will adjust the size of the cells to accommodate
    such widgets, they are still confined by grid lines.
  prefs: []
  type: TYPE_NORMAL
- en: However, every now and then, you'll need to build a layout based on grid cells.
    For situations like this, you'll want to use the `GridLayout` class. `GridLayout`
    allows you to define layouts based on an invisible grid, where each widget can
    take up one or more cells, and the size of each row and column is flexible; that
    is, each column can be a different width, and each row can be a different height.
    It's important to remember that `GridLayout` is not intended for displaying large
    tables of data, but rather for laying out screens that favor a grid-like structure.
    If you need to present your user with a scrolling grid (for example, of icon images),
    then a better model to be used is the `RecyclerView` with a `GridLayoutManager`,
    as this will scale to virtually any number of child components.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different implementations of `GridLayout` in Android: one is
    in the platform core APIs, and the other is in the support v7 APIs. For compatibility
    reasons, it''s typically best to use the class from the support package as it
    includes many of the more recently added features that might not appear on the
    platform implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore the `GridLayout` a bit, let''s take a look at how you will implement
    the *Capture Claim Details* card using `GridLayout` instead of `ConstraintLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need to add the `GridLayout` implementation to your project. Open
    the Gradle Scripts in the project tree and open the build.gradle for the app module
    (use the Android perspective).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the dependencies list, add a dependency for the grid-layout module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The version number at the end (in this case, `26.0.0`) must exactly match the
    version number of the `appcompat` module your application references. If these
    versions don't match exactly, it can lead to instabilities and in some cases,
    your application won't even compile. Change the version number to match the one
    declared on the `appcompat` reference in your `build.gradle` before continuing
    to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file, and synchronize the project using the Sync Now link that appears
    at the top of the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the res | layout directory in the project file tree, and select
    New | Layout resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `fragment_capture_claim_grid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the root element to `android.support.v7.widget.GridLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d0713e73-432f-47b0-96f3-47fb7083ee73.png)'
  prefs: []
  type: TYPE_IMG
- en: Change to the Text mode editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you''re using the support libraries `GridLayout` implementation, several
    of the XML attributes will be in the `app` namespace rather than the platform
    (`android`) namespace. You''ll need to add the `app` namespace to the `GridLayout`
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**9.  `GridLayout` sets many of the layout attributes by default, and assumes,
    by default, that each child is in the cell, following the one before it (starting
    at the top-left cell). It allows you to specify the `columnWeight` and `rowWeight`
    attributes to define how much of the available space each cell should take up.
    Declare a `TextInputLayout` to take up 70% of the available space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `TextInputLayout` widget only occupies a single cell within the
    `GridLayout`, but that cell has been told to take up 70% of the available horizontal
    space when rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, declare the amount `TextInputLayout`; this will also only occupy a single
    cell, but we''ll want it to occupy the remaining 30% of the horizontal space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to declare a `DatePickerLayout` for the user to select the date,
    but we need to tell the `GridLayout` to put it on the next row. You do this using
    the `row` and `column` attributes. This widget also needs to take up the full
    width of the `GridLayout`, which means it needs to occupy two columns, which is
    done using the `columnSpan` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look in the Design view, you''ll note that this layout looks
    almost identical to the one you wrote in [Chapter 2](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml),
    *Designing Form Screens*, for capturing the claims. The biggest difference is
    that the `ConstraintLayout` uses a fixed minimum size for the Amount, while this
    layout uses relative sizes by manipulating the weights of the grid cells. The
    resulting layout should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7947bd9d-6e56-49b9-a984-c0f0eb3c159f.png)'
  prefs: []
  type: TYPE_IMG
- en: Stack view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it''s useful to be able to display long lists of items with only
    one item visible at a time, for example, the list of attachments for a `ClaimItem`.
    In this case, you can use the side-to-side `ViewPager` as you''ve already done,
    but there is another option--the `StackView`. The `StackView` class presents its
    contents as a three-dimensional stack of cards, with the "top" card fully visible,
    and some of the cards "behind it," as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97eae5f4-0729-43ca-af85-4007e5f7ab7b.png)'
  prefs: []
  type: TYPE_IMG
- en: This is often a very useful pattern, as it provides the user with plenty of
    screen space to view the top item, while also being able to see that there are
    other items that can be viewed. This makes it ideal for displaying photos or large
    cards of data. It's very similar to how Android displays the list of running applications
    when you tap on the "Recent Apps" button on a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StackView` is a classic `Adapter` view, and works using the same `Adapter`
    implementations as `ListView` or `GridView`. If done correctly, you can write
    code that can be used in any of these classes; follow these steps to build a simple
    `StackView` and `Adapter` implementation that can be used to preview the `Attachment`
    differently:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the ui.attachments package in the project tree, and select New|
    Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `AttachmentListAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Superclass to `android.widget.BaseAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new `AttachmentListAdapter` class, declare a `List` of `Attachment`
    objects to present to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a constructor to observe a `LiveData` and assign the `List` of attachments
    and notify the `StackView` when things change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like a `RecyclerView.Adapter` implementation, the `BaseAdapter` needs
    a method to access the number of items it''s expected to present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the `RecyclerView.Adapter` implementations, however, a `BaseAdapter`
    is expected to expose the underlying data directly. It''s also required to expose
    a unique ID for each element of data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, unlike a `RecylcerView.Adapter`, there is only a single method to create
    and reuse the existing view items, as well as bind the data to them. In this method,
    the second argument may be `null`, but can also be an existing view that is expecting
    to be recycled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a `StackView` from a layout XML file, you simply need to declare the
    `StackView` as you would a `RecyclerView` or `ViewPager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from the enclosing `Activity` or `Fragment`, you will need to set its
    `Adapter`. Much like the `RecyclerView`, the `Adapter` can also be specified from
    a data-bound layout. Here''s how the code might look in an `Activity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `StackView` class is an excellent way to present the user with a large number
    of larger and more visual items. It's excellent for browsing things such as photographs
    or preview graphics, and provides you with an easy-to-use three-dimensional transformation.
    Before using `StackView`, you should always consider whether the user will need
    to see the data from more than one item at a time. Sometimes, it's best to combine
    a `RecyclerView` as an "overview" with a `StackView` for viewing the individual
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elevation should be used for which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user selects an item in a list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To selectively highlight one item above a flat layout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user swipes to delete items
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CoordinatorLayout` can be used to coordinate movement and size between which
    of these?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The components nested in an `AppBarLayout`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of its direct child widgets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fragment` in different activities'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To change elevation of a widget in a backward-compatible way, you need to do
    which of the mentioned?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nest the widget in a `CardView`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `ViewCompat` class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Java reflection to call `setElevation`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GridLayout` class should be used in which of the following conditions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `ConstraintLayout` is not available
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To display large tables of data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To lay out screens along grid lines
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking ownership of what is normally the system's decorations for your application
    provides you with a huge variety of additional flexibility and power. By using
    the `CoordinatorLayout` to host the scaffolding and content of your screens, you
    further extend your flexibility by allowing widgets to dynamically interact with
    each other, even when being animated. This provides you with a way to produce
    pixel-perfect screens with minimal additional work.
  prefs: []
  type: TYPE_NORMAL
- en: Using layouts that cannot only dynamically change their shape, but also change
    their content using gestures such as swipe-to-dismiss to further enhance the direct
    manipulation aspects of a touchscreen user interface have been covered. At the
    same time, it's important to always consider the interactions of your user and
    when to interrupt them, especially around destructive actions. While there are
    still times where you might want to use a confirmation dialog, it's generally
    better to give users a method to undo their actions. It's often a very simple
    thing to keep the deleted entity objects in-memory until the `Snackbar` vanishes
    and is released from memory. Inserting entities that you have deleted from Room
    will actually maintain their IDs, meaning that their rows are restored exactly
    as they were before they were deleted.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at navigation in Android applications,
    and explore various user interface features that are provided for your user to
    navigate your application. We'll also take a look at some techniques that allow
    you to take more control of your application's navigation flow. Providing consistent
    and quality navigation makes a huge difference to your user's experience.**
  prefs: []
  type: TYPE_NORMAL
