<html><head></head><body>
<div id="_idContainer076">
<h1 class="chapter-number" id="_idParaDest-159"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-160"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.2.1">Using the Room Database and Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Android applications can benefit significantly from storing data locally. </span><span class="koboSpan" id="kobo.3.2">The Room persistence library harnesses the power of SQLite. </span><span class="koboSpan" id="kobo.3.3">In particular, Room offers excellent benefits for Android developers. </span><span class="koboSpan" id="kobo.3.4">Furthermore, Room offers offline support, and the data is stored locally. </span><span class="koboSpan" id="kobo.3.5">In this chapter, we will learn how to implement Room, a </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Jetpack Library.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1"> In this chapter, we’ll be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Implementing Room in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">your applications</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Implementing Dependency Injection </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">in Room</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Supporting </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">multiple entities</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Migrating existing SQL database </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">to Room</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Testing your </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">local database</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">It is also important to mention there are a couple more libraries are used with Room – for example, RxJava and Paging integration. </span><span class="koboSpan" id="kobo.17.2">In this chapter, we will not focus on them but instead on how you can utilize Room to build modern </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Android apps.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">The complete source code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.24.1">Implementing Room in your applications</span></h1>
<p><span class="koboSpan" id="kobo.25.1">Room is an object-relational </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.26.1">mapping library used in Android data persistence and is the recommended data persistence in Modern Android Development. </span><span class="koboSpan" id="kobo.26.2">In addition, it is effortless to use, understand and maintain, and harnesses the powers of </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">SQLiteDatabase</span></strong><span class="koboSpan" id="kobo.28.1">, it also helps reduce boilerplate code, an issue many developers experience when using SQLite. </span><span class="koboSpan" id="kobo.28.2">Writing tests is also very straightforward and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">The most notable advantage of </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.31.1">Room is that it is easy to integrate with other architecture components and gives developers runtime compile checks – that is, Room will complain if you make an error or change your schema without migrating, which is practical and helps </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">reduce crashes</span><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.34.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.35.1">Let’s go ahead and create a new empty compose project and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">RoomExample</span></strong><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">In our example project, we will create a form intake from users; this is where users can save their first and last names, date of birth, gender, the city they live in, and </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">their profession.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">We will save our user data in our Room database, and then later inspect whether the elements we inserted were saved in our database and display the data on </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the screen:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.41.1">In our newly created project, let’s go ahead and delete the unnecessary wanted code – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">Greeting(name: String)</span></strong><span class="koboSpan" id="kobo.43.1">, which comes with all empty Compose projects. </span><span class="koboSpan" id="kobo.43.2">Keep the preview function, since we will use it to view the screen </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">we create.</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">Now, let’s go on and add the needed dependencies for Room and sync the project. </span><span class="koboSpan" id="kobo.45.2">We will touch on</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.46.1"> dependency management using </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">buildSrc</span></strong><span class="koboSpan" id="kobo.48.1"> in </span><a href="B18827_12.xhtml#_idTextAnchor672"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.50.1">, </span><em class="italic"><span class="koboSpan" id="kobo.51.1">Android Studio Tips and Tricks to Help You during Development</span></em><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">You can find the latest version of Room at </span><a href="https://developer.android.com/jetpack/androidx/releases/room"><span class="koboSpan" id="kobo.53.1">https://developer.android.com/jetpack/androidx/releases/room</span></a><span class="koboSpan" id="kobo.54.1">; we will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">kapt</span></strong><span class="koboSpan" id="kobo.56.1">, which stands for </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">Kotlin Annotation Processing Tool</span></strong><span class="koboSpan" id="kobo.58.1">, to enable us to use the Java annotation processor with the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">Kotlin code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.60.1">
dependencies {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.61.1">
implementation "androidx.Room:Room-runtime:2.x.x"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.62.1">
kapt "androidx.Room:Room-compiler:2.x.x"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.63.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.64.1">
//include kapt on your plugins</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.65.1">
plugins {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.66.1">
    id 'kotlin-kapt'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.67.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.68.1">Create a new package and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">data</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">data</span></strong><span class="koboSpan" id="kobo.72.1">, create a new Kotlin class and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">UserInformationModel()</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">A data class is used to hold data only – in our case, the type of data</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.75.1"> that we will collect from users will be the first name, last name, date of birth, and </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">By using Room, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">@Entity</span></strong><span class="koboSpan" id="kobo.79.1"> annotation to give our model a table name; hence, in our newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">UserInformation</span></strong><span class="koboSpan" id="kobo.81.1"> class, let’s go ahead and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">@Entity</span></strong><span class="koboSpan" id="kobo.83.1"> annotation and call our table </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">user information:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.85.1">
@Entity(tableName = "user_information")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.86.1">
data class UserInformationModel(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.87.1">
    val id: Int = 0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.88.1">
    val firstName: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.89.1">
    val lastName: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.90.1">
    val dateOfBirth: Int,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.91.1">
    val gender: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.92.1">
    val city: String,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.93.1">
    val profession: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.94.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.95.1">Next, as in all databases, we need to define a primary key for our database. </span><span class="koboSpan" id="kobo.95.2">Hence, in our ID, we will add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">@PrimaryKey</span></strong><span class="koboSpan" id="kobo.97.1"> annotation to tell Room that this is our primary key, and it should be autogenerated. </span><span class="koboSpan" id="kobo.97.2">If you don’t wish to autogenerate, you can set the Boolean to </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">false</span></strong><span class="koboSpan" id="kobo.99.1">, but this might not be a good idea, due to </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.100.1">conflicts that might arise later in </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">your database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.102.1">
@PrimaryKey(autoGenerate = true)</span></pre></li>
<li><span class="koboSpan" id="kobo.103.1">Now, you should have an entity with a table name, a primary key, and your </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">data types:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.105.1">
import androidx.Room.Entity</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.106.1">
import androidx.Room.PrimaryKey</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.107.1">
@Entity(tableName = "user_information")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.108.1">
data class UserInformationModel(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.109.1">
    @PrimaryKey(autoGenerate = true)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.110.1">
    val id: Int = 0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.111.1">
    ...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.112.1">
)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.113.1">Inside our data package, let us go ahead and create a new package and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">DAO</span></strong><span class="koboSpan" id="kobo.115.1">, which means </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">data accessible object</span></strong><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">Once</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.118.1"> that is done, create a new interface and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">UserInformationDao</span></strong><span class="koboSpan" id="kobo.120.1">; this interface</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.121.1"> will hold the </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">create</span></strong><span class="koboSpan" id="kobo.123.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">read</span></strong><span class="koboSpan" id="kobo.125.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">update</span></strong><span class="koboSpan" id="kobo.127.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">delete</span></strong><span class="koboSpan" id="kobo.129.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.130.1">CRUD</span></strong><span class="koboSpan" id="kobo.131.1">) functionality – that</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.132.1"> is, </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">update</span></strong><span class="koboSpan" id="kobo.134.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">insert</span></strong><span class="koboSpan" id="kobo.136.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">delete</span></strong><span class="koboSpan" id="kobo.138.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.140.1">query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">We must also annotate our interface with </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">@Dao</span></strong><span class="koboSpan" id="kobo.144.1"> to tell Room that this is our DAO. </span><span class="koboSpan" id="kobo.144.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">OnConflictStrategy.REPLACE</span></strong><span class="koboSpan" id="kobo.146.1"> on the update and </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Insert</span></strong><span class="koboSpan" id="kobo.148.1"> functions to help us with a case where we might encounter conflicts in our database. </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">OnConflictStrategy</span></strong><span class="koboSpan" id="kobo.150.1">, in this case, means that if </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">Insert</span></strong><span class="koboSpan" id="kobo.152.1"> has the same ID, it will replace that data with a </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">particular ID:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.154.1">
private const val DEFAULT_USER_ID = 0
@Dao
interface UserInformationDao {
    @Query("SELECT * FROM user_information")
    fun getUsersInformation():
        Flow&lt;List&lt;UserInformationModel&gt;&gt;
    @Query("SELECT * FROM user_information WHERE id =
        :userId")
    fun loadAllUserInformation(userId: Int =
        DEFAULT_USER_ID): Flow&lt;UserInformationModel&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUserInformation(userInformation:
        UserInformationModel)
    @Update(onConflict = OnConflictStrategy.REPLACE)
    suspend fun updateUserInformation(userInformation:
        UserInformationModel)
    @Delete
    suspend fun deleteUserInformation(userInformation:
        UserInformationModel)
}</span></pre>
<ol>
<li value="7"><span class="koboSpan" id="kobo.155.1">Now that we have our entity and DAO, we will finally create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Database</span></strong><span class="koboSpan" id="kobo.157.1"> class, which extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">RoomDatabase()</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">In this class, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">@Database</span></strong><span class="koboSpan" id="kobo.161.1"> annotation, pass</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.162.1"> in the entity that we created, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">UserInformation</span></strong><span class="koboSpan" id="kobo.164.1"> entity, and give our database a version name, which currently is </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">one</span></strong><span class="koboSpan" id="kobo.166.1">. </span><span class="koboSpan" id="kobo.166.2">We will also specify whether our database schema should be exported or not. </span><span class="koboSpan" id="kobo.166.3">So, let’s go ahead and create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">Database</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.168.1">abstract class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.169.1">
@Database(entities = [UserInformation::class], version = 1, exportSchema = false)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.170.1">
abstract class UserInformationDatabase : RoomDatabase() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.171.1">
    abstract fun userInformationDao():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.172.1">
        UserInformationDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.173.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.174.1">Finally, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Room</span></strong><span class="koboSpan" id="kobo.176.1"> set up and ready. </span><span class="koboSpan" id="kobo.176.2">Now, we need to add Dependency Injection and our user interface; you can find the code in the </span><em class="italic"><span class="koboSpan" id="kobo.177.1">Technical requirements</span></em><span class="koboSpan" id="kobo.178.1"> section. </span><span class="koboSpan" id="kobo.178.2">Also, the UI is quite basic at this stage; you can make it a challenge to improve it, as this sample project is just for </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">demonstration purposes.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.180.1"><img alt="Figure 6.1 – The﻿ app's UI" src="image/Figure_6.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.181.1">Figure 6.1 – The</span><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.182.1"> app's UI</span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.183.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.184.1">The Modern Android Development</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.185.1"> Room library has three significant components of the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">Room database:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.187.1">The entity</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.188.1">The DAO</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.189.1">The database</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">Entity</span></strong><span class="koboSpan" id="kobo.191.1"> is a table within the database. </span><span class="koboSpan" id="kobo.191.2">Room generates a table for each class that has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">@Entity</span></strong><span class="koboSpan" id="kobo.193.1"> annotation; if you have used Java before, you can think of the entity as a </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">plain old Java object</span></strong><span class="koboSpan" id="kobo.195.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.196.1">POJO</span></strong><span class="koboSpan" id="kobo.197.1">). </span><span class="koboSpan" id="kobo.197.2">The entity</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.198.1"> classes tend to be minor, don’t contain any logic, and only hold the data type for </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Some significant annotations that map the tables in the database are the foreign keys, indices, primary keys, and table names. </span><span class="koboSpan" id="kobo.200.2">There are other essential annotations, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">ColumnInfo</span></strong><span class="koboSpan" id="kobo.202.1">, which gives column information, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">Ignore</span></strong><span class="koboSpan" id="kobo.204.1">, which, if used, whichever data you wish to ignore will not be persisted </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">by Room.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.206.1"><img alt="Figure 6.2 – Room DAO" src="image/Figure_6.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.207.1">Figure 6.2 – Room DAO</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">@DAO</span></strong><span class="koboSpan" id="kobo.209.1"> defines the functions</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.210.1"> that access the database. </span><span class="koboSpan" id="kobo.210.2">Think of it like CRUD; if you used SQLite before Room, this is similar to using the cursor objects. </span><span class="koboSpan" id="kobo.210.3">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">@Database</span></strong><span class="koboSpan" id="kobo.212.1"> contains the database functions and serves as the main entry point for any underlying connection to our application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">relational data.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">If you need to use this, you annotate with </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">@Database</span></strong><span class="koboSpan" id="kobo.216.1">, as we did in our database class. </span><span class="koboSpan" id="kobo.216.2">In addition, this class extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">RoomDatabase</span></strong><span class="koboSpan" id="kobo.218.1"> and includes the list of entities we create. </span><span class="koboSpan" id="kobo.218.2">It also contains the abstract method that we create, has no arguments, and returns the class that we annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">@Dao</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">We run the database by </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">Room.databaseB</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.223.1">uilder()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.225.1">Implementing Dependency Injection in Room</span></h1>
<p><span class="koboSpan" id="kobo.226.1">As with other recipes, Dependency</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.227.1"> Injection is vital, and in this recipe, we will </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.228.1">walk through how we can inject our </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">DatabaseModule</span></strong><span class="koboSpan" id="kobo.230.1"> and provide the Room database where it</span><a id="_idTextAnchor293"/> <span class="No-Break"><span class="koboSpan" id="kobo.231.1">is needed.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.232.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.233.1">You will need to have prior knowledge of how Hilt works to be able to follow this recipe st</span><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.234.1">ep </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">by step.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.236.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.237.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">RoomExample</span></strong><span class="koboSpan" id="kobo.239.1"> project and add Hilt, which is what we will use for Dependency Injection. </span><span class="koboSpan" id="kobo.239.2">In </span><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.240.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.241.1">, </span><em class="italic"><span class="koboSpan" id="kobo.242.1">Handling the UI State in Jetpack Compose and Using Hilt</span></em><span class="koboSpan" id="kobo.243.1">, we covered </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.244.1">Hilt, so we will not discuss it here but just show you how you</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.245.1"> can use it </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">with Room:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.247.1">Open your project and add the necessary Hilt dependency. </span><span class="koboSpan" id="kobo.247.2">See </span><a href="B18827_03.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.249.1">, </span><em class="italic"><span class="koboSpan" id="kobo.250.1">Handling the UI State in Jetpack Compose and Using Hilt</span></em><span class="koboSpan" id="kobo.251.1">, if you need help setting up Hilt or </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">visit </span></span><a href="https://dagger.dev/hilt/"><span class="No-Break"><span class="koboSpan" id="kobo.253.1">https://dagger.dev/hilt/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.254.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.255.1">Next, let’s go ahead and add our </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">@HiltAndroidApp</span></strong><span class="koboSpan" id="kobo.257.1"> class, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Manifest</span></strong><span class="koboSpan" id="kobo.259.1"> folder, add the name of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">HiltAndroidApp</span></strong><span class="koboSpan" id="kobo.261.1">, in our </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">case, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">UserInformation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.265.1">
@HiltAndroidApp</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.266.1">
class UserInformation : Application()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.267.1">
&lt;application</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.268.1">
    android:allowBackup="true"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.269.1">
    android:name=".UserInformation"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.270.1">
    tools:targetApi="33"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.271.1">
...</span></pre></li>
<li><span class="koboSpan" id="kobo.272.1">Now that we have Dependency Injection, let’s go ahead and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">@AndroidEntryPoint</span></strong><span class="koboSpan" id="kobo.274.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">MainActivity</span></strong><span class="koboSpan" id="kobo.276.1"> class, and in our project, let’s create a new package and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">di</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">Inside, we will create a new class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">DatabaseModule</span></strong><span class="koboSpan" id="kobo.280.1">, and add </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">our functionalities.</span></span></li>
<li><span class="koboSpan" id="kobo.282.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">DatabaseModule</span></strong><span class="koboSpan" id="kobo.284.1">, let’s go ahead and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">provideDatabase()</span></strong><span class="koboSpan" id="kobo.286.1"> function, where we will</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.287.1"> return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Room</span></strong><span class="koboSpan" id="kobo.289.1"> object, add the</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.290.1"> database name, and ensure we build </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">our database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.292.1">
@Module</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
@InstallIn(SingletonComponent::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.294.1">
class DataBaseModule {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.295.1">
    @Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.296.1">
    @Provides</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.297.1">
    fun provideDatabase(@ApplicationContext context:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.298.1">
    Context): UserInformationDatabase {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.299.1">
        return Room.databaseBuilder(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.300.1">
            context,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
            UserInformationDatabase::class.java,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.302.1">
            "user_information.db"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.303.1">
        ).build()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.304.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.305.1">
    @Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.306.1">
    @Provides</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.307.1">
    fun provideUserInformationDao(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.308.1">
    userInformationDatabase: UserInformationDatabase):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.309.1">
    UserInformationDao {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.310.1">
        return</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
          userInformationDatabase.userInformationDao()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.312.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.313.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.314.1">Now that we have our Dependency Injection database module set up, we can now start adding the service, which are functions</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.315.1"> that will help us add user</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.316.1"> information to the database and get user information from the database. </span><span class="koboSpan" id="kobo.316.2">So, let us go ahead and create a new package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">service</span></strong><span class="koboSpan" id="kobo.318.1">. </span><span class="koboSpan" id="kobo.318.2">Inside the package, create a new interface, </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">UserInfoService</span></strong><span class="koboSpan" id="kobo.320.1">, and add the two </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">aforementioned functions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.322.1">
interface UserInfoService {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
    fun getUserInformationFromDB():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.324.1">
        Flow&lt;UserInformation&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.325.1">
    suspend fun addUserInformationInDB(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.326.1">
        userInformation: UserInformation)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.327.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.328.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">UserInfoService</span></strong><span class="koboSpan" id="kobo.330.1"> is an interface, we will need to implement the functionalities in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Impl</span></strong><span class="koboSpan" id="kobo.332.1"> class, so let us now go ahead and create a new class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">UserInfoServiceImpl</span></strong><span class="koboSpan" id="kobo.334.1"> and a singleton class, and then implement </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">the interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.336.1">
@Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.337.1">
class UserInfoServiceImpl() : UserInfoService {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.338.1">
    override fun getUserInformationFromDB():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.339.1">
        Flow&lt;UserInformation&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.340.1">
            TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.341.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.342.1">
    override suspend fun addUserInformationInDB(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.343.1">
        userInformation: UserInformation) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.344.1">
            TODO("Not yet implemented")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.345.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.346.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.347.1">We will need to inject our </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.348.1">constructor and pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">UserInformationDao()</span></strong><span class="koboSpan" id="kobo.350.1">, since we will use the insert</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.351.1"> function to insert the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">user data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.353.1">
class UserInfoServiceImpl @Inject constructor(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.354.1">
private val userInformationDao: UserInformationDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.355.1">
): UserInfoService</span></pre></li>
<li><span class="koboSpan" id="kobo.356.1">Now, we need to add code in our functions that have the TODO in them. </span><span class="koboSpan" id="kobo.356.2">Let’s go ahead and see the user information first. </span><span class="koboSpan" id="kobo.356.3">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">userInformationDao</span></strong><span class="koboSpan" id="kobo.358.1">, we will call the insert function to tell Room that we want to insert this </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">user information:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
override suspend fun addUserInformationInDB(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.361.1">
userInformation: UserInformation) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.362.1">
    userInformationDao.insertUserInformation(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
        UserInformation(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.364.1">
            firstName = userInformation.firstName,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.365.1">
            lastName = userInformation.lastName,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
            dateOfBirth = userInformation.dateOfBirth,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.367.1">
            gender = userInformation.gender,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.368.1">
            city = userInformation.city,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.369.1">
            profession = userInformation.profession</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.370.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.373.1">Then, we need to </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.374.1">get the user information from the database; this will visualize a user’s data </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.375.1">on </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">the screen:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
override fun getUserInformationFromDB() =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.378.1">
    userInformationDao.getUsersInformation().filter {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.379.1">
        information -&gt; information.isNotEmpty()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
    }.flatMapConcat {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
        userInformationDao.loadAllUserInformation()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.382.1">
            .map { userInfo -&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.383.1">
                UserInfo(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.384.1">
                    id = userInfo.id,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
                    firstName = userInfo.firstName,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.386.1">
                    lastName = userInfo.lastName,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.387.1">
                    dateOfBirth =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.388.1">
                        userInfo.dateOfBirth,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.389.1">
                    gender = userInfo.gender,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.390.1">
                    city = userInfo.city,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.391.1">
                    profession = userInfo.profession</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.392.1">
                )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.393.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
    }</span></pre></li>
<li><span class="koboSpan" id="kobo.395.1">Finally, we need to ensure that we provide the implementation through Dependency Injection, so</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.396.1"> let’s now go ahead and add the</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.397.1"> preceding code, then clean the project, run it, and ensure that everything works </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">as expected:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
@Module</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.400.1">
@InstallIn(SingletonComponent::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.401.1">
abstract class UserInfoServiceModule {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.402.1">
    @Singleton</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.403.1">
    @Binds</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.404.1">
    abstract fun bindUserService(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
        userInfoServiceImpl: UserInfoServiceImpl):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.406.1">
            UserInfoService</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.407.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.408.1">Once you run the project, you should be able to see it launch without issue. </span><span class="koboSpan" id="kobo.408.2">We will go ahead and add a function in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">ViewModel</span></strong><span class="koboSpan" id="kobo.410.1"> to insert the data in our database; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">ViewModel</span></strong><span class="koboSpan" id="kobo.412.1"> will be used in the views that </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">we created:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
@HiltViewModel</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
class UserInfoViewModel @Inject constructor(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.416.1">
    private val userInfoService: UserInfoService</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.417.1">
) : ViewModel() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.418.1">
    fun saveUserInformationData(userInfo: UserInfo) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.419.1">
        viewModelScope.launch {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
            userInfoService.addUserInformationInDB(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.421.1">
                userInfo)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.423.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.424.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.425.1">We can now inspect the </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.426.1">database and see whether</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.427.1"> it was created correctly. </span><span class="koboSpan" id="kobo.427.2">Run the app, and once it’s ready in the IDE, click </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">App Inspection</span></strong><span class="koboSpan" id="kobo.429.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.430.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.431.1">.3</span></em><span class="koboSpan" id="kobo.432.1">. </span><span class="koboSpan" id="kobo.432.2">You should be able to open the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">Database Inspector.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.434.1"><img alt="Figure 6.3 – App Inspection" src="image/Figure_6.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.435.1">Figure 6.3 – App Inspection</span></p>
<ol>
<li value="13"><span class="koboSpan" id="kobo.436.1">Once the Database Inspector is loaded, you should be able to select the currently running Android Emulator, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.437.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.438.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.440.1"><img alt="Figure 6.4 – The selected app for app inspection" src="image/Figure_6.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.441.1">Figure 6.4 – The selected app for app inspection</span></p>
<ol>
<li value="14"><span class="koboSpan" id="kobo.442.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.443.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.444.1">.5</span></em><span class="koboSpan" id="kobo.445.1">, you can see the Database Inspector open and </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">our database.</span></span></li>
</ol>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.447.1"><img alt="Figure 6.5 – Our user_information database" src="image/Figure_6.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.448.1">Figure 6.5 – Our user_information database</span></p>
<ol>
<li value="15"><span class="koboSpan" id="kobo.449.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.450.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.451.1">.6</span></em><span class="koboSpan" id="kobo.452.1">, you can</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.453.1"> see that the data we inserted is</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.454.1"> displayed, which means our insert function works </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">as expected.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.456.1"><img alt="Fi﻿gure 6.6 – Our database" src="image/Figure_6.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.457.1">Fi</span><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.458.1">gure 6.6 – Our database</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.459.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.460.1">In this recipe, we opted to use Dependency Injection to supply the needed dependencies to specific classes. </span><span class="koboSpan" id="kobo.460.2">We covered in </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.461.1">depth what Dependency Injection is</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.462.1"> in previous chapters, so we will not explain it again in this recipe but, instead, talk about the modules </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">we created.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">@Singleton</span></strong><span class="koboSpan" id="kobo.466.1"> annotation in Hilt to indicate that </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">provideDatabase</span></strong><span class="koboSpan" id="kobo.468.1">, which provides an instance of Room, should be created only once during the lifetime of our application, and that this instance should be shared across all the components that depend on it. </span><span class="koboSpan" id="kobo.468.2">In addition, when you annotate a class or a binding method with </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">@Singleton</span></strong><span class="koboSpan" id="kobo.470.1">, Hilt ensures that only one instance of that class or object is created and all the components that need that object will receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">same instance.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">It’s important to also know that when we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">@Singleton</span></strong><span class="koboSpan" id="kobo.474.1"> in Hilt, it is not the same as the Singleton pattern in software design, which can easily be a source of confusion. </span><span class="koboSpan" id="kobo.474.2">Hilt’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">@Singleton</span></strong><span class="koboSpan" id="kobo.476.1"> only guarantees that one instance of a class will be created within the context of a particular </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">component hierarchy.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">In our project, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">DatabaseModule()</span></strong><span class="koboSpan" id="kobo.480.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">UserInfoServiceModule()</span></strong><span class="koboSpan" id="kobo.482.1">. </span><span class="koboSpan" id="kobo.482.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">DatabaseModule()</span></strong><span class="koboSpan" id="kobo.484.1"> class, we have two functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">provideDatabase</span></strong><span class="koboSpan" id="kobo.486.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">provideUserInformationDao</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">The first function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">provideDatabase</span></strong><span class="koboSpan" id="kobo.490.1">, returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">UserInformationDatabase</span></strong><span class="koboSpan" id="kobo.492.1"> Room instance, where we get to create the database and </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">build it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
fun provideDatabase(@ApplicationContext context: Context): UserInformationDatabase {
    return Room
        .databaseBuilder(context,
            UserInformationDatabase::class.java,
            "user_information.db")
        .build()
}</span></pre>
<p><span class="koboSpan" id="kobo.495.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">provideUserInformationDao</span></strong><span class="koboSpan" id="kobo.497.1">, we pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">UserInformationDatabase</span></strong><span class="koboSpan" id="kobo.499.1"> in the constructor and</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.500.1"> return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">UserInformationDao</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.502.1">abstract class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
fun provideUserInformationDao(userInformationDatabase: UserInformationDatabase): UserInformationDao {
    return userInformationDatabase.userInformationDao()
}</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.504.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.505.1">If you want to lose existing</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.506.1"> data when you are migrating or if your migration path is missing, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">.fallbackToDestructiveMigration()</span></strong><span class="koboSpan" id="kobo.508.1"> function </span><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.509.1">when creating </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">the database.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.511.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.512.1">There is more to learn in Room, and this recipe has only given you a brief overview of what you can do with it. </span><span class="koboSpan" id="kobo.512.2">You can learn more by following the link </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">at </span></span><a href="https://developer.android.com/reference/androidx/room/package-summary"><span class="No-Break"><span class="koboSpan" id="kobo.514.1">https://developer.android.com/reference/androidx/room/package-summary</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.515.1">.</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.516.1">Supporting multiple entities in Room</span></h1>
<p><span class="koboSpan" id="kobo.517.1">In this recipe, you will learn </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.518.1">how to handle multiple entities in Room. </span><span class="koboSpan" id="kobo.518.2">This is useful whenever you have a big project that needs a different data input. </span><span class="koboSpan" id="kobo.518.3">An excellent example that we can work with is a </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">budgeting app.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">To support multiple entities in Room, you need to define multiple classes that represent your database tables. </span><span class="koboSpan" id="kobo.520.2">Each class should have its own annotations and fields that correspond to columns in a table. </span><span class="koboSpan" id="kobo.520.3">For instance, a budgeting app might need different types of models, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">BudgetData</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">ExpenseData</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">ExpenseItem</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.525.1">Hence, having multiple entities is sometimes necessary, and knowing how to</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.526.1"> handle that comes </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">in handy.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.528.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.529.1">To follow along with this recipe, you must have completed the </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">previous recipe.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.531.1">How to do it …</span></h2>
<p><span class="koboSpan" id="kobo.532.1">You can use any project of your choosing to implement the topics discussed in this recipe. </span><span class="koboSpan" id="kobo.532.2">In addition, you can use this example in your pre-existing project to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the topic.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.534.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">RoomExample</span></strong><span class="koboSpan" id="kobo.536.1">, you can</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.537.1"> add more functionality to the app and try to add more entities, but for this project, let’s go ahead and show how you can handle multiple entities </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">in Room.</span></span></li>
<li><span class="koboSpan" id="kobo.539.1">For this example, we will use the sample budgeting App we introduced in an earlier chapter, and since we are working with entities, this will be easier to follow. </span><span class="koboSpan" id="kobo.539.2">Let’s create a new entity and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">BudgetData</span></strong><span class="koboSpan" id="kobo.541.1">; the budget data class might have several fields, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">budgetName</span></strong><span class="koboSpan" id="kobo.543.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">budgetAmount</span></strong><span class="koboSpan" id="kobo.545.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">expenses</span></strong><span class="koboSpan" id="kobo.547.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">startDate</span></strong><span class="koboSpan" id="kobo.549.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">endDate</span></strong><span class="koboSpan" id="kobo.551.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">notify</span></strong><span class="koboSpan" id="kobo.553.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">currency</span></strong><span class="koboSpan" id="kobo.555.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">totalExpenses</span></strong><span class="koboSpan" id="kobo.557.1">; hence, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">BudgetData</span></strong><span class="koboSpan" id="kobo.559.1"> data class will look </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
@Entity(tableName = "budgets")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
data class BudgetData(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.563.1">
    @PrimaryKey(autoGenerate = true)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.564.1">
    var id: Int = 0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.565.1">
    var budgetName: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.566.1">
    var budgetAmount: Double = 0.0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.567.1">
    var expenses: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.568.1">
    var startDate: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
    var endDate: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.570.1">
    var notify: Int = 0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.571.1">
    var currency: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.572.1">
    var totalExpenses: Double</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.573.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.574.1">Let’s go ahead and add </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.575.1">two more entities. </span><span class="koboSpan" id="kobo.575.2">First, we will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">ExpenseData</span></strong><span class="koboSpan" id="kobo.577.1">, which might have the following fields </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">and types:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.579.1">
@Entity(tableName = "expenses")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.580.1">
data class ExpenseData(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
    @PrimaryKey(autoGenerate = true)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
    var id: Int = 0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.583.1">
    var expenseName: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.584.1">
    var expenseType: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.585.1">
    var expenseAmount: Double = 0.0,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.586.1">
    @ColumnInfo(name = "updated_at")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.587.1">
    var expenseDate: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.588.1">
    var note: String = "",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.589.1">
    var currency: String = ""</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.590.1">
)</span></pre></li>
<li><span class="koboSpan" id="kobo.591.1">Then, let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">ExpenseItem</span></strong><span class="koboSpan" id="kobo.593.1">, which might consist of the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">following fields:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.595.1">
@Entity(tableName = "items")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
Data class ExpenseItem(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
    @PrimaryKey(autoGenerate = true)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.598.1">
    private var _id: Int</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
    val name: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
    var type: String?</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
    val imageContentId: Int</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.602.1">
    val colorContentId: Int)</span></pre></li>
<li><span class="koboSpan" id="kobo.603.1">As you can see, we have</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.604.1"> three entities; based on these entities, you should create different DAOs for </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">each one:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.606.1">
abstract class AppDatabase : RoomDatabase() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.607.1">
    abstract fun budgetDao(): BudgetDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.608.1">
    abstract fun itemDao(): ItemDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.609.1">
    abstract fun expenseDao(): ExpenseDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.610.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.611.1">At the top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">AppDatabase</span></strong><span class="koboSpan" id="kobo.613.1"> abstract class, we will annotate it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">@Database</span></strong><span class="koboSpan" id="kobo.615.1"> and then pass it to all </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">our entities:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.617.1">
@Database(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.618.1">
    entities = [ExpenseItem::class, BudgetData::class,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.619.1">
        ExpenseData::class],</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.620.1">
    version = 1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.621.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.622.1">
@TypeConverters(DateConverter::class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
abstract class AppDatabase : RoomDatabase() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.624.1">
    abstract fun budgetDao(): BudgetDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.625.1">
    abstract fun itemDao(): ItemDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.626.1">
    abstract fun expenseDao(): ExpenseDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.627.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.628.1">You can also use embedded objects; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">@Embedded</span></strong><span class="koboSpan" id="kobo.630.1"> annotation includes nested or related entities within an entity. </span><span class="koboSpan" id="kobo.630.2">It allows you to represent the relationship between </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.631.1">entities by embedding one or more related entities in the </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">parent entity:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.633.1">
data class ExpenseItem(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.635.1">
    @Embedded val tasks: Tasks</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
  )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.637.1">
data class Tasks(...)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.638.1">In our preceding example, we have annotated the tasks property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">ExpenseItem</span></strong><span class="koboSpan" id="kobo.640.1"> entity with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">@Embedded</span></strong><span class="koboSpan" id="kobo.642.1"> annotation. </span><span class="koboSpan" id="kobo.642.2">This tells Room to include the fields of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">Tasks</span></strong><span class="koboSpan" id="kobo.644.1"> data class within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">ExpenseItem</span></strong><span class="koboSpan" id="kobo.646.1"> table, rather than creating a separate table for our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">ExpenseItem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1"> entity.</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.649.1">Then, the Tasks data class can have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">description</span></strong><span class="koboSpan" id="kobo.651.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">priority</span></strong><span class="koboSpan" id="kobo.653.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">updatedAt</span></strong><span class="koboSpan" id="kobo.655.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">and ID:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.657.1">
data class Tasks (</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.658.1">
    @PrimaryKey(autoGenerate = true)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.659.1">
    var id = 0</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.660.1">
    var description: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.661.1">
    var priority: Int</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.662.1">
    @ColumnInfo(name = "updated_at")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.663.1">
    var updatedAt: Date)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.664.1">Hence, the table representing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">ExpenseItem</span></strong><span class="koboSpan" id="kobo.666.1"> object will contain additional columns with the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">added fields.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">That’s it; once you declare the entities in the database and pass them as required, you will have supported multiples</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.669.1"> entities in </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">your </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">Database</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.673.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.674.1">If your entity has multiple embedded fields of the same type, you can keep each column unique by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">Prefix</span></strong><span class="koboSpan" id="kobo.676.1"> property; then, Room will add the provided values to the beginning of each column name in the embedded object. </span><span class="koboSpan" id="kobo.676.2">Find out more </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">at </span></span><a href="https://developer.android.com/"><span class="No-Break"><span class="koboSpan" id="kobo.678.1">https://developer.android.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.679.1">.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.680.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.681.1">According to the rules in Room, you can define an entity relationship in three </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">different ways.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.683.1">One-to-many relationships or </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">many-to-one relationships</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.685.1">One-to-one relationships</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.686.1">Many-to-many relationships</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.687.1">As you have already seen, using entities in one class makes it manageable and easily trackable; hence, this is an excellent solution for Android engineers. </span><span class="koboSpan" id="kobo.687.2">A notable annotation is </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">@Relation</span></strong><span class="koboSpan" id="kobo.689.1">, which specifies where you create an object that shows the relationship between </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">your entities.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.691.1">There’s more...</span></h2>
<p><span class="koboSpan" id="kobo.692.1">There is more to learn in Room – for instance, defining relationships between objects, writing asynchronous data accessible object queries, and referencing complex data. </span><span class="koboSpan" id="kobo.692.2">It is fair to say we cannot cover everything in just one chapter but offer some guidance to help you navigate building Modern Android applications. </span><span class="koboSpan" id="kobo.692.3">For more on Room, </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">visit </span></span><a href="https://developer.android.com/training/data-storage/room"><span class="No-Break"><span class="koboSpan" id="kobo.694.1">https://developer.android.com/training/data-storage/room</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.695.1">.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.696.1">Migrating an existing SQL database to room</span></h1>
<p><span class="koboSpan" id="kobo.697.1">As we mentioned earlier, Room does </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.698.1">harness the power of SQLite, and because many applications still use legacy, you might find applications still using SQL and be wondering how you can migrate to Room and utilize the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">Room features.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">In this recipe, we will cover the migration of an existing SQL database to Room with step-by-step examples. </span><span class="koboSpan" id="kobo.700.2">Furthermore, Room offers an abstraction layer to help with SQLite migrations – that is, by offering </span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.701.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">Migration</span></strong><span class="koboSpan" id="kobo.703.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">to developers.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.705.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.706.1">Because we did not create a new SQLite database example, since that is not necessary, we will try to emulate a scenario with a dummy sample SQLite database and showcase how you can migrate your existing SQLite database </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">to Room:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.708.1">Since we will be adding Room in an existing SQLite project, you will need to ensure you add the required dependencies. </span><span class="koboSpan" id="kobo.708.2">To set this up, refer to the </span><em class="italic"><span class="koboSpan" id="kobo.709.1">Implementing Room in your </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.710.1">applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.711.1"> recipe.</span></span></li>
<li><span class="koboSpan" id="kobo.712.1">Next, you will need to go ahead and create a new DAO and entity, since Room requires it. </span><span class="koboSpan" id="kobo.712.2">Hence, in this set following the first Room recipe, you can update the model classes to entities. </span><span class="koboSpan" id="kobo.712.3">This is pretty straightforward, since mostly what you will do is annotate the classes with </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">@Entity</span></strong><span class="koboSpan" id="kobo.714.1"> and use the table </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">Names</span></strong><span class="koboSpan" id="kobo.716.1"> property to set the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">the table.</span></span></li>
<li><span class="koboSpan" id="kobo.718.1">You must also add </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">@PrimaryKey</span></strong><span class="koboSpan" id="kobo.720.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">@ColumnInfo</span></strong><span class="koboSpan" id="kobo.722.1"> annotations for your entity classes. </span><span class="koboSpan" id="kobo.722.2">Here is a sample </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">SQLite database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.724.1">
fun onCreate(db: SQLiteDatabase) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.725.1">
    // Create a String that contains the SQL statement</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.726.1">
       to create the items table</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.727.1">
    val SQL_CREATE_ITEMS_TABLE =(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.728.1">
            "CREATE TABLE " + ItemsContract.ItemsEntry</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.729.1">
                     .TABLE_NAME.toString() + " ("</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.730.1">
                     + ItemsContract.ItemsEntry.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.731.1">
                     _Id.toString()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.732.1">
                     + " INTEGER PRIMARY KEY</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.733.1">
                     AUTOINCREMENT, "</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.734.1">
                     + ItemsContract.ItemsEntry</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.735.1">
                     .COLUMN_ITEM_NAME.toString()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.736.1">
                     + " TEXT NOT NULL, "</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.737.1">
                     + ItemsContract.ItemsEntry</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.738.1">
                     .COLUMN_ITEM_TYPE.toString()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.739.1">
                     + " TEXT NOT NULL, "</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.740.1">
                     + ItemsContract.ItemsEntry</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.741.1">
                     .COLUMN_ITEM_LOGO.toString()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.742.1">
                     + " INTEGER NOT NULL DEFAULT 0, "</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.743.1">
                     + ItemsContract.ItemsEntry</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.744.1">
                     .COLUMN_ITEM_COLOR.toString()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.745.1">
                     + " INTEGER NOT NULL DEFAULT 0, "</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.746.1">
                     + ItemsContract.ItemsEntry</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.747.1">
                     .COLUMN_ITEM_CREATED_DATE</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.748.1">
                     .toString() + " DATE NOT NULL</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.749.1">
                     DEFAULT CURRENT_TIMESTAMP);")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.750.1">
    // Execute the SQL statement</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.751.1">
    db.execSQL(SQL_CREATE_ITEMS_TABLE)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.753.1">However, Room has simplified the process, and we no longer need to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">Contracts</span></strong><span class="koboSpan" id="kobo.755.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">Contracts</span></strong><span class="koboSpan" id="kobo.757.1"> in Android are a way for developers to define and enforce a set of rules for accessing data within an application. </span><span class="koboSpan" id="kobo.757.2">These contracts typically define the structure and schema of the database tables and the expected data types and formats for the data within them. </span><span class="koboSpan" id="kobo.757.3">In the case of SQLite on Android, contracts are </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.758.1">often used to define the tables and columns of the database, as well as any constraints or relationships </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">between them.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.760.1">Once we have created all our needed entities and DAOs, we can go ahead and create the database. </span><span class="koboSpan" id="kobo.760.2">As we saw in the </span><em class="italic"><span class="koboSpan" id="kobo.761.1">Implementing Room in your Applications</span></em><span class="koboSpan" id="kobo.762.1"> recipe, we can add all our entities in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">@Database</span></strong><span class="koboSpan" id="kobo.764.1"> annotation, and since we are in the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">(1)</span></strong><span class="koboSpan" id="kobo.766.1"> version, we can increment the version </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">to (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">2)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.770.1">
val MIGRATION_1_2 = object : Migration(1, 2) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.771.1">
    override fun migrate(database:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.772.1">
    SupportSQLiteDatabase) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.773.1">
        //alter items table</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.774.1">
        database.execSQL("CREATE TABLE new_items (_id</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.775.1">
            INTEGER PRIMARY KEY AUTOINCREMENT NOT</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.776.1">
            NULL, name TEXT NOT NULL, type TEXT,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.777.1">
            imageContentId INTEGER NOT NULL,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.778.1">
            colorContentId INTEGER NOT NULL)")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.779.1">
        database.execSQL("INSERT INTO new_items</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.780.1">
            (_id,name,type,imageContentId,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.781.1">
            colorContentId)Select_id,name,type,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.782.1">
            imageContentId, colorContentId FROM</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.783.1">
            items")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.784.1">
        database.execSQL("DROP TABLE items")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.785.1">
        database.execSQL("ALTER TABLE new_items RENAME</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.786.1">
            TO items")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
    }</span></pre></li>
<li><span class="koboSpan" id="kobo.788.1">Then, the important part is</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.789.1"> ensuring we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">build()</span></strong><span class="koboSpan" id="kobo.791.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">Room database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.793.1">
Room.databaseBuilder(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.794.1">
    androidContext(),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.795.1">
    AppDatabase::class.java, "budget.db"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.796.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.797.1">
    .addCallback(object : RoomDatabase.Callback() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.798.1">
        override fun</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.799.1">
        onCreate(db:SupportSQLiteDatabase){</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.800.1">
            super.onCreate(db)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.801.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.802.1">
    })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.803.1">
    .addMigrations(MIGRATION_1_2)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.804.1">
    .build()</span></pre></li>
<li><span class="koboSpan" id="kobo.805.1">Once your data layer starts using Room, you can officially replace all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">Cursor</span></strong><span class="koboSpan" id="kobo.807.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">ContentValue</span></strong><span class="koboSpan" id="kobo.809.1"> code with the DAO calls. </span><span class="koboSpan" id="kobo.809.2">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">AppDatabase</span></strong><span class="koboSpan" id="kobo.811.1"> class, we have our entities, and our class </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">extends </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">RoomDatabase()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.815.1">
@Database(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.816.1">
    entities = [&lt;List of entities&gt;],</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.817.1">
    version = 2</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.818.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.819.1">
abstract class AppDatabase : RoomDatabase() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.820.1">
    abstract fun itemDao(): ItemDao</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.821.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.822.1">Because Room offers runtime errors, if any error occurs, you will be notified </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">in Logcat.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.824.1">It is fair to say that not</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.825.1"> everything can be covered in one recipe because SQLite does require a lot of code to set up – for instance, to create queries and handle the cursors – but Room helps to speed these processes up, w</span><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.826.1">hich is why it is </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">highly recommended.</span></span></li>
</ol>
<h2 id="_idParaDest-177"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.828.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.829.1">As recommended earlier, migrating a complex database might be hectic and require caution, since it can affect users if pushed to production without thorough testing. </span><span class="koboSpan" id="kobo.829.2">It is also highly recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">OpenHelper</span></strong><span class="koboSpan" id="kobo.831.1">, exposed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">RoomDatabase</span></strong><span class="koboSpan" id="kobo.833.1">, for more straightforward or minimal changes to your database. </span><span class="koboSpan" id="kobo.833.2">Furthermore, it is worth mentioning that if you have any legacy code using SQLite, it will be written at a high level in Java, so working with a team to find a better solution for the migration </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">is needed.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">In your project, you must update the class that extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">SQLiteOpenHelper</span></strong><span class="koboSpan" id="kobo.837.1">. </span><span class="koboSpan" id="kobo.837.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">SupportSQLiteDatabase</span></strong><span class="koboSpan" id="kobo.839.1"> because we need to update the calls to get the writable and readable database. </span><span class="koboSpan" id="kobo.839.2">This is a cleaner database abstraction class to insert and query </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">the database.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.841.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.842.1">It is important to </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.843.1">note that it might be complicated to migrate to a complex database that has many tables and complex queries. </span><span class="koboSpan" id="kobo.843.2">However, if your database has minimal tables and no complex queries, migration can be done quickly with relatively small incremental changes in a feature branch. </span><span class="koboSpan" id="kobo.843.3">It might be helpful to download the app’s database, and you can do so by visiting the following </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">link: </span></span><a href="https://developer.android.com/training/data-storage/room/testing-db#command-line"><span class="No-Break"><span class="koboSpan" id="kobo.845.1">https://developer.android.com/training/data</span><span id="_idTextAnchor312"/><span class="koboSpan" id="kobo.846.1">-storage/room/testing-db#command-line</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.847.1">.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.848.1">Testing your local database</span></h1>
<p><span class="koboSpan" id="kobo.849.1">So far, we have ensured that we </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.850.1">write tests whenever necessary for our projects. </span><span class="koboSpan" id="kobo.850.2">We will now need to go ahead and write tests for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">RoomExample</span></strong><span class="koboSpan" id="kobo.852.1"> project, since this is crucial, and you might be required to do so in a real-world scenario. </span><span class="koboSpan" id="kobo.852.2">Hence, in this recipe, we will look at a step-by-step guide </span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.853.1">on writing CRUD tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">our database.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.855.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.856.1">You will need to open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">RoomExample</span></strong><span class="koboSpan" id="kobo.858.1"> p</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.859.1">roject to get started with </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">this recipe.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.861.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.862.1">Let’s go ahead and first add all the needed Room testing dependencies, and then start writing our tests. </span><span class="koboSpan" id="kobo.862.2">For the Hilt test setup, refer to the </span><em class="italic"><span class="koboSpan" id="kobo.863.1">Technical requirements</span></em><span class="koboSpan" id="kobo.864.1"> section, where you can find all the </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">required code:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.866.1">You will need to add the following to </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">your </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.870.1">
androidTestImplementation "com.google.truth:truth:1.1.3"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.871.1">
androidTestImplementation "android.arch.core:core-testing:1.1.1"</span></pre></li>
<li><span class="koboSpan" id="kobo.872.1">After you have added the required dependencies inside the Android test, go ahead and create a new class, calling </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">UserInformationDBTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.876.1">
class UserInformationDBTest {...}</span></pre></li>
<li><span class="koboSpan" id="kobo.877.1">Before we can set up our </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">@Before</span></strong><span class="koboSpan" id="kobo.879.1"> function, we will need to create two </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">lateinit var</span></strong><span class="koboSpan" id="kobo.881.1"> instances, which we will initialize in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">Before</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.885.1">
private lateinit var database: UserInformationDatabase</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.886.1">
private lateinit var userInformationDao: UserInformationDao</span></pre></li>
<li><span class="koboSpan" id="kobo.887.1">Now, let us go ahead and set up our </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">@Before</span></strong><span class="koboSpan" id="kobo.889.1"> function and create our database, using</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.890.1"> the in-memory database for </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">testing purposes:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.892.1">
@Before</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.893.1">
fun databaseCreated() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.894.1">
    database = Room.inMemoryDatabaseBuilder(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.895.1">
        ApplicationProvider.getApplicationContext(),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.896.1">
            UserInformationDatabase::class.java</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.897.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.898.1">
        .allowMainThreadQueries()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.899.1">
        .build()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.900.1">
    userInformationDao = database.userInformationDao()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.901.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.902.1">Since we are running and creating the database in memory, we will need to close it after it is done; hence, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">@After</span></strong><span class="koboSpan" id="kobo.904.1"> call, we will need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">close()</span></strong><span class="koboSpan" id="kobo.906.1"> on </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">our database:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.908.1">
@After</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.909.1">
fun closeDatabase() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.910.1">
    database.close()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.911.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.912.1">Now that our setup is </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.913.1">complete, we will go ahead and start testing our CRUD – that is, inserting, deleting, and updating. </span><span class="koboSpan" id="kobo.913.2">Let’s go ahead and create an insert </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">test first:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.915.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.916.1">
fun insertUserInformationReturnsTrue() = runBlocking {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.917.1">
    val userOne = UserInformationModel(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.918.1">
        id = 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.919.1">
        firstName = "Michelle",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.920.1">
        lastName = "Smith",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.921.1">
        dateOfBirth = 9121990,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.922.1">
        gender = "Male",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.923.1">
        city = "New york",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.924.1">
        profession = "Software Engineer"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.925.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.926.1">
    userInformationDao.insertUserInformation(userOne)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.927.1">
    val latch = CountDownLatch(1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.928.1">
    val job = async(Dispatchers.IO) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.929.1">
        userInformationDao.getUsersInformation()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.930.1">
            .collect {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.931.1">
                assertThat(it).contains(userOne)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.932.1">
                latch.countDown()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.933.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.934.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.935.1">
    latch.await()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.936.1">
    job.cancelAndJoin()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.937.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.938.1">Finally, let us </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.939.1">add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">delete</span></strong><span class="koboSpan" id="kobo.941.1"> function, and that will wrap up our testing Room </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">for now:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.943.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.944.1">
fun deleteUserInformation() = runBlocking {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.945.1">
    val userOne = UserInformationModel(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.946.1">
        id = 1,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.947.1">
        firstName = "Michelle",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.948.1">
        lastName = "Smith",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.949.1">
        dateOfBirth = 9121990,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.950.1">
        gender = "Male",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.951.1">
        city = "New york",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.952.1">
        profession = "Software Engineer"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.953.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.954.1">
    val userTwo = UserInformationModel(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.955.1">
        id = 2,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.956.1">
        firstName = "Mary",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.957.1">
        lastName = "Simba",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.958.1">
        dateOfBirth = 9121989,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.959.1">
        gender = "Female",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.960.1">
        city = "New york",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.961.1">
        profession = "Senior Android Engineer"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.962.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.963.1">
    userInformationDao.insertUserInformation(userOne)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.964.1">
    userInformationDao.insertUserInformation(userTwo)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.965.1">
    userInformationDao.deleteUserInformation(userTwo)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.966.1">
    val latch = CountDownLatch(1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.967.1">
    val job = async(Dispatchers.IO) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.968.1">
        userInformationDao.loadAllUserInformation()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.969.1">
            .collect {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.970.1">
                assertThat(it).doesNotContain(userTwo)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.971.1">
                latch.countDown()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.972.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.973.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.974.1">
    latch.await()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.975.1">
    job.cancelAndJoin()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.976.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.977.1">When you run</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.978.1"> the test, they should all pass with a green </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">ch</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.980.1">eck mark:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.981.1"><img alt="Figure 6.7 – Our tests passing" src="image/Figure_6.7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.982.1">Figure 6.7 – Our tests passing</span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.983.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.984.1">You might have noticed</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.985.1"> we have used </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">Truth</span></strong><span class="koboSpan" id="kobo.987.1">, which is a testing framework that provides a fluent and expressive API to write assertions in tests. </span><span class="koboSpan" id="kobo.987.2">It is developed by Google, and some of the advantages of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">Truth</span></strong><span class="koboSpan" id="kobo.989.1"> include readability, flexibility, and clear error messages. </span><span class="koboSpan" id="kobo.989.2">We can easily use a more like natural language constructs – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">isEqualTo</span></strong><span class="koboSpan" id="kobo.991.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">shouldBe</span></strong><span class="koboSpan" id="kobo.993.1"> – which makes the test assertions more intuitive and readable for </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">us developers.</span></span></p>
<p><span class="koboSpan" id="kobo.995.1">When using the framework, you get a wide range of assertion methods that allow you to test a variety of conditions, including equality, order, and containment. </span><span class="koboSpan" id="kobo.995.2">It also allows you to define custom assertion methods, giving you more control over the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">your tests.</span></span></p>
<p><span class="koboSpan" id="kobo.997.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">@Before</span></strong><span class="koboSpan" id="kobo.999.1"> annotation ensures our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">databaseCreated()</span></strong><span class="koboSpan" id="kobo.1001.1"> function is executed before each class. </span><span class="koboSpan" id="kobo.1001.2">Our function then creates a database using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">Room.inMemoryDatabaseBuilder</span></strong><span class="koboSpan" id="kobo.1003.1">, which creates a database in </span><strong class="bold"><span class="koboSpan" id="kobo.1004.1">Random Access Memory</span></strong><span class="koboSpan" id="kobo.1005.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1006.1">RAM</span></strong><span class="koboSpan" id="kobo.1007.1">) instead of</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.1008.1"> persistence storage. </span><span class="koboSpan" id="kobo.1008.2">This means our database will be cleared once the process is killed; hence, in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">@After</span></strong><span class="koboSpan" id="kobo.1010.1"> call, we close </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1012.1">
@After
fun closeDatabase() {
    database.close()
}</span></pre>
<p><span class="koboSpan" id="kobo.1013.1">As you might have seen, our tests are in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">AndroidTest</span></strong><span class="koboSpan" id="kobo.1015.1">, since we launch Room in the main thread and close it after we finish it. </span><span class="koboSpan" id="kobo.1015.2">The test classes just test the DAO functions – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">Update</span></strong><span class="koboSpan" id="kobo.1017.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">Insert</span></strong><span class="koboSpan" id="kobo.1019.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">Delete</span></strong><span class="koboSpan" id="kobo.1021.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">Query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">.</span></span></p>
</div>
</body></html>