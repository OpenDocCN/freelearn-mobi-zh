<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-159"><a id="_idTextAnchor283"/>6</h1>
<h1 id="_idParaDest-160"><a id="_idTextAnchor284"/>Using the Room Database and Testing</h1>
<p>Android applications can benefit significantly from storing data locally. The Room persistence library harnesses the power of SQLite. In particular, Room offers excellent benefits for Android developers. Furthermore, Room offers offline support, and the data is stored locally. In this chapter, we will learn how to implement Room, a Jetpack Library.</p>
<p> In this chapter, we’ll be covering the following recipes:</p>
<ul>
<li>Implementing Room in your applications</li>
<li>Implementing Dependency Injection in Room</li>
<li>Supporting multiple entities</li>
<li>Migrating existing SQL database to Room</li>
<li>Testing your local database</li>
</ul>
<p>It is also important to mention there are a couple more libraries are used with Room – for example, RxJava and Paging integration. In this chapter, we will not focus on them but instead on how you can utilize Room to build modern Android apps.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor285"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_six</a>.</p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor286"/>Implementing Room in your applications</h1>
<p>Room is an object-relational <a id="_idIndexMarker399"/>mapping library used in Android data persistence and is the recommended data persistence in Modern Android Development. In addition, it is effortless to use, understand and maintain, and harnesses the powers of <code>SQLiteDatabase</code>, it also helps reduce boilerplate code, an issue many developers experience when using SQLite. Writing tests is also very straightforward and easy to understand.</p>
<p>The most notable advantage of <a id="_idIndexMarker400"/>Room is that it is easy to integrate with other architecture components and gives developers runtime compile checks – that is, Room will complain if you make an error or change your schema without migrating, which is practical and helps reduce crashes<a id="_idTextAnchor287"/>.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor288"/>How to do it…</h2>
<p>Let’s go ahead and create a new empty compose project and call it <code>RoomExample</code>. In our example project, we will create a form intake from users; this is where users can save their first and last names, date of birth, gender, the city they live in, and their profession.</p>
<p>We will save our user data in our Room database, and then later inspect whether the elements we inserted were saved in our database and display the data on the screen:</p>
<ol>
<li>In our newly created project, let’s go ahead and delete the unnecessary wanted code – that is, <code>Greeting(name: String)</code>, which comes with all empty Compose projects. Keep the preview function, since we will use it to view the screen we create.</li>
<li>Now, let’s go on and add the needed dependencies for Room and sync the project. We will touch on<a id="_idIndexMarker401"/> dependency management using <code>buildSrc</code> in <a href="B18827_12.xhtml#_idTextAnchor672"><em class="italic">Chapter 12</em></a>, <em class="italic">Android Studio Tips and Tricks to Help You during Development</em>. You can find the latest version of Room at <a href="https://developer.android.com/jetpack/androidx/releases/room">https://developer.android.com/jetpack/androidx/releases/room</a>; we will add <code>kapt</code>, which stands for <strong class="bold">Kotlin Annotation Processing Tool</strong>, to enable us to use the Java annotation processor with the Kotlin code:<pre class="source-code">
dependencies {</pre><pre class="source-code">
implementation "androidx.Room:Room-runtime:2.x.x"</pre><pre class="source-code">
kapt "androidx.Room:Room-compiler:2.x.x"</pre><pre class="source-code">
}</pre><pre class="source-code">
//include kapt on your plugins</pre><pre class="source-code">
plugins {</pre><pre class="source-code">
    id 'kotlin-kapt'</pre><pre class="source-code">
}</pre></li>
<li>Create a new package and call it <code>data</code>. Inside <code>data</code>, create a new Kotlin class and call it <code>UserInformationModel()</code>. A data class is used to hold data only – in our case, the type of data<a id="_idIndexMarker402"/> that we will collect from users will be the first name, last name, date of birth, and so on.</li>
<li>By using Room, we use the <code>@Entity</code> annotation to give our model a table name; hence, in our newly created <code>UserInformation</code> class, let’s go ahead and add the <code>@Entity</code> annotation and call our table user information:<pre class="source-code">
@Entity(tableName = "user_information")</pre><pre class="source-code">
data class UserInformationModel(</pre><pre class="source-code">
    val id: Int = 0,</pre><pre class="source-code">
    val firstName: String,</pre><pre class="source-code">
    val lastName: String,</pre><pre class="source-code">
    val dateOfBirth: Int,</pre><pre class="source-code">
    val gender: String,</pre><pre class="source-code">
    val city: String,</pre><pre class="source-code">
    val profession: String</pre><pre class="source-code">
)</pre></li>
<li>Next, as in all databases, we need to define a primary key for our database. Hence, in our ID, we will add the <code>@PrimaryKey</code> annotation to tell Room that this is our primary key, and it should be autogenerated. If you don’t wish to autogenerate, you can set the Boolean to <code>false</code>, but this might not be a good idea, due to <a id="_idIndexMarker403"/>conflicts that might arise later in your database:<pre class="source-code">
@PrimaryKey(autoGenerate = true)</pre></li>
<li>Now, you should have an entity with a table name, a primary key, and your data types:<pre class="source-code">
import androidx.Room.Entity</pre><pre class="source-code">
import androidx.Room.PrimaryKey</pre><pre class="source-code">
@Entity(tableName = "user_information")</pre><pre class="source-code">
data class UserInformationModel(</pre><pre class="source-code">
    @PrimaryKey(autoGenerate = true)</pre><pre class="source-code">
    val id: Int = 0,</pre><pre class="source-code">
    ...</pre><pre class="source-code">
)</pre></li>
</ol>
<p>Inside our data package, let us go ahead and create a new package and call it <code>DAO</code>, which means <code>UserInformationDao</code>; this interface<a id="_idIndexMarker405"/> will hold the <strong class="bold">create</strong>, <strong class="bold">read</strong>, <strong class="bold">update</strong>, and <strong class="bold">delete</strong> (<strong class="bold">CRUD</strong>) functionality – that<a id="_idIndexMarker406"/> is, <strong class="bold">update</strong>, <strong class="bold">insert</strong>, <strong class="bold">delete</strong>, and <strong class="bold">query</strong>.</p>
<p>We must also annotate our interface with <code>@Dao</code> to tell Room that this is our DAO. We use <code>OnConflictStrategy.REPLACE</code> on the update and <code>Insert</code> functions to help us with a case where we might encounter conflicts in our database. <code>OnConflictStrategy</code>, in this case, means that if <code>Insert</code> has the same ID, it will replace that data with a particular ID:</p>
<pre class="source-code">
private const val DEFAULT_USER_ID = 0
@Dao
interface UserInformationDao {
    @Query("SELECT * FROM user_information")
    fun getUsersInformation():
        Flow&lt;List&lt;UserInformationModel&gt;&gt;
    @Query("SELECT * FROM user_information WHERE id =
        :userId")
    fun loadAllUserInformation(userId: Int =
        DEFAULT_USER_ID): Flow&lt;UserInformationModel&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUserInformation(userInformation:
        UserInformationModel)
    @Update(onConflict = OnConflictStrategy.REPLACE)
    suspend fun updateUserInformation(userInformation:
        UserInformationModel)
    @Delete
    suspend fun deleteUserInformation(userInformation:
        UserInformationModel)
}</pre>
<ol>
<li value="7">Now that we have our entity and DAO, we will finally create the <code>Database</code> class, which extends <code>RoomDatabase()</code>. In this class, we will use the <code>@Database</code> annotation, pass<a id="_idIndexMarker407"/> in the entity that we created, which is the <code>UserInformation</code> entity, and give our database a version name, which currently is <code>one</code>. We will also specify whether our database schema should be exported or not. So, let’s go ahead and create the <code>Database</code> abstract class:<pre class="source-code">
@Database(entities = [UserInformation::class], version = 1, exportSchema = false)</pre><pre class="source-code">
abstract class UserInformationDatabase : RoomDatabase() {</pre><pre class="source-code">
    abstract fun userInformationDao():</pre><pre class="source-code">
        UserInformationDao</pre><pre class="source-code">
}</pre></li>
<li>Finally, we have <code>Room</code> set up and ready. Now, we need to add Dependency Injection and our user interface; you can find the code in the <em class="italic">Technical requirements</em> section. Also, the UI is quite basic at this stage; you can make it a challenge to improve it, as this sample project is just for demonstration purposes.</li>
</ol>
<div><div><img alt="Figure 6.1 – The﻿ app's UI" src="img/Figure_6.1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The<a id="_idTextAnchor289"/> app's UI</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor290"/>How it works…</h2>
<p>The Modern Android Development<a id="_idIndexMarker408"/> Room library has three significant components of the Room database:</p>
<ul>
<li>The entity</li>
<li>The DAO</li>
<li>The database</li>
</ul>
<p><code>Entity</code> is a table within the database. Room generates a table for each class that has the <code>@Entity</code> annotation; if you have used Java before, you can think of the entity as a <strong class="bold">plain old Java object</strong> (<strong class="bold">POJO</strong>). The entity<a id="_idIndexMarker409"/> classes tend to be minor, don’t contain any logic, and only hold the data type for the object.</p>
<p>Some significant annotations that map the tables in the database are the foreign keys, indices, primary keys, and table names. There are other essential annotations, such as <code>ColumnInfo</code>, which gives column information, and <code>Ignore</code>, which, if used, whichever data you wish to ignore will not be persisted by Room.</p>
<div><div><img alt="Figure 6.2 – Room DAO" src="img/Figure_6.2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Room DAO</p>
<p><code>@DAO</code> defines the functions<a id="_idIndexMarker410"/> that access the database. Think of it like CRUD; if you used SQLite before Room, this is similar to using the cursor objects. Finally, <code>@Database</code> contains the database functions and serves as the main entry point for any underlying connection to our application’s relational data.</p>
<p>If you need to use this, you annotate with <code>@Database</code>, as we did in our database class. In addition, this class extends <code>RoomDatabase</code> and includes the list of entities we create. It also contains the abstract method that we create, has no arguments, and returns the class that we annotated with <code>@Dao</code>. We run the database by calling <code>Room.databaseB<a id="_idTextAnchor291"/>uilder()</code>.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor292"/>Implementing Dependency Injection in Room</h1>
<p>As with other recipes, Dependency<a id="_idIndexMarker411"/> Injection is vital, and in this recipe, we will <a id="_idIndexMarker412"/>walk through how we can inject our <code>DatabaseModule</code> and provide the Room database where it<a id="_idTextAnchor293"/> is needed.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor294"/>Getting ready</h2>
<p>You will need to have prior knowledge of how Hilt works to be able to follow this recipe st<a id="_idTextAnchor295"/>ep by step.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor296"/>How to do it…</h2>
<p>Open the <code>RoomExample</code> project and add Hilt, which is what we will use for Dependency Injection. In <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and Using Hilt</em>, we covered <a id="_idIndexMarker413"/>Hilt, so we will not discuss it here but just show you how you<a id="_idIndexMarker414"/> can use it with Room:</p>
<ol>
<li>Open your project and add the necessary Hilt dependency. See <a href="B18827_03.xhtml#_idTextAnchor137"><em class="italic">Chapter 3</em></a>, <em class="italic">Handling the UI State in Jetpack Compose and Using Hilt</em>, if you need help setting up Hilt or visit <a href="https://dagger.dev/hilt/">https://dagger.dev/hilt/</a>.</li>
<li>Next, let’s go ahead and add our <code>@HiltAndroidApp</code> class, and in the <code>Manifest</code> folder, add the name of our <code>HiltAndroidApp</code>, in our case, <code>UserInformation</code>:<pre class="source-code">
@HiltAndroidApp</pre><pre class="source-code">
class UserInformation : Application()</pre><pre class="source-code">
&lt;application</pre><pre class="source-code">
    android:allowBackup="true"</pre><pre class="source-code">
    android:name=".UserInformation"</pre><pre class="source-code">
    tools:targetApi="33"&gt;</pre><pre class="source-code">
...</pre></li>
<li>Now that we have Dependency Injection, let’s go ahead and add <code>@AndroidEntryPoint</code> in the <code>MainActivity</code> class, and in our project, let’s create a new package and call it <code>di</code>. Inside, we will create a new class, <code>DatabaseModule</code>, and add our functionalities.</li>
<li>In <code>DatabaseModule</code>, let’s go ahead and create a <code>provideDatabase()</code> function, where we will<a id="_idIndexMarker415"/> return the <code>Room</code> object, add the<a id="_idIndexMarker416"/> database name, and ensure we build our database:<pre class="source-code">
@Module</pre><pre class="source-code">
@InstallIn(SingletonComponent::class)</pre><pre class="source-code">
class DataBaseModule {</pre><pre class="source-code">
    @Singleton</pre><pre class="source-code">
    @Provides</pre><pre class="source-code">
    fun provideDatabase(@ApplicationContext context:</pre><pre class="source-code">
    Context): UserInformationDatabase {</pre><pre class="source-code">
        return Room.databaseBuilder(</pre><pre class="source-code">
            context,</pre><pre class="source-code">
            UserInformationDatabase::class.java,</pre><pre class="source-code">
            "user_information.db"</pre><pre class="source-code">
        ).build()</pre><pre class="source-code">
    }</pre><pre class="source-code">
    @Singleton</pre><pre class="source-code">
    @Provides</pre><pre class="source-code">
    fun provideUserInformationDao(</pre><pre class="source-code">
    userInformationDatabase: UserInformationDatabase):</pre><pre class="source-code">
    UserInformationDao {</pre><pre class="source-code">
        return</pre><pre class="source-code">
          userInformationDatabase.userInformationDao()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now that we have our Dependency Injection database module set up, we can now start adding the service, which are functions<a id="_idIndexMarker417"/> that will help us add user<a id="_idIndexMarker418"/> information to the database and get user information from the database. So, let us go ahead and create a new package called <code>service</code>. Inside the package, create a new interface, <code>UserInfoService</code>, and add the two aforementioned functions:<pre class="source-code">
interface UserInfoService {</pre><pre class="source-code">
    fun getUserInformationFromDB():</pre><pre class="source-code">
        Flow&lt;UserInformation&gt;</pre><pre class="source-code">
    suspend fun addUserInformationInDB(</pre><pre class="source-code">
        userInformation: UserInformation)</pre><pre class="source-code">
}</pre></li>
<li>Since <code>UserInfoService</code> is an interface, we will need to implement the functionalities in our <code>Impl</code> class, so let us now go ahead and create a new class called <code>UserInfoServiceImpl</code> and a singleton class, and then implement the interface:<pre class="source-code">
@Singleton</pre><pre class="source-code">
class UserInfoServiceImpl() : UserInfoService {</pre><pre class="source-code">
    override fun getUserInformationFromDB():</pre><pre class="source-code">
        Flow&lt;UserInformation&gt; {</pre><pre class="source-code">
            TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
    override suspend fun addUserInformationInDB(</pre><pre class="source-code">
        userInformation: UserInformation) {</pre><pre class="source-code">
            TODO("Not yet implemented")</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>We will need to inject our <a id="_idIndexMarker419"/>constructor and pass <code>UserInformationDao()</code>, since we will use the insert<a id="_idIndexMarker420"/> function to insert the user data:<pre class="source-code">
class UserInfoServiceImpl @Inject constructor(</pre><pre class="source-code">
private val userInformationDao: UserInformationDao</pre><pre class="source-code">
): UserInfoService</pre></li>
<li>Now, we need to add code in our functions that have the TODO in them. Let’s go ahead and see the user information first. Using <code>userInformationDao</code>, we will call the insert function to tell Room that we want to insert this user information:<pre class="source-code">
override suspend fun addUserInformationInDB(</pre><pre class="source-code">
userInformation: UserInformation) {</pre><pre class="source-code">
    userInformationDao.insertUserInformation(</pre><pre class="source-code">
        UserInformation(</pre><pre class="source-code">
            firstName = userInformation.firstName,</pre><pre class="source-code">
            lastName = userInformation.lastName,</pre><pre class="source-code">
            dateOfBirth = userInformation.dateOfBirth,</pre><pre class="source-code">
            gender = userInformation.gender,</pre><pre class="source-code">
            city = userInformation.city,</pre><pre class="source-code">
            profession = userInformation.profession</pre><pre class="source-code">
        )</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>Then, we need to <a id="_idIndexMarker421"/>get the user information from the database; this will visualize a user’s data <a id="_idIndexMarker422"/>on the screen:<pre class="source-code">
override fun getUserInformationFromDB() =</pre><pre class="source-code">
    userInformationDao.getUsersInformation().filter {</pre><pre class="source-code">
        information -&gt; information.isNotEmpty()</pre><pre class="source-code">
    }.flatMapConcat {</pre><pre class="source-code">
        userInformationDao.loadAllUserInformation()</pre><pre class="source-code">
            .map { userInfo -&gt;</pre><pre class="source-code">
                UserInfo(</pre><pre class="source-code">
                    id = userInfo.id,</pre><pre class="source-code">
                    firstName = userInfo.firstName,</pre><pre class="source-code">
                    lastName = userInfo.lastName,</pre><pre class="source-code">
                    dateOfBirth =</pre><pre class="source-code">
                        userInfo.dateOfBirth,</pre><pre class="source-code">
                    gender = userInfo.gender,</pre><pre class="source-code">
                    city = userInfo.city,</pre><pre class="source-code">
                    profession = userInfo.profession</pre><pre class="source-code">
                )</pre><pre class="source-code">
            }</pre><pre class="source-code">
    }</pre></li>
<li>Finally, we need to ensure that we provide the implementation through Dependency Injection, so<a id="_idIndexMarker423"/> let’s now go ahead and add the<a id="_idIndexMarker424"/> preceding code, then clean the project, run it, and ensure that everything works as expected:<pre class="source-code">
@Module</pre><pre class="source-code">
@InstallIn(SingletonComponent::class)</pre><pre class="source-code">
abstract class UserInfoServiceModule {</pre><pre class="source-code">
    @Singleton</pre><pre class="source-code">
    @Binds</pre><pre class="source-code">
    abstract fun bindUserService(</pre><pre class="source-code">
        userInfoServiceImpl: UserInfoServiceImpl):</pre><pre class="source-code">
            UserInfoService</pre><pre class="source-code">
}</pre></li>
<li>Once you run the project, you should be able to see it launch without issue. We will go ahead and add a function in our <code>ViewModel</code> to insert the data in our database; the <code>ViewModel</code> will be used in the views that we created:<pre class="source-code">
@HiltViewModel</pre><pre class="source-code">
class UserInfoViewModel @Inject constructor(</pre><pre class="source-code">
    private val userInfoService: UserInfoService</pre><pre class="source-code">
) : ViewModel() {</pre><pre class="source-code">
    fun saveUserInformationData(userInfo: UserInfo) {</pre><pre class="source-code">
        viewModelScope.launch {</pre><pre class="source-code">
            userInfoService.addUserInformationInDB(</pre><pre class="source-code">
                userInfo)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>We can now inspect the <a id="_idIndexMarker425"/>database and see whether<a id="_idIndexMarker426"/> it was created correctly. Run the app, and once it’s ready in the IDE, click <strong class="bold">App Inspection</strong>, as shown in <em class="italic">Figure 6</em><em class="italic">.3</em>. You should be able to open the Database Inspector.</li>
</ol>
<div><div><img alt="Figure 6.3 – App Inspection" src="img/Figure_6.3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – App Inspection</p>
<ol>
<li value="13">Once the Database Inspector is loaded, you should be able to select the currently running Android Emulator, as shown in <em class="italic">Figure 6</em><em class="italic">.4</em>:</li>
</ol>
<div><div><img alt="Figure 6.4 – The selected app for app inspection" src="img/Figure_6.4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The selected app for app inspection</p>
<ol>
<li value="14">In <em class="italic">Figure 6</em><em class="italic">.5</em>, you can see the Database Inspector open and our database.</li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 6.5 – Our user_information database" src="img/Figure_6.5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Our user_information database</p>
<ol>
<li value="15">In <em class="italic">Figure 6</em><em class="italic">.6</em>, you can<a id="_idIndexMarker427"/> see that the data we inserted is<a id="_idIndexMarker428"/> displayed, which means our insert function works as expected.</li>
</ol>
<div><div><img alt="Fi﻿gure 6.6 – Our database" src="img/Figure_6.6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fi<a id="_idTextAnchor297"/>gure 6.6 – Our database</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor298"/>How it works…</h2>
<p>In this recipe, we opted to use Dependency Injection to supply the needed dependencies to specific classes. We covered in <a id="_idIndexMarker429"/>depth what Dependency Injection is<a id="_idIndexMarker430"/> in previous chapters, so we will not explain it again in this recipe but, instead, talk about the modules we created.</p>
<p>We used the <code>@Singleton</code> annotation in Hilt to indicate that <code>provideDatabase</code>, which provides an instance of Room, should be created only once during the lifetime of our application, and that this instance should be shared across all the components that depend on it. In addition, when you annotate a class or a binding method with <code>@Singleton</code>, Hilt ensures that only one instance of that class or object is created and all the components that need that object will receive the same instance.</p>
<p>It’s important to also know that when we use <code>@Singleton</code> in Hilt, it is not the same as the Singleton pattern in software design, which can easily be a source of confusion. Hilt’s <code>@Singleton</code> only guarantees that one instance of a class will be created within the context of a particular component hierarchy.</p>
<p>In our project, we created <code>DatabaseModule()</code> and <code>UserInfoServiceModule()</code>. In the <code>DatabaseModule()</code> class, we have two functions, <code>provideDatabase</code> and <code>provideUserInformationDao</code>. The first function, <code>provideDatabase</code>, returns the <code>UserInformationDatabase</code> Room instance, where we get to create the database and build it:</p>
<pre class="source-code">
fun provideDatabase(@ApplicationContext context: Context): UserInformationDatabase {
    return Room
        .databaseBuilder(context,
            UserInformationDatabase::class.java,
            "user_information.db")
        .build()
}</pre>
<p>In <code>provideUserInformationDao</code>, we pass <code>UserInformationDatabase</code> in the constructor and<a id="_idIndexMarker431"/> return the <code>UserInformationDao</code> abstract class:</p>
<pre class="source-code">
fun provideUserInformationDao(userInformationDatabase: UserInformationDatabase): UserInformationDao {
    return userInformationDatabase.userInformationDao()
}</pre>
<p class="callout-heading">Important note</p>
<p class="callout">If you want to lose existing<a id="_idIndexMarker432"/> data when you are migrating or if your migration path is missing, you can use the <code>.fallbackToDestructiveMigration()</code> function <a id="_idTextAnchor299"/>when creating the database.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor300"/>See also</h2>
<p>There is more to learn in Room, and this recipe has only given you a brief overview of what you can do with it. You can learn more by following the link at <a href="https://developer.android.com/reference/androidx/room/package-summary">https://developer.android.com/reference/androidx/room/package-summary</a>.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor301"/>Supporting multiple entities in Room</h1>
<p>In this recipe, you will learn <a id="_idIndexMarker433"/>how to handle multiple entities in Room. This is useful whenever you have a big project that needs a different data input. An excellent example that we can work with is a budgeting app.</p>
<p>To support multiple entities in Room, you need to define multiple classes that represent your database tables. Each class should have its own annotations and fields that correspond to columns in a table. For instance, a budgeting app might need different types of models, such as the following:</p>
<ul>
<li><code>BudgetData</code></li>
<li><code>ExpenseData</code></li>
<li><code>ExpenseItem</code></li>
</ul>
<p>Hence, having multiple entities is sometimes necessary, and knowing how to<a id="_idTextAnchor302"/> handle that comes in handy.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor303"/>Getting ready</h2>
<p>To follow along with this recipe, you must have completed the previous recipe.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor304"/>How to do it …</h2>
<p>You can use any project of your choosing to implement the topics discussed in this recipe. In addition, you can use this example in your pre-existing project to implement the topic.</p>
<ol>
<li>In <code>RoomExample</code>, you can<a id="_idIndexMarker434"/> add more functionality to the app and try to add more entities, but for this project, let’s go ahead and show how you can handle multiple entities in Room.</li>
<li>For this example, we will use the sample budgeting App we introduced in an earlier chapter, and since we are working with entities, this will be easier to follow. Let’s create a new entity and call it <code>BudgetData</code>; the budget data class might have several fields, such as <code>budgetName</code>, <code>budgetAmount</code>, <code>expenses</code>, <code>startDate</code>, <code>endDate</code>, <code>notify</code>, <code>currency</code>, and <code>totalExpenses</code>; hence, our <code>BudgetData</code> data class will look like this:<pre class="source-code">
@Entity(tableName = "budgets")</pre><pre class="source-code">
data class BudgetData(</pre><pre class="source-code">
    @PrimaryKey(autoGenerate = true)</pre><pre class="source-code">
    var id: Int = 0,</pre><pre class="source-code">
    var budgetName: String = "",</pre><pre class="source-code">
    var budgetAmount: Double = 0.0,</pre><pre class="source-code">
    var expenses: String = "",</pre><pre class="source-code">
    var startDate: String = "",</pre><pre class="source-code">
    var endDate: String = "",</pre><pre class="source-code">
    var notify: Int = 0,</pre><pre class="source-code">
    var currency: String = "",</pre><pre class="source-code">
    var totalExpenses: Double</pre><pre class="source-code">
)</pre></li>
<li>Let’s go ahead and add <a id="_idIndexMarker435"/>two more entities. First, we will add <code>ExpenseData</code>, which might have the following fields and types:<pre class="source-code">
@Entity(tableName = "expenses")</pre><pre class="source-code">
data class ExpenseData(</pre><pre class="source-code">
    @PrimaryKey(autoGenerate = true)</pre><pre class="source-code">
    var id: Int = 0,</pre><pre class="source-code">
    var expenseName: String = "",</pre><pre class="source-code">
    var expenseType: String = "",</pre><pre class="source-code">
    var expenseAmount: Double = 0.0,</pre><pre class="source-code">
    @ColumnInfo(name = "updated_at")</pre><pre class="source-code">
    var expenseDate: String = "",</pre><pre class="source-code">
    var note: String = "",</pre><pre class="source-code">
    var currency: String = ""</pre><pre class="source-code">
)</pre></li>
<li>Then, let’s add <code>ExpenseItem</code>, which might consist of the following fields:<pre class="source-code">
@Entity(tableName = "items")</pre><pre class="source-code">
Data class ExpenseItem(</pre><pre class="source-code">
    @PrimaryKey(autoGenerate = true)</pre><pre class="source-code">
    private var _id: Int</pre><pre class="source-code">
    val name: String</pre><pre class="source-code">
    var type: String?</pre><pre class="source-code">
    val imageContentId: Int</pre><pre class="source-code">
    val colorContentId: Int)</pre></li>
<li>As you can see, we have<a id="_idIndexMarker436"/> three entities; based on these entities, you should create different DAOs for each one:<pre class="source-code">
abstract class AppDatabase : RoomDatabase() {</pre><pre class="source-code">
    abstract fun budgetDao(): BudgetDao</pre><pre class="source-code">
    abstract fun itemDao(): ItemDao</pre><pre class="source-code">
    abstract fun expenseDao(): ExpenseDao</pre><pre class="source-code">
}</pre></li>
<li>At the top of the <code>AppDatabase</code> abstract class, we will annotate it with <code>@Database</code> and then pass it to all our entities:<pre class="source-code">
@Database(</pre><pre class="source-code">
    entities = [ExpenseItem::class, BudgetData::class,</pre><pre class="source-code">
        ExpenseData::class],</pre><pre class="source-code">
    version = 1</pre><pre class="source-code">
)</pre><pre class="source-code">
@TypeConverters(DateConverter::class)</pre><pre class="source-code">
abstract class AppDatabase : RoomDatabase() {</pre><pre class="source-code">
    abstract fun budgetDao(): BudgetDao</pre><pre class="source-code">
    abstract fun itemDao(): ItemDao</pre><pre class="source-code">
    abstract fun expenseDao(): ExpenseDao</pre><pre class="source-code">
}</pre></li>
<li>You can also use embedded objects; the <code>@Embedded</code> annotation includes nested or related entities within an entity. It allows you to represent the relationship between <a id="_idIndexMarker437"/>entities by embedding one or more related entities in the parent entity:<pre class="source-code">
data class ExpenseItem(</pre><pre class="source-code">
...</pre><pre class="source-code">
    @Embedded val tasks: Tasks</pre><pre class="source-code">
  )</pre><pre class="source-code">
data class Tasks(...)</pre></li>
</ol>
<p>In our preceding example, we have annotated the tasks property in the <code>ExpenseItem</code> entity with the <code>@Embedded</code> annotation. This tells Room to include the fields of the <code>Tasks</code> data class within the <code>ExpenseItem</code> table, rather than creating a separate table for our <code>ExpenseItem</code> entity.</p>
<ol>
<li value="8">Then, the Tasks data class can have the <code>description</code>, <code>priority</code>, <code>updatedAt</code>, and ID:<pre class="source-code">
data class Tasks (</pre><pre class="source-code">
    @PrimaryKey(autoGenerate = true)</pre><pre class="source-code">
    var id = 0</pre><pre class="source-code">
    var description: String</pre><pre class="source-code">
    var priority: Int</pre><pre class="source-code">
    @ColumnInfo(name = "updated_at")</pre><pre class="source-code">
    var updatedAt: Date)</pre></li>
</ol>
<p>Hence, the table representing the <code>ExpenseItem</code> object will contain additional columns with the newly added fields.</p>
<p>That’s it; once you declare the entities in the database and pass them as required, you will have supported multiples<a id="_idIndexMarker438"/> entities in your <code>Database</code>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If your entity has multiple embedded fields of the same type, you can keep each column unique by setting the <code>Prefix</code> property; then, Room will add the provided values to the beginning of each column name in the embedded object. Find out more at <a href="https://developer.android.com/">https://developer.android.com/</a>.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor305"/>How it works…</h2>
<p>According to the rules in Room, you can define an entity relationship in three different ways.</p>
<ul>
<li>One-to-many relationships or many-to-one relationships</li>
<li>One-to-one relationships</li>
<li>Many-to-many relationships</li>
</ul>
<p>As you have already seen, using entities in one class makes it manageable and easily trackable; hence, this is an excellent solution for Android engineers. A notable annotation is <code>@Relation</code>, which specifies where you create an object that shows the relationship between your entities.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor306"/>There’s more...</h2>
<p>There is more to learn in Room – for instance, defining relationships between objects, writing asynchronous data accessible object queries, and referencing complex data. It is fair to say we cannot cover everything in just one chapter but offer some guidance to help you navigate building Modern Android applications. For more on Room, visit <a href="https://developer.android.com/training/data-storage/room">https://developer.android.com/training/data-storage/room</a>.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor307"/>Migrating an existing SQL database to room</h1>
<p>As we mentioned earlier, Room does <a id="_idIndexMarker439"/>harness the power of SQLite, and because many applications still use legacy, you might find applications still using SQL and be wondering how you can migrate to Room and utilize the latest Room features.</p>
<p>In this recipe, we will cover the migration of an existing SQL database to Room with step-by-step examples. Furthermore, Room offers an abstraction layer to help with SQLite migrations – that is, by offering <a id="_idTextAnchor308"/>the <code>Migration</code> class to developers.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor309"/>How to do it…</h2>
<p>Because we did not create a new SQLite database example, since that is not necessary, we will try to emulate a scenario with a dummy sample SQLite database and showcase how you can migrate your existing SQLite database to Room:</p>
<ol>
<li>Since we will be adding Room in an existing SQLite project, you will need to ensure you add the required dependencies. To set this up, refer to the <em class="italic">Implementing Room in your </em><em class="italic">applications</em> recipe.</li>
<li>Next, you will need to go ahead and create a new DAO and entity, since Room requires it. Hence, in this set following the first Room recipe, you can update the model classes to entities. This is pretty straightforward, since mostly what you will do is annotate the classes with <code>@Entity</code> and use the table <code>Names</code> property to set the name of the table.</li>
<li>You must also add <code>@PrimaryKey</code> and <code>@ColumnInfo</code> annotations for your entity classes. Here is a sample SQLite database:<pre class="source-code">
fun onCreate(db: SQLiteDatabase) {</pre><pre class="source-code">
    // Create a String that contains the SQL statement</pre><pre class="source-code">
       to create the items table</pre><pre class="source-code">
    val SQL_CREATE_ITEMS_TABLE =(</pre><pre class="source-code">
            "CREATE TABLE " + ItemsContract.ItemsEntry</pre><pre class="source-code">
                     .TABLE_NAME.toString() + " ("</pre><pre class="source-code">
                     + ItemsContract.ItemsEntry.</pre><pre class="source-code">
                     _Id.toString()</pre><pre class="source-code">
                     + " INTEGER PRIMARY KEY</pre><pre class="source-code">
                     AUTOINCREMENT, "</pre><pre class="source-code">
                     + ItemsContract.ItemsEntry</pre><pre class="source-code">
                     .COLUMN_ITEM_NAME.toString()</pre><pre class="source-code">
                     + " TEXT NOT NULL, "</pre><pre class="source-code">
                     + ItemsContract.ItemsEntry</pre><pre class="source-code">
                     .COLUMN_ITEM_TYPE.toString()</pre><pre class="source-code">
                     + " TEXT NOT NULL, "</pre><pre class="source-code">
                     + ItemsContract.ItemsEntry</pre><pre class="source-code">
                     .COLUMN_ITEM_LOGO.toString()</pre><pre class="source-code">
                     + " INTEGER NOT NULL DEFAULT 0, "</pre><pre class="source-code">
                     + ItemsContract.ItemsEntry</pre><pre class="source-code">
                     .COLUMN_ITEM_COLOR.toString()</pre><pre class="source-code">
                     + " INTEGER NOT NULL DEFAULT 0, "</pre><pre class="source-code">
                     + ItemsContract.ItemsEntry</pre><pre class="source-code">
                     .COLUMN_ITEM_CREATED_DATE</pre><pre class="source-code">
                     .toString() + " DATE NOT NULL</pre><pre class="source-code">
                     DEFAULT CURRENT_TIMESTAMP);")</pre><pre class="source-code">
    // Execute the SQL statement</pre><pre class="source-code">
    db.execSQL(SQL_CREATE_ITEMS_TABLE)</pre><pre class="source-code">
}</pre></li>
</ol>
<p>However, Room has simplified the process, and we no longer need to create <code>Contracts</code>. <code>Contracts</code> in Android are a way for developers to define and enforce a set of rules for accessing data within an application. These contracts typically define the structure and schema of the database tables and the expected data types and formats for the data within them. In the case of SQLite on Android, contracts are <a id="_idIndexMarker440"/>often used to define the tables and columns of the database, as well as any constraints or relationships between them.</p>
<ol>
<li value="4">Once we have created all our needed entities and DAOs, we can go ahead and create the database. As we saw in the <em class="italic">Implementing Room in your Applications</em> recipe, we can add all our entities in the <code>@Database</code> annotation, and since we are in the first <code>(1)</code> version, we can increment the version to (<code>2)</code>:<pre class="source-code">
val MIGRATION_1_2 = object : Migration(1, 2) {</pre><pre class="source-code">
    override fun migrate(database:</pre><pre class="source-code">
    SupportSQLiteDatabase) {</pre><pre class="source-code">
        //alter items table</pre><pre class="source-code">
        database.execSQL("CREATE TABLE new_items (_id</pre><pre class="source-code">
            INTEGER PRIMARY KEY AUTOINCREMENT NOT</pre><pre class="source-code">
            NULL, name TEXT NOT NULL, type TEXT,</pre><pre class="source-code">
            imageContentId INTEGER NOT NULL,</pre><pre class="source-code">
            colorContentId INTEGER NOT NULL)")</pre><pre class="source-code">
        database.execSQL("INSERT INTO new_items</pre><pre class="source-code">
            (_id,name,type,imageContentId,</pre><pre class="source-code">
            colorContentId)Select_id,name,type,</pre><pre class="source-code">
            imageContentId, colorContentId FROM</pre><pre class="source-code">
            items")</pre><pre class="source-code">
        database.execSQL("DROP TABLE items")</pre><pre class="source-code">
        database.execSQL("ALTER TABLE new_items RENAME</pre><pre class="source-code">
            TO items")</pre><pre class="source-code">
    }</pre></li>
<li>Then, the important part is<a id="_idIndexMarker441"/> ensuring we call <code>build()</code> to the Room database:<pre class="source-code">
Room.databaseBuilder(</pre><pre class="source-code">
    androidContext(),</pre><pre class="source-code">
    AppDatabase::class.java, "budget.db"</pre><pre class="source-code">
)</pre><pre class="source-code">
    .addCallback(object : RoomDatabase.Callback() {</pre><pre class="source-code">
        override fun</pre><pre class="source-code">
        onCreate(db:SupportSQLiteDatabase){</pre><pre class="source-code">
            super.onCreate(db)</pre><pre class="source-code">
        }</pre><pre class="source-code">
    })</pre><pre class="source-code">
    .addMigrations(MIGRATION_1_2)</pre><pre class="source-code">
    .build()</pre></li>
<li>Once your data layer starts using Room, you can officially replace all the <code>Cursor</code> and <code>ContentValue</code> code with the DAO calls. In our <code>AppDatabase</code> class, we have our entities, and our class extends <code>RoomDatabase()</code>:<pre class="source-code">
@Database(</pre><pre class="source-code">
    entities = [&lt;List of entities&gt;],</pre><pre class="source-code">
    version = 2</pre><pre class="source-code">
)</pre><pre class="source-code">
abstract class AppDatabase : RoomDatabase() {</pre><pre class="source-code">
    abstract fun itemDao(): ItemDao</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Because Room offers runtime errors, if any error occurs, you will be notified in Logcat.</p>
<ol>
<li value="7">It is fair to say that not<a id="_idIndexMarker442"/> everything can be covered in one recipe because SQLite does require a lot of code to set up – for instance, to create queries and handle the cursors – but Room helps to speed these processes up, w<a id="_idTextAnchor310"/>hich is why it is highly recommended.</li>
</ol>
<h2 id="_idParaDest-177"><a id="_idTextAnchor311"/>How it works…</h2>
<p>As recommended earlier, migrating a complex database might be hectic and require caution, since it can affect users if pushed to production without thorough testing. It is also highly recommended to use <code>OpenHelper</code>, exposed by <code>RoomDatabase</code>, for more straightforward or minimal changes to your database. Furthermore, it is worth mentioning that if you have any legacy code using SQLite, it will be written at a high level in Java, so working with a team to find a better solution for the migration is needed.</p>
<p>In your project, you must update the class that extends <code>SQLiteOpenHelper</code>. We use <code>SupportSQLiteDatabase</code> because we need to update the calls to get the writable and readable database. This is a cleaner database abstraction class to insert and query the database.</p>
<p class="callout-heading">Important note</p>
<p class="callout">It is important to <a id="_idIndexMarker443"/>note that it might be complicated to migrate to a complex database that has many tables and complex queries. However, if your database has minimal tables and no complex queries, migration can be done quickly with relatively small incremental changes in a feature branch. It might be helpful to download the app’s database, and you can do so by visiting the following link: <a href="https://developer.android.com/training/data-storage/room/testing-db#command-line">https://developer.android.com/training/data-storage/room/testing-db#command-line</a>.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor313"/>Testing your local database</h1>
<p>So far, we have ensured that we <a id="_idIndexMarker444"/>write tests whenever necessary for our projects. We will now need to go ahead and write tests for our <code>RoomExample</code> project, since this is crucial, and you might be required to do so in a real-world scenario. Hence, in this recipe, we will look at a step-by-step guide <a id="_idTextAnchor314"/>on writing CRUD tests for our database.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor315"/>Getting ready</h2>
<p>You will need to open the <code>RoomExample</code> p<a id="_idTextAnchor316"/>roject to get started with this recipe.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor317"/>How to do it…</h2>
<p>Let’s go ahead and first add all the needed Room testing dependencies, and then start writing our tests. For the Hilt test setup, refer to the <em class="italic">Technical requirements</em> section, where you can find all the required code:</p>
<ol>
<li>You will need to add the following to your <code>build.gradle</code>:<pre class="source-code">
androidTestImplementation "com.google.truth:truth:1.1.3"</pre><pre class="source-code">
androidTestImplementation "android.arch.core:core-testing:1.1.1"</pre></li>
<li>After you have added the required dependencies inside the Android test, go ahead and create a new class, calling it <code>UserInformationDBTest</code>:<pre class="source-code">
class UserInformationDBTest {...}</pre></li>
<li>Before we can set up our <code>@Before</code> function, we will need to create two <code>lateinit var</code> instances, which we will initialize in our <code>@</code><code>Before</code> function:<pre class="source-code">
private lateinit var database: UserInformationDatabase</pre><pre class="source-code">
private lateinit var userInformationDao: UserInformationDao</pre></li>
<li>Now, let us go ahead and set up our <code>@Before</code> function and create our database, using<a id="_idIndexMarker445"/> the in-memory database for testing purposes:<pre class="source-code">
@Before</pre><pre class="source-code">
fun databaseCreated() {</pre><pre class="source-code">
    database = Room.inMemoryDatabaseBuilder(</pre><pre class="source-code">
        ApplicationProvider.getApplicationContext(),</pre><pre class="source-code">
            UserInformationDatabase::class.java</pre><pre class="source-code">
    )</pre><pre class="source-code">
        .allowMainThreadQueries()</pre><pre class="source-code">
        .build()</pre><pre class="source-code">
    userInformationDao = database.userInformationDao()</pre><pre class="source-code">
}</pre></li>
<li>Since we are running and creating the database in memory, we will need to close it after it is done; hence, in our <code>@After</code> call, we will need to call <code>close()</code> on our database:<pre class="source-code">
@After</pre><pre class="source-code">
fun closeDatabase() {</pre><pre class="source-code">
    database.close()</pre><pre class="source-code">
}</pre></li>
<li>Now that our setup is <a id="_idIndexMarker446"/>complete, we will go ahead and start testing our CRUD – that is, inserting, deleting, and updating. Let’s go ahead and create an insert test first:<pre class="source-code">
@Test</pre><pre class="source-code">
fun insertUserInformationReturnsTrue() = runBlocking {</pre><pre class="source-code">
    val userOne = UserInformationModel(</pre><pre class="source-code">
        id = 1,</pre><pre class="source-code">
        firstName = "Michelle",</pre><pre class="source-code">
        lastName = "Smith",</pre><pre class="source-code">
        dateOfBirth = 9121990,</pre><pre class="source-code">
        gender = "Male",</pre><pre class="source-code">
        city = "New york",</pre><pre class="source-code">
        profession = "Software Engineer"</pre><pre class="source-code">
    )</pre><pre class="source-code">
    userInformationDao.insertUserInformation(userOne)</pre><pre class="source-code">
    val latch = CountDownLatch(1)</pre><pre class="source-code">
    val job = async(Dispatchers.IO) {</pre><pre class="source-code">
        userInformationDao.getUsersInformation()</pre><pre class="source-code">
            .collect {</pre><pre class="source-code">
                assertThat(it).contains(userOne)</pre><pre class="source-code">
                latch.countDown()</pre><pre class="source-code">
            }</pre><pre class="source-code">
    }</pre><pre class="source-code">
    latch.await()</pre><pre class="source-code">
    job.cancelAndJoin()</pre><pre class="source-code">
}</pre></li>
<li>Finally, let us <a id="_idIndexMarker447"/>add the <code>delete</code> function, and that will wrap up our testing Room for now:<pre class="source-code">
@Test</pre><pre class="source-code">
fun deleteUserInformation() = runBlocking {</pre><pre class="source-code">
    val userOne = UserInformationModel(</pre><pre class="source-code">
        id = 1,</pre><pre class="source-code">
        firstName = "Michelle",</pre><pre class="source-code">
        lastName = "Smith",</pre><pre class="source-code">
        dateOfBirth = 9121990,</pre><pre class="source-code">
        gender = "Male",</pre><pre class="source-code">
        city = "New york",</pre><pre class="source-code">
        profession = "Software Engineer"</pre><pre class="source-code">
    )</pre><pre class="source-code">
    val userTwo = UserInformationModel(</pre><pre class="source-code">
        id = 2,</pre><pre class="source-code">
        firstName = "Mary",</pre><pre class="source-code">
        lastName = "Simba",</pre><pre class="source-code">
        dateOfBirth = 9121989,</pre><pre class="source-code">
        gender = "Female",</pre><pre class="source-code">
        city = "New york",</pre><pre class="source-code">
        profession = "Senior Android Engineer"</pre><pre class="source-code">
    )</pre><pre class="source-code">
    userInformationDao.insertUserInformation(userOne)</pre><pre class="source-code">
    userInformationDao.insertUserInformation(userTwo)</pre><pre class="source-code">
    userInformationDao.deleteUserInformation(userTwo)</pre><pre class="source-code">
    val latch = CountDownLatch(1)</pre><pre class="source-code">
    val job = async(Dispatchers.IO) {</pre><pre class="source-code">
        userInformationDao.loadAllUserInformation()</pre><pre class="source-code">
            .collect {</pre><pre class="source-code">
                assertThat(it).doesNotContain(userTwo)</pre><pre class="source-code">
                latch.countDown()</pre><pre class="source-code">
            }</pre><pre class="source-code">
    }</pre><pre class="source-code">
    latch.await()</pre><pre class="source-code">
    job.cancelAndJoin()</pre><pre class="source-code">
}</pre></li>
<li>When you run<a id="_idIndexMarker448"/> the test, they should all pass with a green ch<a id="_idTextAnchor318"/>eck mark:</li>
</ol>
<div><div><img alt="Figure 6.7 – Our tests passing" src="img/Figure_6.7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Our tests passing</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor319"/>How it works…</h2>
<p>You might have noticed<a id="_idIndexMarker449"/> we have used <code>Truth</code>, which is a testing framework that provides a fluent and expressive API to write assertions in tests. It is developed by Google, and some of the advantages of using <code>Truth</code> include readability, flexibility, and clear error messages. We can easily use a more like natural language constructs – for example, <code>isEqualTo</code> and <code>shouldBe</code> – which makes the test assertions more intuitive and readable for us developers.</p>
<p>When using the framework, you get a wide range of assertion methods that allow you to test a variety of conditions, including equality, order, and containment. It also allows you to define custom assertion methods, giving you more control over the behavior of your tests.</p>
<p>The <code>@Before</code> annotation ensures our <code>databaseCreated()</code> function is executed before each class. Our function then creates a database using <code>Room.inMemoryDatabaseBuilder</code>, which creates a database in <code>@After</code> call, we close the database:</p>
<pre class="source-code">
@After
fun closeDatabase() {
    database.close()
}</pre>
<p>As you might have seen, our tests are in <code>AndroidTest</code>, since we launch Room in the main thread and close it after we finish it. The test classes just test the DAO functions – that is, <code>Update</code>, <code>Insert</code>, <code>Delete</code>, and <code>Query</code>.</p>
</div>
</body></html>